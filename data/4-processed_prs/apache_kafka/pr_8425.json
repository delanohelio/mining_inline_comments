{"pr_number": 8425, "pr_title": "KAFKA-6145: KIP-441 Move tasks with caught-up destination clients right away", "pr_createdAt": "2020-04-04T04:04:28Z", "pr_url": "https://github.com/apache/kafka/pull/8425", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQyMTUxNg==", "url": "https://github.com/apache/kafka/pull/8425#discussion_r403421516", "bodyText": "This is just a side bug that StreamsPartitionAssignorTest caught, we need to pin the overflow here too", "author": "ableegoldman", "createdAt": "2020-04-04T04:06:51Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignor.java", "diffHunk": "@@ -792,7 +792,13 @@ private boolean populateClientStatesMap(final Map<UUID, ClientState> clientState\n                     log.debug(\"Fetched end offsets did not contain the changelog {} of task {}\", changelog, task);\n                     throw new IllegalStateException(\"Could not get end offset for \" + changelog);\n                 }\n-                taskEndOffsetSums.computeIfPresent(task, (id, curOffsetSum) -> curOffsetSum + offsetResult.offset());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQyMTU1Mg==", "url": "https://github.com/apache/kafka/pull/8425#discussion_r403421552", "bodyText": "Since we now need this in getMovements as well, I moved this for reusability", "author": "ableegoldman", "createdAt": "2020-04-04T04:07:18Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -101,28 +103,6 @@ private void checkClientsAndNumberOfStreamThreads(final Map<UUID, Integer> clien\n         return assignment;\n     }\n \n-    /**\n-     * Maps tasks to clients with caught-up states for the task.\n-     *\n-     * @param statefulTasksToRankedClients ranked clients map\n-     * @return map from tasks with caught-up clients to the list of client candidates\n-     */\n-    private Map<TaskId, List<UUID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<RankedClient>> statefulTasksToRankedClients) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ5ODY2Mw==", "url": "https://github.com/apache/kafka/pull/8425#discussion_r404498663", "bodyText": "There are no logical changes to this file, just factoring out the statefulTasksToRankedCandidates and supplying the tasksToCaughtUpClients as an additional input parameter", "author": "ableegoldman", "createdAt": "2020-04-07T02:23:38Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -41,6 +41,7 @@\n import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.UUID_1;\n import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.UUID_2;\n import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.UUID_3;\n+import static org.apache.kafka.streams.processor.internals.assignment.RankedClient.tasksToCaughtUpClients;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2NzY2NA==", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405067664", "bodyText": "Just out of curiosity, what is the motivation for adding this method and making a copy of the list?", "author": "vvcephei", "createdAt": "2020-04-07T19:45:18Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "diffHunk": "@@ -96,34 +139,46 @@ public void shouldReturnEmptyMovementsWhenPassedEmptyTaskAssignments() {\n             mkEntry(UUID_1, emptyList()),\n             mkEntry(UUID_2, emptyList())\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldReturnEmptyMovementsWhenPassedIdenticalTaskAssignments() {\n         final int maxWarmupReplicas = 2;\n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldThrowIllegalStateExceptionIfAssignmentsAreOfDifferentSize() {\n         final int maxWarmupReplicas = 2;\n \n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_0_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_0_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas));\n+        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas));\n+    }\n+\n+    private static List<TaskId> mkTaskList(final TaskId... tasks) {\n+        return new ArrayList<>(asList(tasks));\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1NDIyOQ==", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405154229", "bodyText": "If we just use asList then shouldImmediatelyMoveTasksWithCaughtUpDestinationClients will throw UnsupportedOperationException on AbstractList.remove", "author": "ableegoldman", "createdAt": "2020-04-07T22:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2NzY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1NDkwNw==", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405154907", "bodyText": "(because we actually move the task in the state constrained assignment)", "author": "ableegoldman", "createdAt": "2020-04-07T22:39:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2NzY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MjgwOQ==", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405742809", "bodyText": "Thanks.", "author": "vvcephei", "createdAt": "2020-04-08T18:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2NzY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1OTg1Nw==", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405559857", "bodyText": "req: My IDE says that this import is not needed. Since the imported method is in the same package, I agree with my IDE. Could you please remove it? Isn't strange that checkstyle did not find this?", "author": "cadonna", "createdAt": "2020-04-08T14:17:13Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -16,6 +16,8 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n+import static org.apache.kafka.streams.processor.internals.assignment.RankedClient.tasksToCaughtUpClients;\n+", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxODQwNA==", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405718404", "bodyText": "Good catch! It does seem weird that this slipped past checkstyle, although I've seen that happen before with an unused import I found on trunk. \ud83e\udd37\u200d\u2640", "author": "ableegoldman", "createdAt": "2020-04-08T18:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1OTg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MjQ2Mw==", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405562463", "bodyText": "req: Now that we can test this method. Could you please add unit tests for this method in RankedClientTest?", "author": "cadonna", "createdAt": "2020-04-08T14:20:39Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/RankedClient.java", "diffHunk": "@@ -78,6 +79,28 @@ public int hashCode() {\n         return Objects.hash(clientId, rank);\n     }\n \n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    static Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<RankedClient>> statefulTasksToRankedClients) {\n+        final Map<TaskId, SortedSet<UUID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<RankedClient>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<RankedClient> rankedClients = taskToRankedClients.getValue();\n+            for (final RankedClient rankedClient : rankedClients) {\n+                if (rankedClient.rank() == Task.LATEST_OFFSET || rankedClient.rank() == 0) {\n+                    final TaskId taskId = taskToRankedClients.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new TreeSet<>()).add(rankedClient.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3NDY2Ng==", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405574666", "bodyText": "req:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        rankForTask01OnClient1,\n          \n          \n            \n                        rankForTask01OnClient2,\n          \n          \n            \n                        rankForTask12OnClient1,\n          \n          \n            \n                        rankForTask12OnClient2\n          \n          \n            \n                    );\n          \n          \n            \n                            rankForTask01OnClient1,\n          \n          \n            \n                            rankForTask01OnClient2,\n          \n          \n            \n                            rankForTask12OnClient1,\n          \n          \n            \n                            rankForTask12OnClient2\n          \n          \n            \n                        );", "author": "cadonna", "createdAt": "2020-04-08T14:37:29Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -147,16 +153,19 @@ public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHosts(\n         final long rankForTask12OnClient2 = 0;\n         final int balanceFactor = 1;\n \n-        final Map<UUID, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor().assign(\n+        final SortedMap<TaskId, SortedSet<RankedClient>> statefulTasksToRankedCandidates =\n             twoStatefulTasksToTwoRankedClients(\n-                rankForTask01OnClient1,\n-                rankForTask01OnClient2,\n-                rankForTask12OnClient1,\n-                rankForTask12OnClient2\n-            ),\n+            rankForTask01OnClient1,\n+            rankForTask01OnClient2,\n+            rankForTask12OnClient1,\n+            rankForTask12OnClient2\n+        );", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NTcyOA==", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405585728", "bodyText": "prop:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(getMovements(stateConstrainedAssignment, balancedAssignment, tasksToCaughtUpClients, maxWarmupReplicas), equalTo(expectedMovements));\n          \n          \n            \n                    assertThat(\n          \n          \n            \n                        getMovements(stateConstrainedAssignment, balancedAssignment, tasksToCaughtUpClients, maxWarmupReplicas), \n          \n          \n            \n                        equalTo(expectedMovements)\n          \n          \n            \n                    );", "author": "cadonna", "createdAt": "2020-04-08T14:52:36Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "diffHunk": "@@ -49,40 +57,75 @@\n     public void shouldGetMovementsFromStateConstrainedToBalancedAssignment() {\n         final int maxWarmupReplicas = Integer.MAX_VALUE;\n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_2)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_0)),\n-            mkEntry(UUID_3, asList(TASK_0_2, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_2)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_0)),\n+            mkEntry(UUID_3, mkTaskList(TASK_0_2, TASK_1_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1)),\n-            mkEntry(UUID_3, asList(TASK_0_2, TASK_1_2))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1)),\n+            mkEntry(UUID_3, mkTaskList(TASK_0_2, TASK_1_2))\n         );\n+        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = getMapWithNoCaughtUpClients(\n+            mkSet(TASK_0_0, TASK_0_1, TASK_0_2, TASK_1_0, TASK_1_1, TASK_1_2)\n+        );\n+\n         final Queue<TaskMovement> expectedMovements = new LinkedList<>();\n         expectedMovements.add(new TaskMovement(TASK_1_2, UUID_1, UUID_3));\n         expectedMovements.add(new TaskMovement(TASK_1_0, UUID_2, UUID_1));\n         expectedMovements.add(new TaskMovement(TASK_1_1, UUID_3, UUID_2));\n \n-        assertThat(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas), equalTo(expectedMovements));\n+        assertThat(getMovements(stateConstrainedAssignment, balancedAssignment, tasksToCaughtUpClients, maxWarmupReplicas), equalTo(expectedMovements));\n+    }\n+\n+    @Test\n+    public void shouldImmediatelyMoveTasksWithCaughtUpDestinationClients() {\n+        final int maxWarmupReplicas = Integer.MAX_VALUE;\n+        final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_2)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_0)),\n+            mkEntry(UUID_3, mkTaskList(TASK_0_2, TASK_1_1))\n+        );\n+        final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1)),\n+            mkEntry(UUID_3, mkTaskList(TASK_0_2, TASK_1_2))\n+        );\n+        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = getMapWithNoCaughtUpClients(\n+            mkSet(TASK_0_0, TASK_0_1, TASK_0_2, TASK_1_0, TASK_1_1, TASK_1_2)\n+        );\n+        tasksToCaughtUpClients.get(TASK_1_0).add(UUID_1);\n+\n+        final Queue<TaskMovement> expectedMovements = new LinkedList<>();\n+        expectedMovements.add(new TaskMovement(TASK_1_2, UUID_1, UUID_3));\n+        expectedMovements.add(new TaskMovement(TASK_1_1, UUID_3, UUID_2));\n+\n+        assertThat(getMovements(stateConstrainedAssignment, balancedAssignment, tasksToCaughtUpClients, maxWarmupReplicas), equalTo(expectedMovements));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4OTM0Mw==", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405589343", "bodyText": "req: Please add a test that verifies the IllegalStateException when a task does not have a destination.", "author": "cadonna", "createdAt": "2020-04-08T14:57:21Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "diffHunk": "@@ -96,34 +139,46 @@ public void shouldReturnEmptyMovementsWhenPassedEmptyTaskAssignments() {\n             mkEntry(UUID_1, emptyList()),\n             mkEntry(UUID_2, emptyList())\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldReturnEmptyMovementsWhenPassedIdenticalTaskAssignments() {\n         final int maxWarmupReplicas = 2;\n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldThrowIllegalStateExceptionIfAssignmentsAreOfDifferentSize() {\n         final int maxWarmupReplicas = 2;\n \n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_0_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_0_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas));\n+        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas));\n+    }\n+", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a9ae9121195c351f4600d9c4707270a170cbec9d", "url": "https://github.com/apache/kafka/commit/a9ae9121195c351f4600d9c4707270a170cbec9d", "message": "move immediately", "committedDate": "2020-04-08T18:10:54Z", "type": "commit"}, {"oid": "8301b5b01084d6a2051d9ab686e7a80276915d82", "url": "https://github.com/apache/kafka/commit/8301b5b01084d6a2051d9ab686e7a80276915d82", "message": "pin overflow in end offsets", "committedDate": "2020-04-08T18:10:54Z", "type": "commit"}, {"oid": "ab1e002982198ea5960257678a8e7e1175291dfa", "url": "https://github.com/apache/kafka/commit/ab1e002982198ea5960257678a8e7e1175291dfa", "message": "extract to static method", "committedDate": "2020-04-08T18:10:54Z", "type": "commit"}, {"oid": "ab1e002982198ea5960257678a8e7e1175291dfa", "url": "https://github.com/apache/kafka/commit/ab1e002982198ea5960257678a8e7e1175291dfa", "message": "extract to static method", "committedDate": "2020-04-08T18:10:54Z", "type": "forcePushed"}, {"oid": "e5a8963c9cf64a60d26affd69e53f4776e9dee49", "url": "https://github.com/apache/kafka/commit/e5a8963c9cf64a60d26affd69e53f4776e9dee49", "message": "github review comments and tests", "committedDate": "2020-04-08T18:48:17Z", "type": "commit"}]}