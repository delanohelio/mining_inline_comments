{"pr_number": 8787, "pr_title": "KAFKA-10085: correctly compute lag for optimized source changelogs", "pr_createdAt": "2020-06-03T00:00:18Z", "pr_url": "https://github.com/apache/kafka/pull/8787", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNjIwNA==", "url": "https://github.com/apache/kafka/pull/8787#discussion_r435416204", "bodyText": "What's the idea of dropping this?", "author": "vvcephei", "createdAt": "2020-06-04T17:10:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -562,23 +564,18 @@ private void restoreChangelog(final ChangelogMetadata changelogMetadata) {\n     }\n \n     private Map<TopicPartition, Long> committedOffsetForChangelogs(final Set<TopicPartition> partitions) {\n-        if (partitions.isEmpty())\n-            return Collections.emptyMap();\n-", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5MDQzNg==", "url": "https://github.com/apache/kafka/pull/8787#discussion_r435590436", "bodyText": "The diff is a bit misleading, this was also factored out into the new ClientUtils#fetchCommittedOffsets", "author": "ableegoldman", "createdAt": "2020-06-04T22:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNjIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODMxMg==", "url": "https://github.com/apache/kafka/pull/8787#discussion_r436208312", "bodyText": "Ah, now I see it.", "author": "vvcephei", "createdAt": "2020-06-05T23:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNjIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQyMDgxOQ==", "url": "https://github.com/apache/kafka/pull/8787#discussion_r435420819", "bodyText": "This seems to be a step backwards, actually. Why wrap it as a StreamsException only just to immediately unwrap it again?", "author": "vvcephei", "createdAt": "2020-06-04T17:18:29Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -562,23 +564,18 @@ private void restoreChangelog(final ChangelogMetadata changelogMetadata) {\n     }\n \n     private Map<TopicPartition, Long> committedOffsetForChangelogs(final Set<TopicPartition> partitions) {\n-        if (partitions.isEmpty())\n-            return Collections.emptyMap();\n-\n         final Map<TopicPartition, Long> committedOffsets;\n         try {\n-            // those do not have a committed offset would default to 0\n-            committedOffsets =  mainConsumer.committed(partitions).entrySet().stream()\n-                .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue() == null ? 0L : e.getValue().offset()));\n-        } catch (final TimeoutException e) {\n-            // if it timed out we just retry next time.\n-            return Collections.emptyMap();\n-        } catch (final KafkaException e) {\n-            throw new StreamsException(String.format(\"Failed to retrieve end offsets for %s\", partitions), e);\n+            committedOffsets = fetchCommittedOffsets(partitions, mainConsumer);\n+        } catch (final StreamsException e) {\n+            if (e.getCause() instanceof TimeoutException) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5MzQ3Nw==", "url": "https://github.com/apache/kafka/pull/8787#discussion_r435593477", "bodyText": "I thought this might raise some eyebrows. I wanted to keep the ClientUtils methods consistent, and thought wrapping everything as a StreamsException would be cleaner. But maybe it makes more sense to throw the TimeoutException separately...", "author": "ableegoldman", "createdAt": "2020-06-04T22:46:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQyMDgxOQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0NzU3NQ==", "url": "https://github.com/apache/kafka/pull/8787#discussion_r435647575", "bodyText": "@vvcephei I've been wondering if maybe we should only  catch the TimeoutException, and interpret a StreamsException as fatal (like IllegalStateException for example). This is how we were using  Consumer#committed in the StoreChangelogReader, and AFAICT that only throws KafkaException on \"unrecoverable errors\" (quoted from javadocs)\nBut I can't tell whether the Admin's listOffsets might throw on transient errors, so I'm leaning towards catching both just to be safe. WDYT?", "author": "ableegoldman", "createdAt": "2020-06-05T01:51:11Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignor.java", "diffHunk": "@@ -763,18 +778,36 @@ private boolean populateClientStatesMap(final Map<UUID, ClientState> clientState\n                     .flatMap(Collection::stream)\n                     .collect(Collectors.toList());\n \n-            final Collection<TopicPartition> allPreexistingChangelogPartitions = new ArrayList<>(allChangelogPartitions);\n-            allPreexistingChangelogPartitions.removeIf(partition -> newlyCreatedChangelogs.contains(partition.topic()));\n+            final Set<TopicPartition> preexistingChangelogPartitions = new HashSet<>();\n+            final Set<TopicPartition> preexistingSourceChangelogPartitions = new HashSet<>();\n+            final Set<TopicPartition> newlyCreatedChangelogPartitions = new HashSet<>();\n+            for (final TopicPartition changelog : allChangelogPartitions) {\n+                if (newlyCreatedChangelogs.contains(changelog.topic())) {\n+                    newlyCreatedChangelogPartitions.add(changelog);\n+                } else if (optimizedSourceChangelogs.contains(changelog.topic())) {\n+                    preexistingSourceChangelogPartitions.add(changelog);\n+                } else {\n+                    preexistingChangelogPartitions.add(changelog);\n+                }\n+            }\n+\n+            // Make the listOffsets request first so it can  fetch the offsets for non-source changelogs\n+            // asynchronously while we use the blocking Consumer#committed call to fetch source-changelog offsets\n+            final KafkaFuture<Map<TopicPartition, ListOffsetsResultInfo>> endOffsetsFuture =\n+                fetchEndOffsetsFuture(preexistingChangelogPartitions, adminClient);\n \n-            final Collection<TopicPartition> allNewlyCreatedChangelogPartitions = new ArrayList<>(allChangelogPartitions);\n-            allNewlyCreatedChangelogPartitions.removeAll(allPreexistingChangelogPartitions);\n+            final Map<TopicPartition, Long> sourceChangelogEndOffsets =\n+                fetchCommittedOffsets(preexistingSourceChangelogPartitions, taskManager.mainConsumer());\n \n-            final Map<TopicPartition, ListOffsetsResultInfo> endOffsets =\n-                fetchEndOffsets(allPreexistingChangelogPartitions, adminClient);\n+            final Map<TopicPartition, ListOffsetsResultInfo> endOffsets = ClientUtils.getEndOffsets(endOffsetsFuture);\n \n-            allTaskEndOffsetSums = computeEndOffsetSumsByTask(endOffsets, changelogsByStatefulTask, allNewlyCreatedChangelogPartitions);\n+            allTaskEndOffsetSums = computeEndOffsetSumsByTask(\n+                changelogsByStatefulTask,\n+                endOffsets,\n+                sourceChangelogEndOffsets,\n+                newlyCreatedChangelogPartitions);\n             fetchEndOffsetsSuccessful = true;\n-        } catch (final StreamsException e) {\n+        } catch (final StreamsException | TimeoutException e) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NzcxOQ==", "url": "https://github.com/apache/kafka/pull/8787#discussion_r438477719", "bodyText": "That sounds reasonable, but I think if you throw an exception in the assignor, it just calls the assignor again in a tight loop, which seems worse than backing off and trying again later.\nIf you want to propose this change, maybe you can verify what exactly happens if we throw.", "author": "vvcephei", "createdAt": "2020-06-11T00:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0NzU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5NTA1Nw==", "url": "https://github.com/apache/kafka/pull/8787#discussion_r438495057", "bodyText": "if you throw an exception in the assignor, it just calls the assignor again in a tight loop\n\nWouldn't the leader thread just die? Not saying that that's ideal, either. But it's at least in line with how exceptions thrown by other admin client requests in the assignment are currently handled.", "author": "ableegoldman", "createdAt": "2020-06-11T01:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0NzU3NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODI0MA==", "url": "https://github.com/apache/kafka/pull/8787#discussion_r436208240", "bodyText": "Upon retrospect, I'm not sure if this is possible. The javadoc for Future#get indicates that any exception would be wrapped in an ExecutionException.", "author": "vvcephei", "createdAt": "2020-06-05T23:43:11Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ClientUtils.java", "diffHunk": "@@ -95,19 +99,65 @@ public static String getTaskProducerClientId(final String threadClientId, final\n         return result;\n     }\n \n-    public static Map<TopicPartition, ListOffsetsResultInfo> fetchEndOffsets(final Collection<TopicPartition> partitions,\n-                                                                             final Admin adminClient) {\n-        final Map<TopicPartition, ListOffsetsResultInfo> endOffsets;\n+    /**\n+     * @throws StreamsException if the consumer throws an exception\n+     * @throws org.apache.kafka.common.errors.TimeoutException if the request times out\n+     */\n+    public static Map<TopicPartition, Long> fetchCommittedOffsets(final Set<TopicPartition> partitions,\n+                                                                  final Consumer<byte[], byte[]> consumer) {\n+        if (partitions.isEmpty()) {\n+            return Collections.emptyMap();\n+        }\n+\n+        final Map<TopicPartition, Long> committedOffsets;\n         try {\n-            final KafkaFuture<Map<TopicPartition, ListOffsetsResultInfo>> future =  adminClient.listOffsets(\n-                partitions.stream().collect(Collectors.toMap(Function.identity(), tp -> OffsetSpec.latest())))\n-                                                                                        .all();\n-            endOffsets = future.get();\n+            // those which do not have a committed offset would default to 0\n+            committedOffsets = consumer.committed(partitions).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue() == null ? 0L : e.getValue().offset()));\n+        } catch (final TimeoutException e) {\n+            LOG.warn(\"The committed offsets request timed out, try increasing the consumer client's default.api.timeout.ms\", e);\n+            throw e;\n+        } catch (final KafkaException e) {\n+            LOG.warn(\"The committed offsets request failed.\", e);\n+            throw new StreamsException(String.format(\"Failed to retrieve end offsets for %s\", partitions), e);\n+        }\n+\n+        return committedOffsets;\n+    }\n \n+    public static KafkaFuture<Map<TopicPartition, ListOffsetsResultInfo>> fetchEndOffsetsFuture(final Collection<TopicPartition> partitions,\n+                                                                                                final Admin adminClient) {\n+        return adminClient.listOffsets(\n+            partitions.stream().collect(Collectors.toMap(Function.identity(), tp -> OffsetSpec.latest())))\n+            .all();\n+    }\n+\n+    /**\n+     * A helper method that wraps the {@code Future#get} call and rethrows any thrown exception as a StreamsException\n+     * @throws StreamsException if the admin client request throws an exception\n+     * @throws org.apache.kafka.common.errors.TimeoutException if the request times out\n+     */\n+    public static Map<TopicPartition, ListOffsetsResultInfo> getEndOffsets(final KafkaFuture<Map<TopicPartition, ListOffsetsResultInfo>> endOffsetsFuture) {\n+        try {\n+            return endOffsetsFuture.get();\n+        } catch (final TimeoutException e) {\n+            LOG.warn(\"The listOffsets request timed out, try increasing the admin client's default.api.timeout.ms\", e);\n+            throw e;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4ODU4NA==", "url": "https://github.com/apache/kafka/pull/8787#discussion_r437788584", "bodyText": "Good catch. Do you think it should still be thrown/treated separately, though?  See also my comment in StreamsPartitionAssignor below", "author": "ableegoldman", "createdAt": "2020-06-10T00:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODI0MA=="}], "type": "inlineReview"}, {"oid": "50aadc714d5da05e4c4d384b06bbcac73b1d3d80", "url": "https://github.com/apache/kafka/commit/50aadc714d5da05e4c4d384b06bbcac73b1d3d80", "message": "WIP", "committedDate": "2020-06-10T16:45:20Z", "type": "commit"}, {"oid": "699d8de34709536a83894fdc7a88e13a0caa21c9", "url": "https://github.com/apache/kafka/commit/699d8de34709536a83894fdc7a88e13a0caa21c9", "message": "refactor ClientUtils and get soruce changelogs", "committedDate": "2020-06-10T16:45:20Z", "type": "commit"}, {"oid": "cf228fbfcb816f2c32802aa2615bad81ec4a230a", "url": "https://github.com/apache/kafka/commit/cf228fbfcb816f2c32802aa2615bad81ec4a230a", "message": "remove consumer reference", "committedDate": "2020-06-10T16:45:20Z", "type": "commit"}, {"oid": "a50a599cb4545d9b93a09f7f49e732fc6710bf69", "url": "https://github.com/apache/kafka/commit/a50a599cb4545d9b93a09f7f49e732fc6710bf69", "message": "remove unused import", "committedDate": "2020-06-10T16:45:20Z", "type": "commit"}, {"oid": "ecebe9a6cb3cc8d38ca6c50758fc66f4e98b19c8", "url": "https://github.com/apache/kafka/commit/ecebe9a6cb3cc8d38ca6c50758fc66f4e98b19c8", "message": "fix ClientUtilsTest test", "committedDate": "2020-06-10T16:45:20Z", "type": "commit"}, {"oid": "da7ea8f6f09f041155d488079f1ed378d46c5a99", "url": "https://github.com/apache/kafka/commit/da7ea8f6f09f041155d488079f1ed378d46c5a99", "message": "throw TimeoutException separately", "committedDate": "2020-06-10T17:25:50Z", "type": "commit"}, {"oid": "bbd8b49fc2ec599b2178c93085e033ed6e545953", "url": "https://github.com/apache/kafka/commit/bbd8b49fc2ec599b2178c93085e033ed6e545953", "message": "unit test new ClientUtils methods", "committedDate": "2020-06-10T17:25:54Z", "type": "commit"}, {"oid": "6f1260b6bf09ec1114c9312c2070bf290ac71be1", "url": "https://github.com/apache/kafka/commit/6f1260b6bf09ec1114c9312c2070bf290ac71be1", "message": "only catch the timeout e's", "committedDate": "2020-06-10T17:26:18Z", "type": "commit"}, {"oid": "cada478d83846e17d51ca4105008cf5853d60873", "url": "https://github.com/apache/kafka/commit/cada478d83846e17d51ca4105008cf5853d60873", "message": "add SPA test coverage", "committedDate": "2020-06-10T17:26:20Z", "type": "commit"}, {"oid": "85acb837276be63479a8f5662d83cc252c6c0565", "url": "https://github.com/apache/kafka/commit/85acb837276be63479a8f5662d83cc252c6c0565", "message": "catch StreamsException too", "committedDate": "2020-06-10T17:26:38Z", "type": "commit"}, {"oid": "3863bb2177336be0fd59e75188bb7da28e8ee963", "url": "https://github.com/apache/kafka/commit/3863bb2177336be0fd59e75188bb7da28e8ee963", "message": "fix merge conflict", "committedDate": "2020-06-10T17:26:39Z", "type": "commit"}, {"oid": "303a6e7bca36a34ea2a1eee8ba71b410a174311f", "url": "https://github.com/apache/kafka/commit/303a6e7bca36a34ea2a1eee8ba71b410a174311f", "message": "remove unnecessary line change", "committedDate": "2020-06-10T17:26:39Z", "type": "commit"}, {"oid": "303a6e7bca36a34ea2a1eee8ba71b410a174311f", "url": "https://github.com/apache/kafka/commit/303a6e7bca36a34ea2a1eee8ba71b410a174311f", "message": "remove unnecessary line change", "committedDate": "2020-06-10T17:26:39Z", "type": "forcePushed"}, {"oid": "8d226945f517bd4037a4e9c5dc3711b30a931bd4", "url": "https://github.com/apache/kafka/commit/8d226945f517bd4037a4e9c5dc3711b30a931bd4", "message": "fix checkstyle", "committedDate": "2020-06-10T17:29:56Z", "type": "commit"}, {"oid": "0be5bb9e1fa73a4c28f01117466e349a684b639a", "url": "https://github.com/apache/kafka/commit/0be5bb9e1fa73a4c28f01117466e349a684b639a", "message": "remove no longer relevant test", "committedDate": "2020-06-10T17:32:06Z", "type": "commit"}, {"oid": "bce24581523f955b02eb52b9e337742ee4b7a459", "url": "https://github.com/apache/kafka/commit/bce24581523f955b02eb52b9e337742ee4b7a459", "message": "only catch Streams/Timeout Exceptions", "committedDate": "2020-06-10T17:34:31Z", "type": "commit"}]}