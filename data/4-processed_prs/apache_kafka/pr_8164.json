{"pr_number": 8164, "pr_title": "KAFKA-9600: EndTxn should enforce strict epoch checking if from client", "pr_createdAt": "2020-02-25T05:42:59Z", "pr_url": "https://github.com/apache/kafka/pull/8164", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk4MDA4NQ==", "url": "https://github.com/apache/kafka/pull/8164#discussion_r393980085", "bodyText": "I think reusing handleEndTransaction to handle coordinator aborts has always been a little confusing. As an alternative, we could move the logic here to an internal helper, maybe just named endTransaction. Then we can assume calls from handleEndTransaction are from the client.", "author": "hachikuji", "createdAt": "2020-03-17T21:25:59Z", "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionCoordinator.scala", "diffHunk": "@@ -351,6 +352,7 @@ class TransactionCoordinator(brokerId: Int,\n                            producerId: Long,\n                            producerEpoch: Short,\n                            txnMarkerResult: TransactionResult,\n+                           fromClient: Boolean,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk4MTg0OA==", "url": "https://github.com/apache/kafka/pull/8164#discussion_r393981848", "bodyText": "At a quick glance, these tests look basically the same except for the epoch which is sent and the expected error. Is it possible to factor out a helper?", "author": "hachikuji", "createdAt": "2020-03-17T21:29:39Z", "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionCoordinatorTest.scala", "diffHunk": "@@ -495,10 +495,62 @@ class TransactionCoordinatorTest {\n \n     EasyMock.replay(transactionManager)\n \n-    coordinator.handleEndTransaction(transactionalId, 0, 0, TransactionResult.COMMIT, errorsCallback)\n+    coordinator.handleEndTransaction(transactionalId, 0, 0, TransactionResult.COMMIT, false, errorsCallback)\n     assertEquals(Errors.COORDINATOR_LOAD_IN_PROGRESS, error)\n   }\n \n+  @Test\n+  def shouldReturnInvalidEpochWhenEndTxnIsFromClientAndEpochIsLarger(): Unit = {\n+    val serverProducerEpoch = 1.toShort", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5MjQyMw==", "url": "https://github.com/apache/kafka/pull/8164#discussion_r394492423", "bodyText": "This is a little awkward. I think the isFromClient flag was easier to understand and avoided the need to duplicate the check in a couple places.", "author": "hachikuji", "createdAt": "2020-03-18T16:47:09Z", "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionCoordinator.scala", "diffHunk": "@@ -352,6 +353,21 @@ class TransactionCoordinator(brokerId: Int,\n                            producerEpoch: Short,\n                            txnMarkerResult: TransactionResult,\n                            responseCallback: EndTxnCallback): Unit = {\n+    endTransaction(transactionalId,\n+      producerId,\n+      producerEpoch,\n+      txnMarkerResult,\n+      // Strict equality is enforced on the client side requests, as they shouldn't bump the producer epoch.\n+      (producerEpoch, txnMetadata) => producerEpoch != txnMetadata.producerEpoch,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5ODczNg==", "url": "https://github.com/apache/kafka/pull/8164#discussion_r395298736", "bodyText": "Tests which capture logging output tend to be brittle. Would it be more direct to call abortTimedOutTransactions directly?", "author": "hachikuji", "createdAt": "2020-03-19T20:24:40Z", "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionCoordinatorTest.scala", "diffHunk": "@@ -842,6 +897,43 @@ class TransactionCoordinatorTest {\n     EasyMock.verify(transactionManager)\n   }\n \n+  @Test\n+  def shouldNotAcceptSmallerEpochDuringTransactionExpiration(): Unit = {\n+    val now = time.milliseconds()\n+    val txnMetadata = new TransactionMetadata(transactionalId, producerId, producerId, producerEpoch,\n+      RecordBatch.NO_PRODUCER_EPOCH, txnTimeoutMs, Ongoing, partitions, now, now)\n+\n+    EasyMock.expect(transactionManager.timedOutTransactions())\n+      .andReturn(List(TransactionalIdAndProducerIdEpoch(transactionalId, producerId, producerEpoch)))\n+    EasyMock.expect(transactionManager.getTransactionState(EasyMock.eq(transactionalId)))\n+      .andReturn(Right(Some(CoordinatorEpochAndTxnMetadata(coordinatorEpoch, txnMetadata))))\n+\n+    val bumpedTxnMetadata = new TransactionMetadata(transactionalId, producerId, producerId, (producerEpoch + 2).toShort,\n+      RecordBatch.NO_PRODUCER_EPOCH, txnTimeoutMs, Ongoing, partitions, now, now)\n+    EasyMock.expect(transactionManager.getTransactionState(EasyMock.eq(transactionalId)))\n+      .andReturn(Right(Some(CoordinatorEpochAndTxnMetadata(coordinatorEpoch, bumpedTxnMetadata))))\n+\n+    val appender = LogCaptureAppender.createAndRegister()\n+    LogCaptureAppender.setClassLoggerLevel(coordinator.getClass, Level.DEBUG)\n+    try {\n+\n+      EasyMock.replay(transactionManager, transactionMarkerChannelManager)\n+\n+      coordinator.startup(false)\n+      time.sleep(TransactionStateManager.DefaultAbortTimedOutTransactionsIntervalMs)\n+      scheduler.tick()\n+      EasyMock.verify(transactionManager)\n+\n+      val event = appender.getMessages.find(e => e.getMessage.equals(\"Rollback of \" +", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQwNTYwMg==", "url": "https://github.com/apache/kafka/pull/8164#discussion_r395405602", "bodyText": "The tricky thing is abortTimedOutTransactions is private and we don't want to expose a function just for testing purpose I guess?", "author": "abbccdda", "createdAt": "2020-03-20T01:41:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5ODczNg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "f3d1f117232fcbc61ce55c0fc4a2fb4f06db2ba0", "url": "https://github.com/apache/kafka/commit/f3d1f117232fcbc61ce55c0fc4a2fb4f06db2ba0", "message": "fix end epoch strict checking", "committedDate": "2020-03-24T02:00:58Z", "type": "commit"}, {"oid": "28fbdee541efd5a2a9225571da474291b1e3eb04", "url": "https://github.com/apache/kafka/commit/28fbdee541efd5a2a9225571da474291b1e3eb04", "message": "refactor endTransaction", "committedDate": "2020-03-24T02:00:58Z", "type": "commit"}, {"oid": "1bb7aa7935f9f9aba80f1da6d2fa31edee8c1e64", "url": "https://github.com/apache/kafka/commit/1bb7aa7935f9f9aba80f1da6d2fa31edee8c1e64", "message": "fix test", "committedDate": "2020-03-24T02:00:58Z", "type": "commit"}, {"oid": "60d67a26bff196512b92a800021059f749ed031e", "url": "https://github.com/apache/kafka/commit/60d67a26bff196512b92a800021059f749ed031e", "message": "add more tests", "committedDate": "2020-03-24T02:00:58Z", "type": "commit"}, {"oid": "f60051aa0d87a7ae6ce1547c1a3c7c6d3ee93193", "url": "https://github.com/apache/kafka/commit/f60051aa0d87a7ae6ce1547c1a3c7c6d3ee93193", "message": "fall back to client flag", "committedDate": "2020-03-24T02:00:58Z", "type": "commit"}, {"oid": "43dad623a744f3d3564a938af6ced0e3e103118c", "url": "https://github.com/apache/kafka/commit/43dad623a744f3d3564a938af6ced0e3e103118c", "message": "make function package private", "committedDate": "2020-03-24T02:00:59Z", "type": "commit"}, {"oid": "43dad623a744f3d3564a938af6ced0e3e103118c", "url": "https://github.com/apache/kafka/commit/43dad623a744f3d3564a938af6ced0e3e103118c", "message": "make function package private", "committedDate": "2020-03-24T02:00:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMTQzNg==", "url": "https://github.com/apache/kafka/pull/8164#discussion_r397511436", "bodyText": "Can this be private?", "author": "hachikuji", "createdAt": "2020-03-24T22:57:18Z", "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionCoordinator.scala", "diffHunk": "@@ -500,24 +516,25 @@ class TransactionCoordinator(brokerId: Int,\n \n   def partitionFor(transactionalId: String): Int = txnManager.partitionFor(transactionalId)\n \n-  private def abortTimedOutTransactions(): Unit = {\n-    def onComplete(txnIdAndPidEpoch: TransactionalIdAndProducerIdEpoch)(error: Errors): Unit = {\n-      error match {\n-        case Errors.NONE =>\n-          info(\"Completed rollback of ongoing transaction for transactionalId \" +\n-            s\"${txnIdAndPidEpoch.transactionalId} due to timeout\")\n-\n-        case error@(Errors.INVALID_PRODUCER_ID_MAPPING |\n-                    Errors.INVALID_PRODUCER_EPOCH |\n-                    Errors.CONCURRENT_TRANSACTIONS) =>\n-          debug(s\"Rollback of ongoing transaction for transactionalId ${txnIdAndPidEpoch.transactionalId} \" +\n-            s\"has been cancelled due to error $error\")\n-\n-        case error =>\n-          warn(s\"Rollback of ongoing transaction for transactionalId ${txnIdAndPidEpoch.transactionalId} \" +\n-            s\"failed due to error $error\")\n-      }\n+  def onEndTransactionComplete(txnIdAndPidEpoch: TransactionalIdAndProducerIdEpoch)(error: Errors): Unit = {", "originalCommit": "43dad623a744f3d3564a938af6ced0e3e103118c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "029dcc6a69e33ef909bcbd0156c109b86e88f7d1", "url": "https://github.com/apache/kafka/commit/029dcc6a69e33ef909bcbd0156c109b86e88f7d1", "message": "address minor", "committedDate": "2020-03-24T23:38:19Z", "type": "commit"}]}