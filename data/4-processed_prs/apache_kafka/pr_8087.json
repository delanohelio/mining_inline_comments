{"pr_number": 8087, "pr_title": "KAFKA-9525: add enforceRebalance method to Consumer API", "pr_createdAt": "2020-02-11T03:46:51Z", "pr_url": "https://github.com/apache/kafka/pull/8087", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNDE5Mg==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382334192", "bodyText": "The kind of ... more than group membership and metadata is a bit unclear what it tries to convey. Or are you trying to say \"E.g. you want to trigger a rebalance with newly encoded subscription metadata, but none of the membership or subscription topics or patterns have changed so consumer group would not automatically rebalance, you can use this function\"?", "author": "guozhangwang", "createdAt": "2020-02-21T00:23:54Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/KafkaConsumer.java", "diffHunk": "@@ -2245,6 +2245,44 @@ public ConsumerGroupMetadata groupMetadata() {\n         return coordinator.groupMetadata();\n     }\n \n+    /**\n+     * Alert the consumer to trigger a new rebalance by rejoining the group. This is a nonblocking call that forces\n+     * the consumer to trigger a new rebalance on the next {@link #poll(Duration)} call. Note that this API does not\n+     * itself initiate the rebalance, so you must still call {@link #poll(Duration)}. If a rebalance is already in\n+     * progress the method will return false to indicate that it was a no-op. You can use this to decide whether to\n+     * just complete the current rebalance or retry in case the current rebalance does not include the latest\n+     * subscription metadata; however, in most cases it is better to determine that based on the resulting assignment\n+     * of the current rebalance. Only when it is not possible to validate whether the latest metadata was used based\n+     * on the received assignment should you consider retrying based on the return value.\n+     * <p>\n+     * You should not need to call this during normal processing, as the consumer group will manage itself\n+     * automatically and rebalance when necessary. However there may be situations where the application wishes to\n+     * trigger a rebalance that would otherwise not occur. For example, if some condition external and invisible to\n+     * the Consumer and its group membership changes in a way that has implications for the partition assignment,\n+     * this method can be used to trigger a reassignment. The kind of system change that would merit calling this\n+     * method is one that would also be reflected in the {@link org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription Subscription}\n+     * userdata that is passed to the assignor so it can make assignment decisions based on more than group membership\n+     * and metadata. If your assignor does not use this userdata, or you do not use a custom", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyMTk5NQ==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382421995", "bodyText": "The general motivation behind this was just to avoid users calling this unnecessarily or for the wrong reasons: basically users should not use this to try and manually intervene with the group membership, as that is and should be handled entirely internally.\nThe partition assignment only has two types of info with which to determine the assignment, one being the cluster metadata and the other being the subscription of each member. If there is a membership/cluster metadata change, the consumer will rebalance on its own. And if nothing changes, there's no reason to trigger a rebalance as the assignment should be the same. However, if there is a change that affects the userdata encoded in the subscription, the consumer will not know about this and therefore won't trigger a rebalance -- unless you tell it to.\nDoes that make sense? Again, the purpose is just to avoid users calling this except for the specific reason it exists, a change affecting subscription userdata. I'll try to think of a better way to phrase this in the javadocs without adding 1000 lines to the PR -- suggestions welcome :)", "author": "ableegoldman", "createdAt": "2020-02-21T06:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNDE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MjIyNw==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r384192227", "bodyText": "Yeah that makes sense :) I think we are on the same page, and I agree it's a bit hard to convey the message in a straight-forward phrasing. I do not have a strong suggestion here and I think your last sentence actually is good: \"E.g. if there is a change that affects the userdata encoded in the subscription\", consumers would not automatically rebalance and the user may want to use this.", "author": "guozhangwang", "createdAt": "2020-02-25T23:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNDE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382337302", "bodyText": "Previously in unsubscribe we do make sure all tasks are closed before re-subscribing, now we are relying on the consumer's response to let us know which (subset of) tasks are to be closed -- so although the task-migrated is triggered by fenced, if the heartbeat thread has not got the error code and reset the group info we would not call onPartitionsLost before re-joining the group, in that case would we possibly have more than one instance claiming to own some same partitions? Worth checking the consumer.assign function to see if the code already handles this case.\nGenerally speaking I do not know if it would expose any edge cases or not. Better run our system tests a couple of times to make sure?", "author": "guozhangwang", "createdAt": "2020-02-21T00:34:57Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -747,23 +747,18 @@ private void runLoop() {\n                 if (assignmentErrorCode.get() == AssignorError.VERSION_PROBING.code()) {\n                     log.info(\"Version probing detected. Triggering new rebalance.\");\n                     assignmentErrorCode.set(AssignorError.NONE.code());\n-                    enforceRebalance();\n+                    consumer.enforceRebalance();\n                 }\n             } catch (final TaskMigratedException ignoreAndRejoinGroup) {\n                 log.warn(\"Detected task {} that got migrated to another thread. \" +\n                              \"This implies that this thread missed a rebalance and dropped out of the consumer group. \" +\n                              \"Will try to rejoin the consumer group.\", ignoreAndRejoinGroup.migratedTaskId());\n \n-                enforceRebalance();\n+                consumer.enforceRebalance();\n             }\n         }\n     }\n \n-    private void enforceRebalance() {\n-        consumer.unsubscribe();\n-        subscribeConsumer();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxODA3Ng==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382418076", "bodyText": "That's a fair point, I think we actually do want to use the old method of unsubscribing in the specific case of a TaskMigratedException, and this new API only for version probing, KIP-441, etc.\nI don't think it would be incorrect to do this, just inefficient -- if the heartbeat thread hasn't reset the group by the next poll call, the consumer will call onPartitionsRevoked (eager) or nothing (cooperative) and send a JoinGroup. On the response it will realize it dropped out and then invoke onPartitionsLost.", "author": "ableegoldman", "createdAt": "2020-02-21T06:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxOTk5Ng==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382419996", "bodyText": "@guozhangwang Actually, looking at onLeavePrepare it seems if the heartbeat thread hasn't reset the group then we won't call onPartitionsLost even on unsubscribe\nYou partially addressed this here, but what happens if we aren't in a rebalance yet? I suppose we could actually combine the old method and the new by calling enforceRebalance and then unsubscribe but that feels a bit hacky. WDYT?\nLooking at this again I'm not sure I understand/remember why it's correct to invoke onPartitionsLost instead of onPartitionsRevoked if a rebalance is in progress during unsubscribe -- can you explain that a bit further?", "author": "ableegoldman", "createdAt": "2020-02-21T06:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczNTYxNQ==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382735615", "bodyText": "There's always a race condition because the fencing error could be notified from the brokers in two ways: 1) heartbeat, 2) commit (including txnal send-offsets). Either one could be ahead of the other in getting the error code.\nWhen we get task-migrated it means 2) got the error, at that time 1) may not get it yet so the local state may still be \"stable\" and generation not reset yet. In that case here we would revokeAll still and committing which is doom to fail again, otherwise we would lostAll (note the PR you referenced just make sure that \"otherwise\" case happens). In my other PR I also realized this from some system test failures and did this change to always \"handleLostAll\" before re-subscribing:\nhttps://github.com/apache/kafka/pull/8058/files#diff-045aeaddb4232a85a8560186b4901e69R763\nIn some sense this is to be conservative and make sure when re-subscribing we do not encode any \"owned partitions\".", "author": "guozhangwang", "createdAt": "2020-02-21T18:25:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc0MDUyNg==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382740526", "bodyText": "I'm also a bit concerned with this change, as we are calling onJoinPrepare before onLeavePrepare which changes the existing sequence for no specific reason.", "author": "abbccdda", "createdAt": "2020-02-21T18:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4MjY5OA==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382782698", "bodyText": "@guozhangwang right, in that case isn't the current behavior also at risk of this race condition? If we hit 2) even unsubscribe/onLeavePrepare will only call onPartitionsRevoked and not onPartitionsLost\nSeems we should try to fix this on the consumer client level for 2.6/trunk, as it's invoking the wrong callback. I'm not sure it's possible to detect this smoothly however, in which case we can handle the TaskMigratedException case by first calling the new enforceRebalance API and then calling unsubscribe -- since you fixed onLeavePrepare to now call onPartitionsLost in one of your cleanup PRs.\nThis still leaves us exposed in 2.5...see comment here", "author": "ableegoldman", "createdAt": "2020-02-21T20:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5MTEwMw==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382791103", "bodyText": "@abbccdda we actually do want to call onJoinPrepare before onLeavePrepare for the specific reason that we don't want to give up all our partitions unnecessarily -- of course, in the TaskMigratedException case we do still want to lose all owned partitions", "author": "ableegoldman", "createdAt": "2020-02-21T20:29:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgwMDMwNg==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382800306", "bodyText": "The current condition is only generation() == Generation.NO_GENERATION || rebalanceInProgress() and enforceRebalance only sets rebalanceNeeded to false, so after that calling unsubscribe sill does not guarantee we trigger onPartitionsLost instead of onPartitionsRevoked right?\nThat's why I think even with my previous fix it is not safe to say we'd always trigger lost, and hence I added the taskManager#handleAllLost. What's your concern of adding this call before enforceRebalance here?", "author": "guozhangwang", "createdAt": "2020-02-21T20:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgwNDgxMg==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382804812", "bodyText": "Right, yeah, I was confusing MemberState.REBALANCING with needsRejoin. Calling enforceRebalance first wouldn't help.\nI guess my preference would be to fix this in the consumer client somehow, ie make sure it invokes the correct callback during unsubscribe. For example if we get TaskMigratedException due to a failed commit, the consumer will reset the generation itself. But I'm not sure we can rely on it resetting the generation for any arbitrary cause of TaskMigratedException -- which can happen for reasons outside of consumer calls failing IIUC.\nIf we can't fix in the consumer client, then I would agree we should catch TaskMigratedException and call handleLostAll followed by unsubscribe (and resubscribe).", "author": "ableegoldman", "createdAt": "2020-02-21T21:04:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgwODIyMg==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382808222", "bodyText": "I guess my real preference would be to consider adding a second new Consumer API as part of this KIP, which acts similar to calling unsubscribe -> resubscribe but always invokes onPartitionsLost. Something like rejoinGroupAsZombie or rejoinAfterDroppingOut to force the consumer to acknowledge that it's dropped out and lost all its partitions.\nAlternatively we could add a Consumer API that basically just calls resetGeneration, and then leave it up to the user to call unsubscribe or enforceRebalance themselves. But, not sure if this is exposing too much through the Consumer interface", "author": "ableegoldman", "createdAt": "2020-02-21T21:13:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgxMjAxOA==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382812018", "bodyText": "Even if ConsumerCoordinator already reset generation on all occasions when throwing the consumer fenced exception that is still not safe, sine we could still be fenced on the producer side.\nPersonally I'm okay with either calling handleAllLost before unsubscribe, or adding a boolean parameter as in enforceRebalance(boolean resetGeneration), seems @ableegoldman is preferring the latter here so I'm giving it to you :) (feeling we are making the new API more and more advanced-usage only now)", "author": "guozhangwang", "createdAt": "2020-02-21T21:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyMjY2Mw==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382822663", "bodyText": "Yeah, I'd rather handle it within Streams or add a new API altogether than start adding semi-orthogonal parameters to this API. Since we can handle this in a reasonable way within Streams (for now) I'm fine with doing so and we can always revisit the issue later", "author": "ableegoldman", "createdAt": "2020-02-21T21:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc0MDE3Nw==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382740177", "bodyText": "s/should not need to/don't need to", "author": "abbccdda", "createdAt": "2020-02-21T18:35:23Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/KafkaConsumer.java", "diffHunk": "@@ -2247,6 +2247,44 @@ public ConsumerGroupMetadata groupMetadata() {\n         return coordinator.groupMetadata();\n     }\n \n+    /**\n+     * Alert the consumer to trigger a new rebalance by rejoining the group. This is a nonblocking call that forces\n+     * the consumer to trigger a new rebalance on the next {@link #poll(Duration)} call. Note that this API does not\n+     * itself initiate the rebalance, so you must still call {@link #poll(Duration)}. If a rebalance is already in\n+     * progress the method will return false to indicate that it was a no-op. You can use this to decide whether to\n+     * just complete the current rebalance or retry in case the current rebalance does not include the latest\n+     * subscription metadata; however, in most cases it is better to determine that based on the resulting assignment\n+     * of the current rebalance. Only when it is not possible to validate whether the latest metadata was used based\n+     * on the received assignment should you consider retrying based on the return value.\n+     * <p>\n+     * You should not need to call this during normal processing, as the consumer group will manage itself", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyODUyOQ==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r383628529", "bodyText": "@guozhangwang @abbccdda We are still at risk of the race condition on a TaskMigratedException where we call onRevoked instead of onLost -- when we directly call handleLostAll we'll remove all active tasks, then invoking handleRevocation will throw IllegalStateException below", "author": "ableegoldman", "createdAt": "2020-02-25T02:37:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -293,6 +293,11 @@ boolean tryToCompleteRestoration() {\n      * @throws TaskMigratedException if the task producer got fenced (EOS only)\n      */\n     void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n+        if (activeTaskIds().isEmpty()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3OTg5Mg==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r384179892", "bodyText": "I've just discussed this with @abbccdda when we were discussing another PR: #8168 and it turns out that in handleRevocation we should actually not throw IllegalStateException at all, since with KIP-429 the handleAssignment triggered from the streams-assignor should close the tasks already so when handleRevocation is triggered we would not have those tasks to be suspended, so we should actually remove that throw statement and replaced with a info log only.", "author": "guozhangwang", "createdAt": "2020-02-25T23:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyODUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyNTgyNw==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r384825827", "bodyText": "nit: maybe extract out the MockRebalanceListener out of ConsumerCoordinatorTest to be shared by multiple test classes?", "author": "guozhangwang", "createdAt": "2020-02-26T23:16:48Z", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java", "diffHunk": "@@ -1951,6 +1951,19 @@ public void onPartitionsAssigned(Collection<TopicPartition> partitions) {\n         };\n     }\n \n+    class CountingRebalanceListener implements ConsumerRebalanceListener {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzNDIzNA==", "url": "https://github.com/apache/kafka/pull/8087#discussion_r384834234", "bodyText": "Ack good call", "author": "ableegoldman", "createdAt": "2020-02-26T23:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyNTgyNw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "7ac705db210ae0a8069d07b6766a154f11ece0f6", "url": "https://github.com/apache/kafka/commit/7ac705db210ae0a8069d07b6766a154f11ece0f6", "message": "add API -- squashed for rebase", "committedDate": "2020-02-29T04:54:25Z", "type": "commit"}, {"oid": "7ac705db210ae0a8069d07b6766a154f11ece0f6", "url": "https://github.com/apache/kafka/commit/7ac705db210ae0a8069d07b6766a154f11ece0f6", "message": "add API -- squashed for rebase", "committedDate": "2020-02-29T04:54:25Z", "type": "forcePushed"}, {"oid": "bdc7c3a0ca08b8aea1255f2776aedabad190c3b5", "url": "https://github.com/apache/kafka/commit/bdc7c3a0ca08b8aea1255f2776aedabad190c3b5", "message": "fix log message used in VP test", "committedDate": "2020-02-29T22:55:51Z", "type": "commit"}]}