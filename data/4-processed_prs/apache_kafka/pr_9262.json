{"pr_number": 9262, "pr_title": "MINOR: Fix log message when tasks directory is cleaned manually", "pr_createdAt": "2020-09-08T10:10:50Z", "pr_url": "https://github.com/apache/kafka/pull/9262", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3MzE2Nw==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r485073167", "bodyText": "Honestly it kind of seems like there is enough divergent logic to merit splitting this up into separate methods for the manual vs cleanup-delay cases.", "author": "ableegoldman", "createdAt": "2020-09-08T17:09:44Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -328,15 +328,15 @@ private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n-                        if (now > lastModifiedMs + cleanupDelayMs) {\n-                            log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n-                                logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n-\n-                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n-                        } else if (manualUserCall) {\n+                        if (manualUserCall) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU3ODQ3NQ==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r488578475", "bodyText": "I think this is a good idea. I will split the method into two.", "author": "cadonna", "createdAt": "2020-09-15T11:04:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3MzE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIxNTczNw==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r488215737", "bodyText": "duplicate line of 340, can probably pull out of the if. Then there should be no need to make a separate method as the only divergence is a log msg.", "author": "wcarlson5", "createdAt": "2020-09-14T20:57:55Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -328,15 +328,15 @@ private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n-                        if (now > lastModifiedMs + cleanupDelayMs) {\n-                            log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n-                                logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n-\n-                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n-                        } else if (manualUserCall) {\n+                        if (manualUserCall) {\n                             log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n                                 logPrefix(), dirName, id);\n \n+                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU3ODE0Mg==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r488578142", "bodyText": "That is not entirely true, because the exception handling differs between user call and cleaner thread call. The cleaner thread call swallows all exceptions and the user call throws all exceptions.", "author": "cadonna", "createdAt": "2020-09-15T11:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIxNTczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3Nzc4Mw==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r488977783", "bodyText": "Can we at least log a warning with the exception we're swallowing? Same for the catch (final OverlappingFileLockException | IOException e)  above", "author": "ableegoldman", "createdAt": "2020-09-15T21:16:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -306,40 +306,52 @@ public synchronized void clean() {\n      */\n     public synchronized void cleanRemovedTasks(final long cleanupDelayMs) {\n         try {\n-            cleanRemovedTasks(cleanupDelayMs, false);\n+            cleanRemovedTasksCalledByCleanerThread(cleanupDelayMs);\n         } catch (final Exception cannotHappen) {\n             throw new IllegalStateException(\"Should have swallowed exception.\", cannotHappen);\n         }\n     }\n \n-    private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n-                                                final boolean manualUserCall) throws Exception {\n-        final File[] taskDirs = listAllTaskDirectories();\n-        if (taskDirs == null || taskDirs.length == 0) {\n-            return; // nothing to do\n-        }\n-\n-        for (final File taskDir : taskDirs) {\n+    private void cleanRemovedTasksCalledByCleanerThread(final long cleanupDelayMs) {\n+        for (final File taskDir : listAllTaskDirectories()) {\n             final String dirName = taskDir.getName();\n             final TaskId id = TaskId.parse(dirName);\n             if (!locks.containsKey(id)) {\n-                Exception exception = null;\n                 try {\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n                         if (now > lastModifiedMs + cleanupDelayMs) {\n                             log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n-                                logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n-\n-                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n-                        } else if (manualUserCall) {\n-                            log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n-                                logPrefix(), dirName, id);\n-\n+                                    logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n                             Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n                         }\n                     }\n+                } catch (final OverlappingFileLockException | IOException e) {\n+                    // do nothing\n+                } finally {\n+                    try {\n+                        unlock(id);\n+                    } catch (final IOException e) {\n+                        // do nothing", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ2NjMwMA==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r489466300", "bodyText": "cleanRemovedTasks -> cleanRemovedTasksCalledByUser", "author": "chia7712", "createdAt": "2020-09-16T14:07:49Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -280,7 +280,7 @@ synchronized void unlock(final TaskId taskId) throws IOException {\n     public synchronized void clean() {\n         // remove task dirs\n         try {\n-            cleanRemovedTasks(0, true);\n+            cleanRemovedTasksCalledByUser();\n         } catch (final Exception e) {\n             // this is already logged within cleanRemovedTasks", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU2ODk2NQ==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r489568965", "bodyText": "I am afraid I do not understand this comment.", "author": "cadonna", "createdAt": "2020-09-16T16:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ2NjMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTE5MQ==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r490405191", "bodyText": "The previous comment is invalid as the method \"cleanRemovedTasks\" is removed. The replacement is \"cleanRemovedTasksCalledByUser\"", "author": "chia7712", "createdAt": "2020-09-17T16:40:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ2NjMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ3NjI2OA==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r489476268", "bodyText": "the method clean catches Exception already. Could we get rid of those try-catch statements? the code log.error(\"{} Failed to release the state directory lock.\", logPrefix()); can be moved to clean. For example:\n    public synchronized void clean() {\n        // remove task dirs\n        try {\n            cleanRemovedTasksCalledByUser();\n        } catch (final Exception e) {\n            log.error(\"{} Failed to release the state directory lock.\", logPrefix());\n            throw new StreamsException(e);\n        }\n    private void cleanRemovedTasksCalledByUser() throws Exception {\n        for (final File taskDir : listAllTaskDirectories()) {\n            final String dirName = taskDir.getName();\n            final TaskId id = TaskId.parse(dirName);\n            if (!locks.containsKey(id) && lock(id)) {\n                try {\n                    log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n                            logPrefix(), dirName, id);\n                    Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n                } finally {\n                    unlock(id);\n                    // for manual user call, stream threads are not running so it is safe to delete\n                    // the whole directory\n                    Utils.delete(taskDir);\n                }", "author": "chia7712", "createdAt": "2020-09-16T14:21:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -306,40 +306,55 @@ public synchronized void clean() {\n      */\n     public synchronized void cleanRemovedTasks(final long cleanupDelayMs) {\n         try {\n-            cleanRemovedTasks(cleanupDelayMs, false);\n+            cleanRemovedTasksCalledByCleanerThread(cleanupDelayMs);\n         } catch (final Exception cannotHappen) {\n             throw new IllegalStateException(\"Should have swallowed exception.\", cannotHappen);\n         }\n     }\n \n-    private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n-                                                final boolean manualUserCall) throws Exception {\n-        final File[] taskDirs = listAllTaskDirectories();\n-        if (taskDirs == null || taskDirs.length == 0) {\n-            return; // nothing to do\n-        }\n-\n-        for (final File taskDir : taskDirs) {\n+    private void cleanRemovedTasksCalledByCleanerThread(final long cleanupDelayMs) {\n+        for (final File taskDir : listAllTaskDirectories()) {\n             final String dirName = taskDir.getName();\n             final TaskId id = TaskId.parse(dirName);\n             if (!locks.containsKey(id)) {\n-                Exception exception = null;\n                 try {\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n                         if (now > lastModifiedMs + cleanupDelayMs) {\n                             log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n                                 logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n-\n-                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n-                        } else if (manualUserCall) {\n-                            log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n-                                logPrefix(), dirName, id);\n-\n                             Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n                         }\n                     }\n+                } catch (final OverlappingFileLockException | IOException e) {\n+                    log.warn(\"{} Swallowed the following exception during deletion of obsolete state directory {} for task {}: {}\",\n+                        logPrefix(), dirName, id, e);\n+                } finally {\n+                    try {\n+                        unlock(id);\n+                    } catch (final IOException e) {\n+                        log.warn(\"{} Swallowed the following exception during unlocking after \" +\n+                                \"deletion of obsolete state directory for task {}: {}\",\n+                            logPrefix(), dirName, e);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void cleanRemovedTasksCalledByUser() throws Exception {\n+        for (final File taskDir : listAllTaskDirectories()) {\n+            final String dirName = taskDir.getName();\n+            final TaskId id = TaskId.parse(dirName);\n+            if (!locks.containsKey(id)) {\n+                Exception exception = null;\n+                try {\n+                    if (lock(id)) {\n+                        log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n+                                logPrefix(), dirName, id);\n+                        Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n+                    }\n                 } catch (final OverlappingFileLockException | IOException e) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE4OTkwNA==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r490189904", "bodyText": "Good observation! I applied some of your suggestions but left the try-catch statements since they allow to log more specific information about the encountered error.", "author": "cadonna", "createdAt": "2020-09-17T12:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ3NjI2OA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEwMjE2MQ==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491102161", "bodyText": "Nice catch!", "author": "mjsax", "createdAt": "2020-09-18T17:48:51Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -292,7 +291,7 @@ public synchronized void clean() {\n             }\n         } catch (final IOException e) {\n             log.error(\"{} Failed to delete global state directory of {} due to an unexpected exception\",\n-                appId, logPrefix(), e);\n+                logPrefix(), appId, e);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEwMjczOQ==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491102739", "bodyText": "I this save? I think if listAllTaskDirectories() returns null we would get an NPE?", "author": "mjsax", "createdAt": "2020-09-18T17:50:04Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -306,59 +305,69 @@ public synchronized void clean() {\n      */\n     public synchronized void cleanRemovedTasks(final long cleanupDelayMs) {\n         try {\n-            cleanRemovedTasks(cleanupDelayMs, false);\n+            cleanRemovedTasksCalledByCleanerThread(cleanupDelayMs);\n         } catch (final Exception cannotHappen) {\n             throw new IllegalStateException(\"Should have swallowed exception.\", cannotHappen);\n         }\n     }\n \n-    private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n-                                                final boolean manualUserCall) throws Exception {\n-        final File[] taskDirs = listAllTaskDirectories();\n-        if (taskDirs == null || taskDirs.length == 0) {\n-            return; // nothing to do\n-        }\n-\n-        for (final File taskDir : taskDirs) {\n+    private void cleanRemovedTasksCalledByCleanerThread(final long cleanupDelayMs) {\n+        for (final File taskDir : listAllTaskDirectories()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEwNzc3Nw==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491107777", "bodyText": "We recently \"fixed\" listAllTaskDirectories to guarantee that it never returns null. We just missed to update all the null checks when we did that", "author": "ableegoldman", "createdAt": "2020-09-18T18:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEwMjczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg2NDg4Ng==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491864886", "bodyText": "I saw the behavior @ableegoldman mentions and then I changed the code. So it is safe.", "author": "cadonna", "createdAt": "2020-09-21T08:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEwMjczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEwMzQzMw==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491103433", "bodyText": "As above.", "author": "mjsax", "createdAt": "2020-09-18T17:51:26Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -306,59 +305,69 @@ public synchronized void clean() {\n      */\n     public synchronized void cleanRemovedTasks(final long cleanupDelayMs) {\n         try {\n-            cleanRemovedTasks(cleanupDelayMs, false);\n+            cleanRemovedTasksCalledByCleanerThread(cleanupDelayMs);\n         } catch (final Exception cannotHappen) {\n             throw new IllegalStateException(\"Should have swallowed exception.\", cannotHappen);\n         }\n     }\n \n-    private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n-                                                final boolean manualUserCall) throws Exception {\n-        final File[] taskDirs = listAllTaskDirectories();\n-        if (taskDirs == null || taskDirs.length == 0) {\n-            return; // nothing to do\n-        }\n-\n-        for (final File taskDir : taskDirs) {\n+    private void cleanRemovedTasksCalledByCleanerThread(final long cleanupDelayMs) {\n+        for (final File taskDir : listAllTaskDirectories()) {\n             final String dirName = taskDir.getName();\n             final TaskId id = TaskId.parse(dirName);\n             if (!locks.containsKey(id)) {\n-                Exception exception = null;\n                 try {\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n                         if (now > lastModifiedMs + cleanupDelayMs) {\n                             log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n                                 logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n-\n-                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n-                        } else if (manualUserCall) {\n-                            log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n-                                logPrefix(), dirName, id);\n-\n                             Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n                         }\n                     }\n-                } catch (final OverlappingFileLockException | IOException e) {\n-                    exception = e;\n+                } catch (final OverlappingFileLockException | IOException exception) {\n+                    log.warn(\"{} Swallowed the following exception during deletion of obsolete state directory {} for task {}: {}\",\n+                        logPrefix(), dirName, id, exception);\n                 } finally {\n                     try {\n                         unlock(id);\n-\n-                        // for manual user call, stream threads are not running so it is safe to delete\n-                        // the whole directory\n-                        if (manualUserCall) {\n-                            Utils.delete(taskDir);\n-                        }\n-                    } catch (final IOException e) {\n-                        exception = e;\n+                    } catch (final IOException exception) {\n+                        log.warn(\"{} Swallowed the following exception during unlocking after \" +\n+                                \"deletion of obsolete state directory for task {}: {}\",\n+                            logPrefix(), dirName, exception);\n                     }\n                 }\n+            }\n+        }\n+    }\n \n-                if (exception != null && manualUserCall) {\n-                    log.error(\"{} Failed to release the state directory lock.\", logPrefix());\n+    private void cleanRemovedTasksCalledByUser() throws Exception {\n+        for (final File taskDir : listAllTaskDirectories()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEwNDEwMQ==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491104101", "bodyText": "Should we log a message that we could not get the lock? -- For a manual user call, this might be good to know?", "author": "mjsax", "createdAt": "2020-09-18T17:52:54Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -306,59 +305,69 @@ public synchronized void clean() {\n      */\n     public synchronized void cleanRemovedTasks(final long cleanupDelayMs) {\n         try {\n-            cleanRemovedTasks(cleanupDelayMs, false);\n+            cleanRemovedTasksCalledByCleanerThread(cleanupDelayMs);\n         } catch (final Exception cannotHappen) {\n             throw new IllegalStateException(\"Should have swallowed exception.\", cannotHappen);\n         }\n     }\n \n-    private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n-                                                final boolean manualUserCall) throws Exception {\n-        final File[] taskDirs = listAllTaskDirectories();\n-        if (taskDirs == null || taskDirs.length == 0) {\n-            return; // nothing to do\n-        }\n-\n-        for (final File taskDir : taskDirs) {\n+    private void cleanRemovedTasksCalledByCleanerThread(final long cleanupDelayMs) {\n+        for (final File taskDir : listAllTaskDirectories()) {\n             final String dirName = taskDir.getName();\n             final TaskId id = TaskId.parse(dirName);\n             if (!locks.containsKey(id)) {\n-                Exception exception = null;\n                 try {\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n                         if (now > lastModifiedMs + cleanupDelayMs) {\n                             log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n                                 logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n-\n-                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n-                        } else if (manualUserCall) {\n-                            log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n-                                logPrefix(), dirName, id);\n-\n                             Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n                         }\n                     }\n-                } catch (final OverlappingFileLockException | IOException e) {\n-                    exception = e;\n+                } catch (final OverlappingFileLockException | IOException exception) {\n+                    log.warn(\"{} Swallowed the following exception during deletion of obsolete state directory {} for task {}: {}\",\n+                        logPrefix(), dirName, id, exception);\n                 } finally {\n                     try {\n                         unlock(id);\n-\n-                        // for manual user call, stream threads are not running so it is safe to delete\n-                        // the whole directory\n-                        if (manualUserCall) {\n-                            Utils.delete(taskDir);\n-                        }\n-                    } catch (final IOException e) {\n-                        exception = e;\n+                    } catch (final IOException exception) {\n+                        log.warn(\"{} Swallowed the following exception during unlocking after \" +\n+                                \"deletion of obsolete state directory for task {}: {}\",\n+                            logPrefix(), dirName, exception);\n                     }\n                 }\n+            }\n+        }\n+    }\n \n-                if (exception != null && manualUserCall) {\n-                    log.error(\"{} Failed to release the state directory lock.\", logPrefix());\n+    private void cleanRemovedTasksCalledByUser() throws Exception {\n+        for (final File taskDir : listAllTaskDirectories()) {\n+            final String dirName = taskDir.getName();\n+            final TaskId id = TaskId.parse(dirName);\n+            if (!locks.containsKey(id)) {\n+                try {\n+                    if (lock(id)) {\n+                        log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n+                            logPrefix(), dirName, id);\n+                        Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n+                    }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEwNTQ4NA==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491105484", "bodyText": "Might be better to use an Exception variable firstException and rethrow at the end if not null -- IIRC, behavior is undefined if we throw a second exception (ie, finally would executed after the first (outer) catch block.", "author": "mjsax", "createdAt": "2020-09-18T17:55:35Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -306,59 +305,69 @@ public synchronized void clean() {\n      */\n     public synchronized void cleanRemovedTasks(final long cleanupDelayMs) {\n         try {\n-            cleanRemovedTasks(cleanupDelayMs, false);\n+            cleanRemovedTasksCalledByCleanerThread(cleanupDelayMs);\n         } catch (final Exception cannotHappen) {\n             throw new IllegalStateException(\"Should have swallowed exception.\", cannotHappen);\n         }\n     }\n \n-    private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n-                                                final boolean manualUserCall) throws Exception {\n-        final File[] taskDirs = listAllTaskDirectories();\n-        if (taskDirs == null || taskDirs.length == 0) {\n-            return; // nothing to do\n-        }\n-\n-        for (final File taskDir : taskDirs) {\n+    private void cleanRemovedTasksCalledByCleanerThread(final long cleanupDelayMs) {\n+        for (final File taskDir : listAllTaskDirectories()) {\n             final String dirName = taskDir.getName();\n             final TaskId id = TaskId.parse(dirName);\n             if (!locks.containsKey(id)) {\n-                Exception exception = null;\n                 try {\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n                         if (now > lastModifiedMs + cleanupDelayMs) {\n                             log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n                                 logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n-\n-                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n-                        } else if (manualUserCall) {\n-                            log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n-                                logPrefix(), dirName, id);\n-\n                             Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n                         }\n                     }\n-                } catch (final OverlappingFileLockException | IOException e) {\n-                    exception = e;\n+                } catch (final OverlappingFileLockException | IOException exception) {\n+                    log.warn(\"{} Swallowed the following exception during deletion of obsolete state directory {} for task {}: {}\",\n+                        logPrefix(), dirName, id, exception);\n                 } finally {\n                     try {\n                         unlock(id);\n-\n-                        // for manual user call, stream threads are not running so it is safe to delete\n-                        // the whole directory\n-                        if (manualUserCall) {\n-                            Utils.delete(taskDir);\n-                        }\n-                    } catch (final IOException e) {\n-                        exception = e;\n+                    } catch (final IOException exception) {\n+                        log.warn(\"{} Swallowed the following exception during unlocking after \" +\n+                                \"deletion of obsolete state directory for task {}: {}\",\n+                            logPrefix(), dirName, exception);\n                     }\n                 }\n+            }\n+        }\n+    }\n \n-                if (exception != null && manualUserCall) {\n-                    log.error(\"{} Failed to release the state directory lock.\", logPrefix());\n+    private void cleanRemovedTasksCalledByUser() throws Exception {\n+        for (final File taskDir : listAllTaskDirectories()) {\n+            final String dirName = taskDir.getName();\n+            final TaskId id = TaskId.parse(dirName);\n+            if (!locks.containsKey(id)) {\n+                try {\n+                    if (lock(id)) {\n+                        log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n+                            logPrefix(), dirName, id);\n+                        Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n+                    }\n+                } catch (final OverlappingFileLockException | IOException exception) {\n+                    log.error(\"{} Failed to delete state directory {} for task {} with exception: {}\",\n+                        logPrefix(), dirName, id, exception);\n                     throw exception;\n+                } finally {\n+                    try {\n+                        unlock(id);\n+                        // for manual user call, stream threads are not running so it is safe to delete\n+                        // the whole directory\n+                        Utils.delete(taskDir);\n+                    } catch (final IOException exception) {\n+                        log.error(\"{} Failed to release lock on state directory {} for task {} with exception: {}\",\n+                            logPrefix(), dirName, id, exception);\n+                        throw exception;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg4MDUxNQ==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491880515", "bodyText": "According to the Java Language Specification, it is not undefined. See https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.20.2. There it says:\n\nIf the catch block completes abruptly for reason R, then the finally block is executed. Then there is a choice:\n\n\nIf the finally block completes normally, then the try statement completes abruptly for reason R.\n\n\nIf the finally block completes abruptly for reason S, then the try statement completes abruptly for reason S (and reason R is discarded).\n\n\n\nThat means, the last thrown exception is propagated. That was also the behavior of the refactored code. Since the goal of this PR is actually just to fix the log message without changing the behavior, I would leave this change to a future PR if we feel that the behavior should change.", "author": "cadonna", "createdAt": "2020-09-21T08:48:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEwNTQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEwNjMxMg==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491106312", "bodyText": "Could we not fix this by flipping the logic to:\nif (manualUserCall) {\n} else if (now > lastModifiedMs + cleanupDelayMs) {\n}\n\nTo avoid code duplication?", "author": "mjsax", "createdAt": "2020-09-18T17:57:13Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -306,59 +305,69 @@ public synchronized void clean() {\n      */\n     public synchronized void cleanRemovedTasks(final long cleanupDelayMs) {\n         try {\n-            cleanRemovedTasks(cleanupDelayMs, false);\n+            cleanRemovedTasksCalledByCleanerThread(cleanupDelayMs);\n         } catch (final Exception cannotHappen) {\n             throw new IllegalStateException(\"Should have swallowed exception.\", cannotHappen);\n         }\n     }\n \n-    private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n-                                                final boolean manualUserCall) throws Exception {\n-        final File[] taskDirs = listAllTaskDirectories();\n-        if (taskDirs == null || taskDirs.length == 0) {\n-            return; // nothing to do\n-        }\n-\n-        for (final File taskDir : taskDirs) {\n+    private void cleanRemovedTasksCalledByCleanerThread(final long cleanupDelayMs) {\n+        for (final File taskDir : listAllTaskDirectories()) {\n             final String dirName = taskDir.getName();\n             final TaskId id = TaskId.parse(dirName);\n             if (!locks.containsKey(id)) {\n-                Exception exception = null;\n                 try {\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n                         if (now > lastModifiedMs + cleanupDelayMs) {\n                             log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n                                 logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n-\n-                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n-                        } else if (manualUserCall) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEwODU0OA==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491108548", "bodyText": "That's what Bruno originally did, but the original cleanRemovedTasks method branched on the manualUserCall flag in several places and was pretty difficult to follow (imo). So (also imo) it's cleaner to split it up into two methods that make it clear what the expected behavior is in each case. Just my 2 cents", "author": "ableegoldman", "createdAt": "2020-09-18T18:01:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEwNjMxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg2NjcxNA==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491866714", "bodyText": "I agree with @ableegoldman. Now the code is easier to follow.", "author": "cadonna", "createdAt": "2020-09-21T08:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEwNjMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA4NTgxOQ==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491085819", "bodyText": "Just noticed something else wrong with this message. e will get ignored. We should instead use log.error(String.format(\"...\", logPrefix(), appId), e)", "author": "vvcephei", "createdAt": "2020-09-18T17:16:31Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -292,7 +291,7 @@ public synchronized void clean() {\n             }\n         } catch (final IOException e) {\n             log.error(\"{} Failed to delete global state directory of {} due to an unexpected exception\",\n-                appId, logPrefix(), e);\n+                logPrefix(), appId, e);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA5MTgwOQ==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491091809", "bodyText": "This log will be incomplete. We report the exception as the cause:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                log.warn(\"{} Swallowed the following exception during deletion of obsolete state directory {} for task {}: {}\",\n          \n          \n            \n                                    logPrefix(), dirName, id, exception);\n          \n          \n            \n                                log.warn(String.format(\"%s Swallowed the following exception during deletion of obsolete state directory %s for task %s\",\n          \n          \n            \n                                    logPrefix(), dirName, id), exception);\n          \n      \n    \n    \n  \n\nThis feedback applies to pretty much all the warn/err logs in this PR.", "author": "vvcephei", "createdAt": "2020-09-18T17:28:48Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -306,59 +305,69 @@ public synchronized void clean() {\n      */\n     public synchronized void cleanRemovedTasks(final long cleanupDelayMs) {\n         try {\n-            cleanRemovedTasks(cleanupDelayMs, false);\n+            cleanRemovedTasksCalledByCleanerThread(cleanupDelayMs);\n         } catch (final Exception cannotHappen) {\n             throw new IllegalStateException(\"Should have swallowed exception.\", cannotHappen);\n         }\n     }\n \n-    private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n-                                                final boolean manualUserCall) throws Exception {\n-        final File[] taskDirs = listAllTaskDirectories();\n-        if (taskDirs == null || taskDirs.length == 0) {\n-            return; // nothing to do\n-        }\n-\n-        for (final File taskDir : taskDirs) {\n+    private void cleanRemovedTasksCalledByCleanerThread(final long cleanupDelayMs) {\n+        for (final File taskDir : listAllTaskDirectories()) {\n             final String dirName = taskDir.getName();\n             final TaskId id = TaskId.parse(dirName);\n             if (!locks.containsKey(id)) {\n-                Exception exception = null;\n                 try {\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n                         if (now > lastModifiedMs + cleanupDelayMs) {\n                             log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n                                 logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n-\n-                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n-                        } else if (manualUserCall) {\n-                            log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n-                                logPrefix(), dirName, id);\n-\n                             Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n                         }\n                     }\n-                } catch (final OverlappingFileLockException | IOException e) {\n-                    exception = e;\n+                } catch (final OverlappingFileLockException | IOException exception) {\n+                    log.warn(\"{} Swallowed the following exception during deletion of obsolete state directory {} for task {}: {}\",\n+                        logPrefix(), dirName, id, exception);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg4ODg4Mw==", "url": "https://github.com/apache/kafka/pull/9262#discussion_r491888883", "bodyText": "Good catch!", "author": "cadonna", "createdAt": "2020-09-21T09:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA5MTgwOQ=="}], "type": "inlineReview"}, {"oid": "01943f9a564000cfcb7414b4e644a4c96ccb99a3", "url": "https://github.com/apache/kafka/commit/01943f9a564000cfcb7414b4e644a4c96ccb99a3", "message": "MINOR: Fix log message when tasks directory is cleaned manually\n\nCurrently when a task directory is cleaned manually the message\nfor the state dir cleaner is logged instead of the message for\nthe manual cleanup. This is because the code checks the elapsed\ntime since the last update before it checks whether the cleanup\nis a manual call. This commit changes the order of the checks.", "committedDate": "2020-09-21T09:12:57Z", "type": "commit"}, {"oid": "250b6b5749fe91d6e2ebee1819186699d9c965b3", "url": "https://github.com/apache/kafka/commit/250b6b5749fe91d6e2ebee1819186699d9c965b3", "message": "Split method in two methods", "committedDate": "2020-09-21T09:12:57Z", "type": "commit"}, {"oid": "845d4ee747f51924c5c9327f97caa6ca573e0ab9", "url": "https://github.com/apache/kafka/commit/845d4ee747f51924c5c9327f97caa6ca573e0ab9", "message": "Add warn log for swallowed exceptions", "committedDate": "2020-09-21T09:12:57Z", "type": "commit"}, {"oid": "e3963ac6bf9399595746c61a65dfeace928a17b6", "url": "https://github.com/apache/kafka/commit/e3963ac6bf9399595746c61a65dfeace928a17b6", "message": "Refactor cleanRemovedTasksCalledByUser", "committedDate": "2020-09-21T09:12:57Z", "type": "commit"}, {"oid": "6e9e22a2d21453d4b8768adfba8117892c5e6b58", "url": "https://github.com/apache/kafka/commit/6e9e22a2d21453d4b8768adfba8117892c5e6b58", "message": "Remove code comment and rename exception variable", "committedDate": "2020-09-21T09:12:57Z", "type": "commit"}, {"oid": "02c8ad59c372bcd072f8d2ba2f2d4992a23db0f6", "url": "https://github.com/apache/kafka/commit/02c8ad59c372bcd072f8d2ba2f2d4992a23db0f6", "message": "Improve log messages", "committedDate": "2020-09-21T09:12:57Z", "type": "commit"}, {"oid": "02c8ad59c372bcd072f8d2ba2f2d4992a23db0f6", "url": "https://github.com/apache/kafka/commit/02c8ad59c372bcd072f8d2ba2f2d4992a23db0f6", "message": "Improve log messages", "committedDate": "2020-09-21T09:12:57Z", "type": "forcePushed"}]}