{"pr_number": 8331, "pr_title": "KAFKA-9748: extend EosIntegrationTest for EOS-beta", "pr_createdAt": "2020-03-23T02:23:43Z", "pr_url": "https://github.com/apache/kafka/pull/8331", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4NTgzMw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396185833", "bodyText": "Passing in the processId does not create unique transaction.id for all threads, because the processId is unique per KafkaStreams instance and the same over all threads within an instance. Thus, I propose to use the following transactional.id instead:\napplicationId + \"-\" + processId + \"-StreamThread-\" + threadIdx\n\nThis variable is the corresponding suffix processId + \"-StreamThread-\" + threadIdx", "author": "mjsax", "createdAt": "2020-03-23T02:28:26Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ActiveTaskCreator.java", "diffHunk": "@@ -79,7 +83,7 @@ private static String getTaskProducerClientId(final String threadClientId, final\n                       final Time time,\n                       final KafkaClientSupplier clientSupplier,\n                       final String threadId,\n-                      final UUID processId,\n+                      final String eosBetaTxIdSuffix,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY5ODg0Nw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396698847", "bodyText": "Is there a unit test to ensure we have different txn.id for different stream threads?", "author": "abbccdda", "createdAt": "2020-03-23T19:21:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4NTgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg0NjE4Nw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396846187", "bodyText": "No, but I am also not sure how to test this in a unit test (suggestions are welcome)? It was caught by an integration test so I was hoping we are fine?", "author": "mjsax", "createdAt": "2020-03-24T00:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4NTgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM0MjEwNQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r397342105", "bodyText": "Do we need to pass in the suffix if we've decided to go with this form? The thread-name should be client-id-StreamThread-threadIdx. So we can trim the client-id from the thread-name and replace with the application-id-process-id?", "author": "guozhangwang", "createdAt": "2020-03-24T17:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4NTgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNDczOA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r397524738", "bodyText": "We could do that, but does it make the code any simpler?", "author": "mjsax", "createdAt": "2020-03-24T23:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4NTgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg3Njc3Mg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398876772", "bodyText": "I think it is somewhat subjective :) My rationale is that it's better to not pass in parameters for a specific mode into the task creator which may not be used at all; i.e. we encapsulate the logic of creating transaction.id when eos-alpha / beta is used only inside the callee (the constructor) rather than letting the caller to prepare for it without knowing if it would really be needed or not.", "author": "guozhangwang", "createdAt": "2020-03-26T20:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4NTgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4Nzg4MQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396187881", "bodyText": "This issue was detected by the test: If we loose all tasks and close all of them it implies that the producer may have been fenced: hence, we try to abort the current transaction, close the thread producer and create a new one.", "author": "mjsax", "createdAt": "2020-03-23T02:39:29Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ActiveTaskCreator.java", "diffHunk": "@@ -108,19 +113,34 @@ private static String getTaskProducerClientId(final String threadClientId, final\n             final String threadProducerClientId = getThreadProducerClientId(threadId);\n             final Map<String, Object> producerConfigs = config.getProducerConfigs(threadProducerClientId);\n \n-            if (processingMode == StreamThread.ProcessingMode.EXACTLY_ONCE_BETA) {\n-                producerConfigs.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, applicationId + \"-\" + processId);\n-                threadProducer = new StreamsProducer(clientSupplier.getProducer(producerConfigs), true, logContext);\n+            if (processingMode == EXACTLY_ONCE_BETA) {\n+                producerConfigs.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, transactionalId);\n+                threadProducer = new StreamsProducer(clientSupplier.getProducer(producerConfigs), EXACTLY_ONCE_BETA, logContext);\n             } else {\n-                threadProducer = new StreamsProducer(clientSupplier.getProducer(producerConfigs), false, logContext);\n+                threadProducer = new StreamsProducer(clientSupplier.getProducer(producerConfigs), AT_LEAST_ONCE, logContext);\n             }\n             taskProducers = Collections.emptyMap();\n         }\n     }\n \n+    public void reInitializeProducer() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcwOTAyMg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396709022", "bodyText": "s/reInitializeProducer/reInitializeThreadProducer", "author": "abbccdda", "createdAt": "2020-03-23T19:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4Nzg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODM1Mg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396188352", "bodyText": "We duplicate each test for eos-alpha and eos-beta (I did not use parameterized tests, because I want to add one more upgrade test that does not need to be parameterized)", "author": "mjsax", "createdAt": "2020-03-23T02:42:06Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/EosIntegrationTest.java", "diffHunk": "@@ -127,13 +127,31 @@ public void createTopics() throws Exception {\n     }\n \n     @Test\n-    public void shouldBeAbleToRunWithEosEnabled() throws Exception {\n-        runSimpleCopyTest(1, SINGLE_PARTITION_INPUT_TOPIC, null, SINGLE_PARTITION_OUTPUT_TOPIC, false);\n+    public void shouldBeAbleToRunWithEosAlphaEnabled() throws Exception {\n+        shouldBeAbleToRunWithEosEnabled(StreamsConfig.EXACTLY_ONCE);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczNzg2OQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396737869", "bodyText": "I'm not sure whether it makes things simpler by just parameterizing the class, if only one upgrade test is the exception? The downside could be we need to add 3 times the same test we are doing here. Thoughts? @guozhangwang", "author": "abbccdda", "createdAt": "2020-03-23T20:31:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg0NzUzNw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396847537", "bodyText": "Fail concern -- not sure. We could also add an EosUpgradeIntegartionTest as its own class?", "author": "mjsax", "createdAt": "2020-03-24T01:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1ODAyOQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r397358029", "bodyText": "I think parameterize this class with eos-alpha and eos-beta is a better idea --- for some tests that do not rely on the flag and hence would be a duplicated one, we can move it to a separate non-parameterized class.", "author": "guozhangwang", "createdAt": "2020-03-24T18:04:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODUzNg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396188536", "bodyText": "Because we run the only stateful test twice now, we need to delete the corresponding changelog topic, too.", "author": "mjsax", "createdAt": "2020-03-23T02:43:03Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/EosIntegrationTest.java", "diffHunk": "@@ -612,6 +713,7 @@ private KafkaStreams getKafkaStreams(final boolean withState,\n                 .withCachingEnabled();\n \n             builder.addStateStore(storeBuilder);\n+            CLUSTER.deleteTopicsAndWait(applicationId + \"-\" + storeName + \"-changelog\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODc4Mg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396188782", "bodyText": "Adding more checks for this and other tests. Here: verify that we don't call put(...) (ie, don't set a transactional.id) for the non-eos case", "author": "mjsax", "createdAt": "2020-03-23T02:44:19Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/ActiveTaskCreatorTest.java", "diffHunk": "@@ -85,9 +89,20 @@\n \n     @Test\n     public void shouldCreateThreadProducerIfEosDisabled() {\n+        final Map<String, Object> mockProducerConfig = mock(Map.class);\n+        expect(mockProducerConfig.containsKey(ProducerConfig.TRANSACTIONAL_ID_CONFIG)).andReturn(false);\n+        replay(mockProducerConfig);\n+\n+        config = new StreamsConfig(properties) {\n+            @Override\n+            public Map<String, Object> getProducerConfigs(final String clientId) {\n+                return mockProducerConfig;\n+            }\n+        };\n         createTasks();\n \n         assertThat(mockClientSupplier.producers.size(), is(1));\n+        verify(mockProducerConfig);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyOTQyMg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r400529422", "bodyText": "Sounds great.", "author": "guozhangwang", "createdAt": "2020-03-30T22:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODkxNg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396188916", "bodyText": "For eos-alpha, we set the transcational.id for each task", "author": "mjsax", "createdAt": "2020-03-23T02:45:04Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/ActiveTaskCreatorTest.java", "diffHunk": "@@ -173,9 +200,24 @@ public void shouldThrowStreamsExceptionOnErrorCloseThreadProducerIfEosDisabled()\n     public void shouldCreateProducerPerTaskIfEosAlphaEnabled() {\n         properties.put(StreamsConfig.PROCESSING_GUARANTEE_CONFIG, StreamsConfig.EXACTLY_ONCE);\n         mockClientSupplier.setApplicationIdForProducer(\"appId\");\n+\n+        final Map<String, Object> mockProducerConfig = mock(Map.class);\n+        expect(mockProducerConfig.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, \"appId-0_0\")).andReturn(null);\n+        expect(mockProducerConfig.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, \"appId-0_1\")).andReturn(null);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1OTM4Nw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r397359387", "bodyText": "Good call, thanks for the improved coverage.", "author": "guozhangwang", "createdAt": "2020-03-24T18:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODk5MQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396188991", "bodyText": "For eos-beta we only set one transactional.id", "author": "mjsax", "createdAt": "2020-03-23T02:45:30Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/ActiveTaskCreatorTest.java", "diffHunk": "@@ -305,9 +362,22 @@ public void shouldThrowStreamsExceptionOnErrorCloseTaskProducerIfEosAlphaEnabled\n     public void shouldCreateThreadProducerIfEosBetaEnabled() {\n         properties.put(StreamsConfig.PROCESSING_GUARANTEE_CONFIG, StreamsConfig.EXACTLY_ONCE_BETA);\n         mockClientSupplier.setApplicationIdForProducer(\"appId\");\n+\n+        final Map<String, Object> mockProducerConfig = mock(Map.class);\n+        expect(mockProducerConfig.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, \"appId-txId\")).andReturn(null);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4OTIyMw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396189223", "bodyText": "This is just a bad diff (the test is not removed, but just the next after this new one)", "author": "mjsax", "createdAt": "2020-03-23T02:46:42Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsProducerTest.java", "diffHunk": "@@ -144,21 +152,81 @@ public void shouldFailIfProducerIsNull() {\n         {\n             final NullPointerException thrown = assertThrows(\n                 NullPointerException.class,\n-                () -> new StreamsProducer(null, true, logContext)\n+                () -> new StreamsProducer(null, EXACTLY_ONCE_ALPHA, logContext)\n+            );\n+\n+            assertThat(thrown.getMessage(), is(\"producer cannot be null\"));\n+        }\n+\n+        {\n+            final NullPointerException thrown = assertThrows(\n+                NullPointerException.class,\n+                () -> new StreamsProducer(null, EXACTLY_ONCE_BETA, logContext)\n             );\n \n             assertThat(thrown.getMessage(), is(\"producer cannot be null\"));\n         }\n     }\n \n     @Test\n-    public void shouldFailIfLogContextIsNull() {\n+    public void shouldFailIfProcessingModeIsNull() {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4OTM4Ng==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396189386", "bodyText": "Missing test (added for both cases)", "author": "mjsax", "createdAt": "2020-03-23T02:47:40Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsProducerTest.java", "diffHunk": "@@ -419,12 +497,39 @@ public void shouldThrowTimeoutExceptionOnEosInitTxTimeout() {\n         assertThat(thrown.getMessage(), is(\"KABOOM!\"));\n     }\n \n+    @Test\n+    public void shouldFailOnMaybeBeginTransactionIfTransactionsNotInitialized() {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4OTcyNA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396189724", "bodyText": "If the StreamsProducer flag would not be reset, this call would not be made below in eosBetaStreamsProducer.initTransaction();", "author": "mjsax", "createdAt": "2020-03-23T02:49:10Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsProducerTest.java", "diffHunk": "@@ -688,12 +793,55 @@ public void shouldThrowStreamsExceptionOnEosAbortTxError() {\n \n     @Test\n     public void shouldFailOnEosAbortTxFatal() {\n-        eosMockProducer.abortTransactionException = new RuntimeException(\"KABOOM!\");\n+        eosAlphaMockProducer.abortTransactionException = new RuntimeException(\"KABOOM!\");\n         // call `send()` to start a transaction\n-        eosStreamsProducer.send(record, null);\n+        eosAlphaStreamsProducer.send(record, null);\n \n-        final RuntimeException thrown = assertThrows(RuntimeException.class, eosStreamsProducer::abortTransaction);\n+        final RuntimeException thrown = assertThrows(RuntimeException.class, eosAlphaStreamsProducer::abortTransaction);\n \n         assertThat(thrown.getMessage(), is(\"KABOOM!\"));\n     }\n+\n+\n+    // EOS beta test\n+\n+    // functional tests\n+\n+    @Test\n+    public void shouldSetSetNewProducerOnResetProducer() {\n+        final Producer<byte[], byte[]> producer = mock(Producer.class);\n+\n+        eosBetaStreamsProducer.resetProducer(producer);\n+\n+        assertThat(eosBetaStreamsProducer.kafkaProducer(), is(producer));\n+    }\n+\n+    @Test\n+    public void shouldResetTransactionInitializedOnResetProducer() {\n+        final Producer<byte[], byte[]> producer = mock(Producer.class);\n+\n+        eosBetaStreamsProducer.initTransaction();\n+        eosBetaStreamsProducer.resetProducer(producer);\n+\n+        producer.initTransactions();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyMDYzMA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396620630", "bodyText": "Is this test added for the fix in this PR?", "author": "abbccdda", "createdAt": "2020-03-23T17:19:08Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -456,6 +456,32 @@ public void shouldCloseActiveTasksWhenHandlingLostTasks() {\n         assertThat(taskManager.standbyTaskMap(), is(singletonMap(taskId01, task01)));\n     }\n \n+    @Test\n+    public void shouldReInitializeThreadProducerOnHandleLostAllIfEosBetaEnabled() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg1Mjc3OA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396852778", "bodyText": "Yes, as the name suggests :)", "author": "mjsax", "createdAt": "2020-03-24T01:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyMDYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNzA4NA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396627084", "bodyText": "I'm not entirely sure whether this is a good practice, but seems like we could just get 3 separate tests?\nhttps://stackoverflow.com/questions/5466974/multiple-open-and-close-curly-brackets-inside-method-java", "author": "abbccdda", "createdAt": "2020-03-23T17:28:22Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsProducerTest.java", "diffHunk": "@@ -144,21 +152,81 @@ public void shouldFailIfProducerIsNull() {\n         {\n             final NullPointerException thrown = assertThrows(\n                 NullPointerException.class,\n-                () -> new StreamsProducer(null, true, logContext)\n+                () -> new StreamsProducer(null, EXACTLY_ONCE_ALPHA, logContext)\n+            );\n+\n+            assertThat(thrown.getMessage(), is(\"producer cannot be null\"));\n+        }\n+\n+        {\n+            final NullPointerException thrown = assertThrows(\n+                NullPointerException.class,\n+                () -> new StreamsProducer(null, EXACTLY_ONCE_BETA, logContext)\n             );\n \n             assertThat(thrown.getMessage(), is(\"producer cannot be null\"));\n         }\n     }\n \n     @Test\n-    public void shouldFailIfLogContextIsNull() {\n+    public void shouldFailIfProcessingModeIsNull() {\n         final NullPointerException thrown = assertThrows(\n             NullPointerException.class,\n-            () -> new StreamsProducer(nonEosMockProducer, false, null)\n+            () -> new StreamsProducer(nonEosMockProducer, null, logContext)\n         );\n \n-        assertThat(thrown.getMessage(), is(\"logContext cannot be null\"));\n+        assertThat(thrown.getMessage(), is(\"processingMode cannot be null\"));\n+    }\n+\n+    @Test\n+    public void shouldFailIfLogContextIsNull() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg1MDU0Mw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396850543", "bodyText": "I can rewrite -- I don't care -- don't see any difference between both.", "author": "mjsax", "createdAt": "2020-03-24T01:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNzA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcwMDM1MQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396700351", "bodyText": "This should be private", "author": "abbccdda", "createdAt": "2020-03-23T19:24:18Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsProducer.java", "diffHunk": "@@ -52,17 +55,19 @@\n     private final Logger log;\n     private final String logPrefix;\n \n-    private final Producer<byte[], byte[]> producer;\n+    private Producer<byte[], byte[]> producer;\n+    final StreamThread.ProcessingMode processingMode;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyMDgzNA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396720834", "bodyText": "nit: now that we are passing in the processingMode, we could potentially use this check as a helper function as:\nprivate boolean0 eosEnabled() {\n  processingMode == EXACTLY_ONCE_ALPHA || processingMode == EXACTLY_ONCE_BETA;\n}", "author": "abbccdda", "createdAt": "2020-03-23T19:58:07Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsProducer.java", "diffHunk": "@@ -52,17 +55,19 @@\n     private final Logger log;\n     private final String logPrefix;\n \n-    private final Producer<byte[], byte[]> producer;\n+    private Producer<byte[], byte[]> producer;\n+    final StreamThread.ProcessingMode processingMode;\n     private final boolean eosEnabled;\n \n     private boolean transactionInFlight = false;\n     private boolean transactionInitialized = false;\n \n     public StreamsProducer(final Producer<byte[], byte[]> producer,\n-                           final boolean eosEnabled,\n+                           final StreamThread.ProcessingMode processingMode,\n                            final LogContext logContext) {\n         this.producer = Objects.requireNonNull(producer, \"producer cannot be null\");\n-        this.eosEnabled = eosEnabled;\n+        this.processingMode = Objects.requireNonNull(processingMode, \"processingMode cannot be null\");\n+        this.eosEnabled = processingMode == EXACTLY_ONCE_ALPHA || processingMode == EXACTLY_ONCE_BETA;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg0NzI5Nw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396847297", "bodyText": "Well, we need this only once -- does not seems to be better to add a helper as we don't reuse the helper and the code is simple enough?", "author": "mjsax", "createdAt": "2020-03-24T01:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyMDgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEzODg5NQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398138895", "bodyText": "I think Guozhang's point above is to maintain only one flag instead of two. Using a helper could solve it IMHO.", "author": "abbccdda", "createdAt": "2020-03-25T20:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcyMDgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczNjcxMg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396736712", "bodyText": "could be named as processingMode", "author": "abbccdda", "createdAt": "2020-03-23T20:29:03Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/EosIntegrationTest.java", "diffHunk": "@@ -159,35 +177,81 @@ public void shouldCommitCorrectOffsetIfInputTopicIsTransactional() throws Except\n     }\n \n     @Test\n-    public void shouldBeAbleToRestartAfterClose() throws Exception {\n-        runSimpleCopyTest(2, SINGLE_PARTITION_INPUT_TOPIC, null, SINGLE_PARTITION_OUTPUT_TOPIC, false);\n+    public void shouldBeAbleToRestartAfterCloseWithEosAlpha() throws Exception {\n+        shouldBeAbleToRestartAfterClose(StreamsConfig.EXACTLY_ONCE);\n+    }\n+\n+    @Test\n+    public void shouldBeAbleToRestartAfterCloseWithEosBeta() throws Exception {\n+        shouldBeAbleToRestartAfterClose(StreamsConfig.EXACTLY_ONCE_BETA);\n+    }\n+\n+    private void shouldBeAbleToRestartAfterClose(final String eosConfig) throws Exception {\n+        runSimpleCopyTest(2, SINGLE_PARTITION_INPUT_TOPIC, null, SINGLE_PARTITION_OUTPUT_TOPIC, false, eosConfig);\n+    }\n+\n+    @Test\n+    public void shouldBeAbleToCommitToMultiplePartitionsWithEosAlpha() throws Exception {\n+        shouldBeAbleToCommitToMultiplePartitions(StreamsConfig.EXACTLY_ONCE);\n+    }\n+\n+    @Test\n+    public void shouldBeAbleToCommitToMultiplePartitionsWithEosBeta() throws Exception {\n+        shouldBeAbleToCommitToMultiplePartitions(StreamsConfig.EXACTLY_ONCE_BETA);\n+    }\n+\n+    private void shouldBeAbleToCommitToMultiplePartitions(final String eosConfig) throws Exception {\n+        runSimpleCopyTest(1, SINGLE_PARTITION_INPUT_TOPIC, null, MULTI_PARTITION_OUTPUT_TOPIC, false, eosConfig);\n     }\n \n     @Test\n-    public void shouldBeAbleToCommitToMultiplePartitions() throws Exception {\n-        runSimpleCopyTest(1, SINGLE_PARTITION_INPUT_TOPIC, null, MULTI_PARTITION_OUTPUT_TOPIC, false);\n+    public void shouldBeAbleToCommitMultiplePartitionOffsetsWitEosAlpha() throws Exception {\n+        shouldBeAbleToCommitMultiplePartitionOffsets(StreamsConfig.EXACTLY_ONCE);\n     }\n \n     @Test\n-    public void shouldBeAbleToCommitMultiplePartitionOffsets() throws Exception {\n-        runSimpleCopyTest(1, MULTI_PARTITION_INPUT_TOPIC, null, SINGLE_PARTITION_OUTPUT_TOPIC, false);\n+    public void shouldBeAbleToCommitMultiplePartitionOffsetsWithEosBeta() throws Exception {\n+        shouldBeAbleToCommitMultiplePartitionOffsets(StreamsConfig.EXACTLY_ONCE_BETA);\n+    }\n+\n+    private void shouldBeAbleToCommitMultiplePartitionOffsets(final String eosConfig) throws Exception {\n+        runSimpleCopyTest(1, MULTI_PARTITION_INPUT_TOPIC, null, SINGLE_PARTITION_OUTPUT_TOPIC, false, eosConfig);\n     }\n \n     @Test\n-    public void shouldBeAbleToRunWithTwoSubtopologies() throws Exception {\n-        runSimpleCopyTest(1, SINGLE_PARTITION_INPUT_TOPIC, SINGLE_PARTITION_THROUGH_TOPIC, SINGLE_PARTITION_OUTPUT_TOPIC, false);\n+    public void shouldBeAbleToRunWithTwoSubtopologiesWithEosAlpha() throws Exception {\n+        shouldBeAbleToRunWithTwoSubtopologies(StreamsConfig.EXACTLY_ONCE);\n     }\n \n     @Test\n-    public void shouldBeAbleToRunWithTwoSubtopologiesAndMultiplePartitions() throws Exception {\n-        runSimpleCopyTest(1, MULTI_PARTITION_INPUT_TOPIC, MULTI_PARTITION_THROUGH_TOPIC, MULTI_PARTITION_OUTPUT_TOPIC, false);\n+    public void shouldBeAbleToRunWithTwoSubtopologiesWithEosBeta() throws Exception {\n+        shouldBeAbleToRunWithTwoSubtopologies(StreamsConfig.EXACTLY_ONCE_BETA);\n+    }\n+\n+    private void shouldBeAbleToRunWithTwoSubtopologies(final String eosConfig) throws Exception {\n+        runSimpleCopyTest(1, SINGLE_PARTITION_INPUT_TOPIC, SINGLE_PARTITION_THROUGH_TOPIC, SINGLE_PARTITION_OUTPUT_TOPIC, false, eosConfig);\n+    }\n+\n+    @Test\n+    public void shouldBeAbleToRunWithTwoSubtopologiesAndMultiplePartitionsWithEosAlpha() throws Exception {\n+        shouldBeAbleToRunWithTwoSubtopologiesAndMultiplePartitions(StreamsConfig.EXACTLY_ONCE);\n+    }\n+\n+    @Test\n+    public void shouldBeAbleToRunWithTwoSubtopologiesAndMultiplePartitionsWithEosBeta() throws Exception {\n+        shouldBeAbleToRunWithTwoSubtopologiesAndMultiplePartitions(StreamsConfig.EXACTLY_ONCE_BETA);\n+    }\n+\n+    private void shouldBeAbleToRunWithTwoSubtopologiesAndMultiplePartitions(final String eosConfig) throws Exception {\n+        runSimpleCopyTest(1, MULTI_PARTITION_INPUT_TOPIC, MULTI_PARTITION_THROUGH_TOPIC, MULTI_PARTITION_OUTPUT_TOPIC, false, eosConfig);\n     }\n \n     private void runSimpleCopyTest(final int numberOfRestarts,\n                                    final String inputTopic,\n                                    final String throughTopic,\n                                    final String outputTopic,\n-                                   final boolean inputTopicTransactional) throws Exception {\n+                                   final boolean inputTopicTransactional,\n+                                   final String eosConfig) throws Exception {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg0Nzc2OA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396847768", "bodyText": "I called it eosConfig because it's string, and because \"at-least-once\" is not a valid config for this case.", "author": "mjsax", "createdAt": "2020-03-24T01:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczNjcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0MzU1OA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396743558", "bodyText": "Shall we also add EXACTLY_ONCE_BETA to this test?", "author": "abbccdda", "createdAt": "2020-03-23T20:41:36Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/RecordCollectorTest.java", "diffHunk": "@@ -101,7 +103,7 @@\n \n     private final MockProducer<byte[], byte[]> mockProducer = new MockProducer<>(\n         cluster, true, new DefaultPartitioner(), byteArraySerializer, byteArraySerializer);\n-    private final StreamsProducer streamsProducer = new StreamsProducer(mockProducer, false, logContext);\n+    private final StreamsProducer streamsProducer = new StreamsProducer(mockProducer, AT_LEAST_ONCE, logContext);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg0ODg5OA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396848898", "bodyText": "This test is about RecrodCollector and most test use the \"at-least-once\" StreamsProducer. In fact, there are only three special test for eos-alpha and those would be the same for eos-beta. Not sure if we would gain anything?", "author": "mjsax", "createdAt": "2020-03-24T01:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0MzU1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE0NzExMQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398147111", "bodyText": "For the test completeness, we could optionally duplicate the cases for EOS-alpha and beta just to make sure the passing in processing-mode is taking effect.", "author": "abbccdda", "createdAt": "2020-03-25T20:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0MzU1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4OTkwMQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r400489901", "bodyText": "I was thinking about this, but it would be redundant tests, because the RecordCollectorImpl only calls StreamsProducer.eosEnabled() that return true for eos-alpha and eos-beta and thus the RecordCollector cannot distinguish both cases anyway. (And we have unit test in StreamsProducerTest to make sure that eosEnabled() works correctly.)", "author": "mjsax", "createdAt": "2020-03-30T20:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0MzU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NTU1OA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396745558", "bodyText": "Sounds more like common tests", "author": "abbccdda", "createdAt": "2020-03-23T20:45:33Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsProducerTest.java", "diffHunk": "@@ -74,24 +77,29 @@\n     private final MockProducer<byte[], byte[]> nonEosMockProducer = new MockProducer<>(\n         cluster, true, new DefaultPartitioner(), byteArraySerializer, byteArraySerializer);\n     private final StreamsProducer nonEosStreamsProducer =\n-        new StreamsProducer(nonEosMockProducer, false, logContext);\n+        new StreamsProducer(nonEosMockProducer, AT_LEAST_ONCE, logContext);\n \n-    private final MockProducer<byte[], byte[]> eosMockProducer = new MockProducer<>(\n+    private final MockProducer<byte[], byte[]> eosAlphaMockProducer = new MockProducer<>(\n         cluster, true, new DefaultPartitioner(), byteArraySerializer, byteArraySerializer);\n-    private final StreamsProducer eosStreamsProducer =\n-        new StreamsProducer(eosMockProducer, true, logContext);\n+    private final StreamsProducer eosAlphaStreamsProducer =\n+        new StreamsProducer(eosAlphaMockProducer, EXACTLY_ONCE_ALPHA, logContext);\n+\n+    private final MockProducer<byte[], byte[]> eosBetaMockProducer = new MockProducer<>(\n+        cluster, true, new DefaultPartitioner(), byteArraySerializer, byteArraySerializer);\n+    private final StreamsProducer eosBetaStreamsProducer =\n+        new StreamsProducer(eosBetaMockProducer, EXACTLY_ONCE_BETA, logContext);\n \n     private final ProducerRecord<byte[], byte[]> record =\n         new ProducerRecord<>(topic, 0, 0L, new byte[0], new byte[0], new RecordHeaders());\n \n     @Before\n     public void before() {\n-        eosStreamsProducer.initTransaction();\n+        eosAlphaStreamsProducer.initTransaction();\n     }\n \n \n \n-    // generic tests (non-EOS and EOS)\n+    // generic tests (non-EOS and EOS-alpha/beta)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg1MDAwNg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396850006", "bodyText": "What is the difference of \"common tests\" vs \"generic test\" ?", "author": "mjsax", "createdAt": "2020-03-24T01:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NTU1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1MTY3Nw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398151677", "bodyText": "From the comparison here: https://wikidiff.com/common/generic, the opposite of generic is specific, which in this case I guess you want to express is mutual. So IMHO common or mutual tests are more accurate here.", "author": "abbccdda", "createdAt": "2020-03-25T20:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NTU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzM0NQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396747345", "bodyText": "I feel we could actually simplify the test by calling streamsProducer.kafkaProducer() every time for the check for the internal producer, instead of keeping a reference here, as the eosAlphaMockProducer and eosAlphaMockProducer look quite similar.", "author": "abbccdda", "createdAt": "2020-03-23T20:49:02Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsProducerTest.java", "diffHunk": "@@ -74,24 +77,29 @@\n     private final MockProducer<byte[], byte[]> nonEosMockProducer = new MockProducer<>(\n         cluster, true, new DefaultPartitioner(), byteArraySerializer, byteArraySerializer);\n     private final StreamsProducer nonEosStreamsProducer =\n-        new StreamsProducer(nonEosMockProducer, false, logContext);\n+        new StreamsProducer(nonEosMockProducer, AT_LEAST_ONCE, logContext);\n \n-    private final MockProducer<byte[], byte[]> eosMockProducer = new MockProducer<>(\n+    private final MockProducer<byte[], byte[]> eosAlphaMockProducer = new MockProducer<>(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg0OTgyMg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396849822", "bodyText": "Can you elaborate? I don't understand how this would simplify the test? For example:\n// existing code\n    @Test\n    public void shouldInitTxOnEos() {\n        assertThat(eosAlphaMockProducer.transactionInitialized(), is(true));\n    }\n\n// new code\n    @Test\n    public void shouldInitTxOnEos() {\n        assertThat(eosAlphaStreamsProducer.kafkaProducer().transactionInitialized(), is(true));\n    }\n\nWhy is the new code simpler? In fact, it looks more complex to me?", "author": "mjsax", "createdAt": "2020-03-24T01:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE0ODA4Mw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398148083", "bodyText": "It's simplified because we have a clear mapping from eosAlphaStreamsProducer to its corresponding internal producer, which in the existing code reader always has to build this mapping manually by checking the initialization code.", "author": "abbccdda", "createdAt": "2020-03-25T20:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5MDQ3OA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r400490478", "bodyText": "Seem rather subjective. I me it's obvious that one needs to read the test setup code to understand the test.", "author": "mjsax", "createdAt": "2020-03-30T21:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzkyOQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396747929", "bodyText": "Also could we try to parameterize this part as well? Like passing processing mode flags to each test", "author": "abbccdda", "createdAt": "2020-03-23T20:50:21Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsProducerTest.java", "diffHunk": "@@ -74,24 +77,29 @@\n     private final MockProducer<byte[], byte[]> nonEosMockProducer = new MockProducer<>(\n         cluster, true, new DefaultPartitioner(), byteArraySerializer, byteArraySerializer);\n     private final StreamsProducer nonEosStreamsProducer =\n-        new StreamsProducer(nonEosMockProducer, false, logContext);\n+        new StreamsProducer(nonEosMockProducer, AT_LEAST_ONCE, logContext);\n \n-    private final MockProducer<byte[], byte[]> eosMockProducer = new MockProducer<>(\n+    private final MockProducer<byte[], byte[]> eosAlphaMockProducer = new MockProducer<>(\n         cluster, true, new DefaultPartitioner(), byteArraySerializer, byteArraySerializer);\n-    private final StreamsProducer eosStreamsProducer =\n-        new StreamsProducer(eosMockProducer, true, logContext);\n+    private final StreamsProducer eosAlphaStreamsProducer =\n+        new StreamsProducer(eosAlphaMockProducer, EXACTLY_ONCE_ALPHA, logContext);\n+\n+    private final MockProducer<byte[], byte[]> eosBetaMockProducer = new MockProducer<>(\n+        cluster, true, new DefaultPartitioner(), byteArraySerializer, byteArraySerializer);\n+    private final StreamsProducer eosBetaStreamsProducer =\n+        new StreamsProducer(eosBetaMockProducer, EXACTLY_ONCE_BETA, logContext);\n \n     private final ProducerRecord<byte[], byte[]> record =\n         new ProducerRecord<>(topic, 0, 0L, new byte[0], new byte[0], new RecordHeaders());\n \n     @Before\n     public void before() {\n-        eosStreamsProducer.initTransaction();\n+        eosAlphaStreamsProducer.initTransaction();\n     }\n \n \n \n-    // generic tests (non-EOS and EOS)\n+    // generic tests (non-EOS and EOS-alpha/beta)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg1MDI2Mw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396850263", "bodyText": "I don't think that works, as the StreamsProducer has different behavior for the three different processing modes -- it would only work if we expect the same behavior to different parameters.", "author": "mjsax", "createdAt": "2020-03-24T01:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE0OTIxNA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398149214", "bodyText": "Not necessarily, we could pass in both processing mode and the expected output as parameters, if the test workflow looks essentially the same.", "author": "abbccdda", "createdAt": "2020-03-25T20:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5MTM1NQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r400491355", "bodyText": "Well, what I tried to say is, that the test workflow is not the same for most cases.", "author": "mjsax", "createdAt": "2020-03-30T21:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc1MjY3Ng==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396752676", "bodyText": "Could we use the StreamThread.eosAlpha/BetaEnabled check here?", "author": "abbccdda", "createdAt": "2020-03-23T20:59:04Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProviderTest.java", "diffHunk": "@@ -370,13 +370,21 @@ private StreamTask createStreamsTask(final StreamsConfig streamsConfig,\n                 clientSupplier.restoreConsumer,\n                 new MockStateRestoreListener()),\n             topology.storeToChangelogTopic(), partitions);\n-        final boolean eosEnabled = StreamsConfig.EXACTLY_ONCE.equals(streamsConfig.getString(StreamsConfig.PROCESSING_GUARANTEE_CONFIG));\n+        final StreamThread.ProcessingMode processingMode;\n+        final String eosConfig = streamsConfig.getString(StreamsConfig.PROCESSING_GUARANTEE_CONFIG);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc1MzUzMQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396753531", "bodyText": "TBH, Since we are adding public flags, could we just make the StreamThread helper functions public so that we don't need to manually write check every time?", "author": "abbccdda", "createdAt": "2020-03-23T21:00:40Z", "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java", "diffHunk": "@@ -588,7 +598,7 @@ private void completeAllProcessableWork() {\n     }\n \n     private void commit(final Map<TopicPartition, OffsetAndMetadata> offsets) {\n-        if (eosEnabled) {\n+        if (processingMode == EXACTLY_ONCE_ALPHA || processingMode == EXACTLY_ONCE_BETA) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg1NDAxOQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r396854019", "bodyText": "Current StreamThread helper function are base on StreamsConfig and don't do anything with ProcessingMode -- and streamsConfig is only available in the constructor of TTD on purpose.", "author": "mjsax", "createdAt": "2020-03-24T01:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc1MzUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzMTg1MA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r400531850", "bodyText": "@mjsax has the fair point here, I think we can defer for future PRs to have a StreamsUtil like function for such static functions.", "author": "guozhangwang", "createdAt": "2020-03-30T22:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc1MzUzMQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM0MjU3NQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r397342575", "bodyText": "See my previous comment above.", "author": "guozhangwang", "createdAt": "2020-03-24T17:40:50Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ActiveTaskCreator.java", "diffHunk": "@@ -95,8 +99,9 @@ private static String getTaskProducerClientId(final String threadClientId, final\n \n         createTaskSensor = ThreadMetrics.createTaskSensor(threadId, streamsMetrics);\n         applicationId = config.getString(StreamsConfig.APPLICATION_ID_CONFIG);\n+        transactionalId = applicationId + \"-\" + eosBetaTxIdSuffix;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1MjA0Mg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r397352042", "bodyText": "This is a meta question: I understand that with txn.id, we should handle ProducerFencedException as fatal and close the producer. However with eos-beta, there should be no other producers configured with the same txn.id like eos-alpha, so we should only get here from the CommitFailedException in sendOffsetsToTxn fenced by the group coordinator, in which case we do not need to close the producer either.\nOr did I miss any other scenarios here?", "author": "guozhangwang", "createdAt": "2020-03-24T17:55:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ActiveTaskCreator.java", "diffHunk": "@@ -108,19 +113,34 @@ private static String getTaskProducerClientId(final String threadClientId, final\n             final String threadProducerClientId = getThreadProducerClientId(threadId);\n             final Map<String, Object> producerConfigs = config.getProducerConfigs(threadProducerClientId);\n \n-            if (processingMode == StreamThread.ProcessingMode.EXACTLY_ONCE_BETA) {\n-                producerConfigs.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, applicationId + \"-\" + processId);\n-                threadProducer = new StreamsProducer(clientSupplier.getProducer(producerConfigs), true, logContext);\n+            if (processingMode == EXACTLY_ONCE_BETA) {\n+                producerConfigs.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, transactionalId);\n+                threadProducer = new StreamsProducer(clientSupplier.getProducer(producerConfigs), EXACTLY_ONCE_BETA, logContext);\n             } else {\n-                threadProducer = new StreamsProducer(clientSupplier.getProducer(producerConfigs), false, logContext);\n+                threadProducer = new StreamsProducer(clientSupplier.getProducer(producerConfigs), AT_LEAST_ONCE, logContext);\n             }\n             taskProducers = Collections.emptyMap();\n         }\n     }\n \n+    public void reInitializeThreadProducer() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI0NDA5MA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398244090", "bodyText": "A ProducerFencedException is thrown if a transaction expires and is aborted by the broker. Hence, it seems reasonable to handle this case gracefully and to create a new producer and rejoin the consumer group. If we don't do anything the thread won't die but would \"spin\" and fail over-and-over again with ProduceFencedException as it will try to rejoin the group but never succeed.\nThe only alternative would be, to terminate the thread explicitly, but this does not seem to be appropriate.", "author": "mjsax", "createdAt": "2020-03-26T00:07:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1MjA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1Mjc1Mw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r397352753", "bodyText": "We should have always called abortTxn in recordCollector#close as part of task closure right?", "author": "guozhangwang", "createdAt": "2020-03-24T17:56:04Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ActiveTaskCreator.java", "diffHunk": "@@ -108,19 +113,34 @@ private static String getTaskProducerClientId(final String threadClientId, final\n             final String threadProducerClientId = getThreadProducerClientId(threadId);\n             final Map<String, Object> producerConfigs = config.getProducerConfigs(threadProducerClientId);\n \n-            if (processingMode == StreamThread.ProcessingMode.EXACTLY_ONCE_BETA) {\n-                producerConfigs.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, applicationId + \"-\" + processId);\n-                threadProducer = new StreamsProducer(clientSupplier.getProducer(producerConfigs), true, logContext);\n+            if (processingMode == EXACTLY_ONCE_BETA) {\n+                producerConfigs.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, transactionalId);\n+                threadProducer = new StreamsProducer(clientSupplier.getProducer(producerConfigs), EXACTLY_ONCE_BETA, logContext);\n             } else {\n-                threadProducer = new StreamsProducer(clientSupplier.getProducer(producerConfigs), false, logContext);\n+                threadProducer = new StreamsProducer(clientSupplier.getProducer(producerConfigs), AT_LEAST_ONCE, logContext);\n             }\n             taskProducers = Collections.emptyMap();\n         }\n     }\n \n+    public void reInitializeThreadProducer() {\n+        if (processingMode != EXACTLY_ONCE_BETA) {\n+            throw new IllegalStateException(\"Exactly-once beta is not enabled.\");\n+        }\n+\n+        threadProducer.abortTransaction();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUzMzkwMg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r397533902", "bodyText": "Hmmm... That is a good point. However, now I am wondering if that is the correct thing to do for eos-beta? Insteand the TaskManager should control this?", "author": "mjsax", "createdAt": "2020-03-25T00:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1Mjc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEzNzY1MQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398137651", "bodyText": "We do call abortTxn in RecordCollector, so I feel as long as we haven't fixed https://issues.apache.org/jira/browse/KAFKA-9592\nthe abortTxn call is still not an no-op, and could be dangerous to trigger the ProducerFenced again, just FYI.", "author": "abbccdda", "createdAt": "2020-03-25T20:10:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1Mjc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE2MjcwNQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398162705", "bodyText": "Agreed, but aborting a TX is done via StreamProducer#abortTransaction() and a ProducerFencedException would be swallowed within this method -- so it is still seems to be save to try aborting in general?\nMy comment is about eoa-alpha vs eos-beta: for eos-alpha the record collector can call abortTransaction() as it is it's own producer. However, for eos-beta the producer is shared: assume one task is closed but another running task has pending writes: for this case the task that gets closed should not call abortTx or we would loose the pending writes from the other task.\nThoughts?", "author": "mjsax", "createdAt": "2020-03-25T20:54:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1Mjc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1MDQ5MQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398750491", "bodyText": "I think there is some broader issue. I would propose to move forward with this PR as-is and address this broader issue (also related to core refactoring) in a follow-up PR.\nHence, I think it's correct to call abortTransaction() here.", "author": "mjsax", "createdAt": "2020-03-26T17:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1Mjc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg3MzY3Mw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398873673", "bodyText": "Not sure if all of us are on the same page for this, my understanding is that, in eos-beta, if one task has an error, then we have to abort the whole txn which would affect other tasks. Do you see an alternative solution to avoid this?", "author": "guozhangwang", "createdAt": "2020-03-26T20:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1Mjc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyNDIzMQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398924231", "bodyText": "That sounds correct. However, it seems we don't do this correctly atm (and that is what I want to address in a follow up PR).", "author": "mjsax", "createdAt": "2020-03-26T22:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1Mjc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyODQ3NA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398928474", "bodyText": "I think we are still not clear on the safety of calling abortTxn here? Are we at the risk of failure to catch the ProducerFenced from here?", "author": "abbccdda", "createdAt": "2020-03-26T22:23:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1Mjc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0MzkxMw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398943913", "bodyText": "I think it's safe, because threadProducer is a StreamsProducer and thus a ProducerFencedException would be swallowed.", "author": "mjsax", "createdAt": "2020-03-26T23:05:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1Mjc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NjAwNA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r397356004", "bodyText": "Why we need to keep both processingMode and eosEnabled?", "author": "guozhangwang", "createdAt": "2020-03-24T18:01:04Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsProducer.java", "diffHunk": "@@ -52,17 +55,19 @@\n     private final Logger log;\n     private final String logPrefix;\n \n-    private final Producer<byte[], byte[]> producer;\n+    private Producer<byte[], byte[]> producer;\n+    private final StreamThread.ProcessingMode processingMode;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUzNDk4MQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r397534981", "bodyText": "It's simpler IMHO -- for most duties like \"initTx\" or \"beginTx\" we don't care if its eos-alpha or eos-beta. If we only keep processingMode we need to rewrite:\nif (eosEnabled) {\n...\n}\n\nto\nif (processingMode == EXACTLY_ONCE_ALPHA || processingMode == EXACTLY_ONCE_BETA) {\n...\n}\n\nwhat seem to be more \"clumsy\" ?", "author": "mjsax", "createdAt": "2020-03-25T00:05:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NjAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg3NTAyNg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398875026", "bodyText": "My concern is that keep two variables is always more vulnerable to bugs where the two mistakenly have different values (e.g. eosEnabled == false while mode == EXACTLY_ONCE). Instead, we can have a private method eosEabled() which is based on the mode variable and then be called whenever possible.", "author": "guozhangwang", "createdAt": "2020-03-26T20:35:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NjAwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyNDcyMw==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398924723", "bodyText": "Works for me", "author": "mjsax", "createdAt": "2020-03-26T22:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NjAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1Njg3Ng==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r397356876", "bodyText": "See my other comment above: with eos-beta I think this should not be triggered by ProducerFencedException ever?", "author": "guozhangwang", "createdAt": "2020-03-24T18:02:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -465,6 +467,10 @@ void handleLostAll() {\n                 partitionToTask.remove(inputPartition);\n             }\n         }\n+\n+        if (processingMode == EXACTLY_ONCE_BETA) {\n+            activeTaskCreator.reInitializeThreadProducer();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1MzIwNg==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398153206", "bodyText": "Why do we only have one error handling test for eos-beta?", "author": "abbccdda", "createdAt": "2020-03-25T20:37:45Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsProducerTest.java", "diffHunk": "@@ -688,12 +791,55 @@ public void shouldThrowStreamsExceptionOnEosAbortTxError() {\n \n     @Test\n     public void shouldFailOnEosAbortTxFatal() {\n-        eosMockProducer.abortTransactionException = new RuntimeException(\"KABOOM!\");\n+        eosAlphaMockProducer.abortTransactionException = new RuntimeException(\"KABOOM!\");\n         // call `send()` to start a transaction\n-        eosStreamsProducer.send(record, null);\n+        eosAlphaStreamsProducer.send(record, null);\n \n-        final RuntimeException thrown = assertThrows(RuntimeException.class, eosStreamsProducer::abortTransaction);\n+        final RuntimeException thrown = assertThrows(RuntimeException.class, eosAlphaStreamsProducer::abortTransaction);\n \n         assertThat(thrown.getMessage(), is(\"KABOOM!\"));\n     }\n+\n+\n+    // EOS beta test\n+\n+    // functional tests\n+\n+    @Test\n+    public void shouldSetSetNewProducerOnResetProducer() {\n+        final Producer<byte[], byte[]> producer = mock(Producer.class);\n+\n+        eosBetaStreamsProducer.resetProducer(producer);\n+\n+        assertThat(eosBetaStreamsProducer.kafkaProducer(), is(producer));\n+    }\n+\n+    @Test\n+    public void shouldResetTransactionInitializedOnResetProducer() {\n+        final Producer<byte[], byte[]> producer = mock(Producer.class);\n+\n+        eosBetaStreamsProducer.initTransaction();\n+        eosBetaStreamsProducer.resetProducer(producer);\n+\n+        producer.initTransactions();\n+        expectLastCall();\n+        replay(producer);\n+\n+        eosBetaStreamsProducer.initTransaction();\n+\n+        verify(producer);\n+    }\n+\n+    // error handling tests", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5Mjg0NA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r400492844", "bodyText": "Because there is no eos-alpha specific error case.", "author": "mjsax", "createdAt": "2020-03-30T21:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1MzIwNg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5MzY0Ng==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398793646", "bodyText": "I realized that the test setup was actually incorrect. We try to use a unique application.id per test method and with parallel test execution the variable cannot be static", "author": "mjsax", "createdAt": "2020-03-26T18:20:37Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/EosIntegrationTest.java", "diffHunk": "@@ -93,7 +98,7 @@\n         Utils.mkProperties(Collections.singletonMap(\"auto.create.topics.enable\", \"false\"))\n     );\n \n-    private static String applicationId;\n+    private String applicationId;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5MzgxMQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r398793811", "bodyText": "Make this static and atomic for parallel test execution", "author": "mjsax", "createdAt": "2020-03-26T18:20:55Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/EosIntegrationTest.java", "diffHunk": "@@ -110,11 +115,22 @@\n     private AtomicInteger commitRequested;\n     private Throwable uncaughtException;\n \n-    private int testNumber = 0;\n+    private static final AtomicInteger TEST_NUMBER = new AtomicInteger(0);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b81bc6ed9657a0436cbcb15fb0c281f996de4589", "url": "https://github.com/apache/kafka/commit/b81bc6ed9657a0436cbcb15fb0c281f996de4589", "message": "MINOR: extend EosIntegrationTest for EOS-beta", "committedDate": "2020-03-27T22:04:17Z", "type": "commit"}, {"oid": "b81bc6ed9657a0436cbcb15fb0c281f996de4589", "url": "https://github.com/apache/kafka/commit/b81bc6ed9657a0436cbcb15fb0c281f996de4589", "message": "MINOR: extend EosIntegrationTest for EOS-beta", "committedDate": "2020-03-27T22:04:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ3MDUxNQ==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r400470515", "bodyText": "nit: remove system println", "author": "abbccdda", "createdAt": "2020-03-30T20:23:24Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/EosIntegrationTest.java", "diffHunk": "@@ -536,6 +553,7 @@ public void shouldNotViolateEosIfOneTaskGetsFencedUsingIsolatedAppInstances() th\n             checkResultPerKey(committedRecords, committedDataBeforeGC);\n             checkResultPerKey(uncommittedRecords, dataBeforeGC);\n \n+            System.err.println(\"mjsax: start GC\");", "originalCommit": "b81bc6ed9657a0436cbcb15fb0c281f996de4589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NTIxOA==", "url": "https://github.com/apache/kafka/pull/8331#discussion_r400485218", "bodyText": "Ups. Good catch!", "author": "mjsax", "createdAt": "2020-03-30T20:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ3MDUxNQ=="}], "type": "inlineReview"}, {"oid": "c01468233fc24b2deb017a7bdf80dc2c644d92fc", "url": "https://github.com/apache/kafka/commit/c01468233fc24b2deb017a7bdf80dc2c644d92fc", "message": "Github comments", "committedDate": "2020-03-30T21:40:39Z", "type": "commit"}]}