{"pr_number": 9065, "pr_title": "KAFKA-10301: Do not clear Partition#remoteReplicasMap during partition assignment updates", "pr_createdAt": "2020-07-23T15:14:05Z", "pr_url": "https://github.com/apache/kafka/pull/9065", "timeline": [{"oid": "5611fd872eed98f02ea805eabaa170c9b09c81a5", "url": "https://github.com/apache/kafka/commit/5611fd872eed98f02ea805eabaa170c9b09c81a5", "message": "KAFKA-10301: Do not clear Partition#remoteReplicasMap during partition assignment updates", "committedDate": "2020-07-23T15:11:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyNzA5Nw==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459527097", "bodyText": "I decided to not get fancy with refactorings - this is literally the old code (\n  \n    \n      kafka/core/src/main/scala/kafka/cluster/Partition.scala\n    \n    \n         Line 657\n      in\n      7f9187f\n    \n    \n    \n    \n\n        \n          \n           removedReplicas.foreach(remoteReplicasMap.remove) \n        \n    \n  \n\n))", "author": "stanislavkozlovski", "createdAt": "2020-07-23T15:15:04Z", "path": "core/src/main/scala/kafka/cluster/Partition.scala", "diffHunk": "@@ -678,11 +678,13 @@ class Partition(val topicPartition: TopicPartition,\n                              isr: Set[Int],\n                              addingReplicas: Seq[Int],\n                              removingReplicas: Seq[Int]): Unit = {\n-    remoteReplicasMap.clear()\n+    val replicaSet = assignment.toSet\n+    val removedReplicas = remoteReplicasMap.keys -- replicaSet\n+\n     assignment\n       .filter(_ != localBrokerId)\n       .foreach(id => remoteReplicasMap.getAndMaybePut(id, new Replica(id, topicPartition)))\n-\n+    removedReplicas.foreach(remoteReplicasMap.remove)", "originalCommit": "5611fd872eed98f02ea805eabaa170c9b09c81a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU2MzIwNQ==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459563205", "bodyText": "Would remoteReplicasMap --= removedReplicas work here?", "author": "ijuma", "createdAt": "2020-07-23T16:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyNzA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU4ODUwMQ==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459588501", "bodyText": "Oh, this is a Pool, so we would have to add a removeAll method. Seems easy enough though since it can call the relevant method in ConcurrentMap.", "author": "ijuma", "createdAt": "2020-07-23T16:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyNzA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NjI3NA==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459596274", "bodyText": "remoteReplicasMap --= removedReplicas doesn't compile - the remoteReplicasMap is using a Kafka Pool class which itself is using a Java Map and I don't think they support the --= notation", "author": "stanislavkozlovski", "createdAt": "2020-07-23T17:01:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyNzA5Nw=="}], "type": "inlineReview"}, {"oid": "664b7cdf60377c54cecf8b36b3a81511132ef008", "url": "https://github.com/apache/kafka/commit/664b7cdf60377c54cecf8b36b3a81511132ef008", "message": "Avoid using SetOps -- trait method\n\nThe given method is deprecated in Scala 2.13", "committedDate": "2020-07-23T15:35:32Z", "type": "commit"}, {"oid": "f6d93406d7563592f8c516b0b8c8d13c7429c290", "url": "https://github.com/apache/kafka/commit/f6d93406d7563592f8c516b0b8c8d13c7429c290", "message": "Prefer Pool#getAndMaybePut to avoid needless Replica instantiations", "committedDate": "2020-07-23T17:02:49Z", "type": "commit"}, {"oid": "12016f1d9ad55482edf89f7315191f131dc1dac6", "url": "https://github.com/apache/kafka/commit/12016f1d9ad55482edf89f7315191f131dc1dac6", "message": "Add test to catch the  race condition", "committedDate": "2020-07-23T17:04:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5ODQzOQ==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459598439", "bodyText": "This fails incredibly quickly 100/100 times without the Partition.scala changes.", "author": "stanislavkozlovski", "createdAt": "2020-07-23T17:05:26Z", "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {", "originalCommit": "12016f1d9ad55482edf89f7315191f131dc1dac6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "21fb575aa28581f5b40953726dc8a9868cc46867", "url": "https://github.com/apache/kafka/commit/21fb575aa28581f5b40953726dc8a9868cc46867", "message": "Introduce Pool#removeAll helper method to improve readability", "committedDate": "2020-07-23T17:18:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNzQ3Ng==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459607476", "bodyText": "Remove unit.", "author": "ijuma", "createdAt": "2020-07-23T17:20:53Z", "path": "core/src/test/scala/unit/kafka/utils/PoolTest.scala", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package unit.kafka.utils", "originalCommit": "21fb575aa28581f5b40953726dc8a9868cc46867", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085", "url": "https://github.com/apache/kafka/commit/c13e73849e4bb1c322aaa099432a4b34401a8085", "message": "Move PoolTest to same package as kafka.utils.Pool", "committedDate": "2020-07-23T17:22:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxMzM5OQ==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459613399", "bodyText": "Nit: () is not needed.", "author": "ijuma", "createdAt": "2020-07-23T17:31:08Z", "path": "core/src/main/scala/kafka/utils/Pool.scala", "diffHunk": "@@ -69,6 +69,8 @@ class Pool[K,V](valueFactory: Option[K => V] = None) extends Iterable[(K, V)] {\n \n   def remove(key: K, value: V): Boolean = pool.remove(key, value)\n \n+  def removeAll(keys: Iterable[K]): Unit = pool.keySet().removeAll(keys.asJavaCollection)", "originalCommit": "c13e73849e4bb1c322aaa099432a4b34401a8085", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNTM5OQ==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459615399", "bodyText": "No need to repeat LeaderAndIsrPartitionState twice.", "author": "ijuma", "createdAt": "2020-07-23T17:34:40Z", "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()", "originalCommit": "c13e73849e4bb1c322aaa099432a4b34401a8085", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNjE1NA==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459616154", "bodyText": "Shouldn't this be inside the thread state?", "author": "ijuma", "createdAt": "2020-07-23T17:36:03Z", "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()\n+      .setControllerEpoch(1)\n+      .setLeader(replicas.get(0))\n+      .setLeaderEpoch(1)\n+      .setIsr(replicas)\n+      .setZkVersion(1)\n+      .setReplicas(replicas)\n+      .setIsNew(true)\n+    val offsetCheckpoints: OffsetCheckpoints = mock(classOf[OffsetCheckpoints])\n+    // Update replica set synchronously first to avoid race conditions\n+    partition.makeLeader(partitionState(secondReplicaSet), offsetCheckpoints)\n+    assertTrue(s\"Expected replica $replicaToCheck to be defined\", partition.getReplica(replicaToCheck).isDefined)\n+\n+    var i = 0", "originalCommit": "c13e73849e4bb1c322aaa099432a4b34401a8085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0MDEzNA==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459640134", "bodyText": "Yeah, nice catch", "author": "stanislavkozlovski", "createdAt": "2020-07-23T18:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNjE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNzI5OA==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459617298", "bodyText": "5 seconds is quite a bit. Can it be lower?", "author": "ijuma", "createdAt": "2020-07-23T17:37:57Z", "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()\n+      .setControllerEpoch(1)\n+      .setLeader(replicas.get(0))\n+      .setLeaderEpoch(1)\n+      .setIsr(replicas)\n+      .setZkVersion(1)\n+      .setReplicas(replicas)\n+      .setIsNew(true)\n+    val offsetCheckpoints: OffsetCheckpoints = mock(classOf[OffsetCheckpoints])\n+    // Update replica set synchronously first to avoid race conditions\n+    partition.makeLeader(partitionState(secondReplicaSet), offsetCheckpoints)\n+    assertTrue(s\"Expected replica $replicaToCheck to be defined\", partition.getReplica(replicaToCheck).isDefined)\n+\n+    var i = 0\n+    val future = executorService.submit((() => {\n+      // Flip assignment between two replica sets\n+      while (active.get) {\n+        val replicas = if (i % 2 == 0) {\n+          firstReplicaSet\n+        } else {\n+          secondReplicaSet\n+        }\n+\n+        partition.makeLeader(partitionState(replicas), offsetCheckpoints)\n+\n+        i += 1\n+        Thread.sleep(1) // just to avoid tight loop\n+      }\n+    }): Runnable)\n+\n+    val deadline = 5.seconds.fromNow", "originalCommit": "c13e73849e4bb1c322aaa099432a4b34401a8085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0MDg1NA==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459640854", "bodyText": "I think so. I opted for 5s as I saw the other tests had up to 15s of waits for futures. Let me see if 1s can go", "author": "stanislavkozlovski", "createdAt": "2020-07-23T18:19:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNzI5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0NTQxMQ==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459645411", "bodyText": "Lowered to 1s", "author": "stanislavkozlovski", "createdAt": "2020-07-23T18:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNzI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxOTgyMQ==", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459619821", "bodyText": "Nit: space missing after while.", "author": "ijuma", "createdAt": "2020-07-23T17:42:21Z", "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()\n+      .setControllerEpoch(1)\n+      .setLeader(replicas.get(0))\n+      .setLeaderEpoch(1)\n+      .setIsr(replicas)\n+      .setZkVersion(1)\n+      .setReplicas(replicas)\n+      .setIsNew(true)\n+    val offsetCheckpoints: OffsetCheckpoints = mock(classOf[OffsetCheckpoints])\n+    // Update replica set synchronously first to avoid race conditions\n+    partition.makeLeader(partitionState(secondReplicaSet), offsetCheckpoints)\n+    assertTrue(s\"Expected replica $replicaToCheck to be defined\", partition.getReplica(replicaToCheck).isDefined)\n+\n+    var i = 0\n+    val future = executorService.submit((() => {\n+      // Flip assignment between two replica sets\n+      while (active.get) {\n+        val replicas = if (i % 2 == 0) {\n+          firstReplicaSet\n+        } else {\n+          secondReplicaSet\n+        }\n+\n+        partition.makeLeader(partitionState(replicas), offsetCheckpoints)\n+\n+        i += 1\n+        Thread.sleep(1) // just to avoid tight loop\n+      }\n+    }): Runnable)\n+\n+    val deadline = 5.seconds.fromNow\n+    while(deadline.hasTimeLeft()) {", "originalCommit": "c13e73849e4bb1c322aaa099432a4b34401a8085", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0f813d69b07fb5cf8a85587576652e4a55cc7f3b", "url": "https://github.com/apache/kafka/commit/0f813d69b07fb5cf8a85587576652e4a55cc7f3b", "message": "Reduce test timeout and address stylistic comments", "committedDate": "2020-07-23T18:27:03Z", "type": "commit"}]}