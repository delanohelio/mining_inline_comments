{"pr_number": 8405, "pr_title": "KAFKA-9801: Still trigger rebalance when static member joins in CompletingRebalance phase", "pr_createdAt": "2020-04-02T01:25:04Z", "pr_url": "https://github.com/apache/kafka/pull/8405", "timeline": [{"oid": "cf8f789864cd868abe24a872a68cfcced5cdb876", "url": "https://github.com/apache/kafka/commit/cf8f789864cd868abe24a872a68cfcced5cdb876", "message": "minor", "committedDate": "2020-04-01T17:38:23Z", "type": "commit"}, {"oid": "3521bec5d6b524f4c3bf764cc938d51712707a63", "url": "https://github.com/apache/kafka/commit/3521bec5d6b524f4c3bf764cc938d51712707a63", "message": "Merge branch '2.5' of https://github.com/apache/kafka into KMinor-2.5-investigation", "committedDate": "2020-04-01T17:39:55Z", "type": "commit"}, {"oid": "9c034ca998f42d7154f02c602235a2dce38f580d", "url": "https://github.com/apache/kafka/commit/9c034ca998f42d7154f02c602235a2dce38f580d", "message": "fenced instance reason", "committedDate": "2020-04-01T17:52:37Z", "type": "commit"}, {"oid": "56555055ddc32fd4894b6274034a653c83f47510", "url": "https://github.com/apache/kafka/commit/56555055ddc32fd4894b6274034a653c83f47510", "message": "Merge branch '2.5' of https://github.com/apache/kafka into KMinor-2.5-investigation", "committedDate": "2020-04-01T18:44:24Z", "type": "commit"}, {"oid": "c8ad46ce14e667f5452a89d0e42f9a2d9d1c14d6", "url": "https://github.com/apache/kafka/commit/c8ad46ce14e667f5452a89d0e42f9a2d9d1c14d6", "message": "more log4j", "committedDate": "2020-04-01T20:00:50Z", "type": "commit"}, {"oid": "4b87e4f6328698c5b3dace1e1fdbb02a40c8cc4e", "url": "https://github.com/apache/kafka/commit/4b87e4f6328698c5b3dace1e1fdbb02a40c8cc4e", "message": "the fix", "committedDate": "2020-04-02T01:20:14Z", "type": "commit"}, {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a", "url": "https://github.com/apache/kafka/commit/03beb118dda94512cbe88f24682c2fcc21e7220a", "message": "remove commented code", "committedDate": "2020-04-02T01:21:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyMDU1Ng==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402020556", "bodyText": "What's the reasoning for this move?", "author": "abbccdda", "createdAt": "2020-04-02T02:42:40Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -451,8 +451,9 @@ boolean joinGroupIfNeeded(final Timer timer) {\n                     return false;\n                 }\n             } else {\n-                resetJoinGroupFuture();\n                 final RuntimeException exception = future.exception();\n+                log.info(\"Join group failed with {}\", exception.toString());\n+                resetJoinGroupFuture();", "originalCommit": "03beb118dda94512cbe88f24682c2fcc21e7220a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxMzA5OQ==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403213099", "bodyText": "No specific reasoning, I just prefer to change the state after we log the message :)", "author": "guozhangwang", "createdAt": "2020-04-03T18:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyMDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyMTAyMw==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402021023", "bodyText": "Should be equivalent to state == MemberState.STABLE?", "author": "abbccdda", "createdAt": "2020-04-02T02:44:31Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -892,7 +893,11 @@ protected synchronized String memberId() {\n \n     private synchronized void resetGeneration() {\n         this.generation = Generation.NO_GENERATION;\n-        resetStateAndRejoin();\n+        rejoinNeeded = true;\n+\n+        // only reset the state to un-joined when it is not already in rebalancing\n+        if (state != MemberState.REBALANCING)", "originalCommit": "03beb118dda94512cbe88f24682c2fcc21e7220a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwNzkwNQ==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403207905", "bodyText": "There are other states beside STABLE and REBALANCING", "author": "guozhangwang", "createdAt": "2020-04-03T18:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyMTAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM1MDE2Mw==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404350163", "bodyText": "But we are moving to UNJOINED anyway, so it won't affect the result right?", "author": "abbccdda", "createdAt": "2020-04-06T19:56:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyMTAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyMzcyOA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402023728", "bodyText": "We should add a comment about why we would like to trigger rebalance in this case, for example \"The rejoining static member will replace the assigned member.id, which could be unknown to the current leader. To avoid having an unknown member assignment returned, we need to trigger another rebalance\".", "author": "abbccdda", "createdAt": "2020-04-02T02:55:19Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1025,7 +991,51 @@ class GroupCoordinator(val brokerId: Int,\n     } else {\n       group.removePendingMember(memberId)\n     }\n-    maybePrepareRebalance(group, s\"Adding new member $memberId with group instanceid $groupInstanceId\")\n+    maybePrepareRebalance(group, s\"Adding new member $memberId with group instance id $groupInstanceId\")\n+  }\n+\n+  private def updateStaticMemberAndRebalance(group: GroupMetadata,\n+                                             newMemberId: String,\n+                                             groupInstanceId: Option[String],\n+                                             protocols: List[(String, Array[Byte])],\n+                                             responseCallback: JoinCallback): Unit = {\n+    val oldMemberId = group.getStaticMemberId(groupInstanceId)\n+    info(s\"Static member $groupInstanceId of group ${group.groupId} with unknown member id rejoins, assigning new member id $newMemberId, while \" +\n+      s\"old member id $oldMemberId will be removed.\")\n+\n+    val currentLeader = group.leaderOrNull\n+    val member = group.replaceGroupInstance(oldMemberId, newMemberId, groupInstanceId)\n+    // Heartbeat of old member id will expire without effect since the group no longer contains that member id.\n+    // New heartbeat shall be scheduled with new member id.\n+    completeAndScheduleNextHeartbeatExpiration(group, member)\n+\n+    val knownStaticMember = group.get(newMemberId)\n+    group.updateMember(knownStaticMember, protocols, responseCallback)\n+\n+    group.currentState match {\n+      case Stable =>\n+        info(s\"Static member joins during Stable stage will not trigger rebalance.\")\n+        group.maybeInvokeJoinCallback(member, JoinGroupResult(\n+          members = List.empty,\n+          memberId = newMemberId,\n+          generationId = group.generationId,\n+          protocolType = group.protocolType,\n+          protocolName = group.protocolName,\n+          // We want to avoid current leader performing trivial assignment while the group\n+          // is in stable sync stage, because the new assignment in leader's next sync call\n+          // won't be broadcast by a stable group. This could be guaranteed by\n+          // always returning the old leader id so that the current leader won't assume itself\n+          // as a leader based on the returned message, since the new member.id won't match\n+          // returned leader id, therefore no assignment will be performed.\n+          leaderId = currentLeader,\n+          error = Errors.NONE))\n+      case CompletingRebalance =>", "originalCommit": "03beb118dda94512cbe88f24682c2fcc21e7220a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyNDc0Mg==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402024742", "bodyText": "Do we have a way to verify the group actually transits CompletingRebalance -> PrepareRebalance -> CompletingRebalance?", "author": "abbccdda", "createdAt": "2020-04-02T02:59:06Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -630,30 +630,31 @@ class GroupCoordinatorTest {\n       Some(protocolType),\n       expectedLeaderId = leaderJoinGroupResult.memberId)\n \n+    // Old follower sync callback will return fenced exception while broker replaces the member identity.\n     EasyMock.reset(replicaManager)\n     val oldFollowerSyncGroupFuture = sendSyncGroupFollower(groupId, oldFollowerJoinGroupResult.generationId,\n       oldFollowerJoinGroupResult.memberId, Some(protocolType), Some(protocolName), followerInstanceId)\n-\n-    // Duplicate follower joins group with unknown member id will trigger member.id replacement.\n     EasyMock.reset(replicaManager)\n     val duplicateFollowerJoinFuture =\n       sendJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols, groupInstanceId = followerInstanceId)\n     timer.advanceClock(1)\n-\n-    // Old follower sync callback will return fenced exception while broker replaces the member identity.\n     val oldFollowerSyncGroupResult = Await.result(oldFollowerSyncGroupFuture, Duration(1, TimeUnit.MILLISECONDS))\n     assertEquals(Errors.FENCED_INSTANCE_ID, oldFollowerSyncGroupResult.error)\n \n-    // Duplicate follower will get the same response as old follower.\n+    // Duplicate follower joins group with unknown member id will trigger member.id replacement,\n+    // and will also trigger a rebalance under CompletingRebalance state", "originalCommit": "03beb118dda94512cbe88f24682c2fcc21e7220a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwMDk1Ng==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403200956", "bodyText": "Good call. In line 623 the group is in CompletingRebalance, and then it transits to PrepareRebalance --- let me add the verification of the group state as well.", "author": "guozhangwang", "createdAt": "2020-04-03T18:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyNDc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyNzI1OA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402727258", "bodyText": "A couple questions on this change:\n\nIf we are leaving the group through resetGenerationOnLeaveGroup, do we still want to continue the rebalance?\nWe use the the REBALANCING state to tell whether to return RebalanceInProgressException or CommitFailedException. If we reset the generation and leave the state in REBALANCING, wouldn't that mess up the check?\n\nMentioned this offline, but if the problem is misinterpreting responses from the wrong generation, I think it would be safer to detect them directly. We can add the generation information to HeartbeatResponseHandler for example. If the stored generation does not match the current generation when the response is received, we can ignore it.", "author": "hachikuji", "createdAt": "2020-04-03T04:14:24Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -892,7 +893,11 @@ protected synchronized String memberId() {\n \n     private synchronized void resetGeneration() {\n         this.generation = Generation.NO_GENERATION;\n-        resetStateAndRejoin();\n+        rejoinNeeded = true;\n+\n+        // only reset the state to un-joined when it is not already in rebalancing\n+        if (state != MemberState.REBALANCING)", "originalCommit": "03beb118dda94512cbe88f24682c2fcc21e7220a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxMTcyMw==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403211723", "bodyText": "Good call, I think the two code path should better not sharing the same callee anyways.\nI think it would not, since if the member is indeed be participating in a rebalance (i.e. it has already sent a join-group request) and a commit is being failed, then heartbeat failure should not change it to return CommitFailedException.\n\nAbout your general comment, I agree that it's better to let heartbeat request remember the generation when it was sent and compare against it even with this change in place. Let me just do that in this PR.", "author": "guozhangwang", "createdAt": "2020-04-03T18:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyNzI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5MDI3NA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403390274", "bodyText": "Was the first point addressed? As far as I can tell, resetGenerationOnLeaveGroup is still going through resetGeneration.", "author": "hachikuji", "createdAt": "2020-04-04T00:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyNzI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc2NDM1OA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403764358", "bodyText": "Regarding the first point, I change the code path to move this.rejoinNeeded = true; out of resetGeneration and only in resetGenerationOnResponseError. But then in trouble-shooting the failed unit test I realized that when heartbeat's poll timer expired it needs to call leaveGroup to notify the caller to re-join upon next poll. While on the other hand, the only other caller consumer.close would close other modules including the coordinator anyways so that right after this call, there will be no heartbeat request or other consumer poll calls, so I think it is actually fine to keep it as is.", "author": "guozhangwang", "createdAt": "2020-04-05T22:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyNzI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NDczNQ==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404394735", "bodyText": "How about unsubscribe? That is a case where we send LeaveGroup, but we do not intend to rejoin the group.", "author": "hachikuji", "createdAt": "2020-04-06T21:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyNzI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMTI5Mw==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404411293", "bodyText": "My thoughts for unsubscribe is that, if consumer still calls poll after unsubscribe then it needs to either subscribe to some other topics or assign specifically with topic-partitions. In the first case, the consumer did need to re-join the group, while in the last case, the consumer's coordinator would not call rejoinNeededOrPending anyways.", "author": "guozhangwang", "createdAt": "2020-04-06T21:53:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyNzI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczOTgyNA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402739824", "bodyText": "Leaving comment here for lack of an alternative. Is it worth checking for the case of an empty assignment? Would the client have been able to recover from this problem by leaving the group and rejoining? I am not sure how much value trying to detect broker versions which are affected by this bug. At least perhaps we can provide a better error message than the BufferUnderflow.", "author": "hachikuji", "createdAt": "2020-04-03T05:09:41Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -892,7 +893,11 @@ protected synchronized String memberId() {\n \n     private synchronized void resetGeneration() {\n         this.generation = Generation.NO_GENERATION;\n-        resetStateAndRejoin();\n+        rejoinNeeded = true;", "originalCommit": "03beb118dda94512cbe88f24682c2fcc21e7220a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNTYxMA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403215610", "bodyText": "Yes that makes sense, let me improve on the error handling.\nRegarding recovering from it, that I've thought about and it was a bit tricky --- if broker is on older versions then even if the client handles empty assignment by re-sending a join-group request, it would still be treated as not-triggering a rebalance, then the same empty assignment would still be returned..", "author": "guozhangwang", "createdAt": "2020-04-03T18:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczOTgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM3OTE3OA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403379178", "bodyText": "Yeah, I had the same thought. I'm satisfied with a better error message.", "author": "hachikuji", "createdAt": "2020-04-03T23:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczOTgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MDQ3NQ==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402740475", "bodyText": "The logic we have in doSyncGroup to fill in missing assignments seems dubious. Perhaps there's a compatibility argument to retain it, but it seems more likely to cause problems like the one here than to be useful.", "author": "hachikuji", "createdAt": "2020-04-03T05:12:28Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1025,7 +991,51 @@ class GroupCoordinator(val brokerId: Int,\n     } else {\n       group.removePendingMember(memberId)\n     }\n-    maybePrepareRebalance(group, s\"Adding new member $memberId with group instanceid $groupInstanceId\")\n+    maybePrepareRebalance(group, s\"Adding new member $memberId with group instance id $groupInstanceId\")\n+  }\n+\n+  private def updateStaticMemberAndRebalance(group: GroupMetadata,", "originalCommit": "03beb118dda94512cbe88f24682c2fcc21e7220a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwNjY4OA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403206688", "bodyText": "Yup I agree, let me file a JIRA for this.", "author": "guozhangwang", "createdAt": "2020-04-03T18:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MDQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MTc4MA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402741780", "bodyText": "How does this test case reproduce the problem? I thought we would need a sync group from the leader which included the old memberId?", "author": "hachikuji", "createdAt": "2020-04-03T05:17:53Z", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -630,30 +630,31 @@ class GroupCoordinatorTest {\n       Some(protocolType),\n       expectedLeaderId = leaderJoinGroupResult.memberId)\n \n+    // Old follower sync callback will return fenced exception while broker replaces the member identity.\n     EasyMock.reset(replicaManager)\n     val oldFollowerSyncGroupFuture = sendSyncGroupFollower(groupId, oldFollowerJoinGroupResult.generationId,\n       oldFollowerJoinGroupResult.memberId, Some(protocolType), Some(protocolName), followerInstanceId)\n-\n-    // Duplicate follower joins group with unknown member id will trigger member.id replacement.\n     EasyMock.reset(replicaManager)\n     val duplicateFollowerJoinFuture =\n       sendJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols, groupInstanceId = followerInstanceId)\n     timer.advanceClock(1)\n-\n-    // Old follower sync callback will return fenced exception while broker replaces the member identity.\n     val oldFollowerSyncGroupResult = Await.result(oldFollowerSyncGroupFuture, Duration(1, TimeUnit.MILLISECONDS))\n     assertEquals(Errors.FENCED_INSTANCE_ID, oldFollowerSyncGroupResult.error)\n \n-    // Duplicate follower will get the same response as old follower.\n+    // Duplicate follower joins group with unknown member id will trigger member.id replacement,", "originalCommit": "03beb118dda94512cbe88f24682c2fcc21e7220a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NzczMw==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403197733", "bodyText": "We just need to check that when the group is already in CompletingRebalance, a duplicate member (could be follower or leader) sending a join group again (line 638) will still trigger a rebalance.", "author": "guozhangwang", "createdAt": "2020-04-03T17:57:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MTc4MA=="}], "type": "inlineReview"}, {"oid": "7a6c43aea6a5997c3abf916762062ceddc6be640", "url": "https://github.com/apache/kafka/commit/7a6c43aea6a5997c3abf916762062ceddc6be640", "message": "github comments", "committedDate": "2020-04-03T20:59:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5MTg2NA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403391864", "bodyText": "Seems like we'd want to do this for OffsetCommitResponseHandler and SyncGroupResponseHandler as well? I am thinking this will be a big enough change that we should pull it into a separate PR.", "author": "hachikuji", "createdAt": "2020-04-04T00:10:47Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -1008,28 +1013,36 @@ public void handle(LeaveGroupResponse leaveResponse, RequestFuture<Void> future)\n \n     // visible for testing\n     synchronized RequestFuture<Void> sendHeartbeatRequest() {\n-        log.debug(\"Sending Heartbeat request to coordinator {}\", coordinator);\n+        log.debug(\"Sending Heartbeat request with generation {} and member id {} to coordinator {}\",\n+            generation.generationId, generation.memberId, coordinator);\n         HeartbeatRequest.Builder requestBuilder =\n                 new HeartbeatRequest.Builder(new HeartbeatRequestData()\n                         .setGroupId(rebalanceConfig.groupId)\n                         .setMemberId(this.generation.memberId)\n                         .setGroupInstanceId(this.rebalanceConfig.groupInstanceId.orElse(null))\n                         .setGenerationId(this.generation.generationId));\n         return client.send(coordinator, requestBuilder)\n-                .compose(new HeartbeatResponseHandler());\n+                .compose(new HeartbeatResponseHandler(generation));\n     }\n \n     private class HeartbeatResponseHandler extends CoordinatorResponseHandler<HeartbeatResponse, Void> {\n+        private final Generation sentGeneration;", "originalCommit": "7a6c43aea6a5997c3abf916762062ceddc6be640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc2NDQwMg==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403764402", "bodyText": "SG, I'm reverting this and putting into https://issues.apache.org/jira/browse/KAFKA-9823", "author": "guozhangwang", "createdAt": "2020-04-05T22:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5MTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5MjcyNw==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403392727", "bodyText": "This is basically the same thing that we have below. I think we could move it into a generic function in CoordinatorResponseHandler so that it could be used by other handlers.", "author": "hachikuji", "createdAt": "2020-04-04T00:15:02Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -1038,16 +1051,30 @@ public void handle(HeartbeatResponse heartbeatResponse, RequestFuture<Void> futu\n                 requestRejoin();\n                 future.raise(error);\n             } else if (error == Errors.ILLEGAL_GENERATION) {\n-                log.info(\"Attempt to heartbeat failed since generation {} is not current\", generation.generationId);\n-                resetGenerationOnResponseError(ApiKeys.HEARTBEAT, error);\n-                future.raise(error);\n+                if (sentGeneration.equals(currentGeneration)) {", "originalCommit": "7a6c43aea6a5997c3abf916762062ceddc6be640", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5NDI2Mg==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403394262", "bodyText": "Just a nit, but there could be one byte in the message. Maybe we can phrase this message something like \"there is insufficient bytes available to read version field (actual size: %d)...\"", "author": "hachikuji", "createdAt": "2020-04-04T00:22:56Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java", "diffHunk": "@@ -346,6 +346,12 @@ protected void onJoinComplete(int generation,\n \n         Set<TopicPartition> ownedPartitions = new HashSet<>(subscriptions.assignedPartitions());\n \n+        // should at least encode the short version\n+        if (assignmentBuffer.remaining() < 2)\n+            throw new IllegalStateException(\"Coordinator returned assignment is empty, this is not expected; \" +", "originalCommit": "7a6c43aea6a5997c3abf916762062ceddc6be640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc2NDQ1Mg==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403764452", "bodyText": "ack.", "author": "guozhangwang", "createdAt": "2020-04-05T22:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5NDI2Mg=="}], "type": "inlineReview"}, {"oid": "e03fd85c4f234a9746a021856f468af4d8a06d7c", "url": "https://github.com/apache/kafka/commit/e03fd85c4f234a9746a021856f468af4d8a06d7c", "message": "revert generation check", "committedDate": "2020-04-05T22:12:49Z", "type": "commit"}, {"oid": "351590a4f73be9f88ae685e1c6dcbd706b0ede54", "url": "https://github.com/apache/kafka/commit/351590a4f73be9f88ae685e1c6dcbd706b0ede54", "message": "github comments", "committedDate": "2020-04-05T22:18:48Z", "type": "commit"}, {"oid": "c4362b2adefcfa8416acaf77201b3cefae891f27", "url": "https://github.com/apache/kafka/commit/c4362b2adefcfa8416acaf77201b3cefae891f27", "message": "minor fix", "committedDate": "2020-04-05T22:30:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI0MDMzMQ==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404240331", "bodyText": "I looked at the flakiness of this test, and propose we just check for exact num.callback", "author": "guozhangwang", "createdAt": "2020-04-06T16:50:13Z", "path": "core/src/test/scala/integration/kafka/api/PlaintextConsumerTest.scala", "diffHunk": "@@ -187,11 +187,15 @@ class PlaintextConsumerTest extends BaseConsumerTest {\n     assertEquals(1, listener.callsToAssigned)\n     assertEquals(0, listener.callsToRevoked)\n \n-    Thread.sleep(3500)\n+    // as long as we are part of max.poll no rebalance should be triggered", "originalCommit": "c4362b2adefcfa8416acaf77201b3cefae891f27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "92d7f2eef2f37f4bc896eb565a0fefbdf0f88bb8", "url": "https://github.com/apache/kafka/commit/92d7f2eef2f37f4bc896eb565a0fefbdf0f88bb8", "message": "Merge branch '2.5' of https://github.com/apache/kafka into KMinor-2.5-investigation", "committedDate": "2020-04-06T17:19:46Z", "type": "commit"}, {"oid": "7dcc8ffa6b1b6a7855486b30a731c89025f10450", "url": "https://github.com/apache/kafka/commit/7dcc8ffa6b1b6a7855486b30a731c89025f10450", "message": "remove debugging log", "committedDate": "2020-04-06T17:27:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM1NDYyNQ==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404354625", "bodyText": "This seems not used", "author": "abbccdda", "createdAt": "2020-04-06T20:04:30Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -1427,5 +1440,7 @@ final boolean hasValidMemberId() {\n         return generation != Generation.NO_GENERATION && generation.hasMemberId();\n     }\n \n-\n+    final void setNewGeneration(final Generation generation) {", "originalCommit": "7dcc8ffa6b1b6a7855486b30a731c89025f10450", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwODEzOQ==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404408139", "bodyText": "Ack", "author": "guozhangwang", "createdAt": "2020-04-06T21:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM1NDYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4OTE2NA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404389164", "bodyText": "Do we need a reference to the future? A boolean would probably be good enough.", "author": "hachikuji", "createdAt": "2020-04-06T21:08:24Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Heartbeat.java", "diffHunk": "@@ -32,6 +32,7 @@\n     private final Timer pollTimer;\n \n     private volatile long lastHeartbeatSend = 0L;\n+    private RequestFuture<Void> heartbeatFuture = null;", "originalCommit": "7dcc8ffa6b1b6a7855486b30a731c89025f10450", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwODg4NQ==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404408885", "bodyText": "I have a follow-up PR which leverages on the future which is based on this one --- I think for this PR it does not harm to keep the future object itself although it is only used for boolean checks in unit tests, wdyt?", "author": "guozhangwang", "createdAt": "2020-04-06T21:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4OTE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5MzI0OA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404393248", "bodyText": "nit: maybe hasInflight?", "author": "hachikuji", "createdAt": "2020-04-06T21:16:30Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Heartbeat.java", "diffHunk": "@@ -56,60 +57,66 @@ public void poll(long now) {\n         pollTimer.reset(maxPollIntervalMs);\n     }\n \n-    public void sentHeartbeat(long now) {\n+    boolean hasOngoing() {", "originalCommit": "7dcc8ffa6b1b6a7855486b30a731c89025f10450", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwODk1MQ==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404408951", "bodyText": "Sure", "author": "guozhangwang", "createdAt": "2020-04-06T21:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5MzI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NjY4MQ==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404396681", "bodyText": "Related to my comment in Heartbeat, but I think this reordering is problematic. It is possible that the heartbeat finishes before we reach this point because it is asynchronous. If we use a boolean in Heartbeat instead, then we can keep the original ordering.", "author": "hachikuji", "createdAt": "2020-04-06T21:22:54Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -1317,6 +1328,8 @@ public void onFailure(RuntimeException e) {\n                                     }\n                                 }\n                             });\n+\n+                            heartbeat.sentHeartbeat(now, heartbeatFuture);", "originalCommit": "7dcc8ffa6b1b6a7855486b30a731c89025f10450", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMjI2Ng==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404412266", "bodyText": "Cool, that makes sense, I will change it back.", "author": "guozhangwang", "createdAt": "2020-04-06T21:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NjY4MQ=="}], "type": "inlineReview"}, {"oid": "e84dd88db8643020a2acbf338e2d2868ba91cbdc", "url": "https://github.com/apache/kafka/commit/e84dd88db8643020a2acbf338e2d2868ba91cbdc", "message": "more comments addressed", "committedDate": "2020-04-06T21:58:12Z", "type": "commit"}, {"oid": "ac640c43ddc39b54f1fd848f4580866ed074d667", "url": "https://github.com/apache/kafka/commit/ac640c43ddc39b54f1fd848f4580866ed074d667", "message": "more comments", "committedDate": "2020-04-06T23:30:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2Nzc4NA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404467784", "bodyText": "nit: we could replace this with TestUtils.waitForCondition?", "author": "hachikuji", "createdAt": "2020-04-07T00:30:34Z", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java", "diffHunk": "@@ -465,6 +465,54 @@ public void testSyncGroupRequestWithFencedInstanceIdException() {\n         assertThrows(FencedInstanceIdException.class, () -> coordinator.ensureActiveGroup());\n     }\n \n+    @Test\n+    public void testHeartbeatUnknownMemberResponseDuringRebalancing() throws InterruptedException {\n+        setupCoordinator();\n+        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n+\n+        final int generation = 1;\n+\n+        mockClient.prepareResponse(joinGroupFollowerResponse(generation, memberId, JoinGroupRequest.UNKNOWN_MEMBER_ID, Errors.NONE));\n+        mockClient.prepareResponse(syncGroupResponse(Errors.NONE));\n+\n+        coordinator.ensureActiveGroup();\n+\n+        final AbstractCoordinator.Generation currGen = coordinator.generation();\n+\n+        // let the heartbeat request to send out a request\n+        mockTime.sleep(HEARTBEAT_INTERVAL_MS);\n+\n+        long startMs = System.currentTimeMillis();\n+        while (System.currentTimeMillis() - startMs < 1000 && !coordinator.heartbeat().hasInflight()) {", "originalCommit": "ac640c43ddc39b54f1fd848f4580866ed074d667", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2ODgyOQ==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404468829", "bodyText": "Can we get rid of this sleep since we're blocking below anyway?", "author": "hachikuji", "createdAt": "2020-04-07T00:34:14Z", "path": "core/src/test/scala/integration/kafka/api/PlaintextConsumerTest.scala", "diffHunk": "@@ -187,11 +187,15 @@ class PlaintextConsumerTest extends BaseConsumerTest {\n     assertEquals(1, listener.callsToAssigned)\n     assertEquals(0, listener.callsToRevoked)\n \n-    Thread.sleep(3500)\n+    // as long as we are part of max.poll no rebalance should be triggered\n+    Thread.sleep(500)\n+    assertEquals(1, listener.callsToAssigned)\n \n-    // we should fall out of the group and need to rebalance\n-    awaitRebalance(consumer, listener)\n-    assertEquals(2, listener.callsToAssigned)\n+    // after we extend longer than max.poll a rebalance should be triggered\n+    // NOTE we need to have a relatively much larger value than max.poll to let heartbeat expired for sure\n+    Thread.sleep(3000)", "originalCommit": "ac640c43ddc39b54f1fd848f4580866ed074d667", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyNjEyNw==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404526127", "bodyText": "Unfortunately we cannot since we need to wait for this amount of time \"without polling\", and then we should poll and see the rebalance being triggered.", "author": "guozhangwang", "createdAt": "2020-04-07T04:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2ODgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2ODk1OA==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404468958", "bodyText": "Can we replace this with waitUntilTrue as well?", "author": "hachikuji", "createdAt": "2020-04-07T00:34:45Z", "path": "core/src/test/scala/integration/kafka/api/PlaintextConsumerTest.scala", "diffHunk": "@@ -187,11 +187,15 @@ class PlaintextConsumerTest extends BaseConsumerTest {\n     assertEquals(1, listener.callsToAssigned)\n     assertEquals(0, listener.callsToRevoked)\n \n-    Thread.sleep(3500)\n+    // as long as we are part of max.poll no rebalance should be triggered\n+    Thread.sleep(500)", "originalCommit": "ac640c43ddc39b54f1fd848f4580866ed074d667", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyNjM3Mg==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404526372", "bodyText": "The num.assignment is already 1 here, and the first sleep is to verify that it did not change; after second thought I think I'll just remove it since without polling there would be no rebalance anyways.", "author": "guozhangwang", "createdAt": "2020-04-07T04:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2ODk1OA=="}], "type": "inlineReview"}, {"oid": "533e0803c106a462134573568ce3475c548df435", "url": "https://github.com/apache/kafka/commit/533e0803c106a462134573568ce3475c548df435", "message": "Merge branch '2.5' of https://github.com/apache/kafka into KMinor-2.5-investigation", "committedDate": "2020-04-07T04:15:22Z", "type": "commit"}, {"oid": "980151b260b0697eedc1062c6c2daa627110d3c0", "url": "https://github.com/apache/kafka/commit/980151b260b0697eedc1062c6c2daa627110d3c0", "message": "cleanup tests", "committedDate": "2020-04-07T04:26:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU1NzMzMQ==", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404557331", "bodyText": "nit: alignment looks a little off", "author": "hachikuji", "createdAt": "2020-04-07T06:10:01Z", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java", "diffHunk": "@@ -494,12 +492,12 @@ public void testHeartbeatUnknownMemberResponseDuringRebalancing() throws Interru\n \n         coordinator.requestRejoin();\n \n-        startMs = System.currentTimeMillis();\n-        while (System.currentTimeMillis() - startMs < 1000 && coordinator.heartbeat().hasInflight()) {\n-            Thread.sleep(10);\n-            // poll the client until the heartbeat response is received\n+        TestUtils.waitForCondition(() -> {\n             coordinator.ensureActiveGroup(new MockTime(1L).timer(100L));\n-        }\n+            return !coordinator.heartbeat().hasInflight();", "originalCommit": "980151b260b0697eedc1062c6c2daa627110d3c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c44f148e48f1bbed4e5717680b17c2b0b5c53044", "url": "https://github.com/apache/kafka/commit/c44f148e48f1bbed4e5717680b17c2b0b5c53044", "message": "checkstyle", "committedDate": "2020-04-07T17:54:21Z", "type": "commit"}]}