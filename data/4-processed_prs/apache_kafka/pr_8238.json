{"pr_number": 8238, "pr_title": "KAFKA-9130: KIP-518 Allow listing consumer groups per state", "pr_createdAt": "2020-03-06T16:31:31Z", "pr_url": "https://github.com/apache/kafka/pull/8238", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4OTg0NA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r393189844", "bodyText": "nit: We could set states only if it is not empty in order to avoid sending an empty array on the wire. It shouldn't alter the bahavior as an empty or null list result in not receiving the state from the broker.", "author": "dajac", "createdAt": "2020-03-16T17:22:22Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -2996,14 +2996,18 @@ void handleResponse(AbstractResponse abstractResponse) {\n                     runnable.call(new Call(\"listConsumerGroups\", deadline, new ConstantNodeIdProvider(node.id())) {\n                         @Override\n                         ListGroupsRequest.Builder createRequest(int timeoutMs) {\n-                            return new ListGroupsRequest.Builder(new ListGroupsRequestData());\n+                            List<String> states = options.states().orElse(Collections.emptySet())\n+                                    .stream()\n+                                    .map(s -> s.toString())\n+                                    .collect(Collectors.toList());\n+                            return new ListGroupsRequest.Builder(new ListGroupsRequestData().setStates(states));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEzNTI5Nw==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r395135297", "bodyText": "If states is empty, it's not serializing an empty array on the wire. If you look at the generated ListGroupsRequestData.write method, it does:\nif (!states.isEmpty()) {\n     _writable.writeUnsignedVarint(0);\n     _writable.writeUnsignedVarint(_cache.getArraySizeInBytes(this.states));\n     _writable.writeUnsignedVarint(states.size() + 1);", "author": "mimaison", "createdAt": "2020-03-19T15:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4OTg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3MDUzOA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r395470538", "bodyText": "Perfect! I did not know about this internal optimization. Thanks for pointing it out.", "author": "dajac", "createdAt": "2020-03-20T07:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4OTg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE5MDEwNQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r393190105", "bodyText": "Shouldn't the version be 4+ here?", "author": "dajac", "createdAt": "2020-03-16T17:22:48Z", "path": "clients/src/main/resources/common/message/ListGroupsRequest.json", "diffHunk": "@@ -20,8 +20,14 @@\n   // Version 1 and 2 are the same as version 0.\n   //\n   // Version 3 is the first flexible version.\n-  \"validVersions\": \"0-3\",\n+  //\n+  // Version 4 adds the States flexible field (KIP-518).\n+  \"validVersions\": \"0-4\",\n   \"flexibleVersions\": \"3+\",\n   \"fields\": [\n+    { \"name\": \"States\", \"type\": \"[]string\", \"versions\": \"4+\", \"tag\": 0, \"taggedVersions\": \"4+\",\n+      \"about\": \"The states of the groups we want to list\", \"fields\": [\n+      { \"name\": \"Name\", \"type\": \"string\", \"versions\": \"3+\", \"about\": \"The group state\" }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE5MDc3MA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r393190770", "bodyText": "nit: I suggest to complete the documentation here to clearly state that providing an empty or null array will result in getting all the groups.", "author": "dajac", "createdAt": "2020-03-16T17:23:55Z", "path": "clients/src/main/resources/common/message/ListGroupsRequest.json", "diffHunk": "@@ -20,8 +20,14 @@\n   // Version 1 and 2 are the same as version 0.\n   //\n   // Version 3 is the first flexible version.\n-  \"validVersions\": \"0-3\",\n+  //\n+  // Version 4 adds the States flexible field (KIP-518).\n+  \"validVersions\": \"0-4\",\n   \"flexibleVersions\": \"3+\",\n   \"fields\": [\n+    { \"name\": \"States\", \"type\": \"[]string\", \"versions\": \"4+\", \"tag\": 0, \"taggedVersions\": \"4+\",\n+      \"about\": \"The states of the groups we want to list\", \"fields\": [", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE5MzAzMA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r393193030", "bodyText": "nit: Alignment is weird.", "author": "dajac", "createdAt": "2020-03-16T17:27:47Z", "path": "clients/src/test/java/org/apache/kafka/clients/admin/KafkaAdminClientTest.java", "diffHunk": "@@ -1263,6 +1265,41 @@ public void testListConsumerGroupsMetadataFailure() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testListConsumerGroupsWithStates() throws Exception {\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(mockCluster(1, 0))) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(env.cluster(), Errors.NONE));\n+\n+            env.kafkaClient().prepareResponseFrom(\n+                    new ListGroupsResponse(\n+                            new ListGroupsResponseData()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE5ODcwMA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r393198700", "bodyText": "I would take the states.isEmpty out of the filter in order to avoid looping over the groups for nothing. What do you think?", "author": "dajac", "createdAt": "2020-03-16T17:37:16Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -804,12 +804,13 @@ class GroupCoordinator(val brokerId: Int,\n     }\n   }\n \n-  def handleListGroups(): (Errors, List[GroupOverview]) = {\n+  def handleListGroups(states: List[String]): (Errors, List[GroupOverview]) = {\n     if (!isActive.get) {\n       (Errors.COORDINATOR_NOT_AVAILABLE, List[GroupOverview]())\n     } else {\n       val errorCode = if (groupManager.isLoading) Errors.COORDINATOR_LOAD_IN_PROGRESS else Errors.NONE\n-      (errorCode, groupManager.currentGroups.map(_.overview).toList)\n+      // if states is empty, return all groups\n+      (errorCode, groupManager.currentGroups.filter(g => states.isEmpty || states.contains(g.summary.state)).map(_.overview).toList)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIwMzI2NA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r393203264", "bodyText": "Could we extract this block (or the whole response construction) into a local function in order to reuse it in the two paths?", "author": "dajac", "createdAt": "2020-03-16T17:44:48Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1360,27 +1360,37 @@ class KafkaApis(val requestChannel: RequestChannel,\n   }\n \n   def handleListGroupsRequest(request: RequestChannel.Request): Unit = {\n-    val (error, groups) = groupCoordinator.handleListGroups()\n+    val listGroupsRequest = request.body[ListGroupsRequest]\n+    val states = listGroupsRequest.data.states.asScala.toList\n+    val (error, groups) = groupCoordinator.handleListGroups(states)\n     if (authorize(request, DESCRIBE, CLUSTER, CLUSTER_NAME))\n       // With describe cluster access all groups are returned. We keep this alternative for backward compatibility.\n       sendResponseMaybeThrottle(request, requestThrottleMs =>\n         new ListGroupsResponse(new ListGroupsResponseData()\n             .setErrorCode(error.code)\n-            .setGroups(groups.map { group => new ListGroupsResponseData.ListedGroup()\n-              .setGroupId(group.groupId)\n-              .setProtocolType(group.protocolType)}.asJava\n-            )\n+            .setGroups(groups.map { group =>\n+                val listedGroup = new ListGroupsResponseData.ListedGroup()\n+                  .setGroupId(group.groupId)\n+                  .setProtocolType(group.protocolType)\n+                if (!states.isEmpty)\n+                  listedGroup.setGroupState(group.state.toString)\n+                listedGroup\n+            }.asJava)\n             .setThrottleTimeMs(requestThrottleMs)\n         ))\n     else {\n       val filteredGroups = groups.filter(group => authorize(request, DESCRIBE, GROUP, group.groupId))\n       sendResponseMaybeThrottle(request, requestThrottleMs =>\n         new ListGroupsResponse(new ListGroupsResponseData()\n           .setErrorCode(error.code)\n-          .setGroups(filteredGroups.map { group => new ListGroupsResponseData.ListedGroup()\n-            .setGroupId(group.groupId)\n-            .setProtocolType(group.protocolType)}.asJava\n-          )\n+          .setGroups(filteredGroups.map { group =>\n+              val listedGroup = new ListGroupsResponseData.ListedGroup()\n+                .setGroupId(group.groupId)\n+                .setProtocolType(group.protocolType)\n+              if (!states.isEmpty)\n+                listedGroup.setGroupState(group.state.toString)\n+              listedGroup", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIwMzU0OQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r393203549", "bodyText": "Could we add tests in KafkaApisTest to cover this one?", "author": "dajac", "createdAt": "2020-03-16T17:45:14Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1360,27 +1360,37 @@ class KafkaApis(val requestChannel: RequestChannel,\n   }\n \n   def handleListGroupsRequest(request: RequestChannel.Request): Unit = {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwOTU4NQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r393509585", "bodyText": "Could we add a test case which verifies that UnsupportedVersionException is thrown when states are provided but an older API is used? Side question, I haven't seen logic to raise it anywhere. Is it handled implicitly by the serialization layer?", "author": "dajac", "createdAt": "2020-03-17T08:24:02Z", "path": "clients/src/test/java/org/apache/kafka/clients/admin/KafkaAdminClientTest.java", "diffHunk": "@@ -1263,6 +1265,41 @@ public void testListConsumerGroupsMetadataFailure() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testListConsumerGroupsWithStates() throws Exception {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUwMDc1NQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r396500755", "bodyText": "Yes, the exception is raised in ListGroupsRequestData. We can't test it here as MockClient does not serialize requests. That said, it's a good point, I'll see where we can test this", "author": "mimaison", "createdAt": "2020-03-23T14:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwOTU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2NzY2NQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r399367665", "bodyText": "So, it will throw the following exception: UnsupportedVersionException(\"Attempted to write a non-default states at version \" + _version).  The message is a bit weird for an end user. Would it make sense to catch it in handleFailure and throw an exception with a better message?\nI wonder how such cases have been handled so far. I don't see any particular handling in the admin client at the moment.", "author": "dajac", "createdAt": "2020-03-27T15:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwOTU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODM4Nw==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r399768387", "bodyText": "I just stumbled upon this: \n  \n    \n      kafka/clients/src/main/java/org/apache/kafka/common/requests/OffsetFetchRequest.java\n    \n    \n         Line 84\n      in\n      169fa0e\n    \n    \n    \n    \n\n        \n          \n           throw new UnsupportedVersionException(\"The broker only supports OffsetFetchRequest \" + \n        \n    \n  \n\n\nWe could perhaps do something similar in our case.", "author": "dajac", "createdAt": "2020-03-29T09:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwOTU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQxMzgyMQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r409413821", "bodyText": "I was sort of avoiding doing this, as I believe we should rely on the underlying Data class instead of having such logic in the Request/Response classes. However, For consistency, let's do it and it will also simplify testing for UnsupportedVersionException.", "author": "mimaison", "createdAt": "2020-04-16T09:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwOTU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzNzQ2Nw==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r409437467", "bodyText": "Thanks. I agree that it is not perfect but it will provide a better error to the end user by explicitly handling it.", "author": "dajac", "createdAt": "2020-04-16T10:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwOTU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxMTQxNw==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r393511417", "bodyText": "I find the usage of UNKNOWN here is not intuitive because, at first, it gives the impression that a group can be in this state. I tend to think that using an Optional in ConsumerGroupListing would be better when we actually don't have the information. What do you think?", "author": "dajac", "createdAt": "2020-03-17T08:27:38Z", "path": "core/src/test/scala/integration/kafka/api/PlaintextAdminIntegrationTest.scala", "diffHunk": "@@ -1056,10 +1056,27 @@ class PlaintextAdminIntegrationTest extends BaseAdminIntegrationTest {\n           assertTrue(latch.await(30000, TimeUnit.MILLISECONDS))\n           // Test that we can list the new group.\n           TestUtils.waitUntilTrue(() => {\n-            val matching = client.listConsumerGroups.all.get().asScala.filter(_.groupId == testGroupId)\n-            matching.nonEmpty\n+            val matching = client.listConsumerGroups.all.get.asScala.filter(group =>\n+                group.groupId == testGroupId &&\n+                group.state == ConsumerGroupState.UNKNOWN)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYyNTc5MA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r398625790", "bodyText": "Yes that's a good idea! \ud83d\udc4d", "author": "mimaison", "createdAt": "2020-03-26T14:40:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxMTQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxMjczOA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r393512738", "bodyText": "nit: matching.nonEmpty is useless here.", "author": "dajac", "createdAt": "2020-03-17T08:30:18Z", "path": "core/src/test/scala/integration/kafka/api/PlaintextAdminIntegrationTest.scala", "diffHunk": "@@ -1056,10 +1056,27 @@ class PlaintextAdminIntegrationTest extends BaseAdminIntegrationTest {\n           assertTrue(latch.await(30000, TimeUnit.MILLISECONDS))\n           // Test that we can list the new group.\n           TestUtils.waitUntilTrue(() => {\n-            val matching = client.listConsumerGroups.all.get().asScala.filter(_.groupId == testGroupId)\n-            matching.nonEmpty\n+            val matching = client.listConsumerGroups.all.get.asScala.filter(group =>\n+                group.groupId == testGroupId &&\n+                group.state == ConsumerGroupState.UNKNOWN)\n+            matching.nonEmpty && matching.size == 1\n           }, s\"Expected to be able to list $testGroupId\")\n \n+          TestUtils.waitUntilTrue(() => {\n+            val options = new ListConsumerGroupsOptions().inAnyState\n+            val matching = client.listConsumerGroups(options).all.get.asScala.filter(group =>\n+                group.groupId == testGroupId &&\n+                group.state == ConsumerGroupState.STABLE)\n+            matching.nonEmpty && matching.size == 1", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxNTk0MA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r393515940", "bodyText": "It seems that any inexistent states provided by the user will default to UNKNOWN. I wonder if it wouldn't be better to be stricter and raise an error directly when the states provided are invalid. What do you think?", "author": "dajac", "createdAt": "2020-03-17T08:36:46Z", "path": "core/src/main/scala/kafka/admin/ConsumerGroupCommand.scala", "diffHunk": "@@ -84,6 +87,10 @@ object ConsumerGroupCommand extends Logging {\n     }\n   }\n \n+  def consumerGroupStatesFromString(input: String): List[ConsumerGroupState] = {\n+    return input.split(',').map(s => ConsumerGroupState.parse(s.trim.toLowerCase.capitalize)).toSet.toList\n+  }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYwNTg0MA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r398605840", "bodyText": "I agree, if invalid states are provided this should be treated as an error. I'll make the corresponding changes.", "author": "mimaison", "createdAt": "2020-03-26T14:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxNTk0MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwODI5NQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r399308295", "bodyText": "nit: The extra () are not required around group.groupState().isEmpty().", "author": "dajac", "createdAt": "2020-03-27T14:33:37Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -3052,14 +3052,21 @@ void handleResponse(AbstractResponse abstractResponse) {\n                     runnable.call(new Call(\"listConsumerGroups\", deadline, new ConstantNodeIdProvider(node.id())) {\n                         @Override\n                         ListGroupsRequest.Builder createRequest(int timeoutMs) {\n-                            return new ListGroupsRequest.Builder(new ListGroupsRequestData());\n+                            List<String> states = options.states().orElse(Collections.emptySet())\n+                                    .stream()\n+                                    .map(s -> s.toString())\n+                                    .collect(Collectors.toList());\n+                            return new ListGroupsRequest.Builder(new ListGroupsRequestData().setStates(states));\n                         }\n \n                         private void maybeAddConsumerGroup(ListGroupsResponseData.ListedGroup group) {\n                             String protocolType = group.protocolType();\n                             if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                 final String groupId = group.groupId();\n-                                final ConsumerGroupListing groupListing = new ConsumerGroupListing(groupId, protocolType.isEmpty());\n+                                final Optional<ConsumerGroupState> state = (group.groupState().isEmpty())", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2OTg1OQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r402469859", "bodyText": "thanks", "author": "edoardocomar", "createdAt": "2020-04-02T17:03:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwODI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyMTc5NQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r399321795", "bodyText": "This test remains valid, isn't it? Do we cover this somewhere else?", "author": "dajac", "createdAt": "2020-03-27T14:52:03Z", "path": "core/src/test/scala/unit/kafka/admin/DescribeConsumerGroupTest.scala", "diffHunk": "@@ -52,13 +51,6 @@ class DescribeConsumerGroupTest extends ConsumerGroupCommandTest {\n     }\n   }\n \n-  @Test(expected = classOf[OptionException])\n-  def testDescribeWithMultipleSubActions(): Unit = {\n-    TestUtils.createOffsetsTopic(zkClient, servers)\n-    val cgcArgs = Array(\"--bootstrap-server\", brokerList, \"--describe\", \"--group\", group, \"--members\", \"--state\")\n-    getConsumerGroupService(cgcArgs)\n-  }\n-", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2ODg4Mw==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r402468883", "bodyText": "By reusing the state flag for both describe and list, the test became invalid.\nThe invalid flag combination is only checked in the ConsumerGroupCommandOptions.checkArgs() method - used by the cli but already not covered by the test.\ntest coverage of checkArgs could be another PR ?", "author": "edoardocomar", "createdAt": "2020-04-02T17:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyMTc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzNjIyMg==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r409436222", "bodyText": "I would prefer to keep this tested somewhere in order to not reduce our test coverage. What about updating this test to call checkArg() and perhaps use grabConsoleOutput? Otherwise, let's add a similar unit test somewhere else.", "author": "dajac", "createdAt": "2020-04-16T10:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyMTc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUyMjMzOA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r409522338", "bodyText": "Because checkArgs() calls exit, it's a bit strange to test but I've readded this test", "author": "mimaison", "createdAt": "2020-04-16T12:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyMTc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyNTA1NA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r399325054", "bodyText": "Could we add few tests which rely on service.listGroups() to verify that --state and --state ... are wired up correctly?", "author": "dajac", "createdAt": "2020-03-27T14:56:28Z", "path": "core/src/test/scala/unit/kafka/admin/ListConsumerGroupTest.scala", "diffHunk": "@@ -44,4 +48,64 @@ class ListConsumerGroupTest extends ConsumerGroupCommandTest {\n     val cgcArgs = Array(\"--new-consumer\", \"--bootstrap-server\", brokerList, \"--list\")\n     getConsumerGroupService(cgcArgs)\n   }\n+\n+  @Test\n+  def testListConsumerGroupsWithStates(): Unit = {\n+    val simpleGroup = \"simple-group\"\n+    addSimpleGroupExecutor(group = simpleGroup)\n+    addConsumerGroupExecutor(numConsumers = 1)\n+\n+    val cgcArgs = Array(\"--bootstrap-server\", brokerList, \"--list\", \"--state\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ1NjIyOQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r409456229", "bodyText": "Yes good idea, I've added testListGroupCommand() that covers both cases", "author": "mimaison", "createdAt": "2020-04-16T10:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyNTA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzMjI3Ng==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r399332276", "bodyText": "nit: all groups are returned without their state?", "author": "dajac", "createdAt": "2020-03-27T15:06:07Z", "path": "clients/src/main/resources/common/message/ListGroupsRequest.json", "diffHunk": "@@ -20,8 +20,14 @@\n   // Version 1 and 2 are the same as version 0.\n   //\n   // Version 3 is the first flexible version.\n-  \"validVersions\": \"0-3\",\n+  //\n+  // Version 4 adds the States flexible field (KIP-518).\n+  \"validVersions\": \"0-4\",\n   \"flexibleVersions\": \"3+\",\n   \"fields\": [\n+    { \"name\": \"States\", \"type\": \"[]string\", \"versions\": \"4+\", \"tag\": 0, \"taggedVersions\": \"4+\",\n+      \"about\": \"The states of the groups we want to list. If empty, all groups are returned.\", \"fields\": [", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4Nzg4Mg==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r402487882", "bodyText": "yes thanks", "author": "edoardocomar", "createdAt": "2020-04-02T17:31:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzMjI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1MjAyMA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r399352020", "bodyText": "This sounds a bit heavy to verify that the serialization effectively returns an UnsupportedVersionException.  What about doing this in RequestResponseTest instead?", "author": "dajac", "createdAt": "2020-03-27T15:33:58Z", "path": "core/src/test/scala/unit/kafka/server/ListGroupsRequestTest.scala", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+  * Licensed to the Apache Software Foundation (ASF) under one or more\n+  * contributor license agreements.  See the NOTICE file distributed with\n+  * this work for additional information regarding copyright ownership.\n+  * The ASF licenses this file to You under the Apache License, Version 2.0\n+  * (the \"License\"); you may not use this file except in compliance with\n+  * the License.  You may obtain a copy of the License at\n+  *\n+  *    http://www.apache.org/licenses/LICENSE-2.0\n+  *\n+  * Unless required by applicable law or agreed to in writing, software\n+  * distributed under the License is distributed on an \"AS IS\" BASIS,\n+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  * See the License for the specific language governing permissions and\n+  * limitations under the License.\n+  */\n+package kafka.server\n+\n+import org.apache.kafka.common.errors.UnsupportedVersionException\n+import org.apache.kafka.common.message.ListGroupsRequestData\n+import org.apache.kafka.common.requests.ListGroupsRequest\n+import org.apache.kafka.common.requests.ListGroupsResponse\n+\n+import java.util.Arrays\n+\n+import org.junit.Assert._\n+import org.junit.Test\n+\n+class ListGroupsRequestTest extends BaseRequestTest {\n+  override val brokerCount: Int = 1\n+\n+  @Test(expected=classOf[UnsupportedVersionException])\n+  def testListGroupsRequestOldVersionWithStates(): Unit = {\n+    val request = new ListGroupsRequest.Builder(\n+        new ListGroupsRequestData().setStates(Arrays.asList(\"Stable\"))\n+    ).build(3)\n+\n+    connectAndReceive[ListGroupsResponse](request, destination = controllerSocketServer)\n+\n+  }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ1NTY4NA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r409455684", "bodyText": "Yes it was indeed pretty heavy. I've made ListGroupsRequest.Builder.build() throw ( as suggested in #8238 (comment) and this is now tested in RequestResponseTest", "author": "mimaison", "createdAt": "2020-04-16T10:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1MjAyMA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4MjEwNQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r412182105", "bodyText": "nit: return can be omitted here.", "author": "dajac", "createdAt": "2020-04-21T13:25:49Z", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1554,50 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testListGroupsRequest(): Unit = {\n+    val overviews = List(\n+      GroupOverview(\"group1\", \"protocol1\", \"Stable\"),\n+      GroupOverview(\"goupp2\", \"qwerty\", \"Empty\")\n+    )\n+    val response = listGroupRequest(Option.empty, overviews)\n+    assertEquals(2, response.data.groups.size)\n+    assertEquals(\"\", response.data.groups.get(0).groupState)\n+    assertEquals(\"\", response.data.groups.get(1).groupState)\n+  }\n+\n+  @Test\n+  def testListGroupsRequestWithState(): Unit = {\n+    val overviews = List(\n+      GroupOverview(\"group1\", \"protocol1\", \"Stable\")\n+    )\n+    val response = listGroupRequest(Option.apply(\"Stable\"), overviews)\n+    assertEquals(1, response.data.groups.size)\n+    assertEquals(\"Stable\", response.data.groups.get(0).groupState)\n+  }\n+\n+  private def listGroupRequest(state: Option[String], overviews: List[GroupOverview]): ListGroupsResponse = {\n+    EasyMock.reset(groupCoordinator, clientRequestQuotaManager, requestChannel)\n+\n+    val data = new ListGroupsRequestData()\n+    if (state.isDefined)\n+      data.setStates(Collections.singletonList(state.get))\n+    val listGroupsRequest = new ListGroupsRequest.Builder(data).build()\n+    val requestChannelRequest = buildRequest(listGroupsRequest)\n+\n+    val capturedResponse = expectNoThrottling()\n+    val expectedStates = if (state.isDefined) List(state.get) else List()\n+    EasyMock.expect(groupCoordinator.handleListGroups(expectedStates))\n+      .andReturn((Errors.NONE, overviews))\n+    EasyMock.replay(groupCoordinator, clientRequestQuotaManager, requestChannel)\n+\n+    createKafkaApis().handleListGroupsRequest(requestChannelRequest)\n+\n+    val response = readResponse(ApiKeys.LIST_GROUPS, listGroupsRequest, capturedResponse).asInstanceOf[ListGroupsResponse]\n+    assertEquals(Errors.NONE.code, response.data.errorCode)\n+    return response", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4NjUwMQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r412186501", "bodyText": "nit: We tend to use None instead of Option.empty.", "author": "dajac", "createdAt": "2020-04-21T13:31:18Z", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1554,50 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testListGroupsRequest(): Unit = {\n+    val overviews = List(\n+      GroupOverview(\"group1\", \"protocol1\", \"Stable\"),\n+      GroupOverview(\"goupp2\", \"qwerty\", \"Empty\")\n+    )\n+    val response = listGroupRequest(Option.empty, overviews)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4NzAzOQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r412187039", "bodyText": "nit: We tend to use Some(\"Stable\") instead of Option.apply.", "author": "dajac", "createdAt": "2020-04-21T13:31:52Z", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1554,50 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testListGroupsRequest(): Unit = {\n+    val overviews = List(\n+      GroupOverview(\"group1\", \"protocol1\", \"Stable\"),\n+      GroupOverview(\"goupp2\", \"qwerty\", \"Empty\")\n+    )\n+    val response = listGroupRequest(Option.empty, overviews)\n+    assertEquals(2, response.data.groups.size)\n+    assertEquals(\"\", response.data.groups.get(0).groupState)\n+    assertEquals(\"\", response.data.groups.get(1).groupState)\n+  }\n+\n+  @Test\n+  def testListGroupsRequestWithState(): Unit = {\n+    val overviews = List(\n+      GroupOverview(\"group1\", \"protocol1\", \"Stable\")\n+    )\n+    val response = listGroupRequest(Option.apply(\"Stable\"), overviews)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5MzIwNQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r412193205", "bodyText": "When I see this, I do wonder if it wouldn't be better to make the GroupState field in the response nullable and to set it to null when the state is not provided. Having to handle empty stings is a bit annoying. What do you think?", "author": "dajac", "createdAt": "2020-04-21T13:39:51Z", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1554,50 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testListGroupsRequest(): Unit = {\n+    val overviews = List(\n+      GroupOverview(\"group1\", \"protocol1\", \"Stable\"),\n+      GroupOverview(\"goupp2\", \"qwerty\", \"Empty\")\n+    )\n+    val response = listGroupRequest(Option.empty, overviews)\n+    assertEquals(2, response.data.groups.size)\n+    assertEquals(\"\", response.data.groups.get(0).groupState)\n+    assertEquals(\"\", response.data.groups.get(1).groupState)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcxNzg0OA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r413717848", "bodyText": "Yes that's a good idea", "author": "mimaison", "createdAt": "2020-04-23T10:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5MzIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5NzcxMQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r412197711", "bodyText": "We should build a string here: mutuallyExclusiveOpts..mkString(\", \")", "author": "dajac", "createdAt": "2020-04-21T13:45:23Z", "path": "core/src/main/scala/kafka/admin/ConsumerGroupCommand.scala", "diffHunk": "@@ -1024,6 +1071,11 @@ object ConsumerGroupCommand extends Logging {\n         if (!options.has(groupOpt) && !options.has(allGroupsOpt))\n           CommandLineUtils.printUsageAndDie(parser,\n             s\"Option $describeOpt takes one of these options: ${allGroupSelectionScopeOpts.mkString(\", \")}\")\n+        val mutuallyExclusiveOpts: Set[OptionSpec[_]] = Set(membersOpt, offsetsOpt, stateOpt)\n+        if (mutuallyExclusiveOpts.toList.map(o => if (options.has(o)) 1 else 0).sum > 1) {\n+          CommandLineUtils.printUsageAndDie(parser,\n+            s\"Option $describeOpt takes at most one of these options: $mutuallyExclusiveOpts\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5OTAyMA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r412199020", "bodyText": "nit: return can be omitted here.", "author": "dajac", "createdAt": "2020-04-21T13:46:57Z", "path": "core/src/main/scala/kafka/admin/ConsumerGroupCommand.scala", "diffHunk": "@@ -84,6 +87,15 @@ object ConsumerGroupCommand extends Logging {\n     }\n   }\n \n+  def consumerGroupStatesFromString(input: String): List[ConsumerGroupState] = {\n+    val parsedStates = input.split(',').map(s => ConsumerGroupState.parse(s.trim.toLowerCase.capitalize)).toSet.toList\n+    if (parsedStates.contains(ConsumerGroupState.UNKNOWN)) {\n+      val validStates = ConsumerGroupState.values().filter(_ != ConsumerGroupState.UNKNOWN)\n+      throw new IllegalArgumentException(s\"Invalid state list '$input'. Valid states are: ${validStates.mkString(\",\")}\")\n+    }\n+    return parsedStates", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5OTk1NA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r412199954", "bodyText": "nit: add a space after ,", "author": "dajac", "createdAt": "2020-04-21T13:48:05Z", "path": "core/src/main/scala/kafka/admin/ConsumerGroupCommand.scala", "diffHunk": "@@ -84,6 +87,15 @@ object ConsumerGroupCommand extends Logging {\n     }\n   }\n \n+  def consumerGroupStatesFromString(input: String): List[ConsumerGroupState] = {\n+    val parsedStates = input.split(',').map(s => ConsumerGroupState.parse(s.trim.toLowerCase.capitalize)).toSet.toList\n+    if (parsedStates.contains(ConsumerGroupState.UNKNOWN)) {\n+      val validStates = ConsumerGroupState.values().filter(_ != ConsumerGroupState.UNKNOWN)\n+      throw new IllegalArgumentException(s\"Invalid state list '$input'. Valid states are: ${validStates.mkString(\",\")}\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyMjUzNg==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r412222536", "bodyText": "I tried to run the tool to see how this behave. It is a bit annoying that we are not consistent with the other command line argument errors.\nIt looks like this:\n$ ./bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list --state aa\n\nError: Executing consumer group command failed due to Invalid state list 'aa'. Valid states are: PreparingRebalance,CompletingRebalance,Stable,Dead,Empty\njava.lang.IllegalArgumentException: Invalid state list 'aa'. Valid states are: PreparingRebalance,CompletingRebalance,Stable,Dead,Empty\n\tat kafka.admin.ConsumerGroupCommand$.consumerGroupStatesFromString(ConsumerGroupCommand.scala:94)\n\tat kafka.admin.ConsumerGroupCommand$ConsumerGroupService.listGroups(ConsumerGroupCommand.scala:199)\n\tat kafka.admin.ConsumerGroupCommand$.main(ConsumerGroupCommand.scala:66)\n\tat kafka.admin.ConsumerGroupCommand.main(ConsumerGroupCommand.scala)`\n\nI have also noticed that we don't handle exceptions thrown when a argument is not recognized:\n$ ./bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list --stat\n\nException in thread \"main\" joptsimple.UnrecognizedOptionException: stat is not a recognized option\n\tat joptsimple.OptionException.unrecognizedOption(OptionException.java:108)\n\tat joptsimple.OptionParser.handleLongOptionToken(OptionParser.java:510)\n\tat joptsimple.OptionParserState$2.handleArgument(OptionParserState.java:56)\n\tat joptsimple.OptionParser.parse(OptionParser.java:396)\n\tat kafka.admin.ConsumerGroupCommand$ConsumerGroupCommandOptions.<init>(ConsumerGroupCommand.scala:1058)\n\tat kafka.admin.ConsumerGroupCommand$.main(ConsumerGroupCommand.scala:51)\n\tat kafka.admin.ConsumerGroupCommand.main(ConsumerGroupCommand.scala)\n\nWhereas, when we do handle things, we print an error and print out the help:\n$ ./bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group bla --state --members\n\nOption [describe] takes at most one of these options: Set([members], [offsets], [state])\nOption                                  Description\n------                                  -----------\n--all-groups                            Apply to all consumer groups.\n--all-topics                            Consider all topics assigned to a\n                                          group in the `reset-offsets` process.\n--bootstrap-server <String: server to   REQUIRED: The server(s) to connect to.\n  connect to>\n--by-duration <String: duration>        Reset offsets to offset by duration\n                                          from current timestamp. Format:\n                                          'PnDTnHnMnS'\n...\n\nI wonder if we could catch OptionException and IllegalArgumentException in the main to print out better error message for the end user.", "author": "dajac", "createdAt": "2020-04-21T14:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5OTk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5NDExOA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r413794118", "bodyText": "I've added the missing space after the comma. I'll play a bit more with the error handling and see what we can do", "author": "mimaison", "createdAt": "2020-04-23T12:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5OTk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNDM4NA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r418314384", "bodyText": "I've added logic to address the top issue.\nThe second one affects most tools and would require much larger changes so probably best to address in a different PR.", "author": "mimaison", "createdAt": "2020-04-30T22:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5OTk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNTYyNQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r420625625", "bodyText": "Thanks!", "author": "dajac", "createdAt": "2020-05-06T08:30:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5OTk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIwMTkxOA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r412201918", "bodyText": "nit: I suppose that the last conversion .toList is not necessary.", "author": "dajac", "createdAt": "2020-04-21T13:50:27Z", "path": "core/src/main/scala/kafka/admin/ConsumerGroupCommand.scala", "diffHunk": "@@ -178,12 +190,44 @@ object ConsumerGroupCommand extends Logging {\n       } else None\n     }\n \n-    def listGroups(): List[String] = {\n+    def listGroups(): Unit = {\n+      if (opts.options.has(opts.stateOpt)) {\n+           val stateValue = opts.options.valueOf(opts.stateOpt)\n+           val states = if (stateValue == null || stateValue.isEmpty)\n+             allStates\n+           else\n+             consumerGroupStatesFromString(stateValue)\n+           val listings = listConsumerGroupsWithState(states)\n+           printGroupStates(listings.map(e => (e.groupId, e.state.get.toString)).toList)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIxMjU3OA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r412212578", "bodyText": "I didn't realize that checkArgs was exiting when an error occurs. The way we use printUsageAndDie everywhere is a bit annoying and makes testing hard. I think that we should throw proper exception and catch them in the main function instead. I suppose that this is something for another PR though...", "author": "dajac", "createdAt": "2020-04-21T14:03:04Z", "path": "core/src/test/scala/unit/kafka/admin/DescribeConsumerGroupTest.scala", "diffHunk": "@@ -52,11 +51,25 @@ class DescribeConsumerGroupTest extends ConsumerGroupCommandTest {\n     }\n   }\n \n-  @Test(expected = classOf[OptionException])\n+  @Test\n   def testDescribeWithMultipleSubActions(): Unit = {\n-    TestUtils.createOffsetsTopic(zkClient, servers)\n+    var exitStatus: Option[Int] = None\n+    var exitMessage: Option[String] = None\n+    Exit.setExitProcedure { (status, err) =>\n+      exitStatus = Some(status)\n+      exitMessage = err\n+      throw new RuntimeException\n+    }\n     val cgcArgs = Array(\"--bootstrap-server\", brokerList, \"--describe\", \"--group\", group, \"--members\", \"--state\")\n-    getConsumerGroupService(cgcArgs)\n+    try {\n+      ConsumerGroupCommand.main(cgcArgs)\n+    } catch {\n+      case e: RuntimeException => //expected\n+    } finally {\n+      Exit.resetExitProcedure()\n+    }\n+    assertEquals(Some(1), exitStatus)\n+    assertTrue(exitMessage.get.contains(\"Option [describe] takes at most one of these options\"))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0NzcyOA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r413647728", "bodyText": "\ud83d\udc4d", "author": "mimaison", "createdAt": "2020-04-23T09:10:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIxMjU3OA=="}], "type": "inlineReview"}, {"oid": "88e7a0ca4f15c3816c9f49ef1e4ffc0c1d36f4cc", "url": "https://github.com/apache/kafka/commit/88e7a0ca4f15c3816c9f49ef1e4ffc0c1d36f4cc", "message": "KAFKA-9130: KIP-518 Allow listing consumer groups per state\n\nCo-authored-by: Mickael Maison <mickael.maison@gmail.com>\nCo-authored-by: Edoardo Comar <ecomar@uk.ibm.com>", "committedDate": "2020-04-30T14:28:24Z", "type": "commit"}, {"oid": "143514cc2a880e2896085cdeb34cc697d62296ab", "url": "https://github.com/apache/kafka/commit/143514cc2a880e2896085cdeb34cc697d62296ab", "message": "Add test in admin e2e", "committedDate": "2020-04-30T14:28:24Z", "type": "commit"}, {"oid": "badbc1a40e59fdb56ba53c3f9c8633a705da085d", "url": "https://github.com/apache/kafka/commit/badbc1a40e59fdb56ba53c3f9c8633a705da085d", "message": "First pass at addressing feedback", "committedDate": "2020-04-30T14:39:37Z", "type": "commit"}, {"oid": "b243a61df164637072453ec1a32ea1cdbfdb4ba1", "url": "https://github.com/apache/kafka/commit/b243a61df164637072453ec1a32ea1cdbfdb4ba1", "message": "Addressed comments", "committedDate": "2020-04-30T14:39:37Z", "type": "commit"}, {"oid": "145b6897390097d93dfedc52036ac2e48906e96a", "url": "https://github.com/apache/kafka/commit/145b6897390097d93dfedc52036ac2e48906e96a", "message": "addressed a couple of comments and CLI's list state formatting", "committedDate": "2020-04-30T14:39:37Z", "type": "commit"}, {"oid": "a0247b048d6a7f70fb225c82557bec300c69a6a7", "url": "https://github.com/apache/kafka/commit/a0247b048d6a7f70fb225c82557bec300c69a6a7", "message": "Address latest feedback", "committedDate": "2020-04-30T14:39:37Z", "type": "commit"}, {"oid": "4bed4d3b2a2f45dc9993bb511bfb6deeb3330585", "url": "https://github.com/apache/kafka/commit/4bed4d3b2a2f45dc9993bb511bfb6deeb3330585", "message": "testDescribeWithMultipleSubActions", "committedDate": "2020-04-30T14:39:37Z", "type": "commit"}, {"oid": "d6102e8f3025f70004bb3081785708af76f2855e", "url": "https://github.com/apache/kafka/commit/d6102e8f3025f70004bb3081785708af76f2855e", "message": "Address feedback", "committedDate": "2020-04-30T14:39:37Z", "type": "commit"}, {"oid": "d6102e8f3025f70004bb3081785708af76f2855e", "url": "https://github.com/apache/kafka/commit/d6102e8f3025f70004bb3081785708af76f2855e", "message": "Address feedback", "committedDate": "2020-04-30T14:39:37Z", "type": "forcePushed"}, {"oid": "5854e560da240c68f48b44996f085d37aca9d254", "url": "https://github.com/apache/kafka/commit/5854e560da240c68f48b44996f085d37aca9d254", "message": "Improve error reporting", "committedDate": "2020-04-30T20:06:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2NDMyOA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r426864328", "bodyText": "Probably worth adding a comment about broker compatibility with this API.", "author": "hachikuji", "createdAt": "2020-05-18T20:04:11Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java", "diffHunk": "@@ -26,4 +31,34 @@\n  */\n @InterfaceStability.Evolving\n public class ListConsumerGroupsOptions extends AbstractOptions<ListConsumerGroupsOptions> {\n+\n+    private Optional<Set<ConsumerGroupState>> states = Optional.empty();\n+\n+    /**\n+     * Only groups in these states will be returned by listConsumerGroups()", "originalCommit": "5854e560da240c68f48b44996f085d37aca9d254", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3OTE4MQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r432179181", "bodyText": "Can you address this comment?", "author": "hachikuji", "createdAt": "2020-05-28T23:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2NDMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2Nzc3NQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r426867775", "bodyText": "Sorry I missed this from the discussion, but why are we bumping the version if we are only adding tagged fields? Is it so that we can detect whether the capability is supported? If so, then I wonder why we don't make this a regular field.", "author": "hachikuji", "createdAt": "2020-05-18T20:11:43Z", "path": "clients/src/main/resources/common/message/ListGroupsRequest.json", "diffHunk": "@@ -20,8 +20,14 @@\n   // Version 1 and 2 are the same as version 0.\n   //\n   // Version 3 is the first flexible version.\n-  \"validVersions\": \"0-3\",\n+  //\n+  // Version 4 adds the States flexible field (KIP-518).\n+  \"validVersions\": \"0-4\",\n   \"flexibleVersions\": \"3+\",\n   \"fields\": [\n+    { \"name\": \"States\", \"type\": \"[]string\", \"versions\": \"4+\", \"tag\": 0, \"taggedVersions\": \"4+\",", "originalCommit": "5854e560da240c68f48b44996f085d37aca9d254", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEzMzUyOQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r429133529", "bodyText": "Yes the version bump is necessary to detect if this field was supported.\nAs we're bumping the version and as you said in #8238 (comment) the overhead of the extra field on this API is not a concern, it's probably simpler to use a regular field.", "author": "mimaison", "createdAt": "2020-05-22T09:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2Nzc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2ODc3Nw==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r426868777", "bodyText": "Hmm.. We have an UNKNOWN state in ConsumerGroupState in case the group coordinator adds a new state that the client isn't aware of. Currently we're going to pass this through the request, which is a bit odd. Furthermore, if the coordinator does add new states, we will be unable to see them using this API. I think it might be better to use a null list of states in the request to indicate that any state is needed.", "author": "hachikuji", "createdAt": "2020-05-18T20:13:50Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java", "diffHunk": "@@ -26,4 +31,34 @@\n  */\n @InterfaceStability.Evolving\n public class ListConsumerGroupsOptions extends AbstractOptions<ListConsumerGroupsOptions> {\n+\n+    private Optional<Set<ConsumerGroupState>> states = Optional.empty();\n+\n+    /**\n+     * Only groups in these states will be returned by listConsumerGroups()\n+     * If not set, all groups are returned without their states\n+     * throw IllegalArgumentException if states is empty\n+     */\n+    public ListConsumerGroupsOptions inStates(Set<ConsumerGroupState> states) {\n+        if (states == null || states.isEmpty()) {\n+            throw new IllegalArgumentException(\"states should not be null or empty\");\n+        }\n+        this.states = Optional.of(states);\n+        return this;\n+    }\n+\n+    /**\n+     * All groups with their states will be returned by listConsumerGroups()\n+     */\n+    public ListConsumerGroupsOptions inAnyState() {\n+        this.states = Optional.of(EnumSet.allOf(ConsumerGroupState.class));", "originalCommit": "5854e560da240c68f48b44996f085d37aca9d254", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEzMTAwMg==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r429131002", "bodyText": "That's a good point so I agree, it makes sense to return all states when null (or an empty list) is used.", "author": "mimaison", "createdAt": "2020-05-22T09:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2ODc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEzNjA1OA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r429136058", "bodyText": "This can also be argued for the state value in the response. Currently ConsumerGroupDescription stores the state as ConsumerGroupState so states the client isn't aware of are mapped to UNKNOWN so I'm doing the same in ConsumerGroupListing.", "author": "mimaison", "createdAt": "2020-05-22T09:16:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2ODc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2OTc1NQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r426869755", "bodyText": "Why don't we always return the state? I don't think overhead is a huge concern for an api like this.", "author": "hachikuji", "createdAt": "2020-05-18T20:15:54Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1397,29 +1398,32 @@ class KafkaApis(val requestChannel: RequestChannel,\n   }\n \n   def handleListGroupsRequest(request: RequestChannel.Request): Unit = {\n-    val (error, groups) = groupCoordinator.handleListGroups()\n+    val listGroupsRequest = request.body[ListGroupsRequest]\n+    val states = listGroupsRequest.data.states.asScala.toList\n+\n+    def createResponse(throttleMs: Int, groups: List[GroupOverview], error: Errors): AbstractResponse = {\n+       new ListGroupsResponse(new ListGroupsResponseData()\n+            .setErrorCode(error.code)\n+            .setGroups(groups.map { group =>\n+                val listedGroup = new ListGroupsResponseData.ListedGroup()\n+                  .setGroupId(group.groupId)\n+                  .setProtocolType(group.protocolType)\n+                if (!states.isEmpty)", "originalCommit": "5854e560da240c68f48b44996f085d37aca9d254", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1f032e71c50411ecff2d99f86e523e02dd560c32", "url": "https://github.com/apache/kafka/commit/1f032e71c50411ecff2d99f86e523e02dd560c32", "message": "Addressed feedback\n\n- Switch to use regular fields instead of tagged fields\n- Empty/null state filter now means all states", "committedDate": "2020-05-22T08:57:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU2ODkwOQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431568909", "bodyText": "Hmm, seems this is a public class. Would it be safer to add a constructor overload?", "author": "hachikuji", "createdAt": "2020-05-28T04:02:14Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java", "diffHunk": "@@ -17,22 +17,30 @@\n \n package org.apache.kafka.clients.admin;\n \n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.kafka.common.ConsumerGroupState;\n+\n /**\n  * A listing of a consumer group in the cluster.\n  */\n public class ConsumerGroupListing {\n     private final String groupId;\n     private final boolean isSimpleConsumerGroup;\n+    private final Optional<ConsumerGroupState> state;\n \n     /**\n      * Create an instance with the specified parameters.\n      *\n      * @param groupId Group Id\n      * @param isSimpleConsumerGroup If consumer group is simple or not.\n+     * @param state The state of the consumer group\n      */\n-    public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup) {\n+    public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup, Optional<ConsumerGroupState> state) {", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU2OTAwOA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431569008", "bodyText": "nit: maybe use requireNonNull?", "author": "hachikuji", "createdAt": "2020-05-28T04:02:38Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java", "diffHunk": "@@ -17,22 +17,30 @@\n \n package org.apache.kafka.clients.admin;\n \n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.kafka.common.ConsumerGroupState;\n+\n /**\n  * A listing of a consumer group in the cluster.\n  */\n public class ConsumerGroupListing {\n     private final String groupId;\n     private final boolean isSimpleConsumerGroup;\n+    private final Optional<ConsumerGroupState> state;\n \n     /**\n      * Create an instance with the specified parameters.\n      *\n      * @param groupId Group Id\n      * @param isSimpleConsumerGroup If consumer group is simple or not.\n+     * @param state The state of the consumer group\n      */\n-    public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup) {\n+    public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup, Optional<ConsumerGroupState> state) {\n         this.groupId = groupId;\n         this.isSimpleConsumerGroup = isSimpleConsumerGroup;\n+        this.state = state;", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5NTU5NA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431595594", "bodyText": "nit: I think the parenthesis are unnecessary?", "author": "hachikuji", "createdAt": "2020-05-28T05:50:07Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -3052,14 +3052,23 @@ void handleResponse(AbstractResponse abstractResponse) {\n                     runnable.call(new Call(\"listConsumerGroups\", deadline, new ConstantNodeIdProvider(node.id())) {\n                         @Override\n                         ListGroupsRequest.Builder createRequest(int timeoutMs) {\n-                            return new ListGroupsRequest.Builder(new ListGroupsRequestData());\n+                            List<String> states = (options.states().isEmpty())", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5NjA1Ng==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431596056", "bodyText": "Do we need this API? Seems this is the default behavior.", "author": "hachikuji", "createdAt": "2020-05-28T05:51:31Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/ListConsumerGroupsOptions.java", "diffHunk": "@@ -26,4 +31,30 @@\n  */\n @InterfaceStability.Evolving\n public class ListConsumerGroupsOptions extends AbstractOptions<ListConsumerGroupsOptions> {\n+\n+    private Set<ConsumerGroupState> states = Collections.emptySet();\n+\n+    /**\n+     * Only groups in these states will be returned by listConsumerGroups()\n+     * If not set, all groups are returned with their states\n+     */\n+    public ListConsumerGroupsOptions inStates(Set<ConsumerGroupState> states) {\n+        this.states = (states == null) ? Collections.emptySet() : new HashSet<>(states);\n+        return this;\n+    }\n+\n+    /**\n+     * All groups with their states will be returned by listConsumerGroups()\n+     */\n+    public ListConsumerGroupsOptions inAnyState() {", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5Njc2Mw==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431596763", "bodyText": "Is it intentional to use nullable versions 0+? I'm surprised the generator doesn't fail.", "author": "hachikuji", "createdAt": "2020-05-28T05:53:44Z", "path": "clients/src/main/resources/common/message/ListGroupsResponse.json", "diffHunk": "@@ -34,7 +36,9 @@\n       { \"name\": \"GroupId\", \"type\": \"string\", \"versions\": \"0+\", \"entityType\": \"groupId\",\n         \"about\": \"The group ID.\" },\n       { \"name\": \"ProtocolType\", \"type\": \"string\", \"versions\": \"0+\",\n-        \"about\": \"The group protocol type.\" }\n+        \"about\": \"The group protocol type.\" },\n+      { \"name\": \"GroupState\", \"type\": \"string\", \"versions\": \"4+\", \"nullableVersions\": \"0+\", \"ignorable\": true, \"default\": \"null\",", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5ODQ0MA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431598440", "bodyText": "It's a little odd that we go on and match the request if it is expected to raise an unsupported version error. Do we have test cases that depend on this? In NetworkClient, if we hit an unsupported version error, the response body would be null.", "author": "hachikuji", "createdAt": "2020-05-28T05:59:12Z", "path": "clients/src/test/java/org/apache/kafka/clients/MockClient.java", "diffHunk": "@@ -215,15 +215,22 @@ public void send(ClientRequest request, long now) {\n             AbstractRequest.Builder<?> builder = request.requestBuilder();\n             short version = nodeApiVersions.latestUsableVersion(request.apiKey(), builder.oldestAllowedVersion(),\n                     builder.latestAllowedVersion());\n-            AbstractRequest abstractRequest = request.requestBuilder().build(version);\n-            if (!futureResp.requestMatcher.matches(abstractRequest))\n-                throw new IllegalStateException(\"Request matcher did not match next-in-line request \" + abstractRequest + \" with prepared response \" + futureResp.responseBody);\n \n             UnsupportedVersionException unsupportedVersionException = null;\n             if (futureResp.isUnsupportedRequest)\n-                unsupportedVersionException = new UnsupportedVersionException(\"Api \" +\n-                        request.apiKey() + \" with version \" + version);\n-\n+                unsupportedVersionException = new UnsupportedVersionException(\n+                        \"Api \" + request.apiKey() + \" with version \" + version);\n+            try {\n+                AbstractRequest abstractRequest = request.requestBuilder().build(version);", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5OTIzNg==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431599236", "bodyText": "nit: you can use TestUtils.assertFutureThrows", "author": "hachikuji", "createdAt": "2020-05-28T06:01:37Z", "path": "clients/src/test/java/org/apache/kafka/clients/admin/KafkaAdminClientTest.java", "diffHunk": "@@ -1312,6 +1324,79 @@ public void testListConsumerGroupsMetadataFailure() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testListConsumerGroupsWithStates() throws Exception {\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(mockCluster(1, 0))) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(env.cluster(), Errors.NONE));\n+\n+            env.kafkaClient().prepareResponseFrom(\n+                new ListGroupsResponse(new ListGroupsResponseData()\n+                    .setErrorCode(Errors.NONE.code())\n+                    .setGroups(Arrays.asList(\n+                            new ListGroupsResponseData.ListedGroup()\n+                                .setGroupId(\"group-1\")\n+                                .setProtocolType(ConsumerProtocol.PROTOCOL_TYPE)\n+                                .setGroupState(\"Stable\"),\n+                            new ListGroupsResponseData.ListedGroup()\n+                                .setGroupId(\"group-2\")\n+                                .setGroupState(\"Empty\")))),\n+                env.cluster().nodeById(0));\n+\n+            final ListConsumerGroupsOptions options = new ListConsumerGroupsOptions().inAnyState();\n+            final ListConsumerGroupsResult result = env.adminClient().listConsumerGroups(options);\n+            Collection<ConsumerGroupListing> listings = result.valid().get();\n+\n+            assertEquals(2, listings.size());\n+            List<ConsumerGroupListing> expected = new ArrayList<>();\n+            expected.add(new ConsumerGroupListing(\"group-2\", true, Optional.of(ConsumerGroupState.EMPTY)));\n+            expected.add(new ConsumerGroupListing(\"group-1\", false, Optional.of(ConsumerGroupState.STABLE)));\n+            assertEquals(expected, listings);\n+            assertEquals(0, result.errors().get().size());\n+        }\n+    }\n+\n+    @Test\n+    public void testListConsumerGroupsWithStatesOlderBrokerVersion() throws Exception {\n+        ApiVersion listGroupV3 = new ApiVersion(ApiKeys.LIST_GROUPS.id, (short) 0, (short) 3);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(mockCluster(1, 0))) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create(Collections.singletonList(listGroupV3)));\n+\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(env.cluster(), Errors.NONE));\n+\n+            // Check we can list groups with older broker if we don't specify states\n+            env.kafkaClient().prepareResponseFrom(\n+                    new ListGroupsResponse(new ListGroupsResponseData()\n+                        .setErrorCode(Errors.NONE.code())\n+                        .setGroups(Collections.singletonList(\n+                                new ListGroupsResponseData.ListedGroup()\n+                                    .setGroupId(\"group-1\")\n+                                    .setProtocolType(ConsumerProtocol.PROTOCOL_TYPE)))),\n+                    env.cluster().nodeById(0));\n+            ListConsumerGroupsOptions options = new ListConsumerGroupsOptions().inAnyState();\n+            ListConsumerGroupsResult result = env.adminClient().listConsumerGroups(options);\n+            Collection<ConsumerGroupListing> listing = result.all().get();\n+            assertEquals(1, listing.size());\n+            List<ConsumerGroupListing> expected = Collections.singletonList(new ConsumerGroupListing(\"group-1\", false, Optional.empty()));\n+            assertEquals(expected, listing);\n+\n+            // But we cannot set a state filter with older broker\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(env.cluster(), Errors.NONE));\n+            env.kafkaClient().prepareUnsupportedVersionResponse(\n+                body -> body instanceof ListGroupsRequest);\n+\n+            options = new ListConsumerGroupsOptions().inStates(Collections.singleton(ConsumerGroupState.STABLE));\n+            result = env.adminClient().listConsumerGroups(options);\n+            try {\n+                result.all().get();\n+                fail(\"Should have thrown\");", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5OTgyNQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431599825", "bodyText": "Seems we need to update this now that we use empty list to request all states.", "author": "hachikuji", "createdAt": "2020-05-28T06:03:26Z", "path": "core/src/main/scala/kafka/admin/ConsumerGroupCommand.scala", "diffHunk": "@@ -178,12 +200,44 @@ object ConsumerGroupCommand extends Logging {\n       } else None\n     }\n \n-    def listGroups(): List[String] = {\n+    def listGroups(): Unit = {\n+      if (opts.options.has(opts.stateOpt)) {\n+           val stateValue = opts.options.valueOf(opts.stateOpt)\n+           val states = if (stateValue == null || stateValue.isEmpty)\n+             allStates", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwMjM2OA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431602368", "bodyText": "Since we have an optional argument, do we need to validate that it is not provided when --describe is used?", "author": "hachikuji", "createdAt": "2020-05-28T06:11:22Z", "path": "core/src/main/scala/kafka/admin/ConsumerGroupCommand.scala", "diffHunk": "@@ -1004,9 +1061,9 @@ object ConsumerGroupCommand extends Logging {\n     val offsetsOpt = parser.accepts(\"offsets\", OffsetsDoc)\n                            .availableIf(describeOpt)\n     val stateOpt = parser.accepts(\"state\", StateDoc)\n-                         .availableIf(describeOpt)\n-\n-    parser.mutuallyExclusive(membersOpt, offsetsOpt, stateOpt)\n+                         .availableIf(describeOpt, listOpt)\n+                         .withOptionalArg()", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwMjg1OQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431602859", "bodyText": "Could this be a Set?", "author": "hachikuji", "createdAt": "2020-05-28T06:12:55Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -797,12 +797,17 @@ class GroupCoordinator(val brokerId: Int,\n     }\n   }\n \n-  def handleListGroups(): (Errors, List[GroupOverview]) = {\n+  def handleListGroups(states: List[String]): (Errors, List[GroupOverview]) = {", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNTUzOA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431605538", "bodyText": "Seems this is ignored because the type of StatesFilter is []string. Sort of feels like a bug in the schema validation that this gets ignored. In any case, should we remove it?", "author": "hachikuji", "createdAt": "2020-05-28T06:21:10Z", "path": "clients/src/main/resources/common/message/ListGroupsRequest.json", "diffHunk": "@@ -20,8 +20,14 @@\n   // Version 1 and 2 are the same as version 0.\n   //\n   // Version 3 is the first flexible version.\n-  \"validVersions\": \"0-3\",\n+  //\n+  // Version 4 adds the StatesFilter field (KIP-518).\n+  \"validVersions\": \"0-4\",\n   \"flexibleVersions\": \"3+\",\n   \"fields\": [\n+    { \"name\": \"StatesFilter\", \"type\": \"[]string\", \"versions\": \"4+\", \"nullableVersions\": \"4+\", \"default\": \"null\",\n+      \"about\": \"The states of the groups we want to list. If empty or null, all groups are returned with their state.\", \"fields\": [\n+      { \"name\": \"Name\", \"type\": \"string\", \"versions\": \"4+\", \"about\": \"The name of the group state\" }", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNzk1OQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r431607959", "bodyText": "The behavior of null is identical to an empty list in terms of semantics. However, if an empty list is provided, the request cannot be serialized with older versions because the field is not marked as ignorable. Would it be simpler if we made this field non-nullable and used the default of an empty array so that we don't have this inconsistency?", "author": "hachikuji", "createdAt": "2020-05-28T06:27:35Z", "path": "clients/src/main/resources/common/message/ListGroupsRequest.json", "diffHunk": "@@ -20,8 +20,14 @@\n   // Version 1 and 2 are the same as version 0.\n   //\n   // Version 3 is the first flexible version.\n-  \"validVersions\": \"0-3\",\n+  //\n+  // Version 4 adds the StatesFilter field (KIP-518).\n+  \"validVersions\": \"0-4\",\n   \"flexibleVersions\": \"3+\",\n   \"fields\": [\n+    { \"name\": \"StatesFilter\", \"type\": \"[]string\", \"versions\": \"4+\", \"nullableVersions\": \"4+\", \"default\": \"null\",", "originalCommit": "1f032e71c50411ecff2d99f86e523e02dd560c32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "499b15b40039927ec5b6a599024a082e001b456e", "url": "https://github.com/apache/kafka/commit/499b15b40039927ec5b6a599024a082e001b456e", "message": "Address some of the feedback", "committedDate": "2020-05-28T12:38:23Z", "type": "commit"}, {"oid": "56f839afcf1d4c956cb807f6d4cdf79cf8f88d55", "url": "https://github.com/apache/kafka/commit/56f839afcf1d4c956cb807f6d4cdf79cf8f88d55", "message": "Address some of the feedback", "committedDate": "2020-05-28T18:40:02Z", "type": "commit"}, {"oid": "5e18e5c03c29a33e9098418b98c2c67843624c5b", "url": "https://github.com/apache/kafka/commit/5e18e5c03c29a33e9098418b98c2c67843624c5b", "message": "Address comments", "committedDate": "2020-05-28T20:53:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3ODcwNg==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r432178706", "bodyText": "nit: usually we would write this is this.state = requireNonNull(state);", "author": "hachikuji", "createdAt": "2020-05-28T23:29:53Z", "path": "clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupListing.java", "diffHunk": "@@ -31,8 +37,21 @@\n      * @param isSimpleConsumerGroup If consumer group is simple or not.\n      */\n     public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup) {\n+        this(groupId, isSimpleConsumerGroup, Optional.empty());\n+    }\n+\n+    /**\n+     * Create an instance with the specified parameters.\n+     *\n+     * @param groupId Group Id\n+     * @param isSimpleConsumerGroup If consumer group is simple or not.\n+     * @param state The state of the consumer group\n+     */\n+    public ConsumerGroupListing(String groupId, boolean isSimpleConsumerGroup, Optional<ConsumerGroupState> state) {\n+        Objects.requireNonNull(state);\n         this.groupId = groupId;\n         this.isSimpleConsumerGroup = isSimpleConsumerGroup;\n+        this.state = state;", "originalCommit": "5e18e5c03c29a33e9098418b98c2c67843624c5b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3OTgxNg==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r432179816", "bodyText": "Is this used?", "author": "hachikuji", "createdAt": "2020-05-28T23:33:38Z", "path": "core/src/main/scala/kafka/admin/ConsumerGroupCommand.scala", "diffHunk": "@@ -41,26 +41,37 @@ import org.apache.kafka.common.protocol.Errors\n import scala.collection.immutable.TreeMap\n import scala.reflect.ClassTag\n import org.apache.kafka.common.requests.ListOffsetResponse\n+import org.apache.kafka.common.ConsumerGroupState\n+import joptsimple.OptionException\n \n object ConsumerGroupCommand extends Logging {\n \n+  val allStates = ConsumerGroupState.values.toList", "originalCommit": "5e18e5c03c29a33e9098418b98c2c67843624c5b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MTc1NA==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r432181754", "bodyText": "This seems the same as the previous case. It might be more interesting if we request only groups that are stable? Then we have covered both successful and unsuccessful matching.", "author": "hachikuji", "createdAt": "2020-05-28T23:40:50Z", "path": "core/src/test/scala/integration/kafka/api/PlaintextAdminIntegrationTest.scala", "diffHunk": "@@ -1061,10 +1061,27 @@ class PlaintextAdminIntegrationTest extends BaseAdminIntegrationTest {\n           assertTrue(latch.await(30000, TimeUnit.MILLISECONDS))\n           // Test that we can list the new group.\n           TestUtils.waitUntilTrue(() => {\n-            val matching = client.listConsumerGroups.all.get().asScala.filter(_.groupId == testGroupId)\n-            matching.nonEmpty\n+            val matching = client.listConsumerGroups.all.get.asScala.filter(group =>\n+                group.groupId == testGroupId &&\n+                group.state.get == ConsumerGroupState.STABLE)\n+            matching.size == 1\n           }, s\"Expected to be able to list $testGroupId\")\n \n+          TestUtils.waitUntilTrue(() => {\n+            val options = new ListConsumerGroupsOptions()", "originalCommit": "5e18e5c03c29a33e9098418b98c2c67843624c5b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MTkwMQ==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r432181901", "bodyText": "nit: looks misaligned", "author": "hachikuji", "createdAt": "2020-05-28T23:41:24Z", "path": "core/src/test/scala/unit/kafka/admin/ListConsumerGroupTest.scala", "diffHunk": "@@ -44,4 +48,100 @@ class ListConsumerGroupTest extends ConsumerGroupCommandTest {\n     val cgcArgs = Array(\"--new-consumer\", \"--bootstrap-server\", brokerList, \"--list\")\n     getConsumerGroupService(cgcArgs)\n   }\n+\n+  @Test\n+  def testListConsumerGroupsWithStates(): Unit = {\n+    val simpleGroup = \"simple-group\"\n+    addSimpleGroupExecutor(group = simpleGroup)\n+    addConsumerGroupExecutor(numConsumers = 1)\n+\n+    val cgcArgs = Array(\"--bootstrap-server\", brokerList, \"--list\", \"--state\")\n+    val service = getConsumerGroupService(cgcArgs)\n+\n+    val expectedListing = Set(\n+        new ConsumerGroupListing(simpleGroup, true, Optional.of(ConsumerGroupState.EMPTY)),", "originalCommit": "5e18e5c03c29a33e9098418b98c2c67843624c5b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MjMzNg==", "url": "https://github.com/apache/kafka/pull/8238#discussion_r432182336", "bodyText": "nit: we could use assertThrows or intercept for all of these", "author": "hachikuji", "createdAt": "2020-05-28T23:42:50Z", "path": "core/src/test/scala/unit/kafka/admin/ListConsumerGroupTest.scala", "diffHunk": "@@ -44,4 +48,100 @@ class ListConsumerGroupTest extends ConsumerGroupCommandTest {\n     val cgcArgs = Array(\"--new-consumer\", \"--bootstrap-server\", brokerList, \"--list\")\n     getConsumerGroupService(cgcArgs)\n   }\n+\n+  @Test\n+  def testListConsumerGroupsWithStates(): Unit = {\n+    val simpleGroup = \"simple-group\"\n+    addSimpleGroupExecutor(group = simpleGroup)\n+    addConsumerGroupExecutor(numConsumers = 1)\n+\n+    val cgcArgs = Array(\"--bootstrap-server\", brokerList, \"--list\", \"--state\")\n+    val service = getConsumerGroupService(cgcArgs)\n+\n+    val expectedListing = Set(\n+        new ConsumerGroupListing(simpleGroup, true, Optional.of(ConsumerGroupState.EMPTY)),\n+        new ConsumerGroupListing(group, false, Optional.of(ConsumerGroupState.STABLE)))\n+\n+    var foundListing = Set.empty[ConsumerGroupListing]\n+    TestUtils.waitUntilTrue(() => {\n+      foundListing = service.listConsumerGroupsWithState(ConsumerGroupState.values.toSet).toSet\n+      expectedListing == foundListing\n+    }, s\"Expected to show groups $expectedListing, but found $foundListing\")\n+\n+    val expectedListingStable = Set(\n+        new ConsumerGroupListing(group, false, Optional.of(ConsumerGroupState.STABLE)))\n+\n+    foundListing = Set.empty[ConsumerGroupListing]\n+    TestUtils.waitUntilTrue(() => {\n+      foundListing = service.listConsumerGroupsWithState(Set(ConsumerGroupState.STABLE)).toSet\n+      expectedListingStable == foundListing\n+    }, s\"Expected to show groups $expectedListingStable, but found $foundListing\")\n+  }\n+\n+  @Test\n+  def testConsumerGroupStatesFromString(): Unit = {\n+    var result = ConsumerGroupCommand.consumerGroupStatesFromString(\"Stable\")\n+    assertEquals(Set(ConsumerGroupState.STABLE), result)\n+\n+    result = ConsumerGroupCommand.consumerGroupStatesFromString(\"Stable, PreparingRebalance\")\n+    assertEquals(Set(ConsumerGroupState.STABLE, ConsumerGroupState.PREPARING_REBALANCE), result)\n+\n+    result = ConsumerGroupCommand.consumerGroupStatesFromString(\"Dead,CompletingRebalance,\")\n+    assertEquals(Set(ConsumerGroupState.DEAD, ConsumerGroupState.COMPLETING_REBALANCE), result)\n+\n+    try {\n+      ConsumerGroupCommand.consumerGroupStatesFromString(\"bad, wrong\")", "originalCommit": "5e18e5c03c29a33e9098418b98c2c67843624c5b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "acb64f32f6fc2353dcaec2be44d05c6cd1a77b2d", "url": "https://github.com/apache/kafka/commit/acb64f32f6fc2353dcaec2be44d05c6cd1a77b2d", "message": "Address last round of reviews", "committedDate": "2020-05-29T09:30:35Z", "type": "commit"}]}