{"pr_number": 9717, "pr_title": "KAFKA-10766: Unit test cases for RocksDBRangeIterator", "pr_createdAt": "2020-12-09T01:39:26Z", "pr_url": "https://github.com/apache/kafka/pull/9717", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTExMDU1Mg==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r545110552", "bodyText": "It is not a good idea to change a class due to unit tests if it is not absolutely necessary. In this case it is definitely not necessary. See my suggestion how to change the tests.", "author": "cadonna", "createdAt": "2020-12-17T13:59:41Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBRangeIterator.java", "diffHunk": "@@ -55,20 +56,36 @@\n         }\n     }\n \n+    public byte[] getRawLastKey() {\n+        return rawLastKey;\n+    }\n+\n+    public boolean isForward() {\n+        return forward;\n+    }\n+\n+    public KeyValue<Bytes, byte[]> getNext() {\n+        return super.makeNext();\n+    }\n+\n+    public Comparator<byte[]> getComparator() {\n+        return comparator;\n+    }\n+\n     @Override\n     public KeyValue<Bytes, byte[]> makeNext() {\n-        final KeyValue<Bytes, byte[]> next = super.makeNext();\n+        final KeyValue<Bytes, byte[]> next = getNext();\n         if (next == null) {\n             return allDone();\n         } else {\n-            if (forward) {\n-                if (comparator.compare(next.key.get(), rawLastKey) <= 0) {\n+            if (isForward()) {\n+                if (getComparator().compare(next.key.get(), getRawLastKey()) <= 0) {\n                     return next;\n                 } else {\n                     return allDone();\n                 }\n             } else {\n-                if (comparator.compare(next.key.get(), rawLastKey) >= 0) {\n+                if (getComparator().compare(next.key.get(), getRawLastKey()) >= 0) {", "originalCommit": "d24d1fce3feed7f96b6a2aff538b7c2d4614dbea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEyMDcxMA==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r545120710", "bodyText": "You usually do not want to mock the class under test, because you want to test it. Also partial mocks should only be used if absolutely necessary. A rule of thumb is if a partial mock is needed then most probably the design has a flaw.\nIn this specific case, you should mock RocksDB's iterator. For the class under test, you should test hasNext(), next(), peekNextKey() and close(), because those are the one exposed (makeNext() should actually de declared as protected, IMO).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final RocksDBRangeIterator rocksDBRangeIterator = mockRocksDBRangeIterator();\n          \n          \n            \n            \n          \n          \n            \n                    final String key1 = \"a\";\n          \n          \n            \n                    final String key2 = \"b\";\n          \n          \n            \n                    final String key3 = \"c\";\n          \n          \n            \n                    final String key4 = \"d\";\n          \n          \n            \n                    final String value = \"value\";\n          \n          \n            \n            \n          \n          \n            \n                    final  Bytes key1Bytes = Bytes.wrap(key1.getBytes());\n          \n          \n            \n                    final  Bytes key2Bytes = Bytes.wrap(key2.getBytes());\n          \n          \n            \n                    final  Bytes key3Bytes = Bytes.wrap(key3.getBytes());\n          \n          \n            \n                    final  Bytes key4Bytes = Bytes.wrap(key4.getBytes());\n          \n          \n            \n                    final byte[] valueBytes = value.getBytes();\n          \n          \n            \n            \n          \n          \n            \n                    expect(rocksDBRangeIterator.getNext())\n          \n          \n            \n                        .andReturn(KeyValue.pair(key1Bytes, valueBytes))\n          \n          \n            \n                        .andReturn(KeyValue.pair(key2Bytes, valueBytes))\n          \n          \n            \n                        .andReturn(KeyValue.pair(key3Bytes, valueBytes))\n          \n          \n            \n                        .andReturn(KeyValue.pair(key4Bytes, valueBytes));\n          \n          \n            \n            \n          \n          \n            \n                    expect(rocksDBRangeIterator.getRawLastKey())\n          \n          \n            \n                        .andReturn(key3Bytes.get())\n          \n          \n            \n                        .anyTimes();\n          \n          \n            \n            \n          \n          \n            \n                    expect(rocksDBRangeIterator.isForward())\n          \n          \n            \n                        .andReturn(true)\n          \n          \n            \n                        .anyTimes();\n          \n          \n            \n            \n          \n          \n            \n                    expect(rocksDBRangeIterator.getComparator())\n          \n          \n            \n                        .andReturn(Bytes.BYTES_LEXICO_COMPARATOR)\n          \n          \n            \n                        .anyTimes();\n          \n          \n            \n            \n          \n          \n            \n            \n          \n          \n            \n                    replay(rocksDBRangeIterator);\n          \n          \n            \n                    assertThat(rocksDBRangeIterator.makeNext().key, is(key1Bytes));\n          \n          \n            \n                    assertThat(rocksDBRangeIterator.makeNext().key, is(key2Bytes));\n          \n          \n            \n                    assertThat(rocksDBRangeIterator.makeNext().key, is(key3Bytes));\n          \n          \n            \n                    assertThat(rocksDBRangeIterator.makeNext(), is(nullValue()));\n          \n          \n            \n                    final String key1 = \"a\";\n          \n          \n            \n                    final String key2 = \"b\";\n          \n          \n            \n                    final String key3 = \"c\";\n          \n          \n            \n                    final String key4 = \"d\";\n          \n          \n            \n                    final String value = \"value\";\n          \n          \n            \n            \n          \n          \n            \n                    final  Bytes key1Bytes = Bytes.wrap(key1.getBytes());\n          \n          \n            \n                    final  Bytes key2Bytes = Bytes.wrap(key2.getBytes());\n          \n          \n            \n                    final  Bytes key3Bytes = Bytes.wrap(key3.getBytes());\n          \n          \n            \n                    final  Bytes key4Bytes = Bytes.wrap(key4.getBytes());\n          \n          \n            \n                    final byte[] valueBytes = value.getBytes();\n          \n          \n            \n            \n          \n          \n            \n                    final RocksIterator rocksIterator = mock(RocksIterator.class);\n          \n          \n            \n                    rocksIterator.seek(key1Bytes.get());\n          \n          \n            \n                    expect(rocksIterator.isValid())\n          \n          \n            \n                        .andReturn(true)\n          \n          \n            \n                        .andReturn(true)\n          \n          \n            \n                        .andReturn(true)\n          \n          \n            \n                        .andReturn(true)\n          \n          \n            \n                        .andReturn(false);\n          \n          \n            \n                    expect(rocksIterator.key())\n          \n          \n            \n                        .andReturn(key1Bytes.get())\n          \n          \n            \n                        .andReturn(key2Bytes.get())\n          \n          \n            \n                        .andReturn(key3Bytes.get())\n          \n          \n            \n                        .andReturn(key4Bytes.get());\n          \n          \n            \n                    expect(rocksIterator.value()).andReturn(valueBytes).times(4);\n          \n          \n            \n                    rocksIterator.next();\n          \n          \n            \n                    expectLastCall().times(4);\n          \n          \n            \n                    replay(rocksIterator);\n          \n          \n            \n            \n          \n          \n            \n                    final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n          \n          \n            \n                        STORE_NAME,\n          \n          \n            \n                        rocksIterator,\n          \n          \n            \n                        Collections.emptySet(),\n          \n          \n            \n                        key1Bytes,\n          \n          \n            \n                        key4Bytes,\n          \n          \n            \n                        true\n          \n          \n            \n                    );\n          \n          \n            \n                    assertThat(rocksDBRangeIterator.hasNext(), is(true));\n          \n          \n            \n                    assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n          \n          \n            \n                    assertThat(rocksDBRangeIterator.hasNext(), is(true));\n          \n          \n            \n                    assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n          \n          \n            \n                    assertThat(rocksDBRangeIterator.hasNext(), is(true));\n          \n          \n            \n                    assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n          \n          \n            \n                    assertThat(rocksDBRangeIterator.hasNext(), is(true));\n          \n          \n            \n                    assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n          \n          \n            \n                    assertThat(rocksDBRangeIterator.hasNext(), is(false));\n          \n          \n            \n                    verify(rocksIterator);", "author": "cadonna", "createdAt": "2020-12-17T14:13:57Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBRangeIteratorTest.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.streams.KeyValue;\n+import org.junit.Test;\n+\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.partialMockBuilder;\n+import static org.easymock.EasyMock.replay;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.core.Is.is;\n+\n+public class RocksDBRangeIteratorTest {\n+\n+    private RocksDBRangeIterator mockRocksDBRangeIterator() {\n+        return partialMockBuilder(RocksDBRangeIterator.class)\n+                .addMockedMethod(\"getNext\")\n+                .addMockedMethod(\"getRawLastKey\")\n+                .addMockedMethod(\"isForward\")\n+                .addMockedMethod(\"getComparator\")\n+                .createMock();\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeInForwardDirection() {\n+        final RocksDBRangeIterator rocksDBRangeIterator = mockRocksDBRangeIterator();\n+\n+        final String key1 = \"a\";\n+        final String key2 = \"b\";\n+        final String key3 = \"c\";\n+        final String key4 = \"d\";\n+        final String value = \"value\";\n+\n+        final  Bytes key1Bytes = Bytes.wrap(key1.getBytes());\n+        final  Bytes key2Bytes = Bytes.wrap(key2.getBytes());\n+        final  Bytes key3Bytes = Bytes.wrap(key3.getBytes());\n+        final  Bytes key4Bytes = Bytes.wrap(key4.getBytes());\n+        final byte[] valueBytes = value.getBytes();\n+\n+        expect(rocksDBRangeIterator.getNext())\n+            .andReturn(KeyValue.pair(key1Bytes, valueBytes))\n+            .andReturn(KeyValue.pair(key2Bytes, valueBytes))\n+            .andReturn(KeyValue.pair(key3Bytes, valueBytes))\n+            .andReturn(KeyValue.pair(key4Bytes, valueBytes));\n+\n+        expect(rocksDBRangeIterator.getRawLastKey())\n+            .andReturn(key3Bytes.get())\n+            .anyTimes();\n+\n+        expect(rocksDBRangeIterator.isForward())\n+            .andReturn(true)\n+            .anyTimes();\n+\n+        expect(rocksDBRangeIterator.getComparator())\n+            .andReturn(Bytes.BYTES_LEXICO_COMPARATOR)\n+            .anyTimes();\n+\n+\n+        replay(rocksDBRangeIterator);\n+        assertThat(rocksDBRangeIterator.makeNext().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.makeNext().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.makeNext().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.makeNext(), is(nullValue()));", "originalCommit": "d24d1fce3feed7f96b6a2aff538b7c2d4614dbea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2MDU5NQ==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r546260595", "bodyText": "@cadonna , honestly even I wasn't making the changes that I ended up making but I assumed that makeNext is the only method that needs to be tested wrt Range Iterator as other methods are inherited by it so those should have test cases separately. I have changes the test cases now.", "author": "vamossagar12", "createdAt": "2020-12-19T17:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEyMDcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NDEyMQ==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r553484121", "bodyText": "@cadonna , did you get  a chance to review these changes?", "author": "vamossagar12", "createdAt": "2021-01-07T17:46:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEyMDcxMA=="}], "type": "inlineReview"}, {"oid": "92cd48a3477d7dfe9f6c387b55d70946f5c587d1", "url": "https://github.com/apache/kafka/commit/92cd48a3477d7dfe9f6c387b55d70946f5c587d1", "message": "KAFKA-10766: Unit test cases for RocksDBRangeIterator", "committedDate": "2020-12-19T17:05:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA0NTY0MQ==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r566045641", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n          \n          \n            \n                            storeName,\n          \n          \n            \n                        rocksIterator,\n          \n          \n            \n                        Collections.emptySet(),\n          \n          \n            \n                        key1Bytes,\n          \n          \n            \n                        key3Bytes,\n          \n          \n            \n                        true\n          \n          \n            \n                    );\n          \n          \n            \n                    final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n          \n          \n            \n                        storeName,\n          \n          \n            \n                        rocksIterator,\n          \n          \n            \n                        Collections.emptySet(),\n          \n          \n            \n                        key1Bytes,\n          \n          \n            \n                        key3Bytes,\n          \n          \n            \n                        true\n          \n          \n            \n                    );\n          \n      \n    \n    \n  \n\nPlease also fix the other wrong indentations.", "author": "cadonna", "createdAt": "2021-01-28T12:11:35Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBRangeIteratorTest.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import org.apache.kafka.common.utils.Bytes;\n+import org.junit.Test;\n+import org.rocksdb.RocksIterator;\n+\n+import java.util.Collections;\n+import java.util.NoSuchElementException;\n+\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.expectLastCall;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertThrows;\n+\n+public class RocksDBRangeIteratorTest {\n+\n+    private final String storeName = \"store\";\n+    private final String key1 = \"a\";\n+    private final String key2 = \"b\";\n+    private final String key3 = \"c\";\n+    private final String key4 = \"d\";\n+\n+    private final String value = \"value\";\n+    private final  Bytes key1Bytes = Bytes.wrap(key1.getBytes());\n+    private final  Bytes key2Bytes = Bytes.wrap(key2.getBytes());\n+    private final  Bytes key3Bytes = Bytes.wrap(key3.getBytes());\n+    private final  Bytes key4Bytes = Bytes.wrap(key4.getBytes());\n+    private final byte[] valueBytes = value.getBytes();\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeInForwardDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key1Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.next();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true\n+        );", "originalCommit": "92cd48a3477d7dfe9f6c387b55d70946f5c587d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA0OTU4Ng==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r566049586", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final  Bytes toBytes = Bytes.wrap(to.getBytes());\n          \n          \n            \n                    final Bytes toBytes = Bytes.wrap(to.getBytes());\n          \n      \n    \n    \n  \n\nPlease also check other occurrences of this additional space.", "author": "cadonna", "createdAt": "2021-01-28T12:18:37Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBRangeIteratorTest.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import org.apache.kafka.common.utils.Bytes;\n+import org.junit.Test;\n+import org.rocksdb.RocksIterator;\n+\n+import java.util.Collections;\n+import java.util.NoSuchElementException;\n+\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.expectLastCall;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertThrows;\n+\n+public class RocksDBRangeIteratorTest {\n+\n+    private final String storeName = \"store\";\n+    private final String key1 = \"a\";\n+    private final String key2 = \"b\";\n+    private final String key3 = \"c\";\n+    private final String key4 = \"d\";\n+\n+    private final String value = \"value\";\n+    private final  Bytes key1Bytes = Bytes.wrap(key1.getBytes());\n+    private final  Bytes key2Bytes = Bytes.wrap(key2.getBytes());\n+    private final  Bytes key3Bytes = Bytes.wrap(key3.getBytes());\n+    private final  Bytes key4Bytes = Bytes.wrap(key4.getBytes());\n+    private final byte[] valueBytes = value.getBytes();\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeInForwardDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key1Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.next();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeReverseDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(key3Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key1Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.prev();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            false\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysWhenLastKeyIsGreaterThanLargestKeyInStateStoreInForwardDirection() {\n+\n+        final String to = \"f\";\n+        final  Bytes toBytes = Bytes.wrap(to.getBytes());", "originalCommit": "92cd48a3477d7dfe9f6c387b55d70946f5c587d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA1MjkyMQ==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r566052921", "bodyText": "nit: Couldn't you Instead of using a literal, use Bytes.increment(key4Bytes) for the to parameter?", "author": "cadonna", "createdAt": "2021-01-28T12:23:15Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBRangeIteratorTest.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import org.apache.kafka.common.utils.Bytes;\n+import org.junit.Test;\n+import org.rocksdb.RocksIterator;\n+\n+import java.util.Collections;\n+import java.util.NoSuchElementException;\n+\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.expectLastCall;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertThrows;\n+\n+public class RocksDBRangeIteratorTest {\n+\n+    private final String storeName = \"store\";\n+    private final String key1 = \"a\";\n+    private final String key2 = \"b\";\n+    private final String key3 = \"c\";\n+    private final String key4 = \"d\";\n+\n+    private final String value = \"value\";\n+    private final  Bytes key1Bytes = Bytes.wrap(key1.getBytes());\n+    private final  Bytes key2Bytes = Bytes.wrap(key2.getBytes());\n+    private final  Bytes key3Bytes = Bytes.wrap(key3.getBytes());\n+    private final  Bytes key4Bytes = Bytes.wrap(key4.getBytes());\n+    private final byte[] valueBytes = value.getBytes();\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeInForwardDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key1Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.next();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeReverseDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(key3Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key1Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.prev();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            false\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysWhenLastKeyIsGreaterThanLargestKeyInStateStoreInForwardDirection() {\n+\n+        final String to = \"f\";", "originalCommit": "92cd48a3477d7dfe9f6c387b55d70946f5c587d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA1NjM5OQ==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r566056399", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    expect(rocksIterator.isValid())\n          \n          \n            \n                        .andReturn(false);\n          \n          \n            \n                    expect(rocksIterator.isValid()).andReturn(false);", "author": "cadonna", "createdAt": "2021-01-28T12:28:31Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBRangeIteratorTest.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import org.apache.kafka.common.utils.Bytes;\n+import org.junit.Test;\n+import org.rocksdb.RocksIterator;\n+\n+import java.util.Collections;\n+import java.util.NoSuchElementException;\n+\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.expectLastCall;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertThrows;\n+\n+public class RocksDBRangeIteratorTest {\n+\n+    private final String storeName = \"store\";\n+    private final String key1 = \"a\";\n+    private final String key2 = \"b\";\n+    private final String key3 = \"c\";\n+    private final String key4 = \"d\";\n+\n+    private final String value = \"value\";\n+    private final  Bytes key1Bytes = Bytes.wrap(key1.getBytes());\n+    private final  Bytes key2Bytes = Bytes.wrap(key2.getBytes());\n+    private final  Bytes key3Bytes = Bytes.wrap(key3.getBytes());\n+    private final  Bytes key4Bytes = Bytes.wrap(key4.getBytes());\n+    private final byte[] valueBytes = value.getBytes();\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeInForwardDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key1Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.next();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeReverseDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(key3Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key1Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.prev();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            false\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysWhenLastKeyIsGreaterThanLargestKeyInStateStoreInForwardDirection() {\n+\n+        final String to = \"f\";\n+        final  Bytes toBytes = Bytes.wrap(to.getBytes());\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key1Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key4Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(4);\n+        rocksIterator.next();\n+        expectLastCall().times(4);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            toBytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+\n+    @Test\n+    public void shouldReturnAllKeysWhenLastKeyIsSmallerThanSmallestKeyInStateStoreInReverseDirection() {\n+        final String to = \"a\";\n+        final  Bytes toBytes = Bytes.wrap(to.getBytes());\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(key4Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key4Bytes.get())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key1Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(4);\n+        rocksIterator.prev();\n+        expectLastCall().times(4);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            toBytes,\n+            key4Bytes,\n+            false\n+        );\n+\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+\n+    @Test\n+    public void shouldReturnNoKeysWhenLastKeyIsSmallerThanSmallestKeyInStateStoreForwardDirection() {\n+\n+        // key range in state store: [c-f]\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(false);\n+", "originalCommit": "92cd48a3477d7dfe9f6c387b55d70946f5c587d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA2MjM1Nw==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r566062357", "bodyText": "I think, it would be good to verify that a second call to  peekNextKey() right after the first call to peekNextKey() returns the same value, since this is the main difference between next() and peekNextKey().", "author": "cadonna", "createdAt": "2021-01-28T12:38:27Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBRangeIteratorTest.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import org.apache.kafka.common.utils.Bytes;\n+import org.junit.Test;\n+import org.rocksdb.RocksIterator;\n+\n+import java.util.Collections;\n+import java.util.NoSuchElementException;\n+\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.expectLastCall;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertThrows;\n+\n+public class RocksDBRangeIteratorTest {\n+\n+    private final String storeName = \"store\";\n+    private final String key1 = \"a\";\n+    private final String key2 = \"b\";\n+    private final String key3 = \"c\";\n+    private final String key4 = \"d\";\n+\n+    private final String value = \"value\";\n+    private final  Bytes key1Bytes = Bytes.wrap(key1.getBytes());\n+    private final  Bytes key2Bytes = Bytes.wrap(key2.getBytes());\n+    private final  Bytes key3Bytes = Bytes.wrap(key3.getBytes());\n+    private final  Bytes key4Bytes = Bytes.wrap(key4.getBytes());\n+    private final byte[] valueBytes = value.getBytes();\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeInForwardDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key1Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.next();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeReverseDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(key3Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key1Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.prev();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            false\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysWhenLastKeyIsGreaterThanLargestKeyInStateStoreInForwardDirection() {\n+\n+        final String to = \"f\";\n+        final  Bytes toBytes = Bytes.wrap(to.getBytes());\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key1Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key4Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(4);\n+        rocksIterator.next();\n+        expectLastCall().times(4);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            toBytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+\n+    @Test\n+    public void shouldReturnAllKeysWhenLastKeyIsSmallerThanSmallestKeyInStateStoreInReverseDirection() {\n+        final String to = \"a\";\n+        final  Bytes toBytes = Bytes.wrap(to.getBytes());\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(key4Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key4Bytes.get())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key1Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(4);\n+        rocksIterator.prev();\n+        expectLastCall().times(4);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            toBytes,\n+            key4Bytes,\n+            false\n+        );\n+\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+\n+    @Test\n+    public void shouldReturnNoKeysWhenLastKeyIsSmallerThanSmallestKeyInStateStoreForwardDirection() {\n+\n+        // key range in state store: [c-f]\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(false);\n+\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key2Bytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+\n+    }\n+\n+    @Test\n+    public void shouldReturnNoKeysWhenLastKeyIsLargerThanLargestKeyInStateStoreReverseDirection() {\n+\n+        // key range in state store: [c-f]\n+        final String from = \"g\";\n+        final String to = \"h\";\n+\n+        final  Bytes fromBytes = Bytes.wrap(from.getBytes());\n+        final  Bytes toBytes = Bytes.wrap(to.getBytes());\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(toBytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(false);\n+\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            fromBytes,\n+            toBytes,\n+            false\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInPartiallyOverlappingRangeInForwardDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.next();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInPartiallyOverlappingRangeInReverseDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        final String to = \"e\";\n+        final Bytes toBytes = Bytes.wrap(to.getBytes());\n+        rocksIterator.seekForPrev(toBytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key4Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.prev();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key3Bytes,\n+            toBytes,\n+            false\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnTheCurrentKeyOnInvokingPeekNextKeyInForwardDirection() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.next();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true\n+        );\n+\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));", "originalCommit": "92cd48a3477d7dfe9f6c387b55d70946f5c587d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA2MjYxNQ==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r566062615", "bodyText": "See my comment above.", "author": "cadonna", "createdAt": "2021-01-28T12:38:58Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBRangeIteratorTest.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import org.apache.kafka.common.utils.Bytes;\n+import org.junit.Test;\n+import org.rocksdb.RocksIterator;\n+\n+import java.util.Collections;\n+import java.util.NoSuchElementException;\n+\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.expectLastCall;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertThrows;\n+\n+public class RocksDBRangeIteratorTest {\n+\n+    private final String storeName = \"store\";\n+    private final String key1 = \"a\";\n+    private final String key2 = \"b\";\n+    private final String key3 = \"c\";\n+    private final String key4 = \"d\";\n+\n+    private final String value = \"value\";\n+    private final  Bytes key1Bytes = Bytes.wrap(key1.getBytes());\n+    private final  Bytes key2Bytes = Bytes.wrap(key2.getBytes());\n+    private final  Bytes key3Bytes = Bytes.wrap(key3.getBytes());\n+    private final  Bytes key4Bytes = Bytes.wrap(key4.getBytes());\n+    private final byte[] valueBytes = value.getBytes();\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeInForwardDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key1Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.next();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeReverseDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(key3Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key1Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.prev();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            false\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysWhenLastKeyIsGreaterThanLargestKeyInStateStoreInForwardDirection() {\n+\n+        final String to = \"f\";\n+        final  Bytes toBytes = Bytes.wrap(to.getBytes());\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key1Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key4Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(4);\n+        rocksIterator.next();\n+        expectLastCall().times(4);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            toBytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+\n+    @Test\n+    public void shouldReturnAllKeysWhenLastKeyIsSmallerThanSmallestKeyInStateStoreInReverseDirection() {\n+        final String to = \"a\";\n+        final  Bytes toBytes = Bytes.wrap(to.getBytes());\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(key4Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key4Bytes.get())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key1Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(4);\n+        rocksIterator.prev();\n+        expectLastCall().times(4);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            toBytes,\n+            key4Bytes,\n+            false\n+        );\n+\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+\n+    @Test\n+    public void shouldReturnNoKeysWhenLastKeyIsSmallerThanSmallestKeyInStateStoreForwardDirection() {\n+\n+        // key range in state store: [c-f]\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(false);\n+\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key2Bytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+\n+    }\n+\n+    @Test\n+    public void shouldReturnNoKeysWhenLastKeyIsLargerThanLargestKeyInStateStoreReverseDirection() {\n+\n+        // key range in state store: [c-f]\n+        final String from = \"g\";\n+        final String to = \"h\";\n+\n+        final  Bytes fromBytes = Bytes.wrap(from.getBytes());\n+        final  Bytes toBytes = Bytes.wrap(to.getBytes());\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(toBytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(false);\n+\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            fromBytes,\n+            toBytes,\n+            false\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInPartiallyOverlappingRangeInForwardDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.next();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInPartiallyOverlappingRangeInReverseDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        final String to = \"e\";\n+        final Bytes toBytes = Bytes.wrap(to.getBytes());\n+        rocksIterator.seekForPrev(toBytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key4Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.prev();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key3Bytes,\n+            toBytes,\n+            false\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnTheCurrentKeyOnInvokingPeekNextKeyInForwardDirection() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.next();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true\n+        );\n+\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        assertThrows(NoSuchElementException.class, rocksDBRangeIterator::peekNextKey);\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnTheCurrentKeyOnInvokingPeekNextKeyInReverseDirection() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        final String to = \"e\";\n+        final Bytes toBytes = Bytes.wrap(to.getBytes());\n+        rocksIterator.seekForPrev(toBytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key4Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.prev();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key3Bytes,\n+            toBytes,\n+            false\n+        );\n+\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));", "originalCommit": "92cd48a3477d7dfe9f6c387b55d70946f5c587d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA2Nzg5NQ==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r566067895", "bodyText": "Please remove empty lines here and in the other test methods.", "author": "cadonna", "createdAt": "2021-01-28T12:48:10Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBRangeIteratorTest.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import org.apache.kafka.common.utils.Bytes;\n+import org.junit.Test;\n+import org.rocksdb.RocksIterator;\n+\n+import java.util.Collections;\n+import java.util.NoSuchElementException;\n+\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.expectLastCall;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertThrows;\n+\n+public class RocksDBRangeIteratorTest {\n+\n+    private final String storeName = \"store\";\n+    private final String key1 = \"a\";\n+    private final String key2 = \"b\";\n+    private final String key3 = \"c\";\n+    private final String key4 = \"d\";\n+\n+    private final String value = \"value\";\n+    private final  Bytes key1Bytes = Bytes.wrap(key1.getBytes());\n+    private final  Bytes key2Bytes = Bytes.wrap(key2.getBytes());\n+    private final  Bytes key3Bytes = Bytes.wrap(key3.getBytes());\n+    private final  Bytes key4Bytes = Bytes.wrap(key4.getBytes());\n+    private final byte[] valueBytes = value.getBytes();\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeInForwardDirection() {\n+", "originalCommit": "92cd48a3477d7dfe9f6c387b55d70946f5c587d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA3MTMyMw==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r566071323", "bodyText": "Please rename to shouldCloseIterator().", "author": "cadonna", "createdAt": "2021-01-28T12:54:13Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBRangeIteratorTest.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import org.apache.kafka.common.utils.Bytes;\n+import org.junit.Test;\n+import org.rocksdb.RocksIterator;\n+\n+import java.util.Collections;\n+import java.util.NoSuchElementException;\n+\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.expectLastCall;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertThrows;\n+\n+public class RocksDBRangeIteratorTest {\n+\n+    private final String storeName = \"store\";\n+    private final String key1 = \"a\";\n+    private final String key2 = \"b\";\n+    private final String key3 = \"c\";\n+    private final String key4 = \"d\";\n+\n+    private final String value = \"value\";\n+    private final  Bytes key1Bytes = Bytes.wrap(key1.getBytes());\n+    private final  Bytes key2Bytes = Bytes.wrap(key2.getBytes());\n+    private final  Bytes key3Bytes = Bytes.wrap(key3.getBytes());\n+    private final  Bytes key4Bytes = Bytes.wrap(key4.getBytes());\n+    private final byte[] valueBytes = value.getBytes();\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeInForwardDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key1Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.next();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeReverseDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(key3Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key1Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.prev();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            false\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysWhenLastKeyIsGreaterThanLargestKeyInStateStoreInForwardDirection() {\n+\n+        final String to = \"f\";\n+        final  Bytes toBytes = Bytes.wrap(to.getBytes());\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key1Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key4Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(4);\n+        rocksIterator.next();\n+        expectLastCall().times(4);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            toBytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+\n+    @Test\n+    public void shouldReturnAllKeysWhenLastKeyIsSmallerThanSmallestKeyInStateStoreInReverseDirection() {\n+        final String to = \"a\";\n+        final  Bytes toBytes = Bytes.wrap(to.getBytes());\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(key4Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key4Bytes.get())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key1Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(4);\n+        rocksIterator.prev();\n+        expectLastCall().times(4);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            toBytes,\n+            key4Bytes,\n+            false\n+        );\n+\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+\n+    @Test\n+    public void shouldReturnNoKeysWhenLastKeyIsSmallerThanSmallestKeyInStateStoreForwardDirection() {\n+\n+        // key range in state store: [c-f]\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(false);\n+\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key2Bytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+\n+    }\n+\n+    @Test\n+    public void shouldReturnNoKeysWhenLastKeyIsLargerThanLargestKeyInStateStoreReverseDirection() {\n+\n+        // key range in state store: [c-f]\n+        final String from = \"g\";\n+        final String to = \"h\";\n+\n+        final  Bytes fromBytes = Bytes.wrap(from.getBytes());\n+        final  Bytes toBytes = Bytes.wrap(to.getBytes());\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(toBytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(false);\n+\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            fromBytes,\n+            toBytes,\n+            false\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInPartiallyOverlappingRangeInForwardDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.next();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInPartiallyOverlappingRangeInReverseDirection() {\n+\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        final String to = \"e\";\n+        final Bytes toBytes = Bytes.wrap(to.getBytes());\n+        rocksIterator.seekForPrev(toBytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key4Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.prev();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key3Bytes,\n+            toBytes,\n+            false\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnTheCurrentKeyOnInvokingPeekNextKeyInForwardDirection() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.next();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true\n+        );\n+\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        assertThrows(NoSuchElementException.class, rocksDBRangeIterator::peekNextKey);\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnTheCurrentKeyOnInvokingPeekNextKeyInReverseDirection() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        final String to = \"e\";\n+        final Bytes toBytes = Bytes.wrap(to.getBytes());\n+        rocksIterator.seekForPrev(toBytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key4Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.prev();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+                storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key3Bytes,\n+            toBytes,\n+            false\n+        );\n+\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        assertThrows(NoSuchElementException.class, rocksDBRangeIterator::peekNextKey);\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void testCloseIterator() {", "originalCommit": "92cd48a3477d7dfe9f6c387b55d70946f5c587d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5d7de40be47bc28b6f6ba5684ec8858a5af91c37", "url": "https://github.com/apache/kafka/commit/5d7de40be47bc28b6f6ba5684ec8858a5af91c37", "message": "KAFKA-10766: Unit test cases for RocksDBRangeIterator", "committedDate": "2021-01-31T08:57:34Z", "type": "forcePushed"}, {"oid": "901d8b588130c8dcfe72b3a1674f4d75c173a489", "url": "https://github.com/apache/kafka/commit/901d8b588130c8dcfe72b3a1674f4d75c173a489", "message": "KAFKA-10766: Unit test cases for RocksDBRangeIterator", "committedDate": "2021-02-19T11:35:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTc2NTkwNA==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r581765904", "bodyText": "If you change the toInclusive to true in this test, the test also passes. That means, that you are not testing toInclusive in this test.\nI suggest the following test:\n    public void shouldExcludeEndOfRange() {\n        final RocksIterator rocksIterator = mock(RocksIterator.class);\n        rocksIterator.seek(key1Bytes.get());\n        expect(rocksIterator.isValid())\n            .andReturn(true)\n            .andReturn(true);\n        expect(rocksIterator.key())\n            .andReturn(key1Bytes.get())\n            .andReturn(key2Bytes.get());\n        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n        rocksIterator.next();\n        expectLastCall().times(2);\n        replay(rocksIterator);\n        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n            storeName,\n            rocksIterator,\n            Collections.emptySet(),\n            key1Bytes,\n            key2Bytes,\n            true,\n            false\n        );\n        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n        verify(rocksIterator);\n    }", "author": "cadonna", "createdAt": "2021-02-24T08:51:31Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBRangeIteratorTest.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import org.apache.kafka.common.utils.Bytes;\n+import org.junit.Test;\n+import org.rocksdb.RocksIterator;\n+\n+import java.util.Collections;\n+import java.util.NoSuchElementException;\n+\n+import static org.easymock.EasyMock.mock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.expectLastCall;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertThrows;\n+\n+public class RocksDBRangeIteratorTest {\n+\n+    private final String storeName = \"store\";\n+    private final String key1 = \"a\";\n+    private final String key2 = \"b\";\n+    private final String key3 = \"c\";\n+    private final String key4 = \"d\";\n+\n+    private final String value = \"value\";\n+    private final  Bytes key1Bytes = Bytes.wrap(key1.getBytes());\n+    private final  Bytes key2Bytes = Bytes.wrap(key2.getBytes());\n+    private final  Bytes key3Bytes = Bytes.wrap(key3.getBytes());\n+    private final  Bytes key4Bytes = Bytes.wrap(key4.getBytes());\n+    private final byte[] valueBytes = value.getBytes();\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeInForwardDirection() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key1Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.next();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+            storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInTheRangeReverseDirection() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(key3Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key1Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(3);\n+        rocksIterator.prev();\n+        expectLastCall().times(3);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+            storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            false,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysWhenLastKeyIsGreaterThanLargestKeyInStateStoreInForwardDirection() {\n+        final Bytes toBytes = Bytes.increment(key4Bytes);\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key1Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key4Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(4);\n+        rocksIterator.next();\n+        expectLastCall().times(4);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+            storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            toBytes,\n+            true,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+\n+    @Test\n+    public void shouldReturnAllKeysWhenLastKeyIsSmallerThanSmallestKeyInStateStoreInReverseDirection() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(key4Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key4Bytes.get())\n+            .andReturn(key3Bytes.get())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key1Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(4);\n+        rocksIterator.prev();\n+        expectLastCall().times(4);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+            storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key4Bytes,\n+            false,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key1Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+\n+    @Test\n+    public void shouldReturnNoKeysWhenLastKeyIsSmallerThanSmallestKeyInStateStoreForwardDirection() {\n+        // key range in state store: [c-f]\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid()).andReturn(false);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+            storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key2Bytes,\n+            true,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnNoKeysWhenLastKeyIsLargerThanLargestKeyInStateStoreReverseDirection() {\n+        // key range in state store: [c-f]\n+        final String from = \"g\";\n+        final String to = \"h\";\n+        final  Bytes fromBytes = Bytes.wrap(from.getBytes());\n+        final  Bytes toBytes = Bytes.wrap(to.getBytes());\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seekForPrev(toBytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(false);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+            storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            fromBytes,\n+            toBytes,\n+            false,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInPartiallyOverlappingRangeInForwardDirection() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.next();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+            storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnAllKeysInPartiallyOverlappingRangeInReverseDirection() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        final String to = \"e\";\n+        final Bytes toBytes = Bytes.wrap(to.getBytes());\n+        rocksIterator.seekForPrev(toBytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key4Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.prev();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+            storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key3Bytes,\n+            toBytes,\n+            false,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnTheCurrentKeyOnInvokingPeekNextKeyInForwardDirection() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key2Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.next();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+            storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key3Bytes,\n+            true,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.next().key, is(key2Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        assertThrows(NoSuchElementException.class, rocksDBRangeIterator::peekNextKey);\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnTheCurrentKeyOnInvokingPeekNextKeyInReverseDirection() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        final Bytes toBytes = Bytes.increment(key4Bytes);\n+        rocksIterator.seekForPrev(toBytes.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(key4Bytes.get())\n+            .andReturn(key3Bytes.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.prev();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+            storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key3Bytes,\n+            toBytes,\n+            false,\n+            true\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.next().key, is(key4Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.peekNextKey(), is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.next().key, is(key3Bytes));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        assertThrows(NoSuchElementException.class, rocksDBRangeIterator::peekNextKey);\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldCloseIterator() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        rocksIterator.seek(key1Bytes.get());\n+        rocksIterator.close();\n+        expectLastCall().times(1);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+            storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            key1Bytes,\n+            key2Bytes,\n+            true,\n+            true\n+        );\n+        rocksDBRangeIterator.close();\n+        verify(rocksIterator);\n+    }\n+\n+    @Test\n+    public void shouldReturnNextKeyValueMatchingPrefix() {\n+        final RocksIterator rocksIterator = mock(RocksIterator.class);\n+        final Bytes prefixKey1 = Bytes.wrap(\"prefix-1\".getBytes());\n+        final Bytes prefixKey2 = Bytes.wrap(\"prefix-2\".getBytes());\n+        final Bytes prefix = Bytes.wrap(\"prefix\".getBytes());\n+        final Bytes toBytes = Bytes.increment(prefix);\n+        rocksIterator.seek(prefix.get());\n+        expect(rocksIterator.isValid())\n+            .andReturn(true)\n+            .andReturn(true)\n+            .andReturn(false);\n+        expect(rocksIterator.key())\n+            .andReturn(prefixKey1.get())\n+            .andReturn(prefixKey2.get());\n+        expect(rocksIterator.value()).andReturn(valueBytes).times(2);\n+        rocksIterator.next();\n+        expectLastCall().times(2);\n+        replay(rocksIterator);\n+        final RocksDBRangeIterator rocksDBRangeIterator = new RocksDBRangeIterator(\n+            storeName,\n+            rocksIterator,\n+            Collections.emptySet(),\n+            prefix,\n+            toBytes,\n+            true,\n+            false\n+        );\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(prefixKey1));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(true));\n+        assertThat(rocksDBRangeIterator.next().key, is(prefixKey2));\n+        assertThat(rocksDBRangeIterator.hasNext(), is(false));\n+        verify(rocksIterator);\n+    }", "originalCommit": "901d8b588130c8dcfe72b3a1674f4d75c173a489", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjYyOTQ3OQ==", "url": "https://github.com/apache/kafka/pull/9717#discussion_r582629479", "bodyText": "@cadonna , added this test.", "author": "vamossagar12", "createdAt": "2021-02-25T08:22:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTc2NTkwNA=="}], "type": "inlineReview"}, {"oid": "bb34c6a67fc87e4066d97d861710d95fabdeb2f7", "url": "https://github.com/apache/kafka/commit/bb34c6a67fc87e4066d97d861710d95fabdeb2f7", "message": "KAFKA-10766: Unit test cases for RocksDBRangeIterator", "committedDate": "2021-02-25T08:21:31Z", "type": "commit"}, {"oid": "bb34c6a67fc87e4066d97d861710d95fabdeb2f7", "url": "https://github.com/apache/kafka/commit/bb34c6a67fc87e4066d97d861710d95fabdeb2f7", "message": "KAFKA-10766: Unit test cases for RocksDBRangeIterator", "committedDate": "2021-02-25T08:21:31Z", "type": "forcePushed"}]}