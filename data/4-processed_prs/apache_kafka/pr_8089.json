{"pr_number": 8089, "pr_title": "KAFKA-6266: Repeated occurrence of WARN Resetting first dirty offset", "pr_createdAt": "2020-02-11T18:34:41Z", "pr_url": "https://github.com/apache/kafka/pull/8089", "timeline": [{"oid": "daee236d53286fac06a4dbfd69a36eacd0e79062", "url": "https://github.com/apache/kafka/commit/daee236d53286fac06a4dbfd69a36eacd0e79062", "message": "KAFKA-6266: Repeated occurrence of WARN Resetting first dirty offset", "committedDate": "2020-02-11T18:26:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMzIyMQ==", "url": "https://github.com/apache/kafka/pull/8089#discussion_r377923221", "bodyText": "LogCleanerManager.updateCheckpoints() can be called with update=None. In this case, the method removes topic partitions that no longer exist from the checkpoint file. It looks like the test suite does not deal with test cases that remove partitions when testing with mock log cleaner manager. However, it's useful to handle this case explicitly here so that it is easier to debug if code changes, etc.\nI think it's enough to throw an exception here if update=None with the explicit message that this case is not handled (yet) by LogCleanerManagerMock (you can do this by calling `update.getOrElse(throw new...)). Or maybe you have other ideas.", "author": "apovzner", "createdAt": "2020-02-11T21:55:30Z", "path": "core/src/test/scala/unit/kafka/log/LogCleanerManagerTest.scala", "diffHunk": "@@ -54,6 +54,11 @@ class LogCleanerManagerTest extends Logging {\n     override def allCleanerCheckpoints: Map[TopicPartition, Long] = {\n       cleanerCheckpoints.toMap\n     }\n+\n+    override def updateCheckpoints(dataDir: File, update: Option[(TopicPartition,Long)]): Unit = {\n+      val (tp, offset) = update.get", "originalCommit": "daee236d53286fac06a4dbfd69a36eacd0e79062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMDM5Mw==", "url": "https://github.com/apache/kafka/pull/8089#discussion_r377930393", "bodyText": "I agree with your comment on this PR that it is better to move the call to updateCheckpoints to cleanableOffsets / closer to the logic that resets the first dirty offset, since you know exactly when the offset was reset and there is no need to check again. Otherwise, we are opening more possibilities for future bugs if the logic changes but only one place gets updated.", "author": "apovzner", "createdAt": "2020-02-11T22:11:18Z", "path": "core/src/main/scala/kafka/log/LogCleanerManager.scala", "diffHunk": "@@ -179,7 +179,11 @@ private[log] class LogCleanerManager(val logDirs: Seq[File],\n         case (topicPartition, log) => // create a LogToClean instance for each\n           try {\n             val lastCleanOffset = lastClean.get(topicPartition)\n+            val logStartOffset = log.logStartOffset\n             val (firstDirtyOffset, firstUncleanableDirtyOffset) = cleanableOffsets(log, lastCleanOffset, now)\n+            // update checkpoint for logs with invalid checkpointed offsets", "originalCommit": "daee236d53286fac06a4dbfd69a36eacd0e79062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eeed9bf2de684ecccb0a7460b9e1ed3ad1ae3cdc", "url": "https://github.com/apache/kafka/commit/eeed9bf2de684ecccb0a7460b9e1ed3ad1ae3cdc", "message": "refactor code to keep checkpoint reset logic in one location", "committedDate": "2020-02-12T01:01:20Z", "type": "commit"}, {"oid": "022c65ac281169fba0db84ac8d6c7f8f415da970", "url": "https://github.com/apache/kafka/commit/022c65ac281169fba0db84ac8d6c7f8f415da970", "message": "updates javadoc for OffsetsToClean, fixes cleanOffsets inconsistency", "committedDate": "2020-02-12T01:08:00Z", "type": "commit"}, {"oid": "586de577887a2e221aa02821d8dd8f39a187d74a", "url": "https://github.com/apache/kafka/commit/586de577887a2e221aa02821d8dd8f39a187d74a", "message": "mock updateCheckpoints update=None case", "committedDate": "2020-02-12T01:11:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM5ODM0NQ==", "url": "https://github.com/apache/kafka/pull/8089#discussion_r378398345", "bodyText": "Could you use @param tag for each parameter description? When describing needUpdateCheckpoint, would be useful to mention that firstDirtyOffset is the new checkpoint offset to update to (if true).\nAlso, there may be multiple segments between firstDirtyOffset and firstUncleanableDirtyOffset offsets, so instead of \"for the cleanable segment of a log\" maybe say something like \"that represents a range of dirty offsets that can be cleaned\".", "author": "apovzner", "createdAt": "2020-02-12T17:22:30Z", "path": "core/src/main/scala/kafka/log/LogCleanerManager.scala", "diffHunk": "@@ -480,6 +484,15 @@ private[log] class LogCleanerManager(val logDirs: Seq[File],\n   }\n }\n \n+/**\n+ * Helper class for the cleanable segment of a log and whether to update the checkpoint associated with the log\n+ * firstDirtyOffset the lower (inclusive) and firstUncleanableDirtyOffset the upper(exclusive) offsets", "originalCommit": "586de577887a2e221aa02821d8dd8f39a187d74a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQwODMxMg==", "url": "https://github.com/apache/kafka/pull/8089#discussion_r378408312", "bodyText": "It's better to use offsetsToClean. firstDirtyOffset instead of logStartOffset here, because that would remove the assumption in the code that offsetsToClean. firstDirtyOffset would always be log start offset when needUpdateCheckpoint is true.", "author": "apovzner", "createdAt": "2020-02-12T17:40:32Z", "path": "core/src/main/scala/kafka/log/LogCleanerManager.scala", "diffHunk": "@@ -179,11 +179,15 @@ private[log] class LogCleanerManager(val logDirs: Seq[File],\n         case (topicPartition, log) => // create a LogToClean instance for each\n           try {\n             val lastCleanOffset = lastClean.get(topicPartition)\n-            val (firstDirtyOffset, firstUncleanableDirtyOffset) = cleanableOffsets(log, lastCleanOffset, now)\n-            val compactionDelayMs = maxCompactionDelay(log, firstDirtyOffset, now)\n+            val logStartOffset = log.logStartOffset\n+            val offsetsToClean = cleanableOffsets(log, lastCleanOffset, now)\n+            // update checkpoint for logs with invalid checkpointed offsets\n+            if (offsetsToClean.needUpdateCheckpoint)\n+              updateCheckpoints(log.dir.getParentFile(), Option(topicPartition, logStartOffset))", "originalCommit": "586de577887a2e221aa02821d8dd8f39a187d74a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQxMjE2NA==", "url": "https://github.com/apache/kafka/pull/8089#discussion_r378412164", "bodyText": "looks like math (scala) got replaced with Math (java), probably unintentional?", "author": "apovzner", "createdAt": "2020-02-12T17:47:47Z", "path": "core/src/main/scala/kafka/log/LogCleanerManager.scala", "diffHunk": "@@ -572,7 +588,7 @@ private[log] object LogCleanerManager extends Logging {\n       s\"now=$now => firstDirtyOffset=$firstDirtyOffset firstUncleanableOffset=$firstUncleanableDirtyOffset \" +\n       s\"activeSegment.baseOffset=${log.activeSegment.baseOffset}\")\n \n-    (firstDirtyOffset, math.max(firstDirtyOffset, firstUncleanableDirtyOffset))\n+    OffsetsToClean(firstDirtyOffset, Math.max(firstDirtyOffset, firstUncleanableDirtyOffset), needsUpdateCheckpoint)", "originalCommit": "586de577887a2e221aa02821d8dd8f39a187d74a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQxNjU3NQ==", "url": "https://github.com/apache/kafka/pull/8089#discussion_r378416575", "bodyText": "I think it should be ok to also return true (update checkpoint file) for \"compact, delete\" topics as well, even though we are not printing a warning for them. @junrao What do you think? It seems consistent to update checkpoint for all the cases here that set firstDirtyOffset to log start; unless there is a reason to only update checkpoint when we print the warning about resetting first dirty offset?", "author": "apovzner", "createdAt": "2020-02-12T17:56:22Z", "path": "core/src/main/scala/kafka/log/LogCleanerManager.scala", "diffHunk": "@@ -515,29 +528,32 @@ private[log] object LogCleanerManager extends Logging {\n     * @param log the log\n     * @param lastCleanOffset the last checkpointed offset\n     * @param now the current time in milliseconds of the cleaning operation\n-    * @return the lower (inclusive) and upper (exclusive) offsets\n+    * @return OffsetsToClean containing offsets for cleanable portion of log and whether the log checkpoint needs updating\n     */\n-  def cleanableOffsets(log: Log, lastCleanOffset: Option[Long], now: Long): (Long, Long) = {\n+  def cleanableOffsets(log: Log, lastCleanOffset: Option[Long], now: Long): OffsetsToClean = {\n     // If the log segments are abnormally truncated and hence the checkpointed offset is no longer valid;\n     // reset to the log starting offset and log the error\n-    val firstDirtyOffset = {\n+    val (firstDirtyOffset, needsUpdateCheckpoint) = {\n       val logStartOffset = log.logStartOffset\n       val checkpointDirtyOffset = lastCleanOffset.getOrElse(logStartOffset)\n \n       if (checkpointDirtyOffset < logStartOffset) {\n         // Don't bother with the warning if compact and delete are enabled.\n-        if (!isCompactAndDelete(log))\n+        if (!isCompactAndDelete(log)) {\n           warn(s\"Resetting first dirty offset of ${log.name} to log start offset $logStartOffset \" +\n             s\"since the checkpointed offset $checkpointDirtyOffset is invalid.\")\n-        logStartOffset\n+          (logStartOffset, true)", "originalCommit": "586de577887a2e221aa02821d8dd8f39a187d74a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzOTE3Mg==", "url": "https://github.com/apache/kafka/pull/8089#discussion_r379139172", "bodyText": "The reason that we don't log a warn here is that checkpointDirtyOffset is expected to be less than logStartOffset for compact and delete topic. However, it does seem we should update dirtyOffset in this case.", "author": "junrao", "createdAt": "2020-02-13T21:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQxNjU3NQ=="}], "type": "inlineReview"}, {"oid": "4e9f934550f13105385b3094049c69e3c3d56331", "url": "https://github.com/apache/kafka/commit/4e9f934550f13105385b3094049c69e3c3d56331", "message": "updates javadoc, small fixes for code review", "committedDate": "2020-02-13T01:28:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzMjY3Ng==", "url": "https://github.com/apache/kafka/pull/8089#discussion_r379132676", "bodyText": "To make it clear, perhaps needUpdateCheckpoint can be forceUpdateCheckpoint?", "author": "junrao", "createdAt": "2020-02-13T21:37:56Z", "path": "core/src/main/scala/kafka/log/LogCleanerManager.scala", "diffHunk": "@@ -480,6 +483,20 @@ private[log] class LogCleanerManager(val logDirs: Seq[File],\n   }\n }\n \n+/**\n+ * Helper class for the range of cleanable dirty offsets of a log and whether to update the checkpoint associated with\n+ * the log\n+ *\n+ * @param firstDirtyOffset the lower (inclusive) offset to begin cleaning from\n+ * @param firstUncleanableDirtyOffset the upper(exclusive) offset to clean to\n+ * @param needUpdateCheckpoint whether to update the checkpoint associated with this log. if true, checkpoint should be\n+ *                             reset to firstDirtyOffset\n+ */\n+private case class OffsetsToClean(firstDirtyOffset: Long,\n+                                  firstUncleanableDirtyOffset: Long,\n+                                  needUpdateCheckpoint: Boolean = false) {", "originalCommit": "4e9f934550f13105385b3094049c69e3c3d56331", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNjIzNw==", "url": "https://github.com/apache/kafka/pull/8089#discussion_r379136237", "bodyText": "Could we add some error message that explains the expectation if the test fails? Ditto below.", "author": "junrao", "createdAt": "2020-02-13T21:45:37Z", "path": "core/src/test/scala/unit/kafka/log/LogCleanerManagerTest.scala", "diffHunk": "@@ -478,8 +483,30 @@ class LogCleanerManagerTest extends Logging {\n \n     val lastCleanOffset = Some(0L)\n     val cleanableOffsets = LogCleanerManager.cleanableOffsets(log, lastCleanOffset, time.milliseconds)\n-    assertEquals(\"The first cleanable offset starts at the beginning of the log.\", 0L, cleanableOffsets._1)\n-    assertEquals(\"The first uncleanable offset begins with active segment.\", log.activeSegment.baseOffset, cleanableOffsets._2)\n+    assertEquals(\"The first cleanable offset starts at the beginning of the log.\", 0L, cleanableOffsets.firstDirtyOffset)\n+    assertEquals(\"The first uncleanable offset begins with active segment.\", log.activeSegment.baseOffset, cleanableOffsets.firstUncleanableDirtyOffset)\n+  }\n+\n+  @Test\n+  def testCleanableOffsetsNeedsCheckpointReset(): Unit = {\n+    val tp = new TopicPartition(\"foo\", 0)\n+    val logs = setupIncreasinglyFilthyLogs(Seq(tp), startNumBatches = 20, batchIncrement = 5)\n+    logs.get(tp).maybeIncrementLogStartOffset(10L)\n+\n+    var lastCleanOffset = Some(15L)\n+    var cleanableOffsets = LogCleanerManager.cleanableOffsets(logs.get(tp), lastCleanOffset, time.milliseconds)\n+    assertEquals(false, cleanableOffsets.needUpdateCheckpoint)", "originalCommit": "4e9f934550f13105385b3094049c69e3c3d56331", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNjg5Nw==", "url": "https://github.com/apache/kafka/pull/8089#discussion_r379136897", "bodyText": "Do we need // ?", "author": "junrao", "createdAt": "2020-02-13T21:47:03Z", "path": "core/src/test/scala/unit/kafka/log/LogCleanerManagerTest.scala", "diffHunk": "@@ -574,6 +601,45 @@ class LogCleanerManagerTest extends Logging {\n     assertEquals(LogCleaningPaused(1), cleanerManager.cleaningState(tp).get)\n   }\n \n+  /**\n+   * Logs with invalid checkpoint offsets should update their checkpoint offset even if the log doesn't need cleaning\n+   */\n+  @Test\n+  def testCheckpointUpdatedForInvalidOffsetNoCleaning(): Unit = {\n+    val tp = new TopicPartition(\"foo\", 0)\n+    val logs = setupIncreasinglyFilthyLogs(Seq(tp), startNumBatches = 20, batchIncrement = 5)\n+\n+    logs.get(tp).maybeIncrementLogStartOffset(20L)\n+    val cleanerManager = createCleanerManagerMock(logs)\n+    cleanerCheckpoints.put(tp, 15L)\n+\n+    val filthiestLog = cleanerManager.grabFilthiestCompactedLog(time)\n+    assertEquals(None, filthiestLog)\n+    assertEquals(20L, cleanerCheckpoints.get(tp).get)\n+  }\n+\n+  /**\n+   * Logs with invalid checkpoint offsets should update their checkpoint offset even if they aren't selected\n+   * for immediate cleaning\n+//   */", "originalCommit": "4e9f934550f13105385b3094049c69e3c3d56331", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "501f8d3b6e1531d3ef0a1cf6705ffa462b45ea2f", "url": "https://github.com/apache/kafka/commit/501f8d3b6e1531d3ef0a1cf6705ffa462b45ea2f", "message": "variable rename, adds messages for test failures", "committedDate": "2020-02-13T23:19:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY5NDA2MA==", "url": "https://github.com/apache/kafka/pull/8089#discussion_r379694060", "bodyText": "you can also use assertFalse here or assertTrue (below) when testing equality with the boolean value.", "author": "apovzner", "createdAt": "2020-02-14T23:53:35Z", "path": "core/src/test/scala/unit/kafka/log/LogCleanerManagerTest.scala", "diffHunk": "@@ -478,8 +483,27 @@ class LogCleanerManagerTest extends Logging {\n \n     val lastCleanOffset = Some(0L)\n     val cleanableOffsets = LogCleanerManager.cleanableOffsets(log, lastCleanOffset, time.milliseconds)\n-    assertEquals(\"The first cleanable offset starts at the beginning of the log.\", 0L, cleanableOffsets._1)\n-    assertEquals(\"The first uncleanable offset begins with active segment.\", log.activeSegment.baseOffset, cleanableOffsets._2)\n+    assertEquals(\"The first cleanable offset starts at the beginning of the log.\", 0L, cleanableOffsets.firstDirtyOffset)\n+    assertEquals(\"The first uncleanable offset begins with active segment.\", log.activeSegment.baseOffset, cleanableOffsets.firstUncleanableDirtyOffset)\n+  }\n+\n+  @Test\n+  def testCleanableOffsetsNeedsCheckpointReset(): Unit = {\n+    val tp = new TopicPartition(\"foo\", 0)\n+    val logs = setupIncreasinglyFilthyLogs(Seq(tp), startNumBatches = 20, batchIncrement = 5)\n+    logs.get(tp).maybeIncrementLogStartOffset(10L)\n+\n+    var lastCleanOffset = Some(15L)\n+    var cleanableOffsets = LogCleanerManager.cleanableOffsets(logs.get(tp), lastCleanOffset, time.milliseconds)\n+    assertEquals(\"Checkpoint offset should not be reset if valid\", false, cleanableOffsets.forceUpdateCheckpoint)", "originalCommit": "501f8d3b6e1531d3ef0a1cf6705ffa462b45ea2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7a9d3dd627db241e942dc296946d9f2b3f7a4faf", "url": "https://github.com/apache/kafka/commit/7a9d3dd627db241e942dc296946d9f2b3f7a4faf", "message": "fix asserts", "committedDate": "2020-02-15T00:07:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1MDA4Mw==", "url": "https://github.com/apache/kafka/pull/8089#discussion_r380850083", "bodyText": "Should we change needsUpdateCheckpoint to forceUpdateCheckpoint?", "author": "junrao", "createdAt": "2020-02-18T18:18:55Z", "path": "core/src/main/scala/kafka/log/LogCleanerManager.scala", "diffHunk": "@@ -515,12 +532,12 @@ private[log] object LogCleanerManager extends Logging {\n     * @param log the log\n     * @param lastCleanOffset the last checkpointed offset\n     * @param now the current time in milliseconds of the cleaning operation\n-    * @return the lower (inclusive) and upper (exclusive) offsets\n+    * @return OffsetsToClean containing offsets for cleanable portion of log and whether the log checkpoint needs updating\n     */\n-  def cleanableOffsets(log: Log, lastCleanOffset: Option[Long], now: Long): (Long, Long) = {\n+  def cleanableOffsets(log: Log, lastCleanOffset: Option[Long], now: Long): OffsetsToClean = {\n     // If the log segments are abnormally truncated and hence the checkpointed offset is no longer valid;\n     // reset to the log starting offset and log the error\n-    val firstDirtyOffset = {\n+    val (firstDirtyOffset, needsUpdateCheckpoint) = {", "originalCommit": "7a9d3dd627db241e942dc296946d9f2b3f7a4faf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "90f350679fa01f4613b1e6cfeca25ec412086817", "url": "https://github.com/apache/kafka/commit/90f350679fa01f4613b1e6cfeca25ec412086817", "message": "consistent variable naming", "committedDate": "2020-02-18T19:04:50Z", "type": "commit"}]}