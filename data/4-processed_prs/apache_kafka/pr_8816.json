{"pr_number": 8816, "pr_title": "MINOR: Print all removed dynamic members during join complete", "pr_createdAt": "2020-06-05T17:01:40Z", "pr_url": "https://github.com/apache/kafka/pull/8816", "timeline": [{"oid": "e63b4641f24b17cf4e75239515a27213fb5bc1ee", "url": "https://github.com/apache/kafka/commit/e63b4641f24b17cf4e75239515a27213fb5bc1ee", "message": "add dynamic member function and enhance the test cases", "committedDate": "2020-06-05T16:59:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0ODcxMw==", "url": "https://github.com/apache/kafka/pull/8816#discussion_r436048713", "bodyText": "This is a cleanup. In the current logic we should never hit a static member in this block", "author": "abbccdda", "createdAt": "2020-06-05T17:02:37Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1150,7 +1150,6 @@ class GroupCoordinator(val brokerId: Int,\n       group.notYetRejoinedMembers.filterNot(_.isStaticMember) foreach { failedMember =>\n         removeHeartbeatForLeavingMember(group, failedMember)\n         group.remove(failedMember.memberId)\n-        group.removeStaticMember(failedMember.groupInstanceId)", "originalCommit": "e63b4641f24b17cf4e75239515a27213fb5bc1ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzMTczOQ==", "url": "https://github.com/apache/kafka/pull/8816#discussion_r436131739", "bodyText": "Shouldn't we include the group id in the log as well?", "author": "dajac", "createdAt": "2020-06-05T19:51:20Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1186,6 +1185,8 @@ class GroupCoordinator(val brokerId: Int,\n           for (member <- group.allMemberMetadata) {\n             val joinResult = JoinGroupResult(\n               members = if (group.isLeader(member.memberId)) {\n+                info(s\"Reply the group leader with the following dynamic members' metadata: ${group.allDynamicMembers}\" +\n+                  s\"and static members' metadata: ${group.allStaticMembers}\")", "originalCommit": "e63b4641f24b17cf4e75239515a27213fb5bc1ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MDM2NA==", "url": "https://github.com/apache/kafka/pull/8816#discussion_r436140364", "bodyText": "Good idea", "author": "abbccdda", "createdAt": "2020-06-05T20:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzMTczOQ=="}], "type": "inlineReview"}, {"oid": "c968af37aa8dd1d073074b69afa14a86e141b11b", "url": "https://github.com/apache/kafka/commit/c968af37aa8dd1d073074b69afa14a86e141b11b", "message": "add group id", "committedDate": "2020-06-05T20:07:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MTIwNg==", "url": "https://github.com/apache/kafka/pull/8816#discussion_r436191206", "bodyText": "Do we need to print this for every member? That is O(n^2). Keep in mind that groups in the thousands are not unheard of. I think it would be better if we just ensured that we log the id of every member entering and leaving the group.", "author": "hachikuji", "createdAt": "2020-06-05T22:25:31Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1186,6 +1185,9 @@ class GroupCoordinator(val brokerId: Int,\n           for (member <- group.allMemberMetadata) {\n             val joinResult = JoinGroupResult(\n               members = if (group.isLeader(member.memberId)) {\n+                info(s\"Group ${group.groupId} replies the leader with \" +", "originalCommit": "c968af37aa8dd1d073074b69afa14a86e141b11b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fcfb77f0960625746f76c42bbb30cb6827d04f76", "url": "https://github.com/apache/kafka/commit/fcfb77f0960625746f76c42bbb30cb6827d04f76", "message": "only log removed members", "committedDate": "2020-06-06T00:32:03Z", "type": "commit"}, {"oid": "fcfb77f0960625746f76c42bbb30cb6827d04f76", "url": "https://github.com/apache/kafka/commit/fcfb77f0960625746f76c42bbb30cb6827d04f76", "message": "only log removed members", "committedDate": "2020-06-06T00:32:03Z", "type": "forcePushed"}, {"oid": "72012b2f9eba7e557170c62b2cab93a17b313c4f", "url": "https://github.com/apache/kafka/commit/72012b2f9eba7e557170c62b2cab93a17b313c4f", "message": "fix tests", "committedDate": "2020-06-08T15:51:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NTMwOQ==", "url": "https://github.com/apache/kafka/pull/8816#discussion_r437795309", "bodyText": "Nice catch.", "author": "guozhangwang", "createdAt": "2020-06-10T00:31:16Z", "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1146,12 +1146,16 @@ class GroupCoordinator(val brokerId: Int,\n \n   def onCompleteJoin(group: GroupMetadata): Unit = {\n     group.inLock {\n-      // remove dynamic members who haven't joined the group yet\n-      group.notYetRejoinedMembers.filterNot(_.isStaticMember) foreach { failedMember =>\n-        removeHeartbeatForLeavingMember(group, failedMember)\n-        group.remove(failedMember.memberId)\n-        group.removeStaticMember(failedMember.groupInstanceId)", "originalCommit": "72012b2f9eba7e557170c62b2cab93a17b313c4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}