{"pr_number": 7929, "pr_title": "KAFKA-9393: DeleteRecords may cause extreme lock contention for large partition directories", "pr_createdAt": "2020-01-10T19:03:54Z", "pr_url": "https://github.com/apache/kafka/pull/7929", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc4MzMzNg==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r367783336", "bodyText": "This should be moved to loadLog() since it only needs to run at startup. Also, the set of offsets to delete should exclude the log end offset, since that is snapshotted out during shutdown.", "author": "gardnervickers", "createdAt": "2020-01-17T06:16:05Z", "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -870,6 +870,10 @@ class Log(@volatile var dir: File,\n   }\n \n   private def loadProducerState(lastOffset: Long, reloadFromCleanShutdown: Boolean): Unit = lock synchronized {\n+    // Pass the set of loaded segment base offsets to diff against the set of producer state snapshot\n+    // files. Any orphaned files should be cleaned up.\n+    val keepOffsets = logSegments.map(_.baseOffset)\n+    producerStateManager.cleanupOrphanSnapshotFiles(keepOffsets)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ0Mjc2OQ==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r371442769", "bodyText": "nit: I'd suggest a more descriptive name like segmentBaseOffsets", "author": "hachikuji", "createdAt": "2020-01-27T19:40:36Z", "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -310,6 +310,10 @@ class Log(@volatile var dir: File,\n     // from scratch.\n     if (!producerStateManager.isEmpty)\n       throw new IllegalStateException(\"Producer state must be empty during log initialization\")\n+    // Pass the set of loaded segment base offsets to diff against the set of producer state snapshot\n+    // files. Any orphaned files should be cleaned up.\n+    val keepOffsets = logSegments.map(_.baseOffset)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ0MzU2Nw==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r371443567", "bodyText": "nit: braces are probably not needed", "author": "hachikuji", "createdAt": "2020-01-27T19:42:05Z", "path": "core/src/main/scala/kafka/log/LogSegment.scala", "diffHunk": "@@ -622,7 +623,8 @@ class LogSegment private[log] (val log: FileRecords,\n       () => delete(log.deleteIfExists _, \"log\", log.file, logIfMissing = true),\n       () => delete(offsetIndex.deleteIfExists _, \"offset index\", lazyOffsetIndex.file, logIfMissing = true),\n       () => delete(timeIndex.deleteIfExists _, \"time index\", lazyTimeIndex.file, logIfMissing = true),\n-      () => delete(txnIndex.deleteIfExists _, \"transaction index\", txnIndex.file, logIfMissing = false)\n+      () => delete(txnIndex.deleteIfExists _, \"transaction index\", txnIndex.file, logIfMissing = false),\n+      () => delete(() => {Files.deleteIfExists(producerStateSnapshot.toPath)}, \"producer state snapshot\", producerStateSnapshot, logIfMissing = false)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxMTgyOA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r371511828", "bodyText": "Just mentioning this as an observation. Unlike the index files, which have a lifecycle clearly tied to the segment, producer snapshots are a bit of a mix. They are created in Log when a segment is rolled, but deletion is the job of the segment. I'm partially wondering if it would be clearer to handle both operations in the same context.", "author": "hachikuji", "createdAt": "2020-01-27T22:12:11Z", "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -310,6 +310,10 @@ class Log(@volatile var dir: File,\n     // from scratch.\n     if (!producerStateManager.isEmpty)\n       throw new IllegalStateException(\"Producer state must be empty during log initialization\")\n+    // Pass the set of loaded segment base offsets to diff against the set of producer state snapshot\n+    // files. Any orphaned files should be cleaned up.\n+    val keepOffsets = logSegments.map(_.baseOffset)\n+    producerStateManager.cleanupOrphanSnapshotFiles(keepOffsets)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgzNDI1Ng==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r374834256", "bodyText": "Hmm I might be misunderstanding @hachikuji but the current PR should delete producer state snapshot files along with segment deletion. I included this additional cleanup step during log opening because snapshot files are not atomically renamed as part of deletion like other files, which seems to allow for orphaned files if there is a crash during segment deletion. Are you suggesting that we handle snapshot file deletion like the deletion of index/segment files by adding the deleted suffix?", "author": "gardnervickers", "createdAt": "2020-02-04T18:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxMTgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NDMxNg==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r375564316", "bodyText": "What I was saying is more in line with Jun's comment below. It is more about managing the lifecycle of the snapshot consistently. Typically it's simpler if creation and deletion happen in the same context.", "author": "hachikuji", "createdAt": "2020-02-05T23:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUxMTgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUyMDE0MA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r371520140", "bodyText": "Can we add a log message when we delete snapshot files?", "author": "hachikuji", "createdAt": "2020-01-27T22:32:18Z", "path": "core/src/main/scala/kafka/log/ProducerStateManager.scala", "diffHunk": "@@ -759,6 +759,15 @@ class ProducerStateManager(val topicPartition: TopicPartition,\n       None\n   }\n \n-  private def listSnapshotFiles: Seq[File] = ProducerStateManager.listSnapshotFiles(logDir)\n+  private[log] def listSnapshotFiles: Seq[File] = ProducerStateManager.listSnapshotFiles(logDir)\n \n+  /**\n+   * Remove any producer state snapshot files which do not have a corresponding offset provided\n+   * in keepOffsets. The latest snapshot file will always be kept.\n+   */\n+  def cleanupOrphanSnapshotFiles(keepOffsets: Iterable[Long]): Unit = {\n+    val expected = keepOffsets.map(Log.producerSnapshotFile(logDir, _)).toSet ++ latestSnapshotFile\n+    val actual = listSnapshotFiles.toSet\n+    actual.diff(expected).foreach(file => Files.deleteIfExists(file.toPath))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUyMTcxOA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r371521718", "bodyText": "Was there a reason you chose to cleanup the orphaned files before loading producer state? I'm not sure it matters too much, but it does mean that we won't remove the snapshot from the log end offset until the following restart.", "author": "hachikuji", "createdAt": "2020-01-27T22:36:08Z", "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -310,6 +310,10 @@ class Log(@volatile var dir: File,\n     // from scratch.\n     if (!producerStateManager.isEmpty)\n       throw new IllegalStateException(\"Producer state must be empty during log initialization\")\n+    // Pass the set of loaded segment base offsets to diff against the set of producer state snapshot\n+    // files. Any orphaned files should be cleaned up.\n+    val keepOffsets = logSegments.map(_.baseOffset)\n+    producerStateManager.cleanupOrphanSnapshotFiles(keepOffsets)\n     loadProducerState(logEndOffset, reloadFromCleanShutdown = hasCleanShutdownFile)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM0MTgwNQ==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r373341805", "bodyText": "I don't have a specific reason for this, but that's a good point that we won't remove the log end offset snapshot file until the next restart. I'll swap the ordering here, thanks!", "author": "gardnervickers", "createdAt": "2020-01-31T07:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUyMTcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxMzgzOQ==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r375013839", "bodyText": "So, this means that we will be removing the producer snapshot corresponding to log end offset. One of the potential impact is that if the broker has an immediate hard failure after this point, the recovery will have to rebuild the producer snapshot for the active segment, which can be expensive. We probably want to think if there is any other impact.", "author": "junrao", "createdAt": "2020-02-05T01:20:00Z", "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -311,6 +311,10 @@ class Log(@volatile var dir: File,\n     if (!producerStateManager.isEmpty)\n       throw new IllegalStateException(\"Producer state must be empty during log initialization\")\n     loadProducerState(logEndOffset, reloadFromCleanShutdown = hasCleanShutdownFile)\n+    // Pass the set of loaded segment base offsets to diff against the set of producer state snapshot\n+    // files. Any orphaned files should be cleaned up.\n+    val segmentBaseOffsets = logSegments.map(_.baseOffset)\n+    producerStateManager.cleanupOrphanSnapshotFiles(segmentBaseOffsets)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2MjQzMw==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r375362433", "bodyText": "I think cleanupOrphanSnapshotFiles always retains the last snapshot.", "author": "hachikuji", "createdAt": "2020-02-05T16:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxMzgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5MTAwOA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r375391008", "bodyText": "Thanks. Sounds good. We probably should change the comment above to make it clear that the last snapshot is always preserved?", "author": "junrao", "createdAt": "2020-02-05T17:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxMzgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxNTY2Mg==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r375015662", "bodyText": "Hmm, should we include fileSuffix in producerStateSnapshot too?", "author": "junrao", "createdAt": "2020-02-05T01:26:49Z", "path": "core/src/main/scala/kafka/log/LogSegment.scala", "diffHunk": "@@ -653,11 +655,13 @@ object LogSegment {\n   def open(dir: File, baseOffset: Long, config: LogConfig, time: Time, fileAlreadyExists: Boolean = false,\n            initFileSize: Int = 0, preallocate: Boolean = false, fileSuffix: String = \"\"): LogSegment = {\n     val maxIndexSize = config.maxIndexSize\n+    val producerStateSnapshot = Log.producerSnapshotFile(dir, baseOffset)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxNjI1NA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r375016254", "bodyText": "Hmm, it seems that we are missing the handling of producerStateSnapshot in a few methods like changeFileSuffixes(), updateDir(), and potentially flush().", "author": "junrao", "createdAt": "2020-02-05T01:29:18Z", "path": "core/src/main/scala/kafka/log/LogSegment.scala", "diffHunk": "@@ -57,6 +57,7 @@ class LogSegment private[log] (val log: FileRecords,\n                                val lazyOffsetIndex: LazyIndex[OffsetIndex],\n                                val lazyTimeIndex: LazyIndex[TimeIndex],\n                                val txnIndex: TransactionIndex,\n+                               val producerStateSnapshot: File,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1MDI5Ng==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r375050296", "bodyText": "Hmm I think if we want to treat producer snapshot files like other index files, it seems we may need a different approach. In this PR I was relying on cleanupOrphanSnapshotFiles to avoid having to deal with changeFileSuffixes and updateDir.", "author": "gardnervickers", "createdAt": "2020-02-05T04:07:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxNjI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1ODI4Mg==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r375058282", "bodyText": "Hmm, by putting producerStateSnapshot inside LogSegment, it seems to suggest that producerStateSnapshot should be managed as other files belonging to a segment?", "author": "junrao", "createdAt": "2020-02-05T04:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxNjI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1OTEzNg==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r375059136", "bodyText": "I would agree.", "author": "ijuma", "createdAt": "2020-02-05T04:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxNjI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM3OTgxMg==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r375379812", "bodyText": "That sounds good, I was just saying the approach taken in this PR will have to be rethought depending on what degree we want the LogSegment to manage producer state snapshots versus the Log/ProducerStateManager. I can think of two options which can be taken to improve the ownership here a bit.\n\n\nThe Log continues to manage producer state snapshots via the ProducerStateManager and the logic for deletion is lifted back into the log layer. This means wherever we try to delete segments with LogSegment.deleteIfExists we also delete the corresponding producer state snapshot via a call to the ProducerStateManager. I think this most closely resembles the current state in trunk.\n\n\nThe LogSegment and Log/ProducerStateManager share ownership of the producer state snapshot with only the LogSegment owning deletion and access going through the ProducerStateManager. This may allow us to get rid of the producer state snapshot specific truncation logic in ProducerStateManager. The question here is what to do about producer state snapshot files which don't match a corresponding segments base offset. This may not be too bad as I think in all cases they would just be associated with the active segment.", "author": "gardnervickers", "createdAt": "2020-02-05T16:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxNjI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxMTc0Nw==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r375411747", "bodyText": "I see. The tricky thing is that the last snapshot doesn't have a corresponding log segment and needs to be managed separately outside of the LogSegment. However, for snapshots that have an associated segment, managing the snapshot file as part of the log segment seems convenient.", "author": "junrao", "createdAt": "2020-02-05T17:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAxNjI1NA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "be858cd5a3f9be029ec2a7368024028403c976c5", "url": "https://github.com/apache/kafka/commit/be858cd5a3f9be029ec2a7368024028403c976c5", "message": "KAFKA-9393: Address PR feedback.", "committedDate": "2020-03-10T05:36:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk0MzQ4NA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r391943484", "bodyText": "unused import CoreUtils", "author": "junrao", "createdAt": "2020-03-12T22:41:18Z", "path": "core/src/main/scala/kafka/log/ProducerStateManager.scala", "diffHunk": "@@ -23,7 +23,7 @@ import java.nio.file.{Files, StandardOpenOption}\n \n import kafka.log.Log.offsetFromFile\n import kafka.server.LogOffsetMetadata\n-import kafka.utils.{Logging, nonthreadsafe, threadsafe}\n+import kafka.utils.{CoreUtils, Logging, nonthreadsafe, threadsafe}", "originalCommit": "be858cd5a3f9be029ec2a7368024028403c976c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk0NzU3Mg==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r391947572", "bodyText": "Since this is called on broker restart, it seems that we no longer need to call deleteSnapshotFiles() in truncateAndReload(), truncateHead() and truncate() ?", "author": "junrao", "createdAt": "2020-03-12T22:54:28Z", "path": "core/src/main/scala/kafka/log/ProducerStateManager.scala", "diffHunk": "@@ -753,6 +753,18 @@ class ProducerStateManager(val topicPartition: TopicPartition,\n       None\n   }\n \n-  private def listSnapshotFiles: Seq[File] = ProducerStateManager.listSnapshotFiles(logDir)\n+  private[log] def listSnapshotFiles: Seq[File] = ProducerStateManager.listSnapshotFiles(logDir)\n \n+  /**\n+   * Remove any producer state snapshot files which do not have a corresponding offset provided\n+   * in keepOffsets. The latest snapshot file will always be kept.\n+   */\n+  def cleanupOrphanSnapshotFiles(segmentBaseOffsets: Iterable[Long]): Unit = {", "originalCommit": "be858cd5a3f9be029ec2a7368024028403c976c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYxNDc4MA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r397614780", "bodyText": "Thanks @junrao,\nI wanted to enumerate why it's safe to remove these now to make sure we're on the same page.\n\n\ndeleteSnapshotFiles can be deleted because snapshot file deletion is done outside of the ProducerStateManager now.\n\n\ntruncate can be deleted because we only ever fully truncate the producer state snapshots if we are also truncating the log, and as a result, the segment files.\n\n\ntruncateAndReload and truncateHead seems to be called when recovering a segment and when loading the log. Upon starting up after an unclean shutdown, we will call truncateAndReload. I'm a bit less certain that we can get rid of these methods, I will need to investigate further.", "author": "gardnervickers", "createdAt": "2020-03-25T05:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk0NzU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk0ODQ0Nw==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r391948447", "bodyText": "We don't need to clear the producer snapshot here. However, it seems that we still need to do other things in truncateHead() like removeUnreplicatedTransactions()?", "author": "junrao", "createdAt": "2020-03-12T22:57:26Z", "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -1260,7 +1265,6 @@ class Log(@volatile var dir: File,\n           info(s\"Incrementing log start offset to $newLogStartOffset\")\n           updateLogStartOffset(newLogStartOffset)\n           leaderEpochCache.foreach(_.truncateFromStart(logStartOffset))\n-          producerStateManager.truncateHead(newLogStartOffset)", "originalCommit": "be858cd5a3f9be029ec2a7368024028403c976c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk0OTA4MQ==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r391949081", "bodyText": "segments base offset => segment's base offset", "author": "junrao", "createdAt": "2020-03-12T22:59:31Z", "path": "core/src/main/scala/kafka/log/LogSegment.scala", "diffHunk": "@@ -47,6 +47,7 @@ import scala.math._\n  * @param lazyOffsetIndex The offset index\n  * @param lazyTimeIndex The timestamp index\n  * @param txnIndex The transaction index\n+ * @param producerStateSnapshot The producer state snapshot file matching this segments base offset", "originalCommit": "be858cd5a3f9be029ec2a7368024028403c976c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1NDM0NQ==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r391954345", "bodyText": "For consistency, should we cover producerStateSnapshot in lastModified_= ?", "author": "junrao", "createdAt": "2020-03-12T23:17:28Z", "path": "core/src/main/scala/kafka/log/LogSegment.scala", "diffHunk": "@@ -622,7 +631,8 @@ class LogSegment private[log] (val log: FileRecords,\n       () => delete(log.deleteIfExists _, \"log\", log.file, logIfMissing = true),\n       () => delete(offsetIndex.deleteIfExists _, \"offset index\", lazyOffsetIndex.file, logIfMissing = true),\n       () => delete(timeIndex.deleteIfExists _, \"time index\", lazyTimeIndex.file, logIfMissing = true),\n-      () => delete(txnIndex.deleteIfExists _, \"transaction index\", txnIndex.file, logIfMissing = false)\n+      () => delete(txnIndex.deleteIfExists _, \"transaction index\", txnIndex.file, logIfMissing = false),\n+      () => delete(() =>  Files.deleteIfExists(producerStateSnapshot.toPath), \"producer state snapshot\", producerStateSnapshot, logIfMissing = false)", "originalCommit": "be858cd5a3f9be029ec2a7368024028403c976c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYxNjMzMg==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r397616332", "bodyText": "Yes thanks!", "author": "gardnervickers", "createdAt": "2020-03-25T05:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1NDM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1NzExOA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r391957118", "bodyText": "Just to be clear. You mentioned\n\"I choose to implement #2 as it was simpler, and instead of just deleting the highest producer state snapshot file without a corresponding segment file, I delete all producer state snapshot files without a corresponding segment file.\"\nBut, we are still keeping the snapshot file with the largest offset?", "author": "junrao", "createdAt": "2020-03-12T23:28:01Z", "path": "core/src/main/scala/kafka/log/ProducerStateManager.scala", "diffHunk": "@@ -753,6 +753,18 @@ class ProducerStateManager(val topicPartition: TopicPartition,\n       None\n   }\n \n-  private def listSnapshotFiles: Seq[File] = ProducerStateManager.listSnapshotFiles(logDir)\n+  private[log] def listSnapshotFiles: Seq[File] = ProducerStateManager.listSnapshotFiles(logDir)\n \n+  /**\n+   * Remove any producer state snapshot files which do not have a corresponding offset provided\n+   * in keepOffsets. The latest snapshot file will always be kept.\n+   */\n+  def cleanupOrphanSnapshotFiles(segmentBaseOffsets: Iterable[Long]): Unit = {\n+    val expected = segmentBaseOffsets.map(Log.producerSnapshotFile(logDir, _)).toSet ++ latestSnapshotFile", "originalCommit": "be858cd5a3f9be029ec2a7368024028403c976c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk4Mjk5Mw==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r397982993", "bodyText": "Yes this is a mistake, now that cleanupOrphanSnapshotFiles occurs after loading the producer state, we should also delete the latest snapshot file.", "author": "gardnervickers", "createdAt": "2020-03-25T16:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1NzExOA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MjQ3Nw==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r436792477", "bodyText": "Nit: case and newline are unnecessary here.", "author": "ijuma", "createdAt": "2020-06-08T15:23:44Z", "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2237,7 +2209,11 @@ class Log(@volatile private var _dir: File,\n     def deleteSegments(): Unit = {\n       info(s\"Deleting segments ${segments.mkString(\",\")}\")\n       maybeHandleIOException(s\"Error while deleting segments for $topicPartition in dir ${dir.getParent}\") {\n-        segments.foreach(_.deleteIfExists())\n+        segments.foreach {\n+          case segment =>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzNzE4Nw==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r440537187", "bodyText": "What's keepOffsets?", "author": "junrao", "createdAt": "2020-06-16T01:38:08Z", "path": "core/src/main/scala/kafka/log/ProducerStateManager.scala", "diffHunk": "@@ -751,6 +751,25 @@ class ProducerStateManager(val topicPartition: TopicPartition,\n       None\n   }\n \n-  private def listSnapshotFiles: Seq[File] = ProducerStateManager.listSnapshotFiles(logDir)\n+  private[log] def listSnapshotFiles: Seq[File] = ProducerStateManager.listSnapshotFiles(logDir)\n \n+  /**\n+   * Remove any producer state snapshot files which do not have a corresponding offset provided\n+   * in keepOffsets. The latest snapshot file will always be kept.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcxOTc4NA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r441719784", "bodyText": "This should be segmentBaseOffsets, thanks!", "author": "gardnervickers", "createdAt": "2020-06-17T17:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzNzE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzODc3MA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r440538770", "bodyText": "It doesn't seem that we generate producer snapshot files for those new segments?", "author": "junrao", "createdAt": "2020-06-16T01:44:01Z", "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2421,6 +2396,7 @@ class Log(@volatile private var _dir: File,\n         newSegments.foreach { splitSegment =>\n           splitSegment.close()\n           splitSegment.deleteIfExists()\n+          producerStateManager.deleteIfExists(splitSegment.baseOffset)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzOTI5MQ==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r440539291", "bodyText": "Hmm, the cleaned segment has the same base offset as the first segment. So, we don't want to delete that snapshot file.", "author": "junrao", "createdAt": "2020-06-16T01:45:58Z", "path": "core/src/main/scala/kafka/log/LogCleaner.scala", "diffHunk": "@@ -595,8 +595,10 @@ private[log] class Cleaner(val id: Int,\n       log.replaceSegments(List(cleaned), segments)\n     } catch {\n       case e: LogCleaningAbortedException =>\n-        try cleaned.deleteIfExists()\n-        catch {\n+        try {\n+          cleaned.deleteIfExists()\n+          log.producerStateManager.deleteIfExists(cleaned.baseOffset)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU0MDkzMw==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r440540933", "bodyText": "Hmm, this can be a bit tricky. When we replace old segments with a new segment in LogCleaner, each of the old segment will be deleted. However, the first old segment has the same offset as the new segment. So, we don't want to just delete the producer snapshot corresponding to the first old segment.", "author": "junrao", "createdAt": "2020-06-16T01:52:17Z", "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2237,7 +2209,10 @@ class Log(@volatile private var _dir: File,\n     def deleteSegments(): Unit = {\n       info(s\"Deleting segments ${segments.mkString(\",\")}\")\n       maybeHandleIOException(s\"Error while deleting segments for $topicPartition in dir ${dir.getParent}\") {\n-        segments.foreach(_.deleteIfExists())\n+        segments.foreach { segment =>\n+          segment.deleteIfExists()\n+          producerStateManager.deleteIfExists(segment.baseOffset)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "ff9dc5bfc8233874c222413afb780b179e0c4639", "url": "https://github.com/apache/kafka/commit/ff9dc5bfc8233874c222413afb780b179e0c4639", "message": "Rework how producer state snapshot files are maintained:\n\n- On broker startup, only the most recent producer state snapshot and producer state snapshots associated with a segment file are retained.\n\n- Producer state snapshot files are managed via an in-memory index inside of the ProducerStateManager to reduce lookup costs.\n\n- Producer state snapshots are kept around for the lifetime of their associated segment to prevent large truncations from deleting all producer state snapshot files.\n\n- Producer state snapshots are now deleted asynchronously as part of the thread which\n  deletes segment and index files. Snapshot file deletion occurs when segment deletion occurs.", "committedDate": "2020-10-01T21:37:52Z", "type": "commit"}, {"oid": "ff9dc5bfc8233874c222413afb780b179e0c4639", "url": "https://github.com/apache/kafka/commit/ff9dc5bfc8233874c222413afb780b179e0c4639", "message": "Rework how producer state snapshot files are maintained:\n\n- On broker startup, only the most recent producer state snapshot and producer state snapshots associated with a segment file are retained.\n\n- Producer state snapshot files are managed via an in-memory index inside of the ProducerStateManager to reduce lookup costs.\n\n- Producer state snapshots are kept around for the lifetime of their associated segment to prevent large truncations from deleting all producer state snapshot files.\n\n- Producer state snapshots are now deleted asynchronously as part of the thread which\n  deletes segment and index files. Snapshot file deletion occurs when segment deletion occurs.", "committedDate": "2020-10-01T21:37:52Z", "type": "forcePushed"}, {"oid": "b0c0b9caf3ae300d2ff65abcb8f187783e21d7af", "url": "https://github.com/apache/kafka/commit/b0c0b9caf3ae300d2ff65abcb8f187783e21d7af", "message": "Add tests verifying that deleting stray snapshots does not remove the\n\nlargest stray snapshot.", "committedDate": "2020-10-02T19:03:23Z", "type": "commit"}, {"oid": "c0c6475e19028c43ba52b12513ae691fa0b678fd", "url": "https://github.com/apache/kafka/commit/c0c6475e19028c43ba52b12513ae691fa0b678fd", "message": "The snapshots var maintained by the PoducerStateManager does not need to be volatile as it is only a set once during log initialization.", "committedDate": "2020-10-05T14:44:57Z", "type": "commit"}, {"oid": "28ec7f1ebb79be0eef4f6242c3cef2789a471913", "url": "https://github.com/apache/kafka/commit/28ec7f1ebb79be0eef4f6242c3cef2789a471913", "message": "When deleting cleaned segment files, do not delete the\ncorresponding producer state snapshot file if the deleted snapshot\nfile is being replaced with a clean version.", "committedDate": "2020-10-05T16:17:45Z", "type": "commit"}, {"oid": "ab7cc894ad1f7bfdb4c2ca3dd84a0e2827f4cf0e", "url": "https://github.com/apache/kafka/commit/ab7cc894ad1f7bfdb4c2ca3dd84a0e2827f4cf0e", "message": "When advancing the log start offset, ensure that the lastMapOffset is advanced in the ProducerStateManager.", "committedDate": "2020-10-05T17:03:34Z", "type": "commit"}, {"oid": "1a233f30a53b1bd5ef94ae1e79c5ce79566f9b74", "url": "https://github.com/apache/kafka/commit/1a233f30a53b1bd5ef94ae1e79c5ce79566f9b74", "message": "Merge branch 'trunk' of github.com:apache/kafka into KAFKA-9393-2", "committedDate": "2020-10-05T20:52:36Z", "type": "commit"}, {"oid": "d22dfddcaaa5c5f304e8dfbc40a5286be2cc6823", "url": "https://github.com/apache/kafka/commit/d22dfddcaaa5c5f304e8dfbc40a5286be2cc6823", "message": "Cleanup ProducerStateManager\n\n- Use `snapshot` instead of `file` for snapshot name when loading producer state.\n- Use `removeAndDeleteSnapshot` where applicable instead of doing it manuallly.", "committedDate": "2020-10-06T12:26:54Z", "type": "commit"}, {"oid": "1fd21b9e9bfaf5668f6cae3d5819d11c191bf359", "url": "https://github.com/apache/kafka/commit/1fd21b9e9bfaf5668f6cae3d5819d11c191bf359", "message": "Clarify comment for LogManagerTest.", "committedDate": "2020-10-06T12:29:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNTcwNQ==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r501325705", "bodyText": "ProducerStateManager.listSnapshotFiles() could just be listSnapshotFiles() ?", "author": "junrao", "createdAt": "2020-10-07T21:39:53Z", "path": "core/src/main/scala/kafka/log/ProducerStateManager.scala", "diffHunk": "@@ -496,6 +491,53 @@ class ProducerStateManager(val topicPartition: TopicPartition,\n   // completed transactions whose markers are at offsets above the high watermark\n   private val unreplicatedTxns = new util.TreeMap[Long, TxnMetadata]\n \n+  /**\n+   * Load producer state snapshots by scanning the _logDir.\n+   */\n+  private def loadSnapshots(): ConcurrentSkipListMap[java.lang.Long, SnapshotFile] = {\n+    val tm = new ConcurrentSkipListMap[java.lang.Long, SnapshotFile]()\n+    for (f <- ProducerStateManager.listSnapshotFiles(_logDir)) {", "originalCommit": "1fd21b9e9bfaf5668f6cae3d5819d11c191bf359", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNjEyMA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r501326120", "bodyText": "Incomplete sentence after \"but not to remove\".", "author": "junrao", "createdAt": "2020-10-07T21:40:55Z", "path": "core/src/main/scala/kafka/log/ProducerStateManager.scala", "diffHunk": "@@ -496,6 +491,53 @@ class ProducerStateManager(val topicPartition: TopicPartition,\n   // completed transactions whose markers are at offsets above the high watermark\n   private val unreplicatedTxns = new util.TreeMap[Long, TxnMetadata]\n \n+  /**\n+   * Load producer state snapshots by scanning the _logDir.\n+   */\n+  private def loadSnapshots(): ConcurrentSkipListMap[java.lang.Long, SnapshotFile] = {\n+    val tm = new ConcurrentSkipListMap[java.lang.Long, SnapshotFile]()\n+    for (f <- ProducerStateManager.listSnapshotFiles(_logDir)) {\n+      tm.put(f.offset, f)\n+    }\n+    tm\n+  }\n+\n+  /**\n+   * Scans the log directory, gathering all producer state snapshot files. Snapshot files which do not have an offset\n+   * corresponding to one of the provided offsets in segmentBaseOffsets will be removed, except in the case that there\n+   * is a snapshot file at a higher offset than any offset in segmentBaseOffsets.\n+   *\n+   * The goal here is to remove any snapshot files which do not have an associated segment file, but not to remove", "originalCommit": "1fd21b9e9bfaf5668f6cae3d5819d11c191bf359", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyODA2Nw==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r501328067", "bodyText": "Could we also make sure that the offset for latestStraySnapshot is > the largest offset in segmentBaseOffsets?", "author": "junrao", "createdAt": "2020-10-07T21:45:31Z", "path": "core/src/main/scala/kafka/log/ProducerStateManager.scala", "diffHunk": "@@ -496,6 +491,53 @@ class ProducerStateManager(val topicPartition: TopicPartition,\n   // completed transactions whose markers are at offsets above the high watermark\n   private val unreplicatedTxns = new util.TreeMap[Long, TxnMetadata]\n \n+  /**\n+   * Load producer state snapshots by scanning the _logDir.\n+   */\n+  private def loadSnapshots(): ConcurrentSkipListMap[java.lang.Long, SnapshotFile] = {\n+    val tm = new ConcurrentSkipListMap[java.lang.Long, SnapshotFile]()\n+    for (f <- ProducerStateManager.listSnapshotFiles(_logDir)) {\n+      tm.put(f.offset, f)\n+    }\n+    tm\n+  }\n+\n+  /**\n+   * Scans the log directory, gathering all producer state snapshot files. Snapshot files which do not have an offset\n+   * corresponding to one of the provided offsets in segmentBaseOffsets will be removed, except in the case that there\n+   * is a snapshot file at a higher offset than any offset in segmentBaseOffsets.\n+   *\n+   * The goal here is to remove any snapshot files which do not have an associated segment file, but not to remove\n+   */\n+  private[log] def removeStraySnapshots(segmentBaseOffsets: Set[Long]): Unit = {\n+    var latestStraySnapshot: Option[SnapshotFile] = None\n+    val ss = loadSnapshots()\n+    for (snapshot <- ss.values().asScala) {\n+      val key = snapshot.offset\n+      latestStraySnapshot match {\n+        case Some(prev) =>\n+          if (!segmentBaseOffsets.contains(key)) {\n+            // this snapshot is now the largest stray snapshot.\n+            prev.deleteIfExists()\n+            ss.remove(prev.offset)\n+            latestStraySnapshot = Some(snapshot)\n+          }\n+        case None =>\n+          if (!segmentBaseOffsets.contains(key)) {\n+            latestStraySnapshot = Some(snapshot)", "originalCommit": "1fd21b9e9bfaf5668f6cae3d5819d11c191bf359", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk0NDE4NQ==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r501944185", "bodyText": "We perform a check below which may cover this case. After setting the snapshots map, we look at the latest snapshot in the map. If the latest snapshot in the map is not equal to the latestStraySnapshot, we delete the latestStraySnapshot.\nI think this is a bit confusing though, so it might be better if instead we directly check that the latestStraySnapshot is larger than the largest offset in segmentBaseOffsets.", "author": "gardnervickers", "createdAt": "2020-10-08T18:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyODA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMjU2OQ==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r501332569", "bodyText": "Hmm, why don't we need to delete snapshots before logStartOffset?", "author": "junrao", "createdAt": "2020-10-07T21:55:43Z", "path": "core/src/main/scala/kafka/log/ProducerStateManager.scala", "diffHunk": "@@ -653,36 +697,44 @@ class ProducerStateManager(val topicPartition: TopicPartition,\n   def takeSnapshot(): Unit = {\n     // If not a new offset, then it is not worth taking another snapshot\n     if (lastMapOffset > lastSnapOffset) {\n-      val snapshotFile = Log.producerSnapshotFile(logDir, lastMapOffset)\n+      val snapshotFile = SnapshotFile(Log.producerSnapshotFile(_logDir, lastMapOffset))\n       info(s\"Writing producer snapshot at offset $lastMapOffset\")\n-      writeSnapshot(snapshotFile, producers)\n+      writeSnapshot(snapshotFile.file, producers)\n+      snapshots.put(snapshotFile.offset, snapshotFile)\n \n       // Update the last snap offset according to the serialized map\n       lastSnapOffset = lastMapOffset\n     }\n   }\n \n+  /**\n+   * Update the parentDir for this ProducerStateManager and all of the snapshot files which it manages.\n+   */\n+  def updateParentDir(parentDir: File): Unit ={\n+    _logDir = parentDir\n+    snapshots.forEach((_, s) => s.updateParentDir(parentDir))\n+  }\n+\n   /**\n    * Get the last offset (exclusive) of the latest snapshot file.\n    */\n-  def latestSnapshotOffset: Option[Long] = latestSnapshotFile.map(file => offsetFromFile(file))\n+  def latestSnapshotOffset: Option[Long] = latestSnapshotFile.map(_.offset)\n \n   /**\n    * Get the last offset (exclusive) of the oldest snapshot file.\n    */\n-  def oldestSnapshotOffset: Option[Long] = oldestSnapshotFile.map(file => offsetFromFile(file))\n+  def oldestSnapshotOffset: Option[Long] = oldestSnapshotFile.map(_.offset)\n \n   /**\n-   * When we remove the head of the log due to retention, we need to remove snapshots older than\n-   * the new log start offset.\n+   * Remove any unreplicated transactions lower than the provided logStartOffset and bring the lastMapOffset forward\n+   * if necessary.\n    */\n-  def truncateHead(logStartOffset: Long): Unit = {\n+  def onLogStartOffsetIncremented(logStartOffset: Long): Unit = {\n     removeUnreplicatedTransactions(logStartOffset)\n \n     if (lastMapOffset < logStartOffset)\n       lastMapOffset = logStartOffset\n \n-    deleteSnapshotsBefore(logStartOffset)", "originalCommit": "1fd21b9e9bfaf5668f6cae3d5819d11c191bf359", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk0MjUxMg==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r501942512", "bodyText": "The idea here is to clear un-replicated transactions and optionally advance the lastMapOffset and lastSnapOffset when the logStartOffset is advanced, but to leave the snapshot files around. The corresponding snapshot files should be removed during the retention pass as we cleanup the associated segment files.\nI was attempting to optimize incrementing the logStartOffset a bit so that we don't need to delete the snapshot files from the request handler thread when handling DELETE_RECORDS.", "author": "gardnervickers", "createdAt": "2020-10-08T18:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMjU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2MjMzNQ==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r501862335", "bodyText": "Hmm, why is orphanedSnapshotFile deleted since we keep the last stray snapshot?", "author": "junrao", "createdAt": "2020-10-08T16:42:19Z", "path": "core/src/test/scala/unit/kafka/log/LogTest.scala", "diffHunk": "@@ -1226,6 +1225,104 @@ class LogTest {\n     assertEquals(retainedLastSeqOpt, reloadedLastSeqOpt)\n   }\n \n+  @Test\n+  def testRetentionDeletesProducerStateSnapshots(): Unit = {\n+    val logConfig = LogTest.createLogConfig(segmentBytes = 2048 * 5, retentionBytes = 0, retentionMs = 1000 * 60, fileDeleteDelayMs = 0)\n+    val log = createLog(logDir, logConfig)\n+    val pid1 = 1L\n+    val epoch = 0.toShort\n+\n+    log.appendAsLeader(TestUtils.records(List(new SimpleRecord(\"a\".getBytes)), producerId = pid1,\n+      producerEpoch = epoch, sequence = 0), leaderEpoch = 0)\n+    log.roll()\n+    log.appendAsLeader(TestUtils.records(List(new SimpleRecord(\"b\".getBytes)), producerId = pid1,\n+      producerEpoch = epoch, sequence = 1), leaderEpoch = 0)\n+    log.roll()\n+    log.appendAsLeader(TestUtils.records(List(new SimpleRecord(\"c\".getBytes)), producerId = pid1,\n+      producerEpoch = epoch, sequence = 2), leaderEpoch = 0)\n+\n+    log.updateHighWatermark(log.logEndOffset)\n+\n+    assertEquals(2, ProducerStateManager.listSnapshotFiles(logDir).size)\n+    // Sleep to breach the retention period\n+    mockTime.sleep(1000 * 60 + 1)\n+    log.deleteOldSegments()\n+    // Sleep to breach the file delete delay and run scheduled file deletion tasks\n+    mockTime.sleep(1)\n+    assertEquals(\"expect a single producer state snapshot remaining\", 1, ProducerStateManager.listSnapshotFiles(logDir).size)\n+  }\n+\n+  @Test\n+  def testLogStartOffsetMovementDeletesSnapshots(): Unit = {\n+    val logConfig = LogTest.createLogConfig(segmentBytes = 2048 * 5, retentionBytes = -1, fileDeleteDelayMs = 0)\n+    val log = createLog(logDir, logConfig)\n+    val pid1 = 1L\n+    val epoch = 0.toShort\n+\n+    log.appendAsLeader(TestUtils.records(List(new SimpleRecord(\"a\".getBytes)), producerId = pid1,\n+      producerEpoch = epoch, sequence = 0), leaderEpoch = 0)\n+    log.roll()\n+    log.appendAsLeader(TestUtils.records(List(new SimpleRecord(\"b\".getBytes)), producerId = pid1,\n+      producerEpoch = epoch, sequence = 1), leaderEpoch = 0)\n+    log.roll()\n+    log.appendAsLeader(TestUtils.records(List(new SimpleRecord(\"c\".getBytes)), producerId = pid1,\n+      producerEpoch = epoch, sequence = 2), leaderEpoch = 0)\n+    log.updateHighWatermark(log.logEndOffset)\n+    assertEquals(2, ProducerStateManager.listSnapshotFiles(logDir).size)\n+\n+    // Increment the log start offset to exclude the first two segments.\n+    log.maybeIncrementLogStartOffset(log.logEndOffset - 1, ClientRecordDeletion)\n+    log.deleteOldSegments()\n+    // Sleep to breach the file delete delay and run scheduled file deletion tasks\n+    mockTime.sleep(1)\n+    assertEquals(\"expect a single producer state snapshot remaining\", 1, ProducerStateManager.listSnapshotFiles(logDir).size)\n+  }\n+\n+  @Test\n+  def testCompactionDeletesProducerStateSnapshots(): Unit = {\n+    val logConfig = LogTest.createLogConfig(segmentBytes = 2048 * 5, cleanupPolicy = LogConfig.Compact, fileDeleteDelayMs = 0)\n+    val log = createLog(logDir, logConfig)\n+    val pid1 = 1L\n+    val epoch = 0.toShort\n+    val cleaner = new Cleaner(id = 0,\n+      offsetMap = new FakeOffsetMap(Int.MaxValue),\n+      ioBufferSize = 64 * 1024,\n+      maxIoBufferSize = 64 * 1024,\n+      dupBufferLoadFactor = 0.75,\n+      throttler = new Throttler(Double.MaxValue, Long.MaxValue, false, time = mockTime),\n+      time = mockTime,\n+      checkDone = _ => {})\n+\n+    log.appendAsLeader(TestUtils.records(List(new SimpleRecord(\"a\".getBytes, \"a\".getBytes())), producerId = pid1,\n+      producerEpoch = epoch, sequence = 0), leaderEpoch = 0)\n+    log.roll()\n+    log.appendAsLeader(TestUtils.records(List(new SimpleRecord(\"a\".getBytes, \"b\".getBytes())), producerId = pid1,\n+      producerEpoch = epoch, sequence = 1), leaderEpoch = 0)\n+    log.roll()\n+    log.appendAsLeader(TestUtils.records(List(new SimpleRecord(\"a\".getBytes, \"c\".getBytes())), producerId = pid1,\n+      producerEpoch = epoch, sequence = 2), leaderEpoch = 0)\n+    log.updateHighWatermark(log.logEndOffset)\n+    assertEquals(\"expected a snapshot file per segment base offset, except the first segment\", log.logSegments.map(_.baseOffset).toSeq.sorted.drop(1), ProducerStateManager.listSnapshotFiles(logDir).map(_.offset).sorted)\n+    assertEquals(2, ProducerStateManager.listSnapshotFiles(logDir).size)\n+\n+    // Clean segments, this should delete everything except the active segment since there only\n+    // exists the key \"a\".\n+    cleaner.clean(LogToClean(log.topicPartition, log, 0, log.logEndOffset))\n+    log.deleteOldSegments()\n+    // Sleep to breach the file delete delay and run scheduled file deletion tasks\n+    mockTime.sleep(1)\n+    assertEquals(\"expected a snapshot file per segment base offset, excluding the first\", log.logSegments.map(_.baseOffset).toSeq.sorted.drop(1), ProducerStateManager.listSnapshotFiles(logDir).map(_.offset).sorted)\n+  }\n+\n+  @Test\n+  def testLoadingLogCleansOrphanedProducerStateSnapshots(): Unit = {\n+    val orphanedSnapshotFile = Log.producerSnapshotFile(logDir, 42).toPath\n+    Files.createFile(orphanedSnapshotFile)\n+    val logConfig = LogTest.createLogConfig(segmentBytes = 2048 * 5, retentionBytes = -1, fileDeleteDelayMs = 0)\n+    createLog(logDir, logConfig)\n+    assertEquals(\"expected orphaned producer state snapshot file to be cleaned up\", 0, ProducerStateManager.listSnapshotFiles(logDir).size)", "originalCommit": "1fd21b9e9bfaf5668f6cae3d5819d11c191bf359", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk1NzgwMA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r501957800", "bodyText": "It's being deleted because during producer state loading because we truncate producer state to match the bounds of the log, and the snapshot file written out at offset 42 is higher than the log end offset of the empty log. The test name is not very clear in this case though.\nI will fix the name and add another test which checks that we keep around the largest stray producer state snapshot file.", "author": "gardnervickers", "createdAt": "2020-10-08T19:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2MjMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk3OTM4OA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r501979388", "bodyText": "I added some extra context to the existing test and created a new test which verifies from the log that the largest stray snapshot which is within the logs end offset is retained testLoadingLogKeepsLargestStrayProducerStateSnapshot.", "author": "gardnervickers", "createdAt": "2020-10-08T20:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2MjMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2MzExMQ==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r501863111", "bodyText": "mockTime.sleep() calls scheduler.tick() already.", "author": "junrao", "createdAt": "2020-10-08T16:43:37Z", "path": "core/src/test/scala/unit/kafka/log/LogTest.scala", "diffHunk": "@@ -1661,14 +1753,17 @@ class LogTest {\n     log.roll()\n \n     assertEquals(2, log.activeProducersWithLastSequence.size)\n-    assertEquals(2, ProducerStateManager.listSnapshotFiles(log.producerStateManager.logDir).size)\n+    assertEquals(2, ProducerStateManager.listSnapshotFiles(log.dir).size)\n \n     log.updateHighWatermark(log.logEndOffset)\n     log.maybeIncrementLogStartOffset(2L, ClientRecordDeletion)\n+    log.deleteOldSegments() // force retention to kick in so that the snapshot files are cleaned up.\n+    mockTime.sleep(logConfig.fileDeleteDelayMs + 1000) // advance the clock so file deletion takes place\n+    mockTime.scheduler.tick()", "originalCommit": "1fd21b9e9bfaf5668f6cae3d5819d11c191bf359", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2NTkzMg==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r501865932", "bodyText": "Below, the base offset of the largest segment equals to and doesn't exceed the offset of the largest stray snapshot.", "author": "junrao", "createdAt": "2020-10-08T16:48:13Z", "path": "core/src/test/scala/unit/kafka/log/ProducerStateManagerTest.scala", "diffHunk": "@@ -834,6 +834,40 @@ class ProducerStateManagerTest {\n     assertEquals(None, stateManager.lastEntry(producerId).get.currentTxnFirstOffset)\n   }\n \n+  @Test\n+  def testRemoveStraySnapshotsKeepCleanShutdownSnapshot(): Unit = {\n+    // Test that when stray snapshots are removed, the largest stray snapshot is kept around. This covers the case where\n+    // the broker shutdown cleanly and emitted a snapshot file larger than the base offset of the active segment.\n+\n+    // Create 3 snapshot files at different offsets.\n+    Log.producerSnapshotFile(logDir, 42).createNewFile()\n+    Log.producerSnapshotFile(logDir, 5).createNewFile()\n+    Log.producerSnapshotFile(logDir, 2).createNewFile()\n+\n+    // claim that we only have one segment with a base offset of 5\n+    stateManager.removeStraySnapshots(Set(5))\n+\n+    // The snapshot file at offset 2 should be considered a stray, but the snapshot at 42 should be kept\n+    // around because it is the largest snapshot.\n+    assertEquals(Some(42), stateManager.latestSnapshotOffset)\n+    assertEquals(Some(5), stateManager.oldestSnapshotOffset)\n+    assertEquals(Seq(5, 42), ProducerStateManager.listSnapshotFiles(logDir).map(_.offset).sorted)\n+  }\n+\n+  @Test\n+  def testRemoveAllStraySnapshots(): Unit = {\n+    // Test that when stray snapshots are removed, all stray snapshots are removed when the base offset of the largest\n+    // segment exceeds the offset of the largest stray snapshot.", "originalCommit": "1fd21b9e9bfaf5668f6cae3d5819d11c191bf359", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk3MDcxNg==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r501970716", "bodyText": "Hmm, I think my comment here could be worded better. Offset 42 here is not a \"stray\", since we provide it along with the list of segmentBaseOffsets to removeStraySnapshots.\nI'll change up the wording on this, thanks!", "author": "gardnervickers", "createdAt": "2020-10-08T19:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2NTkzMg=="}], "type": "inlineReview"}, {"oid": "15bc15f15e7fe0cd92978cbad4699a3c956cab7b", "url": "https://github.com/apache/kafka/commit/15bc15f15e7fe0cd92978cbad4699a3c956cab7b", "message": "Address PR feedback\n\n- Clarify the purpose of the test which verifies truncation cleans up snapshots.\n\n- Add new test which verifies that we delete stray snapshots below the base offset of the active segment, but keep the largest stray snapshot within the log end offset.", "committedDate": "2020-10-08T19:25:25Z", "type": "commit"}, {"oid": "aa072aaeaeda278f92da51ac26f4f0c0f473a0a8", "url": "https://github.com/apache/kafka/commit/aa072aaeaeda278f92da51ac26f4f0c0f473a0a8", "message": "Address PR feedback\n\n- Directly remove the latestStraySnapshot if it is less than the largest segment base offset.", "committedDate": "2020-10-08T19:35:53Z", "type": "commit"}, {"oid": "16f51f78f676c2dcaf2f75b0ec41d0847f277390", "url": "https://github.com/apache/kafka/commit/16f51f78f676c2dcaf2f75b0ec41d0847f277390", "message": "Address PR feedback\n\n- Reword some comments in ProducerStateManagerTest", "committedDate": "2020-10-08T19:48:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyMzg5OQ==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r502023899", "bodyText": "Since deleteSnapshotsBefore() still exist, could we keep using it?", "author": "junrao", "createdAt": "2020-10-08T21:30:30Z", "path": "core/src/test/scala/unit/kafka/log/LogTest.scala", "diffHunk": "@@ -782,7 +782,7 @@ class LogTest {\n     }\n \n     // Retain snapshots for the last 2 segments\n-    ProducerStateManager.deleteSnapshotsBefore(logDir, segmentOffsets(segmentOffsets.size - 2))\n+    ProducerStateManager.listSnapshotFiles(logDir).filter(_.offset < segmentOffsets(segmentOffsets.size - 2)).foreach(_.deleteIfExists())", "originalCommit": "16f51f78f676c2dcaf2f75b0ec41d0847f277390", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3ODU4NA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r502078584", "bodyText": "Yes, it should work if we switch these back to using deleteSnapshotsBefore. Thanks!", "author": "gardnervickers", "createdAt": "2020-10-08T23:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyMzg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyMzk1OA==", "url": "https://github.com/apache/kafka/pull/7929#discussion_r502023958", "bodyText": "Since deleteSnapshotsBefore() still exist, could we keep using it?", "author": "junrao", "createdAt": "2020-10-08T21:30:37Z", "path": "core/src/test/scala/unit/kafka/log/LogTest.scala", "diffHunk": "@@ -794,16 +794,12 @@ class LogTest {\n \n     // Only delete snapshots before the base offset of the recovery point segment (post KAFKA-5829 behaviour) to\n     // avoid reading all segments\n-    ProducerStateManager.deleteSnapshotsBefore(logDir, offsetForRecoveryPointSegment)\n+    ProducerStateManager.listSnapshotFiles(logDir).filter(_.offset < offsetForRecoveryPointSegment).foreach(_.deleteIfExists())", "originalCommit": "16f51f78f676c2dcaf2f75b0ec41d0847f277390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "56a68f566da4eecf7a88cd782967bfc4838808b9", "url": "https://github.com/apache/kafka/commit/56a68f566da4eecf7a88cd782967bfc4838808b9", "message": "Address PR feedback\n\n- Switch back to using `deleteSnapshotsBefore`", "committedDate": "2020-10-08T23:29:34Z", "type": "commit"}, {"oid": "9de260d604a75d44b91e5063b5b6ff119b3c0c33", "url": "https://github.com/apache/kafka/commit/9de260d604a75d44b91e5063b5b6ff119b3c0c33", "message": "`maxOption` is not available in this version of Scala, use the explicit form instead.", "committedDate": "2020-10-09T02:02:35Z", "type": "commit"}, {"oid": "ae99b4ebf20875bf69ce4d992586cc5707c6a0ee", "url": "https://github.com/apache/kafka/commit/ae99b4ebf20875bf69ce4d992586cc5707c6a0ee", "message": "Merge branch 'trunk' of github.com:apache/kafka into KAFKA-9393-2", "committedDate": "2020-10-09T13:21:33Z", "type": "commit"}]}