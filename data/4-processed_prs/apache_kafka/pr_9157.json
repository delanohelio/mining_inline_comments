{"pr_number": 9157, "pr_title": "KAFKA-5636: Update for KIP-450 to handle early records", "pr_createdAt": "2020-08-10T18:26:27Z", "pr_url": "https://github.com/apache/kafka/pull/9157", "timeline": [{"oid": "1b2b7583c481a7fbd3dedc35c838e3d98603e16d", "url": "https://github.com/apache/kafka/commit/1b2b7583c481a7fbd3dedc35c838e3d98603e16d", "message": "Initial classes for SlidingWindows, changes to processors", "committedDate": "2020-07-17T15:42:48Z", "type": "commit"}, {"oid": "3ee045a49a0c5e6478112af400e57c277b38f312", "url": "https://github.com/apache/kafka/commit/3ee045a49a0c5e6478112af400e57c277b38f312", "message": "updates to processor", "committedDate": "2020-07-17T18:31:10Z", "type": "commit"}, {"oid": "ff6ca4f62482d32f2f22a45647448727cfb67980", "url": "https://github.com/apache/kafka/commit/ff6ca4f62482d32f2f22a45647448727cfb67980", "message": "updated for grace period checks", "committedDate": "2020-07-17T20:19:34Z", "type": "commit"}, {"oid": "56a86f1718ba74e6ce4b808cb205ecf71a3d0b16", "url": "https://github.com/apache/kafka/commit/56a86f1718ba74e6ce4b808cb205ecf71a3d0b16", "message": "fixes for checkstyle", "committedDate": "2020-07-20T14:17:03Z", "type": "commit"}, {"oid": "0a3d6d490f0894ad128d4f981f9d7f87cf165f7d", "url": "https://github.com/apache/kafka/commit/0a3d6d490f0894ad128d4f981f9d7f87cf165f7d", "message": "fixes for checkstyle", "committedDate": "2020-07-20T14:20:42Z", "type": "commit"}, {"oid": "c6d358dfb62d09f4e8f406487b1f887c3db49267", "url": "https://github.com/apache/kafka/commit/c6d358dfb62d09f4e8f406487b1f887c3db49267", "message": "update algorithm, KIP changes, test", "committedDate": "2020-07-27T22:19:10Z", "type": "commit"}, {"oid": "0c1541ab543d2cfa0cb5e1e5288d39ec86187317", "url": "https://github.com/apache/kafka/commit/0c1541ab543d2cfa0cb5e1e5288d39ec86187317", "message": "Merge remote-tracking branch 'upstream/trunk' into slidingwindows", "committedDate": "2020-07-27T22:27:14Z", "type": "commit"}, {"oid": "7f1b886f9da1f0ee5d84806875f93088c7b3c4d8", "url": "https://github.com/apache/kafka/commit/7f1b886f9da1f0ee5d84806875f93088c7b3c4d8", "message": "updates for windowedBy and associated processors", "committedDate": "2020-07-28T16:36:31Z", "type": "commit"}, {"oid": "de89fe07b9ac515a0c430274200c39cadddbf64b", "url": "https://github.com/apache/kafka/commit/de89fe07b9ac515a0c430274200c39cadddbf64b", "message": "test fixes, updating algorithms", "committedDate": "2020-07-29T17:10:05Z", "type": "commit"}, {"oid": "35e637d6c0d932129d69b50072d2d1b412af7d10", "url": "https://github.com/apache/kafka/commit/35e637d6c0d932129d69b50072d2d1b412af7d10", "message": ":review updates", "committedDate": "2020-07-31T19:59:41Z", "type": "commit"}, {"oid": "dc2f65f711a54e995094a1885df1dc728c479b1b", "url": "https://github.com/apache/kafka/commit/dc2f65f711a54e995094a1885df1dc728c479b1b", "message": "review updates, test additions", "committedDate": "2020-08-05T00:09:33Z", "type": "commit"}, {"oid": "9cca939e7b54f60cbbf0fc8abdd0f94fbbe19f45", "url": "https://github.com/apache/kafka/commit/9cca939e7b54f60cbbf0fc8abdd0f94fbbe19f45", "message": "sophie's reviews", "committedDate": "2020-08-05T14:20:20Z", "type": "commit"}, {"oid": "e5a0d4b4a60f55d2ee7f412486ed8b567d493e25", "url": "https://github.com/apache/kafka/commit/e5a0d4b4a60f55d2ee7f412486ed8b567d493e25", "message": "cleaning up pr", "committedDate": "2020-08-05T15:37:05Z", "type": "commit"}, {"oid": "0afd88e97047c97e91e6d6273eb909e76eb782f4", "url": "https://github.com/apache/kafka/commit/0afd88e97047c97e91e6d6273eb909e76eb782f4", "message": "Merge branch 'trunk' of github.com:apache/kafka into slidingwindows", "committedDate": "2020-08-05T18:54:34Z", "type": "commit"}, {"oid": "24d91d8c33d3d3660f548623d6bcc7ef727d0862", "url": "https://github.com/apache/kafka/commit/24d91d8c33d3d3660f548623d6bcc7ef727d0862", "message": "updated tests", "committedDate": "2020-08-05T19:43:05Z", "type": "commit"}, {"oid": "65231139fb27f8e380d8bf6552a31c09f5fd28ff", "url": "https://github.com/apache/kafka/commit/65231139fb27f8e380d8bf6552a31c09f5fd28ff", "message": "grouped k stream and suppression tests", "committedDate": "2020-08-07T15:17:24Z", "type": "commit"}, {"oid": "34b3f5a2f6dee16a514698f39187eddcfab134bc", "url": "https://github.com/apache/kafka/commit/34b3f5a2f6dee16a514698f39187eddcfab134bc", "message": "removing reverse iterator, to be implemented later", "committedDate": "2020-08-07T20:41:17Z", "type": "commit"}, {"oid": "1071098d77ebda24f4a5791ca449efbb0cdabd48", "url": "https://github.com/apache/kafka/commit/1071098d77ebda24f4a5791ca449efbb0cdabd48", "message": "sophie's comments and testing updates", "committedDate": "2020-08-12T15:54:25Z", "type": "commit"}, {"oid": "824f8702114bff71944a2004cf8eadbd7144c785", "url": "https://github.com/apache/kafka/commit/824f8702114bff71944a2004cf8eadbd7144c785", "message": "trunk updates", "committedDate": "2020-08-17T14:38:32Z", "type": "commit"}, {"oid": "1163c2faa84d3bb05c178ce67ecb047a92b9a054", "url": "https://github.com/apache/kafka/commit/1163c2faa84d3bb05c178ce67ecb047a92b9a054", "message": "cogrouped builder updates", "committedDate": "2020-08-17T14:44:58Z", "type": "commit"}, {"oid": "296a6c3035f7eda71729d5cec7e16778383b7fad", "url": "https://github.com/apache/kafka/commit/296a6c3035f7eda71729d5cec7e16778383b7fad", "message": "test updates and clean up", "committedDate": "2020-08-19T18:12:59Z", "type": "commit"}, {"oid": "bb609a89ec7543943d03a1939e61f8208847ce8e", "url": "https://github.com/apache/kafka/commit/bb609a89ec7543943d03a1939e61f8208847ce8e", "message": "randomized and small test improvements", "committedDate": "2020-08-24T17:07:55Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyNzQ2Nw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475927467", "bodyText": "This is really just the timestamp of the previous record, right? Can we call it something that reflects that", "author": "ableegoldman", "createdAt": "2020-08-24T22:23:12Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -183,7 +188,8 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n \n             //create right window for previous record\n             if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n+                final long leftWindowEnd = latestLeftTypeWindow.key.window().end();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyOTM2OQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475929369", "bodyText": "We need to make sure the fetch bounds don't go into the negative. We only call processEarly if the record's timestamp is within the timeDifferenceMs, but here we search starting at timestamp - 2*timeDifferenceMs", "author": "ableegoldman", "createdAt": "2020-08-24T22:28:08Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -148,7 +153,7 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean rightWinAlreadyCreated = false;\n \n             // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> latestLeftTypeWindow = null;\n             try (\n                     final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzMTUxOA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r476531518", "bodyText": "Fetch having negative bounds doesn't throw any errors or cause any issues, is there a different reason to make sure the bounds aren't negative? Since we don't store windows with a negative start time it shouldn't return anything we don't expect", "author": "lct45", "createdAt": "2020-08-25T15:18:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyOTM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc4MTEyNg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r476781126", "bodyText": "Are you sure it's actually returning something? Have you tested it with a rocksdb store or just with the in-memory store? I think the in-memory store would handle this fine since it never serializes the key/timestamps, but if you have a rocksdb store (or a caching layer) then the range query works by looking up any data between the serialized bounds. Unfortunately a negative long is lexicographically greater than a positive long when serialized to bytes. The \"negative\" is encoded as a leading 1 -- which means the lower bound ends up being \"larger\" than the upper bound.\nI would assume that would result in no data being returned, but I'm not actually 100% sure what would happen", "author": "ableegoldman", "createdAt": "2020-08-25T22:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyOTM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM4MDM0Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477380346", "bodyText": "Ah yeah the different types of stores is a good point, I haven't tested with all of them. I changed it to do 0 or the positive fetch start", "author": "lct45", "createdAt": "2020-08-26T15:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyOTM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzMjg1Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475932853", "bodyText": "I think this fetch might break if you go into the negatives, should just fetch starting from 0", "author": "ableegoldman", "createdAt": "2020-08-24T22:38:03Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -211,6 +217,67 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUzMTc0NQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r476531745", "bodyText": "Same as above, it seems like it still works as expected", "author": "lct45", "createdAt": "2020-08-25T15:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzMjg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc4MzkwNQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r476783905", "bodyText": "See above -- even if it seems to be working I think we should restrict the range anyway. We know that there's no windows earlier than 0 so why extend the query beyond this?", "author": "ableegoldman", "createdAt": "2020-08-25T22:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzMjg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NzM5NA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475947394", "bodyText": "This is just a window from [0, timeDifferenceMs] that stores the aggregation of all the \"early\" records, right? I can't really think of a more descriptive name so can we just leave a comment explaining what it's for", "author": "ableegoldman", "createdAt": "2020-08-24T23:13:19Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk2ODA1NA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475968054", "bodyText": "It took me a second to get this -- can we explicitly check if startTime == timestamp + 1 instead of falling back to else and implicitly relying on the fetch bounds? You can just get rid of the else altogether or throw an IllegalStateException if none of the specific conditions are met and the else is reached, whatever makes sense to you", "author": "ableegoldman", "createdAt": "2020-08-24T23:42:28Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),\n+                            // to catch the current record's right window, if it exists, without more calls to the store\n+                            timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime == windows.timeDifferenceMs()) {\n+                        combinedWindow = next;\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk2OTc3Nw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475969777", "bodyText": "nit: can we make this if startTime == 0 ? That seems slightly easier to understand, and then all the conditionals can be in terms of startTime which is a bit more intuitive since that's what we're iterating over. Context switching between startTime and endTime kind of makes me lose my train of thought", "author": "ableegoldman", "createdAt": "2020-08-24T23:44:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),\n+                            // to catch the current record's right window, if it exists, without more calls to the store\n+                            timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime == windows.timeDifferenceMs()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk3MzA2Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475973066", "bodyText": "most recent max timestamp\n\nHuh? I think I know what you're trying to say here but it seems like two different phrases got a bit mixed up here", "author": "ableegoldman", "createdAt": "2020-08-24T23:49:43Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),\n+                            // to catch the current record's right window, if it exists, without more calls to the store\n+                            timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime == windows.timeDifferenceMs()) {\n+                        combinedWindow = next;\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the most recent max timestamp in the combined window", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk3NDE0MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475974141", "bodyText": "This name keeps throwing me off...right window of what? Is it like previousRecordRightWindow?", "author": "ableegoldman", "createdAt": "2020-08-24T23:51:11Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),\n+                            // to catch the current record's right window, if it exists, without more calls to the store\n+                            timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime == windows.timeDifferenceMs()) {\n+                        combinedWindow = next;\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the most recent max timestamp in the combined window\n+                final long rightWinStart = combinedWindow.value.timestamp() + 1;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0NjQxMA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r476546410", "bodyText": "I went with maxRightWindowStart since it's not always going to be the previous record, either in terms of process order or time order.", "author": "lct45", "createdAt": "2020-08-25T15:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk3NDE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk4MDkwMw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475980903", "bodyText": "It's not immediately obvious why this is correct/captures all possible cases so we should leave a comment, or better yet factor out this condition into a descriptively named method (or best yet, do both)\nI was concerned about out-of-order records, since in that case the previous record would obviously not be the one with the maximum timestamp in the combined window. But I realized that we actually never need to create a previous record's right window for out-of-order early records, since there's no way for a full timeDifferenceMs to fit between the previous record and whatever the max record in the combined window is. So, all we need to do is make sure we only try to create the previous record's right window if the current window is the maximum record within the combined window, ie the combinedWindow.value.timestamp() < timestamp\nBut that's a very long and pretty ineloquent comment to leave in the code. Hopefully you can come up with a more concise explanation", "author": "ableegoldman", "createdAt": "2020-08-25T00:00:57Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),\n+                            // to catch the current record's right window, if it exists, without more calls to the store\n+                            timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime == windows.timeDifferenceMs()) {\n+                        combinedWindow = next;\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the most recent max timestamp in the combined window\n+                final long rightWinStart = combinedWindow.value.timestamp() + 1;\n+                if (!windowStartTimes.contains(rightWinStart) && combinedWindow.value.timestamp() < timestamp) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk4MTE2Nw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475981167", "bodyText": "nit: aggregated -> aggregate", "author": "ableegoldman", "createdAt": "2020-08-25T00:01:18Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),\n+                            // to catch the current record's right window, if it exists, without more calls to the store\n+                            timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime == windows.timeDifferenceMs()) {\n+                        combinedWindow = next;\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the most recent max timestamp in the combined window\n+                final long rightWinStart = combinedWindow.value.timestamp() + 1;\n+                if (!windowStartTimes.contains(rightWinStart) && combinedWindow.value.timestamp() < timestamp) {\n+                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregated", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk4NTA3Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475985073", "bodyText": "Can we add maybe one or two more tests? I think at the least we should have one test that processes only early records, and one test that covers input(s) with the same timestamp.", "author": "ableegoldman", "createdAt": "2020-08-25T00:07:07Z", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -328,6 +328,68 @@ public void testAggregateLargeInput() {\n         );\n     }\n \n+    @Test\n+    public void testEarlyRecords() {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "64d4cbbdec80580a91c13a57e4d091efebf749d7", "url": "https://github.com/apache/kafka/commit/64d4cbbdec80580a91c13a57e4d091efebf749d7", "message": "testing clean up", "committedDate": "2020-08-26T16:30:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc1NjYzMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477756632", "bodyText": "This comment kind of comes out of nowhere since there's no concept of the \"combined window\" outside of processEarly. Maybe you can just add a quick mention of what it is and that it's for early records", "author": "ableegoldman", "createdAt": "2020-08-27T00:20:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -160,11 +160,18 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n+                        // store the combined window if it is found so that a right window can be created for\n+                        // the combined window's max record, as needed", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NDA4NA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477784084", "bodyText": "We only need to check if the previous right window needs to be created if the current record's left window was not previously a left-type window, ie the max_timestamp < timestamp. Otherwise, we'd have already created any windows since that implies we processed a record with this exact timestamp already.\nSo then why do we set latestLeftTypeWindow = next ? It seems like it's possible that this actually isn't a left-type window, in which case we shouldn't overwrite any existing value for latestLeftTypeWindow.\nOn the other hand, if it actually is a left type window, then that means we don't need to create the previous record's right window so we should just set it to null. But that seems to apply regardless of whether this is the early record combined window or not?", "author": "ableegoldman", "createdAt": "2020-08-27T00:35:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -160,11 +160,18 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n+                        // store the combined window if it is found so that a right window can be created for\n+                        // the combined window's max record, as needed\n                         if (isLeftWindow(next) || endTime == windows.timeDifferenceMs()) {\n                             latestLeftTypeWindow = next;\n                         }\n                     } else if (endTime == timestamp) {\n                         leftWinAlreadyCreated = true;\n+                        // if current record's left window is the combined window, need to check later if there is a\n+                        // record that needs a right window within the combined window\n+                        if (endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQzNTgzMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478435832", "bodyText": "I see what you're saying about checking to see if the left window (in this case [0,timeDifference]) was already a left window and I can substitute for that check. The overall point was to catch instances of a record coming in at say 10 (with a timeDifference of 10) and also having one at 5, so 5 needs a right window but the combined window will only be picked up by this if() since endTime == timestamp. Setting latestLeftTypeWindow = next here will generally not be a left type window, but the combined window is a special case since there are records that may need a right window in there anyways. Because this tracks the latest left type window, storing the combined window should never override any other formal left type window that needs a right window.\nThat being said, I get that this is confusing. Do you think changing the check to `if (endTime == windows.TimeDifferenceMs() && !isLeftWindow(next)) would make it seem cleaner?", "author": "lct45", "createdAt": "2020-08-27T13:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NDA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODczMDI1OA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478730258", "bodyText": "That being said, I get that this is confusing. Do you think changing the check to if (endTime == windows.TimeDifferenceMs() && !isLeftWindow(next)) would make it seem cleaner?\n\nHaha no, I don't think saying if (!isLeftWindow(next)): then next = latestLeftTypeWindow would be less confusing. If we call a variable leftTypeWindow then it should always be a left type window.\nThat said, I now see what you meant here and it's the same problem as above, with the same fix of replacing latestLeftTypeWindow with previousRecordTimestamp. In that case I think we can just remove this check entirely (ie, don't explicitly check if it's the combined window), and all we need to do is make sure previousRecordTimestamp is set correctly", "author": "ableegoldman", "createdAt": "2020-08-27T22:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NDA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODczMDc2NQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478730765", "bodyText": "I think with this replacement then we might be able to get out of doing any kind of special handling for the combined window outside of processEarly", "author": "ableegoldman", "createdAt": "2020-08-27T22:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NDA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NDE2Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478744162", "bodyText": "I think we'd still need a check within this part of the if() to catch the previous timestamp, right? I think we could take out the if (endTime == windows.TimeDifferenceMS()) and instead always do previousRecord = next.value.timestamp", "author": "lct45", "createdAt": "2020-08-27T23:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NDA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1ODc3OQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478758779", "bodyText": "Yeah sorry I didn't mean that we shouldn't have any conditionals here whatsoever, I just meant that we don't need the combined window check (or really anything other than what we need to accurately set previousRecordTimestamp)", "author": "ableegoldman", "createdAt": "2020-08-28T00:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NDA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1OTk5Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478759996", "bodyText": "I guess you could just have a separate setPreviousRecordTimestampIfNecessary(window, previousRecordTimestamp) method that sets the previousRecordTimestamp to the window's max timestamp if it's larger. And then if it ends up that previousRecordTimestamp == timestamp then we can automatically skip all of the window creation below, which is nice", "author": "ableegoldman", "createdAt": "2020-08-28T00:05:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NDA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQxMTgzMA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r479411830", "bodyText": "Would the window's max timestamp always be larger than the previous window's by nature of moving forward in time? I think it would be somewhat more convenient but I feel like adding additional boolean checks makes the algorithm feel longer, especially if the issue will get handled in later checks", "author": "lct45", "createdAt": "2020-08-28T16:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NDA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NTg0OA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477785848", "bodyText": "Parameter alignment is off. Also the naming here isn't very clear about what it's for/what it means. Don't have great suggestions but maybe previousRightWindowMustBeCreated or even just previousRecordIsWithinMaxTimeDifferenceFromCurrentRecord and then a quick comment saying that this means we will have to create a right window for the previous record.\nAlso shouldn't rightWindowStart <= currentRecordTimestamp always be true?", "author": "ableegoldman", "createdAt": "2020-08-27T00:36:02Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream.internals;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.Aggregator;\n+import org.apache.kafka.streams.kstream.Initializer;\n+import org.apache.kafka.streams.kstream.Window;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.kstream.SlidingWindows;\n+import org.apache.kafka.streams.processor.AbstractProcessor;\n+import org.apache.kafka.streams.processor.Processor;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.processor.internals.InternalProcessorContext;\n+import org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.TimestampedWindowStore;\n+import org.apache.kafka.streams.state.ValueAndTimestamp;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrLateRecordDropSensor;\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrSkippedRecordsSensor;\n+import static org.apache.kafka.streams.state.ValueAndTimestamp.getValueOrNull;\n+\n+public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProcessorSupplier<K, Windowed<K>, V, Agg> {\n+    private final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final String storeName;\n+    private final SlidingWindows windows;\n+    private final Initializer<Agg> initializer;\n+    private final Aggregator<? super K, ? super V, Agg> aggregator;\n+\n+    private boolean sendOldValues = false;\n+\n+    public KStreamSlidingWindowAggregate(final SlidingWindows windows,\n+                                         final String storeName,\n+                                         final Initializer<Agg> initializer,\n+                                         final Aggregator<? super K, ? super V, Agg> aggregator) {\n+        this.windows = windows;\n+        this.storeName = storeName;\n+        this.initializer = initializer;\n+        this.aggregator = aggregator;\n+    }\n+\n+    @Override\n+    public Processor<K, V> get() {\n+        return new KStreamSlidingWindowAggregateProcessor();\n+    }\n+\n+    public SlidingWindows windows() {\n+        return windows;\n+    }\n+\n+    @Override\n+    public void enableSendingOldValues() {\n+        sendOldValues = true;\n+    }\n+\n+    private class KStreamSlidingWindowAggregateProcessor extends AbstractProcessor<K, V> {\n+        private TimestampedWindowStore<K, Agg> windowStore;\n+        private TimestampedTupleForwarder<Windowed<K>, Agg> tupleForwarder;\n+        private StreamsMetricsImpl metrics;\n+        private InternalProcessorContext internalProcessorContext;\n+        private Sensor lateRecordDropSensor;\n+        private Sensor droppedRecordsSensor;\n+        private long observedStreamTime = ConsumerRecord.NO_TIMESTAMP;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void init(final ProcessorContext context) {\n+            super.init(context);\n+            internalProcessorContext = (InternalProcessorContext) context;\n+            metrics = internalProcessorContext.metrics();\n+            final String threadId = Thread.currentThread().getName();\n+            lateRecordDropSensor = droppedRecordsSensorOrLateRecordDropSensor(\n+                threadId,\n+                context.taskId().toString(),\n+                internalProcessorContext.currentNode().name(),\n+                metrics\n+            );\n+            droppedRecordsSensor = droppedRecordsSensorOrSkippedRecordsSensor(threadId, context.taskId().toString(), metrics);\n+            windowStore = (TimestampedWindowStore<K, Agg>) context.getStateStore(storeName);\n+            tupleForwarder = new TimestampedTupleForwarder<>(\n+                windowStore,\n+                context,\n+                new TimestampedCacheFlushListener<>(context),\n+                sendOldValues);\n+        }\n+\n+        @Override\n+        public void process(final K key, final V value) {\n+            if (key == null || value == null) {\n+                log.warn(\n+                    \"Skipping record due to null key or value. value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n+                    value, context().topic(), context().partition(), context().offset()\n+                );\n+                droppedRecordsSensor.record();\n+                return;\n+            }\n+\n+            final long timestamp = context().timestamp();\n+            processInOrder(key, value, timestamp);\n+        }\n+\n+        public void processInOrder(final K key, final V value, final long timestamp) {\n+\n+            observedStreamTime = Math.max(observedStreamTime, timestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;\n+            }\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            // keep the left type window closest to the record\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> latestLeftTypeWindow = null;\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        // store the combined window if it is found so that a right window can be created for\n+                        // the combined window's max record, as needed\n+                        if (isLeftWindow(next) || endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                    } else if (endTime == timestamp) {\n+                        leftWinAlreadyCreated = true;\n+                        // if current record's left window is the combined window, need to check later if there is a\n+                        // record that needs a right window within the combined window\n+                        if (endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+            //create right window for previous record\n+            if (latestLeftTypeWindow != null) {\n+                final long previousRecord = latestLeftTypeWindow.key.window().end();\n+                final long rightWinStart = previousRecord == windows.timeDifferenceMs() ? latestLeftTypeWindow.value.timestamp() + 1 : previousRecord + 1;\n+                if (!windowStartTimes.contains(rightWinStart) && previousRightWindowPossible(rightWinStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+            }\n+\n+            //create left window for new record\n+            if (!leftWinAlreadyCreated) {\n+                final ValueAndTimestamp<Agg> valueAndTime;\n+                // if there's a right window that the new record could create --> new record's left window is not empty\n+                if (latestLeftTypeWindow != null && previousRightWindowPossible(latestLeftTypeWindow.value.timestamp(), timestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                } else {\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                }\n+                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                    } else if (endTime >= timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window iwll go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the combined window's max record before the current record was added\n+                final long maxRightWindowStart = combinedWindow.value.timestamp() + 1;\n+                //only create the right window if new record falls within it and it does not already exist\n+                if (!windowStartTimes.contains(maxRightWindowStart) && previousRightWindowPossible(maxRightWindowStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(maxRightWindowStart, maxRightWindowStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        private boolean previousRightWindowPossible(\n+            final long rightWindowStart,\n+            final long currentRecordTimestamp) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg4MDMyOQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477880329", "bodyText": "Ok, I see that rightWindowStart <= currentRecordTimestamp isn't necessarily true when you call this from processEarly but I think you're kind of abusing this poor method \ud83d\ude1c . I would keep things simple here and make sure the parameters always mean exactly the same thing when you call this, ie rightWindowStart should always mean that \"the start time of the right window for the record which is previous to the current record\" . If that means some duplicated boolean checks here and there, so be it.", "author": "ableegoldman", "createdAt": "2020-08-27T01:36:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NTg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQzNzU5Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478437596", "bodyText": "Yeah I definitely overused this method, the boolean checks were all so similar but not quite the same that I just kinda forced it together. In terms of duplicated boolean checks, do you mean similar boolean methods would be preferable? Or keeping the boolean checks in the main algorithm", "author": "lct45", "createdAt": "2020-08-27T13:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NTg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ1NDcxNg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478454716", "bodyText": "Update: after parsing out the sketchy use of this function I went with\n// previous record's right window does not already exist and current record falls within previous record's right window private boolean rightWindowNecessaryAndPossible\nI added the check for !windowStartTimesContains()` to clean up the original check (since both check that), which is why I added the \"Necessary\" to the function name. WDYT?", "author": "lct45", "createdAt": "2020-08-27T14:18:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NTg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2MTU0MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478761540", "bodyText": "I guess \"Necessary\" still seems kind of open-ended/vague. By that you mean, \"is not already created\", right? But maybe we should wait until we see the final form of this method in case there are any further changes, and then we can go back and try to fish out a more specific name", "author": "ableegoldman", "createdAt": "2020-08-28T00:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NTg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgwNTYzMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477805632", "bodyText": "I'm having trouble wrapping my head around this line. Why would we create a right window at latestLeftTypeWindow.maxTimestamp + 1 if the previous record was at timeDifferenceMs? Wouldn't we have created the right window for whatever is at latestLeftTypeWindow.maxTimestamp + 1 when we processed the previousRecord?", "author": "ableegoldman", "createdAt": "2020-08-27T00:46:28Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -174,12 +181,11 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n                     }\n                 }\n             }\n-\n             //create right window for previous record\n             if (latestLeftTypeWindow != null) {\n-                final long leftWindowEnd = latestLeftTypeWindow.key.window().end();\n-                final long rightWinStart = leftWindowEnd == windows.timeDifferenceMs() ? latestLeftTypeWindow.value.timestamp() + 1 : leftWindowEnd + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n+                final long previousRecord = latestLeftTypeWindow.key.window().end();\n+                final long rightWinStart = previousRecord == windows.timeDifferenceMs() ? latestLeftTypeWindow.value.timestamp() + 1 : previousRecord + 1;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ0MjczOQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478442739", "bodyText": "If previous record is at timeDifferenceMs then the \"left type window\" we found was the window from [0,timeDifference]. Since we know it's the left window from windowEnd == timeDifference, we know that either we'll create a right window for the max record in the combined window, or we'll create a right window for the record at the end point of the window (which would still be the max record).\nI see that previousRecord is misleading, I renamed it to previousWindowEnd. previousRecord here was really just the windowEnd, since there might not be a record at the end of the combined window, which is the case this is covering. This case is specifically for records that come outside of the combined window, but still need to create a right window for something in the combined window, in which case the right window won't already exist.", "author": "lct45", "createdAt": "2020-08-27T14:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgwNTYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2MjY2Nw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478762667", "bodyText": "Ok before I continue to try and wrap my head around this, is this particular line going to be moot if we start tracking previousRecordTimestamp instead of latestLeftTypeWindow? The point of it was just to distinguish that special case, but now we can just say rightWindowStart = previousRecordTimestamp + 1 -- does that sound right?", "author": "ableegoldman", "createdAt": "2020-08-28T00:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgwNTYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgzNzM3OQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477837379", "bodyText": "Not sure I understand the || endTime == windows.timeDifferenceMs(), is that left over from the 1st PR? It seems important to enforce that the window latestLeftTypeWindow points to is actually a left window", "author": "ableegoldman", "createdAt": "2020-08-27T01:03:42Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -160,11 +160,18 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n+                        // store the combined window if it is found so that a right window can be created for\n+                        // the combined window's max record, as needed\n                         if (isLeftWindow(next) || endTime == windows.timeDifferenceMs()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ0NTEzNw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478445137", "bodyText": "It is, until we have a combined window that holds records that don't have corresponding left windows. I treated the combined window as a defacto left window since it's taking the place of early record's left windows. EX: for timeDifference=10, a record at 4 would be stored in [0,10]. If a record comes in at 11, we need the window from [5,15], but we only create that if we find a leftTypeWindow, which doesn't exist for 4. For these records, [0,10] is the only window we have, and therefore the closest thing to a left type window.\nI didn't change variable names because I wanted the original algorithm to be understandable. It feels like adding early records has added a significant amount of complexity and I do wonder if it's worth it to have the addition confusion for testing flexibility - WDYT?", "author": "lct45", "createdAt": "2020-08-27T14:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgzNzM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyNTIwOQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478725209", "bodyText": "I think it's way too confusing if latestLeftTypeWindow is not necessarily a left type window, we should definitely rename it. But I think we can pick a reasonable name -- the point of keeping this window is really just to learn the timestamp of the previous record, right? Do we even need the aggregate or any other data for this window, or can we just keep track of a long previousRecordTimestamp variable and any time we process a new window in the loop, we just check if window.value.timestamp > previousRecordTimestamp and if so then we set previousRecordTimestamp to this new value\nActually I think that sheds some light on all this: the whole \"keep track of the latest left type window\" idea was a clever way to find the previous record in the original design, before we knew  we could use ValueAndTimestamp to get the max  timestamp of a window. And we never went back over that clever hack and realized we could be less clever now, and just go with the simple approach of checking the max timestamp of every window", "author": "ableegoldman", "createdAt": "2020-08-27T22:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgzNzM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MzUyOA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478743528", "bodyText": "Yeah I think this makes a lot of sense. The one catch I found is that we check to see if latestLeftTypeWindow != null when creating the current record's left window, and if we update previousRecord each time we see a window, we could get a number that isn't actually within range for the current record's left window. EX: record comes in at 30, timeDifference = 10. we have a window [10,20] but it's a right window, and within it the only record is at 12. since it's the max record within that window, we would store it in previousRecordTimestamp , but it's right window is [13,23] which we don't want to create. So I think storing just the long is fine (mostly typing it out to work out my thought process), and the check rightWindowNecessaryAndPossible would weed out us creating the [13,23] window on accident. Does this all seem right?", "author": "lct45", "createdAt": "2020-08-27T23:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgzNzM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1ODQ4Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478758482", "bodyText": "Yeah, you're saying that we just always keep track of the previousRecordTimestamp, but before we go ahead and create a left window for the current window we just actually verify that the previous record is within range? That makes sense to me, actually if anything I feel like it will make rightWindowNecessaryAndPossible even more clear to put it in terms of previousRecordTimestamp. What I'm realizing from this is that it's easier to understand these boolean checks in terms of the actual record locations, in general. Maybe it's just my mental model, I still picture a rectangle sliding over boxes on a timeline \ud83d\ude04", "author": "ableegoldman", "createdAt": "2020-08-27T23:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgzNzM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg2Njg4MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477866880", "bodyText": "Now that I think about it, this isn't exactly true -- you could have the previous record at 10 and the current record at 21 (size is 10), then you'd have to create a right window for [11, 21] but the left window is also [11, 21] which is empty (except for the current record of course).So you'd want to check that previousRecord >= currentRecord - timeDifference which is actually technically what previousRightWindowPossible(rightWindow, timestamp) returns but it took me a long time to figure all that out because we're sort of passing in the wrong parameters here. In this call we pass in latestLeftTypeWindow.value.timestamp which is equivalent to previousRecord.timestamp which is not conceptually the same as the rightWindowStart . I know the logic works out the way you intended but it's pretty hard to untangle. You should update the comment and create a separate method for this case which you can name more accurately for this specific scenario", "author": "ableegoldman", "createdAt": "2020-08-27T01:23:21Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -189,8 +195,8 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create --> new record's left window is not empty", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ1OTQwNQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478459405", "bodyText": "It actually still works for that example. The range doesn't pick up the window from [0,10] as it goes from timestamp - 2*timeDifference, so for this example the range would start at 1. I initially did this to avoid these scenarios entirely. You are right though that the comment doesn't hold for the combined window scenarios. For example, we find the combined window and store it as \"latestLeftTypeWindow\" when we process a record at say, 14. If the max record in \"latestLeftTypeWindow\" is 2, then we don't want to create the right window for that, since it would be [3,13].\nI improved the comment to be if there's a right window that the new record could create && max record falls within left window --> new record's left window is not empty", "author": "lct45", "createdAt": "2020-08-27T14:25:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg2Njg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2MzA3MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478763071", "bodyText": "Here too, is this kind of moot now that we can just track the previousRecordTimestamp? IIUC all we really want to do is make sure that the left window is not empty, which is actually a pretty simple calculation in terms of the previousRecordTimestamp", "author": "ableegoldman", "createdAt": "2020-08-28T00:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg2Njg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg3MDIzNA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477870234", "bodyText": "Actually, do we even need the endTime >= timestamp part of the condition? We're really just iterating over the single dimension of the startTime from 0 to timestamp + 1", "author": "ableegoldman", "createdAt": "2020-08-27T01:26:34Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -232,40 +239,54 @@ private void processEarly(final K key, final V value, final long timestamp, fina\n                     final long startTime = next.key.window().start();\n                     final long endTime = startTime + windows.timeDifferenceMs();\n \n-                    if (endTime == windows.timeDifferenceMs()) {\n+                    if (startTime == 0) {\n                         combinedWindow = next;\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                    } else if (endTime >= timestamp && startTime <= timestamp) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2MjM5NA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478462394", "bodyText": "Yeah I think you're right, I'll take it out", "author": "lct45", "createdAt": "2020-08-27T14:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg3MDIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg3MTA3OQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477871079", "bodyText": "iwll \ud83d\ude42", "author": "ableegoldman", "createdAt": "2020-08-27T01:27:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -232,40 +239,54 @@ private void processEarly(final K key, final V value, final long timestamp, fina\n                     final long startTime = next.key.window().start();\n                     final long endTime = startTime + windows.timeDifferenceMs();\n \n-                    if (endTime == windows.timeDifferenceMs()) {\n+                    if (startTime == 0) {\n                         combinedWindow = next;\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                    } else if (endTime >= timestamp && startTime <= timestamp) {\n                         rightWinAgg = next.value;\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                    } else if (startTime == timestamp + 1) {\n                         rightWinAlreadyCreated = true;\n                     }\n                 }\n             }\n \n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window iwll go in the new record's right window", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg4NDA4OA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477884088", "bodyText": "Also, cool,  I think I understand the concept here but some of the details are a bit fuzzy. Basically if we don't find a right window agg that means we didn't find any windows (besides the combined window), which in turn means that there can only be a single record in the combined window (otherwise you'd get a right window for the earlier record).\nSo we need to use the combined window agg for the current record's right window.  But we should only do that if the one record is actually after the current record, right? I think you actually do implicitly check that is the case below but it's pretty subtle: basically in previousRightWindowPossible you would return false if rightWindowStart > currentRecordTimestamp. But we can check that right here and make it explicit, so that rightWinAgg only ever means the aggregate that we will actually put in the current record's right window. Then we can also clean up previousRightWindowPossible", "author": "ableegoldman", "createdAt": "2020-08-27T01:39:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg3MTA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ4OTQzOA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478489438", "bodyText": "There can be more than one record in the combined window, but if we don't find any right window agg then there are no records to the left of this record (in time) AND to the right of this record (could be one or the other). There could be multiple to the right though.\nIt took me like 5 minutes to figure this out, but actually the call to previousRightWindowPossible is when we're creating the right window for the previous record, not for the current record. This call doesn't involved rightWindowAgg at all, since the check rightWindowStart > currentRecordTimestamp wouldn't help us figure out if previous record > current record.\nThe check for this is actually a little further down (line 277) where we do rightWindowIsNotEmpty, and there it confirms that the values in rightWinAgg are > timestamp.", "author": "lct45", "createdAt": "2020-08-27T15:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg3MTA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2NjE5Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478766196", "bodyText": "Couldn't there still be a record to the left? Like we could have a record at 5 and at 50 and nothing else, then all we would have so far is the combined window and one at [40, 50],  but rightWindowAgg would be null. So that's why we need to check that the combinedWindow.maxTimestamp > timestamp (and if not then we should leave rightWinAgg as null). Looks like this is what you're doing, so not suggesting any changes, just trying to make sure I have this right.", "author": "ableegoldman", "createdAt": "2020-08-28T00:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg3MTA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg4NjY5OA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477886698", "bodyText": "See above: we shouldn't rely on previousRightWindow here. Actually I don't think we need it at all? (assuming we move the check in it to the condition above where we use the combined window agg)", "author": "ableegoldman", "createdAt": "2020-08-27T01:40:55Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -232,40 +239,54 @@ private void processEarly(final K key, final V value, final long timestamp, fina\n                     final long startTime = next.key.window().start();\n                     final long endTime = startTime + windows.timeDifferenceMs();\n \n-                    if (endTime == windows.timeDifferenceMs()) {\n+                    if (startTime == 0) {\n                         combinedWindow = next;\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                    } else if (endTime >= timestamp && startTime <= timestamp) {\n                         rightWinAgg = next.value;\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                    } else if (startTime == timestamp + 1) {\n                         rightWinAlreadyCreated = true;\n                     }\n                 }\n             }\n \n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window iwll go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n             if (combinedWindow == null) {\n                 final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n                 final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n \n             } else {\n-                //create the right window for the most recent max timestamp in the combined window\n-                final long rightWinStart = combinedWindow.value.timestamp() + 1;\n-                if (!windowStartTimes.contains(rightWinStart) && combinedWindow.value.timestamp() < timestamp) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n+                //create the right window for the combined window's max record before the current record was added\n+                final long maxRightWindowStart = combinedWindow.value.timestamp() + 1;\n+                //only create the right window if new record falls within it and it does not already exist\n+                if (!windowStartTimes.contains(maxRightWindowStart) && previousRightWindowPossible(maxRightWindowStart, timestamp)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5MDg2MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478490860", "bodyText": "The comment here was unclear, that's my bad. It should read only create the previous record's right window if the new record falls within it ... . This part doesn't leverage rightWinAgg, since the agg in the previous record's right window will just be the current record's value.", "author": "lct45", "createdAt": "2020-08-27T15:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg4NjY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2MjE1MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478762151", "bodyText": "Alignment is still off, the first parameter should be on the same line as the method declaration. Also, if this method is only ever used in deciding whether to create the previous record's right window, then let's name the parameter previousRecordRightWindowStart or something. Of course, you could also just pass in the previousRecordTimestamp now that we have that, and then do the math in here. Whatever you think makes the most sense", "author": "ableegoldman", "createdAt": "2020-08-28T00:13:36Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream.internals;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.Aggregator;\n+import org.apache.kafka.streams.kstream.Initializer;\n+import org.apache.kafka.streams.kstream.Window;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.kstream.SlidingWindows;\n+import org.apache.kafka.streams.processor.AbstractProcessor;\n+import org.apache.kafka.streams.processor.Processor;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.processor.internals.InternalProcessorContext;\n+import org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.TimestampedWindowStore;\n+import org.apache.kafka.streams.state.ValueAndTimestamp;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrLateRecordDropSensor;\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrSkippedRecordsSensor;\n+import static org.apache.kafka.streams.state.ValueAndTimestamp.getValueOrNull;\n+\n+public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProcessorSupplier<K, Windowed<K>, V, Agg> {\n+    private final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final String storeName;\n+    private final SlidingWindows windows;\n+    private final Initializer<Agg> initializer;\n+    private final Aggregator<? super K, ? super V, Agg> aggregator;\n+\n+    private boolean sendOldValues = false;\n+\n+    public KStreamSlidingWindowAggregate(final SlidingWindows windows,\n+                                         final String storeName,\n+                                         final Initializer<Agg> initializer,\n+                                         final Aggregator<? super K, ? super V, Agg> aggregator) {\n+        this.windows = windows;\n+        this.storeName = storeName;\n+        this.initializer = initializer;\n+        this.aggregator = aggregator;\n+    }\n+\n+    @Override\n+    public Processor<K, V> get() {\n+        return new KStreamSlidingWindowAggregateProcessor();\n+    }\n+\n+    public SlidingWindows windows() {\n+        return windows;\n+    }\n+\n+    @Override\n+    public void enableSendingOldValues() {\n+        sendOldValues = true;\n+    }\n+\n+    private class KStreamSlidingWindowAggregateProcessor extends AbstractProcessor<K, V> {\n+        private TimestampedWindowStore<K, Agg> windowStore;\n+        private TimestampedTupleForwarder<Windowed<K>, Agg> tupleForwarder;\n+        private StreamsMetricsImpl metrics;\n+        private InternalProcessorContext internalProcessorContext;\n+        private Sensor lateRecordDropSensor;\n+        private Sensor droppedRecordsSensor;\n+        private long observedStreamTime = ConsumerRecord.NO_TIMESTAMP;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void init(final ProcessorContext context) {\n+            super.init(context);\n+            internalProcessorContext = (InternalProcessorContext) context;\n+            metrics = internalProcessorContext.metrics();\n+            final String threadId = Thread.currentThread().getName();\n+            lateRecordDropSensor = droppedRecordsSensorOrLateRecordDropSensor(\n+                threadId,\n+                context.taskId().toString(),\n+                internalProcessorContext.currentNode().name(),\n+                metrics\n+            );\n+            droppedRecordsSensor = droppedRecordsSensorOrSkippedRecordsSensor(threadId, context.taskId().toString(), metrics);\n+            windowStore = (TimestampedWindowStore<K, Agg>) context.getStateStore(storeName);\n+            tupleForwarder = new TimestampedTupleForwarder<>(\n+                windowStore,\n+                context,\n+                new TimestampedCacheFlushListener<>(context),\n+                sendOldValues);\n+        }\n+\n+        @Override\n+        public void process(final K key, final V value) {\n+            if (key == null || value == null) {\n+                log.warn(\n+                    \"Skipping record due to null key or value. value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n+                    value, context().topic(), context().partition(), context().offset()\n+                );\n+                droppedRecordsSensor.record();\n+                return;\n+            }\n+\n+            final long timestamp = context().timestamp();\n+            processInOrder(key, value, timestamp);\n+        }\n+\n+        public void processInOrder(final K key, final V value, final long timestamp) {\n+\n+            observedStreamTime = Math.max(observedStreamTime, timestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;\n+            }\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            // keep the left type window closest to the record\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> latestLeftTypeWindow = null;\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        // store the combined window (window from [0,timeDifference] that contains any early records)\n+                        // if it is found so that a right window can be created for the combined window's max record, as needed\n+                        if (isLeftWindow(next) || endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                    } else if (endTime == timestamp) {\n+                        leftWinAlreadyCreated = true;\n+                        // if current record's left window is the combined window, need to check later if there is a\n+                        // record that needs a right window within the combined window\n+                        if (endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+            //create right window for previous record\n+            if (latestLeftTypeWindow != null) {\n+                final long previousWindowEnd = latestLeftTypeWindow.key.window().end();\n+                final long rightWinStart = previousWindowEnd == windows.timeDifferenceMs() ? latestLeftTypeWindow.value.timestamp() + 1 : previousWindowEnd + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, rightWinStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+            }\n+\n+            //create left window for new record\n+            if (!leftWinAlreadyCreated) {\n+                final ValueAndTimestamp<Agg> valueAndTime;\n+                // if there's a right window that the new record could create && max record falls within left window --> new record's left window is not empty\n+                if (latestLeftTypeWindow != null && recordFallsWithinCurrentRecordsLeftWindow(latestLeftTypeWindow.value.timestamp(), timestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                } else {\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                }\n+                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the combined window's max record before the current record was added\n+                final long maxRightWindowStart = combinedWindow.value.timestamp() + 1;\n+                //only create the previous record's right window if the new record falls within it and it does not already exist\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, maxRightWindowStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(maxRightWindowStart, maxRightWindowStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        private boolean recordFallsWithinCurrentRecordsLeftWindow(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n+        }\n+\n+        // previous record's right window does not already exist and current record falls within previous record's right window\n+        private boolean rightWindowNecessaryAndPossible(\n+                                                    final Set<Long> windowStartTimes,\n+                                                    final long rightWindowStart,\n+                                                    final long currentRecordTimestamp) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2ODMzNQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478768335", "bodyText": "This is also kind of unclear (what is a max right window?), but I get that we can't call it previousRecordRightWindow since we don't know that it is a previous record or not at this point. I think yet again, just keeping track of the previous record's timestamp as we iterate through the windows, will be the most clear; if previousRecordTimestamp is still null by this point, we know right away that we don't have to create a previous right window. And then we can actually drop the rightWindowNecessaryAndPossible check altogether, since we know the current record has to be in range of the right window of the previous record (since we're in processEarly). The one exception is if the previous record and current record are on the same timestamp, so we can actually skip the previous right window creation if previousRecordTimestamp  is null OR equal to timestamp", "author": "ableegoldman", "createdAt": "2020-08-28T00:38:40Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream.internals;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.Aggregator;\n+import org.apache.kafka.streams.kstream.Initializer;\n+import org.apache.kafka.streams.kstream.Window;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.kstream.SlidingWindows;\n+import org.apache.kafka.streams.processor.AbstractProcessor;\n+import org.apache.kafka.streams.processor.Processor;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.processor.internals.InternalProcessorContext;\n+import org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.TimestampedWindowStore;\n+import org.apache.kafka.streams.state.ValueAndTimestamp;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrLateRecordDropSensor;\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrSkippedRecordsSensor;\n+import static org.apache.kafka.streams.state.ValueAndTimestamp.getValueOrNull;\n+\n+public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProcessorSupplier<K, Windowed<K>, V, Agg> {\n+    private final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final String storeName;\n+    private final SlidingWindows windows;\n+    private final Initializer<Agg> initializer;\n+    private final Aggregator<? super K, ? super V, Agg> aggregator;\n+\n+    private boolean sendOldValues = false;\n+\n+    public KStreamSlidingWindowAggregate(final SlidingWindows windows,\n+                                         final String storeName,\n+                                         final Initializer<Agg> initializer,\n+                                         final Aggregator<? super K, ? super V, Agg> aggregator) {\n+        this.windows = windows;\n+        this.storeName = storeName;\n+        this.initializer = initializer;\n+        this.aggregator = aggregator;\n+    }\n+\n+    @Override\n+    public Processor<K, V> get() {\n+        return new KStreamSlidingWindowAggregateProcessor();\n+    }\n+\n+    public SlidingWindows windows() {\n+        return windows;\n+    }\n+\n+    @Override\n+    public void enableSendingOldValues() {\n+        sendOldValues = true;\n+    }\n+\n+    private class KStreamSlidingWindowAggregateProcessor extends AbstractProcessor<K, V> {\n+        private TimestampedWindowStore<K, Agg> windowStore;\n+        private TimestampedTupleForwarder<Windowed<K>, Agg> tupleForwarder;\n+        private StreamsMetricsImpl metrics;\n+        private InternalProcessorContext internalProcessorContext;\n+        private Sensor lateRecordDropSensor;\n+        private Sensor droppedRecordsSensor;\n+        private long observedStreamTime = ConsumerRecord.NO_TIMESTAMP;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void init(final ProcessorContext context) {\n+            super.init(context);\n+            internalProcessorContext = (InternalProcessorContext) context;\n+            metrics = internalProcessorContext.metrics();\n+            final String threadId = Thread.currentThread().getName();\n+            lateRecordDropSensor = droppedRecordsSensorOrLateRecordDropSensor(\n+                threadId,\n+                context.taskId().toString(),\n+                internalProcessorContext.currentNode().name(),\n+                metrics\n+            );\n+            droppedRecordsSensor = droppedRecordsSensorOrSkippedRecordsSensor(threadId, context.taskId().toString(), metrics);\n+            windowStore = (TimestampedWindowStore<K, Agg>) context.getStateStore(storeName);\n+            tupleForwarder = new TimestampedTupleForwarder<>(\n+                windowStore,\n+                context,\n+                new TimestampedCacheFlushListener<>(context),\n+                sendOldValues);\n+        }\n+\n+        @Override\n+        public void process(final K key, final V value) {\n+            if (key == null || value == null) {\n+                log.warn(\n+                    \"Skipping record due to null key or value. value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n+                    value, context().topic(), context().partition(), context().offset()\n+                );\n+                droppedRecordsSensor.record();\n+                return;\n+            }\n+\n+            final long timestamp = context().timestamp();\n+            processInOrder(key, value, timestamp);\n+        }\n+\n+        public void processInOrder(final K key, final V value, final long timestamp) {\n+\n+            observedStreamTime = Math.max(observedStreamTime, timestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;\n+            }\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            // keep the left type window closest to the record\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> latestLeftTypeWindow = null;\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        // store the combined window (window from [0,timeDifference] that contains any early records)\n+                        // if it is found so that a right window can be created for the combined window's max record, as needed\n+                        if (isLeftWindow(next) || endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                    } else if (endTime == timestamp) {\n+                        leftWinAlreadyCreated = true;\n+                        // if current record's left window is the combined window, need to check later if there is a\n+                        // record that needs a right window within the combined window\n+                        if (endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+            //create right window for previous record\n+            if (latestLeftTypeWindow != null) {\n+                final long previousWindowEnd = latestLeftTypeWindow.key.window().end();\n+                final long rightWinStart = previousWindowEnd == windows.timeDifferenceMs() ? latestLeftTypeWindow.value.timestamp() + 1 : previousWindowEnd + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, rightWinStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+            }\n+\n+            //create left window for new record\n+            if (!leftWinAlreadyCreated) {\n+                final ValueAndTimestamp<Agg> valueAndTime;\n+                // if there's a right window that the new record could create && max record falls within left window --> new record's left window is not empty\n+                if (latestLeftTypeWindow != null && recordFallsWithinCurrentRecordsLeftWindow(latestLeftTypeWindow.value.timestamp(), timestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                } else {\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                }\n+                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the combined window's max record before the current record was added\n+                final long maxRightWindowStart = combinedWindow.value.timestamp() + 1;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2ODYyNQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478768625", "bodyText": "I know it's effectively the same thing, but it feels a bit harder to reason about a \"hypothetical previous record's right window that may actually not be a previous record at all\" than just \"we do/do not have a previous record\"", "author": "ableegoldman", "createdAt": "2020-08-28T00:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2ODMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5NDQxMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r480194412", "bodyText": "Yeah I see what you mean, I think it makes sense to utilize previous record for both processInOrder and processEarly", "author": "lct45", "createdAt": "2020-08-31T15:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2ODMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2OTAwNA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478769004", "bodyText": "Is this the same as in the non-early process? Maybe we can factor it out into  its own createRightWindowIfNeeded(or whatever)  method.", "author": "ableegoldman", "createdAt": "2020-08-28T00:41:16Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream.internals;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.Aggregator;\n+import org.apache.kafka.streams.kstream.Initializer;\n+import org.apache.kafka.streams.kstream.Window;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.kstream.SlidingWindows;\n+import org.apache.kafka.streams.processor.AbstractProcessor;\n+import org.apache.kafka.streams.processor.Processor;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.processor.internals.InternalProcessorContext;\n+import org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.TimestampedWindowStore;\n+import org.apache.kafka.streams.state.ValueAndTimestamp;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrLateRecordDropSensor;\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrSkippedRecordsSensor;\n+import static org.apache.kafka.streams.state.ValueAndTimestamp.getValueOrNull;\n+\n+public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProcessorSupplier<K, Windowed<K>, V, Agg> {\n+    private final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final String storeName;\n+    private final SlidingWindows windows;\n+    private final Initializer<Agg> initializer;\n+    private final Aggregator<? super K, ? super V, Agg> aggregator;\n+\n+    private boolean sendOldValues = false;\n+\n+    public KStreamSlidingWindowAggregate(final SlidingWindows windows,\n+                                         final String storeName,\n+                                         final Initializer<Agg> initializer,\n+                                         final Aggregator<? super K, ? super V, Agg> aggregator) {\n+        this.windows = windows;\n+        this.storeName = storeName;\n+        this.initializer = initializer;\n+        this.aggregator = aggregator;\n+    }\n+\n+    @Override\n+    public Processor<K, V> get() {\n+        return new KStreamSlidingWindowAggregateProcessor();\n+    }\n+\n+    public SlidingWindows windows() {\n+        return windows;\n+    }\n+\n+    @Override\n+    public void enableSendingOldValues() {\n+        sendOldValues = true;\n+    }\n+\n+    private class KStreamSlidingWindowAggregateProcessor extends AbstractProcessor<K, V> {\n+        private TimestampedWindowStore<K, Agg> windowStore;\n+        private TimestampedTupleForwarder<Windowed<K>, Agg> tupleForwarder;\n+        private StreamsMetricsImpl metrics;\n+        private InternalProcessorContext internalProcessorContext;\n+        private Sensor lateRecordDropSensor;\n+        private Sensor droppedRecordsSensor;\n+        private long observedStreamTime = ConsumerRecord.NO_TIMESTAMP;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void init(final ProcessorContext context) {\n+            super.init(context);\n+            internalProcessorContext = (InternalProcessorContext) context;\n+            metrics = internalProcessorContext.metrics();\n+            final String threadId = Thread.currentThread().getName();\n+            lateRecordDropSensor = droppedRecordsSensorOrLateRecordDropSensor(\n+                threadId,\n+                context.taskId().toString(),\n+                internalProcessorContext.currentNode().name(),\n+                metrics\n+            );\n+            droppedRecordsSensor = droppedRecordsSensorOrSkippedRecordsSensor(threadId, context.taskId().toString(), metrics);\n+            windowStore = (TimestampedWindowStore<K, Agg>) context.getStateStore(storeName);\n+            tupleForwarder = new TimestampedTupleForwarder<>(\n+                windowStore,\n+                context,\n+                new TimestampedCacheFlushListener<>(context),\n+                sendOldValues);\n+        }\n+\n+        @Override\n+        public void process(final K key, final V value) {\n+            if (key == null || value == null) {\n+                log.warn(\n+                    \"Skipping record due to null key or value. value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n+                    value, context().topic(), context().partition(), context().offset()\n+                );\n+                droppedRecordsSensor.record();\n+                return;\n+            }\n+\n+            final long timestamp = context().timestamp();\n+            processInOrder(key, value, timestamp);\n+        }\n+\n+        public void processInOrder(final K key, final V value, final long timestamp) {\n+\n+            observedStreamTime = Math.max(observedStreamTime, timestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;\n+            }\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            // keep the left type window closest to the record\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> latestLeftTypeWindow = null;\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        // store the combined window (window from [0,timeDifference] that contains any early records)\n+                        // if it is found so that a right window can be created for the combined window's max record, as needed\n+                        if (isLeftWindow(next) || endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                    } else if (endTime == timestamp) {\n+                        leftWinAlreadyCreated = true;\n+                        // if current record's left window is the combined window, need to check later if there is a\n+                        // record that needs a right window within the combined window\n+                        if (endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+            //create right window for previous record\n+            if (latestLeftTypeWindow != null) {\n+                final long previousWindowEnd = latestLeftTypeWindow.key.window().end();\n+                final long rightWinStart = previousWindowEnd == windows.timeDifferenceMs() ? latestLeftTypeWindow.value.timestamp() + 1 : previousWindowEnd + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, rightWinStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+            }\n+\n+            //create left window for new record\n+            if (!leftWinAlreadyCreated) {\n+                final ValueAndTimestamp<Agg> valueAndTime;\n+                // if there's a right window that the new record could create && max record falls within left window --> new record's left window is not empty\n+                if (latestLeftTypeWindow != null && recordFallsWithinCurrentRecordsLeftWindow(latestLeftTypeWindow.value.timestamp(), timestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                } else {\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                }\n+                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the combined window's max record before the current record was added\n+                final long maxRightWindowStart = combinedWindow.value.timestamp() + 1;\n+                //only create the previous record's right window if the new record falls within it and it does not already exist\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, maxRightWindowStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(maxRightWindowStart, maxRightWindowStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "48328f651602f2078add6f780bb42199cd2c0316", "url": "https://github.com/apache/kafka/commit/48328f651602f2078add6f780bb42199cd2c0316", "message": "udpates wtih john's comments", "committedDate": "2020-08-28T15:04:32Z", "type": "commit"}, {"oid": "fdfb1cde038e3750bb6d8c3900558bacc18feabc", "url": "https://github.com/apache/kafka/commit/fdfb1cde038e3750bb6d8c3900558bacc18feabc", "message": "udpates wtih john's comments", "committedDate": "2020-08-28T15:42:10Z", "type": "commit"}, {"oid": "1ce06f9321e8c74eeb0c80daaf1acb0ca70f8bd8", "url": "https://github.com/apache/kafka/commit/1ce06f9321e8c74eeb0c80daaf1acb0ca70f8bd8", "message": "Merge branch 'slidingwindows' of github.com:lct45/kafka into slidingwindows", "committedDate": "2020-08-28T15:43:54Z", "type": "commit"}, {"oid": "dd8c4e431479ce88ce3e95a5fe3ba288e5741ce8", "url": "https://github.com/apache/kafka/commit/dd8c4e431479ce88ce3e95a5fe3ba288e5741ce8", "message": "fixes for early records", "committedDate": "2020-08-31T14:33:17Z", "type": "commit"}, {"oid": "8c7e736d6b0b7c9d40e946375065ac976428742b", "url": "https://github.com/apache/kafka/commit/8c7e736d6b0b7c9d40e946375065ac976428742b", "message": "working updates", "committedDate": "2020-08-31T14:33:17Z", "type": "commit"}, {"oid": "8e1d23504ad4c733718fe1f491e0c95bb28e732e", "url": "https://github.com/apache/kafka/commit/8e1d23504ad4c733718fe1f491e0c95bb28e732e", "message": "algorithm and test updates", "committedDate": "2020-08-31T14:33:17Z", "type": "commit"}, {"oid": "c061076d72e51ed0ab056a8dc808566398cbf0d2", "url": "https://github.com/apache/kafka/commit/c061076d72e51ed0ab056a8dc808566398cbf0d2", "message": "updates from sophie's comments", "committedDate": "2020-08-31T14:33:17Z", "type": "commit"}, {"oid": "b7663e7673f470ed74429440689904d92a7132d8", "url": "https://github.com/apache/kafka/commit/b7663e7673f470ed74429440689904d92a7132d8", "message": "PreviousRecord updates, method streamlining", "committedDate": "2020-08-31T15:17:44Z", "type": "commit"}, {"oid": "b7663e7673f470ed74429440689904d92a7132d8", "url": "https://github.com/apache/kafka/commit/b7663e7673f470ed74429440689904d92a7132d8", "message": "PreviousRecord updates, method streamlining", "committedDate": "2020-08-31T15:17:44Z", "type": "forcePushed"}, {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "url": "https://github.com/apache/kafka/commit/8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "message": "rebase with sliding windows pr", "committedDate": "2020-08-31T22:49:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzNTUyOA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481335528", "bodyText": "Seems like we should move this above into the top-level process instead of first calling processInOrder and then calling processEarly.  For one thing, since we actually do need to iterate the full range for the early records, we can just call processEarly without having to decide between processInOrder and processReverse", "author": "ableegoldman", "createdAt": "2020-09-01T18:08:24Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -135,7 +127,11 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             observedStreamTime = Math.max(observedStreamTime, timestamp);\n             final long closeTime = observedStreamTime - windows.gracePeriodMs();\n \n-            //store start times of windows we find\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzNTg0OA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481335848", "bodyText": "Use previousRecordTimestamp like in processEarly.  You can probably remove the comment then", "author": "ableegoldman", "createdAt": "2020-09-01T18:09:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,13 +142,14 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            // Store the previous record\n+            Long previousRecord = null;", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzODAzMA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481338030", "bodyText": "This comment doesn't really add anything, it just describes what the code says. Also, don't we need to check that   windowMaxTimestamp > previousRecordTimestamp before updating previousRecordTimestamp (where windowMaxTimestamp = next.value.timestamp -- it would be nice to assign this to a variable with an explicit name to make it clear what next.value.timestamp actually means).\nSame goes for the below, I guess you could just put the check in a maybeUpdatePreviousRecordTimestamp() method and call it from both places", "author": "ableegoldman", "createdAt": "2020-09-01T18:13:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -164,11 +161,13 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n+                        // update to store the previous record", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3NTgzNA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481375834", "bodyText": "I'm not sure we need to check that, I think that by the nature of going through windows forward, the next window we find will always have a max timestamp that's larger than the previous window. Right? Lemme do an example:\nRecord comes in @30, previous record was at @23, timeDifference = 10. The last window we find with an endTime < timestamp will be 23's left window, where the max record value is 23. Any earlier windows with endTime < timestamp will have a max value less than 23, so we can override them safely", "author": "lct45", "createdAt": "2020-09-01T19:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzODAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MTQ0Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481341446", "bodyText": "This doesn't look right..why would we need to pass in the key and value to createRightWindow ? The distinguishing feature of the current record's right window is that it doesn't  include the current record at all. I see that createRightWindow ultimately calls putAndForward which takes a key and value, but that just seems misleading. I think we should either pass in null to putAndForward for things we don't need, or better yet (imo) don't use putAndForward for the right window creation and just have a clean separation between creation of the right window and everything else", "author": "ableegoldman", "createdAt": "2020-09-01T18:19:17Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MjA4Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481342082", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n          \n          \n            \n                     * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create", "author": "ableegoldman", "createdAt": "2020-09-01T18:20:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MjM5Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481342393", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n          \n          \n            \n                     * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]", "author": "ableegoldman", "createdAt": "2020-09-01T18:20:57Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MjU2MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481342561", "bodyText": "update, or create? (or both?)", "author": "ableegoldman", "createdAt": "2020-09-01T18:21:16Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MzIyMA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481343220", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        //window from [0,timeDifference] that holds all early records\n          \n          \n            \n                        // A window from [0, timeDifferenceMs] that holds all early records\n          \n      \n    \n    \n  \n\nAlso I'd suggest putting the combinedWindow declaration (and comment) above rightWinAgg to avoid ambiguity in what the comment refers to", "author": "ableegoldman", "createdAt": "2020-09-01T18:22:31Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0NDk0NQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481344945", "bodyText": "I think we should always assign the next.value.timestamp value to a variable with an explicit name, eg windowMaxRecordTimestamp, because it's pretty non-obvious what it means and easy to forget", "author": "ableegoldman", "createdAt": "2020-09-01T18:25:44Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0ODM4Nw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481348387", "bodyText": "I think we should add a comment somewhere clarifying some things about how we set the previousRecordTimestamp in processEarly:\nBasically, we only need to check and maybe set it when we're on the combined window, because if it's still null when we're past the combined window then we know there was a record greater than the current record in the combined window already, and in that case we must have already created the right window for the actual previous record. Hopefully you can find a better & more concise way to explain that \ud83d\ude04", "author": "ableegoldman", "createdAt": "2020-09-01T18:32:01Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NTk3Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481355973", "bodyText": "Just leaving a note to the next reviewer, and making sure I understand this myself:\nIf we didn't find a right window agg that either means\n\nthere were no other windows with startTime <= timestamp, which means there are no records earlier than the current one, and no records later than timeDifference (but within range of the current record). We take that to mean that whatever is in the combined window is an aggregate of records that are all to the right of the current record. Note that there could be a record at the same timestamp as the current record, but we will check for that before actually creating the right window below (by checking !rightWinAlreadyCreated)\nThere is just a single record in the combined window that is earlier than the current record. We check for that with the combinedWindow.value.timestamp() > timestamp condition and in that case create no right window\n\nBy the way, can we move the creation of the right window to just after this block, to keep all the relevant logic together?", "author": "ableegoldman", "createdAt": "2020-09-01T18:46:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI4NTQ5Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483285496", "bodyText": "Not sure if I can follow. If combinedWindow.value.timestamp() > timestamp this seems to imply that the current record is out-of-order? Above, you state that for the out-of-order case, the right window would always exist already though? So why do we need this additional check?", "author": "mjsax", "createdAt": "2020-09-03T22:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwNzA4MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483307081", "bodyText": "I think the case you're referring to above is saying that for the out-of-order case, the previous record's right window should already exist -- this line is dealing with the right window of the current record. Maybe that's a signal that we need to clarify the comment/code above (you are referring to this comment, right?)", "author": "ableegoldman", "createdAt": "2020-09-03T23:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxODQ4MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483718480", "bodyText": "Updated the comment in an attempt to do a mini-proof:\n`If there wasn't a right window agg found and we need a right window for our new record, the current aggregate in the combined window will go in the new record's right window. We can be sure that the combined window only holds records that fall into the current record's right window for two reasons:\n\nIf there were records earlier than the current record AND later than the current record, there would be a right window found when we looked for right window agg.\nIf there was only a record before the current record, we wouldn't need a right window for the current record and wouldn't update the rightWinAgg value here, as the combinedWindow.value.timestamp() < inputRecordTimestamp`", "author": "lct45", "createdAt": "2020-09-04T16:10:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0MjM2MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483742361", "bodyText": "I think the case you're referring to above is saying that for the out-of-order case, the previous record's right window should already exist -- this line is dealing with the right window of the current record.\n\nAh. I missed this.\n@lct45: the explanation makes sense. Thx!", "author": "mjsax", "createdAt": "2020-09-04T16:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NTk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MDY3Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481360673", "bodyText": "It's pretty weird to have to pass in key and value when they're not used to create the right window. I notice they're used in the log message for dropped late windows actually, but it seems odd that we should ever end up dropping the right window of the current record. If the record itself is that old, we should just drop it before even processing it, right?\nAssuming you do that, then it feels a lot more reasonable to not call putAndForward from createRightWindow at all, and just do the actual putting and forwarding for the right window case inline.", "author": "ableegoldman", "createdAt": "2020-09-01T18:53:58Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+                if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                    final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createRightWindow(final long timestamp,\n+                                       final ValueAndTimestamp<Agg> rightWinAgg,\n+                                       final K key,\n+                                       final V value,\n+                                       final long closeTime) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+            putAndForward(window, valueAndTime, key, value, closeTime, timestamp);", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3ODIwMQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481378201", "bodyText": "Key is still used when the window is put into the windowStore, but value isn't needed. I agree that it's nice to separate them to clean up the if() checks as well", "author": "lct45", "createdAt": "2020-09-01T19:23:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MDY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2OTAyMQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481469021", "bodyText": "Oh good point, we definitely need the key. But I think separating them turned out well", "author": "ableegoldman", "createdAt": "2020-09-01T22:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MDY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MTQ4NQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481361485", "bodyText": "This isn't used anymore, right?", "author": "ableegoldman", "createdAt": "2020-09-01T18:54:35Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+                if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                    final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createRightWindow(final long timestamp,\n+                                       final ValueAndTimestamp<Agg> rightWinAgg,\n+                                       final K key,\n+                                       final V value,\n+                                       final long closeTime) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+            putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n         }\n \n-        private boolean isLeftWindow(final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> window) {\n-            return window.key.window().end() == window.value.timestamp();\n+        // previous record's right window does not already exist and current record falls within previous record's right window\n+        private boolean rightWindowNecessaryAndPossible(final Set<Long> windowStartTimes,\n+                                                        final long previousRightWindowStart,\n+                                                        final long currentRecordTimestamp) {\n+            return !windowStartTimes.contains(previousRightWindowStart) && previousRightWindowStart + windows.timeDifferenceMs() >= currentRecordTimestamp;\n+        }", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM5MTk5Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481391993", "bodyText": "Just ran it with updates and we do need to check to make sure that the previous record is close enough for us to make a right window from the current record, so I've updated the processEarly create right window for previous record to call this method again", "author": "lct45", "createdAt": "2020-09-01T19:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2MzMzMw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481463333", "bodyText": "I think you mean  processInOrder, not  processEarly (this is correct in the code, it's just the latest comment that doesn't match up)", "author": "ableegoldman", "createdAt": "2020-09-01T22:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA3OTIyMA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r482079220", "bodyText": "Aha yes I very much mean processInOrder", "author": "lct45", "createdAt": "2020-09-02T13:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MTQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MTc0OQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481361749", "bodyText": "nit: remove this added line", "author": "ableegoldman", "createdAt": "2020-09-01T18:54:49Z", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedStreamImplTest.java", "diffHunk": "@@ -239,6 +239,7 @@ private void doCountSlidingWindows(final  MockProcessorSupplier<Windowed<String>\n             inputTopic.pipeInput(\"2\", \"B\", 1000L);\n             inputTopic.pipeInput(\"3\", \"C\", 600L);\n         }\n+", "originalCommit": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "url": "https://github.com/apache/kafka/commit/7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "message": "Method clean-up", "committedDate": "2020-09-01T20:40:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2MDQxMw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481460413", "bodyText": "Sorry, I think my previous comment was a bit unclear. I meant that we should move this block up to where we set the rightWinAgg right after the loop, since this is what we actually use the rightWinAgg for.\nI think the \"create right window for previous record\" logic is fine wherever", "author": "ableegoldman", "createdAt": "2020-09-01T22:10:53Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +190,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);", "originalCommit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NTI2Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481465262", "bodyText": "Do we need to use getValueOrNull here? It seems like rightWinAgg should never be null if we are using it to create a right window", "author": "ableegoldman", "createdAt": "2020-09-01T22:22:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -254,35 +257,43 @@ private void processEarly(final K key, final V value, final long timestamp, fina\n                 rightWinAgg = combinedWindow.value;\n             }\n \n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n             if (combinedWindow == null) {\n                 final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n                 final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n \n             } else {\n-                //create the right window for the previous record if the previous record exists and the window hasn't already been created\n-                if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n-                    final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n-                }\n                 //update the combined window with the new aggregate\n                 putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n             //create right window for new record if needed\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n             }\n         }\n \n-        private void createRightWindow(final long timestamp,\n-                                       final ValueAndTimestamp<Agg> rightWinAgg,\n-                                       final K key,\n-                                       final V value,\n-                                       final long closeTime) {\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n             final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n-            putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), rightWinAgg.timestamp());", "originalCommit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA3ODM0Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r482078343", "bodyText": "Yeah good point, we check for null before calling it", "author": "lct45", "createdAt": "2020-09-02T13:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NTI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NzA1Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481467056", "bodyText": "Same here, can this ever be null? It doesn't seem like it, even if it's a new window we still pass in the initializer value so valueAndTime won't ever be null. ...right?", "author": "ableegoldman", "createdAt": "2020-09-01T22:27:44Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -311,13 +322,8 @@ private void putAndForward(final Window window,\n             if (windowEnd > closeTime) {\n                 //get aggregate from existing window\n                 final Agg oldAgg = getValueOrNull(valueAndTime);", "originalCommit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA4NDg1MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r482084851", "bodyText": "I just ran the tests and it's mostly true that it won't be null. We do have a test, and so it seems like a real life scenario (?), where the reduce initializer is null, so when creating a new window valueAndTime is null.", "author": "lct45", "createdAt": "2020-09-02T13:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NzA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzNDYxMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r482234612", "bodyText": "True, I guess there's no reason the initializer can't return null. Nevermind then", "author": "ableegoldman", "createdAt": "2020-09-02T17:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NzA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjM4OA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481512388", "bodyText": "By the way, I think we should also check if the record is so old that even the latest window it could possibly create/affect would be dropped, and then not process the record at all. (ie basically check if the current record's right window would be dropped) We can record on the lateRecordDropSensor and log the message using the current record's left window.", "author": "ableegoldman", "createdAt": "2020-09-02T00:50:36Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -118,24 +118,20 @@ public void process(final K key, final V value) {\n             }\n \n             final long timestamp = context().timestamp();\n-            //don't process records that don't fall within a full sliding window\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+", "originalCommit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "99507f5d005023eec78a21b6c52cb4e228ee1434", "url": "https://github.com/apache/kafka/commit/99507f5d005023eec78a21b6c52cb4e228ee1434", "message": "Sliding Windows structural updates", "committedDate": "2020-09-02T15:20:45Z", "type": "commit"}, {"oid": "99507f5d005023eec78a21b6c52cb4e228ee1434", "url": "https://github.com/apache/kafka/commit/99507f5d005023eec78a21b6c52cb4e228ee1434", "message": "Sliding Windows structural updates", "committedDate": "2020-09-02T15:20:45Z", "type": "forcePushed"}, {"oid": "c0461645e135237553a65ab7f43750b3f3ee8e5a", "url": "https://github.com/apache/kafka/commit/c0461645e135237553a65ab7f43750b3f3ee8e5a", "message": "add testing for early records", "committedDate": "2020-09-02T17:34:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI5NzY2OQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r482297669", "bodyText": "Wait...what's going on here? Aren't we just creating a new ValueAndTimestamp that's identical to the rightWinAgg? We don't need to make a copy, I assume", "author": "ableegoldman", "createdAt": "2020-09-02T18:45:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,127 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(rightWinAgg.value(), rightWinAgg.timestamp());", "originalCommit": "c0461645e135237553a65ab7f43750b3f3ee8e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMyNDQzNA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r482324434", "bodyText": "Yup, good catch. Must've been leftover from a cleanup", "author": "lct45", "createdAt": "2020-09-02T19:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI5NzY2OQ=="}], "type": "inlineReview"}, {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "url": "https://github.com/apache/kafka/commit/b250d7dc49daf1c98b307cd3367b0088b1952e5a", "message": "Simplify creating current right window", "committedDate": "2020-09-02T19:13:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2NDM5MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481764391", "bodyText": "nit: next is not a great name; maybe existingWindow instead?", "author": "mjsax", "createdAt": "2020-09-02T06:09:48Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -161,29 +157,31 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n                     windowStartTimes.add(next.key.window().start());", "originalCommit": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwMjUzOA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483302538", "bodyText": "currentWindow is probably more traditional but existingWindow sounds good too", "author": "ableegoldman", "createdAt": "2020-09-03T23:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2NDM5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcyOTQwMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483729402", "bodyText": "Well, currentWindows sound like the window of the current record, while this variable point to other windows, too.", "author": "mjsax", "createdAt": "2020-09-04T16:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2NDM5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgyODMzNA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483828334", "bodyText": "Fair enough. I was thinking of current in the context of the while loop, but given that we refer to the \"current record\" elsewhere, currentWindow might be ambiguous", "author": "ableegoldman", "createdAt": "2020-09-04T20:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2NDM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3MzA1Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483073056", "bodyText": "Not sure how this change relates to \"early records\"?", "author": "mjsax", "createdAt": "2020-09-03T15:37:47Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -228,13 +345,8 @@ private void putAndForward(final Window window,\n             if (windowEnd > closeTime) {\n                 //get aggregate from existing window\n                 final Agg oldAgg = getValueOrNull(valueAndTime);\n-                final Agg newAgg;\n-                // keep old aggregate if adding a right window, else add new record's value\n-                if (windowStart == timestamp + 1) {\n-                    newAgg = oldAgg;\n-                } else {\n-                    newAgg = aggregator.apply(key, value, oldAgg);\n-                }\n+                final Agg newAgg = aggregator.apply(key, value, oldAgg);", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNTg0NQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483715845", "bodyText": "I think it might've gotten pulled over when updating from the original PR", "author": "lct45", "createdAt": "2020-09-04T16:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3MzA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgyODA2MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483828060", "bodyText": "This was just from the semi-related cleanup of splitting putAndForward into a separate method for createRightWindow, which was done after the first PR was merged (hence the cleanup occurs in this PR). I think?", "author": "ableegoldman", "createdAt": "2020-09-04T20:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3MzA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NDAwOQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483074009", "bodyText": "Why do we need to check the timestamp?", "author": "mjsax", "createdAt": "2020-09-03T15:39:10Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            windowStore.put(\n+                key,\n+                rightWinAgg,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n+        }\n+\n+        // previous record's right window does not already exist and current record falls within previous record's right window\n+        private boolean rightWindowNecessaryAndPossible(final Set<Long> windowStartTimes,\n+                                                        final long previousRightWindowStart,\n+                                                        final long currentRecordTimestamp) {\n+            return !windowStartTimes.contains(previousRightWindowStart) && previousRightWindowStart + windows.timeDifferenceMs() >= currentRecordTimestamp;\n         }\n \n-        private boolean isLeftWindow(final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> window) {\n-            return window.key.window().end() == window.value.timestamp();\n+        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n+            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNTMzNg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483715336", "bodyText": "In our scan for rightWinAgg , there's a possibility that we find a rightWinAgg that doesn't actually fall within the current record's right window. For example, if we have a record come in at 18, previous records at 16 and 10, we would find the window [11,21] (10's right window) when scanning for our rightWinAgg in processInOrder. [11,21] contains only 16, which is smaller than 18, our current record, indicating that the rightWinAgg is incorrect and the right window is in fact empty.", "author": "lct45", "createdAt": "2020-09-04T16:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NDAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0OTIwNA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483749204", "bodyText": "Thanks. As above, maybe add a short comment? Can it be that we overload the term \"right window\"? For this case, rightWinAgg seems to be the aggregate of last window \"left of the current record\" (and it might contribute to the agg of the right window of the current record). However, it \"is\" not the \"right window of the current record\" itself?", "author": "mjsax", "createdAt": "2020-09-04T17:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NDAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1MjYwMw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483752603", "bodyText": "Just added a comment similar to above.\nAnd yeah, we definitely overload the term \"right window\". The rightWinAgg holds what will be in the current record's right window, if anything, but is not really the right window. A name change could be possible, something like previousWindow but I wonder if that would make using that aggregate to create the new record's right window more confusing.", "author": "lct45", "createdAt": "2020-09-04T17:10:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NDAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgyNzUzMA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483827530", "bodyText": "I thought it was called rightWinAgg because it's the aggregate that goes in the current record's right window. Of course we had to find this aggregate from some other existing window, eg from the \"last window left of the current record\".", "author": "ableegoldman", "createdAt": "2020-09-04T20:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NDAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1MzQ0Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485053442", "bodyText": "I think the catch is that it's only sometimes the aggregate that goes in the current record's right window. Sometimes we don't use the value in rightWingAgg because the right window is empty/doesn't exist, but if there is a right window aggregate, it will be in rightWinAgg", "author": "lct45", "createdAt": "2020-09-08T16:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NDAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NzIzOA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483077238", "bodyText": "q: Should we rename currentTimestamp -> timestamp for consistency? (or maybe, rename timestamp to inputRecordTimestamp all over the place?", "author": "mjsax", "createdAt": "2020-09-03T15:43:54Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            windowStore.put(\n+                key,\n+                rightWinAgg,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwNzI4OQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483307289", "bodyText": "+1 to this", "author": "ableegoldman", "createdAt": "2020-09-03T23:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NzIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3ODAxOA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483078018", "bodyText": "Why do we do this check based on timestamps?", "author": "mjsax", "createdAt": "2020-09-03T15:44:59Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            windowStore.put(\n+                key,\n+                rightWinAgg,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5NTcwMw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483695703", "bodyText": "If the previous record falls within the current record's left window, then it contains values other than just the current record. There is a scenario where we find a previous record just outside of the current record, which would indicate that the current record's left window only contains the current record.\nEX: if we have a record at 25, and previous records at 13 and 4 and with a time difference of 10, we find 4's right window at [5,15] in our scan. We log the maxRecordTimestamp of this window, which is 13, as 25's previous record. We don't actually want to create 13's right window though, even if it's the previous record, because 25 falls outside of [14,24].\nUsing the timestamps seemed like a simple litmus test to see if we found anything that falls within the window and was necessary after we found the previous record consistently by looking at the maxRecordTimestamp of a window.", "author": "lct45", "createdAt": "2020-09-04T15:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3ODAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0NjE2Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483746166", "bodyText": "Thanks. Should we add a comment?\n// checks if the previous record falls into the current records left window; if yes, the left window is not empty, otherwise it is empty\n\nOr something like this?", "author": "mjsax", "createdAt": "2020-09-04T16:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3ODAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3OTIyOQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483079229", "bodyText": "Same question as above about currentRecordTimestamp (It seems best to me, to use the same variable name for the same think throughout all methods.)", "author": "mjsax", "createdAt": "2020-09-03T15:46:40Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            windowStore.put(\n+                key,\n+                rightWinAgg,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n+        }\n+\n+        // previous record's right window does not already exist and current record falls within previous record's right window\n+        private boolean rightWindowNecessaryAndPossible(final Set<Long> windowStartTimes,\n+                                                        final long previousRightWindowStart,\n+                                                        final long currentRecordTimestamp) {", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4MjA2MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483082060", "bodyText": "nit: Instead, they will fall within the [0, timeDifferenceMs] -> Instead, we will put them into the [0, timeDifferenceMs] window as a \"workaround\",", "author": "mjsax", "createdAt": "2020-09-03T15:50:56Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4NTA2Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483085063", "bodyText": "nit: flip both lines:\nfinal long startTime = next.key.window().start();\nwindowStartTimes.add(startTime);", "author": "mjsax", "createdAt": "2020-09-03T15:55:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483205168", "bodyText": "Not sure if I understand the last sentence: This will always be true for early records, as they all fall within [0, timeDifferenceMs]?\nAlso not sure how this comment relates to setting previousRecordTimestamp ?", "author": "mjsax", "createdAt": "2020-09-03T19:25:49Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwNTUwMQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483305501", "bodyText": "I think it means, for a generic out-of-order record, it's possible that the previous record's right window will have already been created (by whatever record (s) are later than the current one). But for an early record, if maxRecordTimestamp > timestamp, then we know that the previous record's right window must have already been created (by whatever record(s) are within the combined window but later than the current record).\nThis is relevant to setting previousRecordTimestamp because if maxRecordTimestamp >= timestamp, the previous record's right window has already been created. And if that's the case, we don't have to create it ourselves and thus we don't care about the previousRecordTimestamp\nDoes that sound right Leah?", "author": "ableegoldman", "createdAt": "2020-09-03T23:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwOTA4Nw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483309087", "bodyText": "Yeah that's right.\n\nBut for an early record, if maxRecordTimestamp > timestamp, we know that the previous record's right window must have already been created\n\nI think this is key - we know this because for any early record, it will always fall within the right window of the previous record (given there is one), since they both fall within the [0, timeDifferenceMs] window. It's hard to phrase clearly on the comment, I can add another line about the proof if that would be helful", "author": "lct45", "createdAt": "2020-09-03T23:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4NTMyNQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483685325", "bodyText": "Going back and re-reading this comments in the context of Matthias's later comment, it seems like maybe this one is unnecessary. Correct me if I'm wrong, but it feels like the statement if (windowMaxRecordTimestamp < timestamp) { previousRecordTimestamp = windowMaxRecordTimestamp; }\nis somewhat self explanatory. I also don't think I ever leverage the idea that if there is a record before the current record, then the previous record's right window has already been created. Below, I still check previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1). I think either the logic can be updated to leverage what the above comment indicates, or we can cut it out and keep the logic simple. WDYT?", "author": "lct45", "createdAt": "2020-09-04T15:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczOTc4Mw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483739783", "bodyText": "@ableegoldman WDYT?", "author": "mjsax", "createdAt": "2020-09-04T16:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgzNTczMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483835732", "bodyText": "the statement if (windowMaxRecordTimestamp < timestamp) { previousRecordTimestamp = windowMaxRecordTimestamp; }is somewhat self explanatory\n\nI think that's fair. My concern was with the windowMaxRecordTimestamp > timestamp case -- in that situation, we don't know and can't know what the previousRecordTimestamp is, because all we save is the maxTimestamp of the combined window and therefore the information is lost. I just thought we should clarify that this is actually ok, because if windowMaxRecordTimestamp > timestamp then we must have already created the right window of the previous record. So I agree that the !windowStartTimes.contains(previousRecordTimestamp + 1) check would logically catch this, but I don't think we can remove either check:\nIf we remove the if (windowMaxRecordTimestamp < timestamp) { previousRecordTimestamp = windowMaxRecordTimestamp; } then we might set previousRecordTimestamp to a value that isn't actually the timestamp of a previous record, and we should make sure all variables are always accurate\nIf we remove the !windowStartTimes.contains(previousRecordTimestamp + 1) then we could miss a case where the previous record's right window was already created, but by a record out side of the combined window\nSo, I think the code itself is complete as is. But probably we can simplify the comments to make it more understandable -- it seems reasonable to remove the comment here entirely. Then maybe you could leave a brief comment down below where we create the previous record's right window saying \"if the previousRecordTimestamp is null, either there is no previous record or it's right window has already been created\"", "author": "ableegoldman", "createdAt": "2020-09-04T20:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgzOTA2MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483839060", "bodyText": "Oh yeah you're right, I'd forgotten why we added that comment in the first place. What about something briefer like\nWe don't need to store previousRecordTimestamp if maxRecordTimestamp > timestamp because the previous record's right window (if there is a previous record) would have already been created by maxRecordTimestamp", "author": "lct45", "createdAt": "2020-09-04T20:51:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NDUxMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r484094512", "bodyText": "Ah, good call, that makes sense to me", "author": "ableegoldman", "createdAt": "2020-09-06T17:24:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNzEwNg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483207106", "bodyText": "nit: should we rename putAndForward to updateWindowAndForward?", "author": "mjsax", "createdAt": "2020-09-03T19:29:55Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxMDkxMg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483210912", "bodyText": "Seem this can be a simple else? No need to verify the condition? (Maybe it's helpful to add a comment instead?)", "author": "mjsax", "createdAt": "2020-09-03T19:37:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwNjEwOQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483306109", "bodyText": "Maybe we can do an else throw IllegalStateException here as well. I guess a comment could achieve the same code clarify, but personally I think it's a good idea to have this sanity check.", "author": "ableegoldman", "createdAt": "2020-09-03T23:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxMDkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0MDAxNg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483740016", "bodyText": "SGTM.", "author": "mjsax", "createdAt": "2020-09-04T16:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxMDkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxNDgwNQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483214805", "bodyText": "Given, that we call processEarly only if 0 < timestamp < timeDifferenceMs, we know that timestamp - 2 * windows.timeDifferenceMs() would always be negative? Thus, we can just pass in zero here?\nIf this is correct, we might want to add a check at the beginning of this method:\nif (timestamp < 0 || timestamp >= timeDifferenceMs) {\n  throw new IllegalArgumentException(\"...\");\n}", "author": "mjsax", "createdAt": "2020-09-03T19:45:54Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4MTk1Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483681956", "bodyText": "Makes sense to me", "author": "lct45", "createdAt": "2020-09-04T15:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxNDgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI4OTQ2Nw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483289467", "bodyText": "Seems we don't need the if as this is the only valid case? Adding a comment might be helpful.\nIf you want to keep the if as a sanity check, we should add a final:\n} else {\n  throw new IllegalStateException(...):\n}", "author": "mjsax", "createdAt": "2020-09-03T22:36:13Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -161,29 +180,31 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n                     windowStartTimes.add(next.key.window().start());\n                     final long startTime = next.key.window().start();\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n                     } else if (endTime == timestamp) {\n                         leftWinAlreadyCreated = true;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n                     } else if (endTime > timestamp && startTime <= timestamp) {\n                         rightWinAgg = next.value;\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                    } else if (startTime == timestamp + 1) {", "originalCommit": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwMjkzNA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483302934", "bodyText": "It was my suggestion to explicitly check if (startTime == timestamp + 1) instead of just falling back to else, for code clarify and safety, so blame me. But +1 to adding the else throw IllegalStateException", "author": "ableegoldman", "createdAt": "2020-09-03T23:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI4OTQ2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwODA5MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483308090", "bodyText": "Ah yeah, I do throw one in the updated version of this in the reverse iterator PR, but it hasn't gotten moved over here yet. I'll do that.", "author": "lct45", "createdAt": "2020-09-03T23:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI4OTQ2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczNjI1Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483736252", "bodyText": "The suggest is not bad, but required to add the else-throw to make sense. Otherwise, an programming error could slip undetected.", "author": "mjsax", "createdAt": "2020-09-04T16:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI4OTQ2Nw=="}], "type": "inlineReview"}, {"oid": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "url": "https://github.com/apache/kafka/commit/6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "message": "Matthias's updates", "committedDate": "2020-09-04T17:15:14Z", "type": "commit"}, {"oid": "586621302e59977d8b6eb3ddf15714cc39c0df3b", "url": "https://github.com/apache/kafka/commit/586621302e59977d8b6eb3ddf15714cc39c0df3b", "message": "updated comments", "committedDate": "2020-09-08T16:35:39Z", "type": "commit"}, {"oid": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "url": "https://github.com/apache/kafka/commit/6821e92e2cfd4ee8d763cdf2569578682db6d463", "message": "Merge branch 'trunk' of github.com:apache/kafka into early-records", "committedDate": "2020-09-08T16:40:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyOTU5OQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485129599", "bodyText": "nit: 1 -> 1L", "author": "mjsax", "createdAt": "2020-09-08T18:54:25Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -117,25 +117,44 @@ public void process(final K key, final V value) {\n                 return;\n             }\n \n-            final long timestamp = context().timestamp();\n-            //don't process records that don't fall within a full sliding window\n-            if (timestamp < windows.timeDifferenceMs()) {\n+            final long inputRecordTimestamp = context().timestamp();\n+            observedStreamTime = Math.max(observedStreamTime, inputRecordTimestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (inputRecordTimestamp + 1 + windows.timeDifferenceMs() <= closeTime) {", "originalCommit": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTIwMQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485141201", "bodyText": "nit: fall between 0 < inputRecordTimestamp -> fall between 0 <= inputRecordTimestamp", "author": "mjsax", "createdAt": "2020-09-08T19:16:26Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,96 +165,203 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            Long previousRecordTimestamp = null;\n+\n             try (\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    timestamp - 2 * windows.timeDifferenceMs(),\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n                 while (iterator.hasNext()) {\n-                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n \n-                    if (endTime < timestamp) {\n-                        leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n-                    } else if (endTime == timestamp) {\n+                    if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = windowBeingProcessed.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                    } else if (endTime == inputRecordTimestamp) {\n                         leftWinAlreadyCreated = true;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n+                    final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n                 } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n                 }\n-                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                final TimeWindow window = new TimeWindow(inputRecordTimestamp - windows.timeDifferenceMs(), inputRecordTimestamp);\n+                updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n             }\n-            //create right window for new record\n-            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, inputRecordTimestamp)) {\n+                createCurrentRecordRightWindow(inputRecordTimestamp, rightWinAgg, key);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        /**\n+         * Created to handle records where 0 < inputRecordTimestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, we will put them into the [0, timeDifferenceMs]\n+         * window as a \"workaround\", and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long inputRecordTimestamp, final long closeTime) {\n+            if (inputRecordTimestamp < 0 || inputRecordTimestamp >= windows.timeDifferenceMs()) {\n+                throw new IllegalArgumentException(\"Early record for sliding windows must fall between 0 < inputRecordTimestamp < timeDifferenceMs\");", "originalCommit": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMTkzMQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485221931", "bodyText": "nit: log an error and include the inputRecordTimestamp", "author": "ableegoldman", "createdAt": "2020-09-08T22:06:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTg5Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485141892", "bodyText": "nit: maxRecordTimestamp > timestamp -> maxRecordTimestamp >= timestamp\nnit: missing space: // We", "author": "mjsax", "createdAt": "2020-09-08T19:17:55Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,96 +165,203 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            Long previousRecordTimestamp = null;\n+\n             try (\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    timestamp - 2 * windows.timeDifferenceMs(),\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n                 while (iterator.hasNext()) {\n-                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n \n-                    if (endTime < timestamp) {\n-                        leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n-                    } else if (endTime == timestamp) {\n+                    if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = windowBeingProcessed.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                    } else if (endTime == inputRecordTimestamp) {\n                         leftWinAlreadyCreated = true;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n+                    final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n                 } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n                 }\n-                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                final TimeWindow window = new TimeWindow(inputRecordTimestamp - windows.timeDifferenceMs(), inputRecordTimestamp);\n+                updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n             }\n-            //create right window for new record\n-            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, inputRecordTimestamp)) {\n+                createCurrentRecordRightWindow(inputRecordTimestamp, rightWinAgg, key);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        /**\n+         * Created to handle records where 0 < inputRecordTimestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, we will put them into the [0, timeDifferenceMs]\n+         * window as a \"workaround\", and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long inputRecordTimestamp, final long closeTime) {\n+            if (inputRecordTimestamp < 0 || inputRecordTimestamp >= windows.timeDifferenceMs()) {\n+                throw new IllegalArgumentException(\"Early record for sliding windows must fall between 0 < inputRecordTimestamp < timeDifferenceMs\");\n+            }\n+\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    0,\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    inputRecordTimestamp + 1)\n+            ) {\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = windowBeingProcessed;\n+                        //We don't need to store previousRecordTimestamp if maxRecordTimestamp > timestamp", "originalCommit": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0OTY0MQ==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485149641", "bodyText": "Why do we need to suppress?", "author": "mjsax", "createdAt": "2020-09-08T19:32:49Z", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -439,6 +442,185 @@ public void testJoin() {\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzNTg4MA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485235880", "bodyText": "Without it, there are warnings with the transition from K, V to Long, ValueAndTimestamp when adding and updating the hash map that holds the results.", "author": "lct45", "createdAt": "2020-09-08T22:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0OTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzOTk5OA==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485239998", "bodyText": "That seems weird to me. Guessing it's ultimately due to the supplier.theCapturedProcessor().processed() we loop over. But then wouldn't we get the warning a bit earlier? \ud83e\udd37\u200d\u2640\ufe0f", "author": "ableegoldman", "createdAt": "2020-09-08T22:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0OTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0ODQ4Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485248486", "bodyText": "Yeah I do find it odd that there are no warnings earlier, it's something about the Map that's triggering them", "author": "lct45", "createdAt": "2020-09-08T23:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0OTY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0OTA4Nw==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485249087", "bodyText": "It's probably some weird Java thing where it lazily types the generics and doesn't force the cast until you put it in the map. (I just made that up, but @vvcephei  would probably know)", "author": "ableegoldman", "createdAt": "2020-09-08T23:26:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0OTY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMTA1Mg==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485221052", "bodyText": "nit: log an error and include the relevant info (eg windowStart and inputRecordTimestamp at least). Same for the IllegalStateException in processEarly", "author": "ableegoldman", "createdAt": "2020-09-08T22:03:54Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,96 +165,203 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            Long previousRecordTimestamp = null;\n+\n             try (\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    timestamp - 2 * windows.timeDifferenceMs(),\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n                 while (iterator.hasNext()) {\n-                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n \n-                    if (endTime < timestamp) {\n-                        leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n-                    } else if (endTime == timestamp) {\n+                    if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = windowBeingProcessed.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                    } else if (endTime == inputRecordTimestamp) {\n                         leftWinAlreadyCreated = true;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");", "originalCommit": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMjk5Ng==", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485222996", "bodyText": "nit: this code is pretty self-explanatory now, so the comment isn't really adding anything", "author": "ableegoldman", "createdAt": "2020-09-08T22:09:09Z", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,96 +165,203 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            Long previousRecordTimestamp = null;\n+\n             try (\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    timestamp - 2 * windows.timeDifferenceMs(),\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n                 while (iterator.hasNext()) {\n-                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n \n-                    if (endTime < timestamp) {\n-                        leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n-                    } else if (endTime == timestamp) {\n+                    if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = windowBeingProcessed.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                    } else if (endTime == inputRecordTimestamp) {\n                         leftWinAlreadyCreated = true;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n+                    final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n                 } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n                 }\n-                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                final TimeWindow window = new TimeWindow(inputRecordTimestamp - windows.timeDifferenceMs(), inputRecordTimestamp);\n+                updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n             }\n-            //create right window for new record\n-            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, inputRecordTimestamp)) {\n+                createCurrentRecordRightWindow(inputRecordTimestamp, rightWinAgg, key);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        /**\n+         * Created to handle records where 0 < inputRecordTimestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, we will put them into the [0, timeDifferenceMs]\n+         * window as a \"workaround\", and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long inputRecordTimestamp, final long closeTime) {\n+            if (inputRecordTimestamp < 0 || inputRecordTimestamp >= windows.timeDifferenceMs()) {\n+                throw new IllegalArgumentException(\"Early record for sliding windows must fall between 0 < inputRecordTimestamp < timeDifferenceMs\");\n+            }\n+\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    0,\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    inputRecordTimestamp + 1)\n+            ) {\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = windowBeingProcessed;\n+                        //We don't need to store previousRecordTimestamp if maxRecordTimestamp > timestamp\n+                        // because the previous record's right window (if there is a previous record)\n+                        // would have already been created by maxRecordTimestamp\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n+                    }\n+                }\n+            }\n+\n+            // If there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window. We can be sure that the combined\n+            // window only holds records that fall into the current record's right window for two reasons:\n+            // 1. If there were records earlier than the current record AND later than the current record, there would be a right window found\n+            // when we looked for right window agg.\n+            // 2. If there was only a record before the current record, we wouldn't need a right window for the current record and wouldn't update the\n+            // rightWinAgg value here, as the combinedWindow.value.timestamp() < inputRecordTimestamp\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > inputRecordTimestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed", "originalCommit": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6580b9f9670ac77220eeb29fd50733c73a532f2a", "url": "https://github.com/apache/kafka/commit/6580b9f9670ac77220eeb29fd50733c73a532f2a", "message": "Nit fixes", "committedDate": "2020-09-08T23:06:42Z", "type": "commit"}, {"oid": "7d4ca6a3b9ea899afa680ec852fdfdfb5e2f3d58", "url": "https://github.com/apache/kafka/commit/7d4ca6a3b9ea899afa680ec852fdfdfb5e2f3d58", "message": "log fixes", "committedDate": "2020-09-08T23:35:04Z", "type": "commit"}]}