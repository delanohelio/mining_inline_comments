{"pr_number": 8569, "pr_title": "KIP-551: Expose disk read and write metrics", "pr_createdAt": "2020-04-28T05:32:34Z", "pr_url": "https://github.com/apache/kafka/pull/8569", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MTY5OQ==", "url": "https://github.com/apache/kafka/pull/8569#discussion_r416391699", "bodyText": "Nit: do you think the lock should be hold while reading /proc, or restricted to the update of lastUpdateMs, cachedReadBytes and cachedWriteBytes?", "author": "Hangleton", "createdAt": "2020-04-28T07:29:53Z", "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(val procPath: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedReadBytes\n+  }\n+\n+  def writeBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedWriteBytes\n+  }\n+\n+  /**\n+   * Read /proc/self/io.\n+   *\n+   * Generally, each line in this file contains a prefix followed by a colon and a number.\n+   *\n+   * For example, it might contain this:\n+   * rchar: 4052\n+   * wchar: 0\n+   * syscr: 13\n+   * syscw: 0\n+   * read_bytes: 0\n+   * write_bytes: 0\n+   * cancelled_write_bytes: 0\n+   */\n+  def updateValues(now: Long): Boolean = this.synchronized {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MTUyMw==", "url": "https://github.com/apache/kafka/pull/8569#discussion_r416961523", "bodyText": "Unless we choose to read this file in a background thread, there isn't a reason to avoid using a lock here.", "author": "cmccabe", "createdAt": "2020-04-28T22:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MTY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEwNzc3Nw==", "url": "https://github.com/apache/kafka/pull/8569#discussion_r417107777", "bodyText": "What I meant is not avoid the usage of a lock but restrict its scope to put it outside of the invocation of Files#readline.\nThe motivation for this is in case of I/O stall, that invocation may block for a long time (until the kernel times the operation out), with consequences for other pretendant to acquire the lock.\nThat said the invocation is on the readBytes/writeBytes metrics path, so in fine it doesn't matter.", "author": "Hangleton", "createdAt": "2020-04-29T07:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MTY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4NDgyOQ==", "url": "https://github.com/apache/kafka/pull/8569#discussion_r422584829", "bodyText": "Assuming there's no background refresh thread, the only thread that is reading from /proc is the thread calling readBytes.  So you still have to wait for that read, whether or not you use a lock here.", "author": "cmccabe", "createdAt": "2020-05-10T04:57:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MTY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4NDkyNA==", "url": "https://github.com/apache/kafka/pull/8569#discussion_r422584924", "bodyText": "Also there is not going to be an I/O stall reading from /proc since /proc is not a real disk.  I would still prefer to do fewer system calls rather than more, but I don't think that's worth adding a background thread for.", "author": "cmccabe", "createdAt": "2020-05-10T04:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MTY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyMTY2Nw==", "url": "https://github.com/apache/kafka/pull/8569#discussion_r421521667", "bodyText": "This prints a stacktrace at startup when not on Linux. I wonder if we should check if /proc exists and only print a stacktrace if it exists and we can't read it. WDYT?", "author": "mimaison", "createdAt": "2020-05-07T13:53:12Z", "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(val procPath: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedReadBytes\n+  }\n+\n+  def writeBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedWriteBytes\n+  }\n+\n+  /**\n+   * Read /proc/self/io.\n+   *\n+   * Generally, each line in this file contains a prefix followed by a colon and a number.\n+   *\n+   * For example, it might contain this:\n+   * rchar: 4052\n+   * wchar: 0\n+   * syscr: 13\n+   * syscw: 0\n+   * read_bytes: 0\n+   * write_bytes: 0\n+   * cancelled_write_bytes: 0\n+   */\n+  def updateValues(now: Long): Boolean = this.synchronized {\n+    try {\n+      cachedReadBytes = -1\n+      cachedWriteBytes = -1\n+      val lines = Files.readAllLines(Paths.get(procPath, \"self\", \"io\")).asScala\n+      lines.foreach(line => {\n+        if (line.startsWith(READ_BYTES_PREFIX)) {\n+          cachedReadBytes = line.substring(READ_BYTES_PREFIX.size).toLong\n+        } else if (line.startsWith(WRITE_BYTES_PREFIX)) {\n+          cachedWriteBytes = line.substring(WRITE_BYTES_PREFIX.size).toLong\n+        }\n+      })\n+      lastUpdateMs = now\n+      true\n+    } catch {\n+      case t: Throwable => {\n+        logger.warn(\"LinuxIoMetricsCollector: unable to update metrics\", t)\n+        false\n+      }\n+    }\n+  }\n+\n+  def usable(): Boolean = {\n+    updateValues(time.milliseconds())", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4NTQwOA==", "url": "https://github.com/apache/kafka/pull/8569#discussion_r422585408", "bodyText": "Good point.  I will add a check.", "author": "cmccabe", "createdAt": "2020-05-10T05:04:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyMTY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyNTMyNA==", "url": "https://github.com/apache/kafka/pull/8569#discussion_r421525324", "bodyText": "Should we have add small jitter to lastUpdateMs as both metrics should trigger around the same time, ie\nif (curMs > lastUpdateMs + 100) {", "author": "mimaison", "createdAt": "2020-05-07T13:57:57Z", "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(val procPath: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4NTU1OQ==", "url": "https://github.com/apache/kafka/pull/8569#discussion_r422585559", "bodyText": "This code is just there to prevent reading from proc more than once a millisecond.  I expect in practice we will read fewer times since we only read when the metrics values are fetched.", "author": "cmccabe", "createdAt": "2020-05-10T05:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyNTMyNA=="}], "type": "inlineReview"}, {"oid": "97e8934a1ad9a71a1ad4251499151a09becdfabc", "url": "https://github.com/apache/kafka/commit/97e8934a1ad9a71a1ad4251499151a09becdfabc", "message": "KIP-551: Expose disk read and write metrics", "committedDate": "2020-05-10T05:05:23Z", "type": "commit"}, {"oid": "8ff17cc0ab0961ff8eda2d75fb53faef7cfa4396", "url": "https://github.com/apache/kafka/commit/8ff17cc0ab0961ff8eda2d75fb53faef7cfa4396", "message": "Address review comments", "committedDate": "2020-05-10T05:05:23Z", "type": "commit"}, {"oid": "8ff17cc0ab0961ff8eda2d75fb53faef7cfa4396", "url": "https://github.com/apache/kafka/commit/8ff17cc0ab0961ff8eda2d75fb53faef7cfa4396", "message": "Address review comments", "committedDate": "2020-05-10T05:05:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ0Mzg4OQ==", "url": "https://github.com/apache/kafka/pull/8569#discussion_r425443889", "bodyText": "minor nit: could move the time check to the updateValues method since that's where lastUpdateMs is set?", "author": "mumrah", "createdAt": "2020-05-14T21:33:45Z", "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,102 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(procRoot: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+  val path = Paths.get(procRoot, \"self\", \"io\")\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()", "originalCommit": "8ff17cc0ab0961ff8eda2d75fb53faef7cfa4396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwODY1Nw==", "url": "https://github.com/apache/kafka/pull/8569#discussion_r426808657", "bodyText": "Interesting idea, but that would complicate the usable function, right?  Probably better to leave it where it is.", "author": "cmccabe", "createdAt": "2020-05-18T18:12:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ0Mzg4OQ=="}], "type": "inlineReview"}]}