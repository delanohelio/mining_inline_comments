{"pr_number": 8706, "pr_title": "KAFKA-10030 allow fetching a key from a single partition", "pr_createdAt": "2020-05-21T11:06:57Z", "pr_url": "https://github.com/apache/kafka/pull/8706", "timeline": [{"oid": "439bb29d51b2e6f8522013a7eaf42adcc74238f5", "url": "https://github.com/apache/kafka/commit/439bb29d51b2e6f8522013a7eaf42adcc74238f5", "message": "MAJOR: Fix allow fetching key from single partition", "committedDate": "2020-05-21T11:06:00Z", "type": "commit"}, {"oid": "891abd9e8d70bc08892b9f61ab081acf9befed31", "url": "https://github.com/apache/kafka/commit/891abd9e8d70bc08892b9f61ab081acf9befed31", "message": "break if at least one state store is found", "committedDate": "2020-05-21T11:22:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMTE1Mg==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r428831152", "bodyText": "We should write a proper test case instead of \"piggy-backing\" it into an existing test.", "author": "mjsax", "createdAt": "2020-05-21T18:21:41Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -332,6 +332,7 @@ private Properties streamsConfiguration() {\n         config.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, 200);\n         config.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, 1000);\n         config.put(StreamsConfig.COMMIT_INTERVAL_MS_CONFIG, 100);\n+        config.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 2);", "originalCommit": "891abd9e8d70bc08892b9f61ab081acf9befed31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg5OTM4Mw==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r428899383", "bodyText": "Added dedicated test", "author": "dima5rr", "createdAt": "2020-05-21T20:35:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMTE1Mg=="}], "type": "inlineReview"}, {"oid": "d49d97837452f01a84ca2cb41247f15b0432bc34", "url": "https://github.com/apache/kafka/commit/d49d97837452f01a84ca2cb41247f15b0432bc34", "message": "[TESTS] add dedicated tests running streams with multiple threads", "committedDate": "2020-05-21T20:34:36Z", "type": "commit"}, {"oid": "3fd8aff27c7370a851469e3ee9f2990a124172fd", "url": "https://github.com/apache/kafka/commit/3fd8aff27c7370a851469e3ee9f2990a124172fd", "message": "[TESTS] remove unused import", "committedDate": "2020-05-21T20:43:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUxNTEwNg==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r429515106", "bodyText": "stale stores \"are\" not enabled?", "author": "brary", "createdAt": "2020-05-23T05:07:32Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -296,6 +297,87 @@ public void shouldQuerySpecificStalePartitionStores() throws Exception {\n         assertThat(store4.get(key), is(nullValue()));\n     }\n \n+    @Test\n+    public void shouldQuerySpecificActivePartitionStoresMultiStreamThreads() throws Exception {\n+        final int batch1NumMessages = 100;\n+        final int key = 1;\n+        final Semaphore semaphore = new Semaphore(0);\n+        final int numStreamThreads = 2;\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder.table(INPUT_TOPIC_NAME, Consumed.with(Serdes.Integer(), Serdes.Integer()),\n+                Materialized.<Integer, Integer, KeyValueStore<Bytes, byte[]>>as(TABLE_NAME)\n+                        .withCachingDisabled())\n+                .toStream()\n+                .peek((k, v) -> semaphore.release());\n+\n+        final Properties streamsConfiguration1 = streamsConfiguration();\n+        streamsConfiguration1.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, numStreamThreads);\n+\n+        final Properties streamsConfiguration2 = streamsConfiguration();\n+        streamsConfiguration2.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, numStreamThreads);\n+\n+        final KafkaStreams kafkaStreams1 = createKafkaStreams(builder, streamsConfiguration1);\n+        final KafkaStreams kafkaStreams2 = createKafkaStreams(builder, streamsConfiguration2);\n+        final List<KafkaStreams> kafkaStreamsList = Arrays.asList(kafkaStreams1, kafkaStreams2);\n+\n+        startApplicationAndWaitUntilRunning(kafkaStreamsList, Duration.ofSeconds(60));\n+\n+        assertTrue(numStreamThreads > 1);\n+        assertTrue(kafkaStreams1.localThreadsMetadata().size() > 1);\n+        assertTrue(kafkaStreams2.localThreadsMetadata().size() > 1);\n+\n+        produceValueRange(key, 0, batch1NumMessages);\n+\n+        // Assert that all messages in the first batch were processed in a timely manner\n+        assertThat(semaphore.tryAcquire(batch1NumMessages, 60, TimeUnit.SECONDS), is(equalTo(true)));\n+        final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, new IntegerSerializer());\n+\n+        //key belongs to this partition\n+        final int keyPartition = keyQueryMetadata.getPartition();\n+\n+        //key doesn't belongs to this partition\n+        final int keyDontBelongPartition = (keyPartition == 0) ? 1 : 0;\n+        final boolean kafkaStreams1IsActive = (keyQueryMetadata.getActiveHost().port() % 2) == 1;\n+\n+        StoreQueryParameters<ReadOnlyKeyValueStore<Integer, Integer>> storeQueryParam =\n+                StoreQueryParameters.<ReadOnlyKeyValueStore<Integer, Integer>>fromNameAndType(TABLE_NAME, QueryableStoreTypes.keyValueStore())\n+                        .withPartition(keyPartition);\n+        ReadOnlyKeyValueStore<Integer, Integer> store1 = null;\n+        ReadOnlyKeyValueStore<Integer, Integer> store2 = null;\n+        if (kafkaStreams1IsActive) {\n+            store1 = IntegrationTestUtils.getStore(kafkaStreams1, storeQueryParam);\n+        } else {\n+            store2 = IntegrationTestUtils.getStore(kafkaStreams2, storeQueryParam);\n+        }\n+\n+        if (kafkaStreams1IsActive) {\n+            assertThat(store1, is(notNullValue()));\n+            assertThat(store2, is(nullValue()));\n+        } else {\n+            assertThat(store2, is(notNullValue()));\n+            assertThat(store1, is(nullValue()));\n+        }\n+\n+        // Assert that only active for a specific requested partition serves key if stale stores and not enabled", "originalCommit": "3fd8aff27c7370a851469e3ee9f2990a124172fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU2Nzc4NA==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r429567784", "bodyText": "correct, changed test to check both store types", "author": "dima5rr", "createdAt": "2020-05-23T18:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUxNTEwNg=="}], "type": "inlineReview"}, {"oid": "c8e956159426a1c0ede7122a3c87ab489d7487b0", "url": "https://github.com/apache/kafka/commit/c8e956159426a1c0ede7122a3c87ab489d7487b0", "message": "[TESTS] add dedicated test for multiple stream threads", "committedDate": "2020-05-23T18:25:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM2MDM1Nw==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r431360357", "bodyText": "We should extend QueryableStoreProviderTest for this case -- throwing this exception moves from StreamThreadStateStoreProvider to here and we should not just remove the test from StreamThreadStateStoreProviderTest but add a new one to QueryableStoreProviderTest, too.", "author": "mjsax", "createdAt": "2020-05-27T18:37:08Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/QueryableStoreProvider.java", "diffHunk": "@@ -58,9 +58,21 @@ public QueryableStoreProvider(final List<StreamThreadStateStoreProvider> storePr\n         }\n         final List<T> allStores = new ArrayList<>();\n         for (final StreamThreadStateStoreProvider storeProvider : storeProviders) {\n-            allStores.addAll(storeProvider.stores(storeQueryParameters));\n+            final List<T> stores = storeProvider.stores(storeQueryParameters);\n+            if (stores != null && !stores.isEmpty()) {\n+                allStores.addAll(stores);\n+                if (storeQueryParameters.partition() != null) {\n+                    break;\n+                }\n+            }\n         }\n         if (allStores.isEmpty()) {\n+            if (storeQueryParameters.partition() != null) {", "originalCommit": "c8e956159426a1c0ede7122a3c87ab489d7487b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4NzE3OQ==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r431687179", "bodyText": "I extended StateStoreProviderStub functionality to add store by partition with default partition 0, + relevant tests in QueryableStoreProviderTest", "author": "dima5rr", "createdAt": "2020-05-28T09:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM2MDM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM2MTQ4NQ==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r431361485", "bodyText": "numStreamThreads is a final variable -> assertion can be removed", "author": "mjsax", "createdAt": "2020-05-27T18:39:17Z", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -296,6 +289,75 @@ public void shouldQuerySpecificStalePartitionStores() throws Exception {\n         assertThat(store4.get(key), is(nullValue()));\n     }\n \n+    @Test\n+    public void shouldQuerySpecificStalePartitionStoresMultiStreamThreads() throws Exception {\n+        final int batch1NumMessages = 100;\n+        final int key = 1;\n+        final Semaphore semaphore = new Semaphore(0);\n+        final int numStreamThreads = 2;\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder.table(INPUT_TOPIC_NAME, Consumed.with(Serdes.Integer(), Serdes.Integer()),\n+                Materialized.<Integer, Integer, KeyValueStore<Bytes, byte[]>>as(TABLE_NAME)\n+                        .withCachingDisabled())\n+                .toStream()\n+                .peek((k, v) -> semaphore.release());\n+\n+        final Properties streamsConfiguration1 = streamsConfiguration();\n+        streamsConfiguration1.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, numStreamThreads);\n+\n+        final Properties streamsConfiguration2 = streamsConfiguration();\n+        streamsConfiguration2.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, numStreamThreads);\n+\n+        final KafkaStreams kafkaStreams1 = createKafkaStreams(builder, streamsConfiguration1);\n+        final KafkaStreams kafkaStreams2 = createKafkaStreams(builder, streamsConfiguration2);\n+        final List<KafkaStreams> kafkaStreamsList = Arrays.asList(kafkaStreams1, kafkaStreams2);\n+\n+        startApplicationAndWaitUntilRunning(kafkaStreamsList, Duration.ofSeconds(60));\n+\n+        assertTrue(numStreamThreads > 1);", "originalCommit": "c8e956159426a1c0ede7122a3c87ab489d7487b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ad2b7fc8d767c669ed3c1081429c885206ec9a21", "url": "https://github.com/apache/kafka/commit/ad2b7fc8d767c669ed3c1081429c885206ec9a21", "message": "[TESTS] provide StateStoreProviderStub to query partitioned store", "committedDate": "2020-05-28T08:56:29Z", "type": "commit"}, {"oid": "74dd371196c105603d049d4cc5d4a42f8796dca5", "url": "https://github.com/apache/kafka/commit/74dd371196c105603d049d4cc5d4a42f8796dca5", "message": "[TESTS] provide StateStoreProviderStub to query partitioned store", "committedDate": "2020-05-28T09:04:06Z", "type": "commit"}, {"oid": "56b0121ea5b7c09248011c40ca8632bdd0b52466", "url": "https://github.com/apache/kafka/commit/56b0121ea5b7c09248011c40ca8632bdd0b52466", "message": "[TESTS] provide StateStoreProviderStub to query partitioned store", "committedDate": "2020-05-28T09:05:48Z", "type": "commit"}, {"oid": "2c9e1e69b66e441815c0a0a57777455f2aa8f397", "url": "https://github.com/apache/kafka/commit/2c9e1e69b66e441815c0a0a57777455f2aa8f397", "message": "[TESTS] query with partition test", "committedDate": "2020-05-28T09:10:53Z", "type": "commit"}, {"oid": "db0f2388d4629d1e687b0c09d162577d5ed2acff", "url": "https://github.com/apache/kafka/commit/db0f2388d4629d1e687b0c09d162577d5ed2acff", "message": "[TESTS] find all stores with the same name", "committedDate": "2020-05-28T12:27:00Z", "type": "commit"}, {"oid": "4f251f7cbaa5db21450a3c93556cd98d93c1ef6e", "url": "https://github.com/apache/kafka/commit/4f251f7cbaa5db21450a3c93556cd98d93c1ef6e", "message": "[TESTS] find all stores with the same name", "committedDate": "2020-05-28T12:28:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0NDYxMA==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r432144610", "bodyText": "Thinking about this one more, stores can never be null? Can we remove this check?", "author": "mjsax", "createdAt": "2020-05-28T21:51:46Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/QueryableStoreProvider.java", "diffHunk": "@@ -58,9 +58,21 @@ public QueryableStoreProvider(final List<StreamThreadStateStoreProvider> storePr\n         }\n         final List<T> allStores = new ArrayList<>();\n         for (final StreamThreadStateStoreProvider storeProvider : storeProviders) {\n-            allStores.addAll(storeProvider.stores(storeQueryParameters));\n+            final List<T> stores = storeProvider.stores(storeQueryParameters);\n+            if (stores != null && !stores.isEmpty()) {", "originalCommit": "4f251f7cbaa5db21450a3c93556cd98d93c1ef6e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0NTEyMQ==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r432145121", "bodyText": "As above: stores should never be null, and thus we don't need this change? Also the check for isEmpty does give us much, we can still call addAll even it stores is empty?", "author": "mjsax", "createdAt": "2020-05-28T21:53:02Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/WrappingStoreProvider.java", "diffHunk": "@@ -48,7 +48,9 @@ public void setStoreQueryParameters(final StoreQueryParameters storeQueryParamet\n         final List<T> allStores = new ArrayList<>();\n         for (final StreamThreadStateStoreProvider provider : storeProviders) {\n             final List<T> stores = provider.stores(storeQueryParameters);\n-            allStores.addAll(stores);\n+            if (stores != null && !stores.isEmpty()) {\n+                allStores.addAll(stores);\n+            }", "originalCommit": "4f251f7cbaa5db21450a3c93556cd98d93c1ef6e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0NjUwNQ==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r432146505", "bodyText": "It might be better to test if the right store is returned instead of just checking for not-null? For this, in before() we need to get a reference on the store we pass into addStore()?", "author": "mjsax", "createdAt": "2020-05-28T21:56:12Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/QueryableStoreProviderTest.java", "diffHunk": "@@ -88,5 +91,23 @@ public void shouldFindGlobalStores() {\n         assertNotNull(storeProvider.getStore(StoreQueryParameters.fromNameAndType(\"global\", QueryableStoreTypes.keyValueStore())));\n     }\n \n+    @Test\n+    public void shouldReturnKVStoreWithPartitionWhenItExists() {\n+        assertNotNull(storeProvider.getStore(StoreQueryParameters.fromNameAndType(keyValueStore, QueryableStoreTypes.keyValueStore()).withPartition(numStateStorePartitions - 1)));", "originalCommit": "4f251f7cbaa5db21450a3c93556cd98d93c1ef6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM5MzQ1OQ==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r432393459", "bodyText": "I think how to validate returned store reference, QueryableStoreProvider always wraps it in CompositeReadOnlyKeyValueStore?", "author": "dima5rr", "createdAt": "2020-05-29T10:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0NjUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MTIyOQ==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r432671229", "bodyText": "Hmmm... Good point. Let leave it as-is. It's also covered in integration tests that the right store is returned.", "author": "mjsax", "createdAt": "2020-05-29T18:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0NjUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0ODc1Ng==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r432148756", "bodyText": "Can we split this as follows:\nfinal StoreQueryParameters parameters = (StoreQueryParameters.fromNameAndType(keyValueStore, QueryableStoreTypes.keyValueStore()).withPartition(numStateStorePartitions + 1);\n\nfinal InvalidStateStoreException exception = asserThrows(\n  InvalidStateStoreException.class,\n  () -> storeProvider.getStore(parameters)\n);\nassertThat(exception.message(), equalTo(\"...\"));\n\nAnd remove the (excpected = ...) annotation.\n(1) We should always limit the code that might throw the exception (eg, if withPartition would throw an InvalidStateStoreException the test should fail, but would pass in it's current setup) (2) We should always verify the exception cause -- getStore() could throw an InvalidStateStoreException or multiple reasons and we should make sure it's throwing for the reason under test.\nSame below for the windowed case", "author": "mjsax", "createdAt": "2020-05-28T22:01:23Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/QueryableStoreProviderTest.java", "diffHunk": "@@ -88,5 +91,23 @@ public void shouldFindGlobalStores() {\n         assertNotNull(storeProvider.getStore(StoreQueryParameters.fromNameAndType(\"global\", QueryableStoreTypes.keyValueStore())));\n     }\n \n+    @Test\n+    public void shouldReturnKVStoreWithPartitionWhenItExists() {\n+        assertNotNull(storeProvider.getStore(StoreQueryParameters.fromNameAndType(keyValueStore, QueryableStoreTypes.keyValueStore()).withPartition(numStateStorePartitions - 1)));\n+    }\n+\n+    @Test(expected = InvalidStateStoreException.class)\n+    public void shouldThrowExceptionWhenKVStoreWithPartitionDoesntExists() {\n+        storeProvider.getStore(StoreQueryParameters.fromNameAndType(keyValueStore, QueryableStoreTypes.keyValueStore()).withPartition(numStateStorePartitions + 1));", "originalCommit": "4f251f7cbaa5db21450a3c93556cd98d93c1ef6e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7836004c631beb69184d2601a974645312b71312", "url": "https://github.com/apache/kafka/commit/7836004c631beb69184d2601a974645312b71312", "message": "[TESTS] always verify the exception cause", "committedDate": "2020-05-29T10:13:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4MzYzMg==", "url": "https://github.com/apache/kafka/pull/8706#discussion_r432783632", "bodyText": "nit: space", "author": "abbccdda", "createdAt": "2020-05-29T23:41:21Z", "path": "streams/src/test/java/org/apache/kafka/test/StateStoreProviderStub.java", "diffHunk": "@@ -22,16 +22,22 @@\n import org.apache.kafka.streams.state.QueryableStoreType;\n import org.apache.kafka.streams.state.internals.StreamThreadStateStoreProvider;\n \n+import java.util.AbstractMap.SimpleEntry;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n \n public class StateStoreProviderStub extends StreamThreadStateStoreProvider {\n \n-    private final Map<String, StateStore> stores = new HashMap<>();\n+    //<store name : partition> -> state store", "originalCommit": "7836004c631beb69184d2601a974645312b71312", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}