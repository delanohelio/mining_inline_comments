{"pr_number": 9137, "pr_title": "KAFKA-9929: Support reverse iterator on KeyValueStore", "pr_createdAt": "2020-08-07T16:20:51Z", "pr_url": "https://github.com/apache/kafka/pull/9137", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3MTU4OQ==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468771589", "bodyText": "Seems a bit tricky to say that to is the variable where iteration starts from \ud83d\ude09  But I can see it both ways, so being clear in the javadocs is good enough for me", "author": "ableegoldman", "createdAt": "2020-08-11T18:12:55Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/ReadOnlyKeyValueStore.java", "diffHunk": "@@ -38,35 +38,68 @@\n      *\n      * @param key The key to fetch\n      * @return The value or null if no value is found.\n-     * @throws NullPointerException If null is used for key.\n+     * @throws NullPointerException       If null is used for key.\n      * @throws InvalidStateStoreException if the store is not initialized\n      */\n     V get(K key);\n \n     /**\n      * Get an iterator over a given range of keys. This iterator must be closed after use.\n      * The returned iterator must be safe from {@link java.util.ConcurrentModificationException}s\n-     * and must not return null values. No ordering guarantees are provided.\n-     * @param from The first key that could be in the range\n-     * @param to The last key that could be in the range\n-     * @return The iterator for this range.\n-     * @throws NullPointerException If null is used for from or to.\n+     * and must not return null values.\n+     * Order is not guaranteed as bytes lexicographical ordering might not represent key order.\n+     *\n+     * @param from The first key that could be in the range, where iteration starts from.\n+     * @param to   The last key that could be in the range, where iteration ends.\n+     * @return The iterator for this range, from smallest to largest bytes.\n+     * @throws NullPointerException       If null is used for from or to.\n      * @throws InvalidStateStoreException if the store is not initialized\n      */\n     KeyValueIterator<K, V> range(K from, K to);\n \n+    /**\n+     * Get a reverse iterator over a given range of keys. This iterator must be closed after use.\n+     * The returned iterator must be safe from {@link java.util.ConcurrentModificationException}s\n+     * and must not return null values.\n+     * Order is not guaranteed as bytes lexicographical ordering might not represent key order.\n+     *\n+     * @param from The first key that could be in the range, where iteration ends.\n+     * @param to   The last key that could be in the range, where iteration starts from.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MTAxMw==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468781013", "bodyText": "Should be private", "author": "ableegoldman", "createdAt": "2020-08-11T18:29:54Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemoryKeyValueStore.java", "diffHunk": "@@ -110,7 +111,15 @@ public void putAll(final List<KeyValue<Bytes, byte[]>> entries) {\n \n     @Override\n     public synchronized KeyValueIterator<Bytes, byte[]> range(final Bytes from, final Bytes to) {\n+        return range(from, to, false);\n+    }\n+\n+    @Override\n+    public KeyValueIterator<Bytes, byte[]> reverseRange(final Bytes from, final Bytes to) {\n+        return range(from, to, true);\n+    }\n \n+    KeyValueIterator<Bytes, byte[]> range(final Bytes from, final Bytes to, final boolean reverse) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MTgyNg==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468781826", "bodyText": "nit: Use braces & separate lines", "author": "ableegoldman", "createdAt": "2020-08-11T18:31:29Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemoryKeyValueStore.java", "diffHunk": "@@ -150,8 +166,9 @@ public void close() {\n     private class InMemoryKeyValueIterator implements KeyValueIterator<Bytes, byte[]> {\n         private final Iterator<Bytes> iter;\n \n-        private InMemoryKeyValueIterator(final Set<Bytes> keySet) {\n-            this.iter = new TreeSet<>(keySet).iterator();\n+        private InMemoryKeyValueIterator(final Set<Bytes> keySet, final boolean reverse) {\n+            if (reverse) this.iter = new TreeSet<>(keySet).descendingIterator();\n+            else this.iter = new TreeSet<>(keySet).iterator();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMTIwMA==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468831200", "bodyText": "nit: braces + separate lines", "author": "ableegoldman", "createdAt": "2020-08-11T20:00:40Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/NamedCache.java", "diffHunk": "@@ -281,15 +281,24 @@ public boolean isEmpty() {\n     }\n \n     synchronized Iterator<Bytes> keyRange(final Bytes from, final Bytes to) {\n-        return keySetIterator(cache.navigableKeySet().subSet(from, true, to, true));\n+        return keySetIterator(cache.navigableKeySet().subSet(from, true, to, true), false);\n     }\n \n-    private Iterator<Bytes> keySetIterator(final Set<Bytes> keySet) {\n-        return new TreeSet<>(keySet).iterator();\n+    synchronized Iterator<Bytes> reverseKeyRange(final Bytes from, final Bytes to) {\n+        return keySetIterator(cache.navigableKeySet().subSet(from, true, to, true), true);\n+    }\n+\n+    private Iterator<Bytes> keySetIterator(final Set<Bytes> keySet, final boolean reverse) {\n+        if (reverse) return new TreeSet<>(keySet).descendingIterator();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MTc1Nw==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468841757", "bodyText": "nit: RawToKey --> RawLastKey", "author": "ableegoldman", "createdAt": "2020-08-11T20:21:59Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBRangeIterator.java", "diffHunk": "@@ -29,32 +29,41 @@\n     // comparator to be pluggable, and the default is lexicographic, so it's\n     // safe to just force lexicographic comparator here for now.\n     private final Comparator<byte[]> comparator = Bytes.BYTES_LEXICO_COMPARATOR;\n-    private final byte[] rawToKey;\n+    private final byte[] rawLastKey;\n+    private final boolean reverse;\n \n     RocksDBRangeIterator(final String storeName,\n                          final RocksIterator iter,\n                          final Set<KeyValueIterator<Bytes, byte[]>> openIterators,\n                          final Bytes from,\n-                         final Bytes to) {\n-        super(storeName, iter, openIterators);\n-        iter.seek(from.get());\n-        rawToKey = to.get();\n-        if (rawToKey == null) {\n+                         final Bytes to,\n+                         final boolean reverse) {\n+        super(storeName, iter, openIterators, reverse);\n+        this.reverse = reverse;\n+        if (reverse) {\n+            iter.seekForPrev(to.get());\n+            rawLastKey = from.get();\n+        } else {\n+            iter.seek(from.get());\n+            rawLastKey = to.get();\n+        }\n+        if (rawLastKey == null) {\n             throw new NullPointerException(\"RocksDBRangeIterator: RawToKey is null for key \" + to);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MjE5OQ==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468842199", "bodyText": "Also it should be from for the reverse case, right?", "author": "ableegoldman", "createdAt": "2020-08-11T20:22:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MTc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTIyNTM2OA==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r469225368", "bodyText": "right. I've moved this into each condition to set a correct exception message.", "author": "jeqo", "createdAt": "2020-08-12T12:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MTc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MjQ1OQ==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468842459", "bodyText": "nit: braces & separate lines", "author": "ableegoldman", "createdAt": "2020-08-11T20:23:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBRangeIterator.java", "diffHunk": "@@ -29,32 +29,41 @@\n     // comparator to be pluggable, and the default is lexicographic, so it's\n     // safe to just force lexicographic comparator here for now.\n     private final Comparator<byte[]> comparator = Bytes.BYTES_LEXICO_COMPARATOR;\n-    private final byte[] rawToKey;\n+    private final byte[] rawLastKey;\n+    private final boolean reverse;\n \n     RocksDBRangeIterator(final String storeName,\n                          final RocksIterator iter,\n                          final Set<KeyValueIterator<Bytes, byte[]>> openIterators,\n                          final Bytes from,\n-                         final Bytes to) {\n-        super(storeName, iter, openIterators);\n-        iter.seek(from.get());\n-        rawToKey = to.get();\n-        if (rawToKey == null) {\n+                         final Bytes to,\n+                         final boolean reverse) {\n+        super(storeName, iter, openIterators, reverse);\n+        this.reverse = reverse;\n+        if (reverse) {\n+            iter.seekForPrev(to.get());\n+            rawLastKey = from.get();\n+        } else {\n+            iter.seek(from.get());\n+            rawLastKey = to.get();\n+        }\n+        if (rawLastKey == null) {\n             throw new NullPointerException(\"RocksDBRangeIterator: RawToKey is null for key \" + to);\n         }\n     }\n \n     @Override\n     public KeyValue<Bytes, byte[]> makeNext() {\n         final KeyValue<Bytes, byte[]> next = super.makeNext();\n-\n         if (next == null) {\n             return allDone();\n         } else {\n-            if (comparator.compare(next.key.get(), rawToKey) <= 0) {\n-                return next;\n+            if (!reverse) {\n+                if (comparator.compare(next.key.get(), rawLastKey) <= 0) return next;\n+                else return allDone();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MzE3OA==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468843178", "bodyText": "braces & separate lines", "author": "ableegoldman", "createdAt": "2020-08-11T20:24:41Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBTimestampedStore.java", "diffHunk": "@@ -193,22 +193,26 @@ public void prepareBatch(final List<KeyValue<Bytes, byte[]>> entries,\n \n         @Override\n         public KeyValueIterator<Bytes, byte[]> range(final Bytes from,\n-                                                     final Bytes to) {\n+                                                     final Bytes to,\n+                                                     final boolean reverse) {\n             return new RocksDBDualCFRangeIterator(\n                 name,\n                 db.newIterator(newColumnFamily),\n                 db.newIterator(oldColumnFamily),\n                 from,\n-                to);\n+                to,\n+                reverse);\n         }\n \n         @Override\n-        public KeyValueIterator<Bytes, byte[]> all() {\n+        public KeyValueIterator<Bytes, byte[]> all(final boolean reverse) {\n             final RocksIterator innerIterWithTimestamp = db.newIterator(newColumnFamily);\n-            innerIterWithTimestamp.seekToFirst();\n+            if (reverse) innerIterWithTimestamp.seekToLast();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MzQ2NQ==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468843465", "bodyText": "separate lines \ud83d\ude42", "author": "ableegoldman", "createdAt": "2020-08-11T20:25:18Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDbIterator.java", "diffHunk": "@@ -58,7 +61,8 @@ public synchronized boolean hasNext() {\n             return allDone();\n         } else {\n             next = getKeyValue();\n-            iter.next();\n+            if (reverse) iter.prev();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MzczNw==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468843737", "bodyText": "braces & separate lines here and below", "author": "ableegoldman", "createdAt": "2020-08-11T20:25:49Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBTimestampedStore.java", "diffHunk": "@@ -306,26 +313,29 @@ public synchronized boolean hasNext() {\n                 } else {\n                     next = KeyValue.pair(new Bytes(nextWithTimestamp), iterWithTimestamp.value());\n                     nextWithTimestamp = null;\n-                    iterWithTimestamp.next();\n+                    if (reverse) iterWithTimestamp.prev();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0NzQ3Nw==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468847477", "bodyText": "Can we add tests for some other invalid range cases? For example with both bounds positive but from > to", "author": "ableegoldman", "createdAt": "2020-08-11T20:31:45Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractKeyValueStoreTest.java", "diffHunk": "@@ -422,6 +503,21 @@ public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n                     \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n             );\n         }\n+    }\n+\n+    @Test\n+    public void shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMxNDkzOA==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r469314938", "bodyText": "ack. added.", "author": "jeqo", "createdAt": "2020-08-12T14:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0NzQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0ODMwNQ==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468848305", "bodyText": "Can we add some tests that verify the actual contents + order of the reverse range?", "author": "ableegoldman", "createdAt": "2020-08-11T20:33:24Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingKeyValueStoreTest.java", "diffHunk": "@@ -294,13 +305,27 @@ public void shouldIterateOverRange() {\n         assertEquals(items, results.size());\n     }\n \n+    @Test\n+    public void shouldReverseIterateOverRange() {\n+        final int items = addItemsToCache();\n+        final KeyValueIterator<Bytes, byte[]> range =\n+            store.reverseRange(bytesKey(String.valueOf(0)), bytesKey(String.valueOf(items)));\n+        final List<Bytes> results = new ArrayList<>();\n+        while (range.hasNext()) {\n+            results.add(range.next().key);\n+        }\n+        assertEquals(items, results.size());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMxNTMwMA==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r469315300", "bodyText": "ack. added.", "author": "jeqo", "createdAt": "2020-08-12T14:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0ODMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0OTE0NQ==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468849145", "bodyText": "Use assertThrows -- we've been (slowly) migrating away from @Test(expected) in the Streams tests", "author": "ableegoldman", "createdAt": "2020-08-11T20:35:15Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingKeyValueStoreTest.java", "diffHunk": "@@ -339,12 +366,24 @@ public void shouldThrowIfTryingToDoRangeQueryOnClosedCachingStore() {\n         store.range(bytesKey(\"a\"), bytesKey(\"b\"));\n     }\n \n+    @Test(expected = InvalidStateStoreException.class)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMxNTgyOA==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r469315828", "bodyText": "migrated the whole class. will apply this to the other PRs.", "author": "jeqo", "createdAt": "2020-08-12T14:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0OTE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0OTQ1Mw==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468849453", "bodyText": "use assertThrows here as well", "author": "ableegoldman", "createdAt": "2020-08-11T20:35:58Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CompositeReadOnlyKeyValueStoreTest.java", "diffHunk": "@@ -150,6 +161,17 @@ public void shouldThrowUnsupportedOperationExceptionWhileRemove() {\n         } catch (final UnsupportedOperationException e) { }\n     }\n \n+    @Test\n+    public void shouldThrowUnsupportedOperationExceptionWhileReverseRange() {\n+        stubOneUnderlying.put(\"a\", \"1\");\n+        stubOneUnderlying.put(\"b\", \"1\");\n+        final KeyValueIterator<String, String> keyValueIterator = theStore.reverseRange(\"a\", \"b\");\n+        try {\n+            keyValueIterator.remove();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1MjI0NQ==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468852245", "bodyText": "I think the best we can do is just make sure that order is correct within a store. ie if a, m are all in stubOneUnderling then make sure the reverse range returns m before a.\nI also think it would be fine to just make sure all the expected values are returned without checking the order, since there are other tests to verify that the order within a store is correct", "author": "ableegoldman", "createdAt": "2020-08-11T20:41:35Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CompositeReadOnlyKeyValueStoreTest.java", "diffHunk": "@@ -199,11 +236,44 @@ public void shouldSupportRangeAcrossMultipleKVStores() {\n         cache.put(\"x\", \"x\");\n \n         final List<KeyValue<String, String>> results = toList(theStore.range(\"a\", \"e\"));\n+        assertArrayEquals(\n+            asList(\n+                new KeyValue<>(\"a\", \"a\"),\n+                new KeyValue<>(\"b\", \"b\"),\n+                new KeyValue<>(\"c\", \"c\"),\n+                new KeyValue<>(\"d\", \"d\")\n+            ).toArray(),\n+            results.toArray());\n+    }\n+\n+    @Test\n+    public void shouldSupportReverseRangeAcrossMultipleKVStores() {\n+        final KeyValueStore<String, String> cache = newStoreInstance();\n+        stubProviderTwo.addStore(storeName, cache);\n+\n+        stubOneUnderlying.put(\"a\", \"a\");\n+        stubOneUnderlying.put(\"b\", \"b\");\n+        stubOneUnderlying.put(\"z\", \"z\");\n+\n+        cache.put(\"c\", \"c\");\n+        cache.put(\"d\", \"d\");\n+        cache.put(\"x\", \"x\");\n+\n+        final List<KeyValue<String, String>> results = toList(theStore.reverseRange(\"a\", \"e\"));\n         assertTrue(results.contains(new KeyValue<>(\"a\", \"a\")));\n         assertTrue(results.contains(new KeyValue<>(\"b\", \"b\")));\n         assertTrue(results.contains(new KeyValue<>(\"c\", \"c\")));\n         assertTrue(results.contains(new KeyValue<>(\"d\", \"d\")));\n         assertEquals(4, results.size());\n+        //FIXME: order does not hold between stores, how to validate order here?", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkwNjM2Ng==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r469906366", "bodyText": "ack. make sense.", "author": "jeqo", "createdAt": "2020-08-13T12:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1MjI0NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMxMTA2Mg==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470311062", "bodyText": "This class is still unused so maybe we should just take it out. Someone's working on a prefix seek KIP at the moment so it'll be replaced soon anyway", "author": "ableegoldman", "createdAt": "2020-08-13T23:56:52Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBPrefixIterator.java", "diffHunk": "@@ -29,7 +29,7 @@\n                           final RocksIterator newIterator,\n                           final Set<KeyValueIterator<Bytes, byte[]>> openIterators,\n                           final Bytes prefix) {\n-        super(name, newIterator, openIterators);\n+        super(name, newIterator, openIterators, false);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzODI0NA==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470338244", "bodyText": "We need to branch on reverse here too, right?", "author": "ableegoldman", "createdAt": "2020-08-14T00:42:57Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBTimestampedStore.java", "diffHunk": "@@ -374,7 +412,7 @@ public Bytes peekNextKey() {\n             if (next == null) {\n                 return allDone();\n             } else {\n-                if (comparator.compare(next.key.get(), upperBoundKey) <= 0) {\n+                if (comparator.compare(next.key.get(), lastKey) <= 0) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM0NTUxMw==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470345513", "bodyText": "Kind of unrelated, but WDYT about renaming RocksDBDualCFIterator to RocksDBDualCFAllIterator or something on the side? I feel like these iterators could be cleaned up a bit in general to be more understandable -- for example, it's weird that we do the iterator#seek-ing in the actual all() method but for range queries we do the seeking inside the iterator constructor.\nJust thinking out loud though, we can do some followup refactoring once this is merged", "author": "ableegoldman", "createdAt": "2020-08-14T00:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzODI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ0OTgwNw==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r471449807", "bodyText": "Agree. I will continue the current approoach and create an issue to follow up this.", "author": "jeqo", "createdAt": "2020-08-17T12:39:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzODI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1MTQ5OA==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r471451498", "bodyText": "https://issues.apache.org/jira/browse/KAFKA-10409", "author": "jeqo", "createdAt": "2020-08-17T12:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzODI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM1MDMwOQ==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470350309", "bodyText": "If compare(noTimestamp, withTimestamp) <= 0 then withTimestamp >= noTimestamp, so for the reverse case we would actually want to return withTimestamp next here (and vice versa in the else block)", "author": "ableegoldman", "createdAt": "2020-08-14T01:00:53Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBTimestampedStore.java", "diffHunk": "@@ -306,26 +319,41 @@ public synchronized boolean hasNext() {\n                 } else {\n                     next = KeyValue.pair(new Bytes(nextWithTimestamp), iterWithTimestamp.value());\n                     nextWithTimestamp = null;\n-                    iterWithTimestamp.next();\n+                    if (reverse) {\n+                        iterWithTimestamp.prev();\n+                    } else {\n+                        iterWithTimestamp.next();\n+                    }\n                 }\n             } else {\n                 if (nextWithTimestamp == null) {\n                     next = KeyValue.pair(new Bytes(nextNoTimestamp), convertToTimestampedFormat(iterNoTimestamp.value()));\n                     nextNoTimestamp = null;\n-                    iterNoTimestamp.next();\n+                    if (reverse) {\n+                        iterNoTimestamp.prev();\n+                    } else {\n+                        iterNoTimestamp.next();\n+                    }\n                 } else {\n                     if (comparator.compare(nextNoTimestamp, nextWithTimestamp) <= 0) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM1ODM4NA==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470358384", "bodyText": "Instead of storing and checking the reverse flag on every iteration, can we define something like\njava.util.function.Consumer<RocksIterator> advanceIterator = reverse ? RocksIterator::prev : RocksIterator::next;\n\nso then we can just blindly call advanceIterator.accept(iter)", "author": "ableegoldman", "createdAt": "2020-08-14T01:12:40Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDbIterator.java", "diffHunk": "@@ -58,7 +61,11 @@ public synchronized boolean hasNext() {\n             return allDone();\n         } else {\n             next = getKeyValue();\n-            iter.next();\n+            if (reverse) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM1OTQ4Nw==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470359487", "bodyText": "Awesome, thank you for cleaning up the whole class \ud83d\ude4f", "author": "ableegoldman", "createdAt": "2020-08-14T01:17:32Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingKeyValueStoreTest.java", "diffHunk": "@@ -321,67 +368,94 @@ public void shouldClearNamespaceCacheOnClose() {\n         assertEquals(0, cache.size());\n     }\n \n-    @Test(expected = InvalidStateStoreException.class)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM2MTcyNg==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470361726", "bodyText": "I think we should add some tests to RocksDBTimestampedStoreTest. I thought it would extend AbstractKeyValueStoreTest and thus benefit from everything you added here, but doesn't seem to be the case :/\nPersonally I found the RocksDBDualCFIterator logic a bit difficult to follow even before the reverse iteration,  so it would be nice to have some tests specifically covering reverse iterators over multi-column-family timestamped stores", "author": "ableegoldman", "createdAt": "2020-08-14T01:27:07Z", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractKeyValueStoreTest.java", "diffHunk": "@@ -188,7 +188,55 @@ public void testPutGetRange() {\n     }\n \n     @Test\n-    public void testPutGetRangeWithDefaultSerdes() {\n+    public void testPutGetReverseRange() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUzNjAzNA==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470536034", "bodyText": "Just realized that, I also thought that path was tested. Good catch!", "author": "jeqo", "createdAt": "2020-08-14T10:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM2MTcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1OTU3NA==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r471459574", "bodyText": "@ableegoldman I have extended RocksDBTimestampedStoreTest to use reverseAll and reverseRange as part of the current tests.\nUnfortunately, AbstractKeyValueStoreTest tests do not fit with the creation path of Timestamped stores as pre inserted data is required.\nWill add this to the same JIRA ticket to consider when refactoring iterators and tests.", "author": "jeqo", "createdAt": "2020-08-17T12:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM2MTcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNjc4OQ==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r471836789", "bodyText": "Ah, that makes sense I guess. Looks like the new additions to RocksDBTimestampedStoreTest cover the cross-column family code path so that's good enough for now", "author": "ableegoldman", "createdAt": "2020-08-17T23:55:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM2MTcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5NzU2NQ==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r472397565", "bodyText": "This warning seems to miss the most likely scenario, that the user just passed the arguments in the wrong order.", "author": "vvcephei", "createdAt": "2020-08-18T18:27:49Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingKeyValueStore.java", "diffHunk": "@@ -249,7 +248,23 @@ public void putAll(final List<KeyValue<Bytes, byte[]>> entries) {\n         validateStoreOpen();\n         final KeyValueIterator<Bytes, byte[]> storeIterator = wrapped().range(from, to);\n         final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator = context.cache().range(cacheName, from, to);\n-        return new MergedSortedCacheKeyValueBytesStoreIterator(cacheIterator, storeIterator);\n+        return new MergedSortedCacheKeyValueBytesStoreIterator(cacheIterator, storeIterator, false);\n+    }\n+\n+    @Override\n+    public KeyValueIterator<Bytes, byte[]> reverseRange(final Bytes from,\n+                                                        final Bytes to) {\n+        if (from.compareTo(to) > 0) {\n+            LOG.warn(\"Returning empty iterator for fetch with invalid key range: from > to. \"\n+                + \"This may be due to serdes that don't preserve ordering when lexicographically comparing the serialized bytes. \" +\n+                \"Note that the built-in numerical serdes do not follow this for negative numbers\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzMTIzNw==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r472531237", "bodyText": "Was this class unused or something?", "author": "vvcephei", "createdAt": "2020-08-18T22:35:49Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBPrefixIterator.java", "diffHunk": "@@ -1,54 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.state.internals;\n-\n-import org.apache.kafka.common.utils.Bytes;\n-import org.apache.kafka.streams.state.KeyValueIterator;\n-import org.rocksdb.RocksIterator;\n-\n-import java.util.Set;\n-\n-class RocksDBPrefixIterator extends RocksDbIterator {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2ODUxNQ==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r473068515", "bodyText": "yes, it looks like it was. Thanks for cleaning it up!", "author": "vvcephei", "createdAt": "2020-08-19T14:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzMTIzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxMzIwNA==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r474213204", "bodyText": "Yeah this was left over from the FKJ work IIRC", "author": "ableegoldman", "createdAt": "2020-08-20T19:16:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzMTIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3MTIwMA==", "url": "https://github.com/apache/kafka/pull/9137#discussion_r473071200", "bodyText": "clever!", "author": "vvcephei", "createdAt": "2020-08-19T14:26:23Z", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDbIterator.java", "diffHunk": "@@ -58,7 +62,7 @@ public synchronized boolean hasNext() {\n             return allDone();\n         } else {\n             next = getKeyValue();\n-            iter.next();\n+            advanceIterator.accept(iter);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3f7f70b1918acf456b12384d1e63ccc85394ddac", "url": "https://github.com/apache/kafka/commit/3f7f70b1918acf456b12384d1e63ccc85394ddac", "message": "key/value reverse operations", "committedDate": "2020-08-20T09:21:00Z", "type": "commit"}, {"oid": "07acb80d25bcc934904079c8d00cd7fecc3df38e", "url": "https://github.com/apache/kafka/commit/07acb80d25bcc934904079c8d00cd7fecc3df38e", "message": "refactor choose next key and value", "committedDate": "2020-08-20T09:21:01Z", "type": "commit"}, {"oid": "58f6c197be396a75c2a15dcffe6b8db07c6d483d", "url": "https://github.com/apache/kafka/commit/58f6c197be396a75c2a15dcffe6b8db07c6d483d", "message": "fix final params", "committedDate": "2020-08-20T09:21:01Z", "type": "commit"}, {"oid": "e7ddbb9c78714995c4c3c5233b82626bf7da40a1", "url": "https://github.com/apache/kafka/commit/e7ddbb9c78714995c4c3c5233b82626bf7da40a1", "message": "improve ordering docs", "committedDate": "2020-08-20T09:21:01Z", "type": "commit"}, {"oid": "39d8e6339b6b268d27b295d378be5bce3dba4f5a", "url": "https://github.com/apache/kafka/commit/39d8e6339b6b268d27b295d378be5bce3dba4f5a", "message": "fix range validator not needed", "committedDate": "2020-08-20T09:21:02Z", "type": "commit"}, {"oid": "dddfa75530ee8939273d1eb9fe551d8ac9c20598", "url": "https://github.com/apache/kafka/commit/dddfa75530ee8939273d1eb9fe551d8ac9c20598", "message": "resolve nits", "committedDate": "2020-08-20T09:21:02Z", "type": "commit"}, {"oid": "834da345e1336d9db801a3280c0a3c2869b9d4f8", "url": "https://github.com/apache/kafka/commit/834da345e1336d9db801a3280c0a3c2869b9d4f8", "message": "improve tests", "committedDate": "2020-08-20T09:21:02Z", "type": "commit"}, {"oid": "842c358d5f657996f9398c168dcfab3c88c5e557", "url": "https://github.com/apache/kafka/commit/842c358d5f657996f9398c168dcfab3c88c5e557", "message": "improve tests", "committedDate": "2020-08-20T09:21:03Z", "type": "commit"}, {"oid": "c634673602018315aebf2272273ffeacb5d93db7", "url": "https://github.com/apache/kafka/commit/c634673602018315aebf2272273ffeacb5d93db7", "message": "complete reverse paths", "committedDate": "2020-08-20T09:21:03Z", "type": "commit"}, {"oid": "a8bdfd453b62b2b1c2c464d95504083348252909", "url": "https://github.com/apache/kafka/commit/a8bdfd453b62b2b1c2c464d95504083348252909", "message": "complete kvstore implementations", "committedDate": "2020-08-20T09:21:03Z", "type": "commit"}, {"oid": "b124cb7b758941f957e23f20f87ee417a8055aea", "url": "https://github.com/apache/kafka/commit/b124cb7b758941f957e23f20f87ee417a8055aea", "message": "replace backward flag to forward flag", "committedDate": "2020-08-20T09:21:04Z", "type": "commit"}, {"oid": "b124cb7b758941f957e23f20f87ee417a8055aea", "url": "https://github.com/apache/kafka/commit/b124cb7b758941f957e23f20f87ee417a8055aea", "message": "replace backward flag to forward flag", "committedDate": "2020-08-20T09:21:04Z", "type": "forcePushed"}, {"oid": "9a0adeb57ccb7c8c9a6174010e3a3c4bcffdec08", "url": "https://github.com/apache/kafka/commit/9a0adeb57ccb7c8c9a6174010e3a3c4bcffdec08", "message": "improve range wrong order warning", "committedDate": "2020-08-20T09:28:13Z", "type": "commit"}, {"oid": "4dd41696e7d9855f77603c13b53648257981bfd0", "url": "https://github.com/apache/kafka/commit/4dd41696e7d9855f77603c13b53648257981bfd0", "message": "fix style", "committedDate": "2020-08-20T15:49:04Z", "type": "commit"}, {"oid": "38c3bb5e35a11c4e553c896b685ca141c960dbed", "url": "https://github.com/apache/kafka/commit/38c3bb5e35a11c4e553c896b685ca141c960dbed", "message": "fix concat style", "committedDate": "2020-08-20T16:39:08Z", "type": "commit"}]}