{"pr_number": 9008, "pr_title": "KAFKA-9629 Use generated protocol for Fetch API", "pr_createdAt": "2020-07-10T17:50:50Z", "pr_url": "https://github.com/apache/kafka/pull/9008", "timeline": [{"oid": "56e4156930bb8a4445cd2023e17fa84d862bb919", "url": "https://github.com/apache/kafka/commit/56e4156930bb8a4445cd2023e17fa84d862bb919", "message": "KAFKA-10265 Use the generated messages for FetchRequest and FetchResponse", "committedDate": "2020-07-10T15:51:33Z", "type": "commit"}, {"oid": "04538af26ab9f036d547f4b6f34bdffb720e8007", "url": "https://github.com/apache/kafka/commit/04538af26ab9f036d547f4b6f34bdffb720e8007", "message": "Fix compile errors and checkstyle", "committedDate": "2020-07-10T17:38:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NTU0NQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r453085545", "bodyText": "Can we revert some of these renamings? We intentionally changed them in #8802.", "author": "hachikuji", "createdAt": "2020-07-10T21:29:24Z", "path": "clients/src/main/resources/common/message/FetchRequest.json", "diffHunk": "@@ -49,41 +49,41 @@\n   \"fields\": [\n     { \"name\": \"ReplicaId\", \"type\": \"int32\", \"versions\": \"0+\",\n       \"about\": \"The broker ID of the follower, of -1 if this request is from a consumer.\" },\n-    { \"name\": \"MaxWaitMs\", \"type\": \"int32\", \"versions\": \"0+\",\n+    { \"name\": \"MaxWaitTime\", \"type\": \"int32\", \"versions\": \"0+\",", "originalCommit": "04538af26ab9f036d547f4b6f34bdffb720e8007", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4NjcyOA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r453086728", "bodyText": "nit: I guess we didn't need this?", "author": "hachikuji", "createdAt": "2020-07-10T21:32:45Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchResponse.java", "diffHunk": "@@ -366,225 +368,164 @@ public FetchResponse(Errors error,\n                          LinkedHashMap<TopicPartition, PartitionData<T>> responseData,\n                          int throttleTimeMs,\n                          int sessionId) {\n-        this.error = error;\n-        this.responseData = responseData;\n-        this.throttleTimeMs = throttleTimeMs;\n-        this.sessionId = sessionId;\n+        this.fetchResponseData = toMessage(throttleTimeMs, error, responseData.entrySet().iterator(), sessionId);\n+        this.responseDataMap = responseData;\n     }\n \n-    public static FetchResponse<MemoryRecords> parse(Struct struct) {\n-        LinkedHashMap<TopicPartition, PartitionData<MemoryRecords>> responseData = new LinkedHashMap<>();\n-        for (Object topicResponseObj : struct.getArray(RESPONSES_KEY_NAME)) {\n-            Struct topicResponse = (Struct) topicResponseObj;\n-            String topic = topicResponse.get(TOPIC_NAME);\n-            for (Object partitionResponseObj : topicResponse.getArray(PARTITIONS_KEY_NAME)) {\n-                Struct partitionResponse = (Struct) partitionResponseObj;\n-                Struct partitionResponseHeader = partitionResponse.getStruct(PARTITION_HEADER_KEY_NAME);\n-                int partition = partitionResponseHeader.get(PARTITION_ID);\n-                Errors error = Errors.forCode(partitionResponseHeader.get(ERROR_CODE));\n-                long highWatermark = partitionResponseHeader.get(HIGH_WATERMARK);\n-                long lastStableOffset = partitionResponseHeader.getOrElse(LAST_STABLE_OFFSET, INVALID_LAST_STABLE_OFFSET);\n-                long logStartOffset = partitionResponseHeader.getOrElse(LOG_START_OFFSET, INVALID_LOG_START_OFFSET);\n-                Optional<Integer> preferredReadReplica = Optional.of(\n-                    partitionResponseHeader.getOrElse(PREFERRED_READ_REPLICA, INVALID_PREFERRED_REPLICA_ID)\n-                ).filter(Predicate.isEqual(INVALID_PREFERRED_REPLICA_ID).negate());\n-\n-                BaseRecords baseRecords = partitionResponse.getRecords(RECORD_SET_KEY_NAME);\n-                if (!(baseRecords instanceof MemoryRecords))\n-                    throw new IllegalStateException(\"Unknown records type found: \" + baseRecords.getClass());\n-                MemoryRecords records = (MemoryRecords) baseRecords;\n-\n-                List<AbortedTransaction> abortedTransactions = null;\n-                if (partitionResponseHeader.hasField(ABORTED_TRANSACTIONS_KEY_NAME)) {\n-                    Object[] abortedTransactionsArray = partitionResponseHeader.getArray(ABORTED_TRANSACTIONS_KEY_NAME);\n-                    if (abortedTransactionsArray != null) {\n-                        abortedTransactions = new ArrayList<>(abortedTransactionsArray.length);\n-                        for (Object abortedTransactionObj : abortedTransactionsArray) {\n-                            Struct abortedTransactionStruct = (Struct) abortedTransactionObj;\n-                            long producerId = abortedTransactionStruct.get(PRODUCER_ID);\n-                            long firstOffset = abortedTransactionStruct.get(FIRST_OFFSET);\n-                            abortedTransactions.add(new AbortedTransaction(producerId, firstOffset));\n-                        }\n-                    }\n-                }\n-\n-                PartitionData<MemoryRecords> partitionData = new PartitionData<>(error, highWatermark, lastStableOffset,\n-                        logStartOffset, preferredReadReplica, abortedTransactions, records);\n-                responseData.put(new TopicPartition(topic, partition), partitionData);\n-            }\n-        }\n-        return new FetchResponse<>(Errors.forCode(struct.getOrElse(ERROR_CODE, (short) 0)), responseData,\n-                struct.getOrElse(THROTTLE_TIME_MS, DEFAULT_THROTTLE_TIME), struct.getOrElse(SESSION_ID, INVALID_SESSION_ID));\n+    public FetchResponse(FetchResponseData fetchResponseData) {\n+        this.fetchResponseData = fetchResponseData;\n+        this.responseDataMap = toResponseDataMap(fetchResponseData);\n     }\n \n     @Override\n     public Struct toStruct(short version) {\n-        return toStruct(version, throttleTimeMs, error, responseData.entrySet().iterator(), sessionId);\n+        return fetchResponseData.toStruct(version);\n     }\n \n     @Override\n     protected Send toSend(String dest, ResponseHeader responseHeader, short apiVersion) {\n-        Struct responseHeaderStruct = responseHeader.toStruct();\n-        Struct responseBodyStruct = toStruct(apiVersion);\n+        // Generate the Sends for the response fields and records\n+        ArrayDeque<Send> sends = new ArrayDeque<>();\n+        RecordsWriter writer = new RecordsWriter(dest, sends::add);\n+        ObjectSerializationCache cache = new ObjectSerializationCache();\n+        fetchResponseData.size(cache, apiVersion);\n+        fetchResponseData.write(writer, cache, apiVersion);\n+        writer.flush();\n+\n+        // Compute the total size of all the Sends and write it out along with the header in the first Send\n+        ResponseHeaderData responseHeaderData = responseHeader.data();\n+\n+        //Struct responseHeaderStruct = responseHeader.toStruct();", "originalCommit": "04538af26ab9f036d547f4b6f34bdffb720e8007", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA4ODA2Nw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r453088067", "bodyText": "nit: in all of the other classes, we just use the name data. Can we do the same here?", "author": "hachikuji", "createdAt": "2020-07-10T21:36:38Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchResponse.java", "diffHunk": "@@ -218,23 +220,19 @@\n             SESSION_ID,\n             new Field(RESPONSES_KEY_NAME, new ArrayOf(FETCH_RESPONSE_TOPIC_V6)));\n \n-\n-    public static Schema[] schemaVersions() {\n-        return new Schema[] {FETCH_RESPONSE_V0, FETCH_RESPONSE_V1, FETCH_RESPONSE_V2,\n-            FETCH_RESPONSE_V3, FETCH_RESPONSE_V4, FETCH_RESPONSE_V5, FETCH_RESPONSE_V6,\n-            FETCH_RESPONSE_V7, FETCH_RESPONSE_V8, FETCH_RESPONSE_V9, FETCH_RESPONSE_V10,\n-            FETCH_RESPONSE_V11};\n-    }\n-\n     public static final long INVALID_HIGHWATERMARK = -1L;\n     public static final long INVALID_LAST_STABLE_OFFSET = -1L;\n     public static final long INVALID_LOG_START_OFFSET = -1L;\n     public static final int INVALID_PREFERRED_REPLICA_ID = -1;\n \n-    private final int throttleTimeMs;\n-    private final Errors error;\n-    private final int sessionId;\n-    private final LinkedHashMap<TopicPartition, PartitionData<T>> responseData;\n+    private final FetchResponseData fetchResponseData;", "originalCommit": "04538af26ab9f036d547f4b6f34bdffb720e8007", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5NDMyMw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r453094323", "bodyText": "We can get rid of all the stuff above too, right?", "author": "hachikuji", "createdAt": "2020-07-10T21:55:21Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchResponse.java", "diffHunk": "@@ -218,23 +220,19 @@\n             SESSION_ID,\n             new Field(RESPONSES_KEY_NAME, new ArrayOf(FETCH_RESPONSE_TOPIC_V6)));", "originalCommit": "04538af26ab9f036d547f4b6f34bdffb720e8007", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5NTczMQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r453095731", "bodyText": "Probably better to save for a follow-up, but potentially we can get rid of this conversion by using FetchablePartitionResponse directly in the broker.", "author": "hachikuji", "createdAt": "2020-07-10T21:59:45Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchResponse.java", "diffHunk": "@@ -366,225 +368,164 @@ public FetchResponse(Errors error,\n                          LinkedHashMap<TopicPartition, PartitionData<T>> responseData,\n                          int throttleTimeMs,\n                          int sessionId) {\n-        this.error = error;\n-        this.responseData = responseData;\n-        this.throttleTimeMs = throttleTimeMs;\n-        this.sessionId = sessionId;\n+        this.fetchResponseData = toMessage(throttleTimeMs, error, responseData.entrySet().iterator(), sessionId);", "originalCommit": "04538af26ab9f036d547f4b6f34bdffb720e8007", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5NzUzMw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r453097533", "bodyText": "Similarly, we can get rid of all this.", "author": "hachikuji", "createdAt": "2020-07-10T22:03:02Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchRequest.java", "diffHunk": "@@ -209,30 +210,21 @@\n             FORGOTTEN_TOPIC_DATA_V7,\n             RACK_ID);", "originalCommit": "04538af26ab9f036d547f4b6f34bdffb720e8007", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMjc3Ng==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r453822776", "bodyText": "I don't think FileRecords and MemoryRecords instances can be compared directly, if that's what the question is about.", "author": "hachikuji", "createdAt": "2020-07-13T17:46:49Z", "path": "generator/src/main/java/org/apache/kafka/message/MessageDataGenerator.java", "diffHunk": "@@ -2078,6 +2103,11 @@ private void generateFieldEquals(FieldSpec field) {\n                 buffer.printf(\"if (!Arrays.equals(this.%s, other.%s)) return false;%n\",\n                     field.camelCaseName(), field.camelCaseName());\n             }\n+        } else if (field.type().isRecords()) {\n+            // TODO is this valid for record instances?", "originalCommit": "04538af26ab9f036d547f4b6f34bdffb720e8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg0OTQxOQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r453849419", "bodyText": "No I don't think they are designed to be compared. My main question was whether we can compare the same type (MemoryRecords to MemoryRecords). I think it should work in the case of Objects.equals since it first checks if the instances are the same. I don't think we have any use cases where we have equivalent instances of records that are actual separate objects.\nI have a similar question about hashCode down below. Records doesn't implement either of these, but we have to include them for all fields in the generated message classes for completeness. I think it's probably fine.\n@cmccabe, any insight here?", "author": "mumrah", "createdAt": "2020-07-13T18:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMjc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NzMyMQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456197321", "bodyText": "The hashCode of MemoryRecords takes into account the buffer position, so it's kind of useless. FileRecords doesn't even define it. We should consider defining the hashCode and equals of Records to be identity based.", "author": "ijuma", "createdAt": "2020-07-17T03:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMjc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNDAyOA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456224028", "bodyText": "@mumrah : equality for the generated messages should mean bytewise equality.  So if two FetchResponseData instances contain the same data, they should be equal, even if one is using MemoryRecords and the other is using FileRecords.  Same for hashCode, of course.\nIf it's too much trouble to change the Records class, you can just write a static utility method in MessageUtils and invoke it from the generated classes.  I expect that we won't be doing this kind of comparison except in tests, so you don't need to optimize the method too much.", "author": "cmccabe", "createdAt": "2020-07-17T05:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMjc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNTQyNw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456225427", "bodyText": "That would mean loading data from disk to compute equals and hashCode for FileRecords. That's pretty unusual for such methods.", "author": "ijuma", "createdAt": "2020-07-17T05:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMjc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzMDMxNg==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r453830316", "bodyText": "Pretty nice if this is all the manual code we need. If we wanted to go a little further, we could push toSend into the generated class as well. That will be necessary if we ever want to get of the current AbstractRequest and AbstractResponse types and replace them with the generated data classes (which was always the plan). However, I think this could be left for follow-up work.", "author": "hachikuji", "createdAt": "2020-07-13T17:59:30Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchResponse.java", "diffHunk": "@@ -366,225 +368,164 @@ public FetchResponse(Errors error,\n                          LinkedHashMap<TopicPartition, PartitionData<T>> responseData,\n                          int throttleTimeMs,\n                          int sessionId) {\n-        this.error = error;\n-        this.responseData = responseData;\n-        this.throttleTimeMs = throttleTimeMs;\n-        this.sessionId = sessionId;\n+        this.fetchResponseData = toMessage(throttleTimeMs, error, responseData.entrySet().iterator(), sessionId);\n+        this.responseDataMap = responseData;\n     }\n \n-    public static FetchResponse<MemoryRecords> parse(Struct struct) {\n-        LinkedHashMap<TopicPartition, PartitionData<MemoryRecords>> responseData = new LinkedHashMap<>();\n-        for (Object topicResponseObj : struct.getArray(RESPONSES_KEY_NAME)) {\n-            Struct topicResponse = (Struct) topicResponseObj;\n-            String topic = topicResponse.get(TOPIC_NAME);\n-            for (Object partitionResponseObj : topicResponse.getArray(PARTITIONS_KEY_NAME)) {\n-                Struct partitionResponse = (Struct) partitionResponseObj;\n-                Struct partitionResponseHeader = partitionResponse.getStruct(PARTITION_HEADER_KEY_NAME);\n-                int partition = partitionResponseHeader.get(PARTITION_ID);\n-                Errors error = Errors.forCode(partitionResponseHeader.get(ERROR_CODE));\n-                long highWatermark = partitionResponseHeader.get(HIGH_WATERMARK);\n-                long lastStableOffset = partitionResponseHeader.getOrElse(LAST_STABLE_OFFSET, INVALID_LAST_STABLE_OFFSET);\n-                long logStartOffset = partitionResponseHeader.getOrElse(LOG_START_OFFSET, INVALID_LOG_START_OFFSET);\n-                Optional<Integer> preferredReadReplica = Optional.of(\n-                    partitionResponseHeader.getOrElse(PREFERRED_READ_REPLICA, INVALID_PREFERRED_REPLICA_ID)\n-                ).filter(Predicate.isEqual(INVALID_PREFERRED_REPLICA_ID).negate());\n-\n-                BaseRecords baseRecords = partitionResponse.getRecords(RECORD_SET_KEY_NAME);\n-                if (!(baseRecords instanceof MemoryRecords))\n-                    throw new IllegalStateException(\"Unknown records type found: \" + baseRecords.getClass());\n-                MemoryRecords records = (MemoryRecords) baseRecords;\n-\n-                List<AbortedTransaction> abortedTransactions = null;\n-                if (partitionResponseHeader.hasField(ABORTED_TRANSACTIONS_KEY_NAME)) {\n-                    Object[] abortedTransactionsArray = partitionResponseHeader.getArray(ABORTED_TRANSACTIONS_KEY_NAME);\n-                    if (abortedTransactionsArray != null) {\n-                        abortedTransactions = new ArrayList<>(abortedTransactionsArray.length);\n-                        for (Object abortedTransactionObj : abortedTransactionsArray) {\n-                            Struct abortedTransactionStruct = (Struct) abortedTransactionObj;\n-                            long producerId = abortedTransactionStruct.get(PRODUCER_ID);\n-                            long firstOffset = abortedTransactionStruct.get(FIRST_OFFSET);\n-                            abortedTransactions.add(new AbortedTransaction(producerId, firstOffset));\n-                        }\n-                    }\n-                }\n-\n-                PartitionData<MemoryRecords> partitionData = new PartitionData<>(error, highWatermark, lastStableOffset,\n-                        logStartOffset, preferredReadReplica, abortedTransactions, records);\n-                responseData.put(new TopicPartition(topic, partition), partitionData);\n-            }\n-        }\n-        return new FetchResponse<>(Errors.forCode(struct.getOrElse(ERROR_CODE, (short) 0)), responseData,\n-                struct.getOrElse(THROTTLE_TIME_MS, DEFAULT_THROTTLE_TIME), struct.getOrElse(SESSION_ID, INVALID_SESSION_ID));\n+    public FetchResponse(FetchResponseData fetchResponseData) {\n+        this.fetchResponseData = fetchResponseData;\n+        this.responseDataMap = toResponseDataMap(fetchResponseData);\n     }\n \n     @Override\n     public Struct toStruct(short version) {\n-        return toStruct(version, throttleTimeMs, error, responseData.entrySet().iterator(), sessionId);\n+        return fetchResponseData.toStruct(version);\n     }\n \n     @Override\n     protected Send toSend(String dest, ResponseHeader responseHeader, short apiVersion) {\n-        Struct responseHeaderStruct = responseHeader.toStruct();\n-        Struct responseBodyStruct = toStruct(apiVersion);\n+        // Generate the Sends for the response fields and records\n+        ArrayDeque<Send> sends = new ArrayDeque<>();\n+        RecordsWriter writer = new RecordsWriter(dest, sends::add);", "originalCommit": "04538af26ab9f036d547f4b6f34bdffb720e8007", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzMjcwNw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r453832707", "bodyText": "Is it worth extending ByteBufferAccessor or not?", "author": "hachikuji", "createdAt": "2020-07-13T18:03:36Z", "path": "clients/src/main/java/org/apache/kafka/common/protocol/RecordsReader.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.protocol;\n+\n+import org.apache.kafka.common.record.BaseRecords;\n+import org.apache.kafka.common.record.MemoryRecords;\n+import org.apache.kafka.common.utils.ByteUtils;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Implementation of Readable which reads from a byte buffer and can read records as {@link MemoryRecords}\n+ *\n+ * @see org.apache.kafka.common.requests.FetchResponse\n+ */\n+public class RecordsReader implements Readable {", "originalCommit": "04538af26ab9f036d547f4b6f34bdffb720e8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg0Njc5OQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r453846799", "bodyText": "Are you suggesting a combined records reader+writer? ByteBufferAccessor is both Readable and Writable", "author": "mumrah", "createdAt": "2020-07-13T18:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzMjcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2NDU0NQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r454664545", "bodyText": "That's fair. I'm ok to leave it as is.", "author": "hachikuji", "createdAt": "2020-07-14T21:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzMjcwNw=="}], "type": "inlineReview"}, {"oid": "6094e4e201d4b15db31605143841df3545414071", "url": "https://github.com/apache/kafka/commit/6094e4e201d4b15db31605143841df3545414071", "message": "Feedback from PR", "committedDate": "2020-07-13T18:36:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NjQxOA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r453856418", "bodyText": "s/Responses/TopicResponses?", "author": "abbccdda", "createdAt": "2020-07-13T18:44:32Z", "path": "clients/src/main/resources/common/message/FetchResponse.json", "diffHunk": "@@ -47,33 +47,35 @@\n       \"about\": \"The top level response error code.\" },\n     { \"name\": \"SessionId\", \"type\": \"int32\", \"versions\": \"7+\", \"default\": \"0\", \"ignorable\": false,\n       \"about\": \"The fetch session ID, or 0 if this is not part of a fetch session.\" },\n-    { \"name\": \"Topics\", \"type\": \"[]FetchableTopicResponse\", \"versions\": \"0+\",\n+    { \"name\": \"Responses\", \"type\": \"[]FetchableTopicResponse\", \"versions\": \"0+\",", "originalCommit": "04538af26ab9f036d547f4b6f34bdffb720e8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ0NDc5NA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456444794", "bodyText": "I was trying to keep the field names aligned with what was defined in the manual schemas. So, not sure if we should change any other field names in this PR", "author": "mumrah", "createdAt": "2020-07-17T13:33:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NjQxOA=="}], "type": "inlineReview"}, {"oid": "41d03d1e52da1906b8479cbd369eb95954c09ff8", "url": "https://github.com/apache/kafka/commit/41d03d1e52da1906b8479cbd369eb95954c09ff8", "message": "Merge remote-tracking branch 'apache-github/trunk' into KAFKA-9629-fetch-api-generated-protocol", "committedDate": "2020-07-13T19:46:36Z", "type": "commit"}, {"oid": "5c98083b2d673b9acde687627fd8e3da94588195", "url": "https://github.com/apache/kafka/commit/5c98083b2d673b9acde687627fd8e3da94588195", "message": "Fix re-ordering of topic partitions", "committedDate": "2020-07-14T15:00:02Z", "type": "commit"}, {"oid": "8ca460c2ac2a0b71c5565c927ba21bce8b7749f1", "url": "https://github.com/apache/kafka/commit/8ca460c2ac2a0b71c5565c927ba21bce8b7749f1", "message": "Use generated message class for serialization in FetchRequest also", "committedDate": "2020-07-14T15:00:22Z", "type": "commit"}, {"oid": "3808a96aa8ef182c5cabebfba6debe5a303c2b5e", "url": "https://github.com/apache/kafka/commit/3808a96aa8ef182c5cabebfba6debe5a303c2b5e", "message": "Feedback from PR", "committedDate": "2020-07-14T15:01:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2NjcwOA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r454866708", "bodyText": "@mumrah Have we considered dropping the PartitionData class entirely in favour of using FetchRequestData .FetchPartition directly in the broker? The main difference is that FetchPartition does not have an Optional for the leader epoch but returns the default value (-1) instead.", "author": "dajac", "createdAt": "2020-07-15T08:02:58Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchRequest.java", "diffHunk": "@@ -273,6 +99,28 @@ public boolean equals(Object o) {\n         }\n     }\n \n+    private Map<TopicPartition, PartitionData> toPartitionDataMap(List<FetchRequestData.FetchTopic> fetchableTopics) {\n+       Map<TopicPartition, PartitionData> result = new LinkedHashMap<>();\n+        fetchableTopics.forEach(fetchTopic -> fetchTopic.partitions().forEach(fetchPartition -> {\n+            Optional<Integer> leaderEpoch = Optional.of(fetchPartition.currentLeaderEpoch())\n+                .filter(epoch -> epoch != RecordBatch.NO_PARTITION_LEADER_EPOCH);\n+            result.put(new TopicPartition(fetchTopic.topic(), fetchPartition.partition()),\n+                new PartitionData(fetchPartition.fetchOffset(), fetchPartition.logStartOffset(),\n+                    fetchPartition.partitionMaxBytes(), leaderEpoch));", "originalCommit": "3808a96aa8ef182c5cabebfba6debe5a303c2b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA5NDQ0OA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r455094448", "bodyText": "Yes, I think it's a good idea. However, it would expand the scope of this change quite a bit. I'm working on some micro benchmarks now, and if we don't have any apparent regressions then I'll save this for a follow-on PR.", "author": "mumrah", "createdAt": "2020-07-15T14:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2NjcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQwNzA0Mw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r455407043", "bodyText": "As an aside, it would be awesome to add Optional support to the generated classes. We have had so many bugs which were caused by sentinel values sneaking into unexpected places.", "author": "hachikuji", "createdAt": "2020-07-15T22:44:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2NjcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgzNTM4MA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r455835380", "bodyText": "Let's open a jira for getting rid of the toPartitionDataMap if we don't address it in this PR. It's a pretty large part of the cost here and there are only a few places we would have to deal with it. I think we should fix it sooner rather than later too.", "author": "lbradstreet", "createdAt": "2020-07-16T14:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2NjcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ0NzU1NA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456447554", "bodyText": "Yeah, Optional support would be awesome. I was actually thinking how to do it. I may give it a shot during the weekend ;)", "author": "dajac", "createdAt": "2020-07-17T13:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2NjcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkwOTUyOQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r460909529", "bodyText": "@hachikuji @mumrah @cmccabe I have put together a prototype to support java.util.Optional in the auto-generated classes. It a good draft at the moment but it is a good basis for discussions: #9085", "author": "dajac", "createdAt": "2020-07-27T13:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2NjcwOA=="}], "type": "inlineReview"}, {"oid": "efdadc5ab419806b6165cc2ce90a23e36117d007", "url": "https://github.com/apache/kafka/commit/efdadc5ab419806b6165cc2ce90a23e36117d007", "message": "Add jmh benchmarks and fix checkstyle", "committedDate": "2020-07-15T18:01:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxODEyOQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r455318129", "bodyText": "Can we please have benchmarks for both forConsumer and forReplica fetch requests?", "author": "lbradstreet", "createdAt": "2020-07-15T20:20:36Z", "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/common/FetchRequestBenchmark.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.jmh.common;\n+\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.network.Send;\n+import org.apache.kafka.common.protocol.ApiKeys;\n+import org.apache.kafka.common.requests.ByteBufferChannel;\n+import org.apache.kafka.common.requests.FetchRequest;\n+import org.apache.kafka.common.requests.RequestHeader;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+@State(Scope.Benchmark)\n+@Fork(value = 1)\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 15)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+public class FetchRequestBenchmark {\n+    @Param({\"1000\"})\n+    private int topicCount;\n+\n+    @Param({\"20\"})\n+    private int partitionCount;\n+\n+    Map<TopicPartition, FetchRequest.PartitionData> fetchData;\n+\n+    RequestHeader header;\n+\n+    FetchRequest request;\n+\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        this.fetchData = new HashMap<>();\n+        for (int topicIdx = 0; topicIdx < topicCount; topicIdx++) {\n+            for (int partitionId = 0; partitionId < partitionCount; partitionId++) {\n+                FetchRequest.PartitionData partitionData = new FetchRequest.PartitionData(\n+                    0, 0, 4096, Optional.empty());\n+                fetchData.put(new TopicPartition(String.format(\"topic-%04d\", topicIdx), partitionId), partitionData);\n+            }\n+        }\n+\n+        this.header = new RequestHeader(ApiKeys.FETCH, ApiKeys.FETCH.latestVersion(), \"jmh-benchmark\", 100);\n+        this.request = FetchRequest.Builder.forConsumer(0, 0, fetchData).build(ApiKeys.FETCH.latestVersion());", "originalCommit": "efdadc5ab419806b6165cc2ce90a23e36117d007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM0MjUzNQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r455342535", "bodyText": "Can you also try rerunning the benchmark with random topic names, e.g. UUID.randomUUID().toString() and compare it to the existing topic names? I think our hashCode implementation sucks and we are seeing a lot of collisions.", "author": "lbradstreet", "createdAt": "2020-07-15T21:03:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxODEyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUxODQzNA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r455518434", "bodyText": "Changing our hashCode method massively improves the benchmark times so I think the current benchmark results aren't really representative.\n--- a/clients/src/main/java/org/apache/kafka/common/TopicPartition.java\n+++ b/clients/src/main/java/org/apache/kafka/common/TopicPartition.java\n@@ -46,10 +46,7 @@ public final class TopicPartition implements Serializable {\n     public int hashCode() {\n         if (hash != 0)\n             return hash;\n-        final int prime = 31;\n-        int result = 1;\n-        result = prime * result + partition;\n-        result = prime * result + Objects.hashCode(topic);\n+        int result = Objects.hash(topic, partition);\n         this.hash = result;\n         return result;\n     }\n\nEdit: it looks like the main difference here is ordering by topic and then partition which seems to avoid the collisions for this reasonably pathological case. Maybe we can just change the test case.", "author": "lbradstreet", "createdAt": "2020-07-16T05:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxODEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM2MTg1NQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r455361855", "bodyText": "Let's add a smaller topic or partition count param benchmark. 20,000 partitions in a fetch request is larger than we would normally see :)", "author": "lbradstreet", "createdAt": "2020-07-15T21:26:40Z", "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/common/FetchRequestBenchmark.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.jmh.common;\n+\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.network.Send;\n+import org.apache.kafka.common.protocol.ApiKeys;\n+import org.apache.kafka.common.requests.ByteBufferChannel;\n+import org.apache.kafka.common.requests.FetchRequest;\n+import org.apache.kafka.common.requests.RequestHeader;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+@State(Scope.Benchmark)\n+@Fork(value = 1)\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 15)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+public class FetchRequestBenchmark {\n+    @Param({\"1000\"})", "originalCommit": "efdadc5ab419806b6165cc2ce90a23e36117d007", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgyODg5MA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r455828890", "bodyText": "Typo \"Forgotton\"", "author": "lbradstreet", "createdAt": "2020-07-16T14:27:51Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchRequest.java", "diffHunk": "@@ -273,6 +99,28 @@ public boolean equals(Object o) {\n         }\n     }\n \n+    private Map<TopicPartition, PartitionData> toPartitionDataMap(List<FetchRequestData.FetchTopic> fetchableTopics) {\n+        Map<TopicPartition, PartitionData> result = new LinkedHashMap<>();\n+        fetchableTopics.forEach(fetchTopic -> fetchTopic.partitions().forEach(fetchPartition -> {\n+            Optional<Integer> leaderEpoch = Optional.of(fetchPartition.currentLeaderEpoch())\n+                .filter(epoch -> epoch != RecordBatch.NO_PARTITION_LEADER_EPOCH);\n+            result.put(new TopicPartition(fetchTopic.topic(), fetchPartition.partition()),\n+                new PartitionData(fetchPartition.fetchOffset(), fetchPartition.logStartOffset(),\n+                    fetchPartition.partitionMaxBytes(), leaderEpoch));\n+        }));\n+        return Collections.unmodifiableMap(result);\n+    }\n+\n+    private List<TopicPartition> toForgottonTopicList(List<FetchRequestData.ForgottenTopic> forgottenTopics) {", "originalCommit": "efdadc5ab419806b6165cc2ce90a23e36117d007", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "538ed0010f048d48517057aa932c5f377b6c00d7", "url": "https://github.com/apache/kafka/commit/538ed0010f048d48517057aa932c5f377b6c00d7", "message": "Fix sizeOf for records in message class generator", "committedDate": "2020-07-16T15:53:49Z", "type": "commit"}, {"oid": "155621b97fc1c1c32ec4998165fcaf1858bd1cd4", "url": "https://github.com/apache/kafka/commit/155621b97fc1c1c32ec4998165fcaf1858bd1cd4", "message": "Don't re-create the whole message on static size method", "committedDate": "2020-07-16T16:17:11Z", "type": "commit"}, {"oid": "89de5083ecbee44f730bf1f15b422c01c2114976", "url": "https://github.com/apache/kafka/commit/89de5083ecbee44f730bf1f15b422c01c2114976", "message": "Update benchmarks", "committedDate": "2020-07-16T20:58:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1Nzg0OQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456057849", "bodyText": "nit: could probably change this to use ifPresent", "author": "hachikuji", "createdAt": "2020-07-16T20:27:58Z", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java", "diffHunk": "@@ -1249,26 +1249,26 @@ private CompletedFetch initializeCompletedFetch(CompletedFetch nextCompletedFetc\n                     }\n                 }\n \n-                if (partition.highWatermark >= 0) {\n-                    log.trace(\"Updating high watermark for partition {} to {}\", tp, partition.highWatermark);\n-                    subscriptions.updateHighWatermark(tp, partition.highWatermark);\n+                if (partition.highWatermark() >= 0) {\n+                    log.trace(\"Updating high watermark for partition {} to {}\", tp, partition.highWatermark());\n+                    subscriptions.updateHighWatermark(tp, partition.highWatermark());\n                 }\n \n-                if (partition.logStartOffset >= 0) {\n-                    log.trace(\"Updating log start offset for partition {} to {}\", tp, partition.logStartOffset);\n-                    subscriptions.updateLogStartOffset(tp, partition.logStartOffset);\n+                if (partition.logStartOffset() >= 0) {\n+                    log.trace(\"Updating log start offset for partition {} to {}\", tp, partition.logStartOffset());\n+                    subscriptions.updateLogStartOffset(tp, partition.logStartOffset());\n                 }\n \n-                if (partition.lastStableOffset >= 0) {\n-                    log.trace(\"Updating last stable offset for partition {} to {}\", tp, partition.lastStableOffset);\n-                    subscriptions.updateLastStableOffset(tp, partition.lastStableOffset);\n+                if (partition.lastStableOffset() >= 0) {\n+                    log.trace(\"Updating last stable offset for partition {} to {}\", tp, partition.lastStableOffset());\n+                    subscriptions.updateLastStableOffset(tp, partition.lastStableOffset());\n                 }\n \n-                if (partition.preferredReadReplica.isPresent()) {\n-                    subscriptions.updatePreferredReadReplica(completedFetch.partition, partition.preferredReadReplica.get(), () -> {\n+                if (partition.preferredReadReplica().isPresent()) {", "originalCommit": "155621b97fc1c1c32ec4998165fcaf1858bd1cd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA3NjkyNw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456076927", "bodyText": "Is there an advantage to pulling this up? Seems like we still need to update a bunch more classes. Until we have all the protocols converted, it might be safer to find another approach.", "author": "hachikuji", "createdAt": "2020-07-16T21:04:15Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/AbstractRequestResponse.java", "diffHunk": "@@ -16,5 +16,16 @@\n  */\n package org.apache.kafka.common.requests;\n \n+import org.apache.kafka.common.protocol.ApiMessage;\n+\n public interface AbstractRequestResponse {\n+    /**\n+     * Return the auto-generated `Message` instance if this request/response relies on one for\n+     * serialization/deserialization. If this class has not yet been updated to rely on the auto-generated protocol\n+     * classes, return `null`.\n+     * @return\n+     */\n+    default ApiMessage data() {", "originalCommit": "89de5083ecbee44f730bf1f15b422c01c2114976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA5MTI0MQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456091241", "bodyText": "I have a PR that does need. I really need to get that over the line.", "author": "ijuma", "createdAt": "2020-07-16T21:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA3NjkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA5MjAzNw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456092037", "bodyText": "Perhaps instead we could add this to a mixin type. Then if we find cases where getting accessing to the ApiMessage generally would be useful, we could just use instanceof checks. These would ultimately go away after the conversions are finished.", "author": "hachikuji", "createdAt": "2020-07-16T21:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA3NjkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwMzY2MQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r461203661", "bodyText": "@mumrah Do we need this for this PR or can we leave this for #7409?", "author": "hachikuji", "createdAt": "2020-07-27T22:21:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA3NjkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA4MTM3NA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456081374", "bodyText": "Are we overriding this so that we save the conversion to Struct? As far as I can tell, there's nothing specific to FetchRequest below. I wonder if we can move this implementation to AbstractRequest.serialize so that we save the conversion to Struct for all APIs that have been converted?", "author": "hachikuji", "createdAt": "2020-07-16T21:13:38Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchRequest.java", "diffHunk": "@@ -492,74 +327,51 @@ public int maxBytes() {\n     }\n \n     public boolean isFromFollower() {\n-        return replicaId >= 0;\n+        return replicaId() >= 0;\n     }\n \n     public IsolationLevel isolationLevel() {\n-        return isolationLevel;\n+        return IsolationLevel.forId(data.isolationLevel());\n     }\n \n     public FetchMetadata metadata() {\n         return metadata;\n     }\n \n     public String rackId() {\n-        return rackId;\n+        return data.rackId();\n     }\n \n     public static FetchRequest parse(ByteBuffer buffer, short version) {\n-        return new FetchRequest(ApiKeys.FETCH.parseRequest(version, buffer), version);\n+        ByteBufferAccessor accessor = new ByteBufferAccessor(buffer);\n+        FetchRequestData message = new FetchRequestData();\n+        message.read(accessor, version);\n+        return new FetchRequest(message, version);\n+    }\n+\n+    @Override\n+    public ByteBuffer serialize(RequestHeader header) {", "originalCommit": "89de5083ecbee44f730bf1f15b422c01c2114976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ0OTAzNQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456449035", "bodyText": "Indeed this is generic serialization code for the message classes. If we go with a mixin interface to indicate a class has been converted over to generated messages, we could also push this up to AbstractRequest. However, this might be better saved for a follow-on since we'll probably want to pick up additional changes from @ijuma's PR. Thoughts?", "author": "mumrah", "createdAt": "2020-07-17T13:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA4MTM3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2MDM3OQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456660379", "bodyText": "I'm ok saving this for #7409.", "author": "hachikuji", "createdAt": "2020-07-17T20:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA4MTM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA4NDIxNg==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456084216", "bodyText": "In the parsing logic, we still convert to struct first before calling AbstractRequest.parseRequest. I think we could bypass the Struct conversion by changing AbstractRequest.parseRequest to take the ByteBuffer instead of the Struct.\n    public static AbstractRequest parseRequest(ApiKeys apiKey, short apiVersion, ByteBuffer buffer) {\nThen in the fetch case, we could just call this method.", "author": "hachikuji", "createdAt": "2020-07-16T21:19:40Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchRequest.java", "diffHunk": "@@ -492,74 +327,51 @@ public int maxBytes() {\n     }\n \n     public boolean isFromFollower() {\n-        return replicaId >= 0;\n+        return replicaId() >= 0;\n     }\n \n     public IsolationLevel isolationLevel() {\n-        return isolationLevel;\n+        return IsolationLevel.forId(data.isolationLevel());\n     }\n \n     public FetchMetadata metadata() {\n         return metadata;\n     }\n \n     public String rackId() {\n-        return rackId;\n+        return data.rackId();\n     }\n \n     public static FetchRequest parse(ByteBuffer buffer, short version) {\n-        return new FetchRequest(ApiKeys.FETCH.parseRequest(version, buffer), version);\n+        ByteBufferAccessor accessor = new ByteBufferAccessor(buffer);", "originalCommit": "89de5083ecbee44f730bf1f15b422c01c2114976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MDEwNw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456450107", "bodyText": "I believe this is also addressed in @ijuma's PR.", "author": "mumrah", "createdAt": "2020-07-17T13:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA4NDIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NTkzNA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456195934", "bodyText": "This seems pretty inefficient (creating a lambda for each byte we write). Are we sure about it?", "author": "ijuma", "createdAt": "2020-07-17T03:19:46Z", "path": "clients/src/main/java/org/apache/kafka/common/protocol/RecordsWriter.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.protocol;\n+\n+import org.apache.kafka.common.network.ByteBufferSend;\n+import org.apache.kafka.common.network.Send;\n+import org.apache.kafka.common.record.BaseRecords;\n+import org.apache.kafka.common.utils.ByteUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutput;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Implementation of Writable which produces a sequence of {@link Send} objects. This allows for deferring the transfer\n+ * of data from a record-set's file channel to the eventual socket channel.\n+ *\n+ * Excepting {@link #writeRecords(BaseRecords)}, calls to the write methods on this class will append to a byte array\n+ * according to the format specified in {@link DataOutput}. When a call is made to writeRecords, any previously written\n+ * bytes will be flushed as a new {@link ByteBufferSend} to the given Send consumer. After flushing the pending bytes,\n+ * another Send is passed to the consumer which wraps the underlying record-set's transfer logic.\n+ *\n+ * For example,\n+ *\n+ * <pre>\n+ *     recordsWritable.writeInt(10);\n+ *     recordsWritable.writeRecords(records1);\n+ *     recordsWritable.writeInt(20);\n+ *     recordsWritable.writeRecords(records2);\n+ *     recordsWritable.writeInt(30);\n+ *     recordsWritable.flush();\n+ * </pre>\n+ *\n+ * Will pass 5 Send objects to the consumer given in the constructor. Care must be taken by callers to flush any\n+ * pending bytes at the end of the writing sequence to ensure everything is flushed to the consumer. This class is\n+ * intended to be used with {@link org.apache.kafka.common.record.MultiRecordsSend}.\n+ *\n+ * @see org.apache.kafka.common.requests.FetchResponse\n+ */\n+public class RecordsWriter implements Writable {\n+    private final String dest;\n+    private final Consumer<Send> sendConsumer;\n+    private final ByteArrayOutputStream byteArrayOutputStream;\n+    private final DataOutput output;\n+\n+    public RecordsWriter(String dest, Consumer<Send> sendConsumer) {\n+        this.dest = dest;\n+        this.sendConsumer = sendConsumer;\n+        this.byteArrayOutputStream = new ByteArrayOutputStream();\n+        this.output = new DataOutputStream(this.byteArrayOutputStream);\n+    }\n+\n+    @Override\n+    public void writeByte(byte val) {\n+        writeQuietly(() -> output.writeByte(val));", "originalCommit": "89de5083ecbee44f730bf1f15b422c01c2114976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUzOTQ4OA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456539488", "bodyText": "This would only get called when we're writing a int8 field I believe, but you're right these lambdas could create un-needed object allocations. I'll rewrite as simple try/catch statements", "author": "mumrah", "createdAt": "2020-07-17T16:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NTkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NjMzMQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456196331", "bodyText": "Is this and the respective writeRecords in the base interface needed? It seems like they're only implemented in two specific cases. Could we not downcast for those cases?", "author": "ijuma", "createdAt": "2020-07-17T03:21:28Z", "path": "clients/src/main/java/org/apache/kafka/common/protocol/Readable.java", "diffHunk": "@@ -35,6 +36,10 @@\n     int readUnsignedVarint();\n     ByteBuffer readByteBuffer(int length);\n \n+    default BaseRecords readRecords(int length) {\n+        throw new UnsupportedOperationException(\"Not implemented\");\n+    }", "originalCommit": "89de5083ecbee44f730bf1f15b422c01c2114976", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NzYwMQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456197601", "bodyText": "This creates a copy of the underlying bytes, can we avoid it?", "author": "ijuma", "createdAt": "2020-07-17T03:26:55Z", "path": "clients/src/main/java/org/apache/kafka/common/protocol/RecordsWriter.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.protocol;\n+\n+import org.apache.kafka.common.network.ByteBufferSend;\n+import org.apache.kafka.common.network.Send;\n+import org.apache.kafka.common.record.BaseRecords;\n+import org.apache.kafka.common.utils.ByteUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutput;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Implementation of Writable which produces a sequence of {@link Send} objects. This allows for deferring the transfer\n+ * of data from a record-set's file channel to the eventual socket channel.\n+ *\n+ * Excepting {@link #writeRecords(BaseRecords)}, calls to the write methods on this class will append to a byte array\n+ * according to the format specified in {@link DataOutput}. When a call is made to writeRecords, any previously written\n+ * bytes will be flushed as a new {@link ByteBufferSend} to the given Send consumer. After flushing the pending bytes,\n+ * another Send is passed to the consumer which wraps the underlying record-set's transfer logic.\n+ *\n+ * For example,\n+ *\n+ * <pre>\n+ *     recordsWritable.writeInt(10);\n+ *     recordsWritable.writeRecords(records1);\n+ *     recordsWritable.writeInt(20);\n+ *     recordsWritable.writeRecords(records2);\n+ *     recordsWritable.writeInt(30);\n+ *     recordsWritable.flush();\n+ * </pre>\n+ *\n+ * Will pass 5 Send objects to the consumer given in the constructor. Care must be taken by callers to flush any\n+ * pending bytes at the end of the writing sequence to ensure everything is flushed to the consumer. This class is\n+ * intended to be used with {@link org.apache.kafka.common.record.MultiRecordsSend}.\n+ *\n+ * @see org.apache.kafka.common.requests.FetchResponse\n+ */\n+public class RecordsWriter implements Writable {\n+    private final String dest;\n+    private final Consumer<Send> sendConsumer;\n+    private final ByteArrayOutputStream byteArrayOutputStream;\n+    private final DataOutput output;\n+\n+    public RecordsWriter(String dest, Consumer<Send> sendConsumer) {\n+        this.dest = dest;\n+        this.sendConsumer = sendConsumer;\n+        this.byteArrayOutputStream = new ByteArrayOutputStream();\n+        this.output = new DataOutputStream(this.byteArrayOutputStream);\n+    }\n+\n+    @Override\n+    public void writeByte(byte val) {\n+        writeQuietly(() -> output.writeByte(val));\n+    }\n+\n+    @Override\n+    public void writeShort(short val) {\n+        writeQuietly(() -> output.writeShort(val));\n+    }\n+\n+    @Override\n+    public void writeInt(int val) {\n+        writeQuietly(() -> output.writeInt(val));\n+    }\n+\n+    @Override\n+    public void writeLong(long val) {\n+        writeQuietly(() -> output.writeLong(val));\n+\n+    }\n+\n+    @Override\n+    public void writeDouble(double val) {\n+        writeQuietly(() -> ByteUtils.writeDouble(val, output));\n+\n+    }\n+\n+    @Override\n+    public void writeByteArray(byte[] arr) {\n+        writeQuietly(() -> output.write(arr));\n+    }\n+\n+    @Override\n+    public void writeUnsignedVarint(int i) {\n+        writeQuietly(() -> ByteUtils.writeUnsignedVarint(i, output));\n+    }\n+\n+    @Override\n+    public void writeByteBuffer(ByteBuffer src) {\n+        writeQuietly(() -> output.write(src.array(), src.position(), src.remaining()));\n+    }\n+\n+    @FunctionalInterface\n+    private interface IOExceptionThrowingRunnable {\n+        void run() throws IOException;\n+    }\n+\n+    private void writeQuietly(IOExceptionThrowingRunnable runnable) {\n+        try {\n+            runnable.run();\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Writable encountered an IO error\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRecords(BaseRecords records) {\n+        flush();\n+        sendConsumer.accept(records.toSend(dest));\n+    }\n+\n+    /**\n+     * Flush any pending bytes as a ByteBufferSend and reset the buffer\n+     */\n+    public void flush() {\n+        ByteBufferSend send = new ByteBufferSend(dest,\n+                ByteBuffer.wrap(byteArrayOutputStream.toByteArray()));", "originalCommit": "89de5083ecbee44f730bf1f15b422c01c2114976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxODUyOQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456518529", "bodyText": "Yea, it's possible, but rather complicated I think. We would need to manage our own byte array and grow it on-demand (like what happens in ByteArrayOutputStream). Then we could use ByteBuffer#slice to pass views of this array to the ByteBufferSend objects. I don't think this current approach is any worse than before in terms of array allocations, so maybe we could save this for a future optimization?", "author": "mumrah", "createdAt": "2020-07-17T15:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NzYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5MjAzMw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456692033", "bodyText": "Would org.apache.kafka.common.utils.ByteBufferOutputStream be useful here?", "author": "ijuma", "createdAt": "2020-07-17T22:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NzYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNzcxNQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456727715", "bodyText": "Looks like the expansion factor for ByteArrayOutputStream varies on the JDK version. In JDK 8 and 11 it's 2x, but in JDK 14 it just grows the buffer to the minimum needed size.\nOur growth factor of 1.1 in ByteBufferOutputStream seems reasonable . Not to mention avoiding the final copy by using slice would be nice too.", "author": "mumrah", "createdAt": "2020-07-18T00:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NzYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ5NjY4OA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r457496688", "bodyText": "@mumrah Thanks for checking this. However, the behavior in JDK 14 has not changed in that way. Performance would be atrocious if it did:\nprivate void ensureCapacity(int minCapacity) {\n        // overflow-conscious code\n        int oldCapacity = buf.length;\n        int minGrowth = minCapacity - oldCapacity;\n        if (minGrowth > 0) {\n            buf = Arrays.copyOf(buf, ArraysSupport.newLength(oldCapacity,\n                    minGrowth, oldCapacity /* preferred growth */));\n        }\nThe third parameter passed to newLength is the preferred growth, which is oldCapacity. That is, it doubles if it doesn't cause overflow. We should probably double for ByteBufferOutputStream too if we have no estimate of the expected size. 1.1 growth makes sense if we do have a reasonable estimate (which is the case in current usage, I believe, but perhaps not in this case).", "author": "ijuma", "createdAt": "2020-07-20T15:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NzYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMzcxMw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r457513713", "bodyText": "Looking a bit more, it seems like this will be mostly used by the data that precedes the actual records. Do we have a sense for what's the typical size for that? If we do, we can use that in the initial size and we can keep the 1.1 growth.", "author": "ijuma", "createdAt": "2020-07-20T15:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NzYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU0NjI4MQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r457546281", "bodyText": "Thanks for the explanation, @ijuma. I missed the semantics of newLength\nAfter the initial few top-level fields, each partition will have something like 38 bytes preceding its records (at a minimum, aborted transactions could increase that). Maybe we could increase initial capacity to 64 bytes?", "author": "mumrah", "createdAt": "2020-07-20T16:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NzYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2MjQxNQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r457562415", "bodyText": "Sounds good.", "author": "ijuma", "createdAt": "2020-07-20T17:06:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NzYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM4MjkzNQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r458382935", "bodyText": "I increased the initial buffer size to 64 and also added 2x growth factor for the buffer. It occurred to me the initial size only really helps for the first partition's header fields, but beyond that (since we are reusing/growing the same ByteBufferOutputStream) we don't know what we'll need. The JMH benchmark did confirm that 2x was more performant than 1.1x for FetchResponse.\nExisting usages of ByteBufferOutputStream were not modified and still use 1.1x", "author": "mumrah", "createdAt": "2020-07-21T20:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NzYwMQ=="}], "type": "inlineReview"}, {"oid": "7878289a11d1efb500440c3218b4cac6670791b1", "url": "https://github.com/apache/kafka/commit/7878289a11d1efb500440c3218b4cac6670791b1", "message": "Pull up readRecords and writeRecords out of the base interfaces", "committedDate": "2020-07-17T16:06:51Z", "type": "commit"}, {"oid": "701619dbfd23f1b41c3376f33c9615107dc1e8f3", "url": "https://github.com/apache/kafka/commit/701619dbfd23f1b41c3376f33c9615107dc1e8f3", "message": "Add a struct -> message benchmark", "committedDate": "2020-07-17T16:16:31Z", "type": "commit"}, {"oid": "82a0d46ecea2d18a59de64fbb18c8a40f1c05e3e", "url": "https://github.com/apache/kafka/commit/82a0d46ecea2d18a59de64fbb18c8a40f1c05e3e", "message": "Merge remote-tracking branch 'apache-github/trunk' into KAFKA-9629-fetch-api-generated-protocol", "committedDate": "2020-07-17T19:59:55Z", "type": "commit"}, {"oid": "38b2ebf3c3343d7d6a5c354096fc24c6bbf73535", "url": "https://github.com/apache/kafka/commit/38b2ebf3c3343d7d6a5c354096fc24c6bbf73535", "message": "Re-add storage error conversion logic", "committedDate": "2020-07-17T20:18:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2Mjg1MA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456662850", "bodyText": "Using null as the default seems reasonable to me. We also have MemoryRecords.EMPTY which we could use.", "author": "hachikuji", "createdAt": "2020-07-17T20:37:05Z", "path": "generator/src/main/java/org/apache/kafka/message/MessageDataGenerator.java", "diffHunk": "@@ -2397,6 +2460,9 @@ private String fieldDefault(FieldSpec field) {\n                 headerGenerator.addImport(MessageGenerator.BYTES_CLASS);\n                 return \"Bytes.EMPTY\";\n             }\n+        } else if (field.type().isRecords()) {\n+            // TODO should we use some special EmptyRecords class instead?", "originalCommit": "38b2ebf3c3343d7d6a5c354096fc24c6bbf73535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjczMDU4MA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r456730580", "bodyText": "Ok, going to leave it as null since we need to deal with FileRecords and MemoryRecords in different cases.", "author": "mumrah", "createdAt": "2020-07-18T01:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2Mjg1MA=="}], "type": "inlineReview"}, {"oid": "efa54501144764fb7159f1e9211fecd88dd34401", "url": "https://github.com/apache/kafka/commit/efa54501144764fb7159f1e9211fecd88dd34401", "message": "Use ByteBufferOutputStream for auto-resizing buffer in RecordsWriter", "committedDate": "2020-07-18T00:55:03Z", "type": "commit"}, {"oid": "2514f5ae54b4f51dad11b6ff23ecafc28362f7bd", "url": "https://github.com/apache/kafka/commit/2514f5ae54b4f51dad11b6ff23ecafc28362f7bd", "message": "Remove some TODOs", "committedDate": "2020-07-18T01:11:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQxNjI2OQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r457416269", "bodyText": "I ended up having to keep a separate mark here since ByteBufferOutputStream doesn't keep the mark when it replaces the underlying buffer. I also didn't want to mess with that class in this PR since it had quite a lot of usages. We could look into fixing that as a follow-on", "author": "mumrah", "createdAt": "2020-07-20T14:05:08Z", "path": "clients/src/main/java/org/apache/kafka/common/protocol/RecordsWriter.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.protocol;\n+\n+import org.apache.kafka.common.network.ByteBufferSend;\n+import org.apache.kafka.common.network.Send;\n+import org.apache.kafka.common.record.BaseRecords;\n+import org.apache.kafka.common.utils.ByteBufferOutputStream;\n+import org.apache.kafka.common.utils.ByteUtils;\n+\n+import java.io.DataOutput;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Implementation of Writable which produces a sequence of {@link Send} objects. This allows for deferring the transfer\n+ * of data from a record-set's file channel to the eventual socket channel.\n+ *\n+ * Excepting {@link #writeRecords(BaseRecords)}, calls to the write methods on this class will append to a byte array\n+ * according to the format specified in {@link DataOutput}. When a call is made to writeRecords, any previously written\n+ * bytes will be flushed as a new {@link ByteBufferSend} to the given Send consumer. After flushing the pending bytes,\n+ * another Send is passed to the consumer which wraps the underlying record-set's transfer logic.\n+ *\n+ * For example,\n+ *\n+ * <pre>\n+ *     recordsWritable.writeInt(10);\n+ *     recordsWritable.writeRecords(records1);\n+ *     recordsWritable.writeInt(20);\n+ *     recordsWritable.writeRecords(records2);\n+ *     recordsWritable.writeInt(30);\n+ *     recordsWritable.flush();\n+ * </pre>\n+ *\n+ * Will pass 5 Send objects to the consumer given in the constructor. Care must be taken by callers to flush any\n+ * pending bytes at the end of the writing sequence to ensure everything is flushed to the consumer. This class is\n+ * intended to be used with {@link org.apache.kafka.common.record.MultiRecordsSend}.\n+ *\n+ * @see org.apache.kafka.common.requests.FetchResponse\n+ */\n+public class RecordsWriter implements Writable {\n+    private final String dest;\n+    private final Consumer<Send> sendConsumer;\n+    private final ByteBufferOutputStream byteArrayOutputStream;\n+    private final DataOutput output;\n+    private int mark;\n+\n+    public RecordsWriter(String dest, Consumer<Send> sendConsumer) {\n+        this.dest = dest;\n+        this.sendConsumer = sendConsumer;\n+        this.byteArrayOutputStream = new ByteBufferOutputStream(32);\n+        this.output = new DataOutputStream(this.byteArrayOutputStream);\n+        this.mark = 0;\n+    }\n+\n+    @Override\n+    public void writeByte(byte val) {\n+        try {\n+            output.writeByte(val);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"RecordsWriter encountered an IO error\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeShort(short val) {\n+        try {\n+            output.writeShort(val);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"RecordsWriter encountered an IO error\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeInt(int val) {\n+        try {\n+            output.writeInt(val);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"RecordsWriter encountered an IO error\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeLong(long val) {\n+        try {\n+            output.writeLong(val);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"RecordsWriter encountered an IO error\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeDouble(double val) {\n+        try {\n+            ByteUtils.writeDouble(val, output);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"RecordsWriter encountered an IO error\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeByteArray(byte[] arr) {\n+        try {\n+            output.write(arr);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"RecordsWriter encountered an IO error\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeUnsignedVarint(int i) {\n+        try {\n+            ByteUtils.writeUnsignedVarint(i, output);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"RecordsWriter encountered an IO error\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeByteBuffer(ByteBuffer src) {\n+        try {\n+            output.write(src.array(), src.position(), src.remaining());\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"RecordsWriter encountered an IO error\", e);\n+        }\n+    }\n+\n+    public void writeRecords(BaseRecords records) {\n+        flush();\n+        sendConsumer.accept(records.toSend(dest));\n+    }\n+\n+    /**\n+     * Flush any pending bytes as a ByteBufferSend and reset the buffer\n+     */\n+    public void flush() {\n+        ByteBuffer buf = byteArrayOutputStream.buffer();\n+        int end = buf.position();\n+        int len = end - mark;\n+\n+        if (len > 0) {\n+            buf.position(mark);\n+            ByteBuffer slice = buf.slice();\n+            slice.limit(len);\n+            ByteBufferSend send = new ByteBufferSend(dest, slice);\n+            sendConsumer.accept(send);\n+        }\n+\n+        buf.position(end);\n+        mark = end;", "originalCommit": "2514f5ae54b4f51dad11b6ff23ecafc28362f7bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5OTkxMQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r459499911", "bodyText": "Ended up not using ByteBufferOutputStream", "author": "mumrah", "createdAt": "2020-07-23T14:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQxNjI2OQ=="}], "type": "inlineReview"}, {"oid": "e198797840bfb4679ba81f6da42aa267f6156409", "url": "https://github.com/apache/kafka/commit/e198797840bfb4679ba81f6da42aa267f6156409", "message": "Clean up and comment ByteBuffer usage", "committedDate": "2020-07-20T14:39:49Z", "type": "commit"}, {"oid": "cf3bf3360c0dab8402e6c5adbbb2ce9bc0ac8374", "url": "https://github.com/apache/kafka/commit/cf3bf3360c0dab8402e6c5adbbb2ce9bc0ac8374", "message": "Allocated a larger initial buffer for FetchResponse and grow it at 2x", "committedDate": "2020-07-21T20:44:19Z", "type": "commit"}, {"oid": "78cd0124dc0573819e169c432b45929efd933665", "url": "https://github.com/apache/kafka/commit/78cd0124dc0573819e169c432b45929efd933665", "message": "Use ByteBuffer with a single allocation", "committedDate": "2020-07-23T02:02:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE3MzE2Mg==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r461173162", "bodyText": "I guess the implicit expectation is that if the protocol does not support the read_committed isolation level, then it wouldn't have transactional data anyway, so reverting to read_uncommitted is safe. Can't find a fault with that.", "author": "hachikuji", "createdAt": "2020-07-27T21:12:47Z", "path": "clients/src/main/resources/common/message/FetchRequest.json", "diffHunk": "@@ -55,35 +55,35 @@\n       \"about\": \"The minimum bytes to accumulate in the response.\" },\n     { \"name\": \"MaxBytes\", \"type\": \"int32\", \"versions\": \"3+\", \"default\": \"0x7fffffff\", \"ignorable\": true,\n       \"about\": \"The maximum bytes to fetch.  See KIP-74 for cases where this limit may not be honored.\" },\n-    { \"name\": \"IsolationLevel\", \"type\": \"int8\", \"versions\": \"4+\", \"default\": \"0\", \"ignorable\": false,\n+    { \"name\": \"IsolationLevel\", \"type\": \"int8\", \"versions\": \"4+\", \"default\": \"0\", \"ignorable\": true,", "originalCommit": "78cd0124dc0573819e169c432b45929efd933665", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQzMDgxNA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r462430814", "bodyText": "I changed this to make the JSON schema match what was previously in FetchRequest.java. During serialization, we would simply stick the isolation level in the Struct regardless of the api version:\nstruct.setIfExists(ISOLATION_LEVEL, isolationLevel.id());\nSo even if we were writing out a v3 FetchRequest, whatever value we put here would be ignored and not sent out. There were also some unit tests that utilized this behavior.\nYour assessment sounds correct though, so it probably doesn't matter whether it's ignorable or not.", "author": "mumrah", "createdAt": "2020-07-29T16:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE3MzE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwMTM2Mg==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r461201362", "bodyText": "More of a side question, but is this length guaranteed to be less than the buffer size? Wondering if it is worth adding range checking.", "author": "hachikuji", "createdAt": "2020-07-27T22:15:08Z", "path": "clients/src/main/java/org/apache/kafka/common/protocol/RecordsReader.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.protocol;\n+\n+import org.apache.kafka.common.record.BaseRecords;\n+import org.apache.kafka.common.record.MemoryRecords;\n+import org.apache.kafka.common.utils.ByteUtils;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Implementation of Readable which reads from a byte buffer and can read records as {@link MemoryRecords}\n+ *\n+ * @see org.apache.kafka.common.requests.FetchResponse\n+ */\n+public class RecordsReader implements Readable {\n+    private final ByteBuffer buf;\n+\n+    public RecordsReader(ByteBuffer buf) {\n+        this.buf = buf;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        return buf.get();\n+    }\n+\n+    @Override\n+    public short readShort() {\n+        return buf.getShort();\n+    }\n+\n+    @Override\n+    public int readInt() {\n+        return buf.getInt();\n+    }\n+\n+    @Override\n+    public long readLong() {\n+        return buf.getLong();\n+    }\n+\n+    @Override\n+    public double readDouble() {\n+        return ByteUtils.readDouble(buf);\n+    }\n+\n+    @Override\n+    public void readArray(byte[] arr) {\n+        buf.get(arr);\n+    }\n+\n+    @Override\n+    public int readUnsignedVarint() {\n+        return ByteUtils.readUnsignedVarint(buf);\n+    }\n+\n+    @Override\n+    public ByteBuffer readByteBuffer(int length) {", "originalCommit": "78cd0124dc0573819e169c432b45929efd933665", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM3NDY2OQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r462374669", "bodyText": "This is copied straight from ByteBufferAccessor and will probably go away in a follow-on PR. But either way, looking at it it seems it should always be in range since this is used by zero-copy byte fields in the message classes, e.g.\nint len = _reader.readInt();\nif (len > 0) {\n  this.someZeroCopyField = _reader.readByteBuffer(len);\n}\nSo generally it's probably safe. In the case of a corrupt message where the length is wrong, ByteBuffer#limit will throw an error and parsing will fail. It probably would be nice to put a range check in ByteBufferAccessor so we can throw a more useful error.", "author": "mumrah", "createdAt": "2020-07-29T15:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwMTM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwMjg3MQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r461202871", "bodyText": "Could we rename totalSize so that it is clear that it does not cover the record sizes. Maybe totalOverheadSize or totalNonRecordSize or something like that.", "author": "hachikuji", "createdAt": "2020-07-27T22:19:10Z", "path": "clients/src/main/java/org/apache/kafka/common/protocol/RecordsWriter.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.protocol;\n+\n+import org.apache.kafka.common.network.ByteBufferSend;\n+import org.apache.kafka.common.network.Send;\n+import org.apache.kafka.common.record.BaseRecords;\n+import org.apache.kafka.common.utils.ByteUtils;\n+\n+import java.io.DataOutput;\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Implementation of Writable which produces a sequence of {@link Send} objects. This allows for deferring the transfer\n+ * of data from a record-set's file channel to the eventual socket channel.\n+ *\n+ * Excepting {@link #writeRecords(BaseRecords)}, calls to the write methods on this class will append to a byte array\n+ * according to the format specified in {@link DataOutput}. When a call is made to writeRecords, any previously written\n+ * bytes will be flushed as a new {@link ByteBufferSend} to the given Send consumer. After flushing the pending bytes,\n+ * another Send is passed to the consumer which wraps the underlying record-set's transfer logic.\n+ *\n+ * For example,\n+ *\n+ * <pre>\n+ *     recordsWritable.writeInt(10);\n+ *     recordsWritable.writeRecords(records1);\n+ *     recordsWritable.writeInt(20);\n+ *     recordsWritable.writeRecords(records2);\n+ *     recordsWritable.writeInt(30);\n+ *     recordsWritable.flush();\n+ * </pre>\n+ *\n+ * Will pass 5 Send objects to the consumer given in the constructor. Care must be taken by callers to flush any\n+ * pending bytes at the end of the writing sequence to ensure everything is flushed to the consumer. This class is\n+ * intended to be used with {@link org.apache.kafka.common.record.MultiRecordsSend}.\n+ *\n+ * @see org.apache.kafka.common.requests.FetchResponse\n+ */\n+public class RecordsWriter implements Writable {\n+    private final String dest;\n+    private final Consumer<Send> sendConsumer;\n+    private final ByteBuffer buffer;\n+    private int mark;\n+\n+    public RecordsWriter(String dest, int totalSize, Consumer<Send> sendConsumer) {", "originalCommit": "78cd0124dc0573819e169c432b45929efd933665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwMzI4Nw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r461203287", "bodyText": "nit: any reason not to stick with the same constructor convention as the other requests?", "author": "hachikuji", "createdAt": "2020-07-27T22:20:10Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/AbstractRequest.java", "diffHunk": "@@ -146,7 +147,7 @@ public static AbstractRequest parseRequest(ApiKeys apiKey, short apiVersion, Str\n             case PRODUCE:\n                 return new ProduceRequest(struct, apiVersion);\n             case FETCH:\n-                return new FetchRequest(struct, apiVersion);\n+                return new FetchRequest(new FetchRequestData(struct, apiVersion), apiVersion);", "originalCommit": "78cd0124dc0573819e169c432b45929efd933665", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM2ODQxNA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r462368414", "bodyText": "I just wanted to remove the Struct constructor of FetchRequest completely. Eventually, RequestContext#parseRequest(ByteBuffer) will stop using Structs and pass the message data classes to AbstractRequest#parseRequest (or similar).", "author": "mumrah", "createdAt": "2020-07-29T15:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwMzI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwNTQyNw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r461205427", "bodyText": "nit: wonder if this should be RecordsWritable for consistency with Writable.", "author": "hachikuji", "createdAt": "2020-07-27T22:25:41Z", "path": "clients/src/main/java/org/apache/kafka/common/protocol/RecordsWriter.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.protocol;\n+\n+import org.apache.kafka.common.network.ByteBufferSend;\n+import org.apache.kafka.common.network.Send;\n+import org.apache.kafka.common.record.BaseRecords;\n+import org.apache.kafka.common.utils.ByteUtils;\n+\n+import java.io.DataOutput;\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Implementation of Writable which produces a sequence of {@link Send} objects. This allows for deferring the transfer\n+ * of data from a record-set's file channel to the eventual socket channel.\n+ *\n+ * Excepting {@link #writeRecords(BaseRecords)}, calls to the write methods on this class will append to a byte array\n+ * according to the format specified in {@link DataOutput}. When a call is made to writeRecords, any previously written\n+ * bytes will be flushed as a new {@link ByteBufferSend} to the given Send consumer. After flushing the pending bytes,\n+ * another Send is passed to the consumer which wraps the underlying record-set's transfer logic.\n+ *\n+ * For example,\n+ *\n+ * <pre>\n+ *     recordsWritable.writeInt(10);\n+ *     recordsWritable.writeRecords(records1);\n+ *     recordsWritable.writeInt(20);\n+ *     recordsWritable.writeRecords(records2);\n+ *     recordsWritable.writeInt(30);\n+ *     recordsWritable.flush();\n+ * </pre>\n+ *\n+ * Will pass 5 Send objects to the consumer given in the constructor. Care must be taken by callers to flush any\n+ * pending bytes at the end of the writing sequence to ensure everything is flushed to the consumer. This class is\n+ * intended to be used with {@link org.apache.kafka.common.record.MultiRecordsSend}.\n+ *\n+ * @see org.apache.kafka.common.requests.FetchResponse\n+ */\n+public class RecordsWriter implements Writable {", "originalCommit": "78cd0124dc0573819e169c432b45929efd933665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwOTU2Ng==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r461209566", "bodyText": "nit: not a big deal, but I feel like calling flush should really be the responsibility of write.", "author": "hachikuji", "createdAt": "2020-07-27T22:36:36Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchResponse.java", "diffHunk": "@@ -366,225 +255,128 @@ public FetchResponse(Errors error,\n                          LinkedHashMap<TopicPartition, PartitionData<T>> responseData,\n                          int throttleTimeMs,\n                          int sessionId) {\n-        this.error = error;\n-        this.responseData = responseData;\n-        this.throttleTimeMs = throttleTimeMs;\n-        this.sessionId = sessionId;\n+        this.data = toMessage(throttleTimeMs, error, responseData.entrySet().iterator(), sessionId);\n+        this.responseDataMap = responseData;\n     }\n \n-    public static FetchResponse<MemoryRecords> parse(Struct struct) {\n-        LinkedHashMap<TopicPartition, PartitionData<MemoryRecords>> responseData = new LinkedHashMap<>();\n-        for (Object topicResponseObj : struct.getArray(RESPONSES_KEY_NAME)) {\n-            Struct topicResponse = (Struct) topicResponseObj;\n-            String topic = topicResponse.get(TOPIC_NAME);\n-            for (Object partitionResponseObj : topicResponse.getArray(PARTITIONS_KEY_NAME)) {\n-                Struct partitionResponse = (Struct) partitionResponseObj;\n-                Struct partitionResponseHeader = partitionResponse.getStruct(PARTITION_HEADER_KEY_NAME);\n-                int partition = partitionResponseHeader.get(PARTITION_ID);\n-                Errors error = Errors.forCode(partitionResponseHeader.get(ERROR_CODE));\n-                long highWatermark = partitionResponseHeader.get(HIGH_WATERMARK);\n-                long lastStableOffset = partitionResponseHeader.getOrElse(LAST_STABLE_OFFSET, INVALID_LAST_STABLE_OFFSET);\n-                long logStartOffset = partitionResponseHeader.getOrElse(LOG_START_OFFSET, INVALID_LOG_START_OFFSET);\n-                Optional<Integer> preferredReadReplica = Optional.of(\n-                    partitionResponseHeader.getOrElse(PREFERRED_READ_REPLICA, INVALID_PREFERRED_REPLICA_ID)\n-                ).filter(Predicate.isEqual(INVALID_PREFERRED_REPLICA_ID).negate());\n-\n-                BaseRecords baseRecords = partitionResponse.getRecords(RECORD_SET_KEY_NAME);\n-                if (!(baseRecords instanceof MemoryRecords))\n-                    throw new IllegalStateException(\"Unknown records type found: \" + baseRecords.getClass());\n-                MemoryRecords records = (MemoryRecords) baseRecords;\n-\n-                List<AbortedTransaction> abortedTransactions = null;\n-                if (partitionResponseHeader.hasField(ABORTED_TRANSACTIONS_KEY_NAME)) {\n-                    Object[] abortedTransactionsArray = partitionResponseHeader.getArray(ABORTED_TRANSACTIONS_KEY_NAME);\n-                    if (abortedTransactionsArray != null) {\n-                        abortedTransactions = new ArrayList<>(abortedTransactionsArray.length);\n-                        for (Object abortedTransactionObj : abortedTransactionsArray) {\n-                            Struct abortedTransactionStruct = (Struct) abortedTransactionObj;\n-                            long producerId = abortedTransactionStruct.get(PRODUCER_ID);\n-                            long firstOffset = abortedTransactionStruct.get(FIRST_OFFSET);\n-                            abortedTransactions.add(new AbortedTransaction(producerId, firstOffset));\n-                        }\n-                    }\n-                }\n-\n-                PartitionData<MemoryRecords> partitionData = new PartitionData<>(error, highWatermark, lastStableOffset,\n-                        logStartOffset, preferredReadReplica, abortedTransactions, records);\n-                responseData.put(new TopicPartition(topic, partition), partitionData);\n-            }\n-        }\n-        return new FetchResponse<>(Errors.forCode(struct.getOrElse(ERROR_CODE, (short) 0)), responseData,\n-                struct.getOrElse(THROTTLE_TIME_MS, DEFAULT_THROTTLE_TIME), struct.getOrElse(SESSION_ID, INVALID_SESSION_ID));\n+    public FetchResponse(FetchResponseData fetchResponseData) {\n+        this.data = fetchResponseData;\n+        this.responseDataMap = toResponseDataMap(fetchResponseData);\n     }\n \n     @Override\n     public Struct toStruct(short version) {\n-        return toStruct(version, throttleTimeMs, error, responseData.entrySet().iterator(), sessionId);\n+        return data.toStruct(version);\n     }\n \n     @Override\n-    protected Send toSend(String dest, ResponseHeader responseHeader, short apiVersion) {\n-        Struct responseHeaderStruct = responseHeader.toStruct();\n-        Struct responseBodyStruct = toStruct(apiVersion);\n-\n-        // write the total size and the response header\n-        ByteBuffer buffer = ByteBuffer.allocate(responseHeaderStruct.sizeOf() + 4);\n-        buffer.putInt(responseHeaderStruct.sizeOf() + responseBodyStruct.sizeOf());\n-        responseHeaderStruct.writeTo(buffer);\n+    public Send toSend(String dest, ResponseHeader responseHeader, short apiVersion) {\n+        // Generate the Sends for the response fields and records\n+        ArrayDeque<Send> sends = new ArrayDeque<>();\n+        ObjectSerializationCache cache = new ObjectSerializationCache();\n+        int totalRecordSize = data.responses().stream()\n+                .flatMap(fetchableTopicResponse -> fetchableTopicResponse.partitionResponses().stream())\n+                .mapToInt(fetchablePartitionResponse -> fetchablePartitionResponse.recordSet().sizeInBytes())\n+                .sum();\n+        int totalMessageSize = data.size(cache, apiVersion);\n+\n+        RecordsWriter writer = new RecordsWriter(dest, totalMessageSize - totalRecordSize, sends::add);\n+        data.write(writer, cache, apiVersion);\n+        writer.flush();", "originalCommit": "78cd0124dc0573819e169c432b45929efd933665", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM2NDcxOQ==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r462364719", "bodyText": "Yea, I agree. @cmccabe had a suggestion about adding Writable#close which would achieve the same goal. I think this would be nice and clean things up a bit. I'll open a follow up PR for this", "author": "mumrah", "createdAt": "2020-07-29T14:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwOTU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMDA0NA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r461210044", "bodyText": "Instead of the cast, could we add a validation check?", "author": "hachikuji", "createdAt": "2020-07-27T22:37:45Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchResponse.java", "diffHunk": "@@ -366,225 +255,128 @@ public FetchResponse(Errors error,\n                          LinkedHashMap<TopicPartition, PartitionData<T>> responseData,\n                          int throttleTimeMs,\n                          int sessionId) {\n-        this.error = error;\n-        this.responseData = responseData;\n-        this.throttleTimeMs = throttleTimeMs;\n-        this.sessionId = sessionId;\n+        this.data = toMessage(throttleTimeMs, error, responseData.entrySet().iterator(), sessionId);\n+        this.responseDataMap = responseData;\n     }\n \n-    public static FetchResponse<MemoryRecords> parse(Struct struct) {\n-        LinkedHashMap<TopicPartition, PartitionData<MemoryRecords>> responseData = new LinkedHashMap<>();\n-        for (Object topicResponseObj : struct.getArray(RESPONSES_KEY_NAME)) {\n-            Struct topicResponse = (Struct) topicResponseObj;\n-            String topic = topicResponse.get(TOPIC_NAME);\n-            for (Object partitionResponseObj : topicResponse.getArray(PARTITIONS_KEY_NAME)) {\n-                Struct partitionResponse = (Struct) partitionResponseObj;\n-                Struct partitionResponseHeader = partitionResponse.getStruct(PARTITION_HEADER_KEY_NAME);\n-                int partition = partitionResponseHeader.get(PARTITION_ID);\n-                Errors error = Errors.forCode(partitionResponseHeader.get(ERROR_CODE));\n-                long highWatermark = partitionResponseHeader.get(HIGH_WATERMARK);\n-                long lastStableOffset = partitionResponseHeader.getOrElse(LAST_STABLE_OFFSET, INVALID_LAST_STABLE_OFFSET);\n-                long logStartOffset = partitionResponseHeader.getOrElse(LOG_START_OFFSET, INVALID_LOG_START_OFFSET);\n-                Optional<Integer> preferredReadReplica = Optional.of(\n-                    partitionResponseHeader.getOrElse(PREFERRED_READ_REPLICA, INVALID_PREFERRED_REPLICA_ID)\n-                ).filter(Predicate.isEqual(INVALID_PREFERRED_REPLICA_ID).negate());\n-\n-                BaseRecords baseRecords = partitionResponse.getRecords(RECORD_SET_KEY_NAME);\n-                if (!(baseRecords instanceof MemoryRecords))\n-                    throw new IllegalStateException(\"Unknown records type found: \" + baseRecords.getClass());\n-                MemoryRecords records = (MemoryRecords) baseRecords;\n-\n-                List<AbortedTransaction> abortedTransactions = null;\n-                if (partitionResponseHeader.hasField(ABORTED_TRANSACTIONS_KEY_NAME)) {\n-                    Object[] abortedTransactionsArray = partitionResponseHeader.getArray(ABORTED_TRANSACTIONS_KEY_NAME);\n-                    if (abortedTransactionsArray != null) {\n-                        abortedTransactions = new ArrayList<>(abortedTransactionsArray.length);\n-                        for (Object abortedTransactionObj : abortedTransactionsArray) {\n-                            Struct abortedTransactionStruct = (Struct) abortedTransactionObj;\n-                            long producerId = abortedTransactionStruct.get(PRODUCER_ID);\n-                            long firstOffset = abortedTransactionStruct.get(FIRST_OFFSET);\n-                            abortedTransactions.add(new AbortedTransaction(producerId, firstOffset));\n-                        }\n-                    }\n-                }\n-\n-                PartitionData<MemoryRecords> partitionData = new PartitionData<>(error, highWatermark, lastStableOffset,\n-                        logStartOffset, preferredReadReplica, abortedTransactions, records);\n-                responseData.put(new TopicPartition(topic, partition), partitionData);\n-            }\n-        }\n-        return new FetchResponse<>(Errors.forCode(struct.getOrElse(ERROR_CODE, (short) 0)), responseData,\n-                struct.getOrElse(THROTTLE_TIME_MS, DEFAULT_THROTTLE_TIME), struct.getOrElse(SESSION_ID, INVALID_SESSION_ID));\n+    public FetchResponse(FetchResponseData fetchResponseData) {\n+        this.data = fetchResponseData;\n+        this.responseDataMap = toResponseDataMap(fetchResponseData);\n     }\n \n     @Override\n     public Struct toStruct(short version) {\n-        return toStruct(version, throttleTimeMs, error, responseData.entrySet().iterator(), sessionId);\n+        return data.toStruct(version);\n     }\n \n     @Override\n-    protected Send toSend(String dest, ResponseHeader responseHeader, short apiVersion) {\n-        Struct responseHeaderStruct = responseHeader.toStruct();\n-        Struct responseBodyStruct = toStruct(apiVersion);\n-\n-        // write the total size and the response header\n-        ByteBuffer buffer = ByteBuffer.allocate(responseHeaderStruct.sizeOf() + 4);\n-        buffer.putInt(responseHeaderStruct.sizeOf() + responseBodyStruct.sizeOf());\n-        responseHeaderStruct.writeTo(buffer);\n+    public Send toSend(String dest, ResponseHeader responseHeader, short apiVersion) {\n+        // Generate the Sends for the response fields and records\n+        ArrayDeque<Send> sends = new ArrayDeque<>();\n+        ObjectSerializationCache cache = new ObjectSerializationCache();\n+        int totalRecordSize = data.responses().stream()\n+                .flatMap(fetchableTopicResponse -> fetchableTopicResponse.partitionResponses().stream())\n+                .mapToInt(fetchablePartitionResponse -> fetchablePartitionResponse.recordSet().sizeInBytes())\n+                .sum();\n+        int totalMessageSize = data.size(cache, apiVersion);\n+\n+        RecordsWriter writer = new RecordsWriter(dest, totalMessageSize - totalRecordSize, sends::add);\n+        data.write(writer, cache, apiVersion);\n+        writer.flush();\n+\n+        // Compute the total size of all the Sends and write it out along with the header in the first Send\n+        ResponseHeaderData responseHeaderData = responseHeader.data();\n+\n+        int headerSize = responseHeaderData.size(cache, responseHeader.headerVersion());\n+        int bodySize = (int) sends.stream().mapToLong(Send::size).sum();", "originalCommit": "78cd0124dc0573819e169c432b45929efd933665", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM2NTQ3Mg==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r462365472", "bodyText": "Do you mean something like Math.toIntExact?", "author": "mumrah", "createdAt": "2020-07-29T14:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMDA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMTY1Nw==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r461211657", "bodyText": "I'm wondering if this should be ignorable. When this is set, the leader returns no data, so it relies crucially on the follower redirecting.", "author": "hachikuji", "createdAt": "2020-07-27T22:42:15Z", "path": "clients/src/main/resources/common/message/FetchResponse.json", "diffHunk": "@@ -43,37 +43,39 @@\n   \"fields\": [\n     { \"name\": \"ThrottleTimeMs\", \"type\": \"int32\", \"versions\": \"1+\", \"ignorable\": true,\n       \"about\": \"The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.\" },\n-    { \"name\": \"ErrorCode\", \"type\": \"int16\", \"versions\": \"7+\", \"ignorable\": false,\n+    { \"name\": \"ErrorCode\", \"type\": \"int16\", \"versions\": \"7+\", \"ignorable\": true,\n       \"about\": \"The top level response error code.\" },\n     { \"name\": \"SessionId\", \"type\": \"int32\", \"versions\": \"7+\", \"default\": \"0\", \"ignorable\": false,\n       \"about\": \"The fetch session ID, or 0 if this is not part of a fetch session.\" },\n-    { \"name\": \"Topics\", \"type\": \"[]FetchableTopicResponse\", \"versions\": \"0+\",\n+    { \"name\": \"Responses\", \"type\": \"[]FetchableTopicResponse\", \"versions\": \"0+\",\n       \"about\": \"The response topics.\", \"fields\": [\n-      { \"name\": \"Name\", \"type\": \"string\", \"versions\": \"0+\", \"entityType\": \"topicName\",\n+      { \"name\": \"Topic\", \"type\": \"string\", \"versions\": \"0+\", \"entityType\": \"topicName\",\n         \"about\": \"The topic name.\" },\n-      { \"name\": \"Partitions\", \"type\": \"[]FetchablePartitionResponse\", \"versions\": \"0+\",\n+      { \"name\": \"PartitionResponses\", \"type\": \"[]FetchablePartitionResponse\", \"versions\": \"0+\",\n         \"about\": \"The topic partitions.\", \"fields\": [\n-        { \"name\": \"PartitionIndex\", \"type\": \"int32\", \"versions\": \"0+\",\n-          \"about\": \"The partiiton index.\" },\n-        { \"name\": \"ErrorCode\", \"type\": \"int16\", \"versions\": \"0+\",\n-          \"about\": \"The error code, or 0 if there was no fetch error.\" },\n-        { \"name\": \"HighWatermark\", \"type\": \"int64\", \"versions\": \"0+\",\n-          \"about\": \"The current high water mark.\" },\n-        { \"name\": \"LastStableOffset\", \"type\": \"int64\", \"versions\": \"4+\", \"default\": \"-1\", \"ignorable\": true,\n-          \"about\": \"The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)\" },\n-        { \"name\": \"LogStartOffset\", \"type\": \"int64\", \"versions\": \"5+\", \"default\": \"-1\", \"ignorable\": true,\n-          \"about\": \"The current log start offset.\" },\n-        { \"name\": \"Aborted\", \"type\": \"[]AbortedTransaction\", \"versions\": \"4+\", \"nullableVersions\": \"4+\", \"ignorable\": false,\n-          \"about\": \"The aborted transactions.\",  \"fields\": [\n-          { \"name\": \"ProducerId\", \"type\": \"int64\", \"versions\": \"4+\", \"entityType\": \"producerId\",\n-            \"about\": \"The producer id associated with the aborted transaction.\" },\n-          { \"name\": \"FirstOffset\", \"type\": \"int64\", \"versions\": \"4+\",\n-            \"about\": \"The first offset in the aborted transaction.\" }\n+        { \"name\":  \"PartitionHeader\", \"type\": \"PartitionHeader\", \"versions\": \"0+\",\n+          \"fields\":  [\n+          { \"name\": \"Partition\", \"type\": \"int32\", \"versions\": \"0+\",\n+            \"about\": \"The partition index.\" },\n+          { \"name\": \"ErrorCode\", \"type\": \"int16\", \"versions\": \"0+\",\n+            \"about\": \"The error code, or 0 if there was no fetch error.\" },\n+          { \"name\": \"HighWatermark\", \"type\": \"int64\", \"versions\": \"0+\",\n+            \"about\": \"The current high water mark.\" },\n+          { \"name\": \"LastStableOffset\", \"type\": \"int64\", \"versions\": \"4+\", \"default\": \"-1\", \"ignorable\": true,\n+            \"about\": \"The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)\" },\n+          { \"name\": \"LogStartOffset\", \"type\": \"int64\", \"versions\": \"5+\", \"default\": \"-1\", \"ignorable\": true,\n+            \"about\": \"The current log start offset.\" },\n+          { \"name\": \"AbortedTransactions\", \"type\": \"[]AbortedTransaction\", \"versions\": \"4+\", \"nullableVersions\": \"4+\", \"ignorable\": true,\n+            \"about\": \"The aborted transactions.\",  \"fields\": [\n+            { \"name\": \"ProducerId\", \"type\": \"int64\", \"versions\": \"4+\", \"entityType\": \"producerId\",\n+              \"about\": \"The producer id associated with the aborted transaction.\" },\n+            { \"name\": \"FirstOffset\", \"type\": \"int64\", \"versions\": \"4+\",\n+              \"about\": \"The first offset in the aborted transaction.\" }\n+          ]},\n+          { \"name\": \"PreferredReadReplica\", \"type\": \"int32\", \"versions\": \"11+\", \"default\": \"-1\", \"ignorable\": true,", "originalCommit": "78cd0124dc0573819e169c432b45929efd933665", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQxODY1OA==", "url": "https://github.com/apache/kafka/pull/9008#discussion_r462418658", "bodyText": "I see what you mean. If we have a bug that causes us to hit the preferred replica code for an older api version, we should fail to serialize the message rather than sending it to a client that doesn't understand follower redirection.\nGood catch.", "author": "mumrah", "createdAt": "2020-07-29T16:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMTY1Nw=="}], "type": "inlineReview"}, {"oid": "507eb047ba0f652f7781d80e35c8d8c262ccb9f5", "url": "https://github.com/apache/kafka/commit/507eb047ba0f652f7781d80e35c8d8c262ccb9f5", "message": "PR feedback", "committedDate": "2020-07-29T16:31:05Z", "type": "commit"}]}