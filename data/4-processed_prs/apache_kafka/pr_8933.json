{"pr_number": 8933, "pr_title": "KAFKA-10163; Throttle Create Topic, Create Partition and Delete Topic Operations (KIP-599, Part I, Broker Changes)", "pr_createdAt": "2020-06-26T12:43:58Z", "pr_url": "https://github.com/apache/kafka/pull/8933", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE2ODk0NA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r446168944", "bodyText": "The various quota enforcement types that can be used with a Sensor.", "author": "dajac", "createdAt": "2020-06-26T13:00:39Z", "path": "clients/src/main/java/org/apache/kafka/common/metrics/Sensor.java", "diffHunk": "@@ -97,7 +97,25 @@ public static RecordingLevel forName(String name) {\n         public boolean shouldRecord(final int configId) {\n             return configId == DEBUG.id || configId == this.id;\n         }\n+    }\n \n+    public enum QuotaEnforcementType {\n+        /**\n+         * The quota is not enforced.\n+         */\n+        NONE,\n+\n+        /**\n+         * The quota is enforced before updating the sensor. An update\n+         * is rejected if the quota is already exhausted.\n+         */\n+        STRICT,\n+\n+        /**\n+         * The quota is enforced after updating the sensor. An update\n+         * is always accepted even if the quota is already exhausted.\n+         */\n+        PERMISSIVE", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE2OTgwOQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r446169809", "bodyText": "I have refactored the ClientQuotaManager to be a bit more generic and to accept a quota enforcement type.", "author": "dajac", "createdAt": "2020-06-26T13:02:23Z", "path": "core/src/main/scala/kafka/server/ClientQuotaManager.scala", "diffHunk": "@@ -154,32 +180,40 @@ object ClientQuotaManager {\n  * @param config @ClientQuotaManagerConfig quota configs\n  * @param metrics @Metrics Metrics instance\n  * @param quotaType Quota type of this quota manager\n+ * @param quotaEnforcementType Quota enforcement type of this quota manager. Refers to the\n+ *                             documentation of {recordAndGetThrottleTimeMs} for details\n  * @param time @Time object to use\n+ * @param threadNamePrefix The thread prefix to use\n+ * @param clientQuotaCallback An optional @ClientQuotaCallback\n  */\n class ClientQuotaManager(private val config: ClientQuotaManagerConfig,\n                          private val metrics: Metrics,\n                          private val quotaType: QuotaType,\n+                         private val quotaEnforcementType: QuotaEnforcementType,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3MTg4MA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456371880", "bodyText": "It looks like we don't need this change since the only one that sets a different type does its own thing.", "author": "rajinisivaram", "createdAt": "2020-07-17T10:57:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE2OTgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQyMzk4Ng==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456423986", "bodyText": "Yes, you are right. I was trying to make ClientQuotaManager a generic base class for all client quotas. I will still try to extract the real common parts in a base class once but that will be for a follow-up PR.", "author": "dajac", "createdAt": "2020-07-17T12:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE2OTgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE3Njg1MA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r446176850", "bodyText": "I have introduced a new construct here in order to make the integration as lightweight as possible: ControllerMutationQuota. It is a small wrapper around the Sensor of a given user/clientId which wraps the quota enforcement and the computation of the throttle time. Three implementations are available: StrictControllerMutationQuota that is used for new clients, PermissiveControllerMutationQuota that is used for old clients, and UnboundedControllerMutationQuota that is used when no quota is set.\nThe ControllerMutationQuota object is then passed to the AdminManager to enforce the quota and later used to compute the final throttle time before sending the response. At this point, the request quota is also computed and the highest one is used.", "author": "dajac", "createdAt": "2020-06-26T13:16:11Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1684,25 +1685,29 @@ class KafkaApis(val requestChannel: RequestChannel,\n   }\n \n   def handleCreateTopicsRequest(request: RequestChannel.Request): Unit = {\n+    // Since version 6 of the API, the quota is strictly enforced. Any topic creation\n+    // above the quota is not allowed and rejected with a THROTTLING_QUOTA_EXCEEDED error.\n+    val controllerMutationQuota = quotas.controllerMutation.newQuotaFor(request, 6)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2Nzk0MA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455867940", "bodyText": "nit: quotas.controllerMutation.newQuotaFor(request, strictSinceVersion=6). Then we can move the comment to the method.", "author": "rajinisivaram", "createdAt": "2020-07-16T15:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE3Njg1MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5NjAzNQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455796035", "bodyText": "Do we really need this? I didn't find the naming of the types very intuitive. We have different variations on the usage of the APIs. But given that we have a public API that enables us to check quotas and another to record with or without the check, we could just use the existing APIs? For example, we already have record without checking quota, we have record with check quota, we have record followed by unrecord. And now we want to check without recording. It seems simpler to leave it to the quota manager to record zero with  checkQuotas first and then record the value without checkQuotas if the first one succeeds.", "author": "rajinisivaram", "createdAt": "2020-07-16T13:43:51Z", "path": "clients/src/main/java/org/apache/kafka/common/metrics/Sensor.java", "diffHunk": "@@ -97,7 +97,25 @@ public static RecordingLevel forName(String name) {\n         public boolean shouldRecord(final int configId) {\n             return configId == DEBUG.id || configId == this.id;\n         }\n+    }\n \n+    public enum QuotaEnforcementType {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2NjI1Mg==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456266252", "bodyText": "I think that we do. I actually did exactly what you suggest in the first place but then realised that it introduces a race condition. For instance, two requests processed in two separate threads can verify the quota at the same time. If it is below the authorized quota, they would go ahead, record the value, and do the creation/deletion. That violates the strict enforcement of the quota as we don't want to accept a creation/deletion if the quota is already violated. In this case, the first request must succeed while the second must fail.\nThe proposed approach allows to do the quota verification and the recording within the sensor lock. That basically allows us to record the value iif the quota is not already violated.\nThis is probably less an issue for our existing quotas because we always accept requests, even if the quota is already violated.\nRegarding the naming, we may find better ones. Would you have any suggestions?", "author": "dajac", "createdAt": "2020-07-17T07:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5NjAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3NzE3Mg==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456377172", "bodyText": "Thanks for the explanation, makes sense.\nNot sure about a better name, but it seems to me that we are changing a boolean checkQuotas=true|false to an enum that says checkQuotas=false|before|after. Perhaps something that makes that clearer.", "author": "rajinisivaram", "createdAt": "2020-07-17T11:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5NjAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQxNTU3Ng==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456415576", "bodyText": "On one side, we have names that describe how the quota enforcement behave, and on the other side, we have names that describe where the quota is enforced. I personally lean towards the current proposal but I an open to discuss this. My reasoning is that the current proposal is aligned with the naming in the quota manager as well. That makes the overall more consistent IMO.", "author": "dajac", "createdAt": "2020-07-17T12:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5NjAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgyNjc4MA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455826780", "bodyText": "Where is this validation done now?", "author": "rajinisivaram", "createdAt": "2020-07-16T14:25:03Z", "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -101,12 +148,6 @@ class AdminManager(val config: KafkaConfig,\n         if (nullConfigs.nonEmpty)\n           throw new InvalidRequestException(s\"Null value not supported for topic configs : ${nullConfigs.mkString(\",\")}\")\n \n-        val configs = new Properties()\n-        topic.configs.forEach { entry =>\n-          configs.setProperty(entry.name, entry.value)\n-        }\n-        LogConfig.validate(configs)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2NzI2Mg==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456267262", "bodyText": "This is done in validateTopicCreate (last line). Actually, I found out that we were validating the LogConfig twice before.", "author": "dajac", "createdAt": "2020-07-17T07:27:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgyNjc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgzMjcwNg==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455832706", "bodyText": "Shouldn't validateOnly tell you know much you would have been throttled?", "author": "rajinisivaram", "createdAt": "2020-07-16T14:32:14Z", "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -295,34 +312,44 @@ class AdminManager(val config: KafkaConfig,\n           throw new InvalidPartitionsException(s\"Topic already has $oldNumPartitions partitions.\")\n         }\n \n-        val newPartitionsAssignment = Option(newPartition.assignments)\n-          .map { assignmentMap =>\n-            val assignments = assignmentMap.asScala.map {\n-              createPartitionAssignment => createPartitionAssignment.brokerIds.asScala.map(_.toInt)\n-            }\n-            val unknownBrokers = assignments.flatten.toSet -- allBrokerIds\n-            if (unknownBrokers.nonEmpty)\n-              throw new InvalidReplicaAssignmentException(\n-                s\"Unknown broker(s) in replica assignment: ${unknownBrokers.mkString(\", \")}.\")\n-\n-            if (assignments.size != numPartitionsIncrement)\n-              throw new InvalidReplicaAssignmentException(\n-                s\"Increasing the number of partitions by $numPartitionsIncrement \" +\n-                  s\"but ${assignments.size} assignments provided.\")\n-\n-            assignments.zipWithIndex.map { case (replicas, index) =>\n-              existingAssignment.size + index -> replicas\n-            }.toMap\n+        val newPartitionsAssignment = Option(newPartition.assignments).map { assignmentMap =>\n+          val assignments = assignmentMap.asScala.map {\n+            createPartitionAssignment => createPartitionAssignment.brokerIds.asScala.map(_.toInt)\n+          }\n+          val unknownBrokers = assignments.flatten.toSet -- allBrokerIds\n+          if (unknownBrokers.nonEmpty)\n+            throw new InvalidReplicaAssignmentException(\n+              s\"Unknown broker(s) in replica assignment: ${unknownBrokers.mkString(\", \")}.\")\n+\n+          if (assignments.size != numPartitionsIncrement)\n+            throw new InvalidReplicaAssignmentException(\n+              s\"Increasing the number of partitions by $numPartitionsIncrement \" +\n+                s\"but ${assignments.size} assignments provided.\")\n+\n+          assignments.zipWithIndex.map { case (replicas, index) =>\n+            existingAssignment.size + index -> replicas\n+          }.toMap\n         }\n \n-        val updatedReplicaAssignment = adminZkClient.addPartitions(topic, existingAssignment, allBrokers,\n-          newPartition.count, newPartitionsAssignment, validateOnly = validateOnly)\n-        CreatePartitionsMetadata(topic, updatedReplicaAssignment.keySet, ApiError.NONE)\n+        val assignmentForNewPartitions = adminZkClient.createNewPartitionsAssignment(\n+          topic, existingAssignment, allBrokers, newPartition.count, newPartitionsAssignment)\n+\n+        if (validateOnly) {\n+          CreatePartitionsMetadata(topic, (existingAssignment ++ assignmentForNewPartitions).keySet)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzE3NA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456273174", "bodyText": "That's a great question. If I remember correctly, someone brought this up in the DISCUSS thread a while back.\nThe main issue is that we can't use the throttleTimeMs field to give back this information to the client because the java client would consider this as a quota violation and would throttle the connection. If we want to do this, we would need to find another way to convey this to the client. I don't think that it is worth it.\nMoreover, as the validation of the request doesn't not entail any creations nor deletions, I would find strange to actually return ThrottlingQuotaExceededException with a throttleTimeMs to the client. ThrottlingQuotaExceededException would actually mean \"the validation has passed but you would have been throttled if you would have executed that request\" which is not intuitive if you care about validating the request only.", "author": "dajac", "createdAt": "2020-07-17T07:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgzMjcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgzNzk4Ng==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455837986", "bodyText": "Doesn't return anything?", "author": "rajinisivaram", "createdAt": "2020-07-16T14:38:59Z", "path": "core/src/main/scala/kafka/server/ClientQuotaManager.scala", "diffHunk": "@@ -234,55 +266,85 @@ class ClientQuotaManager(private val config: ClientQuotaManagerConfig,\n   }\n \n   /**\n-   * Returns maximum value (produced/consume bytes or request processing time) that could be recorded without guaranteed throttling.\n-   * Recording any larger value will always be throttled, even if no other values were recorded in the quota window.\n-   * This is used for deciding the maximum bytes that can be fetched at once\n+   * Records that a user/clientId accumulated or would like to accumulate the provided amount at the\n+   * the specified time, returns throttle time in milliseconds. Depending on the {QuotaEnforcementType}\n+   * used, the behavior of this method changes:\n+   * - QuotaEnforcementType.Strict verifies the quota is not violated before accumulating the\n+   *   provided value. If it is, the value is not accumulated and the throttle time represents\n+   *   the time to wait before the quota comes back to the defined limit.\n+   * - QuotaEnforcementType.PERMISSIVE verifies the quota is not violated after accumulating the\n+   *   provided value. If it is, the value is still accumulated and the throttle time represents\n+   *   the time to wait before the quota comes back to the defined limit.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @param value The value to accumulate\n+   * @param timeMs The time at which to accumulate the value\n+   * @return The throttle time in milliseconds defines as the time to wait until the average\n+   *         rate gets back to the defined quota\n    */\n-  def getMaxValueInQuotaWindow(session: Session, clientId: String): Double = {\n-    if (quotasEnabled) {\n-      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n-      Option(quotaCallback.quotaLimit(clientQuotaType, clientSensors.metricTags.asJava))\n-        .map(_.toDouble * (config.numQuotaSamples - 1) * config.quotaWindowSizeSeconds)\n-        .getOrElse(Double.MaxValue)\n-    } else {\n-      Double.MaxValue\n-    }\n-  }\n-\n   def recordAndGetThrottleTimeMs(session: Session, clientId: String, value: Double, timeMs: Long): Int = {\n     val clientSensors = getOrCreateQuotaSensors(session, clientId)\n     try {\n-      clientSensors.quotaSensor.record(value, timeMs)\n+      clientSensors.quotaSensor.record(value, timeMs, quotaEnforcementType)\n       0\n     } catch {\n       case e: QuotaViolationException =>\n-        val throttleTimeMs = throttleTime(e.value, e.bound, windowSize(e.metric, timeMs)).toInt\n+        val throttleTimeMs = throttleTime(e, timeMs).toInt\n         debug(s\"Quota violated for sensor (${clientSensors.quotaSensor.name}). Delay time: ($throttleTimeMs)\")\n         throttleTimeMs\n     }\n   }\n \n-  /** \"Unrecord\" the given value that has already been recorded for the given user/client by recording a negative value\n-    * of the same quantity.\n-    *\n-    * For a throttled fetch, the broker should return an empty response and thus should not record the value. Ideally,\n-    * we would like to compute the throttle time before actually recording the value, but the current Sensor code\n-    * couples value recording and quota checking very tightly. As a workaround, we will unrecord the value for the fetch\n-    * in case of throttling. Rate keeps the sum of values that fall in each time window, so this should bring the\n-    * overall sum back to the previous value.\n-    */\n+  /**\n+   * Records that a user/clientId changed some metric being throttled without checking for\n+   * quota violation. The aggregate value will subsequently be used for throttling when the\n+   * next request is processed.\n+   */\n+  def recordNoThrottle(session: Session, clientId: String, value: Double): Unit = {\n+    val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+    clientSensors.quotaSensor.record(value, time.milliseconds(), QuotaEnforcementType.NONE)\n+  }\n+\n+  /**\n+   * \"Unrecord\" the given value that has already been recorded for the given user/client by recording a negative value\n+   * of the same quantity.\n+   *\n+   * For a throttled fetch, the broker should return an empty response and thus should not record the value. Ideally,\n+   * we would like to compute the throttle time before actually recording the value, but the current Sensor code\n+   * couples value recording and quota checking very tightly. As a workaround, we will unrecord the value for the fetch\n+   * in case of throttling. Rate keeps the sum of values that fall in each time window, so this should bring the\n+   * overall sum back to the previous value.\n+   */\n   def unrecordQuotaSensor(request: RequestChannel.Request, value: Double, timeMs: Long): Unit = {\n     val clientSensors = getOrCreateQuotaSensors(request.session, request.header.clientId)\n-    clientSensors.quotaSensor.record(value * (-1), timeMs, false)\n+    clientSensors.quotaSensor.record(value * (-1), timeMs, QuotaEnforcementType.NONE)\n   }\n \n   /**\n-    * Throttle a client by muting the associated channel for the given throttle time.\n-    * @param request client request\n-    * @param throttleTimeMs Duration in milliseconds for which the channel is to be muted.\n-    * @param channelThrottlingCallback Callback for channel throttling\n-    * @return ThrottledChannel object\n-    */\n+   * Returns maximum value that could be recorded without guaranteed throttling.\n+   * Recording any larger value will always be throttled, even if no other values were recorded in the quota window.\n+   * This is used for deciding the maximum bytes that can be fetched at once\n+   */\n+  def getMaxValueInQuotaWindow(session: Session, clientId: String): Double = {\n+    if (quotasEnabled) {\n+      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+      Option(quotaCallback.quotaLimit(clientQuotaType, clientSensors.metricTags.asJava))\n+        .map(_.toDouble * (config.numQuotaSamples - 1) * config.quotaWindowSizeSeconds)\n+        .getOrElse(Double.MaxValue)\n+    } else {\n+      Double.MaxValue\n+    }\n+  }\n+\n+  /**\n+   * Throttle a client by muting the associated channel for the given throttle time.\n+   *\n+   * @param request client request\n+   * @param throttleTimeMs Duration in milliseconds for which the channel is to be muted.\n+   * @param channelThrottlingCallback Callback for channel throttling\n+   * @return ThrottledChannel object", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzY0NQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456273645", "bodyText": "Indeed, good catch.", "author": "dajac", "createdAt": "2020-07-17T07:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgzNzk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0MTAzMA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455841030", "bodyText": "We might as well move the name to the companion object above since it is a constant?", "author": "rajinisivaram", "createdAt": "2020-07-16T14:43:05Z", "path": "core/src/main/scala/kafka/server/ClientRequestQuotaManager.scala", "diffHunk": "@@ -20,21 +20,32 @@ import java.util.concurrent.TimeUnit\n \n import kafka.network.RequestChannel\n import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.metrics.Sensor.QuotaEnforcementType\n import org.apache.kafka.common.metrics._\n import org.apache.kafka.common.utils.Time\n import org.apache.kafka.server.quota.ClientQuotaCallback\n \n import scala.jdk.CollectionConverters._\n \n+object ClientRequestQuotaManager {\n+  val QuotaRequestPercentDefault = Int.MaxValue.toDouble\n+  val NanosToPercentagePerSecond = 100.0 / TimeUnit.SECONDS.toNanos(1)\n+}\n \n class ClientRequestQuotaManager(private val config: ClientQuotaManagerConfig,\n                                 private val metrics: Metrics,\n                                 private val time: Time,\n-                                threadNamePrefix: String,\n-                                quotaCallback: Option[ClientQuotaCallback])\n-                                extends ClientQuotaManager(config, metrics, QuotaType.Request, time, threadNamePrefix, quotaCallback) {\n-  val maxThrottleTimeMs = TimeUnit.SECONDS.toMillis(this.config.quotaWindowSizeSeconds)\n-  def exemptSensor = getOrCreateSensor(exemptSensorName, exemptMetricName)\n+                                private val threadNamePrefix: String,\n+                                private val quotaCallback: Option[ClientQuotaCallback])\n+    extends ClientQuotaManager(config, metrics, QuotaType.Request, QuotaEnforcementType.PERMISSIVE,\n+      time, threadNamePrefix, quotaCallback) {\n+\n+  private val maxThrottleTimeMs = TimeUnit.SECONDS.toMillis(this.config.quotaWindowSizeSeconds)\n+  private val exemptMetricName = metrics.metricName(\"exempt-request-time\",\n+    QuotaType.Request.toString, \"Tracking exempt-request-time utilization percentage\")\n+  private val exemptSensorName = \"exempt-\" + QuotaType.Request", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3NTY2NA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456275664", "bodyText": "Yes", "author": "dajac", "createdAt": "2020-07-17T07:45:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0MTAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0NDQ0Nw==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455844447", "bodyText": "nit: maybe use the same record terminology we use elsewhere?", "author": "rajinisivaram", "createdAt": "2020-07-16T14:47:43Z", "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.metrics.Sensor.QuotaEnforcementType\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def accept(permits: Double): Unit", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3Njc1Mw==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456276753", "bodyText": "Yes, that makes sense. I initially went with accept to make it clear that it could be refused but record is fine as well.", "author": "dajac", "createdAt": "2020-07-17T07:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0NDQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0OTQ0MQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455849441", "bodyText": "We should include Request in the names of these traits and associated classes since these are per-request.", "author": "rajinisivaram", "createdAt": "2020-07-16T14:54:18Z", "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.metrics.Sensor.QuotaEnforcementType\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3ODAzOQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456278039", "bodyText": "I am not entirely sold on this one. Do you suggest to use something like ControllerMutationRequestQuota? My intent was to replace Request by Mutation here as the quota is actually enforced by mutation within a request. We could perhaps use ControllerRequestQuota though. How do you see this?", "author": "dajac", "createdAt": "2020-07-17T07:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0OTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUwMTI1MQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456501251", "bodyText": "Sorry, Mutation is fine, and we dont want to sayRequestQuota since request quota is already a thing. My concern was that we have quotas which apply to entities like users over a period of time. But this seems to be something that is relevant to a specific request.", "author": "rajinisivaram", "createdAt": "2020-07-17T15:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0OTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1MTQ2MA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455851460", "bodyText": "Are these called lastXXX because we can record multiple times and we are interested in the last value?", "author": "rajinisivaram", "createdAt": "2020-07-16T14:56:58Z", "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.metrics.Sensor.QuotaEnforcementType\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def accept(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def accept(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor) extends ControllerMutationQuota {\n+\n+  private var lastThrottleTimeMs = 0L\n+  private var lastRecordedTimeMs = 0L", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3OTE5Ng==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456279196", "bodyText": "That is correct. They are basically updated every time record (formally accept) is called if the quota is violated. We keep only the last one because it gives the fresher information about how long is required to bring back the average rate to the quota.", "author": "dajac", "createdAt": "2020-07-17T07:52:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1MTQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NDgwMA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455854800", "bodyText": "Not sure how this works. We calculated throtle time before creating a topic. Then spent some time using up CPU to create the topic. Are we saying that we should throttle less because the request used up time?", "author": "rajinisivaram", "createdAt": "2020-07-16T15:01:23Z", "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.metrics.Sensor.QuotaEnforcementType\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def accept(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def accept(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor) extends ControllerMutationQuota {\n+\n+  private var lastThrottleTimeMs = 0L\n+  private var lastRecordedTimeMs = 0L\n+\n+  override def isExceeded: Boolean = lastThrottleTimeMs > 0\n+\n+  override def accept(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor.record(permits, timeMs, QuotaEnforcementType.STRICT)\n+    } catch {\n+      case e: QuotaViolationException =>\n+        lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+        lastRecordedTimeMs = timeMs\n+        throw new ThrottlingQuotaExceededException(lastThrottleTimeMs.toInt,\n+          Errors.THROTTLING_QUOTA_EXCEEDED.message)\n+    }\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it (e.g. when creating topics).\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4MjQ5MA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456282490", "bodyText": "I realized that I could have better explained this in the comment. I actually do this to deduce the time that the request spent waiting in the purgatory.\nLet's take an example. A CreateTopicsRequest with two topics may be able to create the first topic while the second is refused due to a quota exception with, say a throttling time of 5s. Then the request goes to the purgatory waiting until the first topic is created. That could take few seconds or even longer that the actual throttle time. In the latter case, we want the let the client retries immediately. Therefore, I deduce the time between the last recorded throttle time and now to reflect that.", "author": "dajac", "createdAt": "2020-07-17T07:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NDgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NTg2Mw==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455855863", "bodyText": "Looks pretty identical to StrictControllerMutationQuota apart from the enforcement type, can we reuse code?", "author": "rajinisivaram", "createdAt": "2020-07-16T15:02:55Z", "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.metrics.Sensor.QuotaEnforcementType\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def accept(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def accept(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor) extends ControllerMutationQuota {\n+\n+  private var lastThrottleTimeMs = 0L\n+  private var lastRecordedTimeMs = 0L\n+\n+  override def isExceeded: Boolean = lastThrottleTimeMs > 0\n+\n+  override def accept(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor.record(permits, timeMs, QuotaEnforcementType.STRICT)\n+    } catch {\n+      case e: QuotaViolationException =>\n+        lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+        lastRecordedTimeMs = timeMs\n+        throw new ThrottlingQuotaExceededException(lastThrottleTimeMs.toInt,\n+          Errors.THROTTLING_QUOTA_EXCEEDED.message)\n+    }\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it (e.g. when creating topics).\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt\n+  }\n+}\n+\n+/**\n+ * The PermissiveControllerMutationQuota defines a permissive quota for a given user/clientId pair.\n+ * The quota is permissive meaning that it does accept any mutations even if the quota is exhausted.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class PermissiveControllerMutationQuota(private val time: Time,\n+                                        private val quotaSensor: Sensor) extends ControllerMutationQuota {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MzEyMQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456293121", "bodyText": "Let me try to extract the common bits into a base class.", "author": "dajac", "createdAt": "2020-07-17T08:19:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NTg2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQxNTg3Ng==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456415876", "bodyText": "I have extracted the common bits into a base class. Let me know if that works for you.", "author": "dajac", "createdAt": "2020-07-17T12:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NTg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2ODM5MQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455868391", "bodyText": "As before, use named argument for strictSinceVersion and comment not necessary here?", "author": "rajinisivaram", "createdAt": "2020-07-16T15:20:05Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1746,21 +1751,26 @@ class KafkaApis(val requestChannel: RequestChannel,\n             result.setConfigs(List.empty.asJava)\n               .setNumPartitions(-1)\n               .setReplicationFactor(-1)\n-              .setTopicConfigErrorCode(0.toShort)\n+              .setTopicConfigErrorCode(Errors.NONE.code)\n           }\n         }\n         sendResponseCallback(results)\n       }\n-      adminManager.createTopics(createTopicsRequest.data.timeoutMs,\n-          createTopicsRequest.data.validateOnly,\n-          toCreate,\n-          authorizedForDescribeConfigs,\n-          handleCreateTopicsResults)\n+      adminManager.createTopics(\n+        createTopicsRequest.data.timeoutMs,\n+        createTopicsRequest.data.validateOnly,\n+        toCreate,\n+        authorizedForDescribeConfigs,\n+        controllerMutationQuota,\n+        handleCreateTopicsResults)\n     }\n   }\n \n   def handleCreatePartitionsRequest(request: RequestChannel.Request): Unit = {\n     val createPartitionsRequest = request.body[CreatePartitionsRequest]\n+    // Since version 3 of the API, the quota is strictly enforced. Any partition creation\n+    // above the quota is not allowed and rejected with a THROTTLING_QUOTA_EXCEEDED error.\n+    val controllerMutationQuota = quotas.controllerMutation.newQuotaFor(request, 3)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTkxNQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456295915", "bodyText": "Yeah, that is a good idea.", "author": "dajac", "createdAt": "2020-07-17T08:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2ODM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2ODk0OA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455868948", "bodyText": "Named argument for strictSinceVersion", "author": "rajinisivaram", "createdAt": "2020-07-16T15:20:50Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1803,14 +1813,20 @@ class KafkaApis(val requestChannel: RequestChannel,\n         unauthorized.map(_.name -> new ApiError(Errors.TOPIC_AUTHORIZATION_FAILED, \"The topic authorization is failed.\")) ++\n         queuedForDeletion.map(_.name -> new ApiError(Errors.INVALID_TOPIC_EXCEPTION, \"The topic is queued for deletion.\"))\n \n-      adminManager.createPartitions(createPartitionsRequest.data.timeoutMs,\n+      adminManager.createPartitions(\n+        createPartitionsRequest.data.timeoutMs,\n         valid,\n         createPartitionsRequest.data.validateOnly,\n-        request.context.listenerName, result => sendResponseCallback(result ++ errors))\n+        controllerMutationQuota,\n+        result => sendResponseCallback(result ++ errors))\n     }\n   }\n \n   def handleDeleteTopicsRequest(request: RequestChannel.Request): Unit = {\n+    // Since version 5 of the API, the quota is strictly enforced. Any topic deletion\n+    // above the quota is not allowed and rejected with a THROTTLING_QUOTA_EXCEEDED error.\n+    val controllerMutationQuota = quotas.controllerMutation.newQuotaFor(request, 5)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2OTg2OQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455869869", "bodyText": "nit: Make the last argument a default arg or use named argument since it is not clear what None is.", "author": "rajinisivaram", "createdAt": "2020-07-16T15:22:08Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1777,7 +1787,7 @@ class KafkaApis(val requestChannel: RequestChannel,\n           s\"client ${request.header.clientId}.\")\n         responseBody\n       }\n-      sendResponseMaybeThrottle(request, createResponse)\n+      sendResponseMaybeThrottle(controllerMutationQuota, request, createResponse, None)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwMDIxMw==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456300213", "bodyText": "Ack. I went with the later.", "author": "dajac", "createdAt": "2020-07-17T08:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2OTg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2OTg3MQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455869871", "bodyText": "nit: Make the last argument a default arg or use named argument since it is not clear what None is.", "author": "rajinisivaram", "createdAt": "2020-07-16T15:22:09Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1777,7 +1787,7 @@ class KafkaApis(val requestChannel: RequestChannel,\n           s\"client ${request.header.clientId}.\")\n         responseBody\n       }\n-      sendResponseMaybeThrottle(request, createResponse)\n+      sendResponseMaybeThrottle(controllerMutationQuota, request, createResponse, None)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg3Njc1NA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455876754", "bodyText": "Can we test using mock time or a different approach that doesn't need these long sleeps?", "author": "rajinisivaram", "createdAt": "2020-07-16T15:31:35Z", "path": "core/src/test/scala/unit/kafka/server/ControllerMutationQuotaTest.scala", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ **/\n+package kafka.server\n+\n+import java.util.Properties\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+\n+import kafka.utils.TestUtils\n+import org.apache.kafka.common.internals.KafkaFutureImpl\n+import org.apache.kafka.common.message.CreatePartitionsRequestData\n+import org.apache.kafka.common.message.CreatePartitionsRequestData.CreatePartitionsTopic\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.message.DeleteTopicsRequestData\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.quota.ClientQuotaAlteration\n+import org.apache.kafka.common.quota.ClientQuotaEntity\n+import org.apache.kafka.common.requests.AlterClientQuotasRequest\n+import org.apache.kafka.common.requests.AlterClientQuotasResponse\n+import org.apache.kafka.common.requests.CreatePartitionsRequest\n+import org.apache.kafka.common.requests.CreatePartitionsResponse\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.requests.CreateTopicsResponse\n+import org.apache.kafka.common.requests.DeleteTopicsRequest\n+import org.apache.kafka.common.requests.DeleteTopicsResponse\n+import org.apache.kafka.common.security.auth.AuthenticationContext\n+import org.apache.kafka.common.security.auth.KafkaPrincipal\n+import org.apache.kafka.common.security.auth.KafkaPrincipalBuilder\n+import org.junit.Assert.assertEquals\n+import org.junit.Assert.assertTrue\n+import org.junit.Before\n+import org.junit.Test\n+\n+import scala.jdk.CollectionConverters._\n+\n+object ControllerMutationQuotaTest {\n+  // Principal used for all client connections. This is updated by each test.\n+  var principal = KafkaPrincipal.ANONYMOUS\n+  class TestPrincipalBuilder extends KafkaPrincipalBuilder {\n+    override def build(context: AuthenticationContext): KafkaPrincipal = {\n+      principal\n+    }\n+  }\n+\n+  def asPrincipal(newPrincipal: KafkaPrincipal)(f: => Unit): Unit = {\n+    val currentPrincipal = principal\n+    principal = newPrincipal\n+    try f\n+    finally principal = currentPrincipal\n+  }\n+\n+  val ThrottledPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"ThrottledPrincipal\")\n+  val UnboundedPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"UnboundedPrincipal\")\n+\n+  val StrictCreateTopicsRequestVersion = ApiKeys.CREATE_TOPICS.latestVersion\n+  val PermissiveCreateTopicsRequestVersion = 5.toShort\n+\n+  val StrictDeleteTopicsRequestVersion = ApiKeys.DELETE_TOPICS.latestVersion\n+  val PermissiveDeleteTopicsRequestVersion = 4.toShort\n+\n+  val StrictCreatePartitionsRequestVersion = ApiKeys.CREATE_PARTITIONS.latestVersion\n+  val PermissiveCreatePartitionsRequestVersion = 2.toShort\n+\n+  val TopicsWithOnePartition = Seq(\"topic-1\" ->  1, \"topic-2\" ->  1)\n+  val TopicsWith30Partitions = Seq(\"topic-1\" -> 30, \"topic-2\" -> 30)\n+  val TopicsWith31Partitions = Seq(\"topic-1\" -> 31, \"topic-2\" -> 31)\n+\n+  val ControllerMutationRate = 2.0\n+}\n+\n+class ControllerMutationQuotaTest extends BaseRequestTest {\n+  import ControllerMutationQuotaTest._\n+\n+  override def brokerCount: Int = 1\n+\n+  override def brokerPropertyOverrides(properties: Properties): Unit = {\n+    properties.put(KafkaConfig.ControlledShutdownEnableProp, \"false\")\n+    properties.put(KafkaConfig.OffsetsTopicReplicationFactorProp, \"1\")\n+    properties.put(KafkaConfig.OffsetsTopicPartitionsProp, \"1\")\n+    properties.put(KafkaConfig.PrincipalBuilderClassProp,\n+      classOf[ControllerMutationQuotaTest.TestPrincipalBuilder].getName)\n+    // We use the default number of samples and window size.\n+    properties.put(KafkaConfig.NumControllerQuotaSamplesProp, \"11\")\n+    properties.put(KafkaConfig.ControllerQuotaWindowSizeSecondsProp, \"1\")\n+  }\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    // Define a quota for ThrottledPrincipal\n+    defineUserQuota(ThrottledPrincipal.getName, Some(ControllerMutationRate))\n+    waitUserQuota(ThrottledPrincipal.getName, ControllerMutationRate)\n+  }\n+\n+  @Test\n+  def testSetUnsetQuota(): Unit = {\n+    val principal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"User\")\n+    // Default Value\n+    waitUserQuota(principal.getName, Long.MaxValue)\n+    // Define a new quota\n+    defineUserQuota(principal.getName, Some(ControllerMutationRate))\n+    // Check it\n+    waitUserQuota(principal.getName, ControllerMutationRate)\n+    // Remove it\n+    defineUserQuota(principal.getName, None)\n+    // Back to the default\n+    waitUserQuota(principal.getName, Long.MaxValue)\n+  }\n+\n+  @Test\n+  def testStrictCreateTopicsRequest(): Unit = {\n+    asPrincipal(ThrottledPrincipal) {\n+      // Create two topics worth of 30 partitions each. As we use a strict quota, we\n+      // expect the first topic to be created and the second to be rejected.\n+      // Theoretically, the throttle time should be bellow or equal to:\n+      // ((30 / 10) - 2) / 2 * 10 = 5s\n+      val (throttleTimeMs1, errors1) = createTopics(TopicsWith30Partitions, StrictCreateTopicsRequestVersion)\n+      assertTrue((5000 - throttleTimeMs1) < 1000)\n+      assertEquals(Seq(Errors.NONE, Errors.THROTTLING_QUOTA_EXCEEDED), errors1)\n+\n+      // The implementation of the Rate has NOT been changed yet so we have to wait past\n+      // the window in order to get the avg rate bellow the quota.\n+      Thread.sleep(11000) // Thread.sleep(throttleTimeMs1)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNzEyNg==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456307126", "bodyText": "I do agree that this is pretty annoying. I am a bit reluctant to using mock time here as these are real integration tests so I would like to test the real conditions. When we will have the improvement for the quota, the sleep time will be <5s and we have 3 of them in the whole test suite. IMO, 15s is not that bad. We do similar in the other quota integration tests for example.\nI may be able to reduce it a bit by tweaking the quota used. Let me try.", "author": "dajac", "createdAt": "2020-07-17T08:45:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg3Njc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3ODc4MA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456378780", "bodyText": "In these type of tests, it is better to use waitUntil some condition rather than sleep for a long time. The sleep seems very long because there are multiple tests like this. If it is possible to wait for some condition that typically finishes sooner but may some times take longer, that would be better.", "author": "rajinisivaram", "createdAt": "2020-07-17T11:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg3Njc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQxMDg5Ng==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r456410896", "bodyText": "That makes sense. I have changed them to using waitUntilTrue.", "author": "dajac", "createdAt": "2020-07-17T12:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg3Njc1NA=="}], "type": "inlineReview"}, {"oid": "edaff3d2b32a683b5a9889cd6c595c1ab7c5e2cd", "url": "https://github.com/apache/kafka/commit/edaff3d2b32a683b5a9889cd6c595c1ab7c5e2cd", "message": "Protocol", "committedDate": "2020-07-17T12:26:50Z", "type": "commit"}, {"oid": "125443cd72f7837e96698b8d05d5277eef5395dd", "url": "https://github.com/apache/kafka/commit/125443cd72f7837e96698b8d05d5277eef5395dd", "message": "Sensor", "committedDate": "2020-07-17T12:26:50Z", "type": "commit"}, {"oid": "59fb24c4c055469dc01cf687928ddfb025b07822", "url": "https://github.com/apache/kafka/commit/59fb24c4c055469dc01cf687928ddfb025b07822", "message": "Quota Manager in Core", "committedDate": "2020-07-17T12:28:26Z", "type": "commit"}, {"oid": "c8ba4edeaaee172bc13f2acd22a1d4ed09e9bff9", "url": "https://github.com/apache/kafka/commit/c8ba4edeaaee172bc13f2acd22a1d4ed09e9bff9", "message": "cleanup", "committedDate": "2020-07-17T12:28:26Z", "type": "commit"}, {"oid": "bba2c399c804f349d5c4b8fb4e9db863b9bc484a", "url": "https://github.com/apache/kafka/commit/bba2c399c804f349d5c4b8fb4e9db863b9bc484a", "message": "Address review", "committedDate": "2020-07-17T12:28:26Z", "type": "commit"}, {"oid": "bba2c399c804f349d5c4b8fb4e9db863b9bc484a", "url": "https://github.com/apache/kafka/commit/bba2c399c804f349d5c4b8fb4e9db863b9bc484a", "message": "Address review", "committedDate": "2020-07-17T12:28:26Z", "type": "forcePushed"}, {"oid": "d9da0bdbcf31d2d2dc6c933c0adddae72a258cb5", "url": "https://github.com/apache/kafka/commit/d9da0bdbcf31d2d2dc6c933c0adddae72a258cb5", "message": "Address Anna's comment in #8977.", "committedDate": "2020-07-17T12:35:21Z", "type": "commit"}, {"oid": "e99fb72236527c04dfaecca52708fa7f209c7e88", "url": "https://github.com/apache/kafka/commit/e99fb72236527c04dfaecca52708fa7f209c7e88", "message": "address review", "committedDate": "2020-07-17T13:21:58Z", "type": "commit"}, {"oid": "cc58743728ea9801feed128adce287087b67c918", "url": "https://github.com/apache/kafka/commit/cc58743728ea9801feed128adce287087b67c918", "message": "Remove QuotaEnforcementType", "committedDate": "2020-07-20T08:17:51Z", "type": "commit"}, {"oid": "f3a2968dcb31aa75285c0f20a8fb0492346295e3", "url": "https://github.com/apache/kafka/commit/f3a2968dcb31aa75285c0f20a8fb0492346295e3", "message": "fix checkstyle errors", "committedDate": "2020-07-20T08:49:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE4NTQ0Mw==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457185443", "bodyText": "There are two differences between Strict and Permissive quotas:\n\nAs described above, it does not accept any mutations if quota is already exhausted\nIt does not throttle for any number of mutations if quota is not already exhausted. This is different from the other one which throttles if quota will be exceeded due to the current request.\n\nShould we document the second behaviour as well? I am guessing 2) will be limited by the burst value. Where would that be checked?", "author": "rajinisivaram", "createdAt": "2020-07-20T08:45:10Z", "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def record(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def record(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The AbstractControllerMutationQuota is the base class of StrictControllerMutationQuota and\n+ * PermissiveControllerMutationQuota.\n+ *\n+ * @param time @Time object to use\n+ */\n+abstract class AbstractControllerMutationQuota(private val time: Time) extends ControllerMutationQuota {\n+  protected var lastThrottleTimeMs = 0L\n+  protected var lastRecordedTimeMs = 0L\n+\n+  protected def updateThrottleTime(e: QuotaViolationException, timeMs: Long): Unit = {\n+    lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+    lastRecordedTimeMs = timeMs\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it, especially when a request waits in the purgatory.\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt\n+  }\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.", "originalCommit": "cc58743728ea9801feed128adce287087b67c918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMwNjM2MQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457306361", "bodyText": "Good point. Let me complete the scaladoc.\nRegarding the burst, there is no explicit check for it as it is implicitly enforced based on the length of the time window of the rate. The maximum burst is defined by the length of the window (# samples * sample length).", "author": "dajac", "createdAt": "2020-07-20T11:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE4NTQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE4NzU0MA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457187540", "bodyText": "typo: below", "author": "rajinisivaram", "createdAt": "2020-07-20T08:47:59Z", "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def record(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def record(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The AbstractControllerMutationQuota is the base class of StrictControllerMutationQuota and\n+ * PermissiveControllerMutationQuota.\n+ *\n+ * @param time @Time object to use\n+ */\n+abstract class AbstractControllerMutationQuota(private val time: Time) extends ControllerMutationQuota {\n+  protected var lastThrottleTimeMs = 0L\n+  protected var lastRecordedTimeMs = 0L\n+\n+  protected def updateThrottleTime(e: QuotaViolationException, timeMs: Long): Unit = {\n+    lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+    lastRecordedTimeMs = timeMs\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it, especially when a request waits in the purgatory.\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt\n+  }\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = lastThrottleTimeMs > 0\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(permits, timeMs, false)\n+      }\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+        throw new ThrottlingQuotaExceededException(lastThrottleTimeMs.toInt,\n+          Errors.THROTTLING_QUOTA_EXCEEDED.message)\n+    }\n+  }\n+}\n+\n+/**\n+ * The PermissiveControllerMutationQuota defines a permissive quota for a given user/clientId pair.\n+ * The quota is permissive meaning that it does accept any mutations even if the quota is exhausted.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class PermissiveControllerMutationQuota(private val time: Time,\n+                                        private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = false\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor.record(permits, timeMs, true)\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+    }\n+  }\n+}\n+\n+/**\n+ * The ControllerMutationQuotaManager is a specialized ClientQuotaManager used in the context\n+ * of throttling controller's operations/mutations.\n+ *\n+ * @param config @ClientQuotaManagerConfig quota configs\n+ * @param metrics @Metrics Metrics instance\n+ * @param time @Time object to use\n+ * @param threadNamePrefix The thread prefix to use\n+ * @param quotaCallback @ClientQuotaCallback ClientQuotaCallback to use\n+ */\n+class ControllerMutationQuotaManager(private val config: ClientQuotaManagerConfig,\n+                                     private val metrics: Metrics,\n+                                     private val time: Time,\n+                                     private val threadNamePrefix: String,\n+                                     private val quotaCallback: Option[ClientQuotaCallback])\n+    extends ClientQuotaManager(config, metrics, QuotaType.ControllerMutation, time, threadNamePrefix, quotaCallback) {\n+\n+  override protected def clientRateMetricName(quotaMetricTags: Map[String, String]): MetricName = {\n+    metrics.metricName(\"mutation-rate\", QuotaType.ControllerMutation.toString,\n+      \"Tracking mutation-rate per user/client-id\",\n+      quotaMetricTags.asJava)\n+  }\n+\n+  /**\n+   * Records that a user/clientId accumulated or would like to accumulate the provided amount at the\n+   * the specified time, returns throttle time in milliseconds. The quota is strict meaning that it\n+   * does not accept any mutations once the quota is exhausted until it gets back to the defined rate.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @param value The value to accumulate\n+   * @param timeMs The time at which to accumulate the value\n+   * @return The throttle time in milliseconds defines as the time to wait until the average\n+   *         rate gets back to the defined quota\n+   */\n+  override def recordAndGetThrottleTimeMs(session: Session, clientId: String, value: Double, timeMs: Long): Int = {\n+    val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+    val quotaSensor = clientSensors.quotaSensor\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(value, timeMs, false)\n+      }\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = throttleTime(e, timeMs).toInt\n+        debug(s\"Quota violated for sensor (${quotaSensor.name}). Delay time: ($throttleTimeMs)\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Returns a StrictControllerMutationQuota for the given session/clientId pair or\n+   * a UnboundedControllerMutationQuota$ if the quota is disabled.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @return ControllerMutationQuota\n+   */\n+  def newStrictQuotaFor(session: Session, clientId: String): ControllerMutationQuota = {\n+    if (quotasEnabled) {\n+      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+      new StrictControllerMutationQuota(time, clientSensors.quotaSensor)\n+    } else {\n+      UnboundedControllerMutationQuota\n+    }\n+  }\n+\n+  def newStrictQuotaFor(request: RequestChannel.Request): ControllerMutationQuota =\n+    newStrictQuotaFor(request.session, request.header.clientId)\n+\n+  /**\n+   * Returns a PermissiveControllerMutationQuota for the given session/clientId pair or\n+   * a UnboundedControllerMutationQuota$ if the quota is disabled.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @return ControllerMutationQuota\n+   */\n+  def newPermissiveQuotaFor(session: Session, clientId: String): ControllerMutationQuota = {\n+    if (quotasEnabled) {\n+      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+      new PermissiveControllerMutationQuota(time, clientSensors.quotaSensor)\n+    } else {\n+      UnboundedControllerMutationQuota\n+    }\n+  }\n+\n+  def newPermissiveQuotaFor(request: RequestChannel.Request): ControllerMutationQuota =\n+    newPermissiveQuotaFor(request.session, request.header.clientId)\n+\n+  /**\n+   * Returns a ControllerMutationQuota based on `strictSinceVersion`. It returns a strict\n+   * quota if the version is equal to or above of the `strictSinceVersion`, a permissive\n+   * quota if the version is bellow, and a unbounded quota if the quota is disabled.", "originalCommit": "cc58743728ea9801feed128adce287087b67c918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5MTg4OQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457191889", "bodyText": "nit: user/clientId pair?", "author": "rajinisivaram", "createdAt": "2020-07-20T08:53:44Z", "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def record(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def record(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The AbstractControllerMutationQuota is the base class of StrictControllerMutationQuota and\n+ * PermissiveControllerMutationQuota.\n+ *\n+ * @param time @Time object to use\n+ */\n+abstract class AbstractControllerMutationQuota(private val time: Time) extends ControllerMutationQuota {\n+  protected var lastThrottleTimeMs = 0L\n+  protected var lastRecordedTimeMs = 0L\n+\n+  protected def updateThrottleTime(e: QuotaViolationException, timeMs: Long): Unit = {\n+    lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+    lastRecordedTimeMs = timeMs\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it, especially when a request waits in the purgatory.\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt\n+  }\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = lastThrottleTimeMs > 0\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(permits, timeMs, false)\n+      }\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+        throw new ThrottlingQuotaExceededException(lastThrottleTimeMs.toInt,\n+          Errors.THROTTLING_QUOTA_EXCEEDED.message)\n+    }\n+  }\n+}\n+\n+/**\n+ * The PermissiveControllerMutationQuota defines a permissive quota for a given user/clientId pair.\n+ * The quota is permissive meaning that it does accept any mutations even if the quota is exhausted.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class PermissiveControllerMutationQuota(private val time: Time,\n+                                        private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = false\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor.record(permits, timeMs, true)\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+    }\n+  }\n+}\n+\n+/**\n+ * The ControllerMutationQuotaManager is a specialized ClientQuotaManager used in the context\n+ * of throttling controller's operations/mutations.\n+ *\n+ * @param config @ClientQuotaManagerConfig quota configs\n+ * @param metrics @Metrics Metrics instance\n+ * @param time @Time object to use\n+ * @param threadNamePrefix The thread prefix to use\n+ * @param quotaCallback @ClientQuotaCallback ClientQuotaCallback to use\n+ */\n+class ControllerMutationQuotaManager(private val config: ClientQuotaManagerConfig,\n+                                     private val metrics: Metrics,\n+                                     private val time: Time,\n+                                     private val threadNamePrefix: String,\n+                                     private val quotaCallback: Option[ClientQuotaCallback])\n+    extends ClientQuotaManager(config, metrics, QuotaType.ControllerMutation, time, threadNamePrefix, quotaCallback) {\n+\n+  override protected def clientRateMetricName(quotaMetricTags: Map[String, String]): MetricName = {\n+    metrics.metricName(\"mutation-rate\", QuotaType.ControllerMutation.toString,\n+      \"Tracking mutation-rate per user/client-id\",\n+      quotaMetricTags.asJava)\n+  }\n+\n+  /**\n+   * Records that a user/clientId accumulated or would like to accumulate the provided amount at the\n+   * the specified time, returns throttle time in milliseconds. The quota is strict meaning that it\n+   * does not accept any mutations once the quota is exhausted until it gets back to the defined rate.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @param value The value to accumulate\n+   * @param timeMs The time at which to accumulate the value\n+   * @return The throttle time in milliseconds defines as the time to wait until the average\n+   *         rate gets back to the defined quota\n+   */\n+  override def recordAndGetThrottleTimeMs(session: Session, clientId: String, value: Double, timeMs: Long): Int = {\n+    val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+    val quotaSensor = clientSensors.quotaSensor\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(value, timeMs, false)\n+      }\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = throttleTime(e, timeMs).toInt\n+        debug(s\"Quota violated for sensor (${quotaSensor.name}). Delay time: ($throttleTimeMs)\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Returns a StrictControllerMutationQuota for the given session/clientId pair or", "originalCommit": "cc58743728ea9801feed128adce287087b67c918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5MjIyMA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457192220", "bodyText": "nit: user/clientId pair?", "author": "rajinisivaram", "createdAt": "2020-07-20T08:54:09Z", "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def record(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def record(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The AbstractControllerMutationQuota is the base class of StrictControllerMutationQuota and\n+ * PermissiveControllerMutationQuota.\n+ *\n+ * @param time @Time object to use\n+ */\n+abstract class AbstractControllerMutationQuota(private val time: Time) extends ControllerMutationQuota {\n+  protected var lastThrottleTimeMs = 0L\n+  protected var lastRecordedTimeMs = 0L\n+\n+  protected def updateThrottleTime(e: QuotaViolationException, timeMs: Long): Unit = {\n+    lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+    lastRecordedTimeMs = timeMs\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it, especially when a request waits in the purgatory.\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt\n+  }\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = lastThrottleTimeMs > 0\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(permits, timeMs, false)\n+      }\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+        throw new ThrottlingQuotaExceededException(lastThrottleTimeMs.toInt,\n+          Errors.THROTTLING_QUOTA_EXCEEDED.message)\n+    }\n+  }\n+}\n+\n+/**\n+ * The PermissiveControllerMutationQuota defines a permissive quota for a given user/clientId pair.\n+ * The quota is permissive meaning that it does accept any mutations even if the quota is exhausted.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class PermissiveControllerMutationQuota(private val time: Time,\n+                                        private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = false\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor.record(permits, timeMs, true)\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+    }\n+  }\n+}\n+\n+/**\n+ * The ControllerMutationQuotaManager is a specialized ClientQuotaManager used in the context\n+ * of throttling controller's operations/mutations.\n+ *\n+ * @param config @ClientQuotaManagerConfig quota configs\n+ * @param metrics @Metrics Metrics instance\n+ * @param time @Time object to use\n+ * @param threadNamePrefix The thread prefix to use\n+ * @param quotaCallback @ClientQuotaCallback ClientQuotaCallback to use\n+ */\n+class ControllerMutationQuotaManager(private val config: ClientQuotaManagerConfig,\n+                                     private val metrics: Metrics,\n+                                     private val time: Time,\n+                                     private val threadNamePrefix: String,\n+                                     private val quotaCallback: Option[ClientQuotaCallback])\n+    extends ClientQuotaManager(config, metrics, QuotaType.ControllerMutation, time, threadNamePrefix, quotaCallback) {\n+\n+  override protected def clientRateMetricName(quotaMetricTags: Map[String, String]): MetricName = {\n+    metrics.metricName(\"mutation-rate\", QuotaType.ControllerMutation.toString,\n+      \"Tracking mutation-rate per user/client-id\",\n+      quotaMetricTags.asJava)\n+  }\n+\n+  /**\n+   * Records that a user/clientId accumulated or would like to accumulate the provided amount at the\n+   * the specified time, returns throttle time in milliseconds. The quota is strict meaning that it\n+   * does not accept any mutations once the quota is exhausted until it gets back to the defined rate.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @param value The value to accumulate\n+   * @param timeMs The time at which to accumulate the value\n+   * @return The throttle time in milliseconds defines as the time to wait until the average\n+   *         rate gets back to the defined quota\n+   */\n+  override def recordAndGetThrottleTimeMs(session: Session, clientId: String, value: Double, timeMs: Long): Int = {\n+    val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+    val quotaSensor = clientSensors.quotaSensor\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(value, timeMs, false)\n+      }\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = throttleTime(e, timeMs).toInt\n+        debug(s\"Quota violated for sensor (${quotaSensor.name}). Delay time: ($throttleTimeMs)\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Returns a StrictControllerMutationQuota for the given session/clientId pair or\n+   * a UnboundedControllerMutationQuota$ if the quota is disabled.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @return ControllerMutationQuota\n+   */\n+  def newStrictQuotaFor(session: Session, clientId: String): ControllerMutationQuota = {\n+    if (quotasEnabled) {\n+      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+      new StrictControllerMutationQuota(time, clientSensors.quotaSensor)\n+    } else {\n+      UnboundedControllerMutationQuota\n+    }\n+  }\n+\n+  def newStrictQuotaFor(request: RequestChannel.Request): ControllerMutationQuota =\n+    newStrictQuotaFor(request.session, request.header.clientId)\n+\n+  /**\n+   * Returns a PermissiveControllerMutationQuota for the given session/clientId pair or", "originalCommit": "cc58743728ea9801feed128adce287087b67c918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5MzE5Nw==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457193197", "bodyText": "nit: user and clientId of the session", "author": "rajinisivaram", "createdAt": "2020-07-20T08:55:24Z", "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def record(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def record(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The AbstractControllerMutationQuota is the base class of StrictControllerMutationQuota and\n+ * PermissiveControllerMutationQuota.\n+ *\n+ * @param time @Time object to use\n+ */\n+abstract class AbstractControllerMutationQuota(private val time: Time) extends ControllerMutationQuota {\n+  protected var lastThrottleTimeMs = 0L\n+  protected var lastRecordedTimeMs = 0L\n+\n+  protected def updateThrottleTime(e: QuotaViolationException, timeMs: Long): Unit = {\n+    lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+    lastRecordedTimeMs = timeMs\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it, especially when a request waits in the purgatory.\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt\n+  }\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = lastThrottleTimeMs > 0\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(permits, timeMs, false)\n+      }\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+        throw new ThrottlingQuotaExceededException(lastThrottleTimeMs.toInt,\n+          Errors.THROTTLING_QUOTA_EXCEEDED.message)\n+    }\n+  }\n+}\n+\n+/**\n+ * The PermissiveControllerMutationQuota defines a permissive quota for a given user/clientId pair.\n+ * The quota is permissive meaning that it does accept any mutations even if the quota is exhausted.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class PermissiveControllerMutationQuota(private val time: Time,\n+                                        private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = false\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor.record(permits, timeMs, true)\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+    }\n+  }\n+}\n+\n+/**\n+ * The ControllerMutationQuotaManager is a specialized ClientQuotaManager used in the context\n+ * of throttling controller's operations/mutations.\n+ *\n+ * @param config @ClientQuotaManagerConfig quota configs\n+ * @param metrics @Metrics Metrics instance\n+ * @param time @Time object to use\n+ * @param threadNamePrefix The thread prefix to use\n+ * @param quotaCallback @ClientQuotaCallback ClientQuotaCallback to use\n+ */\n+class ControllerMutationQuotaManager(private val config: ClientQuotaManagerConfig,\n+                                     private val metrics: Metrics,\n+                                     private val time: Time,\n+                                     private val threadNamePrefix: String,\n+                                     private val quotaCallback: Option[ClientQuotaCallback])\n+    extends ClientQuotaManager(config, metrics, QuotaType.ControllerMutation, time, threadNamePrefix, quotaCallback) {\n+\n+  override protected def clientRateMetricName(quotaMetricTags: Map[String, String]): MetricName = {\n+    metrics.metricName(\"mutation-rate\", QuotaType.ControllerMutation.toString,\n+      \"Tracking mutation-rate per user/client-id\",\n+      quotaMetricTags.asJava)\n+  }\n+\n+  /**\n+   * Records that a user/clientId accumulated or would like to accumulate the provided amount at the\n+   * the specified time, returns throttle time in milliseconds. The quota is strict meaning that it\n+   * does not accept any mutations once the quota is exhausted until it gets back to the defined rate.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @param value The value to accumulate\n+   * @param timeMs The time at which to accumulate the value\n+   * @return The throttle time in milliseconds defines as the time to wait until the average\n+   *         rate gets back to the defined quota\n+   */\n+  override def recordAndGetThrottleTimeMs(session: Session, clientId: String, value: Double, timeMs: Long): Int = {\n+    val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+    val quotaSensor = clientSensors.quotaSensor\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(value, timeMs, false)\n+      }\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = throttleTime(e, timeMs).toInt\n+        debug(s\"Quota violated for sensor (${quotaSensor.name}). Delay time: ($throttleTimeMs)\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Returns a StrictControllerMutationQuota for the given session/clientId pair or\n+   * a UnboundedControllerMutationQuota$ if the quota is disabled.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @return ControllerMutationQuota\n+   */\n+  def newStrictQuotaFor(session: Session, clientId: String): ControllerMutationQuota = {\n+    if (quotasEnabled) {\n+      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+      new StrictControllerMutationQuota(time, clientSensors.quotaSensor)\n+    } else {\n+      UnboundedControllerMutationQuota\n+    }\n+  }\n+\n+  def newStrictQuotaFor(request: RequestChannel.Request): ControllerMutationQuota =\n+    newStrictQuotaFor(request.session, request.header.clientId)\n+\n+  /**\n+   * Returns a PermissiveControllerMutationQuota for the given session/clientId pair or\n+   * a UnboundedControllerMutationQuota$ if the quota is disabled.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @return ControllerMutationQuota\n+   */\n+  def newPermissiveQuotaFor(session: Session, clientId: String): ControllerMutationQuota = {\n+    if (quotasEnabled) {\n+      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+      new PermissiveControllerMutationQuota(time, clientSensors.quotaSensor)\n+    } else {\n+      UnboundedControllerMutationQuota\n+    }\n+  }\n+\n+  def newPermissiveQuotaFor(request: RequestChannel.Request): ControllerMutationQuota =\n+    newPermissiveQuotaFor(request.session, request.header.clientId)\n+\n+  /**\n+   * Returns a ControllerMutationQuota based on `strictSinceVersion`. It returns a strict\n+   * quota if the version is equal to or above of the `strictSinceVersion`, a permissive\n+   * quota if the version is bellow, and a unbounded quota if the quota is disabled.\n+   *\n+   * When the quota is strictly enforced. Any operation above the quota is not allowed\n+   * and rejected with a THROTTLING_QUOTA_EXCEEDED error.\n+   *\n+   * @param request The request to extract the session and the clientId from", "originalCommit": "cc58743728ea9801feed128adce287087b67c918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5NTU2OA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457195568", "bodyText": "nit: remove replication", "author": "rajinisivaram", "createdAt": "2020-07-20T08:58:32Z", "path": "core/src/main/scala/kafka/server/KafkaConfig.scala", "diffHunk": "@@ -864,9 +868,12 @@ object KafkaConfig {\n   val NumQuotaSamplesDoc = \"The number of samples to retain in memory for client quotas\"\n   val NumReplicationQuotaSamplesDoc = \"The number of samples to retain in memory for replication quotas\"\n   val NumAlterLogDirsReplicationQuotaSamplesDoc = \"The number of samples to retain in memory for alter log dirs replication quotas\"\n+  val NumControllerQuotaSamplesDoc = \"The number of samples to retain in memory for controller mutations replication quotas\"", "originalCommit": "cc58743728ea9801feed128adce287087b67c918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5NzQ1Nw==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457197457", "bodyText": "nit: return Option[Int] and the caller can do getOrElse(0)?", "author": "rajinisivaram", "createdAt": "2020-07-20T09:00:55Z", "path": "core/src/main/scala/kafka/server/MetadataCache.scala", "diffHunk": "@@ -222,6 +222,10 @@ class MetadataCache(brokerId: Int) extends Logging {\n     metadataSnapshot.partitionStates.get(topic).flatMap(_.get(partitionId))\n   }\n \n+  def numPartitions(topic: String): Int = {\n+    metadataSnapshot.partitionStates.get(topic).map(_.size).getOrElse(0)", "originalCommit": "cc58743728ea9801feed128adce287087b67c918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIxMjMzNQ==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457212335", "bodyText": "We should log the throttle time in the assertion message. Not sure if < 1000 will result in flaky tests, will see how the PR builds in Jenkins do.", "author": "rajinisivaram", "createdAt": "2020-07-20T09:21:09Z", "path": "core/src/test/scala/unit/kafka/server/ControllerMutationQuotaTest.scala", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ **/\n+package kafka.server\n+\n+import java.util.Properties\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+\n+import kafka.utils.TestUtils\n+import org.apache.kafka.common.internals.KafkaFutureImpl\n+import org.apache.kafka.common.message.CreatePartitionsRequestData\n+import org.apache.kafka.common.message.CreatePartitionsRequestData.CreatePartitionsTopic\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.message.DeleteTopicsRequestData\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.quota.ClientQuotaAlteration\n+import org.apache.kafka.common.quota.ClientQuotaEntity\n+import org.apache.kafka.common.requests.AlterClientQuotasRequest\n+import org.apache.kafka.common.requests.AlterClientQuotasResponse\n+import org.apache.kafka.common.requests.CreatePartitionsRequest\n+import org.apache.kafka.common.requests.CreatePartitionsResponse\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.requests.CreateTopicsResponse\n+import org.apache.kafka.common.requests.DeleteTopicsRequest\n+import org.apache.kafka.common.requests.DeleteTopicsResponse\n+import org.apache.kafka.common.security.auth.AuthenticationContext\n+import org.apache.kafka.common.security.auth.KafkaPrincipal\n+import org.apache.kafka.common.security.auth.KafkaPrincipalBuilder\n+import org.junit.Assert.assertEquals\n+import org.junit.Assert.assertTrue\n+import org.junit.Before\n+import org.junit.Test\n+\n+import scala.jdk.CollectionConverters._\n+\n+object ControllerMutationQuotaTest {\n+  // Principal used for all client connections. This is updated by each test.\n+  var principal = KafkaPrincipal.ANONYMOUS\n+  class TestPrincipalBuilder extends KafkaPrincipalBuilder {\n+    override def build(context: AuthenticationContext): KafkaPrincipal = {\n+      principal\n+    }\n+  }\n+\n+  def asPrincipal(newPrincipal: KafkaPrincipal)(f: => Unit): Unit = {\n+    val currentPrincipal = principal\n+    principal = newPrincipal\n+    try f\n+    finally principal = currentPrincipal\n+  }\n+\n+  val ThrottledPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"ThrottledPrincipal\")\n+  val UnboundedPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"UnboundedPrincipal\")\n+\n+  val StrictCreateTopicsRequestVersion = ApiKeys.CREATE_TOPICS.latestVersion\n+  val PermissiveCreateTopicsRequestVersion = 5.toShort\n+\n+  val StrictDeleteTopicsRequestVersion = ApiKeys.DELETE_TOPICS.latestVersion\n+  val PermissiveDeleteTopicsRequestVersion = 4.toShort\n+\n+  val StrictCreatePartitionsRequestVersion = ApiKeys.CREATE_PARTITIONS.latestVersion\n+  val PermissiveCreatePartitionsRequestVersion = 2.toShort\n+\n+  val TopicsWithOnePartition = Seq(\"topic-1\" ->  1, \"topic-2\" ->  1)\n+  val TopicsWith30Partitions = Seq(\"topic-1\" -> 30, \"topic-2\" -> 30)\n+  val TopicsWith31Partitions = Seq(\"topic-1\" -> 31, \"topic-2\" -> 31)\n+\n+  val ControllerMutationRate = 2.0\n+}\n+\n+class ControllerMutationQuotaTest extends BaseRequestTest {\n+  import ControllerMutationQuotaTest._\n+\n+  override def brokerCount: Int = 1\n+\n+  override def brokerPropertyOverrides(properties: Properties): Unit = {\n+    properties.put(KafkaConfig.ControlledShutdownEnableProp, \"false\")\n+    properties.put(KafkaConfig.OffsetsTopicReplicationFactorProp, \"1\")\n+    properties.put(KafkaConfig.OffsetsTopicPartitionsProp, \"1\")\n+    properties.put(KafkaConfig.PrincipalBuilderClassProp,\n+      classOf[ControllerMutationQuotaTest.TestPrincipalBuilder].getName)\n+    // We use the default number of samples and window size.\n+    properties.put(KafkaConfig.NumControllerQuotaSamplesProp, \"11\")\n+    properties.put(KafkaConfig.ControllerQuotaWindowSizeSecondsProp, \"1\")\n+  }\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    // Define a quota for ThrottledPrincipal\n+    defineUserQuota(ThrottledPrincipal.getName, Some(ControllerMutationRate))\n+    waitUserQuota(ThrottledPrincipal.getName, ControllerMutationRate)\n+  }\n+\n+  @Test\n+  def testSetUnsetQuota(): Unit = {\n+    val principal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"User\")\n+    // Default Value\n+    waitUserQuota(principal.getName, Long.MaxValue)\n+    // Define a new quota\n+    defineUserQuota(principal.getName, Some(ControllerMutationRate))\n+    // Check it\n+    waitUserQuota(principal.getName, ControllerMutationRate)\n+    // Remove it\n+    defineUserQuota(principal.getName, None)\n+    // Back to the default\n+    waitUserQuota(principal.getName, Long.MaxValue)\n+  }\n+\n+  @Test\n+  def testStrictCreateTopicsRequest(): Unit = {\n+    asPrincipal(ThrottledPrincipal) {\n+      // Create two topics worth of 30 partitions each. As we use a strict quota, we\n+      // expect the first topic to be created and the second to be rejected.\n+      // Theoretically, the throttle time should be below or equal to:\n+      // ((30 / 10) - 2) / 2 * 10 = 5s\n+      val (throttleTimeMs1, errors1) = createTopics(TopicsWith30Partitions, StrictCreateTopicsRequestVersion)\n+      assertTrue((5000 - throttleTimeMs1) < 1000)", "originalCommit": "cc58743728ea9801feed128adce287087b67c918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMxNTA1MA==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457315050", "bodyText": "Good point. Regarding the flakyness, I never had a failure locally but I suppose that may happen if Jenkins is really slow.", "author": "dajac", "createdAt": "2020-07-20T11:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIxMjMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIxMjgxNg==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457212816", "bodyText": "nit: Include actual throttleTimeMs in assertion message (multiple places)", "author": "rajinisivaram", "createdAt": "2020-07-20T09:21:46Z", "path": "core/src/test/scala/unit/kafka/server/ControllerMutationQuotaTest.scala", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ **/\n+package kafka.server\n+\n+import java.util.Properties\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+\n+import kafka.utils.TestUtils\n+import org.apache.kafka.common.internals.KafkaFutureImpl\n+import org.apache.kafka.common.message.CreatePartitionsRequestData\n+import org.apache.kafka.common.message.CreatePartitionsRequestData.CreatePartitionsTopic\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.message.DeleteTopicsRequestData\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.quota.ClientQuotaAlteration\n+import org.apache.kafka.common.quota.ClientQuotaEntity\n+import org.apache.kafka.common.requests.AlterClientQuotasRequest\n+import org.apache.kafka.common.requests.AlterClientQuotasResponse\n+import org.apache.kafka.common.requests.CreatePartitionsRequest\n+import org.apache.kafka.common.requests.CreatePartitionsResponse\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.requests.CreateTopicsResponse\n+import org.apache.kafka.common.requests.DeleteTopicsRequest\n+import org.apache.kafka.common.requests.DeleteTopicsResponse\n+import org.apache.kafka.common.security.auth.AuthenticationContext\n+import org.apache.kafka.common.security.auth.KafkaPrincipal\n+import org.apache.kafka.common.security.auth.KafkaPrincipalBuilder\n+import org.junit.Assert.assertEquals\n+import org.junit.Assert.assertTrue\n+import org.junit.Before\n+import org.junit.Test\n+\n+import scala.jdk.CollectionConverters._\n+\n+object ControllerMutationQuotaTest {\n+  // Principal used for all client connections. This is updated by each test.\n+  var principal = KafkaPrincipal.ANONYMOUS\n+  class TestPrincipalBuilder extends KafkaPrincipalBuilder {\n+    override def build(context: AuthenticationContext): KafkaPrincipal = {\n+      principal\n+    }\n+  }\n+\n+  def asPrincipal(newPrincipal: KafkaPrincipal)(f: => Unit): Unit = {\n+    val currentPrincipal = principal\n+    principal = newPrincipal\n+    try f\n+    finally principal = currentPrincipal\n+  }\n+\n+  val ThrottledPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"ThrottledPrincipal\")\n+  val UnboundedPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"UnboundedPrincipal\")\n+\n+  val StrictCreateTopicsRequestVersion = ApiKeys.CREATE_TOPICS.latestVersion\n+  val PermissiveCreateTopicsRequestVersion = 5.toShort\n+\n+  val StrictDeleteTopicsRequestVersion = ApiKeys.DELETE_TOPICS.latestVersion\n+  val PermissiveDeleteTopicsRequestVersion = 4.toShort\n+\n+  val StrictCreatePartitionsRequestVersion = ApiKeys.CREATE_PARTITIONS.latestVersion\n+  val PermissiveCreatePartitionsRequestVersion = 2.toShort\n+\n+  val TopicsWithOnePartition = Seq(\"topic-1\" ->  1, \"topic-2\" ->  1)\n+  val TopicsWith30Partitions = Seq(\"topic-1\" -> 30, \"topic-2\" -> 30)\n+  val TopicsWith31Partitions = Seq(\"topic-1\" -> 31, \"topic-2\" -> 31)\n+\n+  val ControllerMutationRate = 2.0\n+}\n+\n+class ControllerMutationQuotaTest extends BaseRequestTest {\n+  import ControllerMutationQuotaTest._\n+\n+  override def brokerCount: Int = 1\n+\n+  override def brokerPropertyOverrides(properties: Properties): Unit = {\n+    properties.put(KafkaConfig.ControlledShutdownEnableProp, \"false\")\n+    properties.put(KafkaConfig.OffsetsTopicReplicationFactorProp, \"1\")\n+    properties.put(KafkaConfig.OffsetsTopicPartitionsProp, \"1\")\n+    properties.put(KafkaConfig.PrincipalBuilderClassProp,\n+      classOf[ControllerMutationQuotaTest.TestPrincipalBuilder].getName)\n+    // We use the default number of samples and window size.\n+    properties.put(KafkaConfig.NumControllerQuotaSamplesProp, \"11\")\n+    properties.put(KafkaConfig.ControllerQuotaWindowSizeSecondsProp, \"1\")\n+  }\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    // Define a quota for ThrottledPrincipal\n+    defineUserQuota(ThrottledPrincipal.getName, Some(ControllerMutationRate))\n+    waitUserQuota(ThrottledPrincipal.getName, ControllerMutationRate)\n+  }\n+\n+  @Test\n+  def testSetUnsetQuota(): Unit = {\n+    val principal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"User\")\n+    // Default Value\n+    waitUserQuota(principal.getName, Long.MaxValue)\n+    // Define a new quota\n+    defineUserQuota(principal.getName, Some(ControllerMutationRate))\n+    // Check it\n+    waitUserQuota(principal.getName, ControllerMutationRate)\n+    // Remove it\n+    defineUserQuota(principal.getName, None)\n+    // Back to the default\n+    waitUserQuota(principal.getName, Long.MaxValue)\n+  }\n+\n+  @Test\n+  def testStrictCreateTopicsRequest(): Unit = {\n+    asPrincipal(ThrottledPrincipal) {\n+      // Create two topics worth of 30 partitions each. As we use a strict quota, we\n+      // expect the first topic to be created and the second to be rejected.\n+      // Theoretically, the throttle time should be below or equal to:\n+      // ((30 / 10) - 2) / 2 * 10 = 5s\n+      val (throttleTimeMs1, errors1) = createTopics(TopicsWith30Partitions, StrictCreateTopicsRequestVersion)\n+      assertTrue((5000 - throttleTimeMs1) < 1000)\n+      assertEquals(Seq(Errors.NONE, Errors.THROTTLING_QUOTA_EXCEEDED), errors1)\n+\n+      // Retry the second topic. It should succeed after the throttling delay is passed and the\n+      // throttle time should be zero.\n+      TestUtils.waitUntilTrue(() => {\n+        val (throttleTimeMs2, errors2) = createTopics(TopicsWith30Partitions.drop(1), StrictCreateTopicsRequestVersion)\n+        throttleTimeMs2 == 0 && errors2 == Seq(Errors.NONE)\n+      }, \"Failed to create topics after having been throttled\")\n+    }\n+  }\n+\n+  @Test\n+  def testPermissiveCreateTopicsRequest(): Unit = {\n+    asPrincipal(ThrottledPrincipal) {\n+      // Create two topics worth of 30 partitions each. As we use a permissive quota, we\n+      // expect both topics to be created.\n+      // Theoretically, the throttle time should be below or equal to:\n+      // ((60 / 10) - 2) / 2 * 10 = 20s\n+      val (throttleTimeMs, errors) = createTopics(TopicsWith30Partitions, PermissiveCreateTopicsRequestVersion)\n+      assertTrue((20000 - throttleTimeMs) < 1000)", "originalCommit": "cc58743728ea9801feed128adce287087b67c918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIxNDU0Ng==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457214546", "bodyText": "Seems to be changing a file for no reason", "author": "rajinisivaram", "createdAt": "2020-07-20T09:24:09Z", "path": "core/src/test/scala/unit/kafka/server/ThrottledChannelExpirationTest.scala", "diffHunk": "@@ -14,10 +14,8 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-", "originalCommit": "cc58743728ea9801feed128adce287087b67c918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIxODI1Nw==", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457218257", "bodyText": "Revert changes to file since nothing has actually changed?", "author": "rajinisivaram", "createdAt": "2020-07-20T09:28:56Z", "path": "core/src/main/scala/kafka/server/ReplicationQuotaManager.scala", "diffHunk": "@@ -20,13 +20,11 @@ import java.util.concurrent.{ConcurrentHashMap, TimeUnit}\n import java.util.concurrent.locks.ReentrantReadWriteLock\n \n import scala.collection.Seq\n-", "originalCommit": "f3a2968dcb31aa75285c0f20a8fb0492346295e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5363f22fceff60617ecf0092054509b1b09e8b32", "url": "https://github.com/apache/kafka/commit/5363f22fceff60617ecf0092054509b1b09e8b32", "message": "address comments", "committedDate": "2020-07-20T12:06:58Z", "type": "commit"}, {"oid": "6b73026e92d723e765503d378b70916c80127da7", "url": "https://github.com/apache/kafka/commit/6b73026e92d723e765503d378b70916c80127da7", "message": "fixup", "committedDate": "2020-07-20T12:08:27Z", "type": "commit"}, {"oid": "227a3907e023a3d2b5193f72c2928ba563928919", "url": "https://github.com/apache/kafka/commit/227a3907e023a3d2b5193f72c2928ba563928919", "message": "fixup", "committedDate": "2020-07-20T15:04:37Z", "type": "commit"}, {"oid": "19eceb5e543561e940d1371d4f4bc5ea81c316b9", "url": "https://github.com/apache/kafka/commit/19eceb5e543561e940d1371d4f4bc5ea81c316b9", "message": "fix flaky tests", "committedDate": "2020-07-21T17:04:00Z", "type": "commit"}, {"oid": "cddbeaa9b1d459a047f638811bad5be453fe9cc5", "url": "https://github.com/apache/kafka/commit/cddbeaa9b1d459a047f638811bad5be453fe9cc5", "message": "Enhance tests", "committedDate": "2020-07-22T12:48:43Z", "type": "commit"}, {"oid": "e7013e950461b6a05a246b7903b4d817dd3c5ed3", "url": "https://github.com/apache/kafka/commit/e7013e950461b6a05a246b7903b4d817dd3c5ed3", "message": "fix flaky test", "committedDate": "2020-07-22T13:18:50Z", "type": "commit"}]}