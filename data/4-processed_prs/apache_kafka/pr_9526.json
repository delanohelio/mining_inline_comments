{"pr_number": 9526, "pr_title": "KAFKA-10525: Emit JSONs with new auto-generated schema", "pr_createdAt": "2020-10-29T03:33:59Z", "pr_url": "https://github.com/apache/kafka/pull/9526", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA5MzYyNg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514093626", "bodyText": "This is not entirely related to your PR but it seems that we are little inconsistent wrt. how we expose/access data in the code base. As an example, here we add an accessor to access data but we keep data field public and keep accessing it directly from various places.\nI think that we should do one the following:\n\nAdd an accessor and make data final private everywhere; or\nMake data final public everywhere.\n\nIt seems that you suggest to go with 1) in the PR. Personally, I don't have a strong preference for any of them but I would like us to be consistent across the board.", "author": "dajac", "createdAt": "2020-10-29T08:50:36Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/AddOffsetsToTxnRequest.java", "diffHunk": "@@ -57,6 +57,10 @@ public AddOffsetsToTxnRequest(Struct struct, short version) {\n         this.data = new AddOffsetsToTxnRequestData(struct, version);\n     }\n \n+    public AddOffsetsToTxnRequestData data() {\n+        return data;\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUwODc1NQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514508755", "bodyText": "Yea I definitely agree with wanting consistency. I'll stick to 1) in the PR.", "author": "anatasiavela", "createdAt": "2020-10-29T19:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA5MzYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA5OTAxNg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514099016", "bodyText": "We may want to gate this by isTraceEnabled in order to not compute it necessarily.", "author": "dajac", "createdAt": "2020-10-29T08:59:31Z", "path": "core/src/main/scala/kafka/network/RequestChannel.scala", "diffHunk": "@@ -162,7 +161,7 @@ object RequestChannel extends Logging {\n       }\n     }\n \n-    trace(s\"Processor $processor received request: ${requestDesc(true)}\")\n+    trace(s\"Processor $processor received request: ${RequestConvertToJson.requestDesc(header, loggableRequest, true).toString}\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3NDgxNA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514574814", "bodyText": "Would we unnecessarily calculate it here? I think the macro will avoid it in this case, but I'm fine with gating it anyway.", "author": "lbradstreet", "createdAt": "2020-10-29T21:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA5OTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzNjY5Mg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514636692", "bodyText": "The macro does check isTraceEnabled, and this check is done before the string is evaluated, so it wouldn't be unnecessarily computed. But I'm also fine with gating it.", "author": "anatasiavela", "createdAt": "2020-10-30T00:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA5OTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwODc5NA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r515308794", "bodyText": "nit: unnecessary call of toString\nisTraceEnabled shouldn't be necessary, if my understanding of the logging macro is correct.\nhttps://github.com/lightbend/scala-logging#scala-logging-", "author": "splett2", "createdAt": "2020-10-30T18:46:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA5OTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ5NTQwMQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r515495401", "bodyText": "Indeed, that is not necessary with the macro. My mistake.", "author": "dajac", "createdAt": "2020-10-31T13:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA5OTAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEwMDY5MA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514100690", "bodyText": "This is one case where we still access data without an accessor.", "author": "dajac", "createdAt": "2020-10-29T09:02:14Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExMTU0MQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514111541", "bodyText": "It is a little frustrating to have to maintain this mapping for each request. I wonder if we could auto-generate such helper based on the protocol description. We already generate DataJsonConverter helpers so it should be feasible to also generate an overall helper.\nHave you already considered this? I am fine with keep it as-is for now though and to investigate this in the future.", "author": "dajac", "createdAt": "2020-10-29T09:19:58Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQwODI3Ng==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r515408276", "bodyText": "I haven't thought about this, but it's a good thing to consider. It would definitely help with the hassle of having to maintain so many different request mappers. Although since it's working as-is, let's keep it and have a separate look into it later.", "author": "anatasiavela", "createdAt": "2020-10-30T22:24:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExMTU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExMzI3OA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514113278", "bodyText": "Should we handle the unknown cases explicitly and throw an exception with an meaningful message instead of relying on MatchError? What do you think?", "author": "dajac", "createdAt": "2020-10-29T09:22:34Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxNDIxNg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514614216", "bodyText": "There was an issue before where a request type wasn't handled and it threw a MatchError. I added the system test to make sure all the request types were handled, but in case this happens again, I'll add the exception for unknown cases.", "author": "anatasiavela", "createdAt": "2020-10-29T22:57:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExMzI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExNTk3Mw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514115973", "bodyText": "nit: Could we add a comment here to explain why we overwrite the requestApiKey?", "author": "dajac", "createdAt": "2020-10-29T09:26:34Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3NTM3Mg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514575372", "bodyText": "Having thought about it a bit more, maybe we could include both the api key number and the api key name rather than overwriting it?", "author": "lbradstreet", "createdAt": "2020-10-29T21:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExNTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxMDQ5OQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514610499", "bodyText": "So I'll keep requestApiKey as it originally was and just add a new one requestApiKeyName.", "author": "anatasiavela", "createdAt": "2020-10-29T22:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExNTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzNTc4NA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514635784", "bodyText": "How about requestApi or requestApiName?", "author": "lbradstreet", "createdAt": "2020-10-30T00:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExNTk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExODYwMw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514118603", "bodyText": "nit: Could we align them with header?", "author": "dajac", "createdAt": "2020-10-29T09:30:29Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExOTU3MA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514119570", "bodyText": "I wonder if we should also structure the client information in JSON instead of relying on the string representation of the object. That would make the information more accessible.", "author": "dajac", "createdAt": "2020-10-29T09:31:57Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3NjEwNQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514576105", "bodyText": "Yes, I agree, this would be helpful if it's not too difficult.", "author": "lbradstreet", "createdAt": "2020-10-29T21:23:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExOTU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyMTI2Ng==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514121266", "bodyText": "Should we add unit tests for these helper methods? I mean that it would be great to ensure that the format of the JSON is equivalent to the JSON what will be generated by the auto-generated protocol.", "author": "dajac", "createdAt": "2020-10-29T09:34:42Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzNjk5Nw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514636997", "bodyText": "Good point, I'll add it.", "author": "anatasiavela", "createdAt": "2020-10-30T00:11:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyMTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyMTM3OQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514121379", "bodyText": "I am working on this one :)", "author": "dajac", "createdAt": "2020-10-29T09:34:54Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxNzYyNg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514617626", "bodyText": "Yay! Excited for this to make even more consistent with other request types.", "author": "anatasiavela", "createdAt": "2020-10-29T23:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyMTM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyNzgyNg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514127826", "bodyText": "nit: We may be able to use request.partitionSizes().forEach directly.", "author": "dajac", "createdAt": "2020-10-29T09:45:04Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topicsToPartitionEpochs = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    for (topicToEpochs <- topicsToPartitionEpochs.entrySet.asScala) {\n+      val topicsData = new ObjectNode(JsonNodeFactory.instance)\n+      topicsData.set(\"name\", new TextNode(topicToEpochs.getKey))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      for (partitionEpoch <- topicToEpochs.getValue.entrySet.asScala) {\n+        val partitionData = partitionEpoch.getValue\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionEpoch.getKey))\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicsData.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicsData)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceRequestNode(request: ProduceRequest, version: Short, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      if (request.transactionalId == null) {\n+        node.set(\"transactionalId\", NullNode.instance)\n+      } else {\n+        node.set(\"transactionalId\", new TextNode(request.transactionalId))\n+      }\n+    }\n+    node.set(\"acks\", new ShortNode(request.acks))\n+    node.set(\"timeoutMs\", new IntNode(request.timeout))\n+    if (verbose) {\n+      val partSizes = new ArrayNode(JsonNodeFactory.instance)\n+      for (partSize <- request.partitionSizes().entrySet.asScala) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyOTMxMA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514129310", "bodyText": "We are using the topic for the partition here. I suppose that we need both, isn't it?", "author": "dajac", "createdAt": "2020-10-29T09:47:24Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topicsToPartitionEpochs = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    for (topicToEpochs <- topicsToPartitionEpochs.entrySet.asScala) {\n+      val topicsData = new ObjectNode(JsonNodeFactory.instance)\n+      topicsData.set(\"name\", new TextNode(topicToEpochs.getKey))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      for (partitionEpoch <- topicToEpochs.getValue.entrySet.asScala) {\n+        val partitionData = partitionEpoch.getValue\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionEpoch.getKey))\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicsData.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicsData)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceRequestNode(request: ProduceRequest, version: Short, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      if (request.transactionalId == null) {\n+        node.set(\"transactionalId\", NullNode.instance)\n+      } else {\n+        node.set(\"transactionalId\", new TextNode(request.transactionalId))\n+      }\n+    }\n+    node.set(\"acks\", new ShortNode(request.acks))\n+    node.set(\"timeoutMs\", new IntNode(request.timeout))\n+    if (verbose) {\n+      val partSizes = new ArrayNode(JsonNodeFactory.instance)\n+      for (partSize <- request.partitionSizes().entrySet.asScala) {\n+        val part = new ObjectNode(JsonNodeFactory.instance)\n+        val topic = partSize.getKey\n+        part.set(\"partition\", new TextNode(topic.toString))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg2MTM4OQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514861389", "bodyText": "Changed to match the auto-generated schema.", "author": "anatasiavela", "createdAt": "2020-10-30T04:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyOTMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEzMDEzMQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514130131", "bodyText": "It is a bit weird to have partitionSizes used with two different type of value. It seems that we were previously using numPartitions for this case.", "author": "dajac", "createdAt": "2020-10-29T09:48:46Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topicsToPartitionEpochs = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    for (topicToEpochs <- topicsToPartitionEpochs.entrySet.asScala) {\n+      val topicsData = new ObjectNode(JsonNodeFactory.instance)\n+      topicsData.set(\"name\", new TextNode(topicToEpochs.getKey))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      for (partitionEpoch <- topicToEpochs.getValue.entrySet.asScala) {\n+        val partitionData = partitionEpoch.getValue\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionEpoch.getKey))\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicsData.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicsData)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceRequestNode(request: ProduceRequest, version: Short, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      if (request.transactionalId == null) {\n+        node.set(\"transactionalId\", NullNode.instance)\n+      } else {\n+        node.set(\"transactionalId\", new TextNode(request.transactionalId))\n+      }\n+    }\n+    node.set(\"acks\", new ShortNode(request.acks))\n+    node.set(\"timeoutMs\", new IntNode(request.timeout))\n+    if (verbose) {\n+      val partSizes = new ArrayNode(JsonNodeFactory.instance)\n+      for (partSize <- request.partitionSizes().entrySet.asScala) {\n+        val part = new ObjectNode(JsonNodeFactory.instance)\n+        val topic = partSize.getKey\n+        part.set(\"partition\", new TextNode(topic.toString))\n+        part.set(\"size\", new IntNode(partSize.getValue))\n+        partSizes.add(part)\n+      }\n+      node.set(\"partitionSizes\", partSizes)\n+    } else {\n+      node.set(\"partitionSizes\", new IntNode(request.partitionSizes.size))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg2MTk5MQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514861991", "bodyText": "Changed to match the auto-generated schema.", "author": "anatasiavela", "createdAt": "2020-10-30T04:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEzMDEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEzMjI3OA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514132278", "bodyText": "It is important to note that the format of the JSON will change when we move to the generated schema. partitionSizes does not exist in the schema. Thus, I wonder if we should better align directly; or keep this exception forever. Have we thought about this?\nSimilarly in the FetchResponse, we were outputting recordsSizeInBytes per partition and it seems that now we put an empty recordSet field. cc @lbradstreet", "author": "dajac", "createdAt": "2020-10-29T09:52:12Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topicsToPartitionEpochs = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    for (topicToEpochs <- topicsToPartitionEpochs.entrySet.asScala) {\n+      val topicsData = new ObjectNode(JsonNodeFactory.instance)\n+      topicsData.set(\"name\", new TextNode(topicToEpochs.getKey))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      for (partitionEpoch <- topicToEpochs.getValue.entrySet.asScala) {\n+        val partitionData = partitionEpoch.getValue\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionEpoch.getKey))\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicsData.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicsData)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3NzAyMQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514577021", "bodyText": "I think that is fair, it would be good to align now. With the FetchResponse I would like to circle back on it and provide more detail. If not the recordSizeInBytes in the FetchResponse I think we need to include a top level responseSizeBytes in the trace.", "author": "lbradstreet", "createdAt": "2020-10-29T21:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEzMjI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg4MjQ3Mw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514882473", "bodyText": "I've change it back to reflect what the auto-generated schema produces. The reason we didn't have it match the auto-generated schema was because it copies every byte of the record into the records field which could be expensive. If this isn't really a problem, I'll leave it as this.", "author": "anatasiavela", "createdAt": "2020-10-30T05:41:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEzMjI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ5NDgyMQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r515494821", "bodyText": "Actually, it is probably better to not serialize the records in our case. Records could be large and bytes are not that useful. I suppose that having the number of bytes as a field like we had before is likely way more valuable. Should we bring back the amount of bytes per partition for both the Fetch response and the Produce request? @lbradstreet What do you think?", "author": "dajac", "createdAt": "2020-10-31T12:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEzMjI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY2MTY2OA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r515661668", "bodyText": "I agree that we shouldn't serialize the records. If it's easy to change the recordSet autogenerated JSON output I think it would be great to retain the sizes. This is something that I wanted to follow up with in a later PR but if we can do it now I think it would be very helpful.", "author": "lbradstreet", "createdAt": "2020-11-01T19:29:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEzMjI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4ODU1OA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r516288558", "bodyText": "I changed the recordSet autogenerated JSON output to be the number of bytes, instead of an empty byte array.", "author": "anatasiavela", "createdAt": "2020-11-02T22:19:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEzMjI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE0MDMxNQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514140315", "bodyText": "Shouldn't we only catch AssertionError here and below?", "author": "dajac", "createdAt": "2020-10-29T10:05:04Z", "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util.HashMap\n+\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.record.MemoryRecords\n+import org.apache.kafka.common.requests._\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  def createRequestsFromApiKey(apiKey: ApiKeys, version: Short): AbstractRequest = apiKey match {\n+    case ApiKeys.PRODUCE => ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new HashMap[TopicPartition, MemoryRecords]()).build()\n+    case ApiKeys.FETCH => new FetchRequest(new FetchRequestData(), version)\n+    case ApiKeys.LIST_OFFSETS => new ListOffsetRequest(new ListOffsetRequestData().toStruct(version), version)\n+    case ApiKeys.METADATA => new MetadataRequest(new MetadataRequestData(), version)\n+    case ApiKeys.OFFSET_COMMIT => new OffsetCommitRequest(new OffsetCommitRequestData(), version)\n+    case ApiKeys.OFFSET_FETCH => new OffsetFetchRequest(new OffsetFetchRequestData().toStruct(version), version)\n+    case ApiKeys.FIND_COORDINATOR => new FindCoordinatorRequest(new FindCoordinatorRequestData().toStruct(version), version)\n+    case ApiKeys.JOIN_GROUP => new JoinGroupRequest(new JoinGroupRequestData(), version)\n+    case ApiKeys.HEARTBEAT => new HeartbeatRequest(new HeartbeatRequestData().toStruct(version), version)\n+    case ApiKeys.LEAVE_GROUP => new LeaveGroupRequest(new LeaveGroupRequestData().toStruct(version), version)\n+    case ApiKeys.SYNC_GROUP => new SyncGroupRequest(new SyncGroupRequestData(), version)\n+    case ApiKeys.STOP_REPLICA => new StopReplicaRequest(new StopReplicaRequestData().toStruct(version), version)\n+    case ApiKeys.CONTROLLED_SHUTDOWN => new ControlledShutdownRequest(new ControlledShutdownRequestData().toStruct(version), version)\n+    case ApiKeys.UPDATE_METADATA => new UpdateMetadataRequest(new UpdateMetadataRequestData().toStruct(version), version)\n+    case ApiKeys.LEADER_AND_ISR => new LeaderAndIsrRequest(new LeaderAndIsrRequestData().toStruct(version), version)\n+    case ApiKeys.DESCRIBE_GROUPS => new DescribeGroupsRequest(new DescribeGroupsRequestData().toStruct(version), version)\n+    case ApiKeys.LIST_GROUPS => new ListGroupsRequest(new ListGroupsRequestData(), version)\n+    case ApiKeys.SASL_HANDSHAKE => new SaslHandshakeRequest(new SaslHandshakeRequestData())\n+    case ApiKeys.API_VERSIONS => new ApiVersionsRequest(new ApiVersionsRequestData(), version)\n+    case ApiKeys.CREATE_TOPICS => new CreateTopicsRequest(new CreateTopicsRequestData().toStruct(version), version)\n+    case ApiKeys.DELETE_TOPICS => new DeleteTopicsRequest(new DeleteTopicsRequestData().toStruct(version), version)\n+    case ApiKeys.DELETE_RECORDS => new DeleteRecordsRequest(new DeleteRecordsRequestData().toStruct(version), version)\n+    case ApiKeys.INIT_PRODUCER_ID => new InitProducerIdRequest(new InitProducerIdRequestData().toStruct(version), version)\n+    case ApiKeys.OFFSET_FOR_LEADER_EPOCH => new OffsetsForLeaderEpochRequest(new OffsetForLeaderEpochResponseData().toStruct(version), version)\n+    case ApiKeys.ADD_PARTITIONS_TO_TXN => new AddPartitionsToTxnRequest(new AddPartitionsToTxnRequestData(), version)\n+    case ApiKeys.ADD_OFFSETS_TO_TXN => new AddOffsetsToTxnRequest(new AddOffsetsToTxnRequestData(), version)\n+    case ApiKeys.END_TXN =>  new EndTxnRequest(new EndTxnRequestData().toStruct(version), version)\n+    case ApiKeys.WRITE_TXN_MARKERS =>  new WriteTxnMarkersRequest(new WriteTxnMarkersRequestData().toStruct(version), version)\n+    case ApiKeys.TXN_OFFSET_COMMIT => new TxnOffsetCommitRequest(new TxnOffsetCommitRequestData(), version)\n+    case ApiKeys.DESCRIBE_ACLS =>\n+      val data = new DescribeAclsRequestData().setResourceTypeFilter(1).setOperation(2).setPermissionType(2)\n+      new DescribeAclsRequest(data.toStruct(version), version)\n+    case ApiKeys.CREATE_ACLS =>  new CreateAclsRequest(new CreateAclsRequestData().toStruct(version), version)\n+    case ApiKeys.DELETE_ACLS => new DeleteAclsRequest(new DeleteAclsRequestData().toStruct(version), version)\n+    case ApiKeys.DESCRIBE_CONFIGS => new DescribeConfigsRequest(new DescribeConfigsRequestData(), version)\n+    case ApiKeys.ALTER_CONFIGS => new AlterConfigsRequest(new AlterConfigsRequestData(), version)\n+    case ApiKeys.ALTER_REPLICA_LOG_DIRS =>  new AlterReplicaLogDirsRequest(new AlterReplicaLogDirsRequestData(), version)\n+    case ApiKeys.DESCRIBE_LOG_DIRS => new DescribeLogDirsRequest(new DescribeLogDirsRequestData(), version)\n+    case ApiKeys.SASL_AUTHENTICATE => new SaslAuthenticateRequest(new SaslAuthenticateRequestData(), version)\n+    case ApiKeys.CREATE_PARTITIONS => new CreatePartitionsRequest(new CreatePartitionsRequestData().toStruct(version), version)\n+    case ApiKeys.CREATE_DELEGATION_TOKEN => new CreateDelegationTokenRequest(new CreateDelegationTokenRequestData().toStruct(version), version)\n+    case ApiKeys.RENEW_DELEGATION_TOKEN => new RenewDelegationTokenRequest(new RenewDelegationTokenRequestData(), version)\n+    case ApiKeys.EXPIRE_DELEGATION_TOKEN => new ExpireDelegationTokenRequest(new ExpireDelegationTokenRequestData().toStruct(version), version)\n+    case ApiKeys.DESCRIBE_DELEGATION_TOKEN => new DescribeDelegationTokenRequest(new DescribeDelegationTokenRequestData(), version)\n+    case ApiKeys.DELETE_GROUPS => new DeleteGroupsRequest(new DeleteGroupsRequestData(), version)\n+    case ApiKeys.ELECT_LEADERS => new ElectLeadersRequest(new ElectLeadersRequestData().toStruct(version), version)\n+    case ApiKeys.INCREMENTAL_ALTER_CONFIGS => new IncrementalAlterConfigsRequest.Builder(new IncrementalAlterConfigsRequestData()).build(version)\n+    case ApiKeys.ALTER_PARTITION_REASSIGNMENTS => new AlterPartitionReassignmentsRequest.Builder(new AlterPartitionReassignmentsRequestData()).build(version)\n+    case ApiKeys.LIST_PARTITION_REASSIGNMENTS => new ListPartitionReassignmentsRequest.Builder(new ListPartitionReassignmentsRequestData()).build(version)\n+    case ApiKeys.OFFSET_DELETE => new OffsetDeleteRequest(new OffsetDeleteRequestData(), version)\n+    case ApiKeys.DESCRIBE_CLIENT_QUOTAS => new DescribeClientQuotasRequest(new DescribeClientQuotasRequestData(), version)\n+    case ApiKeys.ALTER_CLIENT_QUOTAS => new AlterClientQuotasRequest(new AlterClientQuotasRequestData(), version)\n+    case ApiKeys.DESCRIBE_USER_SCRAM_CREDENTIALS => new DescribeUserScramCredentialsRequest.Builder(new DescribeUserScramCredentialsRequestData()).build(version)\n+    case ApiKeys.ALTER_USER_SCRAM_CREDENTIALS => new AlterUserScramCredentialsRequest.Builder(new AlterUserScramCredentialsRequestData()).build(version)\n+    case ApiKeys.VOTE => new VoteRequest.Builder(new VoteRequestData()).build(version)\n+    case ApiKeys.BEGIN_QUORUM_EPOCH => new BeginQuorumEpochRequest.Builder(new BeginQuorumEpochRequestData()).build(version)\n+    case ApiKeys.END_QUORUM_EPOCH => new EndQuorumEpochRequest.Builder(new EndQuorumEpochRequestData()).build(version)\n+    case ApiKeys.DESCRIBE_QUORUM => new DescribeQuorumRequest.Builder(new DescribeQuorumRequestData()).build(version)\n+    case ApiKeys.ALTER_ISR => new AlterIsrRequest.Builder(new AlterIsrRequestData()).build(version)\n+    case ApiKeys.UPDATE_FEATURES => new UpdateFeaturesRequest.Builder(new UpdateFeaturesRequestData()).build(version)\n+    case _ => throw new AssertionError(String.format(\"Request type %s is not tested in `RequestConvertToJsonTest`\", apiKey))\n+  }\n+\n+  def createResponseFromApiKey(apiKey: ApiKeys, version: Short): AbstractResponse = apiKey match {\n+    case ApiKeys.PRODUCE => new ProduceResponse(new ProduceResponseData().toStruct(version))\n+    case ApiKeys.FETCH => new FetchResponse(new FetchResponseData())\n+    case ApiKeys.LIST_OFFSETS => new ListOffsetResponse(new ListOffsetResponseData())\n+    case ApiKeys.METADATA => new MetadataResponse(new MetadataResponseData())\n+    case ApiKeys.OFFSET_COMMIT => new OffsetCommitResponse(new OffsetCommitResponseData())\n+    case ApiKeys.OFFSET_FETCH => new OffsetFetchResponse(new OffsetFetchResponseData().toStruct(version), version)\n+    case ApiKeys.FIND_COORDINATOR => new FindCoordinatorResponse(new FindCoordinatorResponseData())\n+    case ApiKeys.JOIN_GROUP => new JoinGroupResponse(new JoinGroupResponseData())\n+    case ApiKeys.HEARTBEAT => new HeartbeatResponse(new HeartbeatResponseData())\n+    case ApiKeys.LEAVE_GROUP => new LeaveGroupResponse(new LeaveGroupResponseData())\n+    case ApiKeys.SYNC_GROUP => new SyncGroupResponse(new SyncGroupResponseData())\n+    case ApiKeys.STOP_REPLICA => new StopReplicaResponse(new StopReplicaResponseData())\n+    case ApiKeys.CONTROLLED_SHUTDOWN => new ControlledShutdownResponse(new ControlledShutdownResponseData())\n+    case ApiKeys.UPDATE_METADATA => new UpdateMetadataResponse(new UpdateMetadataResponseData())\n+    case ApiKeys.LEADER_AND_ISR => new LeaderAndIsrResponse(new LeaderAndIsrResponseData())\n+    case ApiKeys.DESCRIBE_GROUPS => new DescribeGroupsResponse(new DescribeGroupsResponseData())\n+    case ApiKeys.LIST_GROUPS => new ListGroupsResponse(new ListGroupsResponseData())\n+    case ApiKeys.SASL_HANDSHAKE => new SaslHandshakeResponse(new SaslHandshakeResponseData())\n+    case ApiKeys.API_VERSIONS => new ApiVersionsResponse(new ApiVersionsResponseData())\n+    case ApiKeys.CREATE_TOPICS => new CreateTopicsResponse(new CreateTopicsResponseData())\n+    case ApiKeys.DELETE_TOPICS => new DeleteTopicsResponse(new DeleteTopicsResponseData())\n+    case ApiKeys.DELETE_RECORDS => new DeleteRecordsResponse(new DeleteRecordsResponseData())\n+    case ApiKeys.INIT_PRODUCER_ID => new InitProducerIdResponse(new InitProducerIdResponseData())\n+    case ApiKeys.OFFSET_FOR_LEADER_EPOCH => new OffsetsForLeaderEpochResponse(new OffsetForLeaderEpochResponseData().toStruct(version))\n+    case ApiKeys.ADD_PARTITIONS_TO_TXN => new AddPartitionsToTxnResponse(new AddPartitionsToTxnResponseData().toStruct(version), version)\n+    case ApiKeys.ADD_OFFSETS_TO_TXN => new AddOffsetsToTxnResponse(new AddOffsetsToTxnResponseData())\n+    case ApiKeys.END_TXN => new EndTxnResponse(new EndTxnResponseData())\n+    case ApiKeys.WRITE_TXN_MARKERS => new WriteTxnMarkersResponse(new WriteTxnMarkersResponseData().toStruct(version), version)\n+    case ApiKeys.TXN_OFFSET_COMMIT => new TxnOffsetCommitResponse(new TxnOffsetCommitResponseData())\n+    case ApiKeys.DESCRIBE_ACLS => new DescribeAclsResponse(new DescribeAclsResponseData())\n+    case ApiKeys.CREATE_ACLS => new CreateAclsResponse(new CreateAclsResponseData())\n+    case ApiKeys.DELETE_ACLS => new DeleteAclsResponse(new DeleteAclsResponseData())\n+    case ApiKeys.DESCRIBE_CONFIGS => new DescribeConfigsResponse(new DescribeConfigsResponseData())\n+    case ApiKeys.ALTER_CONFIGS => new AlterConfigsResponse(new AlterConfigsResponseData())\n+    case ApiKeys.ALTER_REPLICA_LOG_DIRS => new AlterReplicaLogDirsResponse(new AlterReplicaLogDirsResponseData())\n+    case ApiKeys.DESCRIBE_LOG_DIRS => new DescribeLogDirsResponse(new DescribeLogDirsResponseData())\n+    case ApiKeys.SASL_AUTHENTICATE => new SaslAuthenticateResponse(new SaslAuthenticateResponseData())\n+    case ApiKeys.CREATE_PARTITIONS => new CreatePartitionsResponse(new CreatePartitionsResponseData())\n+    case ApiKeys.CREATE_DELEGATION_TOKEN => new CreateDelegationTokenResponse(new CreateDelegationTokenResponseData())\n+    case ApiKeys.RENEW_DELEGATION_TOKEN => new RenewDelegationTokenResponse(new RenewDelegationTokenResponseData())\n+    case ApiKeys.EXPIRE_DELEGATION_TOKEN => new ExpireDelegationTokenResponse(new ExpireDelegationTokenResponseData())\n+    case ApiKeys.DESCRIBE_DELEGATION_TOKEN => new DescribeDelegationTokenResponse(new DescribeDelegationTokenResponseData().toStruct(version), version)\n+    case ApiKeys.DELETE_GROUPS => new DeleteGroupsResponse(new DeleteGroupsResponseData())\n+    case ApiKeys.ELECT_LEADERS => new ElectLeadersResponse(new ElectLeadersResponseData().toStruct(version), version)\n+    case ApiKeys.INCREMENTAL_ALTER_CONFIGS => new IncrementalAlterConfigsResponse(new IncrementalAlterConfigsResponseData())\n+    case ApiKeys.ALTER_PARTITION_REASSIGNMENTS => new AlterPartitionReassignmentsResponse(new AlterPartitionReassignmentsResponseData())\n+    case ApiKeys.LIST_PARTITION_REASSIGNMENTS => new ListPartitionReassignmentsResponse(new ListPartitionReassignmentsResponseData())\n+    case ApiKeys.OFFSET_DELETE => new OffsetDeleteResponse(new OffsetDeleteResponseData())\n+    case ApiKeys.DESCRIBE_CLIENT_QUOTAS => new DescribeClientQuotasResponse(new DescribeClientQuotasResponseData().toStruct(version), version)\n+    case ApiKeys.ALTER_CLIENT_QUOTAS => new AlterClientQuotasResponse(new AlterClientQuotasResponseData().toStruct(version), version)\n+    case ApiKeys.DESCRIBE_USER_SCRAM_CREDENTIALS => new DescribeUserScramCredentialsResponse(new DescribeUserScramCredentialsResponseData())\n+    case ApiKeys.ALTER_USER_SCRAM_CREDENTIALS => new AlterUserScramCredentialsResponse(new AlterUserScramCredentialsResponseData())\n+    case ApiKeys.VOTE => new VoteResponse(new VoteResponseData())\n+    case ApiKeys.BEGIN_QUORUM_EPOCH => new BeginQuorumEpochResponse(new BeginQuorumEpochResponseData())\n+    case ApiKeys.END_QUORUM_EPOCH => new EndQuorumEpochResponse(new EndQuorumEpochResponseData())\n+    case ApiKeys.DESCRIBE_QUORUM => new DescribeQuorumResponse(new DescribeQuorumResponseData())\n+    case ApiKeys.ALTER_ISR => new AlterIsrResponse(new AlterIsrResponseData())\n+    case ApiKeys.UPDATE_FEATURES => new UpdateFeaturesResponse(new UpdateFeaturesResponseData())\n+    case _ => throw new AssertionError(String.format(\"Response type %s not tested in `RequestConvertToJsonTest`\", apiKey))\n+  }\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      val req = createRequestsFromApiKey(key, version)\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : Throwable => unhandledKeys += key.toString", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MDA1MQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514150051", "bodyText": "Why are we using toStruct in some cases and passing the *Data object directly in others?", "author": "dajac", "createdAt": "2020-10-29T10:21:06Z", "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util.HashMap\n+\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.record.MemoryRecords\n+import org.apache.kafka.common.requests._\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  def createRequestsFromApiKey(apiKey: ApiKeys, version: Short): AbstractRequest = apiKey match {\n+    case ApiKeys.PRODUCE => ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new HashMap[TopicPartition, MemoryRecords]()).build()\n+    case ApiKeys.FETCH => new FetchRequest(new FetchRequestData(), version)\n+    case ApiKeys.LIST_OFFSETS => new ListOffsetRequest(new ListOffsetRequestData().toStruct(version), version)\n+    case ApiKeys.METADATA => new MetadataRequest(new MetadataRequestData(), version)\n+    case ApiKeys.OFFSET_COMMIT => new OffsetCommitRequest(new OffsetCommitRequestData(), version)\n+    case ApiKeys.OFFSET_FETCH => new OffsetFetchRequest(new OffsetFetchRequestData().toStruct(version), version)\n+    case ApiKeys.FIND_COORDINATOR => new FindCoordinatorRequest(new FindCoordinatorRequestData().toStruct(version), version)\n+    case ApiKeys.JOIN_GROUP => new JoinGroupRequest(new JoinGroupRequestData(), version)\n+    case ApiKeys.HEARTBEAT => new HeartbeatRequest(new HeartbeatRequestData().toStruct(version), version)\n+    case ApiKeys.LEAVE_GROUP => new LeaveGroupRequest(new LeaveGroupRequestData().toStruct(version), version)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxOTg5MQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514619891", "bodyText": "I guess this is related with the inconsistency issue, but I tried not to make too many changes. The constructors with the data parameters were private in some cases, so I used the toStruct. But for consistency, I'll change to use toStruct instead.", "author": "anatasiavela", "createdAt": "2020-10-29T23:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MDA1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg3MjQ3Nw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514872477", "bodyText": "Actually, I found a workaround for this mapping and removed it all together, so there'd be one less apikey mapping to maintain.", "author": "anatasiavela", "createdAt": "2020-10-30T05:17:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MDA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3Nzk5Mg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514577992", "bodyText": "I was thinking a bit more about the time fields, and I think we should add Ms to the end of all of them. What do you think?", "author": "lbradstreet", "createdAt": "2020-10-29T21:26:50Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYyMTU2MQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514621561", "bodyText": "I'm for it, that would be more descriptive.", "author": "anatasiavela", "createdAt": "2020-10-29T23:19:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3Nzk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwMzMwNg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r515303306", "bodyText": "nit: unnecessary call of toString.", "author": "splett2", "createdAt": "2020-10-30T18:34:59Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -131,7 +131,7 @@ class KafkaApis(val requestChannel: RequestChannel,\n    */\n   override def handle(request: RequestChannel.Request): Unit = {\n     try {\n-      trace(s\"Handling request:${request.requestDesc(true)} from connection ${request.context.connectionId};\" +\n+      trace(s\"Handling request:${RequestConvertToJson.requestDesc(request.header, request.loggableRequest, true).toString} from connection ${request.context.connectionId};\" +", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUyNDE3MQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r515524171", "bodyText": "nit: we can use scala interpolated string instead of String.format, unnecessary semicolon.\nalso, our error message mentions ApiKey, but the templated argument is response.\nDitto for request.", "author": "splett2", "createdAt": "2020-10-31T18:18:12Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version)\n+      case req: ProduceRequest => produceRequestNode(req, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new AssertionError(String.format(\"ApiKey %s is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\", request));\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new AssertionError(String.format(\"ApiKey %s is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\", response));\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU1MDI1Mg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r515550252", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assert(unhandledKeys.isEmpty, String.format(\"%s request keys not handled in RequestConvertToJson\", unhandledKeys))\n          \n          \n            \n                assertEquals(\"Unhandled request keys\", ArrayBuffer.empty, unhandledKeys))\n          \n      \n    \n    \n  \n\nnit: we should prefer to use junit assertions.\nditto for testAllResponseTypesHandled.\nThese cases are not too bad because the assertion has a failure message.", "author": "splett2", "createdAt": "2020-10-31T23:02:16Z", "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{CompressionType, MemoryRecords, RecordBatch, TimestampType}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]()).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : AssertionError => unhandledKeys += key.toString\n+      }\n+    })\n+    assert(unhandledKeys.isEmpty, String.format(\"%s request keys not handled in RequestConvertToJson\", unhandledKeys))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU1MDQ3OQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r515550479", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assert(manualGenNode.equals(autoGenNode))\n          \n          \n            \n                assertEquals(autoGenNode, manualGenNode)\n          \n      \n    \n    \n  \n\nusing assertEquals instead of assert(boolean) makes this test easier to debug, since if it fails we get a helpful print out of the objects. ditto for other testFormat tests.", "author": "splett2", "createdAt": "2020-10-31T23:04:53Z", "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{CompressionType, MemoryRecords, RecordBatch, TimestampType}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]()).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : AssertionError => unhandledKeys += key.toString\n+      }\n+    })\n+    assert(unhandledKeys.isEmpty, String.format(\"%s request keys not handled in RequestConvertToJson\", unhandledKeys))\n+  }\n+\n+  @Test\n+  def testAllResponseTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      val struct = ApiMessageType.fromApiKey(key.id).newResponse().toStruct(version)\n+      val res = AbstractResponse.parseResponse(key, struct, version)\n+      try {\n+        RequestConvertToJson.response(res, version)\n+      } catch {\n+        case _ : AssertionError => unhandledKeys += key.toString\n+      }\n+    })\n+    assert(unhandledKeys.isEmpty, String.format(\"%s response keys not handled in RequestConvertToJson\", unhandledKeys))\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochRequestNode(): Unit = {\n+    val partitionDataMap = new util.HashMap[TopicPartition, PartitionData]\n+    partitionDataMap.put(new TopicPartition(\"topic1\", 0), new PartitionData(Optional.of(0),  1))\n+\n+    val version: Short = 3\n+    val request = OffsetsForLeaderEpochRequest.Builder.forConsumer(partitionDataMap).build(version)\n+    val manualGenNode = RequestConvertToJson.request(request, false)\n+\n+    val requestData = OffsetForLeaderEpochRequestDataJsonConverter.read(manualGenNode, version)\n+    val autoGenNode = OffsetForLeaderEpochRequestDataJsonConverter.write(requestData, version)\n+\n+    assert(manualGenNode.equals(autoGenNode))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxNjU0Mg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517316542", "bodyText": "IllegaleStateException sounds more appropriate here and below.", "author": "dajac", "createdAt": "2020-11-04T12:44:14Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version)\n+      case req: ProduceRequest => produceRequestNode(req, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new AssertionError(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxNzM1NA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517317354", "bodyText": "It seems that verbose is not used anymore. I think that we were dumping the full Produce request and Fetch response when verbose was true. Should we just remove it?", "author": "dajac", "createdAt": "2020-11-04T12:45:41Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY0NTcxOA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517645718", "bodyText": "Yes, I kept it because requestDescMetrics originally had the detailsEnabled, but I'll remove it since none of the JsonConverters differentiates between verbose and non-verbose.", "author": "anatasiavela", "createdAt": "2020-11-04T21:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxNzM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY1MTc0Mg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517651742", "bodyText": "Just read through the comment below, so I'll keep the verbose flag for now, but I'll remove it depending on what we decide below.", "author": "anatasiavela", "createdAt": "2020-11-04T21:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxNzM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5Mjg0NQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518192845", "bodyText": "I think that we can remove this verbose flag here and only set it to false for both the produce request and the fetch response. I don't think that we will ever want to print out the bytes in the request log. Previously, we were printing out different things based on the flag but we never printed out the bytes: https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/common/requests/ProduceRequest.java#L314.", "author": "dajac", "createdAt": "2020-11-05T16:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxNzM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxNzY1NA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517317654", "bodyText": "softwareName -> softwareVersion?", "author": "dajac", "createdAt": "2020-11-04T12:46:11Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version)\n+      case req: ProduceRequest => produceRequestNode(req, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new AssertionError(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new AssertionError(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName()))\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareVersion()))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxOTU1Mw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517319553", "bodyText": "nit: Missing space before =>.", "author": "dajac", "createdAt": "2020-11-04T12:49:48Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version)\n+      case req: ProduceRequest => produceRequestNode(req, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new AssertionError(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new AssertionError(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName()))\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareVersion()))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                         context: RequestContext, session: Session, verbose: Boolean,\n+                         totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                         apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                         responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                         messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTimeMs\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTimeMs\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTimeMs\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTimeMs\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTimeMs\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTimeMs\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTimeMs\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", clientInfoNode(context.clientInformation))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData) =>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicNode.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicNode)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceRequestNode(request: ProduceRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      if (request.transactionalId == null) {\n+        node.set(\"transactionalId\", NullNode.instance)\n+      } else {\n+        node.set(\"transactionalId\", new TextNode(request.transactionalId))\n+      }\n+    }\n+    node.set(\"acks\", new ShortNode(request.acks))\n+    node.set(\"timeoutMs\", new IntNode(request.timeout))\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.partitionRecordsOrFail())\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData)=>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxOTgxOQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517319819", "bodyText": "This is not consistent with the changes that have been made in the automated protocol.", "author": "dajac", "createdAt": "2020-11-04T12:50:16Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version)\n+      case req: ProduceRequest => produceRequestNode(req, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new AssertionError(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new AssertionError(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName()))\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareVersion()))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                         context: RequestContext, session: Session, verbose: Boolean,\n+                         totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                         apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                         responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                         messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTimeMs\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTimeMs\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTimeMs\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTimeMs\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTimeMs\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTimeMs\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTimeMs\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", clientInfoNode(context.clientInformation))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData) =>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicNode.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicNode)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceRequestNode(request: ProduceRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      if (request.transactionalId == null) {\n+        node.set(\"transactionalId\", NullNode.instance)\n+      } else {\n+        node.set(\"transactionalId\", new TextNode(request.transactionalId))\n+      }\n+    }\n+    node.set(\"acks\", new ShortNode(request.acks))\n+    node.set(\"timeoutMs\", new IntNode(request.timeout))\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.partitionRecordsOrFail())\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData)=>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (partitionData == null)\n+          partitionNode.set(\"records\", NullNode.instance)\n+        else\n+          partitionNode.set(\"records\", new BinaryNode(util.Arrays.copyOf(partitionData.buffer().array(), partitionData.validBytes())))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY0OTIxOQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517649219", "bodyText": "The ProduceRequest does not match the conditions for the change made in the automated protocol. The records field is of type bytes in ProduceRequest, whereas the change to the protocol only effects fields of type records like in FetchResponse.", "author": "anatasiavela", "createdAt": "2020-11-04T21:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxOTgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4OTk4Nw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518189987", "bodyText": "Right. I think that we will change it to records type when we will migrate the produce request. Anyway, we should not serialize the bytes to JSON here but rather put the size. We should retain the size of the records set for both the produce request and the fetch response.", "author": "dajac", "createdAt": "2020-11-05T16:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxOTgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM2MzQ5MA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518363490", "bodyText": "This ends up breaking testFormatOfProduceRequestNode() because it can't deserialize and serialize the data because of the inconsistency problem discussed below.", "author": "anatasiavela", "createdAt": "2020-11-05T21:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxOTgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NzAzMA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518387030", "bodyText": "Right. We need to update that test for the time being until we migrate the produce request/response. We may be able to verify the output differently.", "author": "dajac", "createdAt": "2020-11-05T21:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxOTgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0Mjk5Nw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517342997", "bodyText": "I am not entirely convinced by this change. The aim of the auto-generated protocol is to serialize/deserialise the requests/responses. Thus, it is a little weird that we only retain the size when serializing records to JSON and we actually expect bytes when deserializing from JSON. We are not consistent.\nI can think of the following alternatives:\n\nWe keep exceptions for both the produce request and the fetch response in RequestConvertToJson where we could add a recordsSizeInBytes field instead of the records field.\nWe could post-process the JSON tree where we could discard records and add recordsSizeInBytes.\nWe could extend the autogenerated protocol to do only retain the size based on a flag. I am thinking about a verbose flag like we had before.\n\nI lean towards 3) at the moment. By default, we should keep the current behavior and only retains the size when verbose is false. We may find a better name than verbose though.\n@anatasiavela @lbradstreet Would this make sense?", "author": "dajac", "createdAt": "2020-11-04T13:30:40Z", "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -380,8 +380,9 @@ private void generateVariableLengthTargetToJson(Target target, Versions versions\n                         target.sourceVariable(), target.sourceVariable())));\n             }\n         } else if (target.field().type().isRecords()) {\n-            headerGenerator.addImport(MessageGenerator.BINARY_NODE_CLASS);\n-            buffer.printf(\"%s;%n\", target.assignmentStatement(\"new BinaryNode(new byte[]{})\"));\n+            headerGenerator.addImport(MessageGenerator.INT_NODE_CLASS);\n+            buffer.printf(\"%s;%n\", target.assignmentStatement(\n+                    String.format(\"new IntNode(%s.sizeInBytes())\", target.sourceVariable())));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2MjM0OA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517562348", "bodyText": "@dajac if I understand correctly, the current generated JSON does not print the recordSet either. Is it breaking anything to return the size rather than an empty array?\n            }\n            if (_object.recordSet == null) {\n                _node.set(\"recordSet\", NullNode.instance);\n            } else {\n                _node.set(\"recordSet\", new BinaryNode(new byte[]{}));\n            }\n\nThat said, implementing a verbose mode (3) where we print out a byte array seems reasonable if we don't use it in the trace logging path by default?", "author": "lbradstreet", "createdAt": "2020-11-04T18:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0Mjk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY2NTM4Mw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517665383", "bodyText": "@lbradstreet The current generated JSON does not print the recordSet either. But when we are serializing a BinaryNode with an empty array, it is still being deserialized as a BinaryNode, so it doesn't break anything.\n            buffer.printf(\"%s;%n\", target.assignmentStatement(\n                String.format(\"MemoryRecords.readableRecords(ByteBuffer.wrap(MessageUtil.jsonNodeToBinary(%s, \\\"%s\\\")))\",\n                    target.sourceVariable(), target.humanReadableName())));\n\nSo I believe the concern is that I had proposed to change the serialization to an IntNode, but the deserialization still expects a BinaryNode which I should have also changed.\nAnother alternative I could fix this by changing the deserialization to expect an IntNode, but I'm for adding a verbose flag", "author": "anatasiavela", "createdAt": "2020-11-04T22:21:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0Mjk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY5OTc4Mw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517699783", "bodyText": "Nvm, we can't deserialize recordSet to an IntNode because FetchResponseData expects recordSet to be of type BaseRecords, not int.\nWhat I've done was left deserialization the same and added the verbose tag to serialization.", "author": "anatasiavela", "createdAt": "2020-11-04T23:52:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0Mjk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4NzEzOQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518187139", "bodyText": "@lbradstreet No, it does not break anything but it is inconsistent. If we put our case aside, the purpose of the JSON converters is to convert to/from JSON so it is fair to expect that we have to maintain this contract by default. Changing it to return the size would break this contract.\nRegarding _node.set(\"recordSet\", new BinaryNode(new byte[]{}));, I do believe that this is a bug actually...\n\nThat said, implementing a verbose mode (3) where we print out a byte array seems reasonable if we don't use it in the trace logging path by default?\n\nAgreed. When logging requests/responses, we should stick to the non-verbose mode.", "author": "dajac", "createdAt": "2020-11-05T16:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0Mjk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4NzY4MQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518187681", "bodyText": "Is this one still used? It seems that it is not the case.", "author": "dajac", "createdAt": "2020-11-05T16:31:07Z", "path": "clients/src/main/java/org/apache/kafka/common/requests/ProduceRequest.java", "diffHunk": "@@ -346,6 +346,10 @@ public ProduceResponse getErrorResponse(int throttleTimeMs, Throwable e) {\n         return partitionSizes.keySet();\n     }\n \n+    public Map<TopicPartition, Integer> partitionSizes() {\n+        return partitionSizes;\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4ODIwNw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518188207", "bodyText": "Could we add a unit test for this method?", "author": "dajac", "createdAt": "2020-11-05T16:31:51Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version, verbose)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version, verbose)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version, verbose)\n+      case req: ProduceRequest => produceRequestNode(req, request.version, verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short, verbose: Boolean): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version, verbose)\n+      case res: ProduceResponse => produceResponseNode(res, version, verbose)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version, verbose)\n+      case _ => throw new IllegalStateException(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader, verbose: Boolean): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion(), verbose).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName()))\n+    node.set(\"softwareVersion\", new TextNode(clientInfo.softwareVersion()))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM1OTE4OA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518359188", "bodyText": "I'm not too sure what this should test, since we don't have an expected output for this besides all fields being filled. What do you think we should test?", "author": "anatasiavela", "createdAt": "2020-11-05T20:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4ODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NDQyMQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518384421", "bodyText": "Yeah, I was thinking about a basic test like this which verifies the fields. We had few typos so it is good to test this.", "author": "dajac", "createdAt": "2020-11-05T21:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4ODIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5MzQ2Ng==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518193466", "bodyText": "IllegalStateException?", "author": "dajac", "createdAt": "2020-11-05T16:39:10Z", "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,141 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{CompressionType, MemoryRecords, RecordBatch, TimestampType}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]()).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : AssertionError => unhandledKeys += key.toString", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5MzU1NA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518193554", "bodyText": "IllegalStateException?", "author": "dajac", "createdAt": "2020-11-05T16:39:18Z", "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,141 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{CompressionType, MemoryRecords, RecordBatch, TimestampType}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]()).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : AssertionError => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled request keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testAllResponseTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      val struct = ApiMessageType.fromApiKey(key.id).newResponse().toStruct(version)\n+      val res = AbstractResponse.parseResponse(key, struct, version)\n+      try {\n+        RequestConvertToJson.response(res, version, false)\n+      } catch {\n+        case _ : AssertionError => unhandledKeys += key.toString", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5NjIyMA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518196220", "bodyText": "I think that we can safely assume that when a request/response is serialized with verbose equals to false, we are not going to deserialize it. Therefore, I suggest to drop the handling of verbose on the read path.", "author": "dajac", "createdAt": "2020-11-05T16:42:54Z", "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -227,9 +227,13 @@ private void generateVariableLengthTargetFromJson(Target target, Versions curVer\n             headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);\n             headerGenerator.addImport(MessageGenerator.BYTE_BUFFER_CLASS);\n             headerGenerator.addImport(MessageGenerator.MEMORY_RECORDS_CLASS);\n+            buffer.printf(\"if (_verbose) {%n\");\n+            buffer.incrementIndent();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5NzYzMw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518197633", "bodyText": "I wonder if we could find a better name than verbose. Perhaps, we could be more explicit and use something like serializeRecords as we actually only use it for this at the moment. What do you think?", "author": "dajac", "createdAt": "2020-11-05T16:44:50Z", "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -380,8 +384,18 @@ private void generateVariableLengthTargetToJson(Target target, Versions versions\n                         target.sourceVariable(), target.sourceVariable())));\n             }\n         } else if (target.field().type().isRecords()) {\n+            headerGenerator.addImport(MessageGenerator.INT_NODE_CLASS);\n             headerGenerator.addImport(MessageGenerator.BINARY_NODE_CLASS);\n+            buffer.printf(\"if (_verbose) {%n\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwNTM2Nw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518205367", "bodyText": "Could we also add a comment here which explains why we are doing this? We can also add the KIP number.", "author": "dajac", "createdAt": "2020-11-05T16:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5NzYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5ODg2OQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518198869", "bodyText": "Instead of changing the usage of this method everywhere in the code base, how about generating an overloaded method which call this one with verbose=true? I only expect this one to be used by the request logger at the moment so it is also more convenient.", "author": "dajac", "createdAt": "2020-11-05T16:46:29Z", "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -261,7 +265,7 @@ private void generateWrite(String className,\n                                StructSpec struct,\n                                Versions parentVersions) {\n         headerGenerator.addImport(MessageGenerator.JSON_NODE_CLASS);\n-        buffer.printf(\"public static JsonNode write(%s _object, short _version) {%n\",\n+        buffer.printf(\"public static JsonNode write(%s _object, short _version, boolean _verbose) {%n\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwMjY3OQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518202679", "bodyText": "I think that we should set this to false.", "author": "dajac", "createdAt": "2020-11-05T16:51:51Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -3354,7 +3354,7 @@ class KafkaApis(val requestChannel: RequestChannel,\n       case Some(response) =>\n         val responseSend = request.context.buildResponse(response)\n         val responseString =\n-          if (RequestChannel.isRequestLoggingEnabled) Some(response.toString(request.context.apiVersion))\n+          if (RequestChannel.isRequestLoggingEnabled) Some(RequestConvertToJson.response(response, request.context.apiVersion, true))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwNDEyMg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518204122", "bodyText": "verbose should be false here (if we keep it).", "author": "dajac", "createdAt": "2020-11-05T16:53:49Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -131,7 +131,7 @@ class KafkaApis(val requestChannel: RequestChannel,\n    */\n   override def handle(request: RequestChannel.Request): Unit = {\n     try {\n-      trace(s\"Handling request:${request.requestDesc(true)} from connection ${request.context.connectionId};\" +\n+      trace(s\"Handling request:${RequestConvertToJson.requestDesc(request.header, request.loggableRequest, true).toString} from connection ${request.context.connectionId};\" +", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwNDM5NA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518204394", "bodyText": "verbose should be false here (if we keep it).", "author": "dajac", "createdAt": "2020-11-05T16:54:11Z", "path": "core/src/main/scala/kafka/tools/TestRaftRequestHandler.scala", "diffHunk": "@@ -39,7 +40,7 @@ class TestRaftRequestHandler(\n \n   override def handle(request: RequestChannel.Request): Unit = {\n     try {\n-      trace(s\"Handling request:${request.requestDesc(true)} from connection ${request.context.connectionId};\" +\n+      trace(s\"Handling request:${RequestConvertToJson.requestDesc(request.header, request.loggableRequest, true)} from connection ${request.context.connectionId};\" +", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MDg0Mw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520340843", "bodyText": "It seems that we can revert this back as we have the overloaded method now.", "author": "dajac", "createdAt": "2020-11-10T07:21:06Z", "path": "clients/src/test/java/org/apache/kafka/common/message/SimpleExampleMessageTest.java", "diffHunk": "@@ -394,7 +394,7 @@ private void testRoundTrip(SimpleExampleMessageData message,\n         assertEquals(message.hashCode(), messageFromStruct.hashCode());\n \n         // Check JSON serialization\n-        JsonNode serializedJson = SimpleExampleMessageDataJsonConverter.write(message, version);\n+        JsonNode serializedJson = SimpleExampleMessageDataJsonConverter.write(message, version, true);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MjExNA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520342114", "bodyText": "It seems that we can remove verbose as we don't really use it anymore. Instead, we could set it to false for the produce request below.", "author": "dajac", "createdAt": "2020-11-10T07:24:19Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MjM3MQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520342371", "bodyText": "Same here. We can remove verbose and set it to false for the fetch response.", "author": "dajac", "createdAt": "2020-11-10T07:24:53Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version, verbose)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version, verbose)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version, verbose)\n+      case req: ProduceRequest => produceRequestNode(req, request.version, verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short, verbose: Boolean): JsonNode = {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0ODQ3MQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520348471", "bodyText": "I suppose that we need to keep checking if (RequestChannel.isRequestLoggingEnabled) here.", "author": "dajac", "createdAt": "2020-11-10T07:39:03Z", "path": "core/src/main/scala/kafka/tools/TestRaftRequestHandler.scala", "diffHunk": "@@ -93,10 +94,8 @@ class TestRaftRequestHandler(\n     val response = responseOpt match {\n       case Some(response) =>\n         val responseSend = request.context.buildResponse(response)\n-        val responseString =\n-          if (RequestChannel.isRequestLoggingEnabled) Some(response.toString(request.context.apiVersion))\n-          else None\n-        new RequestChannel.SendResponse(request, responseSend, responseString, None)\n+        val headerLog = RequestConvertToJson.requestHeaderNode(request.header)\n+        new RequestChannel.SendResponse(request, responseSend, Some(headerLog), None)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0OTQyMQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520349421", "bodyText": "nit: Could we add a new line after @Test?", "author": "dajac", "createdAt": "2020-11-10T07:40:55Z", "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.net.InetAddress\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.ObjectNode\n+import kafka.network\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.memory.MemoryPool\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName, NetworkSend}\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{MemoryRecords, RecordBatch}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.easymock.EasyMock.createNiceMock\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled request keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testAllResponseTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      val struct = ApiMessageType.fromApiKey(key.id).newResponse().toStruct(version)\n+      val res = AbstractResponse.parseResponse(key, struct, version)\n+      try {\n+        RequestConvertToJson.response(res, version, false)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled response keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochRequestNode(): Unit = {\n+    val partitionDataMap = new util.HashMap[TopicPartition, PartitionData]\n+    partitionDataMap.put(new TopicPartition(\"topic1\", 0), new PartitionData(Optional.of(0),  1))\n+\n+    val version: Short = ApiKeys.OFFSET_FOR_LEADER_EPOCH.latestVersion\n+    val request = OffsetsForLeaderEpochRequest.Builder.forConsumer(partitionDataMap).build(version)\n+    val actualNode = RequestConvertToJson.request(request, true)\n+\n+    val requestData = OffsetForLeaderEpochRequestDataJsonConverter.read(actualNode, version)\n+    val expectedNode = OffsetForLeaderEpochRequestDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfProduceRequestNode(): Unit = {\n+    val produceDataMap = new util.HashMap[TopicPartition, MemoryRecords]\n+\n+    val version: Short = ApiKeys.PRODUCE.latestVersion\n+    val serializeRecords: Boolean = false;\n+    val request = ProduceRequest.Builder.forMagic(2, 0.toShort, 0, produceDataMap, \"\").build()\n+    val actualNode = RequestConvertToJson.request(request, serializeRecords)\n+\n+    val requestData = new ProduceRequestData()\n+    val expectedNode = ProduceRequestDataJsonConverter.write(requestData, version, serializeRecords)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochResponseNode(): Unit = {\n+    val endOffsetMap = new util.HashMap[TopicPartition, EpochEndOffset]\n+    endOffsetMap.put(new TopicPartition(\"topic1\", 0), new EpochEndOffset(1, 10L))\n+\n+    val version: Short = ApiKeys.OFFSET_FOR_LEADER_EPOCH.latestVersion\n+    val response = new OffsetsForLeaderEpochResponse(endOffsetMap)\n+    val actualNode = RequestConvertToJson.response(response, version, true)\n+\n+    val requestData = OffsetForLeaderEpochResponseDataJsonConverter.read(actualNode, version)\n+    val expectedNode = OffsetForLeaderEpochResponseDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfProduceResponseNode(): Unit = {\n+    val responseData = new util.HashMap[TopicPartition, ProduceResponse.PartitionResponse]\n+    val partResponse = new ProduceResponse.PartitionResponse(Errors.NONE, 10000, RecordBatch.NO_TIMESTAMP, 100, Collections.singletonList(new ProduceResponse.RecordError(3, \"Record error\")), \"Produce failed\")\n+    responseData.put(new TopicPartition(\"topic1\", 0), partResponse)\n+\n+    val version: Short = ApiKeys.PRODUCE.latestVersion\n+    val response = new ProduceResponse(responseData)\n+    val actualNode = RequestConvertToJson.response(response, version, true)\n+\n+    val requestData = ProduceResponseDataJsonConverter.read(actualNode, version)\n+    val expectedNode = ProduceResponseDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test def testFieldsRequestDescMetrics(): Unit = {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1MTkwMQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520351901", "bodyText": "Thinking a bit more about this. I think that it may be worth validating the values as well to ensure that the input maps to the output. If we use different values for each field, we could verify that the output JSON object is correct. JSONNode are comparable so we could construct the expected output and use it in assertEquals. What do you think?", "author": "dajac", "createdAt": "2020-11-10T07:46:24Z", "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.net.InetAddress\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.ObjectNode\n+import kafka.network\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.memory.MemoryPool\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName, NetworkSend}\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{MemoryRecords, RecordBatch}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.easymock.EasyMock.createNiceMock\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled request keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testAllResponseTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      val struct = ApiMessageType.fromApiKey(key.id).newResponse().toStruct(version)\n+      val res = AbstractResponse.parseResponse(key, struct, version)\n+      try {\n+        RequestConvertToJson.response(res, version, false)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled response keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochRequestNode(): Unit = {\n+    val partitionDataMap = new util.HashMap[TopicPartition, PartitionData]\n+    partitionDataMap.put(new TopicPartition(\"topic1\", 0), new PartitionData(Optional.of(0),  1))\n+\n+    val version: Short = ApiKeys.OFFSET_FOR_LEADER_EPOCH.latestVersion\n+    val request = OffsetsForLeaderEpochRequest.Builder.forConsumer(partitionDataMap).build(version)\n+    val actualNode = RequestConvertToJson.request(request, true)\n+\n+    val requestData = OffsetForLeaderEpochRequestDataJsonConverter.read(actualNode, version)\n+    val expectedNode = OffsetForLeaderEpochRequestDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfProduceRequestNode(): Unit = {\n+    val produceDataMap = new util.HashMap[TopicPartition, MemoryRecords]\n+\n+    val version: Short = ApiKeys.PRODUCE.latestVersion\n+    val serializeRecords: Boolean = false;\n+    val request = ProduceRequest.Builder.forMagic(2, 0.toShort, 0, produceDataMap, \"\").build()\n+    val actualNode = RequestConvertToJson.request(request, serializeRecords)\n+\n+    val requestData = new ProduceRequestData()\n+    val expectedNode = ProduceRequestDataJsonConverter.write(requestData, version, serializeRecords)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochResponseNode(): Unit = {\n+    val endOffsetMap = new util.HashMap[TopicPartition, EpochEndOffset]\n+    endOffsetMap.put(new TopicPartition(\"topic1\", 0), new EpochEndOffset(1, 10L))\n+\n+    val version: Short = ApiKeys.OFFSET_FOR_LEADER_EPOCH.latestVersion\n+    val response = new OffsetsForLeaderEpochResponse(endOffsetMap)\n+    val actualNode = RequestConvertToJson.response(response, version, true)\n+\n+    val requestData = OffsetForLeaderEpochResponseDataJsonConverter.read(actualNode, version)\n+    val expectedNode = OffsetForLeaderEpochResponseDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfProduceResponseNode(): Unit = {\n+    val responseData = new util.HashMap[TopicPartition, ProduceResponse.PartitionResponse]\n+    val partResponse = new ProduceResponse.PartitionResponse(Errors.NONE, 10000, RecordBatch.NO_TIMESTAMP, 100, Collections.singletonList(new ProduceResponse.RecordError(3, \"Record error\")), \"Produce failed\")\n+    responseData.put(new TopicPartition(\"topic1\", 0), partResponse)\n+\n+    val version: Short = ApiKeys.PRODUCE.latestVersion\n+    val response = new ProduceResponse(responseData)\n+    val actualNode = RequestConvertToJson.response(response, version, true)\n+\n+    val requestData = ProduceResponseDataJsonConverter.read(actualNode, version)\n+    val expectedNode = ProduceResponseDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test def testFieldsRequestDescMetrics(): Unit = {\n+    val expectedFields = Set(\"requestHeader\", \"request\", \"response\", \"connection\",\n+      \"totalTimeMs\", \"requestQueueTimeMs\", \"localTimeMs\", \"remoteTimeMs\", \"throttleTimeMs\",\n+      \"responseQueueTimeMs\", \"sendTimeMs\", \"securityProtocol\", \"principal\", \"listener\",\n+      \"clientInformation\", \"softwareName\", \"softwareVersion\", \"temporaryMemoryBytes\", \"messageConversionsTime\")\n+\n+    val req = request(new AlterIsrRequest(new AlterIsrRequestData(), 0))\n+    val byteBuffer = req.body[AbstractRequest].serialize(req.header)\n+    val send = new NetworkSend(req.context.connectionId, byteBuffer)\n+    val headerLog = RequestConvertToJson.requestHeaderNode(req.header)\n+    val res = new RequestChannel.SendResponse(req, send, Some(headerLog), None)\n+\n+    val node = RequestConvertToJson.requestDescMetrics(req.header, res, req.loggableRequest, req.context, req.session,\n+      1, 1, 1, 1, 1, 1, 1, 1, 1).asInstanceOf[ObjectNode]\n+    val foundFields = getFieldNames(node)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ3Mjg2OA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r522472868", "bodyText": "I've modified the test to validate the values, but I'm not sure the worth in doing this especially when constructing the expected output is just copying the code for the node construction into the test, unless you were thinking of another way of constructing the node. Plus it's kind of a hassle when we try to modify requestDescMetric because it would need to be changed in 2 places: the code and the test.", "author": "anatasiavela", "createdAt": "2020-11-12T22:29:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1MTkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1NjEwNQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520356105", "bodyText": "nit: Could we make it private?", "author": "dajac", "createdAt": "2020-11-10T07:55:03Z", "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.net.InetAddress\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.ObjectNode\n+import kafka.network\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.memory.MemoryPool\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName, NetworkSend}\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{MemoryRecords, RecordBatch}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.easymock.EasyMock.createNiceMock\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled request keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testAllResponseTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      val struct = ApiMessageType.fromApiKey(key.id).newResponse().toStruct(version)\n+      val res = AbstractResponse.parseResponse(key, struct, version)\n+      try {\n+        RequestConvertToJson.response(res, version, false)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled response keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochRequestNode(): Unit = {\n+    val partitionDataMap = new util.HashMap[TopicPartition, PartitionData]\n+    partitionDataMap.put(new TopicPartition(\"topic1\", 0), new PartitionData(Optional.of(0),  1))\n+\n+    val version: Short = ApiKeys.OFFSET_FOR_LEADER_EPOCH.latestVersion\n+    val request = OffsetsForLeaderEpochRequest.Builder.forConsumer(partitionDataMap).build(version)\n+    val actualNode = RequestConvertToJson.request(request, true)\n+\n+    val requestData = OffsetForLeaderEpochRequestDataJsonConverter.read(actualNode, version)\n+    val expectedNode = OffsetForLeaderEpochRequestDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfProduceRequestNode(): Unit = {\n+    val produceDataMap = new util.HashMap[TopicPartition, MemoryRecords]\n+\n+    val version: Short = ApiKeys.PRODUCE.latestVersion\n+    val serializeRecords: Boolean = false;\n+    val request = ProduceRequest.Builder.forMagic(2, 0.toShort, 0, produceDataMap, \"\").build()\n+    val actualNode = RequestConvertToJson.request(request, serializeRecords)\n+\n+    val requestData = new ProduceRequestData()\n+    val expectedNode = ProduceRequestDataJsonConverter.write(requestData, version, serializeRecords)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochResponseNode(): Unit = {\n+    val endOffsetMap = new util.HashMap[TopicPartition, EpochEndOffset]\n+    endOffsetMap.put(new TopicPartition(\"topic1\", 0), new EpochEndOffset(1, 10L))\n+\n+    val version: Short = ApiKeys.OFFSET_FOR_LEADER_EPOCH.latestVersion\n+    val response = new OffsetsForLeaderEpochResponse(endOffsetMap)\n+    val actualNode = RequestConvertToJson.response(response, version, true)\n+\n+    val requestData = OffsetForLeaderEpochResponseDataJsonConverter.read(actualNode, version)\n+    val expectedNode = OffsetForLeaderEpochResponseDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfProduceResponseNode(): Unit = {\n+    val responseData = new util.HashMap[TopicPartition, ProduceResponse.PartitionResponse]\n+    val partResponse = new ProduceResponse.PartitionResponse(Errors.NONE, 10000, RecordBatch.NO_TIMESTAMP, 100, Collections.singletonList(new ProduceResponse.RecordError(3, \"Record error\")), \"Produce failed\")\n+    responseData.put(new TopicPartition(\"topic1\", 0), partResponse)\n+\n+    val version: Short = ApiKeys.PRODUCE.latestVersion\n+    val response = new ProduceResponse(responseData)\n+    val actualNode = RequestConvertToJson.response(response, version, true)\n+\n+    val requestData = ProduceResponseDataJsonConverter.read(actualNode, version)\n+    val expectedNode = ProduceResponseDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test def testFieldsRequestDescMetrics(): Unit = {\n+    val expectedFields = Set(\"requestHeader\", \"request\", \"response\", \"connection\",\n+      \"totalTimeMs\", \"requestQueueTimeMs\", \"localTimeMs\", \"remoteTimeMs\", \"throttleTimeMs\",\n+      \"responseQueueTimeMs\", \"sendTimeMs\", \"securityProtocol\", \"principal\", \"listener\",\n+      \"clientInformation\", \"softwareName\", \"softwareVersion\", \"temporaryMemoryBytes\", \"messageConversionsTime\")\n+\n+    val req = request(new AlterIsrRequest(new AlterIsrRequestData(), 0))\n+    val byteBuffer = req.body[AbstractRequest].serialize(req.header)\n+    val send = new NetworkSend(req.context.connectionId, byteBuffer)\n+    val headerLog = RequestConvertToJson.requestHeaderNode(req.header)\n+    val res = new RequestChannel.SendResponse(req, send, Some(headerLog), None)\n+\n+    val node = RequestConvertToJson.requestDescMetrics(req.header, res, req.loggableRequest, req.context, req.session,\n+      1, 1, 1, 1, 1, 1, 1, 1, 1).asInstanceOf[ObjectNode]\n+    val foundFields = getFieldNames(node)\n+\n+    assertEquals(expectedFields, foundFields)\n+  }\n+\n+  def request(req: AbstractRequest): RequestChannel.Request = {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1ODIxMw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520358213", "bodyText": "I am not sure to understand why we are doing this change now. It was not there before. Could you elaborate?\nIs it because the produce request does use bytes as type? It seems bytes was used there by mistake. FYI, the PR which will migrate the produce request to the automated protocol will change it to records: https://github.com/apache/kafka/pull/9401/files#diff-e6dde0832c4873b546db2ad0d37be899855a436972b0a2c5008b100a0ffff64dR50.", "author": "dajac", "createdAt": "2020-11-10T07:59:13Z", "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -375,13 +385,36 @@ private void generateVariableLengthTargetToJson(Target target, Versions versions\n                         target.sourceVariable())));\n             } else {\n                 headerGenerator.addImport(MessageGenerator.ARRAYS_CLASS);\n+                headerGenerator.addImport(MessageGenerator.INT_NODE_CLASS);\n+                buffer.printf(\"if (_serializeRecords) {%n\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgwNzkyMQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520807921", "bodyText": "Yea, this change is because ProduceRequest uses bytes type. It would be worthwhile if we waited until we migrated the produce request to the automated protocol so we wouldn't have to change this.", "author": "anatasiavela", "createdAt": "2020-11-10T19:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1ODIxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI3MzkxMA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r521273910", "bodyText": "Understood. I think that we should revert this. I think that it makes sense to wait until we complete the migration of the remaining requests. We should have them pretty soon now.", "author": "dajac", "createdAt": "2020-11-11T10:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1ODIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM2MDU4MA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520360580", "bodyText": "nit: We would usually use a val here and write the block as follow:\nval req = if (key == ApiKeys.PRODUCE) {\n  ...\n} else {\n  ...\n}", "author": "dajac", "createdAt": "2020-11-10T08:03:43Z", "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.net.InetAddress\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.ObjectNode\n+import kafka.network\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.memory.MemoryPool\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName, NetworkSend}\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{MemoryRecords, RecordBatch}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.easymock.EasyMock.createNiceMock\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM2MzMwMg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520363302", "bodyText": "nit: We tend to write this as follow:\nApiKeys.values().foreach { key => \n  ...\n}\n\nThis is another similar case in testAllResponseTypesHandled.", "author": "dajac", "createdAt": "2020-11-10T08:08:56Z", "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.net.InetAddress\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.ObjectNode\n+import kafka.network\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.memory.MemoryPool\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName, NetworkSend}\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{MemoryRecords, RecordBatch}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.easymock.EasyMock.createNiceMock\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1NTQ1MA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r526255450", "bodyText": "Seeing as #9401 is about to merge, maybe we can wait for that before merging this and drop our manual JSON generation code for produce request/response?", "author": "lbradstreet", "createdAt": "2020-11-18T17:05:40Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version)\n+      case req: ProduceRequest => produceRequestNode(req, request.version, false)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version, false)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new IllegalStateException(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion(), false).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName()))\n+    node.set(\"softwareVersion\", new TextNode(clientInfo.softwareVersion()))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                         context: RequestContext, session: Session,\n+                         totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                         apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                         responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                         messageConversionsTimeMs: Double): JsonNode = {\n+    val node = requestDesc(header, req).asInstanceOf[ObjectNode]\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTimeMs\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTimeMs\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTimeMs\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTimeMs\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTimeMs\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTimeMs\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTimeMs\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", clientInfoNode(context.clientInformation))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData) =>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicNode.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicNode)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceRequestNode(request: ProduceRequest, version: Short, serializeRecords: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      if (request.transactionalId == null) {\n+        node.set(\"transactionalId\", NullNode.instance)\n+      } else {\n+        node.set(\"transactionalId\", new TextNode(request.transactionalId))\n+      }\n+    }\n+    node.set(\"acks\", new ShortNode(request.acks))\n+    node.set(\"timeoutMs\", new IntNode(request.timeout))\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.partitionRecordsOrFail())\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData) =>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (partitionData == null) {\n+          partitionNode.set(\"records\", NullNode.instance)\n+        } else {\n+          if (serializeRecords)\n+            partitionNode.set(\"records\", new BinaryNode(util.Arrays.copyOf(partitionData.buffer().array(), partitionData.validBytes())))\n+          else\n+            partitionNode.set(\"records\", new IntNode(partitionData.validBytes()))\n+        }\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicNode.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicNode)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochResponseNode(response: OffsetsForLeaderEpochResponse, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 2) {\n+      node.set(\"throttleTimeMs\", new IntNode(response.throttleTimeMs))\n+    }\n+    val topics = CollectionUtils.groupPartitionDataByTopic(response.responses)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData) =>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"errorCode\", new ShortNode(partitionData.error.code))\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (version >= 1) partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        partitionNode.set(\"endOffset\", new LongNode(partitionData.endOffset))\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicNode.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicNode)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceResponseNode(response: ProduceResponse, version: Short): JsonNode = {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1ODM4MQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r526258381", "bodyText": "We are actually waiting on that one and this one #9547.", "author": "dajac", "createdAt": "2020-11-18T17:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1NTQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI2NTQ2Ng==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r526265466", "bodyText": "Great", "author": "lbradstreet", "createdAt": "2020-11-18T17:19:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1NTQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxMTA2Nw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r526511067", "bodyText": "Yes! we're waiting on #9401 and #9547 to merge. Once they're merged, I'll pick this PR back up and will remove all the temporary case handling done for the Produce and OffsetsForLeaderEpoch request/response.", "author": "anatasiavela", "createdAt": "2020-11-19T00:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1NTQ1MA=="}], "type": "inlineReview"}, {"oid": "db4cbab3af02e58acf19fe446074857e4eaf44e4", "url": "https://github.com/apache/kafka/commit/db4cbab3af02e58acf19fe446074857e4eaf44e4", "message": "integrate with rebase", "committedDate": "2020-11-20T05:45:12Z", "type": "forcePushed"}, {"oid": "d8a26b6fbaead74096fde0ea41ebe2d337c01bc7", "url": "https://github.com/apache/kafka/commit/d8a26b6fbaead74096fde0ea41ebe2d337c01bc7", "message": "KAFKA-10525: Emit JSONs with new auto-generated schema\n\nKafka\u2019s request and response traces currently output in a format that is JSON-like and are not easily parsable.\n\nThere is a new auto-generated schema for each request type that supports outputting JSON payloads for request and response payloads. These can be adapted to provide structured request tracing.", "committedDate": "2020-12-11T02:53:13Z", "type": "commit"}, {"oid": "c3e1e1f1aa7412b602917b7a8ed00dbb9f8f0cea", "url": "https://github.com/apache/kafka/commit/c3e1e1f1aa7412b602917b7a8ed00dbb9f8f0cea", "message": "add extra lines", "committedDate": "2020-12-11T02:54:08Z", "type": "commit"}, {"oid": "0c7203b6296c0c18b5127726114657c6a3d967ac", "url": "https://github.com/apache/kafka/commit/0c7203b6296c0c18b5127726114657c6a3d967ac", "message": "remove extra spaces", "committedDate": "2020-12-11T02:54:08Z", "type": "commit"}, {"oid": "38747a5782951f6740a1e1cebf007c73a6884b7d", "url": "https://github.com/apache/kafka/commit/38747a5782951f6740a1e1cebf007c73a6884b7d", "message": "add data accessor and creat tests for manually created data", "committedDate": "2020-12-11T02:59:26Z", "type": "commit"}, {"oid": "29392c482c0c0b26b96fa023fec0cd507dcc0bb5", "url": "https://github.com/apache/kafka/commit/29392c482c0c0b26b96fa023fec0cd507dcc0bb5", "message": "access data from accessor", "committedDate": "2020-12-11T02:59:30Z", "type": "commit"}, {"oid": "fb0633cabbd0737ef685726560f05cb7a8711ef7", "url": "https://github.com/apache/kafka/commit/fb0633cabbd0737ef685726560f05cb7a8711ef7", "message": "remove DESCRIBE_QUORUM case and add better error msg", "committedDate": "2020-12-11T02:59:31Z", "type": "commit"}, {"oid": "32f1e9db525d50728f3e36d8c59aaec7d718f90c", "url": "https://github.com/apache/kafka/commit/32f1e9db525d50728f3e36d8c59aaec7d718f90c", "message": "change error messages and asserts", "committedDate": "2020-12-11T02:59:31Z", "type": "commit"}, {"oid": "ab50c8fe258959cd8366ca6dbf56994046ab6f76", "url": "https://github.com/apache/kafka/commit/ab50c8fe258959cd8366ca6dbf56994046ab6f76", "message": "swap expected and actual, change error msg, add accessor to private data field", "committedDate": "2020-12-11T02:59:54Z", "type": "commit"}, {"oid": "97237afbd72335b7617a500afebe5b894aa5bdbc", "url": "https://github.com/apache/kafka/commit/97237afbd72335b7617a500afebe5b894aa5bdbc", "message": "change to data accessor method", "committedDate": "2020-12-11T02:59:57Z", "type": "commit"}, {"oid": "32578e449bb3808f9d19ac8dd7a38e1d91e2fdba", "url": "https://github.com/apache/kafka/commit/32578e449bb3808f9d19ac8dd7a38e1d91e2fdba", "message": "change recordSet field to print sizeInBytes", "committedDate": "2020-12-11T02:59:57Z", "type": "commit"}, {"oid": "ab73c10d4246341a67af90f7bcdd6ab5500da5d5", "url": "https://github.com/apache/kafka/commit/ab73c10d4246341a67af90f7bcdd6ab5500da5d5", "message": "trigger build", "committedDate": "2020-12-11T02:59:57Z", "type": "commit"}, {"oid": "d3b548799abe15655ee1fdafdab5712bc1ea6444", "url": "https://github.com/apache/kafka/commit/d3b548799abe15655ee1fdafdab5712bc1ea6444", "message": "add verbose flag to records in JsonConverter", "committedDate": "2020-12-11T03:01:50Z", "type": "commit"}, {"oid": "bd9a82bd642090a7efbf64ac429a43fa9a040264", "url": "https://github.com/apache/kafka/commit/bd9a82bd642090a7efbf64ac429a43fa9a040264", "message": "add overload method for verbose flag", "committedDate": "2020-12-11T03:03:03Z", "type": "commit"}, {"oid": "0fa879aed005435b8f56534322123f639598296a", "url": "https://github.com/apache/kafka/commit/0fa879aed005435b8f56534322123f639598296a", "message": "add parentheses", "committedDate": "2020-12-11T03:03:07Z", "type": "commit"}, {"oid": "4dd1524301a9dda7dec710d59c9eae204df36a8c", "url": "https://github.com/apache/kafka/commit/4dd1524301a9dda7dec710d59c9eae204df36a8c", "message": "remove verbose tag in unnecessary places", "committedDate": "2020-12-11T03:03:08Z", "type": "commit"}, {"oid": "b102b67fd5c44cd2b01e2e11000176d87b786d8d", "url": "https://github.com/apache/kafka/commit/b102b67fd5c44cd2b01e2e11000176d87b786d8d", "message": "integrate with rebase", "committedDate": "2020-12-11T03:03:09Z", "type": "commit"}, {"oid": "3e439d5d81c9cbede152775385c046b6208a1c04", "url": "https://github.com/apache/kafka/commit/3e439d5d81c9cbede152775385c046b6208a1c04", "message": "handle null ProduceRequest", "committedDate": "2020-12-11T03:03:10Z", "type": "commit"}, {"oid": "4bca18e9b36a8597078f45b4b8eda15e645fecfd", "url": "https://github.com/apache/kafka/commit/4bca18e9b36a8597078f45b4b8eda15e645fecfd", "message": "add specific case for ProduceRequest", "committedDate": "2020-12-11T03:03:10Z", "type": "commit"}, {"oid": "9cc67279ff1b8ea4d0fe014dbaf4787a662b5155", "url": "https://github.com/apache/kafka/commit/9cc67279ff1b8ea4d0fe014dbaf4787a662b5155", "message": "make produce request consistent", "committedDate": "2020-12-11T03:03:11Z", "type": "commit"}, {"oid": "5f91474f006841d679bbe63d64fcdf3cc93282bc", "url": "https://github.com/apache/kafka/commit/5f91474f006841d679bbe63d64fcdf3cc93282bc", "message": "remove special handling for ProduceRequest", "committedDate": "2020-12-11T03:03:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5ODQxMw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540798413", "bodyText": "We must use a val to store the requestLog in order to guarantee that the JSON representation is computed before the request is processed by the api layer. Otherwise, we still have a ProduceRequest without the data. The val may be private as well and I would put it right below bodyAndSize with a comment which explains why we do this.", "author": "dajac", "createdAt": "2020-12-11T09:13:07Z", "path": "core/src/main/scala/kafka/network/RequestChannel.scala", "diffHunk": "@@ -121,9 +122,16 @@ object RequestChannel extends Logging {\n       }\n     }\n \n-    def responseString(response: AbstractResponse): Option[String] = {\n+    def requestLog: Option[JsonNode] = {", "originalCommit": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5OTgxNA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540799814", "bodyText": "It seems that this one is used from KafkaApis and others. It may be better to keep the original implementation for these cases.", "author": "dajac", "createdAt": "2020-12-11T09:15:32Z", "path": "core/src/main/scala/kafka/network/RequestChannel.scala", "diffHunk": "@@ -137,11 +145,8 @@ object RequestChannel extends Logging {\n       }\n     }\n \n-    def requestDesc(details: Boolean): String = {\n-      val forwardDescription = envelope.map { request =>\n-        s\"Forwarded request: ${request.context} \"\n-      }.getOrElse(\"\")\n-      s\"$forwardDescription$header -- ${loggableRequest.toString(details)}\"\n+    def requestDesc: JsonNode = {", "originalCommit": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgwMTI4MQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540801281", "bodyText": "Shouldn't we pass false here in order to not serialize the records?", "author": "dajac", "createdAt": "2020-12-11T09:17:33Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{BooleanNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, ObjectNode, TextNode}\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.requests._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EnvelopeRequest => EnvelopeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => OffsetForLeaderEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ProduceRequest => ProduceRequestDataJsonConverter.write(req.data, request.version)", "originalCommit": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgwMjk3MA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540802970", "bodyText": "It seems that we don't use this one any more.", "author": "dajac", "createdAt": "2020-12-11T09:20:13Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{BooleanNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, ObjectNode, TextNode}\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.requests._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EnvelopeRequest => EnvelopeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => OffsetForLeaderEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ProduceRequest => ProduceRequestDataJsonConverter.write(req.data, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: EnvelopeResponse => EnvelopeResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version, false)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => OffsetForLeaderEpochResponseDataJsonConverter.write(res.data(), version)\n+      case res: ProduceResponse => ProduceResponseDataJsonConverter.write(res.data(), version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new IllegalStateException(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data, header.headerVersion, false).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestContextNode(context: RequestContext): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", clientInfoNode(context.clientInformation))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, requestNode: Option[JsonNode], envelope: Option[RequestChannel.Request] = None): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"isForwarded\", if (envelope.isDefined) BooleanNode.TRUE else BooleanNode.FALSE)\n+    node.set(\"forwardedRequest\", envelope.map(request => requestContextNode(request.context)).getOrElse(new TextNode(\"\")))\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", requestNode.getOrElse(new TextNode(\"\")))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName))\n+    node.set(\"softwareVersion\", new TextNode(clientInfo.softwareVersion))\n+    node\n+  }\n+\n+  def topicPartitionNode(topicPartition: TopicPartition): JsonNode = {", "originalCommit": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgwNDY3OA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540804678", "bodyText": "I am not sure that this is necessary. Knowing that the request is forwarded is enough, I suppose.", "author": "dajac", "createdAt": "2020-12-11T09:22:47Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{BooleanNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, ObjectNode, TextNode}\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.requests._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EnvelopeRequest => EnvelopeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => OffsetForLeaderEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ProduceRequest => ProduceRequestDataJsonConverter.write(req.data, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: EnvelopeResponse => EnvelopeResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version, false)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => OffsetForLeaderEpochResponseDataJsonConverter.write(res.data(), version)\n+      case res: ProduceResponse => ProduceResponseDataJsonConverter.write(res.data(), version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new IllegalStateException(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data, header.headerVersion, false).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestContextNode(context: RequestContext): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", clientInfoNode(context.clientInformation))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, requestNode: Option[JsonNode], envelope: Option[RequestChannel.Request] = None): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"isForwarded\", if (envelope.isDefined) BooleanNode.TRUE else BooleanNode.FALSE)\n+    node.set(\"forwardedRequest\", envelope.map(request => requestContextNode(request.context)).getOrElse(new TextNode(\"\")))", "originalCommit": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgwNTQzMQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540805431", "bodyText": "We must pass either the envelope  or isForwarded here as well. This is the main request log and, as it is, it does not tell if the request is forwarded or not.", "author": "dajac", "createdAt": "2020-12-11T09:24:09Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{BooleanNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, ObjectNode, TextNode}\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.requests._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EnvelopeRequest => EnvelopeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => OffsetForLeaderEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ProduceRequest => ProduceRequestDataJsonConverter.write(req.data, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: EnvelopeResponse => EnvelopeResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version, false)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => OffsetForLeaderEpochResponseDataJsonConverter.write(res.data(), version)\n+      case res: ProduceResponse => ProduceResponseDataJsonConverter.write(res.data(), version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new IllegalStateException(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data, header.headerVersion, false).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestContextNode(context: RequestContext): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", clientInfoNode(context.clientInformation))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, requestNode: Option[JsonNode], envelope: Option[RequestChannel.Request] = None): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"isForwarded\", if (envelope.isDefined) BooleanNode.TRUE else BooleanNode.FALSE)\n+    node.set(\"forwardedRequest\", envelope.map(request => requestContextNode(request.context)).getOrElse(new TextNode(\"\")))\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", requestNode.getOrElse(new TextNode(\"\")))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName))\n+    node.set(\"softwareVersion\", new TextNode(clientInfo.softwareVersion))\n+    node\n+  }\n+\n+  def topicPartitionNode(topicPartition: TopicPartition): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"topic\", new TextNode(topicPartition.topic))\n+    node.set(\"partition\", new IntNode(topicPartition.partition))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, requestNode: Option[JsonNode], responseNode: Option[JsonNode],", "originalCommit": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgxOTE2Mw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540819163", "bodyText": "I wonder if we should name the field %sSizeInBytes. I just looked at the result and having \"records\":83 in the request log is not super clear to me.", "author": "dajac", "createdAt": "2020-12-11T09:45:15Z", "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -377,11 +387,24 @@ private void generateVariableLengthTargetToJson(Target target, Versions versions\n                 headerGenerator.addImport(MessageGenerator.ARRAYS_CLASS);\n                 buffer.printf(\"%s;%n\", target.assignmentStatement(\n                     String.format(\"new BinaryNode(Arrays.copyOf(%s, %s.length))\",\n-                        target.sourceVariable(), target.sourceVariable())));\n+                            target.sourceVariable(), target.sourceVariable())));\n             }\n         } else if (target.field().type().isRecords()) {\n             headerGenerator.addImport(MessageGenerator.BINARY_NODE_CLASS);\n+            headerGenerator.addImport(MessageGenerator.INT_NODE_CLASS);\n+            // KIP-673: When logging requests/responses, we do not serialize the record, instead we\n+            // output its sizeInBytes, because outputting the bytes is not very useful and can be\n+            // quite expensive. Otherwise, we will serialize the record.\n+            buffer.printf(\"if (_serializeRecords) {%n\");\n+            buffer.incrementIndent();\n             buffer.printf(\"%s;%n\", target.assignmentStatement(\"new BinaryNode(new byte[]{})\"));\n+            buffer.decrementIndent();\n+            buffer.printf(\"} else {%n\");\n+            buffer.incrementIndent();\n+            buffer.printf(\"%s;%n\", target.assignmentStatement(", "originalCommit": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI0MDU1OA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r541240558", "bodyText": "I do see the issue of it not being super clear, but I don't think we can change the field name from here. Doing %sSizeInBytes would just add the name at the end of the line which would result in a compilation error. Unless you mean to change the field name in the .json file, but it would change the name for both the serialize and non-serialize case.", "author": "anatasiavela", "createdAt": "2020-12-11T20:15:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgxOTE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwNTI0OQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542305249", "bodyText": "Would something like the following work?\nbuffer.printf(\"_node.set(\\\"%sSizeInBytes\\\", new IntNode(%s.sizeInBytes()));%n\",\n  target.field().camelCaseName(),\n  target.sourceVariable());", "author": "dajac", "createdAt": "2020-12-14T11:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgxOTE2Mw=="}], "type": "inlineReview"}, {"oid": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "url": "https://github.com/apache/kafka/commit/97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "message": "rebase and address comments", "committedDate": "2020-12-11T20:04:10Z", "type": "commit"}, {"oid": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "url": "https://github.com/apache/kafka/commit/97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "message": "rebase and address comments", "committedDate": "2020-12-11T20:04:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwNTkxMg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542305912", "bodyText": "This is likely a mistake.", "author": "dajac", "createdAt": "2020-12-14T11:17:14Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -97,7 +98,8 @@ import scala.annotation.nowarn\n /**\n  * Logic to handle the various Kafka requests\n  */\n-class KafkaApis(val requestChannel: RequestChannel,\n+class\n+KafkaApis(val requestChannel: RequestChannel,", "originalCommit": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwODMwOA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542308308", "bodyText": "nit: context.apiVersion() -> context.apiVersion", "author": "dajac", "createdAt": "2020-12-14T11:21:10Z", "path": "core/src/main/scala/kafka/network/RequestChannel.scala", "diffHunk": "@@ -123,9 +131,9 @@ object RequestChannel extends Logging {\n       }\n     }\n \n-    def responseString(response: AbstractResponse): Option[String] = {\n+    def responseNode(response: AbstractResponse): Option[JsonNode] = {\n       if (RequestChannel.isRequestLoggingEnabled)\n-        Some(response.toString)\n+        Some(RequestConvertToJson.response(response, context.apiVersion()))", "originalCommit": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwOTA3Mg==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542309072", "bodyText": "As discussed offline, I think that we should revert this one. We want to use JSON in the request log (aka requestLogger), not as a replacement of all the toString usages.", "author": "dajac", "createdAt": "2020-12-14T11:22:22Z", "path": "core/src/main/scala/kafka/network/RequestChannel.scala", "diffHunk": "@@ -200,7 +208,7 @@ object RequestChannel extends Logging {\n       }\n     }\n \n-    trace(s\"Processor $processor received request: ${requestDesc(true)}\")\n+    trace(s\"Processor $processor received request: ${RequestConvertToJson.requestDesc(header, requestLog, isForwarded)}\")", "originalCommit": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwOTYzMA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542309630", "bodyText": "It seems that this one is not used anymore.", "author": "dajac", "createdAt": "2020-12-14T11:23:18Z", "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{BooleanNode, DoubleNode, JsonNodeFactory, LongNode, ObjectNode, TextNode}\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.requests._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EnvelopeRequest => EnvelopeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => OffsetForLeaderEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ProduceRequest => ProduceRequestDataJsonConverter.write(req.data, request.version, false)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.apiKey} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: EnvelopeResponse => EnvelopeResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version, false)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => OffsetForLeaderEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ProduceResponse => ProduceResponseDataJsonConverter.write(res.data, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${response.apiKey} is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data, header.headerVersion, false).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestContextNode(context: RequestContext): JsonNode = {", "originalCommit": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMxMDM3MA==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542310370", "bodyText": "We should also revert this one.", "author": "dajac", "createdAt": "2020-12-14T11:24:36Z", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -183,7 +185,8 @@ class KafkaApis(val requestChannel: RequestChannel,\n    */\n   override def handle(request: RequestChannel.Request): Unit = {\n     try {\n-      trace(s\"Handling request:${request.requestDesc(true)} from connection ${request.context.connectionId};\" +\n+      trace(s\"Handling request:${RequestConvertToJson.requestDesc(request.header, request.requestLog, request.isForwarded)} \" +", "originalCommit": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMxMDUxMw==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542310513", "bodyText": "We should also revert this one.", "author": "dajac", "createdAt": "2020-12-14T11:24:48Z", "path": "core/src/main/scala/kafka/tools/TestRaftRequestHandler.scala", "diffHunk": "@@ -39,7 +40,8 @@ class TestRaftRequestHandler(\n \n   override def handle(request: RequestChannel.Request): Unit = {\n     try {\n-      trace(s\"Handling request:${request.requestDesc(true)} from connection ${request.context.connectionId};\" +\n+      trace(s\"Handling request:${RequestConvertToJson.requestDesc(request.header, request.requestLog, request.isForwarded)} \" +", "originalCommit": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMxMjM2OQ==", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542312369", "bodyText": "Could we also add unit tests for RequestConvertToJson.requestDesc, RequestConvertToJson.requestHeaderNode and RequestConvertToJson.clientInfoNode?", "author": "dajac", "createdAt": "2020-12-14T11:28:04Z", "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.net.InetAddress\n+import java.nio.ByteBuffer\n+\n+import com.fasterxml.jackson.databind.node.{DoubleNode, LongNode, ObjectNode, TextNode}\n+import kafka.network\n+import org.apache.kafka.common.memory.MemoryPool\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName, NetworkSend}\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, ByteBufferAccessor, ObjectSerializationCache}\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.easymock.EasyMock.createNiceMock\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach { key => {\n+      val version: Short = key.latestVersion()\n+      val cache = new ObjectSerializationCache\n+      val message = key match {\n+        case ApiKeys.DESCRIBE_ACLS =>\n+          ApiMessageType.fromApiKey(key.id).newRequest().asInstanceOf[DescribeAclsRequestData]\n+            .setPatternTypeFilter(1).setResourceTypeFilter(1).setPermissionType(1).setOperation(1)\n+        case _ =>\n+          ApiMessageType.fromApiKey(key.id).newRequest()\n+      }\n+      val messageSize = message.size(cache, version)\n+      val bytes = new ByteBufferAccessor(ByteBuffer.allocate(messageSize))\n+      message.write(bytes, cache, version)\n+      bytes.flip()\n+\n+      val req = AbstractRequest.parseRequest(key, version, bytes.buffer).request\n+      try {\n+        RequestConvertToJson.request(req)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    }}\n+    assertEquals(\"Unhandled request keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+", "originalCommit": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1fc3a11ca54b9958c1ef20fbca9abb4606ecbdd0", "url": "https://github.com/apache/kafka/commit/1fc3a11ca54b9958c1ef20fbca9abb4606ecbdd0", "message": "address minor comments", "committedDate": "2020-12-14T17:59:50Z", "type": "commit"}]}