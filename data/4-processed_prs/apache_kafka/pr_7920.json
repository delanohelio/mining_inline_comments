{"pr_number": 7920, "pr_title": "KAFKA-7737; Use single path in producer for initializing the producerId", "pr_createdAt": "2020-01-09T17:31:35Z", "pr_url": "https://github.com/apache/kafka/pull/7920", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0NjcyNg==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r366846726", "bodyText": "Just sanity checking: do I understand correctly that this became the part of resetProducerIdIfNeeded so at the first time this code path runs the producer id gets placed in the transactional request queue? Is this also the reason for removing 'maybeWaitForProducerId`?", "author": "viktorsomogyi", "createdAt": "2020-01-15T12:21:22Z", "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -517,16 +512,6 @@ public boolean isRunning() {\n         return running;\n     }\n \n-    private ClientResponse sendAndAwaitInitProducerIdRequest(Node node) throws IOException {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5NTY4Nw==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367095687", "bodyText": "Yes, that's right.", "author": "hachikuji", "createdAt": "2020-01-15T20:40:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0NjcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk3NDQ4Ng==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r366974486", "bodyText": "Would you consider using a long timeout instead and move this to TestUtils? Perhaps we need this somewhere else too.", "author": "viktorsomogyi", "createdAt": "2020-01-15T16:26:29Z", "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java", "diffHunk": "@@ -2925,4 +2766,14 @@ private void assertFutureFailed(Future<RecordMetadata> future) throws Interrupte\n         }\n     }\n \n+    private void runUntil(Supplier<Boolean> condition) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5NjY5Mg==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367096692", "bodyText": "It's a bit difficult to restructure these test cases with a timeout. Most of the logic is basically \"run the sender until X happens, then verify Y.\" With a timeout, we cannot control the stopping condition.", "author": "hachikuji", "createdAt": "2020-01-15T20:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk3NDQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExMDkwOQ==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367110909", "bodyText": "The only other caller of InitProducerIdRequest.Builder is in TransactionManager#initializeTransactions which is only called in producer#iniTxns. For idempotent producer how that initPid request would be sent? Did I miss anything?", "author": "guozhangwang", "createdAt": "2020-01-15T21:16:09Z", "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -538,41 +523,6 @@ private Node awaitNodeReady(FindCoordinatorRequest.CoordinatorType coordinatorTy\n         return null;\n     }\n \n-    private void maybeWaitForProducerId() {\n-        while (!forceClose && !transactionManager.hasProducerId() && !transactionManager.hasError()) {\n-            Node node = null;\n-            try {\n-                node = awaitNodeReady(null);\n-                if (node != null) {\n-                    ClientResponse response = sendAndAwaitInitProducerIdRequest(node);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExMjY3NQ==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367112675", "bodyText": "We also build an InitProducerIdRequest inside TransactionManager.resetProducerIdIfNeeded in this patch.", "author": "hachikuji", "createdAt": "2020-01-15T21:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExMDkwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzMDA3NA==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367130074", "bodyText": "Ack, thanks!", "author": "guozhangwang", "createdAt": "2020-01-15T22:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExMDkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzNjczMw==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367136733", "bodyText": "qq: is the second condition necessary given the first one? If we are not in transactional, then right now the only place to transit to INITIALIZING is line 496 below. I'm actually fine to leave it here to be less bug-vulnerable, but just to clarify my understanding.", "author": "guozhangwang", "createdAt": "2020-01-15T22:17:24Z", "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -481,6 +489,17 @@ synchronized void resetProducerIdIfNeeded() {\n         if (shouldResetProducerStateAfterResolvingSequences())\n             // Check if the previous run expired batches which requires a reset of the producer state.\n             resetProducerId();\n+\n+        if (!isTransactional()\n+                && currentState != State.INITIALIZING", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1ODAyNQ==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367158025", "bodyText": "I added it to ensure that we don't enqueue multiple InitProducerId requests.", "author": "hachikuji", "createdAt": "2020-01-15T23:18:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzNjczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzODkxMA==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367138910", "bodyText": "qq: could you add a comment explaining why we need to call client.poll before exiting under this condition?", "author": "guozhangwang", "createdAt": "2020-01-15T22:22:43Z", "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -300,28 +295,27 @@ public void run() {\n     void runOnce() {\n         if (transactionManager != null) {\n             try {\n-                transactionManager.resetProducerIdIfNeeded();\n-\n-                if (!transactionManager.isTransactional()) {\n-                    // this is an idempotent producer, so make sure we have a producer id\n-                    maybeWaitForProducerId();\n-                } else if (transactionManager.hasUnresolvedSequences() && !transactionManager.hasFatalError()) {\n+                if (transactionManager.isTransactional()\n+                        && transactionManager.hasUnresolvedSequences()\n+                        && !transactionManager.hasFatalError()) {\n                     transactionManager.transitionToFatalError(\n-                        new KafkaException(\"The client hasn't received acknowledgment for \" +\n-                            \"some previously sent messages and can no longer retry them. It isn't safe to continue.\"));\n-                } else if (maybeSendAndPollTransactionalRequest()) {\n-                    return;\n+                            new KafkaException(\"The client hasn't received acknowledgment for \" +\n+                                    \"some previously sent messages and can no longer retry them. It isn't safe to continue.\"));\n                 }\n \n-                // do not continue sending if the transaction manager is in a failed state or if there\n-                // is no producer id (for the idempotent case).\n-                if (transactionManager.hasFatalError() || !transactionManager.hasProducerId()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NzEyNg==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367197126", "bodyText": "I don't have a great explanation for it to be honest. I guess we are trying to ensure that any inflight requests return before we shutdown. Perhaps we should just crash the thread and let the client get cleaned up? How about I open a separate issue for this?", "author": "hachikuji", "createdAt": "2020-01-16T01:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzODkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2MzcyOQ==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r368263729", "bodyText": "SG.", "author": "guozhangwang", "createdAt": "2020-01-19T03:52:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzODkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0MDIwNQ==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367140205", "bodyText": "We can let this to return a boolean on whether a request is enqueued, and then in Sender we could:\nif (transactionManager.resetProducerIdIfNeeded() && maybeSendAndPollTransactionalRequest()) ..\n\nalso nit: Add a comment on top indicating that we will send out a new initPid request if producer is not transactional.", "author": "guozhangwang", "createdAt": "2020-01-15T22:25:58Z", "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -481,6 +489,17 @@ synchronized void resetProducerIdIfNeeded() {\n         if (shouldResetProducerStateAfterResolvingSequences())\n             // Check if the previous run expired batches which requires a reset of the producer state.\n             resetProducerId();\n+\n+        if (!isTransactional()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjUxNg==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367162516", "bodyText": "I think we want to call maybeSendAndPollTransactionalRequest in this loop regardless whether resetProducerIdNeeded returns true. Ack on the comment.", "author": "hachikuji", "createdAt": "2020-01-15T23:33:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0MDIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0MTU5OA==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367141598", "bodyText": "qq: is that a piggy-backed fix, or is it necessary for the refactoring?", "author": "guozhangwang", "createdAt": "2020-01-15T22:29:34Z", "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -412,6 +416,10 @@ synchronized void transitionToAbortableError(RuntimeException exception) {\n \n     synchronized void transitionToFatalError(RuntimeException exception) {\n         transitionTo(State.FATAL_ERROR, exception);\n+\n+        if (pendingResult != null) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2Mjg4Nw==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367162887", "bodyText": "More of an optimization than a fix I guess, but it simplified one of the tests in TransactionManagerTest.", "author": "hachikuji", "createdAt": "2020-01-15T23:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0MTU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0MjExNg==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367142116", "bodyText": "How about: letting the state to transit to UNINITIALIZED inside resetProducerId (since it will only execute successfully if not transactional). By doing this we still have a single transition path to INITIALIZING?", "author": "guozhangwang", "createdAt": "2020-01-15T22:30:59Z", "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -216,7 +216,7 @@ public void resetSequenceNumbers(Consumer<ProducerBatch> resetSequence) {\n         private boolean isTransitionValid(State source, State target) {\n             switch (target) {\n                 case INITIALIZING:\n-                    return source == UNINITIALIZED;\n+                    return source == UNINITIALIZED || source == READY;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MzQxOQ==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367163419", "bodyText": "Yeah, it's a good thought. I don't recall if I previously considered this, but let me take a look and see if it works.", "author": "hachikuji", "createdAt": "2020-01-15T23:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0MjExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1MjI4OQ==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367152289", "bodyText": "qq: Why is this necessary?", "author": "guozhangwang", "createdAt": "2020-01-15T22:59:49Z", "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/SenderTest.java", "diffHunk": "@@ -1154,7 +1154,9 @@ public void testExpiryOfAllSentBatchesShouldCauseUnresolvedSequences() throws Ex\n         Deque<ProducerBatch> batches = accumulator.batches().get(tp0);\n         assertEquals(0, batches.size());\n         assertTrue(transactionManager.hasProducerId(producerId));\n+\n         // We should now clear the old producerId and get a new one in a single run loop.\n+        time.sleep(10);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2Njk0Ng==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367166946", "bodyText": "Note that we blackout the node for 10ms above. Previously we were relying on the backoff logic in maybeWaitForProducerId for the node to be ready again. Now the test needs time to be advanced externally since we cannot rely on client.poll advancing it.", "author": "hachikuji", "createdAt": "2020-01-15T23:50:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1MjI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NTA2MQ==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367195061", "bodyText": "SG.", "author": "guozhangwang", "createdAt": "2020-01-16T01:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1MjI4OQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5OTE1Ng==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367199156", "bodyText": "Reducing visibility here to make sure that test cases are forced through the proper state transitions.", "author": "hachikuji", "createdAt": "2020-01-16T02:04:49Z", "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -451,7 +453,7 @@ boolean hasProducerIdAndEpoch(long producerId, short producerEpoch) {\n     /**\n      * Set the producer id and epoch atomically.\n      */\n-    void setProducerIdAndEpoch(ProducerIdAndEpoch producerIdAndEpoch) {\n+    private void setProducerIdAndEpoch(ProducerIdAndEpoch producerIdAndEpoch) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MTIwNQ==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r369471205", "bodyText": "Just FYI, for KIP-360 I'm doing this check for both idempotent and transactional, since it triggers an epoch bump instead of a producerId reset. I'll just pull this call out to a shared code path, the rest of this method shouldn't need to change.", "author": "bob-barrett", "createdAt": "2020-01-22T10:11:32Z", "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -473,19 +475,32 @@ void setProducerIdAndEpoch(ProducerIdAndEpoch producerIdAndEpoch) {\n      * would not have any way of knowing this happened. So for the transactional producer, it's best to return the\n      * produce error to the user and let them abort the transaction and close the producer explicitly.\n      */\n-    synchronized void resetProducerId() {\n+    synchronized void resetIdempotentProducerId() {\n         if (isTransactional())\n             throw new IllegalStateException(\"Cannot reset producer state for a transactional producer. \" +\n                     \"You must either abort the ongoing transaction or reinitialize the transactional producer instead\");\n         setProducerIdAndEpoch(ProducerIdAndEpoch.NONE);\n         topicPartitionBookkeeper.reset();\n         this.partitionsWithUnresolvedSequences.clear();\n+        transitionTo(State.UNINITIALIZED);\n     }\n \n-    synchronized void resetProducerIdIfNeeded() {\n-        if (shouldResetProducerStateAfterResolvingSequences())\n-            // Check if the previous run expired batches which requires a reset of the producer state.\n-            resetProducerId();\n+    synchronized void resetIdempotentProducerIdIfNeeded() {\n+        if (!isTransactional()) {\n+            if (shouldResetProducerStateAfterResolvingSequences()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY2NTAxMw==", "url": "https://github.com/apache/kafka/pull/7920#discussion_r369665013", "bodyText": "Sounds good. We can rename the method as well.", "author": "hachikuji", "createdAt": "2020-01-22T16:27:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MTIwNQ=="}], "type": "inlineReview"}, {"oid": "724117119041ad85d7106c83721d7ba8c9b64800", "url": "https://github.com/apache/kafka/commit/724117119041ad85d7106c83721d7ba8c9b64800", "message": "KAFKA-7737; Use single path in producer for initializing the producerId", "committedDate": "2020-01-23T00:14:11Z", "type": "commit"}, {"oid": "94df3123c55b956ded078ce81528db9d2f2a94a8", "url": "https://github.com/apache/kafka/commit/94df3123c55b956ded078ce81528db9d2f2a94a8", "message": "A second call to initTransactions should fail", "committedDate": "2020-01-23T00:14:11Z", "type": "commit"}, {"oid": "3e45a5aec8150398eaec3a4aefaa37a07c65239f", "url": "https://github.com/apache/kafka/commit/3e45a5aec8150398eaec3a4aefaa37a07c65239f", "message": "ProducerId reset transitions to UNINITIALIZED", "committedDate": "2020-01-23T00:17:30Z", "type": "commit"}, {"oid": "3e45a5aec8150398eaec3a4aefaa37a07c65239f", "url": "https://github.com/apache/kafka/commit/3e45a5aec8150398eaec3a4aefaa37a07c65239f", "message": "ProducerId reset transitions to UNINITIALIZED", "committedDate": "2020-01-23T00:17:30Z", "type": "forcePushed"}]}