{"pr_number": 8012, "pr_title": "KAFKA-9474: Adds 'float64' to the RPC protocol types.", "pr_createdAt": "2020-01-28T19:33:39Z", "pr_url": "https://github.com/apache/kafka/pull/8012", "timeline": [{"oid": "99f1d9ae3a38c25194283801e614018b5205d463", "url": "https://github.com/apache/kafka/commit/99f1d9ae3a38c25194283801e614018b5205d463", "message": "KAFKA-9474: Adds 'double' to the protocol message types.", "committedDate": "2020-01-28T19:32:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMTIwNg==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372021206", "bodyText": "Should it be float64 to be consistent with int64 (versus long)?", "author": "ijuma", "createdAt": "2020-01-28T19:51:22Z", "path": "clients/src/main/resources/common/message/README.md", "diffHunk": "@@ -79,6 +79,8 @@ There are several primitive field types available.\n \n * \"int64\": a 64-bit integer.\n \n+* \"double\": is a double-precision floating point number (IEEE 754).", "originalCommit": "99f1d9ae3a38c25194283801e614018b5205d463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyNzU2MQ==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372027561", "bodyText": "I went with what proto uses. I have no preference and am fine with either.", "author": "bdbyrne", "createdAt": "2020-01-28T20:04:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMTIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAzMDM5OA==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372030398", "bodyText": "Interesting that they choose to include the size only for the integers. Since there has been a bit of an explosion of float types recently due to Machine Learning, I think float64 is a bit more future proof. What do you think? Also, @hachikuji, do you have any thoughts?", "author": "ijuma", "createdAt": "2020-01-28T20:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMTIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNDQyOA==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372134428", "bodyText": "Updated to float64.", "author": "bdbyrne", "createdAt": "2020-01-29T00:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMTIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyNzE1NA==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372027154", "bodyText": "I was checking protobuf and they do:\n    public double readDouble() throws IOException {\n      return Double.longBitsToDouble(readRawLittleEndian64());\n    }", "author": "ijuma", "createdAt": "2020-01-28T20:03:19Z", "path": "clients/src/main/java/org/apache/kafka/common/utils/ByteUtils.java", "diffHunk": "@@ -253,6 +253,26 @@ public static long readVarlong(ByteBuffer buffer)  {\n         return (value >>> 1) ^ -(value & 1);\n     }\n \n+    /**\n+     * Read a double-precision 64-bit format IEEE 754 value.\n+     *\n+     * @param in The input to read from\n+     * @return The double value read\n+     */\n+    public static double readDouble(DataInput in) throws IOException {\n+        return Double.longBitsToDouble(in.readLong());", "originalCommit": "99f1d9ae3a38c25194283801e614018b5205d463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNTEyNg==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372135126", "bodyText": "From reading ByteBuffer, I couldn't find any documentation that strictly specified the byte format, though it'd be hard to image it ever being changed or differ across JDK implementations. DataInput, on the other hand, does specify. For both, I've maintained the wrapper and test, but used their native calls read/getDouble and write/putDouble.\nLet me know if you'd prefer I fold them away altogether.", "author": "bdbyrne", "createdAt": "2020-01-29T00:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyNzE1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIwMDA4Mw==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372200083", "bodyText": "Looks fine to me.", "author": "ijuma", "createdAt": "2020-01-29T05:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyNzE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODMxNA==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372028314", "bodyText": "So, ByteBuffer does. Are you concerned that they may change the implementation? Seems like they cannot without basically breaking everyone, right?\n    private ByteBuffer putDouble(long a, double x) {\n\n        try {\n            long y = Double.doubleToRawLongBits(x);\n            UNSAFE.putLongUnaligned(null, a, y, bigEndian);\n        } finally {\n            Reference.reachabilityFence(this);\n        }\n        return this;\n    }", "author": "ijuma", "createdAt": "2020-01-28T20:05:56Z", "path": "clients/src/main/java/org/apache/kafka/common/utils/ByteUtils.java", "diffHunk": "@@ -346,6 +366,26 @@ public static void writeVarlong(long value, ByteBuffer buffer) {\n         buffer.put((byte) v);\n     }\n \n+    /**\n+     * Write the given double following the double-precision 64-bit format IEEE 754 value into the output.\n+     *\n+     * @param value The value to write\n+     * @param out The output to write to\n+     */\n+    public static void writeDouble(double value, DataOutput out) throws IOException {\n+        out.writeLong(Double.doubleToRawLongBits(value));\n+    }\n+\n+    /**\n+     * Write the given double following the double-precision 64-bit format IEEE 754 value into the buffer.\n+     *\n+     * @param value The value to write\n+     * @param buffer The buffer to write to\n+     */\n+    public static void writeDouble(double value, ByteBuffer buffer) {\n+        buffer.putLong(Double.doubleToRawLongBits(value));", "originalCommit": "99f1d9ae3a38c25194283801e614018b5205d463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAzMTEwMg==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372031102", "bodyText": "One difference to protobuf is that it's big endian instead of little endian. Edit: nevermind, we can choose big or little endian for byte buffers.", "author": "ijuma", "createdAt": "2020-01-28T20:12:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNTM1MQ==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372135351", "bodyText": "Similar comment to above - maintained ByteBuffer wrapper, but call putDouble() directly. Can remove if requested.", "author": "bdbyrne", "createdAt": "2020-01-29T00:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIwMDE2Mg==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372200162", "bodyText": "Sounds good.", "author": "ijuma", "createdAt": "2020-01-29T05:51:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODMxNA=="}], "type": "inlineReview"}, {"oid": "e789ba0bf71eeedbbe721cf7bf727cb9c22b6c88", "url": "https://github.com/apache/kafka/commit/e789ba0bf71eeedbbe721cf7bf727cb9c22b6c88", "message": "Rename double -> fixed64. Simplify serialization.", "committedDate": "2020-01-29T00:31:04Z", "type": "commit"}, {"oid": "da8469aac18499f22f0292eea3101b7711213d69", "url": "https://github.com/apache/kafka/commit/da8469aac18499f22f0292eea3101b7711213d69", "message": "(minor whitespace improvement)", "committedDate": "2020-01-29T00:40:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5ODk2MA==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372198960", "bodyText": "Do we want to have a simple positive value like 2.5?", "author": "ijuma", "createdAt": "2020-01-29T05:45:37Z", "path": "clients/src/test/java/org/apache/kafka/common/protocol/types/ProtocolSerializationTest.java", "diffHunk": "@@ -87,6 +89,15 @@ public void testSimple() {\n         check(Type.INT16, (short) -11111, \"INT16\");\n         check(Type.INT32, -11111111, \"INT32\");\n         check(Type.INT64, -11111111111L, \"INT64\");\n+        check(Type.FLOAT64, -0.5D, \"FLOAT64\");\n+        check(Type.FLOAT64, 1e300D, \"FLOAT64\");\n+        check(Type.FLOAT64, 0.0D, \"FLOAT64\");\n+        check(Type.FLOAT64, -0.0D, \"FLOAT64\");\n+        check(Type.FLOAT64, Double.MAX_VALUE, \"FLOAT64\");\n+        check(Type.FLOAT64, Double.MIN_VALUE, \"FLOAT64\");\n+        check(Type.FLOAT64, Double.NaN, \"FLOAT64\");\n+        check(Type.FLOAT64, Double.NEGATIVE_INFINITY, \"FLOAT64\");\n+        check(Type.FLOAT64, Double.POSITIVE_INFINITY, \"FLOAT64\");", "originalCommit": "da8469aac18499f22f0292eea3101b7711213d69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUyNjE2Mw==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372526163", "bodyText": "Done.", "author": "bdbyrne", "createdAt": "2020-01-29T17:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5ODk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5OTA5Mw==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372199093", "bodyText": "Nit: do we need the D suffix? Typically, the decimal point is enough to indicate a double in Java.", "author": "ijuma", "createdAt": "2020-01-29T05:46:16Z", "path": "clients/src/test/java/org/apache/kafka/common/protocol/types/ProtocolSerializationTest.java", "diffHunk": "@@ -87,6 +89,15 @@ public void testSimple() {\n         check(Type.INT16, (short) -11111, \"INT16\");\n         check(Type.INT32, -11111111, \"INT32\");\n         check(Type.INT64, -11111111111L, \"INT64\");\n+        check(Type.FLOAT64, -0.5D, \"FLOAT64\");\n+        check(Type.FLOAT64, 1e300D, \"FLOAT64\");\n+        check(Type.FLOAT64, 0.0D, \"FLOAT64\");\n+        check(Type.FLOAT64, -0.0D, \"FLOAT64\");", "originalCommit": "da8469aac18499f22f0292eea3101b7711213d69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUyNjI2NA==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372526264", "bodyText": "Done.", "author": "bdbyrne", "createdAt": "2020-01-29T17:31:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5OTA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5OTQyMQ==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372199421", "bodyText": "Nit: I think 0.0 is idiomatic in Java.", "author": "ijuma", "createdAt": "2020-01-29T05:47:47Z", "path": "generator/src/main/java/org/apache/kafka/message/MessageDataGenerator.java", "diffHunk": "@@ -1893,6 +1909,18 @@ private String fieldDefault(FieldSpec field) {\n                 headerGenerator.addImport(MessageGenerator.UUID_CLASS);\n                 return \"UUID.fromString(\\\"\" + field.defaultString() + \"\\\")\";\n             }\n+        } else if (field.type() instanceof FieldType.Float64FieldType) {\n+            if (field.defaultString().isEmpty()) {\n+                return \"0D\";", "originalCommit": "da8469aac18499f22f0292eea3101b7711213d69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUyNjMyNw==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372526327", "bodyText": "Done.", "author": "bdbyrne", "createdAt": "2020-01-29T17:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5OTQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5OTg2Ng==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372199866", "bodyText": "For my benefit, what was the reasoning for choosing big endian?", "author": "ijuma", "createdAt": "2020-01-29T05:49:46Z", "path": "clients/src/main/java/org/apache/kafka/common/protocol/types/Type.java", "diffHunk": "@@ -367,6 +367,42 @@ public String documentation() {\n         }\n     };\n \n+    public static final DocumentedType FLOAT64 = new DocumentedType() {\n+        @Override\n+        public void write(ByteBuffer buffer, Object o) {\n+            ByteUtils.writeDouble((Double) o, buffer);\n+        }\n+\n+        @Override\n+        public Object read(ByteBuffer buffer) {\n+            return ByteUtils.readDouble(buffer);\n+        }\n+\n+        @Override\n+        public int sizeOf(Object o) {\n+            return 8;\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return \"FLOAT64\";\n+        }\n+\n+        @Override\n+        public Double validate(Object item) {\n+            if (item instanceof Double)\n+                return (Double) item;\n+            else\n+                throw new SchemaException(item + \" is not a Double.\");\n+        }\n+\n+        @Override\n+        public String documentation() {\n+            return \"Represents a double-precision 64-bit format IEEE 754 value. \" +\n+                    \"The values are encoded using eight bytes in network byte order (big-endian).\";", "originalCommit": "da8469aac18499f22f0292eea3101b7711213d69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUyNjUyOQ==", "url": "https://github.com/apache/kafka/pull/8012#discussion_r372526529", "bodyText": "For consistency - all of the integers types are big-endian as well.", "author": "bdbyrne", "createdAt": "2020-01-29T17:32:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5OTg2Ng=="}], "type": "inlineReview"}, {"oid": "533704fe00e87d003c51f50e1a7b48ba98e5d6dd", "url": "https://github.com/apache/kafka/commit/533704fe00e87d003c51f50e1a7b48ba98e5d6dd", "message": "Address review comments.", "committedDate": "2020-01-29T17:30:40Z", "type": "commit"}]}