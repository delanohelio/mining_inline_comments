{"pr_number": 8418, "pr_title": "KAFKA-9807; Protect LSO reads from concurrent high-watermark updates", "pr_createdAt": "2020-04-03T17:23:33Z", "pr_url": "https://github.com/apache/kafka/pull/8418", "timeline": [{"oid": "d162c26242a1fa25479b9067e8238dbdaaf4c75a", "url": "https://github.com/apache/kafka/commit/d162c26242a1fa25479b9067e8238dbdaaf4c75a", "message": "KAFKA-9807; Protect LSO reads from concurrent high-watermark updates", "committedDate": "2020-04-03T17:20:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE4MjU4Ng==", "url": "https://github.com/apache/kafka/pull/8418#discussion_r403182586", "bodyText": "Should we use lambdas for Runnable and Callable?", "author": "ijuma", "createdAt": "2020-04-03T17:40:07Z", "path": "core/src/test/scala/unit/kafka/log/LogTest.scala", "diffHunk": "@@ -3649,6 +3650,61 @@ class LogTest {\n     assertEquals(None, log.firstUnstableOffset)\n   }\n \n+  @Test\n+  def testReadCommittedWithConcurrentHighWatermarkUpdates(): Unit = {\n+    val logConfig = LogTest.createLogConfig(segmentBytes = 1024 * 1024 * 5)\n+    val log = createLog(logDir, logConfig)\n+    val lastOffset = 50L\n+\n+    val producerEpoch = 0.toShort\n+    val producerId = 15L\n+    val appendProducer = appendTransactionalAsLeader(log, producerId, producerEpoch)\n+\n+    // Thread 1 writes single-record transactions and attempts to read them\n+    // before they have been aborted, and then aborts them\n+    val txnVerifier = new Callable[Int]() {\n+      override def call(): Int = {\n+        var nonEmptyReads = 0\n+        while (log.logEndOffset < lastOffset) {\n+          val currentLogEndOffset = log.logEndOffset\n+\n+          appendProducer(1)\n+\n+          val readInfo = log.read(\n+            startOffset = currentLogEndOffset,\n+            maxLength = Int.MaxValue,\n+            isolation = FetchTxnCommitted,\n+            minOneMessage = false)\n+\n+          if (readInfo.records.sizeInBytes() > 0)\n+            nonEmptyReads += 1\n+\n+          appendEndTxnMarkerAsLeader(log, producerId, producerEpoch, ControlRecordType.ABORT)\n+        }\n+        nonEmptyReads\n+      }\n+    }\n+\n+    // Thread 2 watches the log and updates the high watermark\n+    val hwUpdater = new Runnable() {\n+      override def run(): Unit = {\n+        while (log.logEndOffset < lastOffset) {\n+          log.updateHighWatermark(log.logEndOffset)\n+        }\n+      }\n+    }", "originalCommit": "d162c26242a1fa25479b9067e8238dbdaaf4c75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE4MzQ5MA==", "url": "https://github.com/apache/kafka/pull/8418#discussion_r403183490", "bodyText": "Shall we do this within a try/finally?", "author": "ijuma", "createdAt": "2020-04-03T17:41:07Z", "path": "core/src/test/scala/unit/kafka/log/LogTest.scala", "diffHunk": "@@ -3649,6 +3650,61 @@ class LogTest {\n     assertEquals(None, log.firstUnstableOffset)\n   }\n \n+  @Test\n+  def testReadCommittedWithConcurrentHighWatermarkUpdates(): Unit = {\n+    val logConfig = LogTest.createLogConfig(segmentBytes = 1024 * 1024 * 5)\n+    val log = createLog(logDir, logConfig)\n+    val lastOffset = 50L\n+\n+    val producerEpoch = 0.toShort\n+    val producerId = 15L\n+    val appendProducer = appendTransactionalAsLeader(log, producerId, producerEpoch)\n+\n+    // Thread 1 writes single-record transactions and attempts to read them\n+    // before they have been aborted, and then aborts them\n+    val txnVerifier = new Callable[Int]() {\n+      override def call(): Int = {\n+        var nonEmptyReads = 0\n+        while (log.logEndOffset < lastOffset) {\n+          val currentLogEndOffset = log.logEndOffset\n+\n+          appendProducer(1)\n+\n+          val readInfo = log.read(\n+            startOffset = currentLogEndOffset,\n+            maxLength = Int.MaxValue,\n+            isolation = FetchTxnCommitted,\n+            minOneMessage = false)\n+\n+          if (readInfo.records.sizeInBytes() > 0)\n+            nonEmptyReads += 1\n+\n+          appendEndTxnMarkerAsLeader(log, producerId, producerEpoch, ControlRecordType.ABORT)\n+        }\n+        nonEmptyReads\n+      }\n+    }\n+\n+    // Thread 2 watches the log and updates the high watermark\n+    val hwUpdater = new Runnable() {\n+      override def run(): Unit = {\n+        while (log.logEndOffset < lastOffset) {\n+          log.updateHighWatermark(log.logEndOffset)\n+        }\n+      }\n+    }\n+\n+    val executor = Executors.newFixedThreadPool(2)\n+    executor.submit(hwUpdater)\n+\n+    val future = executor.submit(txnVerifier)\n+    val nonEmptyReads = future.get()\n+\n+    assertEquals(0, nonEmptyReads)\n+\n+    executor.shutdownNow()", "originalCommit": "d162c26242a1fa25479b9067e8238dbdaaf4c75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ef0058146efe1bbd9b848be3395c4be571b4842f", "url": "https://github.com/apache/kafka/commit/ef0058146efe1bbd9b848be3395c4be571b4842f", "message": "Address feedback on test case", "committedDate": "2020-04-03T17:54:30Z", "type": "commit"}]}