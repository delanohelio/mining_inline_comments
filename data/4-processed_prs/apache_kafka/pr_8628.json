{"pr_number": 8628, "pr_title": "KAFKA-9942: Fixes ConfigCommand client quotas w/ default users.", "pr_createdAt": "2020-05-06T21:35:11Z", "pr_url": "https://github.com/apache/kafka/pull/8628", "timeline": [{"oid": "927580442ced625bf2988a440d78934665b3c062", "url": "https://github.com/apache/kafka/commit/927580442ced625bf2988a440d78934665b3c062", "message": "KAFKA-9942: Fixes ConfigCommand client quotas w/ default users when using --bootstrap-servers.", "committedDate": "2020-05-06T21:33:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg1ODQxOA==", "url": "https://github.com/apache/kafka/pull/8628#discussion_r421858418", "bodyText": "It's not really that they're invalid, it's that we want to delete them and they're not present, right?  I realize this is an existing issue.", "author": "cmccabe", "createdAt": "2020-05-07T23:52:15Z", "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -362,21 +362,22 @@ object ConfigCommand extends Config {\n         ).asJavaCollection\n         adminClient.incrementalAlterConfigs(Map(configResource -> alterLogLevelEntries).asJava, alterOptions).all().get(60, TimeUnit.SECONDS)\n \n-      case ConfigType.User =>\n-      case ConfigType.Client =>\n-        val oldConfig: Map[String, java.lang.Double] = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n+      case ConfigType.User | ConfigType.Client =>\n+        val oldConfig = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n \n         val invalidConfigs = configsToBeDeleted.filterNot(oldConfig.contains)\n         if (invalidConfigs.nonEmpty)", "originalCommit": "927580442ced625bf2988a440d78934665b3c062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg1OTYzOQ==", "url": "https://github.com/apache/kafka/pull/8628#discussion_r421859639", "bodyText": "That's correct. I can rename the variable for the various cases if you'd prefer.", "author": "bdbyrne", "createdAt": "2020-05-07T23:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg1ODQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzU5NQ==", "url": "https://github.com/apache/kafka/pull/8628#discussion_r422417595", "bodyText": "It's OK as-is.", "author": "cmccabe", "createdAt": "2020-05-08T23:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg1ODQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg2NDEzMQ==", "url": "https://github.com/apache/kafka/pull/8628#discussion_r421864131", "bodyText": "Since this map potentially contains nulls (a bad practice) we need to be very careful about its type.  Many newer map types don't allow nulls and I don't trust Scala to always create a map that allows this.  I suggest manually building a Java HashMap.", "author": "cmccabe", "createdAt": "2020-05-08T00:11:20Z", "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -362,21 +362,22 @@ object ConfigCommand extends Config {\n         ).asJavaCollection\n         adminClient.incrementalAlterConfigs(Map(configResource -> alterLogLevelEntries).asJava, alterOptions).all().get(60, TimeUnit.SECONDS)\n \n-      case ConfigType.User =>\n-      case ConfigType.Client =>\n-        val oldConfig: Map[String, java.lang.Double] = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n+      case ConfigType.User | ConfigType.Client =>\n+        val oldConfig = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n \n         val invalidConfigs = configsToBeDeleted.filterNot(oldConfig.contains)\n         if (invalidConfigs.nonEmpty)\n           throw new InvalidConfigurationException(s\"Invalid config(s): ${invalidConfigs.mkString(\",\")}\")\n \n-        val entity = new ClientQuotaEntity(opts.entityTypes.map { entType =>\n+        val alterEntityTypes = entityTypes.map { entType =>\n           entType match {\n             case ConfigType.User => ClientQuotaEntity.USER\n             case ConfigType.Client => ClientQuotaEntity.CLIENT_ID\n             case _ => throw new IllegalArgumentException(s\"Unexpected entity type: ${entType}\")\n           }\n-        }.zip(opts.entityNames).toMap.asJava)\n+        }\n+        val alterEntityNames = entityNames.map(en => if (en.nonEmpty) en else null)\n+        val entity = new ClientQuotaEntity(alterEntityTypes.zip(alterEntityNames).toMap.asJava)", "originalCommit": "927580442ced625bf2988a440d78934665b3c062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2OTM3Mg==", "url": "https://github.com/apache/kafka/pull/8628#discussion_r422269372", "bodyText": "Done.", "author": "bdbyrne", "createdAt": "2020-05-08T17:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg2NDEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg2OTg4OQ==", "url": "https://github.com/apache/kafka/pull/8628#discussion_r421869889", "bodyText": "Same comment here.  We should use java's HashMap specifically since we know it supports null values and we don't know if other maps do or not.", "author": "cmccabe", "createdAt": "2020-05-08T00:31:18Z", "path": "core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala", "diffHunk": "@@ -398,16 +398,30 @@ class ConfigCommandTest extends ZooKeeperTestHarness with Logging {\n     ConfigCommand.alterConfigWithZk(null, createOpts, new TestAdminZkClient(zkClient))\n   }\n \n-  @Test\n-  def shouldAddClientConfig(): Unit = {\n+  def testShouldAddClientConfig(user: Option[String], clientId: Option[String]): Unit = {\n+    def toValues(entityName: Option[String], entityType: String, command: String):\n+        (Array[String], Option[String], Option[ClientQuotaFilterComponent]) = {\n+      entityName match {\n+        case Some(null) =>\n+          (Array(\"--entity-type\", command, \"--entity-default\"), Some(null),\n+            Some(ClientQuotaFilterComponent.ofDefaultEntity(entityType)))\n+        case Some(name) =>\n+          (Array(\"--entity-type\", command, \"--entity-name\", name), Some(name),\n+            Some(ClientQuotaFilterComponent.ofEntity(entityType, name)))\n+        case None => (Array.empty, None, None)\n+      }\n+    }\n+    val (userArgs, userEntity, userComponent) = toValues(user, ClientQuotaEntity.USER, \"users\")\n+    val (clientIdArgs, clientIdEntity, clientIdComponent) = toValues(clientId, ClientQuotaEntity.CLIENT_ID, \"clients\")\n+\n     val createOpts = new ConfigCommandOptions(Array(\"--bootstrap-server\", \"localhost:9092\",\n-      \"--entity-name\", \"my-client-id\",\n-      \"--entity-type\", \"clients\",\n       \"--alter\",\n       \"--add-config\", \"consumer_byte_rate=20000,producer_byte_rate=10000\",\n-      \"--delete-config\", \"request_percentage\"))\n+      \"--delete-config\", \"request_percentage\") ++ userArgs ++ clientIdArgs)\n \n-    val entity = new ClientQuotaEntity(Map((ClientQuotaEntity.CLIENT_ID -> \"my-client-id\")).asJava)\n+    val entity = new ClientQuotaEntity(Seq(", "originalCommit": "927580442ced625bf2988a440d78934665b3c062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2OTMzNQ==", "url": "https://github.com/apache/kafka/pull/8628#discussion_r422269335", "bodyText": "Done.", "author": "bdbyrne", "createdAt": "2020-05-08T17:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg2OTg4OQ=="}], "type": "inlineReview"}, {"oid": "12a91f3ca2cb2c6bcc9b08cf5c5b68640b3bdd50", "url": "https://github.com/apache/kafka/commit/12a91f3ca2cb2c6bcc9b08cf5c5b68640b3bdd50", "message": "Address comments.", "committedDate": "2020-05-08T17:25:02Z", "type": "commit"}]}