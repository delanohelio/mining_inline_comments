{"pr_number": 8187, "pr_title": "KAFKA-9620: Do not throw in the middle of consumer user callbacks", "pr_createdAt": "2020-02-27T20:43:52Z", "pr_url": "https://github.com/apache/kafka/pull/8187", "timeline": [{"oid": "bbdbb84b4b19eaf6323223204c66b96fc394a50c", "url": "https://github.com/apache/kafka/commit/bbdbb84b4b19eaf6323223204c66b96fc394a50c", "message": "log reason", "committedDate": "2020-02-27T17:16:20Z", "type": "commit"}, {"oid": "d6bfdb82bafed045b807da7f88aa86c496cb8be0", "url": "https://github.com/apache/kafka/commit/d6bfdb82bafed045b807da7f88aa86c496cb8be0", "message": "hold exception until the finish of all callbacks", "committedDate": "2020-02-27T22:34:37Z", "type": "commit"}, {"oid": "d6bfdb82bafed045b807da7f88aa86c496cb8be0", "url": "https://github.com/apache/kafka/commit/d6bfdb82bafed045b807da7f88aa86c496cb8be0", "message": "hold exception until the finish of all callbacks", "committedDate": "2020-02-27T22:34:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxNDU2Ng==", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385414566", "bodyText": "Add a logging to log the IO exception.", "author": "abbccdda", "createdAt": "2020-02-27T22:43:48Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java", "diffHunk": "@@ -84,7 +84,7 @@ static void wipeStateStores(final Logger log, final ProcessorStateManager stateM\n             Utils.delete(stateMgr.baseDir());\n         } catch (final IOException fatalException) {\n             // since it is only called under dirty close, we always swallow the exception\n-            log.warn(\"Failed to wiping state stores for task {}\", stateMgr.taskId());\n+            log.warn(\"Failed to wiping state stores for task {} due to {}\", stateMgr.taskId(), fatalException);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxNjIzNQ==", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385416235", "bodyText": "Simplify the logic here as we no longer throws before task suspend", "author": "abbccdda", "createdAt": "2020-02-27T22:48:20Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -293,12 +301,11 @@ boolean tryToCompleteRestoration() {\n      * @throws TaskMigratedException if the task producer got fenced (EOS only)\n      */\n     void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n-        final Set<TaskId> revokedTasks = new HashSet<>();\n         final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n \n         for (final Task task : tasks.values()) {\n             if (remainingPartitions.containsAll(task.inputPartitions())) {\n-                revokedTasks.add(task.id());\n+                task.suspend();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ1Njg1Mw==", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385456853", "bodyText": "Not sure I follow: we can still throw from inside suspend right?", "author": "guozhangwang", "createdAt": "2020-02-28T01:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxNjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2NTgwMg==", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385465802", "bodyText": "What I mean is that we do not throw if remaining partitions are not empty anymore. We could directly suspend a task here.", "author": "abbccdda", "createdAt": "2020-02-28T01:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxNjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2ODQxOA==", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385468418", "bodyText": "I see.", "author": "guozhangwang", "createdAt": "2020-02-28T01:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxNjIzNQ=="}], "type": "inlineReview"}, {"oid": "9e5126740306723247e240ca4617091f3ee6f0b9", "url": "https://github.com/apache/kafka/commit/9e5126740306723247e240ca4617091f3ee6f0b9", "message": "simplify revocation", "committedDate": "2020-02-27T22:56:05Z", "type": "commit"}, {"oid": "9e5126740306723247e240ca4617091f3ee6f0b9", "url": "https://github.com/apache/kafka/commit/9e5126740306723247e240ca4617091f3ee6f0b9", "message": "simplify revocation", "committedDate": "2020-02-27T22:56:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ1NzExOQ==", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385457119", "bodyText": "I think we should use instanceof KafkaException as well here:  if it is any inheritance of KafkaException, we should not wrap it.", "author": "guozhangwang", "createdAt": "2020-02-28T01:02:27Z", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -198,12 +198,19 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n         }\n \n         if (!taskCloseExceptions.isEmpty()) {\n+            for (final Map.Entry<TaskId, RuntimeException> entry : taskCloseExceptions.entrySet()) {\n+                if (!(entry.getValue() instanceof TaskMigratedException)) {", "originalCommit": "9e5126740306723247e240ca4617091f3ee6f0b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2ODkyOA==", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385468928", "bodyText": "Sounds good", "author": "abbccdda", "createdAt": "2020-02-28T01:47:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ1NzExOQ=="}], "type": "inlineReview"}, {"oid": "8821bfa06121deb8131984d432dd27397b4cb104", "url": "https://github.com/apache/kafka/commit/8821bfa06121deb8131984d432dd27397b4cb104", "message": "unit test", "committedDate": "2020-02-28T01:34:27Z", "type": "commit"}, {"oid": "8821bfa06121deb8131984d432dd27397b4cb104", "url": "https://github.com/apache/kafka/commit/8821bfa06121deb8131984d432dd27397b4cb104", "message": "unit test", "committedDate": "2020-02-28T01:34:27Z", "type": "forcePushed"}, {"oid": "1347ddc2c399ecddc1fa488c8188f3a74f0f5f49", "url": "https://github.com/apache/kafka/commit/1347ddc2c399ecddc1fa488c8188f3a74f0f5f49", "message": "also check Kafka exception", "committedDate": "2020-02-28T01:47:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2OTc4Mw==", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385469783", "bodyText": "Thank you for the added tests!", "author": "guozhangwang", "createdAt": "2020-02-28T01:51:03Z", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -741,6 +733,85 @@ public void shouldHaveRemainingPartitionsUncleared() {\n             \"detecting the heartbeat failure, or the tasks have been cleaned up by the handleAssignment callback.\"));\n     }\n \n+    @Test\n+    public void shouldThrowTaskMigratedWhenAllTaskCloseExceptionsAreTaskMigrated() {\n+        final StateMachineTask migratedTask01 = new StateMachineTask(taskId01, taskId01Partitions, false) {\n+            @Override\n+            public void closeClean() {\n+                throw new TaskMigratedException(\"t1 close exception\", new RuntimeException());\n+            }\n+        };\n+\n+        final StateMachineTask migratedTask02 = new StateMachineTask(taskId02, taskId02Partitions, false) {\n+            @Override\n+            public void closeClean() {\n+                throw new TaskMigratedException(\"t2 close exception\", new RuntimeException());\n+            }\n+        };\n+        taskManager.tasks().put(taskId01, migratedTask01);\n+        taskManager.tasks().put(taskId02, migratedTask02);\n+\n+        final TaskMigratedException thrown = assertThrows(TaskMigratedException.class,\n+            () -> taskManager.handleAssignment(emptyMap(), emptyMap()));\n+        // The task map orders tasks based on topic group id and partition, so here\n+        // t1 should always be the first.\n+        assertThat(thrown.getMessage(), equalTo(\"t1 close exception; it means all tasks belonging to this thread should be migrated.\"));\n+    }\n+\n+    @Test\n+    public void shouldThrowRuntimeExceptionWhenEncounteredUnknownExceptionDuringTaskClose() {", "originalCommit": "1347ddc2c399ecddc1fa488c8188f3a74f0f5f49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5Mjc0NQ==", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385492745", "bodyText": "just a side cleanup", "author": "abbccdda", "createdAt": "2020-02-28T03:34:58Z", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinatorTest.java", "diffHunk": "@@ -338,14 +353,11 @@ public void testManyInFlightAsyncCommitsWithCoordinatorDisconnect() {\n \n         for (int i = 0; i < numRequests; i++) {\n             Map<TopicPartition, OffsetAndMetadata> offsets = singletonMap(tp, new OffsetAndMetadata(i));\n-            coordinator.commitOffsetsAsync(offsets, new OffsetCommitCallback() {\n-                @Override\n-                public void onComplete(Map<TopicPartition, OffsetAndMetadata> offsets, Exception exception) {\n-                    responses.incrementAndGet();\n-                    Throwable cause = exception.getCause();\n-                    assertTrue(\"Unexpected exception cause type: \" + (cause == null ? null : cause.getClass()),\n-                            cause instanceof DisconnectException);\n-                }\n+            coordinator.commitOffsetsAsync(offsets, (offsets1, exception) -> {", "originalCommit": "1347ddc2c399ecddc1fa488c8188f3a74f0f5f49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "abbb2e38df0ff7c250e3b77588c7cc62b22bb4de", "url": "https://github.com/apache/kafka/commit/abbb2e38df0ff7c250e3b77588c7cc62b22bb4de", "message": "minor test fixes", "committedDate": "2020-02-28T04:50:15Z", "type": "commit"}]}