{"pr_number": 1352, "pr_title": "SAMZA-2516: Migrate BaseKeyValueStorageEngineFactory to be an abstract class instead of trait", "pr_createdAt": "2020-04-24T22:52:39Z", "pr_url": "https://github.com/apache/samza/pull/1352", "timeline": [{"oid": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2", "url": "https://github.com/apache/samza/commit/e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2", "message": "SAMZA-2516: Migrate BaseKeyValueStorageEngineFactory to be an abstract class instead of trait", "committedDate": "2020-04-24T21:58:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkxOTEyNA==", "url": "https://github.com/apache/samza/pull/1352#discussion_r416919124", "bodyText": "Is there a difference here between the order of wrapping each store between disallowing large messages vs. allowing? Ie. in the if statement, you first create the maybeCachedStore first and then the LargeMessageSafeStore, then the SerializedStore vs in the else statement, you first create the LargeMessageSafeStore, the SerializedStore, then the maybeCachedStore?\nAlso if there isn't a difference in order, couldn't we refactor this section of the code into a function that is passed  the getDisallowLargeMessages as a param to return the final store?", "author": "PanTheMan", "createdAt": "2020-04-28T21:00:24Z", "path": "samza-kv/src/main/java/org/apache/samza/storage/kv/BaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MetricsConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.apache.samza.util.HighResolutionClock;\n+import org.apache.samza.util.ScalaJavaUtil;\n+\n+\n+/**\n+ * This encapsulates all the steps needed to create a key value storage engine.\n+ * This is meant to be extended by the specific key value store factory implementations which will in turn override the\n+ * getKVStore method to return a raw key-value store.\n+ */\n+public abstract class BaseKeyValueStorageEngineFactory<K, V> implements StorageEngineFactory<K, V> {\n+  private static final String INMEMORY_KV_STORAGE_ENGINE_FACTORY =\n+      \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\";\n+\n+  /**\n+   * Implement this to return a KeyValueStore instance for the given store name, which will be used as the underlying\n+   * raw store.\n+   *\n+   * @param storeName Name of the store\n+   * @param storeDir The directory of the store\n+   * @param registry MetricsRegistry to which to publish store specific metrics.\n+   * @param changeLogSystemStreamPartition Samza stream partition from which to receive the changelog.\n+   * @param jobContext Information about the job in which the task is executing.\n+   * @param containerContext Information about the container in which the task is executing.\n+   * @return A raw KeyValueStore instance\n+   */\n+  protected abstract KeyValueStore<byte[], byte[]> getKVStore(String storeName,\n+      File storeDir,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changeLogSystemStreamPartition,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode);\n+\n+  /**\n+   * Constructs a key-value StorageEngine and returns it to the caller\n+   *\n+   * @param storeName The name of the storage engine.\n+   * @param storeDir The directory of the storage engine.\n+   * @param keySerde The serializer to use for serializing keys when reading or writing to the store.\n+   * @param msgSerde The serializer to use for serializing messages when reading or writing to the store.\n+   * @param changelogCollector MessageCollector the storage engine uses to persist changes.\n+   * @param registry MetricsRegistry to which to publish storage-engine specific metrics.\n+   * @param changelogSSP Samza system stream partition from which to receive the changelog.\n+   * @param containerContext Information about the container in which the task is executing.\n+   **/\n+  public StorageEngine getStorageEngine(String storeName,\n+      File storeDir,\n+      Serde<K> keySerde,\n+      Serde<V> msgSerde,\n+      MessageCollector changelogCollector,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changelogSSP,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode) {\n+    Config storageConfigSubset = jobContext.getConfig().subset(\"stores.\" + storeName + \".\", true);\n+    StorageConfig storageConfig = new StorageConfig(jobContext.getConfig());\n+    Optional<String> storeFactory = storageConfig.getStorageFactoryClassName(storeName);\n+    StoreProperties.StorePropertiesBuilder storePropertiesBuilder = new StoreProperties.StorePropertiesBuilder();\n+    if (!storeFactory.isPresent() || StringUtils.isBlank(storeFactory.get())) {\n+      throw new SamzaException(\"Store factory not defined. Cannot proceed with KV store creation!\");\n+    }\n+    if (!storeFactory.get().equals(INMEMORY_KV_STORAGE_ENGINE_FACTORY)) {\n+      storePropertiesBuilder.setPersistedToDisk(true);\n+    }\n+    int batchSize = storageConfigSubset.getInt(\"write.batch.size\", 500);\n+    int cacheSize = storageConfigSubset.getInt(\"object.cache.size\", Math.max(batchSize, 1000));\n+    if (cacheSize > 0 && cacheSize < batchSize) {\n+      throw new SamzaException(\n+          \"A store's cache.size cannot be less than batch.size as batched values reside in cache.\");\n+    }\n+    if (keySerde == null) {\n+      throw new SamzaException(\"Must define a key serde when using key value storage.\");\n+    }\n+    if (msgSerde == null) {\n+      throw new SamzaException(\"Must define a message serde when using key value storage.\");\n+    }\n+\n+    KeyValueStore<byte[], byte[]> rawStore =\n+        getKVStore(storeName, storeDir, registry, changelogSSP, jobContext, containerContext, storeMode);\n+    KeyValueStore<byte[], byte[]> maybeLoggedStore = buildMaybeLoggedStore(changelogSSP,\n+        storeName, registry, storePropertiesBuilder, rawStore, changelogCollector);\n+    // this also applies serialization and caching layers\n+    KeyValueStore<K, V> toBeAccessLoggedStore = applyLargeMessageHandling(storeName, registry,\n+        maybeLoggedStore, storageConfig, cacheSize, batchSize, keySerde, msgSerde);\n+    KeyValueStore<K, V> maybeAccessLoggedStore =\n+        buildMaybeAccessLoggedStore(storeName, toBeAccessLoggedStore, changelogCollector, changelogSSP, storageConfig,\n+            keySerde);\n+    KeyValueStore<K, V> nullSafeStore = new NullSafeKeyValueStore<>(maybeAccessLoggedStore);\n+\n+    KeyValueStorageEngineMetrics keyValueStorageEngineMetrics = new KeyValueStorageEngineMetrics(storeName, registry);\n+    HighResolutionClock clock = buildClock(jobContext.getConfig());\n+    return new KeyValueStorageEngine<>(storeName, storeDir, storePropertiesBuilder.build(), nullSafeStore, rawStore,\n+        changelogSSP, changelogCollector, keyValueStorageEngineMetrics, batchSize,\n+        ScalaJavaUtil.toScalaFunction(clock::nanoTime));\n+  }\n+\n+  private static KeyValueStore<byte[], byte[]> buildMaybeLoggedStore(SystemStreamPartition changelogSSP,\n+      String storeName,\n+      MetricsRegistry registry,\n+      StoreProperties.StorePropertiesBuilder storePropertiesBuilder,\n+      KeyValueStore<byte[], byte[]> storeToWrap,\n+      MessageCollector changelogCollector) {\n+    if (changelogSSP == null) {\n+      return storeToWrap;\n+    } else {\n+      LoggedStoreMetrics loggedStoreMetrics = new LoggedStoreMetrics(storeName, registry);\n+      storePropertiesBuilder.setLoggedStore(true);\n+      return new LoggedStore<>(storeToWrap, changelogSSP, changelogCollector, loggedStoreMetrics);\n+    }\n+  }\n+\n+  private static <T, U> KeyValueStore<T, U> applyLargeMessageHandling(String storeName,\n+      MetricsRegistry registry,\n+      KeyValueStore<byte[], byte[]> storeToWrap,\n+      StorageConfig storageConfig,\n+      int cacheSize,\n+      int batchSize,\n+      Serde<T> keySerde,\n+      Serde<U> msgSerde) {\n+    int maxMessageSize = storageConfig.getChangelogMaxMsgSizeBytes(storeName);\n+    if (storageConfig.getDisallowLargeMessages(storeName)) {\n+      /*\n+       * If large messages are disallowed in config, then this creates a LargeMessageSafeKeyValueStore that throws a\n+       * RecordTooLargeException when a large message is encountered.\n+       */\n+      KeyValueStore<byte[], byte[]> maybeCachedStore =\n+          buildMaybeCachedStore(storeName, registry, storeToWrap, cacheSize, batchSize);\n+      LargeMessageSafeStore largeMessageSafeKeyValueStore =\n+          new LargeMessageSafeStore(maybeCachedStore, storeName, false, maxMessageSize);\n+      return buildSerializedStore(storeName, registry, largeMessageSafeKeyValueStore, keySerde, msgSerde);\n+    } else {\n+      KeyValueStore<byte[], byte[]> toBeSerializedStore;\n+      if (storageConfig.getDropLargeMessages(storeName)) {\n+        toBeSerializedStore = new LargeMessageSafeStore(storeToWrap, storeName, true, maxMessageSize);\n+      } else {\n+        toBeSerializedStore = storeToWrap;\n+      }\n+      KeyValueStore<T, U> serializedStore =\n+          buildSerializedStore(storeName, registry, toBeSerializedStore, keySerde, msgSerde);\n+      return buildMaybeCachedStore(storeName, registry, serializedStore, cacheSize, batchSize);", "originalCommit": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5Njc0OA==", "url": "https://github.com/apache/samza/pull/1352#discussion_r430596748", "bodyText": "+1", "author": "rmatharu", "createdAt": "2020-05-26T17:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkxOTEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxODEzOQ==", "url": "https://github.com/apache/samza/pull/1352#discussion_r431518139", "bodyText": "Unfortunately, there is a difference. The description of #1008 has some more context, although it's not fully consistent with the code since it mentions a non-existent \"expect.large.message\" config.\nI think the idea is that it may be undesirable to cache a large message when it won't be able to be written to the changelog. In order to prevent that, the serialization needs to go before the cached store. However, if it's ok to cache the large message, then that is more performant since the deserialized object can be stored in the cache. So multiple options were provided, but that required these multiple flows.", "author": "cameronlee314", "createdAt": "2020-05-28T00:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkxOTEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyMzMyMA==", "url": "https://github.com/apache/samza/pull/1352#discussion_r431523320", "bodyText": "I added a couple of javadocs to help clarify.", "author": "cameronlee314", "createdAt": "2020-05-28T00:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkxOTEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTg2NQ==", "url": "https://github.com/apache/samza/pull/1352#discussion_r416929865", "bodyText": "Is there a need to add a unit test if keySerde or msgSerde is missing?", "author": "PanTheMan", "createdAt": "2020-04-28T21:20:12Z", "path": "samza-kv/src/test/java/org/apache/samza/storage/kv/TestBaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Map;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.samza.Partition;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MapConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+\n+public class TestBaseKeyValueStorageEngineFactory {\n+  private static final String STORE_NAME = \"myStore\";\n+  private static final StorageEngineFactory.StoreMode STORE_MODE = StorageEngineFactory.StoreMode.ReadWrite;\n+  private static final SystemStreamPartition CHANGELOG_SSP =\n+      new SystemStreamPartition(\"system\", \"stream\", new Partition(0));\n+  private static final Map<String, String> BASE_CONFIG =\n+      ImmutableMap.of(String.format(StorageConfig.FACTORY, STORE_NAME),\n+          MockKeyValueStorageEngineFactory.class.getName());\n+  private static final Map<String, String> DISABLE_CACHE =\n+      ImmutableMap.of(String.format(\"stores.%s.object.cache.size\", STORE_NAME), \"0\");\n+  private static final Map<String, String> DISALLOW_LARGE_MESSAGES =\n+      ImmutableMap.of(String.format(StorageConfig.DISALLOW_LARGE_MESSAGES, STORE_NAME), \"true\");\n+  private static final Map<String, String> DROP_LARGE_MESSAGES =\n+      ImmutableMap.of(String.format(StorageConfig.DROP_LARGE_MESSAGES, STORE_NAME), \"true\");\n+  private static final Map<String, String> ACCESS_LOG_ENABLED =\n+      ImmutableMap.of(String.format(\"stores.%s.accesslog.enabled\", STORE_NAME), \"true\");\n+\n+  @Mock\n+  private File storeDir;\n+  @Mock\n+  private Serde<String> keySerde;\n+  @Mock\n+  private Serde<String> msgSerde;\n+  @Mock\n+  private MessageCollector changelogCollector;\n+  @Mock\n+  private MetricsRegistry metricsRegistry;\n+  @Mock\n+  private JobContext jobContext;\n+  @Mock\n+  private ContainerContext containerContext;\n+  @Mock\n+  private KeyValueStore<byte[], byte[]> rawKeyValueStore;\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    // some metrics objects need this for histogram metric instantiation\n+    when(this.metricsRegistry.newGauge(any(), any())).thenReturn(mock(Gauge.class));\n+  }\n+\n+  @Test(expected = SamzaException.class)\n+  public void testMissingStoreFactory() {\n+    Config config = new MapConfig();\n+    callGetStorageEngine(config, null);\n+  }\n+\n+  @Test(expected = SamzaException.class)\n+  public void testInvalidCacheSize() {\n+    Config config = new MapConfig(BASE_CONFIG,\n+        ImmutableMap.of(String.format(\"stores.%s.write.cache.batch\", STORE_NAME), \"100\",\n+            String.format(\"stores.%s.object.cache.size\", STORE_NAME), \"50\"));\n+    callGetStorageEngine(config, null);\n+  }\n+\n+  @Test\n+  public void testInMemoryKeyValueStore() {\n+    Config config = new MapConfig(DISABLE_CACHE, ImmutableMap.of(String.format(StorageConfig.FACTORY, STORE_NAME),\n+        \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\"));\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), false, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    // config has the in-memory key-value factory, but still calling the test factory, so store will be the test store\n+    assertEquals(this.rawKeyValueStore, serializedKeyValueStore.getStore());\n+  }\n+\n+  @Test\n+  public void testRawStoreOnly() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    assertEquals(this.rawKeyValueStore, serializedKeyValueStore.getStore());\n+  }\n+\n+  @Test\n+  public void testWithLoggedStore() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE);\n+    StorageEngine storageEngine = callGetStorageEngine(config, CHANGELOG_SSP);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, true);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    LoggedStore<?, ?> loggedStore = assertAndCast(serializedKeyValueStore.getStore(), LoggedStore.class);\n+    // noinspection AssertEqualsBetweenInconvertibleTypes\n+    assertEquals(this.rawKeyValueStore, loggedStore.getStore());\n+  }\n+\n+  @Test\n+  public void testWithLoggedStoreWithCache() {\n+    Config config = new MapConfig(BASE_CONFIG);\n+    StorageEngine storageEngine = callGetStorageEngine(config, CHANGELOG_SSP);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, true);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    CachedStore<?, ?> cachedStore = assertAndCast(nullSafeKeyValueStore.getStore(), CachedStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(cachedStore.getStore(), SerializedKeyValueStore.class);\n+    LoggedStore<?, ?> loggedStore = assertAndCast(serializedKeyValueStore.getStore(), LoggedStore.class);\n+    // noinspection AssertEqualsBetweenInconvertibleTypes\n+    assertEquals(this.rawKeyValueStore, loggedStore.getStore());\n+  }\n+\n+  @Test\n+  public void testDisallowLargeMessages() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE, DISALLOW_LARGE_MESSAGES);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    LargeMessageSafeStore largeMessageSafeStore =\n+        assertAndCast(serializedKeyValueStore.getStore(), LargeMessageSafeStore.class);\n+    assertEquals(this.rawKeyValueStore, largeMessageSafeStore.getStore());\n+  }\n+\n+  @Test\n+  public void testDisallowLargeMessagesWithCache() {\n+    Config config = new MapConfig(BASE_CONFIG, DISALLOW_LARGE_MESSAGES);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    LargeMessageSafeStore largeMessageSafeStore =\n+        assertAndCast(serializedKeyValueStore.getStore(), LargeMessageSafeStore.class);\n+    CachedStore<?, ?> cachedStore = assertAndCast(largeMessageSafeStore.getStore(), CachedStore.class);\n+    // noinspection AssertEqualsBetweenInconvertibleTypes\n+    assertEquals(this.rawKeyValueStore, cachedStore.getStore());\n+  }\n+\n+  @Test\n+  public void testDropLargeMessages() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE, DROP_LARGE_MESSAGES);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    LargeMessageSafeStore largeMessageSafeStore =\n+        assertAndCast(serializedKeyValueStore.getStore(), LargeMessageSafeStore.class);\n+    assertEquals(this.rawKeyValueStore, largeMessageSafeStore.getStore());\n+  }\n+\n+  @Test\n+  public void testDropLargeMessagesWithCache() {\n+    Config config = new MapConfig(BASE_CONFIG, DROP_LARGE_MESSAGES);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    CachedStore<?, ?> cachedStore = assertAndCast(nullSafeKeyValueStore.getStore(), CachedStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(cachedStore.getStore(), SerializedKeyValueStore.class);\n+    LargeMessageSafeStore largeMessageSafeStore =\n+        assertAndCast(serializedKeyValueStore.getStore(), LargeMessageSafeStore.class);\n+    assertEquals(this.rawKeyValueStore, largeMessageSafeStore.getStore());\n+  }\n+\n+  @Test\n+  public void testAccessLogStore() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE, ACCESS_LOG_ENABLED);\n+    // AccessLoggedStore requires a changelog SSP\n+    StorageEngine storageEngine = callGetStorageEngine(config, CHANGELOG_SSP);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, true);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    AccessLoggedStore<?, ?> accessLoggedStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), AccessLoggedStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(accessLoggedStore.getStore(), SerializedKeyValueStore.class);\n+    LoggedStore<?, ?> loggedStore = assertAndCast(serializedKeyValueStore.getStore(), LoggedStore.class);\n+    // noinspection AssertEqualsBetweenInconvertibleTypes\n+    assertEquals(this.rawKeyValueStore, loggedStore.getStore());\n+  }\n+\n+  private static <T extends KeyValueStore<?, ?>> T assertAndCast(KeyValueStore<?, ?> keyValueStore, Class<T> clazz) {\n+    assertTrue(\"Expected type \" + clazz.getName(), clazz.isInstance(keyValueStore));\n+    return clazz.cast(keyValueStore);\n+  }\n+\n+  private KeyValueStorageEngine<?, ?> baseStorageEngineValidation(StorageEngine storageEngine) {\n+    assertTrue(storageEngine instanceof KeyValueStorageEngine);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = (KeyValueStorageEngine<?, ?>) storageEngine;\n+    assertEquals(this.rawKeyValueStore, keyValueStorageEngine.getRawStore());\n+    return keyValueStorageEngine;\n+  }\n+\n+  private static void assertStoreProperties(StoreProperties storeProperties, boolean expectedPersistedToDisk,\n+      boolean expectedLoggedStore) {\n+    assertEquals(expectedPersistedToDisk, storeProperties.isPersistedToDisk());\n+    assertEquals(expectedLoggedStore, storeProperties.isLoggedStore());\n+  }\n+\n+  /**\n+   * @param changelogSSP if non-null, then enables logged store\n+   */\n+  private StorageEngine callGetStorageEngine(Config config, SystemStreamPartition changelogSSP) {\n+    when(this.jobContext.getConfig()).thenReturn(config);\n+    return new MockKeyValueStorageEngineFactory(this.rawKeyValueStore).getStorageEngine(STORE_NAME, this.storeDir,\n+        this.keySerde, this.msgSerde, this.changelogCollector, this.metricsRegistry, changelogSSP, this.jobContext,", "originalCommit": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1MTIzNg==", "url": "https://github.com/apache/samza/pull/1352#discussion_r423551236", "bodyText": "What is this needed for? Can we remove this log line?", "author": "PawasChhokra", "createdAt": "2020-05-12T08:22:41Z", "path": "samza-kv/src/test/java/org/apache/samza/storage/kv/TestBaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Map;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.samza.Partition;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MapConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+\n+public class TestBaseKeyValueStorageEngineFactory {\n+  private static final String STORE_NAME = \"myStore\";\n+  private static final StorageEngineFactory.StoreMode STORE_MODE = StorageEngineFactory.StoreMode.ReadWrite;\n+  private static final SystemStreamPartition CHANGELOG_SSP =\n+      new SystemStreamPartition(\"system\", \"stream\", new Partition(0));\n+  private static final Map<String, String> BASE_CONFIG =\n+      ImmutableMap.of(String.format(StorageConfig.FACTORY, STORE_NAME),\n+          MockKeyValueStorageEngineFactory.class.getName());\n+  private static final Map<String, String> DISABLE_CACHE =\n+      ImmutableMap.of(String.format(\"stores.%s.object.cache.size\", STORE_NAME), \"0\");\n+  private static final Map<String, String> DISALLOW_LARGE_MESSAGES =\n+      ImmutableMap.of(String.format(StorageConfig.DISALLOW_LARGE_MESSAGES, STORE_NAME), \"true\");\n+  private static final Map<String, String> DROP_LARGE_MESSAGES =\n+      ImmutableMap.of(String.format(StorageConfig.DROP_LARGE_MESSAGES, STORE_NAME), \"true\");\n+  private static final Map<String, String> ACCESS_LOG_ENABLED =\n+      ImmutableMap.of(String.format(\"stores.%s.accesslog.enabled\", STORE_NAME), \"true\");\n+\n+  @Mock\n+  private File storeDir;\n+  @Mock\n+  private Serde<String> keySerde;\n+  @Mock\n+  private Serde<String> msgSerde;\n+  @Mock\n+  private MessageCollector changelogCollector;\n+  @Mock\n+  private MetricsRegistry metricsRegistry;\n+  @Mock\n+  private JobContext jobContext;\n+  @Mock\n+  private ContainerContext containerContext;\n+  @Mock\n+  private KeyValueStore<byte[], byte[]> rawKeyValueStore;\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    // some metrics objects need this for histogram metric instantiation\n+    when(this.metricsRegistry.newGauge(any(), any())).thenReturn(mock(Gauge.class));\n+  }\n+\n+  @Test(expected = SamzaException.class)\n+  public void testMissingStoreFactory() {\n+    Config config = new MapConfig();\n+    callGetStorageEngine(config, null);\n+  }\n+\n+  @Test(expected = SamzaException.class)\n+  public void testInvalidCacheSize() {\n+    Config config = new MapConfig(BASE_CONFIG,\n+        ImmutableMap.of(String.format(\"stores.%s.write.cache.batch\", STORE_NAME), \"100\",\n+            String.format(\"stores.%s.object.cache.size\", STORE_NAME), \"50\"));\n+    callGetStorageEngine(config, null);\n+  }\n+\n+  @Test\n+  public void testInMemoryKeyValueStore() {\n+    Config config = new MapConfig(DISABLE_CACHE, ImmutableMap.of(String.format(StorageConfig.FACTORY, STORE_NAME),\n+        \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\"));\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), false, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    // config has the in-memory key-value factory, but still calling the test factory, so store will be the test store\n+    assertEquals(this.rawKeyValueStore, serializedKeyValueStore.getStore());\n+  }\n+\n+  @Test\n+  public void testRawStoreOnly() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    assertEquals(this.rawKeyValueStore, serializedKeyValueStore.getStore());\n+  }\n+\n+  @Test\n+  public void testWithLoggedStore() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE);\n+    StorageEngine storageEngine = callGetStorageEngine(config, CHANGELOG_SSP);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, true);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    LoggedStore<?, ?> loggedStore = assertAndCast(serializedKeyValueStore.getStore(), LoggedStore.class);\n+    // noinspection AssertEqualsBetweenInconvertibleTypes", "originalCommit": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyMTUxNg==", "url": "https://github.com/apache/samza/pull/1352#discussion_r431521516", "bodyText": "This is a comment for suppressing the warning on the next line. It is because the type of the first object is KeyValueStore<byte[], byte[]> and the type of the second is KeyValueStore<?, ?>. The type generics don't matter in these tests since we are just doing top-level type checks and object equality.", "author": "cameronlee314", "createdAt": "2020-05-28T00:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1MTIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1Mjc5MA==", "url": "https://github.com/apache/samza/pull/1352#discussion_r423552790", "bodyText": "Can we change the name of this function to something like testWithLoggedAndCachedStore()?", "author": "PawasChhokra", "createdAt": "2020-05-12T08:25:07Z", "path": "samza-kv/src/test/java/org/apache/samza/storage/kv/TestBaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Map;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.samza.Partition;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MapConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.Gauge;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+\n+public class TestBaseKeyValueStorageEngineFactory {\n+  private static final String STORE_NAME = \"myStore\";\n+  private static final StorageEngineFactory.StoreMode STORE_MODE = StorageEngineFactory.StoreMode.ReadWrite;\n+  private static final SystemStreamPartition CHANGELOG_SSP =\n+      new SystemStreamPartition(\"system\", \"stream\", new Partition(0));\n+  private static final Map<String, String> BASE_CONFIG =\n+      ImmutableMap.of(String.format(StorageConfig.FACTORY, STORE_NAME),\n+          MockKeyValueStorageEngineFactory.class.getName());\n+  private static final Map<String, String> DISABLE_CACHE =\n+      ImmutableMap.of(String.format(\"stores.%s.object.cache.size\", STORE_NAME), \"0\");\n+  private static final Map<String, String> DISALLOW_LARGE_MESSAGES =\n+      ImmutableMap.of(String.format(StorageConfig.DISALLOW_LARGE_MESSAGES, STORE_NAME), \"true\");\n+  private static final Map<String, String> DROP_LARGE_MESSAGES =\n+      ImmutableMap.of(String.format(StorageConfig.DROP_LARGE_MESSAGES, STORE_NAME), \"true\");\n+  private static final Map<String, String> ACCESS_LOG_ENABLED =\n+      ImmutableMap.of(String.format(\"stores.%s.accesslog.enabled\", STORE_NAME), \"true\");\n+\n+  @Mock\n+  private File storeDir;\n+  @Mock\n+  private Serde<String> keySerde;\n+  @Mock\n+  private Serde<String> msgSerde;\n+  @Mock\n+  private MessageCollector changelogCollector;\n+  @Mock\n+  private MetricsRegistry metricsRegistry;\n+  @Mock\n+  private JobContext jobContext;\n+  @Mock\n+  private ContainerContext containerContext;\n+  @Mock\n+  private KeyValueStore<byte[], byte[]> rawKeyValueStore;\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    // some metrics objects need this for histogram metric instantiation\n+    when(this.metricsRegistry.newGauge(any(), any())).thenReturn(mock(Gauge.class));\n+  }\n+\n+  @Test(expected = SamzaException.class)\n+  public void testMissingStoreFactory() {\n+    Config config = new MapConfig();\n+    callGetStorageEngine(config, null);\n+  }\n+\n+  @Test(expected = SamzaException.class)\n+  public void testInvalidCacheSize() {\n+    Config config = new MapConfig(BASE_CONFIG,\n+        ImmutableMap.of(String.format(\"stores.%s.write.cache.batch\", STORE_NAME), \"100\",\n+            String.format(\"stores.%s.object.cache.size\", STORE_NAME), \"50\"));\n+    callGetStorageEngine(config, null);\n+  }\n+\n+  @Test\n+  public void testInMemoryKeyValueStore() {\n+    Config config = new MapConfig(DISABLE_CACHE, ImmutableMap.of(String.format(StorageConfig.FACTORY, STORE_NAME),\n+        \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\"));\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), false, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    // config has the in-memory key-value factory, but still calling the test factory, so store will be the test store\n+    assertEquals(this.rawKeyValueStore, serializedKeyValueStore.getStore());\n+  }\n+\n+  @Test\n+  public void testRawStoreOnly() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE);\n+    StorageEngine storageEngine = callGetStorageEngine(config, null);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, false);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    assertEquals(this.rawKeyValueStore, serializedKeyValueStore.getStore());\n+  }\n+\n+  @Test\n+  public void testWithLoggedStore() {\n+    Config config = new MapConfig(BASE_CONFIG, DISABLE_CACHE);\n+    StorageEngine storageEngine = callGetStorageEngine(config, CHANGELOG_SSP);\n+    KeyValueStorageEngine<?, ?> keyValueStorageEngine = baseStorageEngineValidation(storageEngine);\n+    assertStoreProperties(keyValueStorageEngine.getStoreProperties(), true, true);\n+    NullSafeKeyValueStore<?, ?> nullSafeKeyValueStore =\n+        assertAndCast(keyValueStorageEngine.getWrapperStore(), NullSafeKeyValueStore.class);\n+    SerializedKeyValueStore<?, ?> serializedKeyValueStore =\n+        assertAndCast(nullSafeKeyValueStore.getStore(), SerializedKeyValueStore.class);\n+    LoggedStore<?, ?> loggedStore = assertAndCast(serializedKeyValueStore.getStore(), LoggedStore.class);\n+    // noinspection AssertEqualsBetweenInconvertibleTypes\n+    assertEquals(this.rawKeyValueStore, loggedStore.getStore());\n+  }\n+\n+  @Test\n+  public void testWithLoggedStoreWithCache() {", "originalCommit": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5MzA4OA==", "url": "https://github.com/apache/samza/pull/1352#discussion_r430593088", "bodyText": "Would it help to add the storeName in the error-message, so the user known which store he has not defined the factory for?", "author": "rmatharu", "createdAt": "2020-05-26T17:43:38Z", "path": "samza-kv/src/main/java/org/apache/samza/storage/kv/BaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MetricsConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.apache.samza.util.HighResolutionClock;\n+import org.apache.samza.util.ScalaJavaUtil;\n+\n+\n+/**\n+ * This encapsulates all the steps needed to create a key value storage engine.\n+ * This is meant to be extended by the specific key value store factory implementations which will in turn override the\n+ * getKVStore method to return a raw key-value store.\n+ */\n+public abstract class BaseKeyValueStorageEngineFactory<K, V> implements StorageEngineFactory<K, V> {\n+  private static final String INMEMORY_KV_STORAGE_ENGINE_FACTORY =\n+      \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\";\n+\n+  /**\n+   * Implement this to return a KeyValueStore instance for the given store name, which will be used as the underlying\n+   * raw store.\n+   *\n+   * @param storeName Name of the store\n+   * @param storeDir The directory of the store\n+   * @param registry MetricsRegistry to which to publish store specific metrics.\n+   * @param changeLogSystemStreamPartition Samza stream partition from which to receive the changelog.\n+   * @param jobContext Information about the job in which the task is executing.\n+   * @param containerContext Information about the container in which the task is executing.\n+   * @return A raw KeyValueStore instance\n+   */\n+  protected abstract KeyValueStore<byte[], byte[]> getKVStore(String storeName,\n+      File storeDir,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changeLogSystemStreamPartition,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode);\n+\n+  /**\n+   * Constructs a key-value StorageEngine and returns it to the caller\n+   *\n+   * @param storeName The name of the storage engine.\n+   * @param storeDir The directory of the storage engine.\n+   * @param keySerde The serializer to use for serializing keys when reading or writing to the store.\n+   * @param msgSerde The serializer to use for serializing messages when reading or writing to the store.\n+   * @param changelogCollector MessageCollector the storage engine uses to persist changes.\n+   * @param registry MetricsRegistry to which to publish storage-engine specific metrics.\n+   * @param changelogSSP Samza system stream partition from which to receive the changelog.\n+   * @param containerContext Information about the container in which the task is executing.\n+   **/\n+  public StorageEngine getStorageEngine(String storeName,\n+      File storeDir,\n+      Serde<K> keySerde,\n+      Serde<V> msgSerde,\n+      MessageCollector changelogCollector,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changelogSSP,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode) {\n+    Config storageConfigSubset = jobContext.getConfig().subset(\"stores.\" + storeName + \".\", true);\n+    StorageConfig storageConfig = new StorageConfig(jobContext.getConfig());\n+    Optional<String> storeFactory = storageConfig.getStorageFactoryClassName(storeName);\n+    StoreProperties.StorePropertiesBuilder storePropertiesBuilder = new StoreProperties.StorePropertiesBuilder();\n+    if (!storeFactory.isPresent() || StringUtils.isBlank(storeFactory.get())) {\n+      throw new SamzaException(\"Store factory not defined. Cannot proceed with KV store creation!\");", "originalCommit": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5Mzc3NQ==", "url": "https://github.com/apache/samza/pull/1352#discussion_r430593775", "bodyText": "Should we have variables for DEFAULT_BATCH_SIZE and DEFAULT_CACHE_SIZE?", "author": "rmatharu", "createdAt": "2020-05-26T17:44:54Z", "path": "samza-kv/src/main/java/org/apache/samza/storage/kv/BaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MetricsConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.apache.samza.util.HighResolutionClock;\n+import org.apache.samza.util.ScalaJavaUtil;\n+\n+\n+/**\n+ * This encapsulates all the steps needed to create a key value storage engine.\n+ * This is meant to be extended by the specific key value store factory implementations which will in turn override the\n+ * getKVStore method to return a raw key-value store.\n+ */\n+public abstract class BaseKeyValueStorageEngineFactory<K, V> implements StorageEngineFactory<K, V> {\n+  private static final String INMEMORY_KV_STORAGE_ENGINE_FACTORY =\n+      \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\";\n+\n+  /**\n+   * Implement this to return a KeyValueStore instance for the given store name, which will be used as the underlying\n+   * raw store.\n+   *\n+   * @param storeName Name of the store\n+   * @param storeDir The directory of the store\n+   * @param registry MetricsRegistry to which to publish store specific metrics.\n+   * @param changeLogSystemStreamPartition Samza stream partition from which to receive the changelog.\n+   * @param jobContext Information about the job in which the task is executing.\n+   * @param containerContext Information about the container in which the task is executing.\n+   * @return A raw KeyValueStore instance\n+   */\n+  protected abstract KeyValueStore<byte[], byte[]> getKVStore(String storeName,\n+      File storeDir,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changeLogSystemStreamPartition,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode);\n+\n+  /**\n+   * Constructs a key-value StorageEngine and returns it to the caller\n+   *\n+   * @param storeName The name of the storage engine.\n+   * @param storeDir The directory of the storage engine.\n+   * @param keySerde The serializer to use for serializing keys when reading or writing to the store.\n+   * @param msgSerde The serializer to use for serializing messages when reading or writing to the store.\n+   * @param changelogCollector MessageCollector the storage engine uses to persist changes.\n+   * @param registry MetricsRegistry to which to publish storage-engine specific metrics.\n+   * @param changelogSSP Samza system stream partition from which to receive the changelog.\n+   * @param containerContext Information about the container in which the task is executing.\n+   **/\n+  public StorageEngine getStorageEngine(String storeName,\n+      File storeDir,\n+      Serde<K> keySerde,\n+      Serde<V> msgSerde,\n+      MessageCollector changelogCollector,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changelogSSP,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode) {\n+    Config storageConfigSubset = jobContext.getConfig().subset(\"stores.\" + storeName + \".\", true);\n+    StorageConfig storageConfig = new StorageConfig(jobContext.getConfig());\n+    Optional<String> storeFactory = storageConfig.getStorageFactoryClassName(storeName);\n+    StoreProperties.StorePropertiesBuilder storePropertiesBuilder = new StoreProperties.StorePropertiesBuilder();\n+    if (!storeFactory.isPresent() || StringUtils.isBlank(storeFactory.get())) {\n+      throw new SamzaException(\"Store factory not defined. Cannot proceed with KV store creation!\");\n+    }\n+    if (!storeFactory.get().equals(INMEMORY_KV_STORAGE_ENGINE_FACTORY)) {\n+      storePropertiesBuilder.setPersistedToDisk(true);\n+    }\n+    int batchSize = storageConfigSubset.getInt(\"write.batch.size\", 500);\n+    int cacheSize = storageConfigSubset.getInt(\"object.cache.size\", Math.max(batchSize, 1000));", "originalCommit": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5NDAwOA==", "url": "https://github.com/apache/samza/pull/1352#discussion_r430594008", "bodyText": "Same as above, might help to have storeName in the error message", "author": "rmatharu", "createdAt": "2020-05-26T17:45:12Z", "path": "samza-kv/src/main/java/org/apache/samza/storage/kv/BaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MetricsConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.apache.samza.util.HighResolutionClock;\n+import org.apache.samza.util.ScalaJavaUtil;\n+\n+\n+/**\n+ * This encapsulates all the steps needed to create a key value storage engine.\n+ * This is meant to be extended by the specific key value store factory implementations which will in turn override the\n+ * getKVStore method to return a raw key-value store.\n+ */\n+public abstract class BaseKeyValueStorageEngineFactory<K, V> implements StorageEngineFactory<K, V> {\n+  private static final String INMEMORY_KV_STORAGE_ENGINE_FACTORY =\n+      \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\";\n+\n+  /**\n+   * Implement this to return a KeyValueStore instance for the given store name, which will be used as the underlying\n+   * raw store.\n+   *\n+   * @param storeName Name of the store\n+   * @param storeDir The directory of the store\n+   * @param registry MetricsRegistry to which to publish store specific metrics.\n+   * @param changeLogSystemStreamPartition Samza stream partition from which to receive the changelog.\n+   * @param jobContext Information about the job in which the task is executing.\n+   * @param containerContext Information about the container in which the task is executing.\n+   * @return A raw KeyValueStore instance\n+   */\n+  protected abstract KeyValueStore<byte[], byte[]> getKVStore(String storeName,\n+      File storeDir,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changeLogSystemStreamPartition,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode);\n+\n+  /**\n+   * Constructs a key-value StorageEngine and returns it to the caller\n+   *\n+   * @param storeName The name of the storage engine.\n+   * @param storeDir The directory of the storage engine.\n+   * @param keySerde The serializer to use for serializing keys when reading or writing to the store.\n+   * @param msgSerde The serializer to use for serializing messages when reading or writing to the store.\n+   * @param changelogCollector MessageCollector the storage engine uses to persist changes.\n+   * @param registry MetricsRegistry to which to publish storage-engine specific metrics.\n+   * @param changelogSSP Samza system stream partition from which to receive the changelog.\n+   * @param containerContext Information about the container in which the task is executing.\n+   **/\n+  public StorageEngine getStorageEngine(String storeName,\n+      File storeDir,\n+      Serde<K> keySerde,\n+      Serde<V> msgSerde,\n+      MessageCollector changelogCollector,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changelogSSP,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode) {\n+    Config storageConfigSubset = jobContext.getConfig().subset(\"stores.\" + storeName + \".\", true);\n+    StorageConfig storageConfig = new StorageConfig(jobContext.getConfig());\n+    Optional<String> storeFactory = storageConfig.getStorageFactoryClassName(storeName);\n+    StoreProperties.StorePropertiesBuilder storePropertiesBuilder = new StoreProperties.StorePropertiesBuilder();\n+    if (!storeFactory.isPresent() || StringUtils.isBlank(storeFactory.get())) {\n+      throw new SamzaException(\"Store factory not defined. Cannot proceed with KV store creation!\");\n+    }\n+    if (!storeFactory.get().equals(INMEMORY_KV_STORAGE_ENGINE_FACTORY)) {\n+      storePropertiesBuilder.setPersistedToDisk(true);\n+    }\n+    int batchSize = storageConfigSubset.getInt(\"write.batch.size\", 500);\n+    int cacheSize = storageConfigSubset.getInt(\"object.cache.size\", Math.max(batchSize, 1000));\n+    if (cacheSize > 0 && cacheSize < batchSize) {\n+      throw new SamzaException(\n+          \"A store's cache.size cannot be less than batch.size as batched values reside in cache.\");\n+    }\n+    if (keySerde == null) {\n+      throw new SamzaException(\"Must define a key serde when using key value storage.\");\n+    }\n+    if (msgSerde == null) {\n+      throw new SamzaException(\"Must define a message serde when using key value storage.\");", "originalCommit": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5NDcxNQ==", "url": "https://github.com/apache/samza/pull/1352#discussion_r430594715", "bodyText": "/**\nWraps given store into a LoggedStore if a changeLog for the store is defined, otherwise skips wrapping.\n*/", "author": "rmatharu", "createdAt": "2020-05-26T17:46:24Z", "path": "samza-kv/src/main/java/org/apache/samza/storage/kv/BaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MetricsConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.apache.samza.util.HighResolutionClock;\n+import org.apache.samza.util.ScalaJavaUtil;\n+\n+\n+/**\n+ * This encapsulates all the steps needed to create a key value storage engine.\n+ * This is meant to be extended by the specific key value store factory implementations which will in turn override the\n+ * getKVStore method to return a raw key-value store.\n+ */\n+public abstract class BaseKeyValueStorageEngineFactory<K, V> implements StorageEngineFactory<K, V> {\n+  private static final String INMEMORY_KV_STORAGE_ENGINE_FACTORY =\n+      \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\";\n+\n+  /**\n+   * Implement this to return a KeyValueStore instance for the given store name, which will be used as the underlying\n+   * raw store.\n+   *\n+   * @param storeName Name of the store\n+   * @param storeDir The directory of the store\n+   * @param registry MetricsRegistry to which to publish store specific metrics.\n+   * @param changeLogSystemStreamPartition Samza stream partition from which to receive the changelog.\n+   * @param jobContext Information about the job in which the task is executing.\n+   * @param containerContext Information about the container in which the task is executing.\n+   * @return A raw KeyValueStore instance\n+   */\n+  protected abstract KeyValueStore<byte[], byte[]> getKVStore(String storeName,\n+      File storeDir,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changeLogSystemStreamPartition,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode);\n+\n+  /**\n+   * Constructs a key-value StorageEngine and returns it to the caller\n+   *\n+   * @param storeName The name of the storage engine.\n+   * @param storeDir The directory of the storage engine.\n+   * @param keySerde The serializer to use for serializing keys when reading or writing to the store.\n+   * @param msgSerde The serializer to use for serializing messages when reading or writing to the store.\n+   * @param changelogCollector MessageCollector the storage engine uses to persist changes.\n+   * @param registry MetricsRegistry to which to publish storage-engine specific metrics.\n+   * @param changelogSSP Samza system stream partition from which to receive the changelog.\n+   * @param containerContext Information about the container in which the task is executing.\n+   **/\n+  public StorageEngine getStorageEngine(String storeName,\n+      File storeDir,\n+      Serde<K> keySerde,\n+      Serde<V> msgSerde,\n+      MessageCollector changelogCollector,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changelogSSP,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode) {\n+    Config storageConfigSubset = jobContext.getConfig().subset(\"stores.\" + storeName + \".\", true);\n+    StorageConfig storageConfig = new StorageConfig(jobContext.getConfig());\n+    Optional<String> storeFactory = storageConfig.getStorageFactoryClassName(storeName);\n+    StoreProperties.StorePropertiesBuilder storePropertiesBuilder = new StoreProperties.StorePropertiesBuilder();\n+    if (!storeFactory.isPresent() || StringUtils.isBlank(storeFactory.get())) {\n+      throw new SamzaException(\"Store factory not defined. Cannot proceed with KV store creation!\");\n+    }\n+    if (!storeFactory.get().equals(INMEMORY_KV_STORAGE_ENGINE_FACTORY)) {\n+      storePropertiesBuilder.setPersistedToDisk(true);\n+    }\n+    int batchSize = storageConfigSubset.getInt(\"write.batch.size\", 500);\n+    int cacheSize = storageConfigSubset.getInt(\"object.cache.size\", Math.max(batchSize, 1000));\n+    if (cacheSize > 0 && cacheSize < batchSize) {\n+      throw new SamzaException(\n+          \"A store's cache.size cannot be less than batch.size as batched values reside in cache.\");\n+    }\n+    if (keySerde == null) {\n+      throw new SamzaException(\"Must define a key serde when using key value storage.\");\n+    }\n+    if (msgSerde == null) {\n+      throw new SamzaException(\"Must define a message serde when using key value storage.\");\n+    }\n+\n+    KeyValueStore<byte[], byte[]> rawStore =\n+        getKVStore(storeName, storeDir, registry, changelogSSP, jobContext, containerContext, storeMode);\n+    KeyValueStore<byte[], byte[]> maybeLoggedStore = buildMaybeLoggedStore(changelogSSP,\n+        storeName, registry, storePropertiesBuilder, rawStore, changelogCollector);\n+    // this also applies serialization and caching layers\n+    KeyValueStore<K, V> toBeAccessLoggedStore = applyLargeMessageHandling(storeName, registry,\n+        maybeLoggedStore, storageConfig, cacheSize, batchSize, keySerde, msgSerde);\n+    KeyValueStore<K, V> maybeAccessLoggedStore =\n+        buildMaybeAccessLoggedStore(storeName, toBeAccessLoggedStore, changelogCollector, changelogSSP, storageConfig,\n+            keySerde);\n+    KeyValueStore<K, V> nullSafeStore = new NullSafeKeyValueStore<>(maybeAccessLoggedStore);\n+\n+    KeyValueStorageEngineMetrics keyValueStorageEngineMetrics = new KeyValueStorageEngineMetrics(storeName, registry);\n+    HighResolutionClock clock = buildClock(jobContext.getConfig());\n+    return new KeyValueStorageEngine<>(storeName, storeDir, storePropertiesBuilder.build(), nullSafeStore, rawStore,\n+        changelogSSP, changelogCollector, keyValueStorageEngineMetrics, batchSize,\n+        ScalaJavaUtil.toScalaFunction(clock::nanoTime));\n+  }\n+\n+  private static KeyValueStore<byte[], byte[]> buildMaybeLoggedStore(SystemStreamPartition changelogSSP,", "originalCommit": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5NjMwOA==", "url": "https://github.com/apache/samza/pull/1352#discussion_r430596308", "bodyText": "nit: buildStoreWithLargeMessageHandling?", "author": "rmatharu", "createdAt": "2020-05-26T17:49:03Z", "path": "samza-kv/src/main/java/org/apache/samza/storage/kv/BaseKeyValueStorageEngineFactory.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.config.Config;\n+import org.apache.samza.config.MetricsConfig;\n+import org.apache.samza.config.StorageConfig;\n+import org.apache.samza.context.ContainerContext;\n+import org.apache.samza.context.JobContext;\n+import org.apache.samza.metrics.MetricsRegistry;\n+import org.apache.samza.serializers.Serde;\n+import org.apache.samza.storage.StorageEngine;\n+import org.apache.samza.storage.StorageEngineFactory;\n+import org.apache.samza.storage.StoreProperties;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.MessageCollector;\n+import org.apache.samza.util.HighResolutionClock;\n+import org.apache.samza.util.ScalaJavaUtil;\n+\n+\n+/**\n+ * This encapsulates all the steps needed to create a key value storage engine.\n+ * This is meant to be extended by the specific key value store factory implementations which will in turn override the\n+ * getKVStore method to return a raw key-value store.\n+ */\n+public abstract class BaseKeyValueStorageEngineFactory<K, V> implements StorageEngineFactory<K, V> {\n+  private static final String INMEMORY_KV_STORAGE_ENGINE_FACTORY =\n+      \"org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory\";\n+\n+  /**\n+   * Implement this to return a KeyValueStore instance for the given store name, which will be used as the underlying\n+   * raw store.\n+   *\n+   * @param storeName Name of the store\n+   * @param storeDir The directory of the store\n+   * @param registry MetricsRegistry to which to publish store specific metrics.\n+   * @param changeLogSystemStreamPartition Samza stream partition from which to receive the changelog.\n+   * @param jobContext Information about the job in which the task is executing.\n+   * @param containerContext Information about the container in which the task is executing.\n+   * @return A raw KeyValueStore instance\n+   */\n+  protected abstract KeyValueStore<byte[], byte[]> getKVStore(String storeName,\n+      File storeDir,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changeLogSystemStreamPartition,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode);\n+\n+  /**\n+   * Constructs a key-value StorageEngine and returns it to the caller\n+   *\n+   * @param storeName The name of the storage engine.\n+   * @param storeDir The directory of the storage engine.\n+   * @param keySerde The serializer to use for serializing keys when reading or writing to the store.\n+   * @param msgSerde The serializer to use for serializing messages when reading or writing to the store.\n+   * @param changelogCollector MessageCollector the storage engine uses to persist changes.\n+   * @param registry MetricsRegistry to which to publish storage-engine specific metrics.\n+   * @param changelogSSP Samza system stream partition from which to receive the changelog.\n+   * @param containerContext Information about the container in which the task is executing.\n+   **/\n+  public StorageEngine getStorageEngine(String storeName,\n+      File storeDir,\n+      Serde<K> keySerde,\n+      Serde<V> msgSerde,\n+      MessageCollector changelogCollector,\n+      MetricsRegistry registry,\n+      SystemStreamPartition changelogSSP,\n+      JobContext jobContext,\n+      ContainerContext containerContext,\n+      StoreMode storeMode) {\n+    Config storageConfigSubset = jobContext.getConfig().subset(\"stores.\" + storeName + \".\", true);\n+    StorageConfig storageConfig = new StorageConfig(jobContext.getConfig());\n+    Optional<String> storeFactory = storageConfig.getStorageFactoryClassName(storeName);\n+    StoreProperties.StorePropertiesBuilder storePropertiesBuilder = new StoreProperties.StorePropertiesBuilder();\n+    if (!storeFactory.isPresent() || StringUtils.isBlank(storeFactory.get())) {\n+      throw new SamzaException(\"Store factory not defined. Cannot proceed with KV store creation!\");\n+    }\n+    if (!storeFactory.get().equals(INMEMORY_KV_STORAGE_ENGINE_FACTORY)) {\n+      storePropertiesBuilder.setPersistedToDisk(true);\n+    }\n+    int batchSize = storageConfigSubset.getInt(\"write.batch.size\", 500);\n+    int cacheSize = storageConfigSubset.getInt(\"object.cache.size\", Math.max(batchSize, 1000));\n+    if (cacheSize > 0 && cacheSize < batchSize) {\n+      throw new SamzaException(\n+          \"A store's cache.size cannot be less than batch.size as batched values reside in cache.\");\n+    }\n+    if (keySerde == null) {\n+      throw new SamzaException(\"Must define a key serde when using key value storage.\");\n+    }\n+    if (msgSerde == null) {\n+      throw new SamzaException(\"Must define a message serde when using key value storage.\");\n+    }\n+\n+    KeyValueStore<byte[], byte[]> rawStore =\n+        getKVStore(storeName, storeDir, registry, changelogSSP, jobContext, containerContext, storeMode);\n+    KeyValueStore<byte[], byte[]> maybeLoggedStore = buildMaybeLoggedStore(changelogSSP,\n+        storeName, registry, storePropertiesBuilder, rawStore, changelogCollector);\n+    // this also applies serialization and caching layers\n+    KeyValueStore<K, V> toBeAccessLoggedStore = applyLargeMessageHandling(storeName, registry,\n+        maybeLoggedStore, storageConfig, cacheSize, batchSize, keySerde, msgSerde);\n+    KeyValueStore<K, V> maybeAccessLoggedStore =\n+        buildMaybeAccessLoggedStore(storeName, toBeAccessLoggedStore, changelogCollector, changelogSSP, storageConfig,\n+            keySerde);\n+    KeyValueStore<K, V> nullSafeStore = new NullSafeKeyValueStore<>(maybeAccessLoggedStore);\n+\n+    KeyValueStorageEngineMetrics keyValueStorageEngineMetrics = new KeyValueStorageEngineMetrics(storeName, registry);\n+    HighResolutionClock clock = buildClock(jobContext.getConfig());\n+    return new KeyValueStorageEngine<>(storeName, storeDir, storePropertiesBuilder.build(), nullSafeStore, rawStore,\n+        changelogSSP, changelogCollector, keyValueStorageEngineMetrics, batchSize,\n+        ScalaJavaUtil.toScalaFunction(clock::nanoTime));\n+  }\n+\n+  private static KeyValueStore<byte[], byte[]> buildMaybeLoggedStore(SystemStreamPartition changelogSSP,\n+      String storeName,\n+      MetricsRegistry registry,\n+      StoreProperties.StorePropertiesBuilder storePropertiesBuilder,\n+      KeyValueStore<byte[], byte[]> storeToWrap,\n+      MessageCollector changelogCollector) {\n+    if (changelogSSP == null) {\n+      return storeToWrap;\n+    } else {\n+      LoggedStoreMetrics loggedStoreMetrics = new LoggedStoreMetrics(storeName, registry);\n+      storePropertiesBuilder.setLoggedStore(true);\n+      return new LoggedStore<>(storeToWrap, changelogSSP, changelogCollector, loggedStoreMetrics);\n+    }\n+  }\n+\n+  private static <T, U> KeyValueStore<T, U> applyLargeMessageHandling(String storeName,", "originalCommit": "e56a1a6f593ac85df8f11191f9d6e6ec0b0b35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "76859a95b2eb566d88b14d4023521d90ecc6588d", "url": "https://github.com/apache/samza/commit/76859a95b2eb566d88b14d4023521d90ecc6588d", "message": "added javadocs, extract constants, improve exception messages", "committedDate": "2020-05-28T01:21:23Z", "type": "commit"}, {"oid": "5c67db5d38d0a5c344974313594ac2fe7f3eaabd", "url": "https://github.com/apache/samza/commit/5c67db5d38d0a5c344974313594ac2fe7f3eaabd", "message": "Merge branch 'master' into base_kv_engine_scala", "committedDate": "2020-05-28T17:21:23Z", "type": "commit"}, {"oid": "1a805be9889a57e87070cfc088f18024aab6f381", "url": "https://github.com/apache/samza/commit/1a805be9889a57e87070cfc088f18024aab6f381", "message": "Merge branch 'master' into base_kv_engine_scala", "committedDate": "2020-06-12T16:43:23Z", "type": "commit"}]}