{"pr_number": 1559, "pr_title": "JBTM 3239 Ensure post LRA actions are retried in the presence of failures", "pr_createdAt": "2020-02-02T23:17:05Z", "pr_url": "https://github.com/jbosstm/narayana/pull/1559", "timeline": [{"oid": "36931a9dc5026e6ea541e37526a6dc15289847e3", "url": "https://github.com/jbosstm/narayana/commit/36931a9dc5026e6ea541e37526a6dc15289847e3", "message": "JBTM-3239 Ensure post LRA actions are retried in the presence of failures", "committedDate": "2020-02-03T13:39:14Z", "type": "forcePushed"}, {"oid": "b433f169922821b26e5ef33a9e813446e7c36ba2", "url": "https://github.com/jbosstm/narayana/commit/b433f169922821b26e5ef33a9e813446e7c36ba2", "message": "JBTM-3239 Ensure post LRA actions are retried in the presence of failures", "committedDate": "2020-02-03T18:23:43Z", "type": "forcePushed"}, {"oid": "42eb8d46cc6f74f5d971d62bb7cf284ffe855689", "url": "https://github.com/jbosstm/narayana/commit/42eb8d46cc6f74f5d971d62bb7cf284ffe855689", "message": "JBTM-3239 Ensure post LRA actions are retried in the presence of failures", "committedDate": "2020-02-03T18:25:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI2OTUxMA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374269510", "bodyText": "This comment seems unassertive to me. Does 412 \"imply\" or \"require\" that the participant did this thing. Also \"infer\" could imply an element of doubt, is it possible to express as \"determine\". Are we certain of the outcome here or are there cases where valid responses could be misinterpreted?", "author": "tomjenkinson", "createdAt": "2020-02-03T18:36:36Z", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -445,6 +530,8 @@ private int retryGetEndStatus(URI endPath, boolean compensate) {\n \n                 // 200 and 410 are the only valid response code for reporting the participant status\n                 if (response.getStatus() == Response.Status.GONE.getStatusCode()) {\n+                    // 412 implies that the participant did the correct thing and cleaned up so infer the status", "originalCommit": "42eb8d46cc6f74f5d971d62bb7cf284ffe855689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNTA0OA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374635048", "bodyText": "412 means that the participant no longer knows about this LRA. This means that the participant successfully compensated or completed and forgotten the LRA data. This should be documented in the specification.", "author": "xstefank", "createdAt": "2020-02-04T12:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI2OTUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0MDA3Mg==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374840072", "bodyText": "I reworded the comment and referenced the specification", "author": "mmusgrov", "createdAt": "2020-02-04T18:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI2OTUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI2OTg5Nw==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374269897", "bodyText": "Perhaps the TCK could have an RFE raised?", "author": "tomjenkinson", "createdAt": "2020-02-03T18:37:26Z", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/Transaction.java", "diffHunk": "@@ -519,6 +477,10 @@ private int doEnd(boolean cancel) {\n             status = toLRAStatus(res);\n         }\n \n+        // it would be less invasive to allow recoovery to run post LRA actions", "originalCommit": "42eb8d46cc6f74f5d971d62bb7cf284ffe855689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0MDcxNQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374840715", "bodyText": "This PR runs agains MP-LRA RC1 but I notice that the latest snapshot does run a recovery pass now. Therefore I have reworded the comment.", "author": "mmusgrov", "createdAt": "2020-02-04T18:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI2OTg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIyNTcwNA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375225704", "bodyText": "Thanks @mmusgrov I note the previous comment indicated invasiveness of calling this here but timeliness now? TBH I don't quite understand why they are considered \"Post\" actions as it seems to be the phase that actually completes the LRA?", "author": "tomjenkinson", "createdAt": "2020-02-05T12:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI2OTg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5NjI4Ng==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375396286", "bodyText": "Invasive in the sense that it bulks up the number of changes in the PR. I changed it to timeliness since it is a better functional argument for it.", "author": "mmusgrov", "createdAt": "2020-02-05T17:21:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI2OTg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5NzQ2NA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375397464", "bodyText": "They are called \"Post LRA\" actions since they are performed after the LRA has reached a terminal state.", "author": "mmusgrov", "createdAt": "2020-02-05T17:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI2OTg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI3MDM0NQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374270345", "bodyText": "Does the JBTM exist yet? It would be useful to reference the actual JBTM in the comment", "author": "tomjenkinson", "createdAt": "2020-02-03T18:38:20Z", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/service/LRAService.java", "diffHunk": "@@ -173,7 +173,8 @@ public void finished(Transaction transaction, boolean fromHierarchy) {\n             // the LRA is top level or it's a nested LRA that was closed by a\n             // parent LRA (ie when fromHierarchy is true) then it's okay to forget about the LRA\n \n-            if (transaction.afterLRANotification()) {\n+            if (!transaction.hasPendingActions()) {\n+                // this call is only required to clean up cached LRAs. Follow up with a JBTM to avoid this", "originalCommit": "42eb8d46cc6f74f5d971d62bb7cf284ffe855689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0MTI0NA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374841244", "bodyText": "I raised JBTM-3250 and reworded the comment.", "author": "mmusgrov", "createdAt": "2020-02-04T18:21:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI3MDM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyOTQzMg==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374629432", "bodyText": "this only usable in afterLRA calls because we are passing LRA id as LRA_HTTP_ENDED_CONTEXT_HEADER", "author": "xstefank", "createdAt": "2020-02-04T11:59:59Z", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -361,18 +375,89 @@ private int tryDoEnd(boolean compensate) {\n                  * so if we were to return FINISH_ERROR recovery would not replay the log.\n                  * To force the record to be eligible for recovery we return a heuristic hazard.\n                  */\n-                return TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                return atEnd(TwoPhaseOutcome.HEURISTIC_HAZARD);\n             }\n \n             status = ParticipantStatus.Completing; // recovery will figure out the status via the status url\n \n-            return TwoPhaseOutcome.FINISH_ERROR;\n+            return atEnd(TwoPhaseOutcome.FINISH_ERROR);\n         }\n \n         updateStatus(compensate);\n \n         // if the the request is still in progress (ie accepted is true) let recovery finish it\n-        return accepted ? TwoPhaseOutcome.HEURISTIC_HAZARD : TwoPhaseOutcome.FINISH_OK;\n+        return atEnd(accepted ? TwoPhaseOutcome.HEURISTIC_HAZARD : TwoPhaseOutcome.FINISH_OK);\n+    }\n+\n+    boolean isFinished() {\n+        // nested participants must still be able to compensate even if they are closed\n+        if (compensateURI == null) {\n+            return afterURI != null;\n+        }\n+\n+        switch (status) {\n+            case Completed:\n+                /* FALLTHRU */\n+            case FailedToComplete:\n+                return parentId == null; // completed nested LRAs must remain cancellable\n+            case Compensated:\n+                /* FALLTHRU */\n+            case FailedToCompensate:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean request(URI target, Transaction lra, String payload) {\n+        try {\n+            RequestBuilder builder = new RequestBuilder(target)\n+                    .request()\n+                    .header(LRA.LRA_HTTP_ENDED_CONTEXT_HEADER, lra.getId().toASCIIString())", "originalCommit": "42eb8d46cc6f74f5d971d62bb7cf284ffe855689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0MTgwOA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374841808", "bodyText": "Okay, I fixed the choice of headers depending upon whether or not we are running the AfterLRA notification.", "author": "mmusgrov", "createdAt": "2020-02-04T18:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyOTQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyOTYwMQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374629601", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean request(URI target, Transaction lra, String payload) {\n          \n          \n            \n                private boolean afterLRARequest(URI target, Transaction lra, String payload) {", "author": "xstefank", "createdAt": "2020-02-04T12:00:27Z", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -361,18 +375,89 @@ private int tryDoEnd(boolean compensate) {\n                  * so if we were to return FINISH_ERROR recovery would not replay the log.\n                  * To force the record to be eligible for recovery we return a heuristic hazard.\n                  */\n-                return TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                return atEnd(TwoPhaseOutcome.HEURISTIC_HAZARD);\n             }\n \n             status = ParticipantStatus.Completing; // recovery will figure out the status via the status url\n \n-            return TwoPhaseOutcome.FINISH_ERROR;\n+            return atEnd(TwoPhaseOutcome.FINISH_ERROR);\n         }\n \n         updateStatus(compensate);\n \n         // if the the request is still in progress (ie accepted is true) let recovery finish it\n-        return accepted ? TwoPhaseOutcome.HEURISTIC_HAZARD : TwoPhaseOutcome.FINISH_OK;\n+        return atEnd(accepted ? TwoPhaseOutcome.HEURISTIC_HAZARD : TwoPhaseOutcome.FINISH_OK);\n+    }\n+\n+    boolean isFinished() {\n+        // nested participants must still be able to compensate even if they are closed\n+        if (compensateURI == null) {\n+            return afterURI != null;\n+        }\n+\n+        switch (status) {\n+            case Completed:\n+                /* FALLTHRU */\n+            case FailedToComplete:\n+                return parentId == null; // completed nested LRAs must remain cancellable\n+            case Compensated:\n+                /* FALLTHRU */\n+            case FailedToCompensate:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean request(URI target, Transaction lra, String payload) {", "originalCommit": "42eb8d46cc6f74f5d971d62bb7cf284ffe855689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0MjU4Mg==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374842582", "bodyText": "I used request so that the same method could replace the other REST calls in the class. But I will reword the method name since I have not done that in this PR.", "author": "mmusgrov", "createdAt": "2020-02-04T18:23:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyOTYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzMzE4MA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374633180", "bodyText": "isn't this a normal compensateURI which passed from user? so it can be user-endpoint:user-port/something/compensate? How can we be sure that parent LRA can be extracted?", "author": "xstefank", "createdAt": "2020-02-04T12:09:26Z", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -361,18 +375,89 @@ private int tryDoEnd(boolean compensate) {\n                  * so if we were to return FINISH_ERROR recovery would not replay the log.\n                  * To force the record to be eligible for recovery we return a heuristic hazard.\n                  */\n-                return TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                return atEnd(TwoPhaseOutcome.HEURISTIC_HAZARD);\n             }\n \n             status = ParticipantStatus.Completing; // recovery will figure out the status via the status url\n \n-            return TwoPhaseOutcome.FINISH_ERROR;\n+            return atEnd(TwoPhaseOutcome.FINISH_ERROR);\n         }\n \n         updateStatus(compensate);\n \n         // if the the request is still in progress (ie accepted is true) let recovery finish it\n-        return accepted ? TwoPhaseOutcome.HEURISTIC_HAZARD : TwoPhaseOutcome.FINISH_OK;\n+        return atEnd(accepted ? TwoPhaseOutcome.HEURISTIC_HAZARD : TwoPhaseOutcome.FINISH_OK);\n+    }\n+\n+    boolean isFinished() {\n+        // nested participants must still be able to compensate even if they are closed\n+        if (compensateURI == null) {\n+            return afterURI != null;\n+        }\n+\n+        switch (status) {\n+            case Completed:\n+                /* FALLTHRU */\n+            case FailedToComplete:\n+                return parentId == null; // completed nested LRAs must remain cancellable\n+            case Compensated:\n+                /* FALLTHRU */\n+            case FailedToCompensate:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean request(URI target, Transaction lra, String payload) {\n+        try {\n+            RequestBuilder builder = new RequestBuilder(target)\n+                    .request()\n+                    .header(LRA.LRA_HTTP_ENDED_CONTEXT_HEADER, lra.getId().toASCIIString())\n+                    .header(LRA.LRA_HTTP_RECOVERY_HEADER, recoveryURI.toASCIIString())\n+                    .async(PARTICIPANT_TIMEOUT, TimeUnit.SECONDS);\n+            ResponseHolder response = target.equals(forgetURI) ? builder.delete() : builder.put(payload, MediaType.TEXT_PLAIN);\n+\n+            if (response.getStatus() == 200) {\n+                return true;\n+            }\n+        } catch (WebApplicationException e) {\n+            if (LRALogger.logger.isInfoEnabled()) {\n+                LRALogger.logger.infof(\"Could not notify URI at %s (%s)\", target, e.getMessage());\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private int atEnd(int res) {\n+        URI nested = compensateURI != null ? extractParentLRA(compensateURI) : null;", "originalCommit": "42eb8d46cc6f74f5d971d62bb7cf284ffe855689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0NjI1Mg==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374846252", "bodyText": "The method understands the narayana LRA format for nested LRAs acting as participants. But since I only need the parent in order to deliver the forget notification and since we don't have a test for that in LRA RC1 (you added it after that in issue 208 / pr 258) I have removed the logic. We can add it back in again when we add an implementation of the MP-LRA test TckContextTests#testForgetCalledForNestedParticipantsWhenParentIsClosed", "author": "mmusgrov", "createdAt": "2020-02-04T18:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzMzE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2ODY4MQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374868681", "bodyText": "it seems that you've removed this line. LRARecord already should have parentId in the field so no need to extract it.", "author": "xstefank", "createdAt": "2020-02-04T19:13:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzMzE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIyMzI4MQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375223281", "bodyText": "... But since I only need the parent in order to deliver the forget notification and since we don't have a test for that in LRA RC1 (you added it after that in issue 208 / pr 258) I have removed the logic. We can add it back in again when we add an implementation of the MP-LRA test TckContextTests#testForgetCalledForNestedParticipantsWhenParentIsClosed", "author": "mmusgrov", "createdAt": "2020-02-05T12:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzMzE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzMzk0OQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374633949", "bodyText": "this is wrong since request method packs LRA id as LRA_HTTP_ENDED_CONTEXT_HEADER not as LRA_HTTP_CONTEXT_HEADER.", "author": "xstefank", "createdAt": "2020-02-04T12:11:20Z", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -361,18 +375,89 @@ private int tryDoEnd(boolean compensate) {\n                  * so if we were to return FINISH_ERROR recovery would not replay the log.\n                  * To force the record to be eligible for recovery we return a heuristic hazard.\n                  */\n-                return TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                return atEnd(TwoPhaseOutcome.HEURISTIC_HAZARD);\n             }\n \n             status = ParticipantStatus.Completing; // recovery will figure out the status via the status url\n \n-            return TwoPhaseOutcome.FINISH_ERROR;\n+            return atEnd(TwoPhaseOutcome.FINISH_ERROR);\n         }\n \n         updateStatus(compensate);\n \n         // if the the request is still in progress (ie accepted is true) let recovery finish it\n-        return accepted ? TwoPhaseOutcome.HEURISTIC_HAZARD : TwoPhaseOutcome.FINISH_OK;\n+        return atEnd(accepted ? TwoPhaseOutcome.HEURISTIC_HAZARD : TwoPhaseOutcome.FINISH_OK);\n+    }\n+\n+    boolean isFinished() {\n+        // nested participants must still be able to compensate even if they are closed\n+        if (compensateURI == null) {\n+            return afterURI != null;\n+        }\n+\n+        switch (status) {\n+            case Completed:\n+                /* FALLTHRU */\n+            case FailedToComplete:\n+                return parentId == null; // completed nested LRAs must remain cancellable\n+            case Compensated:\n+                /* FALLTHRU */\n+            case FailedToCompensate:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean request(URI target, Transaction lra, String payload) {\n+        try {\n+            RequestBuilder builder = new RequestBuilder(target)\n+                    .request()\n+                    .header(LRA.LRA_HTTP_ENDED_CONTEXT_HEADER, lra.getId().toASCIIString())\n+                    .header(LRA.LRA_HTTP_RECOVERY_HEADER, recoveryURI.toASCIIString())\n+                    .async(PARTICIPANT_TIMEOUT, TimeUnit.SECONDS);\n+            ResponseHolder response = target.equals(forgetURI) ? builder.delete() : builder.put(payload, MediaType.TEXT_PLAIN);\n+\n+            if (response.getStatus() == 200) {\n+                return true;\n+            }\n+        } catch (WebApplicationException e) {\n+            if (LRALogger.logger.isInfoEnabled()) {\n+                LRALogger.logger.infof(\"Could not notify URI at %s (%s)\", target, e.getMessage());\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private int atEnd(int res) {\n+        URI nested = compensateURI != null ? extractParentLRA(compensateURI) : null;\n+        boolean notifyForget = (nested != null && forgetURI != null);\n+\n+        // Only run the post LRA actions if both the LRA and participant are in an end state\n+        // check the participant first since it will have been removed from one of the lists\n+        if (!isFinished() || !lra.isFinished()) {\n+            if (afterURI != null || notifyForget) {\n+                return TwoPhaseOutcome.HEURISTIC_HAZARD;\n+            }\n+\n+            return res;\n+        }\n+\n+        // run post LRA actions\n+        boolean r1 = afterURI == null || request(afterURI, lra, lra.getLRAStatus().name());\n+        boolean r2 = !notifyForget || request(forgetURI, lra, lra.getLRAStatus().name());", "originalCommit": "42eb8d46cc6f74f5d971d62bb7cf284ffe855689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0NjQ4Mg==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374846482", "bodyText": "Okay", "author": "mmusgrov", "createdAt": "2020-02-04T18:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzMzk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNjIxOQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374636219", "bodyText": "You can reuse isFinished() here.", "author": "xstefank", "createdAt": "2020-02-04T12:16:22Z", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/Transaction.java", "diffHunk": "@@ -532,12 +494,87 @@ private int doEnd(boolean cancel) {\n         return res;\n     }\n \n+    protected void runPostLRAActions() {\n+        // if there are no more heuristics or failures then update the status of the LRA\n+        if (isInEndState()) {\n+            if (preparedList == null) {\n+                preparedList = new RecordList();\n+            }\n+            moveTo(heuristicList, preparedList);\n+            moveTo(failedList, preparedList);\n+            checkParticipant(preparedList);\n+            super.phase2Commit(true);\n+        }\n+    }\n+\n     private boolean updateState(LRAStatus nextState) {\n         status = nextState;\n \n         return (pendingList == null || pendingList.size() == 0) || deactivate();\n     }\n \n+    protected void checkParticipant(RecordList participants) {\n+        RecordListIterator i = new RecordListIterator(participants);\n+        AbstractRecord r;\n+\n+        while ((r = i.iterate()) != null) {\n+            if (r instanceof LRARecord) {\n+                LRARecord rec = (LRARecord) r;\n+\n+                rec.setLraService(getLraService());\n+                rec.setLRA(this);\n+            }\n+        }\n+    }\n+\n+    protected void moveTo(RecordList fromList, RecordList toList) {\n+        AbstractRecord record;\n+\n+        if (fromList != null) {\n+            while ((record = fromList.getFront()) != null) {\n+                toList.putFront(record);\n+            }\n+        }\n+    }\n+\n+    private boolean allFinished(RecordList... lists) {\n+        for (RecordList list : lists) {\n+            if (list != null) {\n+                RecordListIterator i = new RecordListIterator(list);\n+                AbstractRecord r;\n+\n+                while ((r = i.iterate()) != null) {\n+                    if (r instanceof LRARecord) {\n+                        LRARecord rec = (LRARecord) r;\n+                        if (!rec.isFinished()) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    protected boolean isInEndState() {\n+        if (status == LRAStatus.Cancelling && allFinished(heuristicList, failedList)) {\n+            status = LRAStatus.Cancelled;\n+        } else if (status == LRAStatus.Closing && allFinished(heuristicList, failedList)) {\n+            status = LRAStatus.Closed;\n+        }\n+\n+        switch (status) {", "originalCommit": "42eb8d46cc6f74f5d971d62bb7cf284ffe855689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0NjY0OA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374846648", "bodyText": "Thanks", "author": "mmusgrov", "createdAt": "2020-02-04T18:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNjIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNzUyNA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374637524", "bodyText": "Will this be set in the preparedList also in case of recovery? LRARecord doesn't seem to persist the passed Transaction object with its state.", "author": "xstefank", "createdAt": "2020-02-04T12:19:19Z", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/Transaction.java", "diffHunk": "@@ -532,12 +494,87 @@ private int doEnd(boolean cancel) {\n         return res;\n     }\n \n+    protected void runPostLRAActions() {\n+        // if there are no more heuristics or failures then update the status of the LRA\n+        if (isInEndState()) {\n+            if (preparedList == null) {\n+                preparedList = new RecordList();\n+            }\n+            moveTo(heuristicList, preparedList);\n+            moveTo(failedList, preparedList);\n+            checkParticipant(preparedList);\n+            super.phase2Commit(true);\n+        }\n+    }\n+\n     private boolean updateState(LRAStatus nextState) {\n         status = nextState;\n \n         return (pendingList == null || pendingList.size() == 0) || deactivate();\n     }\n \n+    protected void checkParticipant(RecordList participants) {\n+        RecordListIterator i = new RecordListIterator(participants);\n+        AbstractRecord r;\n+\n+        while ((r = i.iterate()) != null) {\n+            if (r instanceof LRARecord) {\n+                LRARecord rec = (LRARecord) r;\n+\n+                rec.setLraService(getLraService());\n+                rec.setLRA(this);", "originalCommit": "42eb8d46cc6f74f5d971d62bb7cf284ffe855689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0NzA1MA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374847050", "bodyText": "This value is set by the recovery module during each recovery pass so it does not need to be durable.", "author": "mmusgrov", "createdAt": "2020-02-04T18:31:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNzUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg3MzY2NQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374873665", "bodyText": "also is it needed to save Transaction in LRARecord? there are individual fields already present (lraId, recoveryId, parentId) so only thing additional thing needed for afterLRA is the outcome of the LRA.", "author": "xstefank", "createdAt": "2020-02-04T19:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNzUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIyMzcwNQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375223705", "bodyText": "Not sure what you mean. But the LRA is set dynamically on each recovery pass so there is no need to make it durable.", "author": "mmusgrov", "createdAt": "2020-02-05T12:21:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNzUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIzMDczNw==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375230737", "bodyText": "the passed transaction (which is passed on every recovery pass to every record) is used only in afterLRA and nested forget calls (post LRA actions). But LRARecord already has fields for lraId, parentId, recoveryId. So is it really necessary to pass the Transaction object on each pass?", "author": "xstefank", "createdAt": "2020-02-05T12:37:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNzUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM0MDI2Nw==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375340267", "bodyText": "It is used in the following line: https://github.com/jbosstm/narayana/pull/1559/files#diff-0f226ae6945188e648e485306754f30cR443", "author": "mmusgrov", "createdAt": "2020-02-05T15:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNzUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM1MDgzNg==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375350836", "bodyText": "ok, I see. Thanks.", "author": "xstefank", "createdAt": "2020-02-05T16:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNzUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzOTcxNw==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374639717", "bodyText": "is this forgotten from testing? Some time ago you mentioned in one of my PRs that 1s is intentional and more than enough for modern network speeds.", "author": "xstefank", "createdAt": "2020-02-04T12:24:20Z", "path": "rts/lra/lra-service-base/src/main/java/io/narayana/lra/LRAHttpClient.java", "diffHunk": "@@ -19,7 +19,7 @@\n import java.util.concurrent.TimeoutException;\n \n public class LRAHttpClient {\n-    public static final long PARTICIPANT_TIMEOUT = 1; // number of seconds to wait for requests\n+    public static final long PARTICIPANT_TIMEOUT = 10; // number of seconds to wait for requests", "originalCommit": "42eb8d46cc6f74f5d971d62bb7cf284ffe855689", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0OTQ2MQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r374849461", "bodyText": "Well 1 second should be more than enough but the new test on the existing CI infrastructure intermittently fails because the 1 second time limit is breached. I have not studied your test in detail to find out why the callbacks sometimes take longer than 1 second (or whether the test is making certain assumptions) but I made it 10 s for expediency. Note that the shorter timelimit should work if the tests run sufficient recovery passes (but I did not spend any time investigating). Perhaps we should revisit the test at a later date.", "author": "mmusgrov", "createdAt": "2020-02-04T18:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzOTcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTExMDQ0MQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375110441", "bodyText": "I have changed it to 2 seconds.", "author": "mmusgrov", "createdAt": "2020-02-05T08:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzOTcxNw=="}], "type": "inlineReview"}, {"oid": "26cc3c8576057ecff90faef34e5a6868ac458226", "url": "https://github.com/jbosstm/narayana/commit/26cc3c8576057ecff90faef34e5a6868ac458226", "message": "JBTM-3239 Ensure post LRA actions are retried in the presence of failures", "committedDate": "2020-02-04T17:52:47Z", "type": "forcePushed"}, {"oid": "f2db3babd15da0a202da93b36e07bcef43ebd396", "url": "https://github.com/jbosstm/narayana/commit/f2db3babd15da0a202da93b36e07bcef43ebd396", "message": "JBTM-3239 Ensure post LRA actions are retried in the presence of failures", "committedDate": "2020-02-05T08:12:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMTc4Mg==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375201782", "bodyText": "@mmusgrov please can you add a reference to https://issues.redhat.com/browse/JBTM-3163 here so we know why it is doing this twice. IIUC the comment from @xstefank then if that is fixed then this line will probably start failing as afterLRA will only be called twice.", "author": "tomjenkinson", "createdAt": "2020-02-05T11:28:12Z", "path": "rts/lra/lra-test/lra-test-basic/src/test/java/io/narayana/lra/arquillian/resource/FailingAfterLRAListener.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2019, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.resource;\n+\n+import org.eclipse.microprofile.lra.annotation.AfterLRA;\n+import org.eclipse.microprofile.lra.annotation.ws.rs.LRA;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+@Path(FailingAfterLRAListener.ROOT_PATH)\n+public class FailingAfterLRAListener {\n+\n+    public static final String ROOT_PATH = \"failing-after-lra-listener\";\n+    public static final String ACTION_PATH = \"action\";\n+\n+    private static final AtomicInteger afterLRACounter = new AtomicInteger(0);\n+\n+    @GET\n+    @Path(ACTION_PATH)\n+    @LRA(LRA.Type.REQUIRED)\n+    public String doWorkInLRA(@HeaderParam(LRA.LRA_HTTP_CONTEXT_HEADER) URI lraId) {\n+        return lraId.toASCIIString();\n+    }\n+\n+    @PUT\n+    @Path(\"after-lra\")\n+    @AfterLRA\n+    public Response afterLRA(@HeaderParam(LRA.LRA_HTTP_ENDED_CONTEXT_HEADER) URI endedLRAId) {\n+        if (afterLRACounter.getAndIncrement() < 2) {", "originalCommit": "f2db3babd15da0a202da93b36e07bcef43ebd396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwODQ5NQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375208495", "bodyText": "@tomjenkinson no, it shouldn't start failing. The recovery will just be replayed two times.", "author": "xstefank", "createdAt": "2020-02-05T11:44:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMTc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxNjcwNQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375216705", "bodyText": "If I understand you correctly, once https://issues.redhat.com/browse/JBTM-3163 is fixed instead of two notifications for one recovery we could go down to \"getAndIncrement < 1\"\nAm I right in thinking therefore that https://github.com/jbosstm/narayana/pull/1559/files#diff-6ba4dd5973413b54d0299d8935a156c1R54-R56 is not actually required or used in this PR? If so I think we should remove that part? I will create a discussion localised on that line for this.", "author": "tomjenkinson", "createdAt": "2020-02-05T12:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMTc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxOTI4NA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375219284", "bodyText": "Actually I see the code may well apply if the scan is in progress", "author": "tomjenkinson", "createdAt": "2020-02-05T12:10:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMTc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIyMDY4Nw==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375220687", "bodyText": "It is possible to move it to < 1 after https://issues.redhat.com/browse/JBTM-3163 is resolved, but not required.\nSorry, the second link doesn't probably take me where you've intended. But if it's NarayanaLRARecovery then that code is correct. The two invocations there are about something different -- namely the clash with periodic recovery which may sometime happen. That is a different issue which was decided that it will not be resolved some time ago.", "author": "xstefank", "createdAt": "2020-02-05T12:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMTc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIyMjA3NQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375222075", "bodyText": "I understand this better now. Currently we need 3 total calls to this method  (two from the normal cleanup, one (though will receive 2) from recovery)\nIn the future we need 2 notifications (one from the normal cleanup, one from recovery) so will be able to change this line to if (afterLRACounter.getAndIncrement() < 1) after JBTM-2863 is solved. As such it needs the comment and a reference to the bit that needs cleanup adding to the JBTM", "author": "tomjenkinson", "createdAt": "2020-02-05T12:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMTc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIzMjQxNA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375232414", "bodyText": "I am not clear on what this discussion is about. The test says afterLRACounter.getAndIncrement() < 2 so it will return a 500 error status 2 times followed by a 200 status. The test is verifying that the LRA implementation will keep attempting the AfterLRA notification until it receives an HTTP 200 OK response. So in all we expect 2+1=3 notifications. The test FailingParticipantCallsIT asserts that the callback was invoked 3 times.\nOn the issue of JBTM-3163 that should have been incidentally resolved by the PR but it seems irrelevant to this PR.", "author": "mmusgrov", "createdAt": "2020-02-05T12:41:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMTc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4MjA4MA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375782080", "bodyText": "The discussion is fundamentally related to the \"2\" in your formula \"2+1=3\", in other words why we have the need to return the ISE twice rather than just once.\nThe reason I understand that the test originally needed to skip \"2\" calls before was because of a duplicate notification (JBTM-3163) so the two calls would have been from the same routine execution in Narayana (this?) and so returning OK to the second notification would not have tested the call was repeated.\nThe premise of the observation is related to why the test not just say:\nif (afterLRACounter.getAndIncrement() < 1) {\n     return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();\n}\nreturn Response.ok().build();", "author": "tomjenkinson", "createdAt": "2020-02-06T11:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMTc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4OTc3Mw==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375789773", "bodyText": "@mmusgrov I think this is the last area to get clarity on. Do we need to return ISE on the first 2 calls to afterLRA or could it just be one now? And what is the plan to resolve JBTM-3163, will it be linked to this PR somehow?", "author": "tomjenkinson", "createdAt": "2020-02-06T11:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMTc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMxMTg1NQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r376311855", "bodyText": "Well okay I changed it to 2 to get faster test turnaround time on testing.", "author": "mmusgrov", "createdAt": "2020-02-07T10:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMTc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxOTYyNA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375219624", "bodyText": "@xstefank @mmusgrov perhaps we could turn off automated recovery for this test if we want more predictability", "author": "tomjenkinson", "createdAt": "2020-02-05T12:11:00Z", "path": "rts/lra/lra-test/lra-test-arquillian-extension/src/main/java/io/narayana/lra/arquillian/spi/NarayanaLRARecovery.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat, Inc., and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+\n+package io.narayana.lra.arquillian.spi;\n+\n+import io.narayana.lra.LRAConstants;\n+import io.narayana.lra.logging.LRALogger;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.client.WebTarget;\n+import javax.ws.rs.core.Response;\n+import java.net.URI;\n+\n+public class NarayanaLRARecovery {\n+\n+    public void waitForCallbacks(URI lraId) {\n+        // no action is needed, tck callbacks calls are sufficiently fast for TCK\n+    }\n+\n+    // TODO remove once this class implements LRARecoveryService\n+    public void waitForRecovery(URI lraId) {\n+        int counter = 0;\n+\n+        do {\n+            LRALogger.logger.info(\"Recovery attempt #\" + ++counter);\n+        } while (!waitForEndPhaseReplay(lraId));\n+        LRALogger.logger.info(\"LRA \" + lraId + \"has finished the recovery \" + counter);\n+    }\n+\n+    public boolean waitForEndPhaseReplay(URI lraId) {\n+        String host = lraId.getHost();\n+        int port = lraId.getPort();\n+        if (!recoverLRAs(host, port, lraId)) {\n+            // first recovery scan probably collided with periodic recovevery which started\n+            // before the test execution so try once more\n+            return recoverLRAs(host, port, lraId);", "originalCommit": "f2db3babd15da0a202da93b36e07bcef43ebd396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIyMTgwNQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375221805", "bodyText": "@tomjenkinson AfterLRA can be replayed several times successfully. The test is just testing that it will be eventually replayed, but the specification allows it to be replayed even 4 or 5 times (unbounded). So I think the test is correct.", "author": "xstefank", "createdAt": "2020-02-05T12:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxOTYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4ODAwMA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375788000", "bodyText": "Sure, but under test conditions in Narayana we can control this to reduce the number of retries. If we turned off background recovery and triggered the recovery manually you would only need one call to recoverLRAs(host, port, lraId).\nHowever, given the recovery manager is (I assume) running in a service similar to in WildFly then actually this is not necessarily possible. What might be possible is to delay the background recovery thread from starting for some arbitrarily long period using \n  \n    \n      narayana/ArjunaCore/arjuna/classes/com/arjuna/ats/arjuna/common/RecoveryEnvironmentBean.java\n    \n    \n         Line 47\n      in\n      1e17caa\n    \n    \n    \n    \n\n        \n          \n           private volatile int periodicRecoveryInitilizationOffset = 0;", "author": "tomjenkinson", "createdAt": "2020-02-06T11:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxOTYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4OTMwNA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375789304", "bodyText": "@tomjenkinson thanks, I didn't know about this. We can use I think. But let's leave that to some other PR/issue, please.", "author": "xstefank", "createdAt": "2020-02-06T11:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxOTYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc5MDkxNQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r375790915", "bodyText": "Yeah, seems reasonable as the test is valid either way I think as we are getting the extra notifications.", "author": "tomjenkinson", "createdAt": "2020-02-06T11:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxOTYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4NjQzNQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r376286435", "bodyText": "We already tweak that config option. You could change it now on the LRA branch or just wait for the merge into master. I don't think there is any particular urgency.", "author": "mmusgrov", "createdAt": "2020-02-07T09:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxOTYyNA=="}], "type": "inlineReview"}, {"oid": "b8f54959b9a418bcb8ca41e8bb518b6e61dc0180", "url": "https://github.com/jbosstm/narayana/commit/b8f54959b9a418bcb8ca41e8bb518b6e61dc0180", "message": "JBTM-3239 Ensure post LRA actions are retried in the presence of failures", "committedDate": "2020-02-07T09:09:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMjM5MA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r376332390", "bodyText": "@mmusgrov please can you expand on the situation where afterURI can be null at this point and what the value of res could be?\nIf afterURI is null we will return TwoPhaseOutcome.FINISH_OK but res might not always be that from what I can see in above calls to atEnd(int) - including at least one call that might pass in HEURISTIC_HAZARD. Maybe in those cases afterURI could never be null? But then what about the one which uses a value from retryGetEndStatus or reportFailure", "author": "tomjenkinson", "createdAt": "2020-02-07T10:56:49Z", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -361,18 +375,88 @@ private int tryDoEnd(boolean compensate) {\n                  * so if we were to return FINISH_ERROR recovery would not replay the log.\n                  * To force the record to be eligible for recovery we return a heuristic hazard.\n                  */\n-                return TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                return atEnd(TwoPhaseOutcome.HEURISTIC_HAZARD);\n             }\n \n             status = ParticipantStatus.Completing; // recovery will figure out the status via the status url\n \n-            return TwoPhaseOutcome.FINISH_ERROR;\n+            return atEnd(TwoPhaseOutcome.FINISH_ERROR);\n         }\n \n         updateStatus(compensate);\n \n         // if the the request is still in progress (ie accepted is true) let recovery finish it\n-        return accepted ? TwoPhaseOutcome.HEURISTIC_HAZARD : TwoPhaseOutcome.FINISH_OK;\n+        return atEnd(accepted ? TwoPhaseOutcome.HEURISTIC_HAZARD : TwoPhaseOutcome.FINISH_OK);\n+    }\n+\n+    boolean isFinished() {\n+        // nested participants must still be able to compensate even if they are closed\n+        if (compensateURI == null) {\n+            return afterURI != null;\n+        }\n+\n+        switch (status) {\n+            case Completed:\n+                /* FALLTHRU */\n+            case FailedToComplete:\n+                return parentId == null; // completed nested LRAs must remain cancellable\n+            case Compensated:\n+                /* FALLTHRU */\n+            case FailedToCompensate:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean afterLRARequest(URI target, Transaction lra, String payload) {\n+        try {\n+            RequestBuilder builder = new RequestBuilder(target)\n+                    .request()\n+                    .header(LRA.LRA_HTTP_RECOVERY_HEADER, recoveryURI.toASCIIString());\n+\n+            if (target.equals(afterURI)) {\n+                builder.header(LRA.LRA_HTTP_ENDED_CONTEXT_HEADER, lra.getId().toASCIIString());\n+            } else {\n+                builder.header(LRA.LRA_HTTP_CONTEXT_HEADER, lra.getId().toASCIIString());\n+            }\n+\n+            builder.async(PARTICIPANT_TIMEOUT, TimeUnit.SECONDS);\n+\n+            ResponseHolder response = target.equals(forgetURI) ? builder.delete() : builder.put(payload, MediaType.TEXT_PLAIN);\n+\n+            if (response.getStatus() == 200) {\n+                return true;\n+            }\n+        } catch (WebApplicationException e) {\n+            if (LRALogger.logger.isInfoEnabled()) {\n+                LRALogger.logger.infof(\"Could not notify URI at %s (%s)\", target, e.getMessage());\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private int atEnd(int res) {\n+        // Only run the post LRA actions if both the LRA and participant are in an end state\n+        // check the participant first since it will have been removed from one of the lists\n+        if (!isFinished() || !lra.isFinished()) {\n+            if (afterURI != null) {\n+                return TwoPhaseOutcome.HEURISTIC_HAZARD;\n+            }\n+\n+            return res;\n+        }\n+\n+        // run post LRA actions\n+        if (afterURI == null || afterLRARequest(afterURI, lra, lra.getLRAStatus().name())) {", "originalCommit": "b8f54959b9a418bcb8ca41e8bb518b6e61dc0180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3MTExNA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r376371114", "bodyText": "This bit of code will only run if it is time to run the post LRA actions. If those actions succeed then we are finished with this record and we return FINISH_OK which removes this record from the intentions list.\nIn more detail:\n\nIf the status passed to the atEnd routine is HEURISTIC_HAZARD then the previous check (line 443) if (!isFinished() || !lra.isFinished()) { will have been true so the bit of code you have highlighted will not be reached and we return HH or the res value depending on whether or not afterURI is null.\nThe reportFailure route will always return TwoPhaseOutcome.FINISH_OK (since the spec only requires us to log failures). But do note that we have JBTM-3247 \"Failed LRA records are reported but they not kept\" which when fixed will keep those records (and the fix for that should take account of your current comment).\nThe other route you mention is retryGetEndStatus then:\n\nif this returns HH then it is covered by point 1) above\nif it returns FE (FINISH_ERROR) then it ought to have been covered by point 2) above where failures should be reported but the log can be removed. Although I do notice in this routine that the failure will not be reported using a logging statement but that is part of the fix for JBTM-3247 (keep failed records).", "author": "mmusgrov", "createdAt": "2020-02-07T12:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMjM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ2MTMxNg==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r376461316", "bodyText": "Thanks Mike. Regarding the missing logging you mentioned \"will not be reported using a logging statement\" - do you mean this particular detection of the LRAStatus being FailedToClose or FailedToCancel was not logged but another one would have been or that it might not have been reported at all? If the latter, it would seem different to https://issues.redhat.com/browse/JBTM-3247\nPlease can you add the conditions necessary to remember to verify JBTM-3247 text so we remember to check them?", "author": "tomjenkinson", "createdAt": "2020-02-07T15:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMjM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjcxNDI4OQ==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r376714289", "bodyText": "I mean not logged at all (but that is not part of the current PR so it doesn't need to block it). I will send all failed outcomes through the reportFailure() route so that they will always be reported on the console. But note that JBTM-3247 keeps the failed records and they are available for inspection using the RecoveryCoordinator resource in the same way that we allow inspection of recovering LRAs. At least that is the way I have resolved JBTM-3247. But my fix for JBTM-3247 requires this current PR so can I have your approval so that I can raise a PR for it.", "author": "mmusgrov", "createdAt": "2020-02-08T14:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMjM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAyMDkxNA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r377020914", "bodyText": "Thanks Mike", "author": "tomjenkinson", "createdAt": "2020-02-10T12:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMjM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2MDc2MA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r376960760", "bodyText": "lra is a field so it should not be necessary to pass it into afterLRARequest method as two parameters.", "author": "xstefank", "createdAt": "2020-02-10T09:55:03Z", "path": "rts/lra/lra-coordinator-jar/src/main/java/io/narayana/lra/coordinator/domain/model/LRARecord.java", "diffHunk": "@@ -361,18 +375,88 @@ private int tryDoEnd(boolean compensate) {\n                  * so if we were to return FINISH_ERROR recovery would not replay the log.\n                  * To force the record to be eligible for recovery we return a heuristic hazard.\n                  */\n-                return TwoPhaseOutcome.HEURISTIC_HAZARD;\n+                return atEnd(TwoPhaseOutcome.HEURISTIC_HAZARD);\n             }\n \n             status = ParticipantStatus.Completing; // recovery will figure out the status via the status url\n \n-            return TwoPhaseOutcome.FINISH_ERROR;\n+            return atEnd(TwoPhaseOutcome.FINISH_ERROR);\n         }\n \n         updateStatus(compensate);\n \n         // if the the request is still in progress (ie accepted is true) let recovery finish it\n-        return accepted ? TwoPhaseOutcome.HEURISTIC_HAZARD : TwoPhaseOutcome.FINISH_OK;\n+        return atEnd(accepted ? TwoPhaseOutcome.HEURISTIC_HAZARD : TwoPhaseOutcome.FINISH_OK);\n+    }\n+\n+    boolean isFinished() {\n+        // nested participants must still be able to compensate even if they are closed\n+        if (compensateURI == null) {\n+            return afterURI != null;\n+        }\n+\n+        switch (status) {\n+            case Completed:\n+                /* FALLTHRU */\n+            case FailedToComplete:\n+                return parentId == null; // completed nested LRAs must remain cancellable\n+            case Compensated:\n+                /* FALLTHRU */\n+            case FailedToCompensate:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean afterLRARequest(URI target, Transaction lra, String payload) {\n+        try {\n+            RequestBuilder builder = new RequestBuilder(target)\n+                    .request()\n+                    .header(LRA.LRA_HTTP_RECOVERY_HEADER, recoveryURI.toASCIIString());\n+\n+            if (target.equals(afterURI)) {\n+                builder.header(LRA.LRA_HTTP_ENDED_CONTEXT_HEADER, lra.getId().toASCIIString());\n+            } else {\n+                builder.header(LRA.LRA_HTTP_CONTEXT_HEADER, lra.getId().toASCIIString());\n+            }\n+\n+            builder.async(PARTICIPANT_TIMEOUT, TimeUnit.SECONDS);\n+\n+            ResponseHolder response = target.equals(forgetURI) ? builder.delete() : builder.put(payload, MediaType.TEXT_PLAIN);\n+\n+            if (response.getStatus() == 200) {\n+                return true;\n+            }\n+        } catch (WebApplicationException e) {\n+            if (LRALogger.logger.isInfoEnabled()) {\n+                LRALogger.logger.infof(\"Could not notify URI at %s (%s)\", target, e.getMessage());\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private int atEnd(int res) {\n+        // Only run the post LRA actions if both the LRA and participant are in an end state\n+        // check the participant first since it will have been removed from one of the lists\n+        if (!isFinished() || !lra.isFinished()) {\n+            if (afterURI != null) {\n+                return TwoPhaseOutcome.HEURISTIC_HAZARD;\n+            }\n+\n+            return res;\n+        }\n+\n+        // run post LRA actions\n+        if (afterURI == null || afterLRARequest(afterURI, lra, lra.getLRAStatus().name())) {", "originalCommit": "b8f54959b9a418bcb8ca41e8bb518b6e61dc0180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAyMzg2Mw==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r377023863", "bodyText": "@mmusgrov is there is some reason the private method would need the parameters?", "author": "tomjenkinson", "createdAt": "2020-02-10T12:07:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2MDc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4NTAxMA==", "url": "https://github.com/jbosstm/narayana/pull/1559#discussion_r377785010", "bodyText": "It can use the field", "author": "mmusgrov", "createdAt": "2020-02-11T17:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2MDc2MA=="}], "type": "inlineReview"}, {"oid": "1251f4c912a3877ca791889947dcde2eb6c12720", "url": "https://github.com/jbosstm/narayana/commit/1251f4c912a3877ca791889947dcde2eb6c12720", "message": "Add test for JBTM-3239", "committedDate": "2020-02-11T17:32:42Z", "type": "commit"}, {"oid": "64549aff3af051794b994967e3c76f82ac18b943", "url": "https://github.com/jbosstm/narayana/commit/64549aff3af051794b994967e3c76f82ac18b943", "message": "JBTM-3239 Ensure post LRA actions are retried in the presence of failures", "committedDate": "2020-02-11T17:32:42Z", "type": "commit"}, {"oid": "64549aff3af051794b994967e3c76f82ac18b943", "url": "https://github.com/jbosstm/narayana/commit/64549aff3af051794b994967e3c76f82ac18b943", "message": "JBTM-3239 Ensure post LRA actions are retried in the presence of failures", "committedDate": "2020-02-11T17:32:42Z", "type": "forcePushed"}]}