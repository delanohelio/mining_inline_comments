{"pr_number": 1844, "pr_title": "Optimize chain sql paths", "pr_createdAt": "2020-05-12T22:13:40Z", "pr_url": "https://github.com/hapifhir/hapi-fhir/pull/1844", "timeline": [{"oid": "cf2a97c36b80117c2418eb4aa752e048376f4329", "url": "https://github.com/hapifhir/hapi-fhir/commit/cf2a97c36b80117c2418eb4aa752e048376f4329", "message": "Start cleanup", "committedDate": "2020-05-12T15:36:58Z", "type": "commit"}, {"oid": "4476eccf5fed20deb41073fa0a59f642c3083ea0", "url": "https://github.com/hapifhir/hapi-fhir/commit/4476eccf5fed20deb41073fa0a59f642c3083ea0", "message": "Almost workinf", "committedDate": "2020-05-12T21:12:13Z", "type": "commit"}, {"oid": "835ad8bb2c49d19579a5d04e4ae9670439f1c254", "url": "https://github.com/hapifhir/hapi-fhir/commit/835ad8bb2c49d19579a5d04e4ae9670439f1c254", "message": "Possibly working!!", "committedDate": "2020-05-12T22:12:52Z", "type": "commit"}, {"oid": "4ccd9844bf97fbbd2fd8c70e8c1f823de5e4659d", "url": "https://github.com/hapifhir/hapi-fhir/commit/4ccd9844bf97fbbd2fd8c70e8c1f823de5e4659d", "message": "Merge branch 'master' into ja_20200511_1842_optimize_chain_sql_paths", "committedDate": "2020-05-13T00:22:16Z", "type": "commit"}, {"oid": "b02455b61a68b568377e30fcbb9ec13c48b53757", "url": "https://github.com/hapifhir/hapi-fhir/commit/b02455b61a68b568377e30fcbb9ec13c48b53757", "message": "Fixes", "committedDate": "2020-05-13T15:52:34Z", "type": "commit"}, {"oid": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "url": "https://github.com/hapifhir/hapi-fhir/commit/cdbcc88ffe461c7d07cf4865937cfe11099ada28", "message": "Test fix", "committedDate": "2020-05-13T19:51:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTEzMTQ2NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425131465", "bodyText": "I love adding Stack to the name--really clarifies the pattern.\nIs it possibly a QueryStack rather than a QueryRootStack?  It's not clear to me what \"root\" is qualifying here...", "author": "fil512", "createdAt": "2020-05-14T13:22:14Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/SearchBuilder.java", "diffHunk": "@@ -35,13 +35,12 @@\n import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n import ca.uhn.fhir.jpa.dao.predicate.PredicateBuilder;\n import ca.uhn.fhir.jpa.dao.predicate.PredicateBuilderFactory;\n-import ca.uhn.fhir.jpa.dao.predicate.QueryRoot;\n+import ca.uhn.fhir.jpa.dao.predicate.querystack.QueryRootStack;", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ1OTgwNg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425459806", "bodyText": "Makes sense to me, I like it. Renaming to QueryStack", "author": "jamesagnew", "createdAt": "2020-05-14T22:11:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTEzMTQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTEzNTU3OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425135578", "bodyText": "I like how clearly this reads", "author": "fil512", "createdAt": "2020-05-14T13:27:56Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/SearchBuilder.java", "diffHunk": "@@ -272,36 +272,25 @@ private void init(SearchParameterMap theParams, String theSearchUuid, RequestPar\n \t\tif (sort != null) {\n \t\t\tassert !theCount;\n \n-\t\t\touterQuery = myCriteriaBuilder.createQuery(Long.class);\n-\t\t\tmyQueryRoot.push(outerQuery);\n-\t\t\tif (theCount) {\n-\t\t\t\touterQuery.multiselect(myCriteriaBuilder.countDistinct(myQueryRoot.getRoot()));\n-\t\t\t} else {\n-\t\t\t\touterQuery.multiselect(myQueryRoot.get(\"myId\").as(Long.class));\n-\t\t\t}\n+\t\t\tmyQueryRootStack.pushResourceTableQuery();", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE0MjA4Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425142083", "bodyText": "If possible, doing this without an output parameter would be clearer.  i.e.\nList<Order> orders = createSort(myCriteriaBuilder, myQueryRoot, sort);", "author": "fil512", "createdAt": "2020-05-14T13:36:44Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/SearchBuilder.java", "diffHunk": "@@ -272,36 +272,25 @@ private void init(SearchParameterMap theParams, String theSearchUuid, RequestPar\n \t\tif (sort != null) {\n \t\t\tassert !theCount;\n \n-\t\t\touterQuery = myCriteriaBuilder.createQuery(Long.class);\n-\t\t\tmyQueryRoot.push(outerQuery);\n-\t\t\tif (theCount) {\n-\t\t\t\touterQuery.multiselect(myCriteriaBuilder.countDistinct(myQueryRoot.getRoot()));\n-\t\t\t} else {\n-\t\t\t\touterQuery.multiselect(myQueryRoot.get(\"myId\").as(Long.class));\n-\t\t\t}\n+\t\t\tmyQueryRootStack.pushResourceTableQuery();\n \n \t\t\tList<Order> orders = Lists.newArrayList();\n-\n-\t\t\tcreateSort(myCriteriaBuilder, myQueryRoot, sort, orders);\n+\t\t\tcreateSort(myCriteriaBuilder, myQueryRootStack, sort, orders);", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ2MTgxNQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425461815", "bodyText": "Done", "author": "jamesagnew", "createdAt": "2020-05-14T22:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE0MjA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE0MjU1NA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425142554", "bodyText": "Oh man this reads so much better now!", "author": "fil512", "createdAt": "2020-05-14T13:37:24Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/SearchBuilder.java", "diffHunk": "@@ -272,36 +272,25 @@ private void init(SearchParameterMap theParams, String theSearchUuid, RequestPar\n \t\tif (sort != null) {\n \t\t\tassert !theCount;\n \n-\t\t\touterQuery = myCriteriaBuilder.createQuery(Long.class);\n-\t\t\tmyQueryRoot.push(outerQuery);\n-\t\t\tif (theCount) {\n-\t\t\t\touterQuery.multiselect(myCriteriaBuilder.countDistinct(myQueryRoot.getRoot()));\n-\t\t\t} else {\n-\t\t\t\touterQuery.multiselect(myQueryRoot.get(\"myId\").as(Long.class));\n-\t\t\t}\n+\t\t\tmyQueryRootStack.pushResourceTableQuery();\n \n \t\t\tList<Order> orders = Lists.newArrayList();\n-\n-\t\t\tcreateSort(myCriteriaBuilder, myQueryRoot, sort, orders);\n+\t\t\tcreateSort(myCriteriaBuilder, myQueryRootStack, sort, orders);\n \t\t\tif (orders.size() > 0) {\n-\t\t\t\touterQuery.orderBy(orders);\n+\t\t\t\tmyQueryRootStack.orderBy(orders);\n \t\t\t}\n \n \t\t} else {\n \n-\t\t\touterQuery = myCriteriaBuilder.createQuery(Long.class);\n-\t\t\tmyQueryRoot.push(outerQuery);\n \t\t\tif (theCount) {\n-\t\t\t\touterQuery.multiselect(myCriteriaBuilder.countDistinct(myQueryRoot.getRoot()));\n+\t\t\t\tmyQueryRootStack.pushResourceTableCountQuery();", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE0NjU0Nw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425146547", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif (!joinOpt.isPresent()) {\n          \n          \n            \n            \t\tif (joinOpt.isEmpty()) {", "author": "fil512", "createdAt": "2020-05-14T13:42:47Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/SearchBuilder.java", "diffHunk": "@@ -478,24 +438,27 @@ private boolean createSort(CriteriaBuilder theBuilder, QueryRoot theQueryRoot, S\n \t\t * sorting on, we'll also sort with it. Otherwise we need a new join.\n \t\t */\n \t\tSearchBuilderJoinKey key = new SearchBuilderJoinKey(theSort.getParamName(), joinType);\n-\t\tJoin<?, ?> join = theQueryRoot.getIndexJoin(key);\n-\t\tif (join == null) {\n-\t\t\tjoin = theQueryRoot.join(joinAttrName, JoinType.LEFT);\n+\t\tOptional<Join<?, ?>> joinOpt = theQueryRootStack.getExistingJoin(key);\n+\n+\t\tFrom<?, ?> join;\n+\t\tif (!joinOpt.isPresent()) {", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ2MjA1Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425462052", "bodyText": "isEmpty() is a JDK11 feature.. we can't use it in a JDK8 codebase", "author": "jamesagnew", "createdAt": "2020-05-14T22:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE0NjU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE0NjY1MA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425146650", "bodyText": "Nice!", "author": "fil512", "createdAt": "2020-05-14T13:42:56Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/SearchBuilder.java", "diffHunk": "@@ -478,24 +438,27 @@ private boolean createSort(CriteriaBuilder theBuilder, QueryRoot theQueryRoot, S\n \t\t * sorting on, we'll also sort with it. Otherwise we need a new join.\n \t\t */\n \t\tSearchBuilderJoinKey key = new SearchBuilderJoinKey(theSort.getParamName(), joinType);\n-\t\tJoin<?, ?> join = theQueryRoot.getIndexJoin(key);\n-\t\tif (join == null) {\n-\t\t\tjoin = theQueryRoot.join(joinAttrName, JoinType.LEFT);\n+\t\tOptional<Join<?, ?>> joinOpt = theQueryRootStack.getExistingJoin(key);", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE0ODI0NA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425148244", "bodyText": "For EMPI I added the concept of troubleshooting logs to hapi.  In the future, it might be handy to pull out logs like this into a dedicated query troubleshooting log.", "author": "fil512", "createdAt": "2020-05-14T13:45:03Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/SearchBuilder.java", "diffHunk": "@@ -478,24 +438,27 @@ private boolean createSort(CriteriaBuilder theBuilder, QueryRoot theQueryRoot, S\n \t\t * sorting on, we'll also sort with it. Otherwise we need a new join.\n \t\t */\n \t\tSearchBuilderJoinKey key = new SearchBuilderJoinKey(theSort.getParamName(), joinType);\n-\t\tJoin<?, ?> join = theQueryRoot.getIndexJoin(key);\n-\t\tif (join == null) {\n-\t\t\tjoin = theQueryRoot.join(joinAttrName, JoinType.LEFT);\n+\t\tOptional<Join<?, ?>> joinOpt = theQueryRootStack.getExistingJoin(key);\n+\n+\t\tFrom<?, ?> join;\n+\t\tif (!joinOpt.isPresent()) {\n+\t\t\tjoin = theQueryRootStack.createJoin(joinType, theSort.getParamName());\n \n \t\t\tif (param.getParamType() == RestSearchParameterTypeEnum.REFERENCE) {\n-\t\t\t\ttheQueryRoot.addPredicate(join.get(\"mySourcePath\").as(String.class).in(param.getPathsSplit()));\n+\t\t\t\ttheQueryRootStack.addPredicate(join.get(\"mySourcePath\").as(String.class).in(param.getPathsSplit()));\n \t\t\t} else {\n \t\t\t\tif (myDaoConfig.getDisableHashBasedSearches()) {\n \t\t\t\t\tPredicate joinParam1 = theBuilder.equal(join.get(\"myParamName\"), theSort.getParamName());\n-\t\t\t\t\ttheQueryRoot.addPredicate(joinParam1);\n+\t\t\t\t\ttheQueryRootStack.addPredicate(joinParam1);\n \t\t\t\t} else {\n \t\t\t\t\tLong hashIdentity = BaseResourceIndexedSearchParam.calculateHashIdentity(myPartitionSettings, myRequestPartitionId, myResourceName, theSort.getParamName());\n \t\t\t\t\tPredicate joinParam1 = theBuilder.equal(join.get(\"myHashIdentity\"), hashIdentity);\n-\t\t\t\t\ttheQueryRoot.addPredicate(joinParam1);\n+\t\t\t\t\ttheQueryRootStack.addPredicate(joinParam1);\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tourLog.debug(\"Reusing join for {}\", theSort.getParamName());", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ2MjQ0MA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425462440", "bodyText": "Oh interesting.. Yeah I could see it.", "author": "jamesagnew", "createdAt": "2020-05-14T22:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE0ODI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE2MDIwNQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425160205", "bodyText": "Awesome javadoc in this class.  Very helpful", "author": "fil512", "createdAt": "2020-05-14T14:00:52Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/querystack/QueryRootStack.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package ca.uhn.fhir.jpa.dao.predicate.querystack;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.interceptor.model.RequestPartitionId;\n+import ca.uhn.fhir.jpa.dao.predicate.SearchBuilderJoinEnum;\n+import ca.uhn.fhir.jpa.dao.predicate.SearchBuilderJoinKey;\n+import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n+import org.apache.commons.lang3.Validate;\n+\n+import javax.persistence.criteria.AbstractQuery;\n+import javax.persistence.criteria.CriteriaBuilder;\n+import javax.persistence.criteria.Expression;\n+import javax.persistence.criteria.From;\n+import javax.persistence.criteria.Join;\n+import javax.persistence.criteria.Order;\n+import javax.persistence.criteria.Path;\n+import javax.persistence.criteria.Predicate;\n+import javax.persistence.criteria.Root;\n+import javax.persistence.criteria.Subquery;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n+\n+/**\n+ * This class represents a SQL SELECT statement that is selecting for resource PIDs, ie.\n+ * the <code>RES_ID</code> column on the <code>HFJ_RESOURCE</code> ({@link ca.uhn.fhir.jpa.model.entity.ResourceTable})\n+ * table.\n+ * <p>\n+ * We add predicates (WHERE A=B) to it, and can join other tables to it as well. At the root of the query\n+ * we are typically doing a <code>select RES_ID from HFJ_RESOURCE where (....)</code> and this class\n+ * is used to build the <i>where</i> clause. In the case of subqueries though, we may be performing a\n+ * select on a different table since many tables have a column with a FK dependency on RES_ID.\n+ * </p>\n+ */\n+public class QueryRootStack {\n+\n+\tprivate final Stack<QueryRootEntry> myQueryRootStack = new Stack<>();\n+\tprivate final CriteriaBuilder myCriteriaBuilder;\n+\tprivate final SearchParameterMap mySearchParameterMap;\n+\tprivate final RequestPartitionId myRequestPartitionId;\n+\tprivate final String myResourceType;\n+\n+\t/**\n+\t * Constructor\n+\t */\n+\tpublic QueryRootStack(CriteriaBuilder theCriteriaBuilder, String theResourceType, SearchParameterMap theSearchParameterMap, RequestPartitionId theRequestPartitionId) {\n+\t\tassert theCriteriaBuilder != null;\n+\t\tassert isNotBlank(theResourceType);\n+\t\tassert theSearchParameterMap != null;\n+\t\tassert theRequestPartitionId != null;\n+\t\tmyCriteriaBuilder = theCriteriaBuilder;\n+\t\tmySearchParameterMap = theSearchParameterMap;\n+\t\tmyRequestPartitionId = theRequestPartitionId;\n+\t\tmyResourceType = theResourceType;\n+\t}\n+\n+\t/**\n+\t * Add a new <code>select RES_ID from HFJ_RESOURCE</code> to the stack. All predicates added to the {@literal QueryRootStack}", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE2MDQ4Mw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425160483", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * This method must be called once all predicated have been added\n          \n          \n            \n            \t * This method must be called once all predicates have been added", "author": "fil512", "createdAt": "2020-05-14T14:01:14Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/querystack/QueryRootStack.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package ca.uhn.fhir.jpa.dao.predicate.querystack;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.interceptor.model.RequestPartitionId;\n+import ca.uhn.fhir.jpa.dao.predicate.SearchBuilderJoinEnum;\n+import ca.uhn.fhir.jpa.dao.predicate.SearchBuilderJoinKey;\n+import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n+import org.apache.commons.lang3.Validate;\n+\n+import javax.persistence.criteria.AbstractQuery;\n+import javax.persistence.criteria.CriteriaBuilder;\n+import javax.persistence.criteria.Expression;\n+import javax.persistence.criteria.From;\n+import javax.persistence.criteria.Join;\n+import javax.persistence.criteria.Order;\n+import javax.persistence.criteria.Path;\n+import javax.persistence.criteria.Predicate;\n+import javax.persistence.criteria.Root;\n+import javax.persistence.criteria.Subquery;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n+\n+/**\n+ * This class represents a SQL SELECT statement that is selecting for resource PIDs, ie.\n+ * the <code>RES_ID</code> column on the <code>HFJ_RESOURCE</code> ({@link ca.uhn.fhir.jpa.model.entity.ResourceTable})\n+ * table.\n+ * <p>\n+ * We add predicates (WHERE A=B) to it, and can join other tables to it as well. At the root of the query\n+ * we are typically doing a <code>select RES_ID from HFJ_RESOURCE where (....)</code> and this class\n+ * is used to build the <i>where</i> clause. In the case of subqueries though, we may be performing a\n+ * select on a different table since many tables have a column with a FK dependency on RES_ID.\n+ * </p>\n+ */\n+public class QueryRootStack {\n+\n+\tprivate final Stack<QueryRootEntry> myQueryRootStack = new Stack<>();\n+\tprivate final CriteriaBuilder myCriteriaBuilder;\n+\tprivate final SearchParameterMap mySearchParameterMap;\n+\tprivate final RequestPartitionId myRequestPartitionId;\n+\tprivate final String myResourceType;\n+\n+\t/**\n+\t * Constructor\n+\t */\n+\tpublic QueryRootStack(CriteriaBuilder theCriteriaBuilder, String theResourceType, SearchParameterMap theSearchParameterMap, RequestPartitionId theRequestPartitionId) {\n+\t\tassert theCriteriaBuilder != null;\n+\t\tassert isNotBlank(theResourceType);\n+\t\tassert theSearchParameterMap != null;\n+\t\tassert theRequestPartitionId != null;\n+\t\tmyCriteriaBuilder = theCriteriaBuilder;\n+\t\tmySearchParameterMap = theSearchParameterMap;\n+\t\tmyRequestPartitionId = theRequestPartitionId;\n+\t\tmyResourceType = theResourceType;\n+\t}\n+\n+\t/**\n+\t * Add a new <code>select RES_ID from HFJ_RESOURCE</code> to the stack. All predicates added to the {@literal QueryRootStack}\n+\t * will be added to this select clause until {@link #pop()} is called.\n+\t * <p>\n+\t * This method must only be called when the stack is empty.\n+\t * </p>\n+\t */\n+\tpublic void pushResourceTableQuery() {\n+\t\tassert myQueryRootStack.isEmpty();\n+\t\tmyQueryRootStack.push(new QueryRootEntryResourceTable(myCriteriaBuilder, false, mySearchParameterMap, myResourceType, myRequestPartitionId));\n+\t}\n+\n+\t/**\n+\t * Add a new <code>select count(RES_ID) from HFJ_RESOURCE</code> to the stack. All predicates added to the {@literal QueryRootStack}\n+\t * will be added to this select clause until {@link #pop()} is called.\n+\t * <p>\n+\t * This method must only be called when the stack is empty.\n+\t * </p>\n+\t */\n+\tpublic void pushResourceTableCountQuery() {\n+\t\tassert myQueryRootStack.isEmpty();\n+\t\tmyQueryRootStack.push(new QueryRootEntryResourceTable(myCriteriaBuilder, true, mySearchParameterMap, myResourceType, myRequestPartitionId));\n+\t}\n+\n+\t/**\n+\t * Add a new <code>select RES_ID from HFJ_RESOURCE</code> to the stack. All predicates added to the {@literal QueryRootStack}\n+\t * will be added to this select clause until {@link #pop()} is called.\n+\t * <p>\n+\t * This method must only be called when the stack is NOT empty.\n+\t * </p>\n+\t */\n+\tpublic void pushResourceTableSubQuery(String theResourceType) {\n+\t\tassert !myQueryRootStack.isEmpty();\n+\t\tmyQueryRootStack.push(new QueryRootEntryResourceTable(myCriteriaBuilder, top(), mySearchParameterMap, theResourceType, myRequestPartitionId));\n+\t}\n+\n+\t/**\n+\t * Add a new <code>select RES_ID from (....)</code> to the stack, where the specific table being selected on will be\n+\t * determined based on the first call to {@link #createJoin(SearchBuilderJoinEnum, String)}. All predicates added\n+\t * to the {@literal QueryRootStack} will be added to this select clause until {@link #pop()} is called.\n+\t * <p>\n+\t * This method must only be called when the stack is NOT empty.\n+\t * </p>\n+\t */\n+\tpublic void pushIndexTableSubQuery() {\n+\t\tassert !myQueryRootStack.isEmpty();\n+\t\tmyQueryRootStack.push(new QueryRootEntryIndexTable(myCriteriaBuilder, top()));\n+\t}\n+\n+\t/**\n+\t * This method must be called once all predicated have been added", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE2NjExNQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425166115", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * This should really be package protected, but it is called externally in one spot - We need to clean that up\n          \n          \n            \n            \t * TODO This should really be package protected, but it is called externally in one spot - We need to clean that up", "author": "fil512", "createdAt": "2020-05-14T14:09:07Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/querystack/QueryRootStack.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package ca.uhn.fhir.jpa.dao.predicate.querystack;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.interceptor.model.RequestPartitionId;\n+import ca.uhn.fhir.jpa.dao.predicate.SearchBuilderJoinEnum;\n+import ca.uhn.fhir.jpa.dao.predicate.SearchBuilderJoinKey;\n+import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n+import org.apache.commons.lang3.Validate;\n+\n+import javax.persistence.criteria.AbstractQuery;\n+import javax.persistence.criteria.CriteriaBuilder;\n+import javax.persistence.criteria.Expression;\n+import javax.persistence.criteria.From;\n+import javax.persistence.criteria.Join;\n+import javax.persistence.criteria.Order;\n+import javax.persistence.criteria.Path;\n+import javax.persistence.criteria.Predicate;\n+import javax.persistence.criteria.Root;\n+import javax.persistence.criteria.Subquery;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n+\n+/**\n+ * This class represents a SQL SELECT statement that is selecting for resource PIDs, ie.\n+ * the <code>RES_ID</code> column on the <code>HFJ_RESOURCE</code> ({@link ca.uhn.fhir.jpa.model.entity.ResourceTable})\n+ * table.\n+ * <p>\n+ * We add predicates (WHERE A=B) to it, and can join other tables to it as well. At the root of the query\n+ * we are typically doing a <code>select RES_ID from HFJ_RESOURCE where (....)</code> and this class\n+ * is used to build the <i>where</i> clause. In the case of subqueries though, we may be performing a\n+ * select on a different table since many tables have a column with a FK dependency on RES_ID.\n+ * </p>\n+ */\n+public class QueryRootStack {\n+\n+\tprivate final Stack<QueryRootEntry> myQueryRootStack = new Stack<>();\n+\tprivate final CriteriaBuilder myCriteriaBuilder;\n+\tprivate final SearchParameterMap mySearchParameterMap;\n+\tprivate final RequestPartitionId myRequestPartitionId;\n+\tprivate final String myResourceType;\n+\n+\t/**\n+\t * Constructor\n+\t */\n+\tpublic QueryRootStack(CriteriaBuilder theCriteriaBuilder, String theResourceType, SearchParameterMap theSearchParameterMap, RequestPartitionId theRequestPartitionId) {\n+\t\tassert theCriteriaBuilder != null;\n+\t\tassert isNotBlank(theResourceType);\n+\t\tassert theSearchParameterMap != null;\n+\t\tassert theRequestPartitionId != null;\n+\t\tmyCriteriaBuilder = theCriteriaBuilder;\n+\t\tmySearchParameterMap = theSearchParameterMap;\n+\t\tmyRequestPartitionId = theRequestPartitionId;\n+\t\tmyResourceType = theResourceType;\n+\t}\n+\n+\t/**\n+\t * Add a new <code>select RES_ID from HFJ_RESOURCE</code> to the stack. All predicates added to the {@literal QueryRootStack}\n+\t * will be added to this select clause until {@link #pop()} is called.\n+\t * <p>\n+\t * This method must only be called when the stack is empty.\n+\t * </p>\n+\t */\n+\tpublic void pushResourceTableQuery() {\n+\t\tassert myQueryRootStack.isEmpty();\n+\t\tmyQueryRootStack.push(new QueryRootEntryResourceTable(myCriteriaBuilder, false, mySearchParameterMap, myResourceType, myRequestPartitionId));\n+\t}\n+\n+\t/**\n+\t * Add a new <code>select count(RES_ID) from HFJ_RESOURCE</code> to the stack. All predicates added to the {@literal QueryRootStack}\n+\t * will be added to this select clause until {@link #pop()} is called.\n+\t * <p>\n+\t * This method must only be called when the stack is empty.\n+\t * </p>\n+\t */\n+\tpublic void pushResourceTableCountQuery() {\n+\t\tassert myQueryRootStack.isEmpty();\n+\t\tmyQueryRootStack.push(new QueryRootEntryResourceTable(myCriteriaBuilder, true, mySearchParameterMap, myResourceType, myRequestPartitionId));\n+\t}\n+\n+\t/**\n+\t * Add a new <code>select RES_ID from HFJ_RESOURCE</code> to the stack. All predicates added to the {@literal QueryRootStack}\n+\t * will be added to this select clause until {@link #pop()} is called.\n+\t * <p>\n+\t * This method must only be called when the stack is NOT empty.\n+\t * </p>\n+\t */\n+\tpublic void pushResourceTableSubQuery(String theResourceType) {\n+\t\tassert !myQueryRootStack.isEmpty();\n+\t\tmyQueryRootStack.push(new QueryRootEntryResourceTable(myCriteriaBuilder, top(), mySearchParameterMap, theResourceType, myRequestPartitionId));\n+\t}\n+\n+\t/**\n+\t * Add a new <code>select RES_ID from (....)</code> to the stack, where the specific table being selected on will be\n+\t * determined based on the first call to {@link #createJoin(SearchBuilderJoinEnum, String)}. All predicates added\n+\t * to the {@literal QueryRootStack} will be added to this select clause until {@link #pop()} is called.\n+\t * <p>\n+\t * This method must only be called when the stack is NOT empty.\n+\t * </p>\n+\t */\n+\tpublic void pushIndexTableSubQuery() {\n+\t\tassert !myQueryRootStack.isEmpty();\n+\t\tmyQueryRootStack.push(new QueryRootEntryIndexTable(myCriteriaBuilder, top()));\n+\t}\n+\n+\t/**\n+\t * This method must be called once all predicated have been added\n+\t */\n+\tpublic AbstractQuery<Long> pop() {\n+\t\tQueryRootEntry element = myQueryRootStack.pop();\n+\t\treturn element.pop();\n+\t}\n+\n+\t/**\n+\t * Creates a new SQL join from the current select statement to another table, using the resource PID as the\n+\t * joining key\n+\t */\n+\tpublic <T> From<?, T> createJoin(SearchBuilderJoinEnum theType, String theSearchParameterName) {\n+\t\treturn top().createJoin(theType, theSearchParameterName);\n+\t}\n+\n+\t/**\n+\t * Returns a join that was previously created by a call to {@link #createJoin(SearchBuilderJoinEnum, String)},\n+\t * if one exists for the given key.\n+\t */\n+\tpublic Optional<Join<?, ?>> getExistingJoin(SearchBuilderJoinKey theKey) {\n+\t\treturn top().getIndexJoin(theKey);\n+\t}\n+\n+\t/**\n+\t * Gets an attribute (aka a column) from the current select statement.\n+\t *\n+\t * @param theAttributeName Must be the name of a java field for the entity/table being selected on\n+\t */\n+\tpublic <Y> Path<Y> get(String theAttributeName) {\n+\t\treturn top().get(theAttributeName);\n+\t}\n+\n+\t/**\n+\t * Adds a predicate to the current select statement\n+\t */\n+\tpublic void addPredicate(Predicate thePredicate) {\n+\t\ttop().addPredicate(thePredicate);\n+\t}\n+\n+\t/**\n+\t * Adds predicate(s) to the current select statement\n+\t */\n+\tpublic void addPredicates(List<Predicate> thePredicates) {\n+\t\ttop().addPredicates(thePredicates);\n+\t}\n+\n+\t/**\n+\t * Clear all predicates from the current select statement\n+\t */\n+\tpublic void clearPredicates() {\n+\t\ttop().clearPredicates();\n+\t}\n+\n+\t/**\n+\t * Fetch all the current predicates\n+\t * <p>\n+\t * This should really be package protected, but it is called externally in one spot - We need to clean that up", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE2NzYyOA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425167628", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * This class should avoid leaking the internal query root, but we need to do so for how composite search params are\n          \n          \n            \n            \t * TODO This class should avoid leaking the internal query root, but we need to do so for how composite search params are", "author": "fil512", "createdAt": "2020-05-14T14:11:05Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/querystack/QueryRootStack.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package ca.uhn.fhir.jpa.dao.predicate.querystack;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.interceptor.model.RequestPartitionId;\n+import ca.uhn.fhir.jpa.dao.predicate.SearchBuilderJoinEnum;\n+import ca.uhn.fhir.jpa.dao.predicate.SearchBuilderJoinKey;\n+import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n+import org.apache.commons.lang3.Validate;\n+\n+import javax.persistence.criteria.AbstractQuery;\n+import javax.persistence.criteria.CriteriaBuilder;\n+import javax.persistence.criteria.Expression;\n+import javax.persistence.criteria.From;\n+import javax.persistence.criteria.Join;\n+import javax.persistence.criteria.Order;\n+import javax.persistence.criteria.Path;\n+import javax.persistence.criteria.Predicate;\n+import javax.persistence.criteria.Root;\n+import javax.persistence.criteria.Subquery;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n+\n+/**\n+ * This class represents a SQL SELECT statement that is selecting for resource PIDs, ie.\n+ * the <code>RES_ID</code> column on the <code>HFJ_RESOURCE</code> ({@link ca.uhn.fhir.jpa.model.entity.ResourceTable})\n+ * table.\n+ * <p>\n+ * We add predicates (WHERE A=B) to it, and can join other tables to it as well. At the root of the query\n+ * we are typically doing a <code>select RES_ID from HFJ_RESOURCE where (....)</code> and this class\n+ * is used to build the <i>where</i> clause. In the case of subqueries though, we may be performing a\n+ * select on a different table since many tables have a column with a FK dependency on RES_ID.\n+ * </p>\n+ */\n+public class QueryRootStack {\n+\n+\tprivate final Stack<QueryRootEntry> myQueryRootStack = new Stack<>();\n+\tprivate final CriteriaBuilder myCriteriaBuilder;\n+\tprivate final SearchParameterMap mySearchParameterMap;\n+\tprivate final RequestPartitionId myRequestPartitionId;\n+\tprivate final String myResourceType;\n+\n+\t/**\n+\t * Constructor\n+\t */\n+\tpublic QueryRootStack(CriteriaBuilder theCriteriaBuilder, String theResourceType, SearchParameterMap theSearchParameterMap, RequestPartitionId theRequestPartitionId) {\n+\t\tassert theCriteriaBuilder != null;\n+\t\tassert isNotBlank(theResourceType);\n+\t\tassert theSearchParameterMap != null;\n+\t\tassert theRequestPartitionId != null;\n+\t\tmyCriteriaBuilder = theCriteriaBuilder;\n+\t\tmySearchParameterMap = theSearchParameterMap;\n+\t\tmyRequestPartitionId = theRequestPartitionId;\n+\t\tmyResourceType = theResourceType;\n+\t}\n+\n+\t/**\n+\t * Add a new <code>select RES_ID from HFJ_RESOURCE</code> to the stack. All predicates added to the {@literal QueryRootStack}\n+\t * will be added to this select clause until {@link #pop()} is called.\n+\t * <p>\n+\t * This method must only be called when the stack is empty.\n+\t * </p>\n+\t */\n+\tpublic void pushResourceTableQuery() {\n+\t\tassert myQueryRootStack.isEmpty();\n+\t\tmyQueryRootStack.push(new QueryRootEntryResourceTable(myCriteriaBuilder, false, mySearchParameterMap, myResourceType, myRequestPartitionId));\n+\t}\n+\n+\t/**\n+\t * Add a new <code>select count(RES_ID) from HFJ_RESOURCE</code> to the stack. All predicates added to the {@literal QueryRootStack}\n+\t * will be added to this select clause until {@link #pop()} is called.\n+\t * <p>\n+\t * This method must only be called when the stack is empty.\n+\t * </p>\n+\t */\n+\tpublic void pushResourceTableCountQuery() {\n+\t\tassert myQueryRootStack.isEmpty();\n+\t\tmyQueryRootStack.push(new QueryRootEntryResourceTable(myCriteriaBuilder, true, mySearchParameterMap, myResourceType, myRequestPartitionId));\n+\t}\n+\n+\t/**\n+\t * Add a new <code>select RES_ID from HFJ_RESOURCE</code> to the stack. All predicates added to the {@literal QueryRootStack}\n+\t * will be added to this select clause until {@link #pop()} is called.\n+\t * <p>\n+\t * This method must only be called when the stack is NOT empty.\n+\t * </p>\n+\t */\n+\tpublic void pushResourceTableSubQuery(String theResourceType) {\n+\t\tassert !myQueryRootStack.isEmpty();\n+\t\tmyQueryRootStack.push(new QueryRootEntryResourceTable(myCriteriaBuilder, top(), mySearchParameterMap, theResourceType, myRequestPartitionId));\n+\t}\n+\n+\t/**\n+\t * Add a new <code>select RES_ID from (....)</code> to the stack, where the specific table being selected on will be\n+\t * determined based on the first call to {@link #createJoin(SearchBuilderJoinEnum, String)}. All predicates added\n+\t * to the {@literal QueryRootStack} will be added to this select clause until {@link #pop()} is called.\n+\t * <p>\n+\t * This method must only be called when the stack is NOT empty.\n+\t * </p>\n+\t */\n+\tpublic void pushIndexTableSubQuery() {\n+\t\tassert !myQueryRootStack.isEmpty();\n+\t\tmyQueryRootStack.push(new QueryRootEntryIndexTable(myCriteriaBuilder, top()));\n+\t}\n+\n+\t/**\n+\t * This method must be called once all predicated have been added\n+\t */\n+\tpublic AbstractQuery<Long> pop() {\n+\t\tQueryRootEntry element = myQueryRootStack.pop();\n+\t\treturn element.pop();\n+\t}\n+\n+\t/**\n+\t * Creates a new SQL join from the current select statement to another table, using the resource PID as the\n+\t * joining key\n+\t */\n+\tpublic <T> From<?, T> createJoin(SearchBuilderJoinEnum theType, String theSearchParameterName) {\n+\t\treturn top().createJoin(theType, theSearchParameterName);\n+\t}\n+\n+\t/**\n+\t * Returns a join that was previously created by a call to {@link #createJoin(SearchBuilderJoinEnum, String)},\n+\t * if one exists for the given key.\n+\t */\n+\tpublic Optional<Join<?, ?>> getExistingJoin(SearchBuilderJoinKey theKey) {\n+\t\treturn top().getIndexJoin(theKey);\n+\t}\n+\n+\t/**\n+\t * Gets an attribute (aka a column) from the current select statement.\n+\t *\n+\t * @param theAttributeName Must be the name of a java field for the entity/table being selected on\n+\t */\n+\tpublic <Y> Path<Y> get(String theAttributeName) {\n+\t\treturn top().get(theAttributeName);\n+\t}\n+\n+\t/**\n+\t * Adds a predicate to the current select statement\n+\t */\n+\tpublic void addPredicate(Predicate thePredicate) {\n+\t\ttop().addPredicate(thePredicate);\n+\t}\n+\n+\t/**\n+\t * Adds predicate(s) to the current select statement\n+\t */\n+\tpublic void addPredicates(List<Predicate> thePredicates) {\n+\t\ttop().addPredicates(thePredicates);\n+\t}\n+\n+\t/**\n+\t * Clear all predicates from the current select statement\n+\t */\n+\tpublic void clearPredicates() {\n+\t\ttop().clearPredicates();\n+\t}\n+\n+\t/**\n+\t * Fetch all the current predicates\n+\t * <p>\n+\t * This should really be package protected, but it is called externally in one spot - We need to clean that up\n+\t * at some point.\n+\t */\n+\tpublic List<Predicate> getPredicates() {\n+\t\treturn top().getPredicates();\n+\t}\n+\n+\t/**\n+\t * Call this method if a join has been created against this root that will ensure:\n+\t * <ul>\n+\t *    <li>Only Resource PIDs for the correct resource type will be selected</li>\n+\t *    <li>Only Resource PIDs for non-deleted resources will be selected</li>\n+\t * </ul>\n+\t * Setting this flag is a performance optimization, since it avoids the need for us to explicitly\n+\t * add predicates for the two conditions above.\n+\t */\n+\tpublic void setHasIndexJoins() {\n+\t\ttop().setHasIndexJoins(true);\n+\t}\n+\n+\t/**\n+\t * @see #setHasIndexJoins()\n+\t */\n+\tpublic void clearHasIndexJoins() {\n+\t\ttop().setHasIndexJoins(false);\n+\t}\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn myQueryRootStack.isEmpty();\n+\t}\n+\n+\t/**\n+\t * Add an SQL <code>order by</code> expression\n+\t */\n+\tpublic void orderBy(List<Order> theOrders) {\n+\t\ttop().orderBy(theOrders);\n+\t}\n+\n+\t/**\n+\t * Fetch the column for the current table root that corresponds to the resource's lastUpdated time\n+\t */\n+\tpublic Expression<Date> getLastUpdatedColumn() {\n+\t\treturn top().getLastUpdatedColumn();\n+\t}\n+\n+\t/**\n+\t * Fetch the column for the current table root that corresponds to the resource's PID\n+\t */\n+\tpublic Expression<Long> getResourcePidColumn() {\n+\t\treturn top().getResourcePidColumn();\n+\t}\n+\n+\tpublic Subquery<Long> subqueryForTagNegation() {\n+\t\treturn top().subqueryForTagNegation();\n+\t}\n+\n+\tprivate QueryRootEntry top() {\n+\t\tValidate.isTrue(!myQueryRootStack.empty());\n+\t\treturn myQueryRootStack.peek();\n+\t}\n+\n+\t/**\n+\t * This class should avoid leaking the internal query root, but we need to do so for how composite search params are", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3MDA2OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425170069", "bodyText": "nitpick: consolidate repeated code", "author": "fil512", "createdAt": "2020-05-14T14:14:19Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/querystack/QueryRootEntryIndexTable.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package ca.uhn.fhir.jpa.dao.predicate.querystack;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.jpa.dao.predicate.SearchBuilderJoinEnum;\n+import ca.uhn.fhir.jpa.model.entity.BaseResourceIndex;\n+import ca.uhn.fhir.jpa.model.entity.ResourceIndexedSearchParamCoords;\n+import ca.uhn.fhir.jpa.model.entity.ResourceIndexedSearchParamDate;\n+import ca.uhn.fhir.jpa.model.entity.ResourceIndexedSearchParamNumber;\n+import ca.uhn.fhir.jpa.model.entity.ResourceIndexedSearchParamQuantity;\n+import ca.uhn.fhir.jpa.model.entity.ResourceIndexedSearchParamString;\n+import ca.uhn.fhir.jpa.model.entity.ResourceIndexedSearchParamToken;\n+import ca.uhn.fhir.jpa.model.entity.ResourceIndexedSearchParamUri;\n+import ca.uhn.fhir.jpa.model.entity.ResourceLink;\n+import org.apache.commons.lang3.Validate;\n+\n+import javax.persistence.criteria.AbstractQuery;\n+import javax.persistence.criteria.CriteriaBuilder;\n+import javax.persistence.criteria.Expression;\n+import javax.persistence.criteria.From;\n+import javax.persistence.criteria.Order;\n+import javax.persistence.criteria.Root;\n+import javax.persistence.criteria.Subquery;\n+import java.util.Date;\n+import java.util.List;\n+\n+public class QueryRootEntryIndexTable extends QueryRootEntry {\n+\tprivate final Subquery<Long> myQuery;\n+\tprivate Root<? extends BaseResourceIndex> myRoot;\n+\tprivate SearchBuilderJoinEnum myParamType;\n+\tprivate Expression<Long> myResourcePidColumn;\n+\n+\tpublic QueryRootEntryIndexTable(CriteriaBuilder theCriteriaBuilder, QueryRootEntry theParent) {\n+\t\tsuper(theCriteriaBuilder);\n+\n+\t\tAbstractQuery<Long> queryRoot = theParent.getQueryRoot();\n+\t\tmyQuery = queryRoot.subquery(Long.class);\n+\t}\n+\n+\t@Override\n+\tvoid orderBy(List<Order> theOrders) {\n+\t\tthrow new IllegalStateException();\n+\t}\n+\n+\t@Override\n+\tExpression<Date> getLastUpdatedColumn() {\n+\t\treturn getRoot().get(\"myUpdated\").as(Date.class);\n+\t}\n+\n+\t@Override\n+\t<T> From<?, T> createJoin(SearchBuilderJoinEnum theType, String theSearchParameterName) {\n+\t\tif (myParamType == null) {\n+\t\t\tswitch (theType) {\n+\t\t\t\tcase REFERENCE:\n+\t\t\t\t\tmyRoot = myQuery.from(ResourceLink.class);\n+\t\t\t\t\tthis.myResourcePidColumn = myRoot.get(\"mySourceResourcePid\").as(Long.class);\n+\t\t\t\t\tmyParamType = SearchBuilderJoinEnum.REFERENCE;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase NUMBER:\n+\t\t\t\t\tmyRoot = myQuery.from(ResourceIndexedSearchParamNumber.class);\n+\t\t\t\t\tmyResourcePidColumn = myRoot.get(\"myResourcePid\").as(Long.class);\n+\t\t\t\t\tmyParamType = SearchBuilderJoinEnum.NUMBER;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase DATE:\n+\t\t\t\t\tmyRoot = myQuery.from(ResourceIndexedSearchParamDate.class);\n+\t\t\t\t\tmyResourcePidColumn = myRoot.get(\"myResourcePid\").as(Long.class);\n+\t\t\t\t\tmyParamType = SearchBuilderJoinEnum.DATE;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase STRING:\n+\t\t\t\t\tmyRoot = myQuery.from(ResourceIndexedSearchParamString.class);\n+\t\t\t\t\tmyResourcePidColumn = myRoot.get(\"myResourcePid\").as(Long.class);\n+\t\t\t\t\tmyParamType = SearchBuilderJoinEnum.STRING;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase TOKEN:\n+\t\t\t\t\tmyRoot = myQuery.from(ResourceIndexedSearchParamToken.class);\n+\t\t\t\t\tmyResourcePidColumn = myRoot.get(\"myResourcePid\").as(Long.class);\n+\t\t\t\t\tmyParamType = SearchBuilderJoinEnum.TOKEN;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase QUANTITY:\n+\t\t\t\t\tmyRoot = myQuery.from(ResourceIndexedSearchParamQuantity.class);\n+\t\t\t\t\tmyResourcePidColumn = myRoot.get(\"myResourcePid\").as(Long.class);\n+\t\t\t\t\tmyParamType = SearchBuilderJoinEnum.QUANTITY;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase URI:\n+\t\t\t\t\tmyRoot = myQuery.from(ResourceIndexedSearchParamUri.class);\n+\t\t\t\t\tmyResourcePidColumn = myRoot.get(\"myResourcePid\").as(Long.class);\n+\t\t\t\t\tmyParamType = SearchBuilderJoinEnum.URI;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase COORDS:\n+\t\t\t\t\tmyRoot = myQuery.from(ResourceIndexedSearchParamCoords.class);\n+\t\t\t\t\tmyResourcePidColumn = myRoot.get(\"myResourcePid\").as(Long.class);", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ2OTg3MQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425469871", "bodyText": "I thought about it here, and it's only one line that is repeated and \"fixing\" it IMO would make this less readable...", "author": "jamesagnew", "createdAt": "2020-05-14T22:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3MDA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3MDc3OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425170779", "bodyText": "move to method javadoc", "author": "fil512", "createdAt": "2020-05-14T14:15:14Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/querystack/QueryRootEntryResourceTable.java", "diffHunk": "@@ -0,0 +1,205 @@\n+package ca.uhn.fhir.jpa.dao.predicate.querystack;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.interceptor.model.RequestPartitionId;\n+import ca.uhn.fhir.jpa.dao.predicate.SearchBuilderJoinEnum;\n+import ca.uhn.fhir.jpa.dao.predicate.SearchBuilderJoinKey;\n+import ca.uhn.fhir.jpa.model.entity.ResourceTable;\n+import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n+\n+import javax.persistence.criteria.AbstractQuery;\n+import javax.persistence.criteria.CriteriaBuilder;\n+import javax.persistence.criteria.CriteriaQuery;\n+import javax.persistence.criteria.Expression;\n+import javax.persistence.criteria.From;\n+import javax.persistence.criteria.Join;\n+import javax.persistence.criteria.JoinType;\n+import javax.persistence.criteria.Order;\n+import javax.persistence.criteria.Root;\n+import javax.persistence.criteria.Subquery;\n+import java.util.Date;\n+import java.util.List;\n+\n+class QueryRootEntryResourceTable extends QueryRootEntry {\n+\n+\tprivate final CriteriaBuilder myCriteriaBuilder;\n+\tprivate final AbstractQuery<Long> myQuery;\n+\tprivate final SearchParameterMap mySearchParameterMap;\n+\tprivate final RequestPartitionId myRequestPartitionId;\n+\tprivate final String myResourceType;\n+\n+\t@Override\n+\tAbstractQuery<Long> pop() {\n+\n+\t\t/*", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3MDI4NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425470285", "bodyText": "done", "author": "jamesagnew", "createdAt": "2020-05-14T22:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3MDc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3NzE1OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425177158", "bodyText": "I like how clean this method reads.\nI've been trying to find the magic of how you resolved the issue, and I'm wondering if this is it.  I see this was moved out of the predicate and into here, and that there are a bunch of new entries added--was adding those new entries to the join logic the key to optimizing the query?  The idea being that we float these joins up to the top and consolidate them there...?", "author": "fil512", "createdAt": "2020-05-14T14:23:39Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/querystack/QueryRootEntryResourceTable.java", "diffHunk": "@@ -0,0 +1,205 @@\n+package ca.uhn.fhir.jpa.dao.predicate.querystack;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.interceptor.model.RequestPartitionId;\n+import ca.uhn.fhir.jpa.dao.predicate.SearchBuilderJoinEnum;\n+import ca.uhn.fhir.jpa.dao.predicate.SearchBuilderJoinKey;\n+import ca.uhn.fhir.jpa.model.entity.ResourceTable;\n+import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n+\n+import javax.persistence.criteria.AbstractQuery;\n+import javax.persistence.criteria.CriteriaBuilder;\n+import javax.persistence.criteria.CriteriaQuery;\n+import javax.persistence.criteria.Expression;\n+import javax.persistence.criteria.From;\n+import javax.persistence.criteria.Join;\n+import javax.persistence.criteria.JoinType;\n+import javax.persistence.criteria.Order;\n+import javax.persistence.criteria.Root;\n+import javax.persistence.criteria.Subquery;\n+import java.util.Date;\n+import java.util.List;\n+\n+class QueryRootEntryResourceTable extends QueryRootEntry {\n+\n+\tprivate final CriteriaBuilder myCriteriaBuilder;\n+\tprivate final AbstractQuery<Long> myQuery;\n+\tprivate final SearchParameterMap mySearchParameterMap;\n+\tprivate final RequestPartitionId myRequestPartitionId;\n+\tprivate final String myResourceType;\n+\n+\t@Override\n+\tAbstractQuery<Long> pop() {\n+\n+\t\t/*\n+\t\t * Add a predicate to make sure we only include non-deleted resources, and only include\n+\t\t * resources of the right type.\n+\t\t *\n+\t\t * If we have any joins to index tables, we get this behaviour already guaranteed so we don't\n+\t\t * need an explicit predicate for it.\n+\t\t */\n+\t\tif (!isHasIndexJoins()) {\n+\t\t\tif (mySearchParameterMap.getEverythingMode() == null) {\n+\t\t\t\taddPredicate(myCriteriaBuilder.equal(getRoot().get(\"myResourceType\"), myResourceType));\n+\t\t\t}\n+\t\t\taddPredicate(myCriteriaBuilder.isNull(getRoot().get(\"myDeleted\")));\n+\t\t\tif (!myRequestPartitionId.isAllPartitions()) {\n+\t\t\t\tif (myRequestPartitionId.getPartitionId() != null) {\n+\t\t\t\t\taddPredicate(myCriteriaBuilder.equal(getRoot().get(\"myPartitionIdValue\").as(Integer.class), myRequestPartitionId.getPartitionId()));\n+\t\t\t\t} else {\n+\t\t\t\t\taddPredicate(myCriteriaBuilder.isNull(getRoot().get(\"myPartitionIdValue\").as(Integer.class)));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn super.pop();\n+\t}\n+\n+\tprivate final Root<ResourceTable> myResourceTableRoot;\n+\n+\t/**\n+\t * Root query constructor\n+\t */\n+\tQueryRootEntryResourceTable(CriteriaBuilder theCriteriaBuilder, boolean theCountQuery, SearchParameterMap theSearchParameterMap, String theResourceType, RequestPartitionId theRequestPartitionId) {\n+\t\tsuper(theCriteriaBuilder);\n+\t\tmyCriteriaBuilder = theCriteriaBuilder;\n+\t\tmySearchParameterMap = theSearchParameterMap;\n+\t\tmyRequestPartitionId = theRequestPartitionId;\n+\t\tmyResourceType = theResourceType;\n+\n+\t\tCriteriaQuery<Long> query = myCriteriaBuilder.createQuery(Long.class);\n+\t\tmyResourceTableRoot = query.from(ResourceTable.class);\n+\n+\t\tif (theCountQuery) {\n+\t\t\tquery.multiselect(myCriteriaBuilder.countDistinct(myResourceTableRoot));\n+\t\t} else {\n+\t\t\tquery.multiselect(get(\"myId\").as(Long.class));\n+\t\t}\n+\t\tmyQuery = query;\n+\t}\n+\n+\t/**\n+\t * Subquery constructor\n+\t */\n+\tQueryRootEntryResourceTable(CriteriaBuilder theCriteriaBuilder, QueryRootEntry theParent, SearchParameterMap theSearchParameterMap, String theResourceType, RequestPartitionId theRequestPartitionId) {\n+\t\tsuper(theCriteriaBuilder);\n+\t\tmyCriteriaBuilder = theCriteriaBuilder;\n+\t\tmySearchParameterMap = theSearchParameterMap;\n+\t\tmyRequestPartitionId = theRequestPartitionId;\n+\t\tmyResourceType = theResourceType;\n+\n+\t\tAbstractQuery<Long> queryRoot = theParent.getQueryRoot();\n+\t\tSubquery<Long> query = queryRoot.subquery(Long.class);\n+\t\tmyQuery = query;\n+\t\tmyResourceTableRoot = myQuery.from(ResourceTable.class);\n+\t\tquery.select(myResourceTableRoot.get(\"myId\").as(Long.class));\n+\t}\n+\n+\t@Override\n+\tvoid orderBy(List<Order> theOrders) {\n+\t\tassert myQuery instanceof CriteriaQuery;\n+\n+\t\t((CriteriaQuery<?>)myQuery).orderBy(theOrders);\n+\t}\n+\n+\t@Override\n+\tExpression<Date> getLastUpdatedColumn() {\n+\t\treturn myResourceTableRoot.get(\"myUpdated\").as(Date.class);\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t@Override\n+\t<T> From<?, T> createJoin(SearchBuilderJoinEnum theType, String theSearchParameterName) {", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3MTA4OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425471088", "bodyText": "Close- The actual magic here is that this method doesn't get called at all when we're doing a chain (another implementation does instead)\nThis method creates and adds a new join against HFJ_RESOURCE, which is fine in cases where we can have 0..N JOINs at the same root. But the very nature of a chain is that there can only be one join, so for that we use QueryRootEntryIndexTable which just makes the target of the join be the root instead of doing any join at all... if that makes sense...", "author": "jamesagnew", "createdAt": "2020-05-14T22:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3NzE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4MTg0Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425181842", "bodyText": "Nitpick: please break up this method.  it is long and difficult to follow.", "author": "fil512", "createdAt": "2020-05-14T14:29:30Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderReference.java", "diffHunk": "@@ -269,7 +268,7 @@ public Predicate addPredicate(String theResourceName,\n \t * This is for handling queries like the following: /Observation?device.identifier=urn:system|foo in which we use a chain\n \t * on the device.\n \t */\n-\tprivate Predicate addPredicateReferenceWithChain(String theResourceName, String theParamName, List<? extends IQueryParameterType> theList, Join<ResourceTable, ResourceLink> theJoin, List<Predicate> theCodePredicates, ReferenceParam theReferenceParam, RequestDetails theRequest, RequestPartitionId theRequestPartitionId) {\n+\tprivate Predicate addPredicateReferenceWithChain(String theResourceName, String theParamName, List<? extends IQueryParameterType> theList, From<?, ResourceLink> theJoin, List<Predicate> theCodePredicates, ReferenceParam theReferenceParam, RequestDetails theRequest, RequestPartitionId theRequestPartitionId) {", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3MzA4MA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425473080", "bodyText": "done", "author": "jamesagnew", "createdAt": "2020-05-14T22:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4MTg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4NjMxMQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425186311", "bodyText": "Nice.  Im curious, do we know that this is an optimization?\nI assume we've ruled out the size==0 case somewhere above?", "author": "fil512", "createdAt": "2020-05-14T14:35:29Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderToken.java", "diffHunk": "@@ -375,7 +373,13 @@ private Predicate addPredicate(String theResourceName, String theParamName, Crit\n \t\t\t\tbreak;\n \t\t}\n \n-\t\tPredicate predicate = hashField.in(values);\n+\t\tPredicate predicate;\n+\t\tif (values.size() == 1) {", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3MzU3Nw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425473577", "bodyText": "size==0 is definitely ruled out, since .in(  emptylist ) already throws an error\nTruthfully I don't know if this is an optimization or not (though it certainly can't hurt)- I just found that it makes the generated SQL much easier to read. So I guess it's a human optimization.", "author": "jamesagnew", "createdAt": "2020-05-14T22:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE4NjMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE5MDAzOA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425190038", "bodyText": "Nice!", "author": "fil512", "createdAt": "2020-05-14T14:40:27Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4QueryCountTest.java", "diffHunk": "@@ -457,6 +459,37 @@ public void testSearchUsingForcedIdReference_DeletedDisabled() {\n \t\tassertEquals(0, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n \t\tassertEquals(0, myCaptureQueriesListener.countDeleteQueriesForCurrentThread());\n \t}\n+\n+\n+\t@Test\n+\tpublic void testSearchOnChainedToken() {\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"P\");\n+\t\tpatient.addIdentifier().setSystem(\"sys\").setValue(\"val\");\n+\t\tmyPatientDao.update(patient);\n+\n+\t\tObservation obs = new Observation();\n+\t\tobs.setId(\"O\");\n+\t\tobs.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.update(obs);\n+\n+\t\tSearchParameterMap map = new SearchParameterMap();\n+\t\tmap.setLoadSynchronous(true);\n+\t\tmap.add(Observation.SP_SUBJECT, new ReferenceParam(\"identifier\", \"sys|val\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tIBundleProvider outcome = myObservationDao.search(map);\n+\t\tassertThat(toUnqualifiedVersionlessIdValues(outcome), containsInAnyOrder(\"Observation/O\"));\n+\n+\t\tassertEquals(2, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countInsertQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countDeleteQueriesForCurrentThread());\n+\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertEquals(1, StringUtils.countMatches(myCaptureQueriesListener.getSelectQueriesForCurrentThread().get(0).getSql(true, true).toLowerCase(), \"join\"));", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE5MDM0Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425190346", "bodyText": "I assume this assert failed before you made your change?", "author": "fil512", "createdAt": "2020-05-14T14:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE5MDAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ2MjIxNw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425462217", "bodyText": "Yup, was 2", "author": "jamesagnew", "createdAt": "2020-05-14T22:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE5MDAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE5MTYwOA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425191608", "bodyText": "Nice how minimal you were able to reduce the example down to.", "author": "fil512", "createdAt": "2020-05-14T14:42:32Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4QueryCountTest.java", "diffHunk": "@@ -457,6 +459,37 @@ public void testSearchUsingForcedIdReference_DeletedDisabled() {\n \t\tassertEquals(0, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n \t\tassertEquals(0, myCaptureQueriesListener.countDeleteQueriesForCurrentThread());\n \t}\n+\n+\n+\t@Test\n+\tpublic void testSearchOnChainedToken() {\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"P\");\n+\t\tpatient.addIdentifier().setSystem(\"sys\").setValue(\"val\");\n+\t\tmyPatientDao.update(patient);\n+\n+\t\tObservation obs = new Observation();\n+\t\tobs.setId(\"O\");\n+\t\tobs.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.update(obs);", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE5MjY5Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425192692", "bodyText": "This pattern is so pervasive, makes me think we should add a SearchParamUtil.newMap() that sets load synchronous true...", "author": "fil512", "createdAt": "2020-05-14T14:43:57Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java", "diffHunk": "@@ -405,24 +405,30 @@ public void testChainWithMultipleTypePossibilities() {\n \t\tIBundleProvider results;\n \n \t\tmap = new SearchParameterMap();\n+\t\tmap.setLoadSynchronous(true);\n \t\tmap.add(Encounter.SP_SUBJECT, new ReferenceParam(\"subject\", \"foo|bar\").setChain(\"identifier\"));\n+\t\tmyCaptureQueriesListener.clear();\n \t\tresults = myEncounterDao.search(map);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread(0);\n \t\tids = toUnqualifiedVersionlessIdValues(results);\n \t\tassertThat(ids, hasItems(enc1Id, enc2Id));\n \n \t\tmap = new SearchParameterMap();\n+\t\tmap.setLoadSynchronous(true);\n \t\tmap.add(Encounter.SP_SUBJECT, new ReferenceParam(\"subject:Patient\", \"foo|bar\").setChain(\"identifier\"));\n \t\tresults = myEncounterDao.search(map);\n \t\tids = toUnqualifiedVersionlessIdValues(results);\n \t\tassertThat(ids, hasItems(enc1Id));\n \n \t\tmap = new SearchParameterMap();\n+\t\tmap.setLoadSynchronous(true);", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3NDQ4NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425474485", "bodyText": "oh man you are completely right. Added.", "author": "jamesagnew", "createdAt": "2020-05-14T22:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE5MjY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE5MzEwMA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425193100", "bodyText": "This is the kind of broken test you like to see!  :-)", "author": "fil512", "createdAt": "2020-05-14T14:44:28Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java", "diffHunk": "@@ -3021,7 +3027,7 @@ public void testSearchLinkToken() {\n \n \t\tString searchQuery = queries.get(0);\n \t\tassertEquals(searchQuery, 3, StringUtils.countMatches(searchQuery.toUpperCase(), \"HFJ_SPIDX_TOKEN\"));\n-\t\tassertEquals(searchQuery, 5, StringUtils.countMatches(searchQuery.toUpperCase(), \"LEFT OUTER JOIN\"));\n+\t\tassertEquals(searchQuery, 4, StringUtils.countMatches(searchQuery.toUpperCase(), \"LEFT OUTER JOIN\"));", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE5MzkxMg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425193912", "bodyText": "this tweak will likely require adjustment on some custom database tuning some of the sites have done", "author": "fil512", "createdAt": "2020-05-14T14:45:32Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchOptimizedTest.java", "diffHunk": "@@ -692,7 +692,7 @@ public void testSearchForTokenValueOnlyUsesValueHash() {\n \t\tmyCaptureQueriesListener.logSelectQueries();\n \n \t\tString selectQuery = myCaptureQueriesListener.getSelectQueries().get(1).getSql(true, true);\n-\t\tassertThat(selectQuery, containsString(\"HASH_VALUE in\"));\n+\t\tassertThat(selectQuery, containsString(\"HASH_VALUE=\"));", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3NDY3Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425474676", "bodyText": "For sure- but this ticket in general will for sure require that.", "author": "jamesagnew", "createdAt": "2020-05-14T22:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE5MzkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIxNzgxOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425217819", "bodyText": "This still niggles at me.  Rather than ensuring we explicitly call this in all the right places, can we make it a side effect of adding a join predicate?  Or if that's not possible for some reason, can we just walk the query tree at the end and deduce whether it has a join?", "author": "fil512", "createdAt": "2020-05-14T15:17:01Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/BasePredicateBuilder.java", "diffHunk": "@@ -126,22 +87,22 @@ void addPredicateParamMissingForReference(String theResourceName, String thePara\n \n \t\taddPartitionIdPredicate(theRequestPartitionId, paramPresentJoin, predicates);\n \n-\t\tmyQueryRoot.setHasIndexJoins();\n-\t\tmyQueryRoot.addPredicates(predicates);\n+\t\tmyQueryRootStack.setHasIndexJoins();", "originalCommit": "cdbcc88ffe461c7d07cf4865937cfe11099ada28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3NDk0MQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1844#discussion_r425474941", "bodyText": "I agree. I have added a new addPredicate method that sets this flag..\nI've also given the flag a better name:\n\t/**\n\t * Adds a predicate and marks it as having implicit type selection in it. In other words, call this method if a\n\t * this predicate will ensure:\n\t * <ul>\n\t *    <li>Only Resource PIDs for the correct resource type will be selected</li>\n\t *    <li>Only Resource PIDs for non-deleted resources will be selected</li>\n\t * </ul>\n\t * Setting this flag is a performance optimization, since it avoids the need for us to explicitly\n\t * add predicates for the two conditions above.\n\t */\n\tpublic void addPredicateWithImplicitTypeSelection(Predicate thePredicate) {\n\t\tsetHasImplicitTypeSelection();\n\t\taddPredicate(thePredicate);\n\t}", "author": "jamesagnew", "createdAt": "2020-05-14T22:55:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIxNzgxOQ=="}], "type": "inlineReview"}, {"oid": "d87fc6fef858546b66c0bbf2ed9b170f4ec0950d", "url": "https://github.com/hapifhir/hapi-fhir/commit/d87fc6fef858546b66c0bbf2ed9b170f4ec0950d", "message": "Update hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/querystack/QueryRootStack.java\n\nCo-authored-by: Ken Stevens <khstevens@gmail.com>", "committedDate": "2020-05-14T22:35:21Z", "type": "commit"}, {"oid": "1dfc4841738923b21ed7bfc4d33d9c5154e3697a", "url": "https://github.com/hapifhir/hapi-fhir/commit/1dfc4841738923b21ed7bfc4d33d9c5154e3697a", "message": "Update hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/querystack/QueryRootStack.java\n\nCo-authored-by: Ken Stevens <khstevens@gmail.com>", "committedDate": "2020-05-14T22:37:54Z", "type": "commit"}, {"oid": "71cc816e0bd21b53c5117555e5a7a5cf2296bddf", "url": "https://github.com/hapifhir/hapi-fhir/commit/71cc816e0bd21b53c5117555e5a7a5cf2296bddf", "message": "Update hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/querystack/QueryRootStack.java\n\nCo-authored-by: Ken Stevens <khstevens@gmail.com>", "committedDate": "2020-05-14T22:38:07Z", "type": "commit"}, {"oid": "647a7c372617f7d4bf93efa1b86c49d4d8c8b52d", "url": "https://github.com/hapifhir/hapi-fhir/commit/647a7c372617f7d4bf93efa1b86c49d4d8c8b52d", "message": "Address review comments", "committedDate": "2020-05-14T22:55:45Z", "type": "commit"}, {"oid": "2e17e8e7650220d8d09e1a6da34883a7b16eac9f", "url": "https://github.com/hapifhir/hapi-fhir/commit/2e17e8e7650220d8d09e1a6da34883a7b16eac9f", "message": "Merge branch 'ja_20200511_1842_optimize_chain_sql_paths' of github.com:jamesagnew/hapi-fhir into ja_20200511_1842_optimize_chain_sql_paths", "committedDate": "2020-05-14T22:56:39Z", "type": "commit"}, {"oid": "f87a0154e791fac8f24d56ae347bfa7d1bb250f1", "url": "https://github.com/hapifhir/hapi-fhir/commit/f87a0154e791fac8f24d56ae347bfa7d1bb250f1", "message": "Add changelog", "committedDate": "2020-05-14T23:15:10Z", "type": "commit"}]}