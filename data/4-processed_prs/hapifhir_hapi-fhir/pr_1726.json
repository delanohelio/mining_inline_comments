{"pr_number": 1726, "pr_title": "Collapse date joins", "pr_createdAt": "2020-02-22T22:58:54Z", "pr_url": "https://github.com/hapifhir/hapi-fhir/pull/1726", "timeline": [{"oid": "894605a697433a8d99befd2c63f31e578fba5d80", "url": "https://github.com/hapifhir/hapi-fhir/commit/894605a697433a8d99befd2c63f31e578fba5d80", "message": "Collapse date joins", "committedDate": "2020-02-22T22:58:26Z", "type": "commit"}, {"oid": "f1698ba7a3672a5fa1cf7b86ca18651ed9f1261c", "url": "https://github.com/hapifhir/hapi-fhir/commit/f1698ba7a3672a5fa1cf7b86ca18651ed9f1261c", "message": "Add changelog", "committedDate": "2020-02-22T23:00:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0ODY4Nw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1726#discussion_r383048687", "bodyText": "if it wasn't for the newJoin flag, I'd suggest a putIfAbsent here...", "author": "fil512", "createdAt": "2020-02-23T23:14:52Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderDate.java", "diffHunk": "@@ -56,7 +60,18 @@ public Predicate addPredicate(String theResourceName,\n \t\t\t\t\t\t\t\t\t\t\tList<? extends IQueryParameterType> theList,\n \t\t\t\t\t\t\t\t\t\t\tSearchFilterParser.CompareOperation operation) {\n \n-\t\tJoin<ResourceTable, ResourceIndexedSearchParamDate> join = createJoin(SearchBuilderJoinEnum.DATE, theParamName);\n+\t\tboolean newJoin = false;\n+\t\tif (myJoinMap == null) {\n+\t\t\tmyJoinMap = new HashMap<>();\n+\t\t}\n+\t\tString key = theResourceName + \" \" + theParamName;\n+\n+\t\tJoin<ResourceTable, ResourceIndexedSearchParamDate> join = myJoinMap.get(key);\n+\t\tif (join == null) {\n+\t\t\tjoin = createJoin(SearchBuilderJoinEnum.DATE, theParamName);\n+\t\t\tmyJoinMap.put(key, join);", "originalCommit": "f1698ba7a3672a5fa1cf7b86ca18651ed9f1261c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4ODMxNg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1726#discussion_r383888316", "bodyText": "Heh yup", "author": "jamesagnew", "createdAt": "2020-02-25T13:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0ODY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0ODkxOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1726#discussion_r383048919", "bodyText": "The fact this change was so easy is a testament to how well designed your solution was in the first place.", "author": "fil512", "createdAt": "2020-02-23T23:17:06Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderDate.java", "diffHunk": "@@ -77,7 +92,14 @@ public Predicate addPredicate(String theResourceName,\n \t\t}\n \n \t\tPredicate orPredicates = myBuilder.or(toArray(codePredicates));\n-\t\tmyQueryRoot.addPredicate(orPredicates);\n+\n+\t\tif (newJoin) {\n+\t\t\tPredicate identityAndValuePredicate = combineParamIndexPredicateWithParamNamePredicate(theResourceName, theParamName, join, orPredicates);\n+\t\t\tmyQueryRoot.addPredicate(identityAndValuePredicate);\n+\t\t} else {\n+\t\t\tmyQueryRoot.addPredicate(orPredicates);", "originalCommit": "f1698ba7a3672a5fa1cf7b86ca18651ed9f1261c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0OTExOQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1726#discussion_r383049119", "bodyText": "calling this obs1 is confusing.  I'd just call them both obs", "author": "fil512", "createdAt": "2020-02-23T23:19:15Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java", "diffHunk": "@@ -3258,6 +3258,73 @@ public void testSearchWithDate() {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testSearchWithDateAndReusesExistingJoin() {\n+\t\t// Add a search parameter to Observation.issued, so that between that one\n+\t\t// and the existing one on Observation.effective, we have 2 date search parameters\n+\t\t// on the same resource\n+\t\t{\n+\t\t\tSearchParameter sp = new SearchParameter();\n+\t\t\tsp.setStatus(Enumerations.PublicationStatus.ACTIVE);\n+\t\t\tsp.addBase(\"Observation\");\n+\t\t\tsp.setType(Enumerations.SearchParamType.DATE);\n+\t\t\tsp.setCode(\"issued\");\n+\t\t\tsp.setExpression(\"Observation.issued\");\n+\t\t\tmySearchParameterDao.create(sp);\n+\t\t\tmySearchParamRegistry.forceRefresh();\n+\t\t}\n+\n+\t\t// Dates are reversed on these two observations\n+\t\tIIdType obsId1;\n+\t\t{\n+\t\t\tObservation obs1 = new Observation();\n+\t\t\tobs1.setIssuedElement(new InstantType(\"2020-06-06T12:00:00Z\"));\n+\t\t\tobs1.setEffective(new InstantType(\"2019-06-06T12:00:00Z\"));\n+\t\t\tobsId1 = myObservationDao.create(obs1).getId().toUnqualifiedVersionless();\n+\t\t}\n+\t\tIIdType obsId2;\n+\t\t{\n+\t\t\tObservation obs1 = new Observation();", "originalCommit": "f1698ba7a3672a5fa1cf7b86ca18651ed9f1261c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4ODc1NA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1726#discussion_r383888754", "bodyText": "Good call, done", "author": "jamesagnew", "createdAt": "2020-02-25T13:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0OTExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0OTI3NA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1726#discussion_r383049274", "bodyText": "This is beautiful.  That captures query listener is the best!", "author": "fil512", "createdAt": "2020-02-23T23:20:49Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java", "diffHunk": "@@ -3258,6 +3258,73 @@ public void testSearchWithDate() {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testSearchWithDateAndReusesExistingJoin() {\n+\t\t// Add a search parameter to Observation.issued, so that between that one\n+\t\t// and the existing one on Observation.effective, we have 2 date search parameters\n+\t\t// on the same resource\n+\t\t{\n+\t\t\tSearchParameter sp = new SearchParameter();\n+\t\t\tsp.setStatus(Enumerations.PublicationStatus.ACTIVE);\n+\t\t\tsp.addBase(\"Observation\");\n+\t\t\tsp.setType(Enumerations.SearchParamType.DATE);\n+\t\t\tsp.setCode(\"issued\");\n+\t\t\tsp.setExpression(\"Observation.issued\");\n+\t\t\tmySearchParameterDao.create(sp);\n+\t\t\tmySearchParamRegistry.forceRefresh();\n+\t\t}\n+\n+\t\t// Dates are reversed on these two observations\n+\t\tIIdType obsId1;\n+\t\t{\n+\t\t\tObservation obs1 = new Observation();\n+\t\t\tobs1.setIssuedElement(new InstantType(\"2020-06-06T12:00:00Z\"));\n+\t\t\tobs1.setEffective(new InstantType(\"2019-06-06T12:00:00Z\"));\n+\t\t\tobsId1 = myObservationDao.create(obs1).getId().toUnqualifiedVersionless();\n+\t\t}\n+\t\tIIdType obsId2;\n+\t\t{\n+\t\t\tObservation obs1 = new Observation();\n+\t\t\tobs1.setIssuedElement(new InstantType(\"2019-06-06T12:00:00Z\"));\n+\t\t\tobs1.setEffective(new InstantType(\"2020-06-06T12:00:00Z\"));\n+\t\t\tobsId2 = myObservationDao.create(obs1).getId().toUnqualifiedVersionless();\n+\t\t}\n+\n+\t\t// Two AND instances of 1 SP\n+\t\t{\n+\t\t\tmyCaptureQueriesListener.clear();\n+\t\t\tSearchParameterMap params = new SearchParameterMap();\n+\t\t\tparams.setLoadSynchronous(true);\n+\t\t\tparams.add(\"issued\", new DateParam(\"ge2020-06-05\"));\n+\t\t\tparams.add(\"issued\", new DateParam(\"lt2020-06-07\"));\n+\t\t\tList<IIdType> patients = toUnqualifiedVersionlessIds(myObservationDao.search(params));\n+\t\t\tassertThat(patients, contains(obsId1));\n+\t\t\tString searchQuery = myCaptureQueriesListener.getSelectQueriesForCurrentThread().get(0).getSql(true, true);\n+\t\t\tourLog.info(\"Search query:\\n{}\", searchQuery);\n+\t\t\tassertEquals(searchQuery, 1, StringUtils.countMatches(searchQuery.toLowerCase(), \"join\"));", "originalCommit": "f1698ba7a3672a5fa1cf7b86ca18651ed9f1261c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0OTQ0NA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1726#discussion_r383049444", "bodyText": "Consider adding a couple of period searches for good measure.  I'd recommend a test with two periods that overlap.", "author": "fil512", "createdAt": "2020-02-23T23:22:43Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java", "diffHunk": "@@ -3258,6 +3258,73 @@ public void testSearchWithDate() {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testSearchWithDateAndReusesExistingJoin() {\n+\t\t// Add a search parameter to Observation.issued, so that between that one\n+\t\t// and the existing one on Observation.effective, we have 2 date search parameters\n+\t\t// on the same resource\n+\t\t{\n+\t\t\tSearchParameter sp = new SearchParameter();\n+\t\t\tsp.setStatus(Enumerations.PublicationStatus.ACTIVE);\n+\t\t\tsp.addBase(\"Observation\");\n+\t\t\tsp.setType(Enumerations.SearchParamType.DATE);\n+\t\t\tsp.setCode(\"issued\");\n+\t\t\tsp.setExpression(\"Observation.issued\");\n+\t\t\tmySearchParameterDao.create(sp);\n+\t\t\tmySearchParamRegistry.forceRefresh();\n+\t\t}\n+\n+\t\t// Dates are reversed on these two observations\n+\t\tIIdType obsId1;\n+\t\t{\n+\t\t\tObservation obs1 = new Observation();\n+\t\t\tobs1.setIssuedElement(new InstantType(\"2020-06-06T12:00:00Z\"));\n+\t\t\tobs1.setEffective(new InstantType(\"2019-06-06T12:00:00Z\"));\n+\t\t\tobsId1 = myObservationDao.create(obs1).getId().toUnqualifiedVersionless();\n+\t\t}\n+\t\tIIdType obsId2;\n+\t\t{\n+\t\t\tObservation obs1 = new Observation();\n+\t\t\tobs1.setIssuedElement(new InstantType(\"2019-06-06T12:00:00Z\"));\n+\t\t\tobs1.setEffective(new InstantType(\"2020-06-06T12:00:00Z\"));\n+\t\t\tobsId2 = myObservationDao.create(obs1).getId().toUnqualifiedVersionless();\n+\t\t}\n+\n+\t\t// Two AND instances of 1 SP\n+\t\t{\n+\t\t\tmyCaptureQueriesListener.clear();\n+\t\t\tSearchParameterMap params = new SearchParameterMap();\n+\t\t\tparams.setLoadSynchronous(true);\n+\t\t\tparams.add(\"issued\", new DateParam(\"ge2020-06-05\"));\n+\t\t\tparams.add(\"issued\", new DateParam(\"lt2020-06-07\"));\n+\t\t\tList<IIdType> patients = toUnqualifiedVersionlessIds(myObservationDao.search(params));\n+\t\t\tassertThat(patients, contains(obsId1));\n+\t\t\tString searchQuery = myCaptureQueriesListener.getSelectQueriesForCurrentThread().get(0).getSql(true, true);\n+\t\t\tourLog.info(\"Search query:\\n{}\", searchQuery);\n+\t\t\tassertEquals(searchQuery, 1, StringUtils.countMatches(searchQuery.toLowerCase(), \"join\"));\n+\t\t\tassertEquals(searchQuery, 1, StringUtils.countMatches(searchQuery.toLowerCase(), \"hash_identity\"));\n+\t\t\tassertEquals(searchQuery, 2, StringUtils.countMatches(searchQuery.toLowerCase(), \"sp_value_low\"));\n+\t\t}\n+\n+\t\t// Two AND instances of 1 SP and 1 instance of another\n+\t\t{\n+\t\t\tmyCaptureQueriesListener.clear();\n+\t\t\tSearchParameterMap params = new SearchParameterMap();\n+\t\t\tparams.setLoadSynchronous(true);\n+\t\t\tparams.add(\"issued\", new DateParam(\"ge2020-06-05\"));\n+\t\t\tparams.add(\"issued\", new DateParam(\"lt2020-06-07\"));\n+\t\t\tparams.add(\"date\", new DateParam(\"gt2019-06-05\"));\n+\t\t\tparams.add(\"date\", new DateParam(\"lt2019-06-07\"));\n+\t\t\tList<IIdType> patients = toUnqualifiedVersionlessIds(myObservationDao.search(params));\n+\t\t\tassertThat(patients, contains(obsId1));\n+\t\t\tString searchQuery = myCaptureQueriesListener.getSelectQueriesForCurrentThread().get(0).getSql(true, true);\n+\t\t\tourLog.info(\"Search query:\\n{}\", searchQuery);\n+\t\t\tassertEquals(searchQuery, 2, StringUtils.countMatches(searchQuery.toLowerCase(), \"join\"));\n+\t\t\tassertEquals(searchQuery, 2, StringUtils.countMatches(searchQuery.toLowerCase(), \"hash_identity\"));\n+\t\t\tassertEquals(searchQuery, 4, StringUtils.countMatches(searchQuery.toLowerCase(), \"sp_value_low\"));\n+\t\t}\n+\t}\n+", "originalCommit": "f1698ba7a3672a5fa1cf7b86ca18651ed9f1261c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NjM1NA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1726#discussion_r384066354", "bodyText": "done", "author": "jamesagnew", "createdAt": "2020-02-25T19:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA0OTQ0NA=="}], "type": "inlineReview"}, {"oid": "b0229c0c6a442384cb8e34df7a597abb8e4936c9", "url": "https://github.com/hapifhir/hapi-fhir/commit/b0229c0c6a442384cb8e34df7a597abb8e4936c9", "message": "Address review comments", "committedDate": "2020-02-25T19:06:52Z", "type": "commit"}, {"oid": "c12572e7004e823435ca5cc6e982f52cfabfa92f", "url": "https://github.com/hapifhir/hapi-fhir/commit/c12572e7004e823435ca5cc6e982f52cfabfa92f", "message": "Add whitespace", "committedDate": "2020-02-25T19:47:51Z", "type": "commit"}, {"oid": "627032d222399b280c877a3c9d10fd0798aaa6db", "url": "https://github.com/hapifhir/hapi-fhir/commit/627032d222399b280c877a3c9d10fd0798aaa6db", "message": "Merge remote-tracking branch 'remotes/origin/master' into ja_20200222_collapse_date_joins", "committedDate": "2020-02-25T20:29:19Z", "type": "commit"}, {"oid": "08d5e377ca3c24f020cb57de3c7aa4bd30cbd983", "url": "https://github.com/hapifhir/hapi-fhir/commit/08d5e377ca3c24f020cb57de3c7aa4bd30cbd983", "message": "fix test", "committedDate": "2020-02-25T20:32:07Z", "type": "commit"}]}