{"pr_number": 1754, "pr_title": "Optmize forced ID resolution", "pr_createdAt": "2020-03-09T13:07:06Z", "pr_url": "https://github.com/hapifhir/hapi-fhir/pull/1754", "timeline": [{"oid": "9e7713d0be154807627bfd4062240c386f504a56", "url": "https://github.com/hapifhir/hapi-fhir/commit/9e7713d0be154807627bfd4062240c386f504a56", "message": "Add forced ID caching", "committedDate": "2020-03-08T16:42:09Z", "type": "commit"}, {"oid": "d43dd32feac53f699ef1063e8ce7e7f7b9496d9d", "url": "https://github.com/hapifhir/hapi-fhir/commit/d43dd32feac53f699ef1063e8ce7e7f7b9496d9d", "message": "Work on id optimization", "committedDate": "2020-03-09T09:11:25Z", "type": "commit"}, {"oid": "ef61b65f59f52d35fd239b3ac0aa9c4549bc4bad", "url": "https://github.com/hapifhir/hapi-fhir/commit/ef61b65f59f52d35fd239b3ac0aa9c4549bc4bad", "message": "Test fixes", "committedDate": "2020-03-09T12:07:58Z", "type": "commit"}, {"oid": "f39e89b66c96be2ae1d845e1963c7527c2b26305", "url": "https://github.com/hapifhir/hapi-fhir/commit/f39e89b66c96be2ae1d845e1963c7527c2b26305", "message": "More optimization work", "committedDate": "2020-03-09T12:40:52Z", "type": "commit"}, {"oid": "43ded0f5fdf4b226697d137657ed91de6ee6b4e9", "url": "https://github.com/hapifhir/hapi-fhir/commit/43ded0f5fdf4b226697d137657ed91de6ee6b4e9", "message": "Add some docs", "committedDate": "2020-03-09T12:49:38Z", "type": "commit"}, {"oid": "1520e2a958f0b6ec495fa522507e5f6da0586280", "url": "https://github.com/hapifhir/hapi-fhir/commit/1520e2a958f0b6ec495fa522507e5f6da0586280", "message": "Work on docs", "committedDate": "2020-03-09T13:25:31Z", "type": "commit"}, {"oid": "05e0ace4c5d54e101b3a8e241c92966e49fd3a85", "url": "https://github.com/hapifhir/hapi-fhir/commit/05e0ace4c5d54e101b3a8e241c92966e49fd3a85", "message": "Test fixes", "committedDate": "2020-03-09T13:48:44Z", "type": "commit"}, {"oid": "6796473bcf67d4da4d2de5bf2b68b1c664383f82", "url": "https://github.com/hapifhir/hapi-fhir/commit/6796473bcf67d4da4d2de5bf2b68b1c664383f82", "message": "Test fixes", "committedDate": "2020-03-09T14:51:03Z", "type": "commit"}, {"oid": "1f89732250c9fdbe51b478516c241ad62169f620", "url": "https://github.com/hapifhir/hapi-fhir/commit/1f89732250c9fdbe51b478516c241ad62169f620", "message": "Test fixes", "committedDate": "2020-03-09T15:29:15Z", "type": "commit"}, {"oid": "8fa86f80bc37b640a90b2d6600963207ce97b57e", "url": "https://github.com/hapifhir/hapi-fhir/commit/8fa86f80bc37b640a90b2d6600963207ce97b57e", "message": "Merge branch 'master' into ja_20200308_forced_id_caching", "committedDate": "2020-03-09T16:50:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NTAzMw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389785033", "bodyText": "This method actually seems to return a Collection of Object arrays. Is it meant to always return a single element?", "author": "tadgh", "createdAt": "2020-03-09T15:55:05Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/data/IForcedIdDao.java", "diffHunk": "@@ -35,13 +36,41 @@\n \t@Query(\"SELECT f.myResourcePid FROM ForcedId f WHERE myForcedId IN (:forced_id)\")\n \tList<Long> findByForcedId(@Param(\"forced_id\") Collection<String> theForcedId);\n \n-\t@Query(\"SELECT f.myResourcePid FROM ForcedId f WHERE myResourceType = :resource_type AND myForcedId IN (:forced_id)\")\n-\tList<Long> findByTypeAndForcedId(@Param(\"resource_type\") String theResourceType, @Param(\"forced_id\") Collection<String> theForcedId);\n+\t@Query(\"SELECT f.myResourcePid FROM ForcedId f WHERE myResourceType = :resource_type AND myForcedId = :forced_id\")\n+\tOptional<Long> findByTypeAndForcedId(@Param(\"resource_type\") String theResourceType, @Param(\"forced_id\") String theForcedId);\n \n \t@Query(\"SELECT f FROM ForcedId f WHERE f.myResourcePid = :resource_pid\")\n \tForcedId findByResourcePid(@Param(\"resource_pid\") Long theResourcePid);\n \n \t@Modifying\n \t@Query(\"DELETE FROM ForcedId t WHERE t.myId = :pid\")\n \tvoid deleteByPid(@Param(\"pid\") Long theId);\n+\n+\t/**\n+\t * This method returns an object array, where the order matters. Be careful if you change this query in any way.\n+\t */", "originalCommit": "6796473bcf67d4da4d2de5bf2b68b1c664383f82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4MTQ0Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389881446", "bodyText": "Updating to:\n\n/**\n\nThis method returns a Collection where each row is an element in the collection. Each element in the collection\nis an object array, where the order matters (the array represents columns returned by the query). Be careful if you change this query in any way.\n*/", "author": "jamesagnew", "createdAt": "2020-03-09T18:30:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NjA1MQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389786051", "bodyText": "Question: Is this correctly named? It seems we do not resolve by type here, unless I am mistaken", "author": "tadgh", "createdAt": "2020-03-09T15:56:34Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/data/IForcedIdDao.java", "diffHunk": "@@ -35,13 +36,41 @@\n \t@Query(\"SELECT f.myResourcePid FROM ForcedId f WHERE myForcedId IN (:forced_id)\")\n \tList<Long> findByForcedId(@Param(\"forced_id\") Collection<String> theForcedId);\n \n-\t@Query(\"SELECT f.myResourcePid FROM ForcedId f WHERE myResourceType = :resource_type AND myForcedId IN (:forced_id)\")\n-\tList<Long> findByTypeAndForcedId(@Param(\"resource_type\") String theResourceType, @Param(\"forced_id\") Collection<String> theForcedId);\n+\t@Query(\"SELECT f.myResourcePid FROM ForcedId f WHERE myResourceType = :resource_type AND myForcedId = :forced_id\")\n+\tOptional<Long> findByTypeAndForcedId(@Param(\"resource_type\") String theResourceType, @Param(\"forced_id\") String theForcedId);\n \n \t@Query(\"SELECT f FROM ForcedId f WHERE f.myResourcePid = :resource_pid\")\n \tForcedId findByResourcePid(@Param(\"resource_pid\") Long theResourcePid);\n \n \t@Modifying\n \t@Query(\"DELETE FROM ForcedId t WHERE t.myId = :pid\")\n \tvoid deleteByPid(@Param(\"pid\") Long theId);\n+\n+\t/**\n+\t * This method returns an object array, where the order matters. Be careful if you change this query in any way.\n+\t */\n+\t@Query(\"SELECT f.myForcedId, f.myResourcePid FROM ForcedId f WHERE myResourceType = :resource_type AND myForcedId IN ( :forced_id )\")\n+\tCollection<Object[]> findByTypeAndForcedId(@Param(\"resource_type\") String theResourceType, @Param(\"forced_id\") Collection<String> theForcedId);\n+\n+\t/**\n+\t * This method returns an object array, where the order matters. Be careful if you change this query in any way.\n+\t */\n+\t@Query(\"\" +\n+\t\t\"SELECT \" +\n+\t\t\"   f.myResourceType, f.myResourcePid, f.myForcedId, t.myDeleted \" +\n+\t\t\"FROM ForcedId f \" +\n+\t\t\"JOIN ResourceTable t ON t.myId = f.myResourcePid \" +\n+\t\t\"WHERE f.myForcedId IN ( :forced_id )\")\n+\tCollection<Object[]> findAndResolveByTypeAndForcedId(@Param(\"forced_id\") Collection<String> theForcedIds);", "originalCommit": "6796473bcf67d4da4d2de5bf2b68b1c664383f82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4NjE4OQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389886189", "bodyText": "Nope. Renaming...", "author": "jamesagnew", "createdAt": "2020-03-09T18:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NjA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NzIyMA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389787220", "bodyText": "Suggestion: Add doc strings to the interface methods in IResourceLinkResolver", "author": "tadgh", "createdAt": "2020-03-09T15:58:19Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/DaoResourceLinkResolver.java", "diffHunk": "@@ -64,16 +64,15 @@\n \tprivate DaoRegistry myDaoRegistry;\n \n \t@Override\n-\tpublic ResourceTable findTargetResource(RuntimeSearchParam theNextSpDef, String theNextPathsUnsplit, IIdType theNextId, String theTypeString, Class<? extends IBaseResource> theType, IBaseReference theReference, RequestDetails theRequest) {\n-\t\tResourceTable target;\n-\t\tResourcePersistentId valueOf;\n+\tpublic IResourceLookup findTargetResource(RuntimeSearchParam theNextSpDef, String theNextPathsUnsplit, IIdType theNextId, String theTypeString, Class<? extends IBaseResource> theType, IBaseReference theReference, RequestDetails theRequest) {", "originalCommit": "6796473bcf67d4da4d2de5bf2b68b1c664383f82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4NTEzMA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389885130", "bodyText": "sounds good, will do.\n\t/**\n\t * This method resolves the target of a reference found within a resource that is being created/updated. We do this\n\t * so that we can create indexed links between resources, and so that we can validate that the target actually\n\t * exists in cases where we need to check that.\n\t * <p>\n\t * This method returns an {@link IResourceLookup} so as to avoid needing to resolve the entire resource.\n\t *\n\t * @param theSearchParam      The param that is being indexed\n\t * @param theSourcePath       The path within the resource where this reference was found\n\t * @param theSourceResourceId The ID of the resource containing the reference to the target being resolved\n\t * @param theTypeString       The type of the resource being resolved\n\t * @param theType             The resource type of the target\n\t * @param theReference        The reference being resolved\n\t * @param theRequest          The incoming request, if any\n\t */\n\tIResourceLookup findTargetResource(RuntimeSearchParam theSearchParam, String theSourcePath, IIdType theSourceResourceId, String theTypeString, Class<? extends IBaseResource> theType, IBaseReference theReference, RequestDetails theRequest);", "author": "jamesagnew", "createdAt": "2020-03-09T18:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NzIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4ODQ4NQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389788485", "bodyText": "Suggestion: Change this variable name, as this is no longer a pid", "author": "tadgh", "createdAt": "2020-03-09T16:00:05Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/DaoResourceLinkResolver.java", "diffHunk": "@@ -64,16 +64,15 @@\n \tprivate DaoRegistry myDaoRegistry;\n \n \t@Override\n-\tpublic ResourceTable findTargetResource(RuntimeSearchParam theNextSpDef, String theNextPathsUnsplit, IIdType theNextId, String theTypeString, Class<? extends IBaseResource> theType, IBaseReference theReference, RequestDetails theRequest) {\n-\t\tResourceTable target;\n-\t\tResourcePersistentId valueOf;\n+\tpublic IResourceLookup findTargetResource(RuntimeSearchParam theNextSpDef, String theNextPathsUnsplit, IIdType theNextId, String theTypeString, Class<? extends IBaseResource> theType, IBaseReference theReference, RequestDetails theRequest) {\n+\t\tIResourceLookup valueOf;\n \t\tString idPart = theNextId.getIdPart();\n \t\ttry {\n-\t\t\tvalueOf = myIdHelperService.translateForcedIdToPid(theTypeString, idPart, theRequest);\n+\t\t\tvalueOf = myIdHelperService.resolveResourceIdentity(theTypeString, idPart, theRequest);\n \t\t\tourLog.trace(\"Translated {}/{} to resource PID {}\", theType, idPart, valueOf);\n \t\t} catch (ResourceNotFoundException e) {\n \n-\t\t\tOptional<ResourcePersistentId> pidOpt = createPlaceholderTargetIfConfiguredToDoSo(theType, theReference, idPart);\n+\t\t\tOptional<ResourceTable> pidOpt = createPlaceholderTargetIfConfiguredToDoSo(theType, theReference, idPart);", "originalCommit": "6796473bcf67d4da4d2de5bf2b68b1c664383f82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4NTUxNw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389885517", "bodyText": "done", "author": "jamesagnew", "createdAt": "2020-03-09T18:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4ODQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MDEwNg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389790106", "bodyText": "Unless im mistaken, this log will interpolate the ResourceTable.toString() as the first argument, which probably isn't what you want? Current definition is:\n\t@Override\n\tpublic String toString() {\n\t\tToStringBuilder b = new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE);\n\t\tb.append(\"resourceType\", myResourceType);\n\t\tb.append(\"pid\", myId);\n\t\treturn b.build();\n\t}\n\nSo you can probably strip out the second log variable", "author": "tadgh", "createdAt": "2020-03-09T16:02:32Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/DaoResourceLinkResolver.java", "diffHunk": "@@ -89,36 +88,29 @@ public ResourceTable findTargetResource(RuntimeSearchParam theNextSpDef, String\n \t\t\tvalueOf = pidOpt.get();\n \t\t}\n \n-\t\ttarget = myEntityManager.find(ResourceTable.class, valueOf.getIdAsLong());\n-\t\tRuntimeResourceDefinition targetResourceDef = myContext.getResourceDefinition(theType);\n-\t\tif (target == null) {\n-\t\t\tString resName = targetResourceDef.getName();\n-\t\t\tthrow new InvalidRequestException(\"Resource \" + resName + \"/\" + idPart + \" not found, specified in path: \" + theNextPathsUnsplit);\n+\t\tourLog.trace(\"Resource PID {} is of type {}\", valueOf, valueOf.getResourceType());", "originalCommit": "6796473bcf67d4da4d2de5bf2b68b1c664383f82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4NjgxOA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389886818", "bodyText": "God, not to mention that the variable is called valueOf, which is horrible.\nFixing.", "author": "jamesagnew", "createdAt": "2020-03-09T18:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MDEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMTUyOA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389831528", "bodyText": "Will having this warning message inside the loop cause performance issues here?", "author": "tadgh", "createdAt": "2020-03-09T17:06:55Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -22,132 +22,222 @@\n \n import ca.uhn.fhir.context.FhirContext;\n import ca.uhn.fhir.interceptor.api.HookParams;\n+import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n import ca.uhn.fhir.jpa.dao.DaoConfig;\n-import ca.uhn.fhir.jpa.model.cross.ResourcePersistentId;\n import ca.uhn.fhir.jpa.dao.data.IForcedIdDao;\n+import ca.uhn.fhir.jpa.dao.data.IResourceTableDao;\n+import ca.uhn.fhir.jpa.model.cross.IResourceLookup;\n+import ca.uhn.fhir.jpa.model.cross.ResourceLookup;\n+import ca.uhn.fhir.jpa.model.cross.ResourcePersistentId;\n import ca.uhn.fhir.jpa.model.entity.ForcedId;\n-import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;\n-import ca.uhn.fhir.interceptor.api.Pointcut;\n import ca.uhn.fhir.jpa.model.search.StorageProcessingMessage;\n import ca.uhn.fhir.jpa.util.JpaInterceptorBroadcaster;\n import ca.uhn.fhir.model.primitive.IdDt;\n import ca.uhn.fhir.rest.api.server.RequestDetails;\n import ca.uhn.fhir.rest.server.exceptions.ResourceNotFoundException;\n import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n import com.google.common.collect.ListMultimap;\n import com.google.common.collect.MultimapBuilder;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.Validate;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n import org.hl7.fhir.instance.model.api.IIdType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n import javax.annotation.Nonnull;\n-import java.util.*;\n+import javax.annotation.PostConstruct;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n \n import static org.apache.commons.lang3.StringUtils.isBlank;\n \n+/**\n+ * This class is used to convert between PIDs (the internal primary key for a particular resource as\n+ * stored in the {@link ca.uhn.fhir.jpa.model.entity.ResourceTable HFJ_RESOURCE} table), and the\n+ * public ID that a resource has.\n+ * <p>\n+ * These IDs are sometimes one and the same (by default, a resource that the server assigns the ID of\n+ * <code>Patient/1</code> will simply use a PID of 1 and and ID of 1. However, they may also be different\n+ * in cases where a forced ID is used (an arbitrary client-assigned ID).\n+ * </p>\n+ * <p>\n+ * This service is highly optimized in order to minimize the number of DB calls as much as possible,\n+ * since ID resolution is fundamental to many basic operations. This service returns either\n+ * {@link IResourceLookup} or {@link ResourcePersistentId} depending on the method being called.\n+ * The former involves an extra database join that the latter does not require, so selecting the\n+ * right method here is important.\n+ * </p>\n+ */\n @Service\n public class IdHelperService {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(IdHelperService.class);\n+\n \t@Autowired\n \tprotected IForcedIdDao myForcedIdDao;\n+\t@Autowired\n+\tprotected IResourceTableDao myResourceTableDao;\n \t@Autowired(required = true)\n \tprivate DaoConfig myDaoConfig;\n \t@Autowired\n \tprivate IInterceptorBroadcaster myInterceptorBroadcaster;\n \n-\tpublic void delete(ForcedId forcedId) {\n-\t\tmyForcedIdDao.deleteByPid(forcedId.getId());\n+\tprivate Cache<String, Long> myPersistentIdCache;\n+\tprivate Cache<String, IResourceLookup> myResourceLookupCache;\n+\n+\t@PostConstruct\n+\tpublic void start() {\n+\t\tmyPersistentIdCache = newCache();\n+\t\tmyResourceLookupCache = newCache();\n \t}\n \n-\t/**\n-\t * @throws ResourceNotFoundException If the ID can not be found\n-\t */\n-\t@Nonnull\n-\tpublic ResourcePersistentId translateForcedIdToPid(IIdType theId, RequestDetails theRequestDetails) {\n-\t\treturn translateForcedIdToPid(theId.getResourceType(), theId.getIdPart(), theRequestDetails);\n+\n+\tpublic void delete(ForcedId forcedId) {\n+\t\tmyForcedIdDao.deleteByPid(forcedId.getId());\n \t}\n \n \t/**\n+\t * Given a resource type and ID, looks up the resource and returns a {@link IResourceLookup}. This\n+\t * object contains the internal PID for the resource and the resource deletion status, making it sufficient\n+\t * for persisting resource links between resources without adding any further database calls after the\n+\t * single one performed by this call.\n+\t *\n \t * @throws ResourceNotFoundException If the ID can not be found\n \t */\n \t@Nonnull\n-\tpublic ResourcePersistentId translateForcedIdToPid(String theResourceName, String theResourceId, RequestDetails theRequestDetails) throws ResourceNotFoundException {\n+\tpublic IResourceLookup resolveResourceIdentity(String theResourceName, String theResourceId, RequestDetails theRequestDetails) throws ResourceNotFoundException {\n \t\t// We only pass 1 input in so only 0..1 will come back\n \t\tIdDt id = new IdDt(theResourceName, theResourceId);\n-\t\tList<ResourcePersistentId> matches = translateForcedIdToPids(myDaoConfig, myInterceptorBroadcaster, theRequestDetails, myForcedIdDao, Collections.singletonList(id));\n+\t\tCollection<IResourceLookup> matches = translateForcedIdToPids(theRequestDetails, Collections.singletonList(id));\n \t\tassert matches.size() <= 1;\n \t\tif (matches.isEmpty()) {\n \t\t\tthrow new ResourceNotFoundException(id);\n \t\t}\n-\t\treturn matches.get(0);\n+\t\treturn matches.iterator().next();\n \t}\n \n-\tpublic List<ResourcePersistentId> translateForcedIdToPids(Collection<IIdType> theId, RequestDetails theRequestDetails) {\n-\t\treturn IdHelperService.translateForcedIdToPids(myDaoConfig, myInterceptorBroadcaster, theRequestDetails, myForcedIdDao, theId);\n+\t/**\n+\t * Given a resource type and ID, determines the internal persistent ID for the resource.\n+\t *\n+\t * @throws ResourceNotFoundException If the ID can not be found\n+\t */\n+\t@Nonnull\n+\tpublic ResourcePersistentId resolveResourcePersistentIds(String theResourceType, String theId) {\n+\t\tLong retVal;\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(theId)) {\n+\t\t\tif (myDaoConfig.isDeleteEnabled()) {\n+\t\t\t\tretVal = resolveResourceIdentity(theResourceType, theId);\n+\t\t\t} else {\n+\t\t\t\tString key = theResourceType + \"/\" + theId;\n+\t\t\t\tretVal = myPersistentIdCache.get(key, t -> resolveResourceIdentity(theResourceType, theId));\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tretVal = Long.parseLong(theId);\n+\t\t}\n+\n+\t\treturn new ResourcePersistentId(retVal);\n \t}\n \n-\tprivate static List<ResourcePersistentId> translateForcedIdToPids(DaoConfig theDaoConfig, IInterceptorBroadcaster theInterceptorBroadcaster, RequestDetails theRequest, IForcedIdDao theForcedIdDao, Collection<IIdType> theId) {\n-\t\ttheId.forEach(id -> Validate.isTrue(id.hasIdPart()));\n+\t/**\n+\t * Given a collection of resource IDs (resource type + id), resolves the internal persistent IDs\n+\t */\n+\t@Nonnull\n+\tpublic List<ResourcePersistentId> resolveResourcePersistentIds(List<IIdType> theIds, RequestDetails theRequest) {\n+\t\ttheIds.forEach(id -> Validate.isTrue(id.hasIdPart()));\n \n-\t\tif (theId.isEmpty()) {\n+\t\tif (theIds.isEmpty()) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n \n \t\tList<ResourcePersistentId> retVal = new ArrayList<>();\n \n-\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n-\t\tfor (IIdType nextId : theId) {\n-\t\t\tif (theDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY && isValidPid(nextId)) {\n-\t\t\t\tretVal.add(new ResourcePersistentId(nextId.getIdPartAsLong()));\n-\t\t\t} else {\n-\t\t\t\tif (nextId.hasResourceType()) {\n-\t\t\t\t\ttypeToIds.put(nextId.getResourceType(), nextId.getIdPart());\n-\t\t\t\t} else {\n-\t\t\t\t\ttypeToIds.put(\"\", nextId.getIdPart());\n-\t\t\t\t}\n-\t\t\t}\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY) {\n+\t\t\ttheIds\n+\t\t\t\t.stream()\n+\t\t\t\t.filter(t -> isValidPid(t))\n+\t\t\t\t.map(t -> t.getIdPartAsLong())\n+\t\t\t\t.map(t -> new ResourcePersistentId(t))\n+\t\t\t\t.forEach(t -> retVal.add(t));\n \t\t}\n \n+\t\tListMultimap<String, String> typeToIds = organizeIdsByResourceType(theIds);\n+\n \t\tfor (Map.Entry<String, Collection<String>> nextEntry : typeToIds.asMap().entrySet()) {\n \t\t\tString nextResourceType = nextEntry.getKey();\n \t\t\tCollection<String> nextIds = nextEntry.getValue();\n \t\t\tif (isBlank(nextResourceType)) {\n \n \t\t\t\tStorageProcessingMessage msg = new StorageProcessingMessage()\n \t\t\t\t\t.setMessage(\"This search uses unqualified resource IDs (an ID without a resource type). This is less efficient than using a qualified type.\");\n+\t\t\t\tourLog.debug(msg.getMessage());", "originalCommit": "1f89732250c9fdbe51b478516c241ad62169f620", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMjMwMA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389832300", "bodyText": "Same with here. Is it maybe worthwhile to pull this out and just broadcast once if the list contained a type-less resource PID? Or is this message valuable for every instance of a pid that was processed?", "author": "tadgh", "createdAt": "2020-03-09T17:08:07Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -22,132 +22,222 @@\n \n import ca.uhn.fhir.context.FhirContext;\n import ca.uhn.fhir.interceptor.api.HookParams;\n+import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n import ca.uhn.fhir.jpa.dao.DaoConfig;\n-import ca.uhn.fhir.jpa.model.cross.ResourcePersistentId;\n import ca.uhn.fhir.jpa.dao.data.IForcedIdDao;\n+import ca.uhn.fhir.jpa.dao.data.IResourceTableDao;\n+import ca.uhn.fhir.jpa.model.cross.IResourceLookup;\n+import ca.uhn.fhir.jpa.model.cross.ResourceLookup;\n+import ca.uhn.fhir.jpa.model.cross.ResourcePersistentId;\n import ca.uhn.fhir.jpa.model.entity.ForcedId;\n-import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;\n-import ca.uhn.fhir.interceptor.api.Pointcut;\n import ca.uhn.fhir.jpa.model.search.StorageProcessingMessage;\n import ca.uhn.fhir.jpa.util.JpaInterceptorBroadcaster;\n import ca.uhn.fhir.model.primitive.IdDt;\n import ca.uhn.fhir.rest.api.server.RequestDetails;\n import ca.uhn.fhir.rest.server.exceptions.ResourceNotFoundException;\n import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n import com.google.common.collect.ListMultimap;\n import com.google.common.collect.MultimapBuilder;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.Validate;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n import org.hl7.fhir.instance.model.api.IIdType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n import javax.annotation.Nonnull;\n-import java.util.*;\n+import javax.annotation.PostConstruct;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n \n import static org.apache.commons.lang3.StringUtils.isBlank;\n \n+/**\n+ * This class is used to convert between PIDs (the internal primary key for a particular resource as\n+ * stored in the {@link ca.uhn.fhir.jpa.model.entity.ResourceTable HFJ_RESOURCE} table), and the\n+ * public ID that a resource has.\n+ * <p>\n+ * These IDs are sometimes one and the same (by default, a resource that the server assigns the ID of\n+ * <code>Patient/1</code> will simply use a PID of 1 and and ID of 1. However, they may also be different\n+ * in cases where a forced ID is used (an arbitrary client-assigned ID).\n+ * </p>\n+ * <p>\n+ * This service is highly optimized in order to minimize the number of DB calls as much as possible,\n+ * since ID resolution is fundamental to many basic operations. This service returns either\n+ * {@link IResourceLookup} or {@link ResourcePersistentId} depending on the method being called.\n+ * The former involves an extra database join that the latter does not require, so selecting the\n+ * right method here is important.\n+ * </p>\n+ */\n @Service\n public class IdHelperService {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(IdHelperService.class);\n+\n \t@Autowired\n \tprotected IForcedIdDao myForcedIdDao;\n+\t@Autowired\n+\tprotected IResourceTableDao myResourceTableDao;\n \t@Autowired(required = true)\n \tprivate DaoConfig myDaoConfig;\n \t@Autowired\n \tprivate IInterceptorBroadcaster myInterceptorBroadcaster;\n \n-\tpublic void delete(ForcedId forcedId) {\n-\t\tmyForcedIdDao.deleteByPid(forcedId.getId());\n+\tprivate Cache<String, Long> myPersistentIdCache;\n+\tprivate Cache<String, IResourceLookup> myResourceLookupCache;\n+\n+\t@PostConstruct\n+\tpublic void start() {\n+\t\tmyPersistentIdCache = newCache();\n+\t\tmyResourceLookupCache = newCache();\n \t}\n \n-\t/**\n-\t * @throws ResourceNotFoundException If the ID can not be found\n-\t */\n-\t@Nonnull\n-\tpublic ResourcePersistentId translateForcedIdToPid(IIdType theId, RequestDetails theRequestDetails) {\n-\t\treturn translateForcedIdToPid(theId.getResourceType(), theId.getIdPart(), theRequestDetails);\n+\n+\tpublic void delete(ForcedId forcedId) {\n+\t\tmyForcedIdDao.deleteByPid(forcedId.getId());\n \t}\n \n \t/**\n+\t * Given a resource type and ID, looks up the resource and returns a {@link IResourceLookup}. This\n+\t * object contains the internal PID for the resource and the resource deletion status, making it sufficient\n+\t * for persisting resource links between resources without adding any further database calls after the\n+\t * single one performed by this call.\n+\t *\n \t * @throws ResourceNotFoundException If the ID can not be found\n \t */\n \t@Nonnull\n-\tpublic ResourcePersistentId translateForcedIdToPid(String theResourceName, String theResourceId, RequestDetails theRequestDetails) throws ResourceNotFoundException {\n+\tpublic IResourceLookup resolveResourceIdentity(String theResourceName, String theResourceId, RequestDetails theRequestDetails) throws ResourceNotFoundException {\n \t\t// We only pass 1 input in so only 0..1 will come back\n \t\tIdDt id = new IdDt(theResourceName, theResourceId);\n-\t\tList<ResourcePersistentId> matches = translateForcedIdToPids(myDaoConfig, myInterceptorBroadcaster, theRequestDetails, myForcedIdDao, Collections.singletonList(id));\n+\t\tCollection<IResourceLookup> matches = translateForcedIdToPids(theRequestDetails, Collections.singletonList(id));\n \t\tassert matches.size() <= 1;\n \t\tif (matches.isEmpty()) {\n \t\t\tthrow new ResourceNotFoundException(id);\n \t\t}\n-\t\treturn matches.get(0);\n+\t\treturn matches.iterator().next();\n \t}\n \n-\tpublic List<ResourcePersistentId> translateForcedIdToPids(Collection<IIdType> theId, RequestDetails theRequestDetails) {\n-\t\treturn IdHelperService.translateForcedIdToPids(myDaoConfig, myInterceptorBroadcaster, theRequestDetails, myForcedIdDao, theId);\n+\t/**\n+\t * Given a resource type and ID, determines the internal persistent ID for the resource.\n+\t *\n+\t * @throws ResourceNotFoundException If the ID can not be found\n+\t */\n+\t@Nonnull\n+\tpublic ResourcePersistentId resolveResourcePersistentIds(String theResourceType, String theId) {\n+\t\tLong retVal;\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(theId)) {\n+\t\t\tif (myDaoConfig.isDeleteEnabled()) {\n+\t\t\t\tretVal = resolveResourceIdentity(theResourceType, theId);\n+\t\t\t} else {\n+\t\t\t\tString key = theResourceType + \"/\" + theId;\n+\t\t\t\tretVal = myPersistentIdCache.get(key, t -> resolveResourceIdentity(theResourceType, theId));\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tretVal = Long.parseLong(theId);\n+\t\t}\n+\n+\t\treturn new ResourcePersistentId(retVal);\n \t}\n \n-\tprivate static List<ResourcePersistentId> translateForcedIdToPids(DaoConfig theDaoConfig, IInterceptorBroadcaster theInterceptorBroadcaster, RequestDetails theRequest, IForcedIdDao theForcedIdDao, Collection<IIdType> theId) {\n-\t\ttheId.forEach(id -> Validate.isTrue(id.hasIdPart()));\n+\t/**\n+\t * Given a collection of resource IDs (resource type + id), resolves the internal persistent IDs\n+\t */\n+\t@Nonnull\n+\tpublic List<ResourcePersistentId> resolveResourcePersistentIds(List<IIdType> theIds, RequestDetails theRequest) {\n+\t\ttheIds.forEach(id -> Validate.isTrue(id.hasIdPart()));\n \n-\t\tif (theId.isEmpty()) {\n+\t\tif (theIds.isEmpty()) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n \n \t\tList<ResourcePersistentId> retVal = new ArrayList<>();\n \n-\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n-\t\tfor (IIdType nextId : theId) {\n-\t\t\tif (theDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY && isValidPid(nextId)) {\n-\t\t\t\tretVal.add(new ResourcePersistentId(nextId.getIdPartAsLong()));\n-\t\t\t} else {\n-\t\t\t\tif (nextId.hasResourceType()) {\n-\t\t\t\t\ttypeToIds.put(nextId.getResourceType(), nextId.getIdPart());\n-\t\t\t\t} else {\n-\t\t\t\t\ttypeToIds.put(\"\", nextId.getIdPart());\n-\t\t\t\t}\n-\t\t\t}\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY) {\n+\t\t\ttheIds\n+\t\t\t\t.stream()\n+\t\t\t\t.filter(t -> isValidPid(t))\n+\t\t\t\t.map(t -> t.getIdPartAsLong())\n+\t\t\t\t.map(t -> new ResourcePersistentId(t))\n+\t\t\t\t.forEach(t -> retVal.add(t));\n \t\t}\n \n+\t\tListMultimap<String, String> typeToIds = organizeIdsByResourceType(theIds);\n+\n \t\tfor (Map.Entry<String, Collection<String>> nextEntry : typeToIds.asMap().entrySet()) {\n \t\t\tString nextResourceType = nextEntry.getKey();\n \t\t\tCollection<String> nextIds = nextEntry.getValue();\n \t\t\tif (isBlank(nextResourceType)) {\n \n \t\t\t\tStorageProcessingMessage msg = new StorageProcessingMessage()\n \t\t\t\t\t.setMessage(\"This search uses unqualified resource IDs (an ID without a resource type). This is less efficient than using a qualified type.\");\n+\t\t\t\tourLog.debug(msg.getMessage());\n \t\t\t\tHookParams params = new HookParams()\n \t\t\t\t\t.add(RequestDetails.class, theRequest)\n \t\t\t\t\t.addIfMatchesType(ServletRequestDetails.class, theRequest)\n \t\t\t\t\t.add(StorageProcessingMessage.class, msg);\n-\t\t\t\tJpaInterceptorBroadcaster.doCallHooks(theInterceptorBroadcaster, theRequest, Pointcut.JPA_PERFTRACE_WARNING, params);\n+\t\t\t\tJpaInterceptorBroadcaster.doCallHooks(myInterceptorBroadcaster, theRequest, Pointcut.JPA_PERFTRACE_WARNING, params);", "originalCommit": "1f89732250c9fdbe51b478516c241ad62169f620", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzNDc2Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389834766", "bodyText": "This is essentially an undocumented data structure, and its a bit tough to read unless you know the full context. Is it worthwhile maybe creating a small data class that can consume one of these known object arrays and making it more readable? If this is super one-off, maybe just comment this block of code", "author": "tadgh", "createdAt": "2020-03-09T17:12:03Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -22,132 +22,222 @@\n \n import ca.uhn.fhir.context.FhirContext;\n import ca.uhn.fhir.interceptor.api.HookParams;\n+import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n import ca.uhn.fhir.jpa.dao.DaoConfig;\n-import ca.uhn.fhir.jpa.model.cross.ResourcePersistentId;\n import ca.uhn.fhir.jpa.dao.data.IForcedIdDao;\n+import ca.uhn.fhir.jpa.dao.data.IResourceTableDao;\n+import ca.uhn.fhir.jpa.model.cross.IResourceLookup;\n+import ca.uhn.fhir.jpa.model.cross.ResourceLookup;\n+import ca.uhn.fhir.jpa.model.cross.ResourcePersistentId;\n import ca.uhn.fhir.jpa.model.entity.ForcedId;\n-import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;\n-import ca.uhn.fhir.interceptor.api.Pointcut;\n import ca.uhn.fhir.jpa.model.search.StorageProcessingMessage;\n import ca.uhn.fhir.jpa.util.JpaInterceptorBroadcaster;\n import ca.uhn.fhir.model.primitive.IdDt;\n import ca.uhn.fhir.rest.api.server.RequestDetails;\n import ca.uhn.fhir.rest.server.exceptions.ResourceNotFoundException;\n import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n import com.google.common.collect.ListMultimap;\n import com.google.common.collect.MultimapBuilder;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.Validate;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n import org.hl7.fhir.instance.model.api.IIdType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n import javax.annotation.Nonnull;\n-import java.util.*;\n+import javax.annotation.PostConstruct;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n \n import static org.apache.commons.lang3.StringUtils.isBlank;\n \n+/**\n+ * This class is used to convert between PIDs (the internal primary key for a particular resource as\n+ * stored in the {@link ca.uhn.fhir.jpa.model.entity.ResourceTable HFJ_RESOURCE} table), and the\n+ * public ID that a resource has.\n+ * <p>\n+ * These IDs are sometimes one and the same (by default, a resource that the server assigns the ID of\n+ * <code>Patient/1</code> will simply use a PID of 1 and and ID of 1. However, they may also be different\n+ * in cases where a forced ID is used (an arbitrary client-assigned ID).\n+ * </p>\n+ * <p>\n+ * This service is highly optimized in order to minimize the number of DB calls as much as possible,\n+ * since ID resolution is fundamental to many basic operations. This service returns either\n+ * {@link IResourceLookup} or {@link ResourcePersistentId} depending on the method being called.\n+ * The former involves an extra database join that the latter does not require, so selecting the\n+ * right method here is important.\n+ * </p>\n+ */\n @Service\n public class IdHelperService {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(IdHelperService.class);\n+\n \t@Autowired\n \tprotected IForcedIdDao myForcedIdDao;\n+\t@Autowired\n+\tprotected IResourceTableDao myResourceTableDao;\n \t@Autowired(required = true)\n \tprivate DaoConfig myDaoConfig;\n \t@Autowired\n \tprivate IInterceptorBroadcaster myInterceptorBroadcaster;\n \n-\tpublic void delete(ForcedId forcedId) {\n-\t\tmyForcedIdDao.deleteByPid(forcedId.getId());\n+\tprivate Cache<String, Long> myPersistentIdCache;\n+\tprivate Cache<String, IResourceLookup> myResourceLookupCache;\n+\n+\t@PostConstruct\n+\tpublic void start() {\n+\t\tmyPersistentIdCache = newCache();\n+\t\tmyResourceLookupCache = newCache();\n \t}\n \n-\t/**\n-\t * @throws ResourceNotFoundException If the ID can not be found\n-\t */\n-\t@Nonnull\n-\tpublic ResourcePersistentId translateForcedIdToPid(IIdType theId, RequestDetails theRequestDetails) {\n-\t\treturn translateForcedIdToPid(theId.getResourceType(), theId.getIdPart(), theRequestDetails);\n+\n+\tpublic void delete(ForcedId forcedId) {\n+\t\tmyForcedIdDao.deleteByPid(forcedId.getId());\n \t}\n \n \t/**\n+\t * Given a resource type and ID, looks up the resource and returns a {@link IResourceLookup}. This\n+\t * object contains the internal PID for the resource and the resource deletion status, making it sufficient\n+\t * for persisting resource links between resources without adding any further database calls after the\n+\t * single one performed by this call.\n+\t *\n \t * @throws ResourceNotFoundException If the ID can not be found\n \t */\n \t@Nonnull\n-\tpublic ResourcePersistentId translateForcedIdToPid(String theResourceName, String theResourceId, RequestDetails theRequestDetails) throws ResourceNotFoundException {\n+\tpublic IResourceLookup resolveResourceIdentity(String theResourceName, String theResourceId, RequestDetails theRequestDetails) throws ResourceNotFoundException {\n \t\t// We only pass 1 input in so only 0..1 will come back\n \t\tIdDt id = new IdDt(theResourceName, theResourceId);\n-\t\tList<ResourcePersistentId> matches = translateForcedIdToPids(myDaoConfig, myInterceptorBroadcaster, theRequestDetails, myForcedIdDao, Collections.singletonList(id));\n+\t\tCollection<IResourceLookup> matches = translateForcedIdToPids(theRequestDetails, Collections.singletonList(id));\n \t\tassert matches.size() <= 1;\n \t\tif (matches.isEmpty()) {\n \t\t\tthrow new ResourceNotFoundException(id);\n \t\t}\n-\t\treturn matches.get(0);\n+\t\treturn matches.iterator().next();\n \t}\n \n-\tpublic List<ResourcePersistentId> translateForcedIdToPids(Collection<IIdType> theId, RequestDetails theRequestDetails) {\n-\t\treturn IdHelperService.translateForcedIdToPids(myDaoConfig, myInterceptorBroadcaster, theRequestDetails, myForcedIdDao, theId);\n+\t/**\n+\t * Given a resource type and ID, determines the internal persistent ID for the resource.\n+\t *\n+\t * @throws ResourceNotFoundException If the ID can not be found\n+\t */\n+\t@Nonnull\n+\tpublic ResourcePersistentId resolveResourcePersistentIds(String theResourceType, String theId) {\n+\t\tLong retVal;\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(theId)) {\n+\t\t\tif (myDaoConfig.isDeleteEnabled()) {\n+\t\t\t\tretVal = resolveResourceIdentity(theResourceType, theId);\n+\t\t\t} else {\n+\t\t\t\tString key = theResourceType + \"/\" + theId;\n+\t\t\t\tretVal = myPersistentIdCache.get(key, t -> resolveResourceIdentity(theResourceType, theId));\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tretVal = Long.parseLong(theId);\n+\t\t}\n+\n+\t\treturn new ResourcePersistentId(retVal);\n \t}\n \n-\tprivate static List<ResourcePersistentId> translateForcedIdToPids(DaoConfig theDaoConfig, IInterceptorBroadcaster theInterceptorBroadcaster, RequestDetails theRequest, IForcedIdDao theForcedIdDao, Collection<IIdType> theId) {\n-\t\ttheId.forEach(id -> Validate.isTrue(id.hasIdPart()));\n+\t/**\n+\t * Given a collection of resource IDs (resource type + id), resolves the internal persistent IDs\n+\t */\n+\t@Nonnull\n+\tpublic List<ResourcePersistentId> resolveResourcePersistentIds(List<IIdType> theIds, RequestDetails theRequest) {\n+\t\ttheIds.forEach(id -> Validate.isTrue(id.hasIdPart()));\n \n-\t\tif (theId.isEmpty()) {\n+\t\tif (theIds.isEmpty()) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n \n \t\tList<ResourcePersistentId> retVal = new ArrayList<>();\n \n-\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n-\t\tfor (IIdType nextId : theId) {\n-\t\t\tif (theDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY && isValidPid(nextId)) {\n-\t\t\t\tretVal.add(new ResourcePersistentId(nextId.getIdPartAsLong()));\n-\t\t\t} else {\n-\t\t\t\tif (nextId.hasResourceType()) {\n-\t\t\t\t\ttypeToIds.put(nextId.getResourceType(), nextId.getIdPart());\n-\t\t\t\t} else {\n-\t\t\t\t\ttypeToIds.put(\"\", nextId.getIdPart());\n-\t\t\t\t}\n-\t\t\t}\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY) {\n+\t\t\ttheIds\n+\t\t\t\t.stream()\n+\t\t\t\t.filter(t -> isValidPid(t))\n+\t\t\t\t.map(t -> t.getIdPartAsLong())\n+\t\t\t\t.map(t -> new ResourcePersistentId(t))\n+\t\t\t\t.forEach(t -> retVal.add(t));\n \t\t}\n \n+\t\tListMultimap<String, String> typeToIds = organizeIdsByResourceType(theIds);\n+\n \t\tfor (Map.Entry<String, Collection<String>> nextEntry : typeToIds.asMap().entrySet()) {\n \t\t\tString nextResourceType = nextEntry.getKey();\n \t\t\tCollection<String> nextIds = nextEntry.getValue();\n \t\t\tif (isBlank(nextResourceType)) {\n \n \t\t\t\tStorageProcessingMessage msg = new StorageProcessingMessage()\n \t\t\t\t\t.setMessage(\"This search uses unqualified resource IDs (an ID without a resource type). This is less efficient than using a qualified type.\");\n+\t\t\t\tourLog.debug(msg.getMessage());\n \t\t\t\tHookParams params = new HookParams()\n \t\t\t\t\t.add(RequestDetails.class, theRequest)\n \t\t\t\t\t.addIfMatchesType(ServletRequestDetails.class, theRequest)\n \t\t\t\t\t.add(StorageProcessingMessage.class, msg);\n-\t\t\t\tJpaInterceptorBroadcaster.doCallHooks(theInterceptorBroadcaster, theRequest, Pointcut.JPA_PERFTRACE_WARNING, params);\n+\t\t\t\tJpaInterceptorBroadcaster.doCallHooks(myInterceptorBroadcaster, theRequest, Pointcut.JPA_PERFTRACE_WARNING, params);\n \n-\t\t\t\ttheForcedIdDao\n-\t\t\t\t\t.findByForcedId(nextIds)\n-\t\t\t\t\t.stream()\n-\t\t\t\t\t.map(t->new ResourcePersistentId(t))\n-\t\t\t\t\t.forEach(t->retVal.add(t));\n+\t\t\t\tList<Long> views = myForcedIdDao.findByForcedId(nextIds);\n+\t\t\t\tviews.forEach(t -> retVal.add(new ResourcePersistentId(t)));\n \n \t\t\t} else {\n \n-\t\t\t\ttheForcedIdDao\n-\t\t\t\t\t.findByTypeAndForcedId(nextResourceType, nextIds)\n-\t\t\t\t\t.stream()\n-\t\t\t\t\t.map(t->new ResourcePersistentId(t))\n-\t\t\t\t\t.forEach(t->retVal.add(t));\n+\t\t\t\tif (!myDaoConfig.isDeleteEnabled()) {\n+\t\t\t\t\tfor (Iterator<String> idIterator = nextIds.iterator(); idIterator.hasNext(); ) {\n+\t\t\t\t\t\tString nextId = idIterator.next();\n+\t\t\t\t\t\tString key = nextResourceType + \"/\" + nextId;\n+\t\t\t\t\t\tLong nextCachedPid = myPersistentIdCache.getIfPresent(key);\n+\t\t\t\t\t\tif (nextCachedPid != null) {\n+\t\t\t\t\t\t\tidIterator.remove();\n+\t\t\t\t\t\t\tretVal.add(new ResourcePersistentId(nextCachedPid));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (nextIds.size() > 0) {\n+\t\t\t\t\tCollection<Object[]> views = myForcedIdDao.findByTypeAndForcedId(nextResourceType, nextIds);\n+\t\t\t\t\tfor (Object[] nextView : views) {\n+\t\t\t\t\t\tString forcedId = (String) nextView[0];\n+\t\t\t\t\t\tLong pid = (Long) nextView[1];", "originalCommit": "1f89732250c9fdbe51b478516c241ad62169f620", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzNzY4OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389837688", "bodyText": "Question: Why is this check necessary? Seems as though this function should organize IDs by type regardless of the ResourceClientIdStrategy, or if the pid is valid or not. If that isnt what this function is supposed to do, (e.g. it should only work on non-valid pids), then this function should be renamed.", "author": "tadgh", "createdAt": "2020-03-09T17:16:36Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -156,17 +246,136 @@ public String translatePidIdToForcedId(String theResourceType, ResourcePersisten\n \t\t}\n \t}\n \n+\tprivate ListMultimap<String, String> organizeIdsByResourceType(Collection<IIdType> theIds) {\n+\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n+\t\tfor (IIdType nextId : theIds) {\n+\t\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(nextId)) {", "originalCommit": "1f89732250c9fdbe51b478516c241ad62169f620", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzOTE5Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389839196", "bodyText": "Suggestion: theIds", "author": "tadgh", "createdAt": "2020-03-09T17:18:57Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -156,17 +246,136 @@ public String translatePidIdToForcedId(String theResourceType, ResourcePersisten\n \t\t}\n \t}\n \n+\tprivate ListMultimap<String, String> organizeIdsByResourceType(Collection<IIdType> theIds) {\n+\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n+\t\tfor (IIdType nextId : theIds) {\n+\t\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(nextId)) {\n+\t\t\t\tif (nextId.hasResourceType()) {\n+\t\t\t\t\ttypeToIds.put(nextId.getResourceType(), nextId.getIdPart());\n+\t\t\t\t} else {\n+\t\t\t\t\ttypeToIds.put(\"\", nextId.getIdPart());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn typeToIds;\n+\t}\n+\n+\tprivate Long resolveResourceIdentity(String theResourceType, String theId) {\n+\t\tLong retVal;\n+\t\tretVal = myForcedIdDao\n+\t\t\t.findByTypeAndForcedId(theResourceType, theId)\n+\t\t\t.orElseThrow(() -> new ResourceNotFoundException(new IdDt(theResourceType, theId)));\n+\t\treturn retVal;\n+\t}\n+\n+\tprivate Collection<IResourceLookup> translateForcedIdToPids(RequestDetails theRequest, Collection<IIdType> theId) {", "originalCommit": "1f89732250c9fdbe51b478516c241ad62169f620", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5NTYxNQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r391895615", "bodyText": "Done", "author": "jamesagnew", "createdAt": "2020-03-12T21:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzOTE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0MDMzMQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389840331", "bodyText": "So this only works in case where Delete is disabled? Is that because it would be too much of a pain to maintain the cache in a scenario where resource deletion is possible?", "author": "tadgh", "createdAt": "2020-03-09T17:20:46Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -156,17 +246,136 @@ public String translatePidIdToForcedId(String theResourceType, ResourcePersisten\n \t\t}\n \t}\n \n+\tprivate ListMultimap<String, String> organizeIdsByResourceType(Collection<IIdType> theIds) {\n+\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n+\t\tfor (IIdType nextId : theIds) {\n+\t\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(nextId)) {\n+\t\t\t\tif (nextId.hasResourceType()) {\n+\t\t\t\t\ttypeToIds.put(nextId.getResourceType(), nextId.getIdPart());\n+\t\t\t\t} else {\n+\t\t\t\t\ttypeToIds.put(\"\", nextId.getIdPart());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn typeToIds;\n+\t}\n+\n+\tprivate Long resolveResourceIdentity(String theResourceType, String theId) {\n+\t\tLong retVal;\n+\t\tretVal = myForcedIdDao\n+\t\t\t.findByTypeAndForcedId(theResourceType, theId)\n+\t\t\t.orElseThrow(() -> new ResourceNotFoundException(new IdDt(theResourceType, theId)));\n+\t\treturn retVal;\n+\t}\n+\n+\tprivate Collection<IResourceLookup> translateForcedIdToPids(RequestDetails theRequest, Collection<IIdType> theId) {\n+\t\ttheId.forEach(id -> Validate.isTrue(id.hasIdPart()));\n+\n+\t\tif (theId.isEmpty()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\tList<IResourceLookup> retVal = new ArrayList<>();\n+\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY) {\n+\t\t\tList<Long> pids = theId\n+\t\t\t\t.stream()\n+\t\t\t\t.filter(t -> isValidPid(t))\n+\t\t\t\t.map(t -> t.getIdPartAsLong())\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\tif (!pids.isEmpty()) {\n+\n+\t\t\t\tCollection<Object[]> lookups = myResourceTableDao.findLookupFieldsByResourcePid(pids);\n+\t\t\t\tfor (Object[] next : lookups) {\n+\t\t\t\t\tString resourceType = (String) next[0];\n+\t\t\t\t\tLong resourcePid = (Long) next[1];\n+\t\t\t\t\tDate deletedAt = (Date) next[2];\n+\t\t\t\t\tretVal.add(new ResourceLookup(resourceType, resourcePid, deletedAt));\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t}\n+\n+\t\tListMultimap<String, String> typeToIds = organizeIdsByResourceType(theId);\n+\t\tfor (Map.Entry<String, Collection<String>> nextEntry : typeToIds.asMap().entrySet()) {\n+\t\t\tString nextResourceType = nextEntry.getKey();\n+\t\t\tCollection<String> nextIds = nextEntry.getValue();\n+\n+\t\t\tif (!myDaoConfig.isDeleteEnabled()) {\n+\t\t\t\tfor (Iterator<String> forcedIdIterator = nextIds.iterator(); forcedIdIterator.hasNext(); ) {\n+\t\t\t\t\tString nextForcedId = forcedIdIterator.next();\n+\t\t\t\t\tString nextKey = nextResourceType + \"/\" + nextForcedId;\n+\t\t\t\t\tIResourceLookup cachedLookup = myResourceLookupCache.getIfPresent(nextKey);\n+\t\t\t\t\tif (cachedLookup != null) {\n+\t\t\t\t\t\tforcedIdIterator.remove();\n+\t\t\t\t\t\tretVal.add(cachedLookup);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}", "originalCommit": "1f89732250c9fdbe51b478516c241ad62169f620", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg5MTA0OA==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389891048", "bodyText": "The idea here is that it's still an improvement even if delete is enabled (some operations dropped from  4 or 5 SELECTS to 2 or 3) but it's an even bigger improvement if we have deletes disabled since then the cache can drop to 0 to 2.\nThe reason is that we need to check whether a resource is deleted if there is a reference targeting that resource (i.e. you can't create a resource with a reference to a deleted resource). We bundle that check into the same lookup so as to reduce the number of DB round trips, but then we can't trust the cache if things might have been deleted..\nThe reason deletes matter is that we cache the deletion status along with", "author": "jamesagnew", "createdAt": "2020-03-09T18:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0MDMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0MjM4MQ==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389842381", "bodyText": "This is the 2nd or 3rd time I've seen this chunk of code. Maybe a constant for this string, or rip the whole Interceptor Broadcast out into a helper function", "author": "tadgh", "createdAt": "2020-03-09T17:23:59Z", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -156,17 +246,136 @@ public String translatePidIdToForcedId(String theResourceType, ResourcePersisten\n \t\t}\n \t}\n \n+\tprivate ListMultimap<String, String> organizeIdsByResourceType(Collection<IIdType> theIds) {\n+\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n+\t\tfor (IIdType nextId : theIds) {\n+\t\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(nextId)) {\n+\t\t\t\tif (nextId.hasResourceType()) {\n+\t\t\t\t\ttypeToIds.put(nextId.getResourceType(), nextId.getIdPart());\n+\t\t\t\t} else {\n+\t\t\t\t\ttypeToIds.put(\"\", nextId.getIdPart());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn typeToIds;\n+\t}\n+\n+\tprivate Long resolveResourceIdentity(String theResourceType, String theId) {\n+\t\tLong retVal;\n+\t\tretVal = myForcedIdDao\n+\t\t\t.findByTypeAndForcedId(theResourceType, theId)\n+\t\t\t.orElseThrow(() -> new ResourceNotFoundException(new IdDt(theResourceType, theId)));\n+\t\treturn retVal;\n+\t}\n+\n+\tprivate Collection<IResourceLookup> translateForcedIdToPids(RequestDetails theRequest, Collection<IIdType> theId) {\n+\t\ttheId.forEach(id -> Validate.isTrue(id.hasIdPart()));\n+\n+\t\tif (theId.isEmpty()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\tList<IResourceLookup> retVal = new ArrayList<>();\n+\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY) {\n+\t\t\tList<Long> pids = theId\n+\t\t\t\t.stream()\n+\t\t\t\t.filter(t -> isValidPid(t))\n+\t\t\t\t.map(t -> t.getIdPartAsLong())\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\tif (!pids.isEmpty()) {\n+\n+\t\t\t\tCollection<Object[]> lookups = myResourceTableDao.findLookupFieldsByResourcePid(pids);\n+\t\t\t\tfor (Object[] next : lookups) {\n+\t\t\t\t\tString resourceType = (String) next[0];\n+\t\t\t\t\tLong resourcePid = (Long) next[1];\n+\t\t\t\t\tDate deletedAt = (Date) next[2];\n+\t\t\t\t\tretVal.add(new ResourceLookup(resourceType, resourcePid, deletedAt));\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t}\n+\n+\t\tListMultimap<String, String> typeToIds = organizeIdsByResourceType(theId);\n+\t\tfor (Map.Entry<String, Collection<String>> nextEntry : typeToIds.asMap().entrySet()) {\n+\t\t\tString nextResourceType = nextEntry.getKey();\n+\t\t\tCollection<String> nextIds = nextEntry.getValue();\n+\n+\t\t\tif (!myDaoConfig.isDeleteEnabled()) {\n+\t\t\t\tfor (Iterator<String> forcedIdIterator = nextIds.iterator(); forcedIdIterator.hasNext(); ) {\n+\t\t\t\t\tString nextForcedId = forcedIdIterator.next();\n+\t\t\t\t\tString nextKey = nextResourceType + \"/\" + nextForcedId;\n+\t\t\t\t\tIResourceLookup cachedLookup = myResourceLookupCache.getIfPresent(nextKey);\n+\t\t\t\t\tif (cachedLookup != null) {\n+\t\t\t\t\t\tforcedIdIterator.remove();\n+\t\t\t\t\t\tretVal.add(cachedLookup);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (nextIds.size() > 0) {\n+\t\t\t\tCollection<Object[]> views;\n+\t\t\t\tif (isBlank(nextResourceType)) {\n+\n+\t\t\t\t\tStorageProcessingMessage msg = new StorageProcessingMessage()\n+\t\t\t\t\t\t.setMessage(\"This search uses unqualified resource IDs (an ID without a resource type). This is less efficient than using a qualified type.\");", "originalCommit": "1f89732250c9fdbe51b478516c241ad62169f620", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4ODI1Ng==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389888256", "bodyText": "good call, done", "author": "jamesagnew", "createdAt": "2020-03-09T18:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0MjM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0NzM2Mg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389847362", "bodyText": "Out of curiosity, why create two here?", "author": "tadgh", "createdAt": "2020-03-09T17:31:24Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4QueryCountTest.java", "diffHunk": "@@ -164,6 +156,177 @@ public void testCreateWithClientAssignedId() {\n \t}\n \n \n+\t@Test\n+\tpublic void testReferenceToForcedId() {\n+\t\tmyDaoConfig.setIndexMissingFields(DaoConfig.IndexEnabledEnum.DISABLED);\n+\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"P\");\n+\t\tpatient.setActive(true);\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tmyPatientDao.update(patient);\n+\n+\t\t/*\n+\t\t * Add a resource with a forced ID target link\n+\t\t */\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tObservation observation = new Observation();\n+\t\tobservation.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.create(observation);\n+\t\tmyCaptureQueriesListener.logAllQueriesForCurrentThread();\n+\t\t// select: lookup forced ID\n+\t\tassertEquals(1, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countDeleteQueriesForCurrentThread());\n+\t\t// insert to: HFJ_RESOURCE, HFJ_RES_VER, HFJ_RES_LINK\n+\t\tassertEquals(3, myCaptureQueriesListener.countInsertQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n+\n+\t\t/*\n+\t\t * Add another\n+\t\t */\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tobservation = new Observation();\n+\t\tobservation.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.create(observation);\n+\t\t// select: lookup forced ID\n+\t\tassertEquals(1, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countDeleteQueriesForCurrentThread());\n+\t\t// insert to: HFJ_RESOURCE, HFJ_RES_VER, HFJ_RES_LINK\n+\t\tassertEquals(3, myCaptureQueriesListener.countInsertQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n+", "originalCommit": "1f89732250c9fdbe51b478516c241ad62169f620", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg4ODM3Nw==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389888377", "bodyText": "per below", "author": "jamesagnew", "createdAt": "2020-03-09T18:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0NzM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0NzYxMg==", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389847612", "bodyText": "ah I now see why", "author": "tadgh", "createdAt": "2020-03-09T17:31:50Z", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4QueryCountTest.java", "diffHunk": "@@ -164,6 +156,177 @@ public void testCreateWithClientAssignedId() {\n \t}\n \n \n+\t@Test\n+\tpublic void testReferenceToForcedId() {\n+\t\tmyDaoConfig.setIndexMissingFields(DaoConfig.IndexEnabledEnum.DISABLED);\n+\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"P\");\n+\t\tpatient.setActive(true);\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tmyPatientDao.update(patient);\n+\n+\t\t/*\n+\t\t * Add a resource with a forced ID target link\n+\t\t */\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tObservation observation = new Observation();\n+\t\tobservation.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.create(observation);\n+\t\tmyCaptureQueriesListener.logAllQueriesForCurrentThread();\n+\t\t// select: lookup forced ID\n+\t\tassertEquals(1, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countDeleteQueriesForCurrentThread());\n+\t\t// insert to: HFJ_RESOURCE, HFJ_RES_VER, HFJ_RES_LINK\n+\t\tassertEquals(3, myCaptureQueriesListener.countInsertQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n+\n+\t\t/*\n+\t\t * Add another\n+\t\t */\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tobservation = new Observation();\n+\t\tobservation.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.create(observation);\n+\t\t// select: lookup forced ID\n+\t\tassertEquals(1, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countDeleteQueriesForCurrentThread());\n+\t\t// insert to: HFJ_RESOURCE, HFJ_RES_VER, HFJ_RES_LINK\n+\t\tassertEquals(3, myCaptureQueriesListener.countInsertQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n+\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testReferenceToForcedId_DeletesDisabled() {\n+\t\tmyDaoConfig.setIndexMissingFields(DaoConfig.IndexEnabledEnum.DISABLED);\n+\t\tmyDaoConfig.setDeleteEnabled(false);\n+\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"P\");\n+\t\tpatient.setActive(true);\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tmyPatientDao.update(patient);\n+\n+\t\t/*\n+\t\t * Add a resource with a forced ID target link\n+\t\t */\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tObservation observation = new Observation();\n+\t\tobservation.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.create(observation);\n+\t\tmyCaptureQueriesListener.logAllQueriesForCurrentThread();\n+\t\t// select: lookup forced ID\n+\t\tassertEquals(1, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countDeleteQueriesForCurrentThread());\n+\t\t// insert to: HFJ_RESOURCE, HFJ_RES_VER, HFJ_RES_LINK\n+\t\tassertEquals(3, myCaptureQueriesListener.countInsertQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n+\n+\t\t/*\n+\t\t * Add another\n+\t\t */\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tobservation = new Observation();\n+\t\tobservation.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.create(observation);\n+\t\t// select: no lookups needed because of cache", "originalCommit": "1f89732250c9fdbe51b478516c241ad62169f620", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e1fad7076931e4fb8df93343b351a7900c38c239", "url": "https://github.com/hapifhir/hapi-fhir/commit/e1fad7076931e4fb8df93343b351a7900c38c239", "message": "Address review comments", "committedDate": "2020-03-10T12:45:34Z", "type": "commit"}, {"oid": "5b67554052a0de683fa67f1baf84cc90951fc1fc", "url": "https://github.com/hapifhir/hapi-fhir/commit/5b67554052a0de683fa67f1baf84cc90951fc1fc", "message": "Compile fix", "committedDate": "2020-03-12T21:12:06Z", "type": "commit"}]}