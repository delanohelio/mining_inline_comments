{"pr_number": 3187, "pr_title": "Add support for flexible transit routing", "pr_createdAt": "2020-09-18T08:57:29Z", "pr_url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187", "timeline": [{"oid": "b17ac1da6e5eb35553a53017e3f8c93d35acce01", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/b17ac1da6e5eb35553a53017e3f8c93d35acce01", "message": "Add FLEXIBLE as transit mode", "committedDate": "2020-09-18T08:14:08Z", "type": "commit"}, {"oid": "0219bb8f2f795fc9f14b034210507e9722c58edd", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/0219bb8f2f795fc9f14b034210507e9722c58edd", "message": "Add DistanceCalculator", "committedDate": "2020-09-18T08:36:27Z", "type": "commit"}, {"oid": "9f70dbc10f1e0f69f6e686b42085fc5eb8b1b837", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/9f70dbc10f1e0f69f6e686b42085fc5eb8b1b837", "message": "Find flex locations when splitting streets for access/egress", "committedDate": "2020-09-18T08:37:52Z", "type": "commit"}, {"oid": "41d4f78595351387691e689a96c930c0940ce274", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/41d4f78595351387691e689a96c930c0940ce274", "message": "Add FlexRouter", "committedDate": "2020-09-18T08:46:51Z", "type": "commit"}, {"oid": "29145c7230a80f0c21fc25d5b541d8ad000758b3", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/29145c7230a80f0c21fc25d5b541d8ad000758b3", "message": "Make AccessEgressRouter return StopAtDistance", "committedDate": "2020-09-18T08:54:45Z", "type": "commit"}, {"oid": "2f40da1dc230a78dc355b6553cd62a759ce644e6", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/2f40da1dc230a78dc355b6553cd62a759ce644e6", "message": "Wire in FlexRouter", "committedDate": "2020-09-18T08:54:58Z", "type": "commit"}, {"oid": "0909081a57da212d4c88038c9f0c5a9c3f3acbf9", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/0909081a57da212d4c88038c9f0c5a9c3f3acbf9", "message": "Improve mapping of ScheduledDeviatedTrip", "committedDate": "2020-09-18T11:12:13Z", "type": "commit"}, {"oid": "539086c387320c547b2fc9803d63f8d4ab98943c", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/539086c387320c547b2fc9803d63f8d4ab98943c", "message": "Add progress tracker", "committedDate": "2020-09-22T08:15:38Z", "type": "commit"}, {"oid": "bd7128519bfff9685d732094996e2eb0ce18008d", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/bd7128519bfff9685d732094996e2eb0ce18008d", "message": "Fix accesses within no through traffic area", "committedDate": "2020-09-22T08:15:48Z", "type": "commit"}, {"oid": "681acd20acf9c56073616856d09c49f43668be45", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/681acd20acf9c56073616856d09c49f43668be45", "message": "Improve flex mapping", "committedDate": "2020-09-22T08:15:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MTM5MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492591391", "bodyText": "Move the mapping to a Mapper class under the RoutingWorker, and rename this class to something like NearByStop.", "author": "t2gran", "createdAt": "2020-09-22T09:20:30Z", "path": "src/main/java/org/opentripplanner/routing/graphfinder/StopAtDistance.java", "diffHunk": "@@ -55,6 +57,15 @@ public int compareTo(StopAtDistance that) {\n     return (int) (this.distance) - (int) (that.distance);\n   }\n \n+  public AccessEgress toAccessEgress(StopIndexForRaptor stopIndex, boolean fromTarget) {", "originalCommit": "29145c7230a80f0c21fc25d5b541d8ad000758b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NDQzOQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492594439", "bodyText": "Rename parameters to fromStopIndex, toStopIndex", "author": "t2gran", "createdAt": "2020-09-22T09:25:17Z", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceCalculator.java", "diffHunk": "@@ -0,0 +1,11 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+import org.opentripplanner.routing.graph.Vertex;\n+\n+/**\n+ * DistanceCalculator is used to calculate the driving times and distances during flex routing\n+ */\n+public interface DistanceCalculator {\n+  DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex);", "originalCommit": "0219bb8f2f795fc9f14b034210507e9722c58edd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMjMxNw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492602317", "bodyText": "Add the geometry here? And then the class name become FlexPath?", "author": "t2gran", "createdAt": "2020-09-22T09:38:30Z", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceAndDuration.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+/**\n+ * This class contains the results from a DistanceCalculator.\n+ */\n+public class DistanceAndDuration {\n+\n+  public int distanceMeters;\n+  public int durationSeconds;", "originalCommit": "0219bb8f2f795fc9f14b034210507e9722c58edd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDIxNw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492604217", "bodyText": "get more than duration, rename calculaeFlexPath", "author": "t2gran", "createdAt": "2020-09-22T09:41:46Z", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.routing.algorithm.astar.AStar;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.spt.DominanceFunction;\n+import org.opentripplanner.routing.spt.GraphPath;\n+import org.opentripplanner.routing.spt.ShortestPathTree;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * StreetDistanceCalculator calculates the driving times and distances based on the street network\n+ * using the AStar algorithm.\n+ *\n+ * TODO: - Mast fast enough to be usable\n+ *       - Use a one-to-many search\n+ *       - Cache found times\n+ */\n+public class StreetDistanceCalculator implements DistanceCalculator {\n+  private Graph graph;\n+  private Map<T2<Vertex, Vertex>, DistanceAndDuration> cache = new HashMap<>();\n+\n+  public StreetDistanceCalculator(Graph graph) {\n+    this.graph = graph;\n+  }\n+\n+  @Override\n+  public DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex) {", "originalCommit": "0219bb8f2f795fc9f14b034210507e9722c58edd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDc3Mw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492604773", "bodyText": "What happes if we can not find a path?", "author": "t2gran", "createdAt": "2020-09-22T09:42:49Z", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.routing.algorithm.astar.AStar;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.spt.DominanceFunction;\n+import org.opentripplanner.routing.spt.GraphPath;\n+import org.opentripplanner.routing.spt.ShortestPathTree;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * StreetDistanceCalculator calculates the driving times and distances based on the street network\n+ * using the AStar algorithm.\n+ *\n+ * TODO: - Mast fast enough to be usable\n+ *       - Use a one-to-many search\n+ *       - Cache found times\n+ */\n+public class StreetDistanceCalculator implements DistanceCalculator {\n+  private Graph graph;\n+  private Map<T2<Vertex, Vertex>, DistanceAndDuration> cache = new HashMap<>();\n+\n+  public StreetDistanceCalculator(Graph graph) {\n+    this.graph = graph;\n+  }\n+\n+  @Override\n+  public DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex) {\n+    T2<Vertex, Vertex> key = new T2<>(fromv, tov);\n+    DistanceAndDuration cacheValue = cache.get(key);\n+    if (cacheValue != null) return cacheValue;\n+\n+    RoutingRequest routingRequest = new RoutingRequest(TraverseMode.CAR);\n+    routingRequest.setNumItineraries(1);\n+\n+    routingRequest.setRoutingContext(graph, fromv, tov);\n+    routingRequest.dominanceFunction = new DominanceFunction.EarliestArrival();\n+    AStar search = new AStar();\n+    ShortestPathTree spt = search.getShortestPathTree(routingRequest);\n+\n+    GraphPath path = spt.getPaths().get(0);\n+\n+    int distance = (int) path.edges.stream().mapToDouble(Edge::getDistanceMeters).sum();\n+    int duration = path.getDuration();", "originalCommit": "0219bb8f2f795fc9f14b034210507e9722c58edd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNzEwNA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492607104", "bodyText": "Use the isEligibleForCarPickupDropOff()  here instead.", "author": "t2gran", "createdAt": "2020-09-22T09:46:58Z", "path": "src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java", "diffHunk": "@@ -408,6 +412,22 @@ else if (ll.getSegmentIndex() == orig.getNumPoints() - 2 && ll.getSegmentFractio\n             SplitterVertex v0 = split(edge, ll, temporaryVertex != null, endVertex);\n             makeLinkEdges(tstop, v0);\n \n+            if (OTPFeature.FlexRouting.isOn() && graph.index != null) {\n+                Point p = GeometryUtils\n+                    .getGeometryFactory()\n+                    .createPoint(v0.getCoordinate());\n+                Envelope env = p.getEnvelopeInternal();\n+                for (FlexStopLocation flexStopLocation : graph.index.getFlexIndex().locationIndex.query(env)) {\n+                    if (edge.canTraverse(new TraverseModeSet(TraverseMode.CAR))", "originalCommit": "9f70dbc10f1e0f69f6e686b42085fc5eb8b1b837", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA4MzYwNA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494083604", "bodyText": "Using StreetTraversalPermission.PEDESTRIAN_AND_CAR, as isEligibleForCarPickupDropOff() operates on vertices", "author": "hannesj", "createdAt": "2020-09-24T07:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNzEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNzA4MA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492617080", "bodyText": "Decuple the raptor API from Flex", "author": "t2gran", "createdAt": "2020-09-22T10:04:16Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.opentripplanner.ext.flex;\n+\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.routing.algorithm.raptor.transit.AccessEgress;\n+import org.opentripplanner.routing.core.State;\n+\n+public class FlexAccessEgress extends AccessEgress {", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYyMDMwNQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492620305", "bodyText": "Remove this parameter, the stopIndex - it should not be necessary if the mapping to Raptor is moved out of flex.", "author": "t2gran", "createdAt": "2020-09-22T10:10:14Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYyNTQyNg==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492625426", "bodyText": "Maybe something like this:\nclass FlexServicesOnDate {\n  private final TIntSet servicesRunning;\n  private final int secondsFromStartOfTime;\n  private final ServiceDate serviceDate;\n}", "author": "t2gran", "createdAt": "2020-09-22T10:19:55Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzMDM4Mw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492630383", "bodyText": "Maybe add some JavaDoc on this method to explain the the intention of the method and any optimalizations.", "author": "t2gran", "createdAt": "2020-09-22T10:29:40Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzMTQ1NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492631454", "bodyText": "Make this a local varable.", "author": "t2gran", "createdAt": "2020-09-22T10:31:40Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzNjE3NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492636174", "bodyText": "Add the call of these methods to the beginning of the method.", "author": "t2gran", "createdAt": "2020-09-22T10:40:58Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+        .stream()\n+        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+\n+    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzNjUwNQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492636505", "bodyText": "Maybe rename to streetEgressByStop", "author": "t2gran", "createdAt": "2020-09-22T10:41:41Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzNzIxOA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492637218", "bodyText": "Rename getDirectItinerary to createDirectItinerary", "author": "t2gran", "createdAt": "2020-09-22T10:43:20Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+        .stream()\n+        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+\n+    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Collection<Itinerary> itineraries = new ArrayList<>();\n+\n+    for (FlexAccessTemplate template : this.flexAccessTemplates) {\n+      StopLocation transferStop = template.getTransferStop();\n+      if (egressStops.contains(transferStop)) {\n+        StopAtDistance egress = egressTransferByStop.get(transferStop);\n+        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzODE3Mw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492638173", "bodyText": "Not Base use template", "author": "t2gran", "createdAt": "2020-09-22T10:45:21Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+        .stream()\n+        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+\n+    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Collection<Itinerary> itineraries = new ArrayList<>();\n+\n+    for (FlexAccessTemplate template : this.flexAccessTemplates) {\n+      StopLocation transferStop = template.getTransferStop();\n+      if (egressStops.contains(transferStop)) {\n+        StopAtDistance egress = egressTransferByStop.get(transferStop);\n+        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        if (itinerary != null) {\n+          itineraries.add(itinerary);\n+        }\n+      }\n+    }\n+\n+    return itineraries;\n+  }\n+\n+  public Collection<FlexAccessEgress> getFlexAccesses() {\n+    calculateFlexAccessTemplates();\n+\n+    return this.flexAccessTemplates\n+        .stream()\n+        .flatMap(flexAccessEgressBase -> flexAccessEgressBase.getFlexAccessEgressStream(graph, stopIndex.indexByStop))", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzOTc2MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492639761", "bodyText": "create/generate not get, maybe?", "author": "t2gran", "createdAt": "2020-09-22T10:48:38Z", "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.opentripplanner.ext.flex.template;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.ext.flex.FlexTripEdge;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.SimpleTransfer;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+public abstract class FlexAccessEgressTemplate {\n+  protected final StopAtDistance accessEgress;\n+  protected final FlexTrip trip;\n+  public final int fromStopIndex;\n+  public final int toStopIndex;\n+  protected final StopLocation transferStop;\n+  protected final int differenceFromStartOfTime;\n+  public final ServiceDate serviceDate;\n+  protected final DistanceCalculator calculator;\n+\n+  FlexAccessEgressTemplate(\n+      StopAtDistance accessEgress,\n+      FlexTrip trip,\n+      int fromStopIndex,\n+      int toStopIndex,\n+      StopLocation transferStop,\n+      int differenceFromStartOfTime,\n+      ServiceDate serviceDate,\n+      DistanceCalculator calculator\n+  ) {\n+    this.accessEgress = accessEgress;\n+    this.trip = trip;\n+    this.fromStopIndex = fromStopIndex;\n+    this.toStopIndex = toStopIndex;\n+    this.transferStop = transferStop;\n+    this.differenceFromStartOfTime = differenceFromStartOfTime;\n+    this.serviceDate = serviceDate;\n+    this.calculator = calculator;\n+  }\n+\n+  public StopLocation getTransferStop() {\n+    return transferStop;\n+  }\n+\n+  public FlexTrip getFlexTrip() {\n+    return trip;\n+  }\n+\n+  abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);\n+\n+  abstract protected StopLocation getFinalStop(SimpleTransfer simpleTransfer);\n+\n+  abstract protected Collection<SimpleTransfer> getTransfersFromTransferStop(Graph graph);\n+\n+  abstract protected Vertex getFlexVertex(Edge edge);\n+\n+  abstract protected int[] getFlexTimes(FlexTripEdge flexEdge, State state);\n+\n+  abstract protected FlexTripEdge getFlexEdge(Vertex flexFromVertex, StopLocation transferStop);\n+\n+  abstract protected boolean isRouteable(Vertex flexVertex);\n+\n+  public Stream<FlexAccessEgress> getFlexAccessEgressStream(", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0MDg4Mg==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492640882", "bodyText": "}\n// Location Area/Line\nelse {", "author": "t2gran", "createdAt": "2020-09-22T10:50:53Z", "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.opentripplanner.ext.flex.template;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.ext.flex.FlexTripEdge;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.SimpleTransfer;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+public abstract class FlexAccessEgressTemplate {\n+  protected final StopAtDistance accessEgress;\n+  protected final FlexTrip trip;\n+  public final int fromStopIndex;\n+  public final int toStopIndex;\n+  protected final StopLocation transferStop;\n+  protected final int differenceFromStartOfTime;\n+  public final ServiceDate serviceDate;\n+  protected final DistanceCalculator calculator;\n+\n+  FlexAccessEgressTemplate(\n+      StopAtDistance accessEgress,\n+      FlexTrip trip,\n+      int fromStopIndex,\n+      int toStopIndex,\n+      StopLocation transferStop,\n+      int differenceFromStartOfTime,\n+      ServiceDate serviceDate,\n+      DistanceCalculator calculator\n+  ) {\n+    this.accessEgress = accessEgress;\n+    this.trip = trip;\n+    this.fromStopIndex = fromStopIndex;\n+    this.toStopIndex = toStopIndex;\n+    this.transferStop = transferStop;\n+    this.differenceFromStartOfTime = differenceFromStartOfTime;\n+    this.serviceDate = serviceDate;\n+    this.calculator = calculator;\n+  }\n+\n+  public StopLocation getTransferStop() {\n+    return transferStop;\n+  }\n+\n+  public FlexTrip getFlexTrip() {\n+    return trip;\n+  }\n+\n+  abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);\n+\n+  abstract protected StopLocation getFinalStop(SimpleTransfer simpleTransfer);\n+\n+  abstract protected Collection<SimpleTransfer> getTransfersFromTransferStop(Graph graph);\n+\n+  abstract protected Vertex getFlexVertex(Edge edge);\n+\n+  abstract protected int[] getFlexTimes(FlexTripEdge flexEdge, State state);\n+\n+  abstract protected FlexTripEdge getFlexEdge(Vertex flexFromVertex, StopLocation transferStop);\n+\n+  abstract protected boolean isRouteable(Vertex flexVertex);\n+\n+  public Stream<FlexAccessEgress> getFlexAccessEgressStream(\n+      Graph graph, Map<Stop, Integer> indexByStop\n+  ) {\n+    if (transferStop instanceof Stop) {\n+      TransitStopVertex flexVertex = graph.index.getStopVertexForStop().get(transferStop);\n+      if (isRouteable(flexVertex)) {\n+        return Stream.of(\n+            getFlexAccessEgress(new ArrayList<>(), flexVertex, indexByStop.get(transferStop))\n+        );\n+      }\n+      return Stream.empty();\n+    } else {", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0NzM3OA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492647378", "bodyText": "Could you use the constant here. The ultimate goal would be to have enums in the internal model.", "author": "t2gran", "createdAt": "2020-09-22T11:02:21Z", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -43,6 +55,70 @@ public ScheduledDeviatedTrip(Trip trip, List<StopTime> stopTimes) {\n     }\n   }\n \n+  @Override\n+  public Stream<FlexAccessTemplate> getFlexAccessTemplates(\n+      StopAtDistance access, int differenceFromStartOfTime, ServiceDate serviceDate, DistanceCalculator calculator\n+  ) {\n+    DistanceCalculator scheduledDistanceCalculator = new ScheduledDistanceCalculator(calculator, this);\n+\n+    int fromIndex = getFromIndex(access);\n+\n+    if (fromIndex == -1) return Stream.empty();\n+\n+    ArrayList<FlexAccessTemplate> res = new ArrayList<>();\n+\n+    for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n+      if (stopTimes[toIndex].dropOffType == 1) continue;", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY1MDk2Mw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492650963", "bodyText": "These are good candidates for UnitTests", "author": "t2gran", "createdAt": "2020-09-22T11:09:37Z", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -43,6 +55,70 @@ public ScheduledDeviatedTrip(Trip trip, List<StopTime> stopTimes) {\n     }\n   }\n \n+  @Override\n+  public Stream<FlexAccessTemplate> getFlexAccessTemplates(\n+      StopAtDistance access, int differenceFromStartOfTime, ServiceDate serviceDate, DistanceCalculator calculator\n+  ) {\n+    DistanceCalculator scheduledDistanceCalculator = new ScheduledDistanceCalculator(calculator, this);\n+\n+    int fromIndex = getFromIndex(access);\n+\n+    if (fromIndex == -1) return Stream.empty();\n+\n+    ArrayList<FlexAccessTemplate> res = new ArrayList<>();\n+\n+    for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n+      if (stopTimes[toIndex].dropOffType == 1) continue;\n+      for (StopLocation stop : expandStops(stopTimes[toIndex].stop)) {\n+        res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate, scheduledDistanceCalculator));\n+      }\n+    }\n+\n+    return res.stream();\n+  }\n+\n+  @Override\n+  public Stream<FlexEgressTemplate> getFlexEgressTemplates(\n+      StopAtDistance egress, int differenceFromStartOfTime, ServiceDate serviceDate, DistanceCalculator calculator\n+  ) {\n+    DistanceCalculator scheduledDistanceCalculator = new ScheduledDistanceCalculator(calculator, this);\n+\n+    int toIndex = getToIndex(egress);\n+\n+    if (toIndex == -1) return Stream.empty();\n+\n+    ArrayList<FlexEgressTemplate> res = new ArrayList<>();\n+\n+    for (int fromIndex = toIndex - 1; fromIndex >= 0; fromIndex--) {\n+      if (stopTimes[fromIndex].pickupType == 1) continue;\n+      for (StopLocation stop : expandStops(stopTimes[fromIndex].stop)) {\n+        res.add(new FlexEgressTemplate(egress, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate, scheduledDistanceCalculator));\n+      }\n+    }\n+\n+    return res.stream();\n+  }\n+\n+  @Override\n+  public int earliestDepartureTime(\n+      int departureTime, int fromStopIndex, int toStopIndex, int flexTime\n+  ) {\n+    int stopTime = MISSING_VALUE;\n+    for (int i = fromStopIndex; stopTime == MISSING_VALUE && i >= 0; i--) {\n+      stopTime = stopTimes[i].departureTime;\n+    }\n+    return stopTime != MISSING_VALUE && stopTime >= departureTime ? stopTime : -1;\n+  }\n+\n+  @Override\n+  public int latestArrivalTime(int arrivalTime, int fromStopIndex, int toStopIndex, int flexTime) {\n+    int stopTime = MISSING_VALUE;\n+    for (int i = toStopIndex; stopTime == MISSING_VALUE && i < stopTimes.length; i++) {\n+      stopTime = stopTimes[i].arrivalTime;\n+    }\n+    return stopTime != MISSING_VALUE && stopTime <= arrivalTime ? stopTime : -1;\n+  }\n+", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY1MTM4OQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492651389", "bodyText": "UnitTests", "author": "t2gran", "createdAt": "2020-09-22T11:10:26Z", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -51,7 +127,49 @@ public ScheduledDeviatedTrip(Trip trip, List<StopTime> stopTimes) {\n         .collect(Collectors.toSet());\n   }\n \n-  private static class ScheduledDeviatedStopTime {\n+  private Collection<StopLocation> expandStops(StopLocation stop) {\n+    return stop instanceof FlexLocationGroup\n+        ? ((FlexLocationGroup) stop).getLocations()\n+        : Collections.singleton(stop);\n+  }\n+\n+  private int getFromIndex(StopAtDistance accessEgress) {\n+    for (int i = 0; i < stopTimes.length; i++) {\n+      if (stopTimes[i].pickupType == 1) continue; // No pickup allowed here\n+      StopLocation stop = stopTimes[i].stop;\n+      if (stop instanceof FlexLocationGroup) {\n+        if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+      else {\n+        if (stop.equals(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private int getToIndex(StopAtDistance accessEgress) {\n+    for (int i = stopTimes.length - 1; i >= 0; i--) {\n+      if (stopTimes[i].dropOffType == 1) continue; // No drop off allowed here\n+      StopLocation stop = stopTimes[i].stop;\n+      if (stop instanceof FlexLocationGroup) {\n+        if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+      else {\n+        if (stop.equals(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY1NDM2OA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492654368", "bodyText": "Rename flexContinuousPickup", "author": "t2gran", "createdAt": "2020-09-22T11:16:59Z", "path": "src/main/java/org/opentripplanner/model/StopTime.java", "diffHunk": "@@ -46,9 +46,11 @@\n \n     private int maxDepartureTime = MISSING_VALUE;\n \n-    private int continuousPickup;\n+    // Disabled by default\n+    private int continuousPickup = MISSING_VALUE;\n \n-    private int continuousDropOff;\n+    // Disabled by default\n+    private int continuousDropOff = MISSING_VALUE;\n ", "originalCommit": "681acd20acf9c56073616856d09c49f43668be45", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1e268b26b76f66baf7347beed502c68a9353bb53", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/1e268b26b76f66baf7347beed502c68a9353bb53", "message": "Rename StopAtDistance NearbyStop\n\nAlso move mapping code to AccessEgressMapper", "committedDate": "2020-09-24T06:53:15Z", "type": "commit"}, {"oid": "4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "message": "improve DistanceCalculator\n\n- rename from and to indext to stop index\n- rename DistanceAndDuration to FlexPath\n- rename getDuration to calculateFlexPath\n- rename DistanceCalculator FlexPathCalculator\n- fix potential NPE in StreetDistanceCalculator", "committedDate": "2020-09-24T07:00:22Z", "type": "commit"}, {"oid": "42ddad1ba8d70825ee52f9cb7764ff1fc4fdcdb7", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/42ddad1ba8d70825ee52f9cb7764ff1fc4fdcdb7", "message": "Fix comment in SimpleStreetSplitter", "committedDate": "2020-09-24T07:05:54Z", "type": "commit"}, {"oid": "71f72ce0442a141c189e89fb9a9f616584db566e", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/71f72ce0442a141c189e89fb9a9f616584db566e", "message": "Decouple FlexAccessEgress from Raptor", "committedDate": "2020-09-24T07:43:07Z", "type": "commit"}, {"oid": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "message": "Update FlexRouter based on comments", "committedDate": "2020-09-24T08:22:11Z", "type": "commit"}, {"oid": "904839ba268e86576cc228199e187c632ea97b73", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/904839ba268e86576cc228199e187c632ea97b73", "message": "Use constant for pickup/dropoff types", "committedDate": "2020-09-24T08:24:55Z", "type": "commit"}, {"oid": "199fa2e32cd31bcd0dbf540aed2bccde274dc913", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/199fa2e32cd31bcd0dbf540aed2bccde274dc913", "message": "Prefix continuous stop flags with flex", "committedDate": "2020-09-24T08:26:15Z", "type": "commit"}, {"oid": "3476ac74e362cab2b3048643555f0a50d70369ab", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/3476ac74e362cab2b3048643555f0a50d70369ab", "message": "Move FlexTripEdge to separate package", "committedDate": "2020-09-24T08:28:02Z", "type": "commit"}, {"oid": "a14e8d2c6d1576842a43d23a4dce3f1acb3163cd", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a14e8d2c6d1576842a43d23a4dce3f1acb3163cd", "message": "Rename FlexServicesOnDate to FlexServiceDate and use it deeper", "committedDate": "2020-09-24T08:42:17Z", "type": "commit"}, {"oid": "dad87843e87453b99b29750c65a25b3a3f865d58", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/dad87843e87453b99b29750c65a25b3a3f865d58", "message": "Move private functions down", "committedDate": "2020-09-24T08:43:15Z", "type": "commit"}, {"oid": "a90d7ed6ba1607139510e269292605b9327acfd2", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a90d7ed6ba1607139510e269292605b9327acfd2", "message": "Do not pass in the whole request to FlexRouter", "committedDate": "2020-09-24T09:01:11Z", "type": "commit"}, {"oid": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/2d309285ec07c8e3cfde7affcfbd6470733458d6", "message": "Merge remote-tracking branch 'origin/dev-2.x' into flex-upstream-routing", "committedDate": "2020-09-24T09:02:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE3NjA5Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494176096", "bodyText": "Put this in org.opentripplanner.routing.algorithm.raptor.transit", "author": "hannesj", "createdAt": "2020-09-24T09:36:44Z", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/AccessEgressMapper.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package org.opentripplanner.routing.algorithm.raptor.transit.mappers;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.routing.algorithm.raptor.transit.AccessEgress;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.graphfinder.NearbyStop;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class AccessEgressMapper {\n+\n+  private final StopIndexForRaptor stopIndex;\n+\n+  public AccessEgressMapper(StopIndexForRaptor stopIndex) {\n+    this.stopIndex = stopIndex;\n+  }\n+\n+  public AccessEgress mapNearbyStop(NearbyStop nearbyStop, boolean isEgress) {\n+    if (!(nearbyStop.stop instanceof Stop)) { return null; }\n+    return new AccessEgress(\n+        stopIndex.indexByStop.get(nearbyStop.stop),\n+        (int) nearbyStop.state.getElapsedTimeSeconds(),\n+        isEgress ? nearbyStop.state.reverse() : nearbyStop.state\n+    );\n+  }\n+\n+  public List<AccessEgress> mapNearbyStops(Collection<NearbyStop> accessStops, boolean isEgress) {\n+    return accessStops\n+        .stream()\n+        .map(stopAtDistance -> mapNearbyStop(stopAtDistance, isEgress))\n+        .filter(Objects::nonNull)\n+        .collect(Collectors.toList());\n+  }\n+\n+  public Collection<AccessEgress> mapFlexAccessEgresses(\n+      Collection<FlexAccessEgress> flexAccessEgresses\n+  ) {\n+    return flexAccessEgresses.stream().map(FlexAccessEgressAdapter::new).collect(Collectors.toList());\n+  }\n+\n+  private class FlexAccessEgressAdapter extends AccessEgress {", "originalCommit": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE4MjU1MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494182551", "bodyText": "Paralellize? Collect vertices and add afterwards", "author": "hannesj", "createdAt": "2020-09-24T09:47:08Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java", "diffHunk": "@@ -25,6 +30,9 @@ public void buildGraph(\n \n     StreetVertexIndex streetIndex = new StreetVertexIndex(graph);\n \n+    ProgressTracker progress = ProgressTracker.track(\"Add flex locations to street vertices\", 1, graph.locationsById.size());\n+\n+    LOG.info(progress.startMessage());", "originalCommit": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE4NzQzMg==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494187432", "bodyText": "Move this up", "author": "hannesj", "createdAt": "2020-09-24T09:55:11Z", "path": "src/ext/java/org/opentripplanner/ext/flex/edgetype/FlexTripEdge.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.opentripplanner.ext.flex.edgetype;\n+\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.LineString;\n+import org.opentripplanner.common.geometry.GeometryUtils;\n+import org.opentripplanner.ext.flex.flexpathcalculator.FlexPath;\n+import org.opentripplanner.ext.flex.flexpathcalculator.FlexPathCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Trip;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.core.StateEditor;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Locale;\n+\n+public class FlexTripEdge extends Edge {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(FlexTripEdge.class);\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  public StopLocation s1;\n+  public StopLocation s2;\n+  private FlexTrip trip;\n+  public FlexAccessEgressTemplate flexTemplate;\n+  public FlexPath flexPath;\n+\n+  public FlexTripEdge(\n+      Vertex v1, Vertex v2, StopLocation s1, StopLocation s2, FlexTrip trip,\n+      FlexAccessEgressTemplate flexTemplate, FlexPathCalculator calculator\n+  ) {\n+    super(new Vertex(null, null, 0.0, 0.0) {}, new Vertex(null, null, 0.0, 0.0) {});\n+    this.s1 = s1;\n+    this.s2 = s2;\n+    this.trip = trip;\n+    this.flexTemplate = flexTemplate;\n+    this.fromv = v1;\n+    this.tov = v2;\n+    // Why is this code so dirty? Because we don't want this edge to be added to the edge lists.", "originalCommit": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5ODAzOQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494198039", "bodyText": "Add javadoc for the fields", "author": "hannesj", "createdAt": "2020-09-24T10:13:06Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexServiceDate.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.graph.Graph;\n+\n+public class FlexServiceDate {\n+  public final ServiceDate serviceDate;", "originalCommit": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwNjk0MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494206941", "bodyText": "Add Javadoc to all these methods, why are they different in access/egress", "author": "hannesj", "createdAt": "2020-09-24T10:28:42Z", "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.opentripplanner.ext.flex.template;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.ext.flex.FlexServiceDate;\n+import org.opentripplanner.ext.flex.edgetype.FlexTripEdge;\n+import org.opentripplanner.ext.flex.flexpathcalculator.FlexPathCalculator;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.SimpleTransfer;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.graphfinder.NearbyStop;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public abstract class FlexAccessEgressTemplate {\n+  protected final NearbyStop accessEgress;\n+  protected final FlexTrip trip;\n+  public final int fromStopIndex;\n+  public final int toStopIndex;\n+  protected final StopLocation transferStop;\n+  protected final int secondsFromStartOfTime;\n+  public final ServiceDate serviceDate;\n+  protected final FlexPathCalculator calculator;\n+\n+  FlexAccessEgressTemplate(\n+      NearbyStop accessEgress,\n+      FlexTrip trip,\n+      int fromStopIndex,\n+      int toStopIndex,\n+      StopLocation transferStop,\n+      FlexServiceDate date,\n+      FlexPathCalculator calculator\n+  ) {\n+    this.accessEgress = accessEgress;\n+    this.trip = trip;\n+    this.fromStopIndex = fromStopIndex;\n+    this.toStopIndex = toStopIndex;\n+    this.transferStop = transferStop;\n+    this.secondsFromStartOfTime = date.secondsFromStartOfTime;\n+    this.serviceDate = date.serviceDate;\n+    this.calculator = calculator;\n+  }\n+\n+  public StopLocation getTransferStop() {\n+    return transferStop;\n+  }\n+\n+  public FlexTrip getFlexTrip() {\n+    return trip;\n+  }\n+\n+  abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);", "originalCommit": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIxNTE2Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494215166", "bodyText": "Change these to flexWindowStart and flexWindowEnd", "author": "hannesj", "createdAt": "2020-09-24T10:44:22Z", "path": "src/main/java/org/opentripplanner/model/StopTime.java", "diffHunk": "@@ -46,9 +46,11 @@\n \n     private int maxDepartureTime = MISSING_VALUE;", "originalCommit": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "69b08774efc0cdb575e7cc72163ef1a56fe00167", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/69b08774efc0cdb575e7cc72163ef1a56fe00167", "message": "Adapt changes from discussion", "committedDate": "2020-09-25T08:10:38Z", "type": "commit"}, {"oid": "558e06d0941eb87cc56301cd5b8bb093690638ae", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/558e06d0941eb87cc56301cd5b8bb093690638ae", "message": "Add initial docs", "committedDate": "2020-09-25T08:42:34Z", "type": "commit"}, {"oid": "4fe831096cf1f973a18ef69ed88f442a893c74fc", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/4fe831096cf1f973a18ef69ed88f442a893c74fc", "message": "Add javadoc", "committedDate": "2020-09-25T08:50:53Z", "type": "commit"}, {"oid": "76163e1ed4c3ded3d32027798a8e7bdbd45d6b0a", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/76163e1ed4c3ded3d32027798a8e7bdbd45d6b0a", "message": "Add Entur as additional contact", "committedDate": "2020-09-25T09:05:03Z", "type": "commit"}, {"oid": "aad1781643f2cec742877ae1f84f9852018680e7", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/aad1781643f2cec742877ae1f84f9852018680e7", "message": "Fix legal name", "committedDate": "2020-09-25T09:12:36Z", "type": "commit"}, {"oid": "e9b59cc461641341397d35b60e4f061eb9382452", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/e9b59cc461641341397d35b60e4f061eb9382452", "message": "Merge remote-tracking branch 'origin/dev-2.x' into flex-upstream-routing", "committedDate": "2020-09-25T09:12:52Z", "type": "commit"}]}