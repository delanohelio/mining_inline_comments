{"pr_number": 2926, "pr_title": "Otp2 limit transit service period", "pr_createdAt": "2020-01-14T20:57:40Z", "pr_url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926", "timeline": [{"oid": "c7ca5473924cda51e9822975023462a602f45268", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/c7ca5473924cda51e9822975023462a602f45268", "message": "Move otp calendar classes into the calendar package. The package existed, but not all date/calendar classes was in the package.", "committedDate": "2020-01-13T15:10:16Z", "type": "commit"}, {"oid": "270577cb83cdd613610572d7c3891e04f19cb603", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/270577cb83cdd613610572d7c3891e04f19cb603", "message": "Limit the transit service period(#2925).", "committedDate": "2020-01-15T09:34:02Z", "type": "commit"}, {"oid": "270577cb83cdd613610572d7c3891e04f19cb603", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/270577cb83cdd613610572d7c3891e04f19cb603", "message": "Limit the transit service period(#2925).", "committedDate": "2020-01-15T09:34:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4NzU0NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r366787544", "bodyText": "Info", "author": "t2gran", "createdAt": "2020-01-15T10:02:13Z", "path": "src/main/java/org/opentripplanner/model/impl/OtpTransitServiceBuilder.java", "diffHunk": "@@ -212,4 +218,101 @@ public void regenerateIndexes() {\n         this.routesById.reindex();\n         this.stopTimesByTrip.reindex();\n     }\n+\n+    /**\n+     * Limit the transit service to a time period removing calendar dates and services\n+     * outside the period. If a service is start before and/or ends after the period\n+     * then the service is modified to match the period.\n+     */\n+    public void limitServiceDays(ServiceDateInterval periodLimit) {\n+        if(periodLimit.isUnbounded()) {\n+            LOG.warn(\"Limiting transit service is skipped, the period is unbounded.\");", "originalCommit": "270577cb83cdd613610572d7c3891e04f19cb603", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4OTE2MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r366789161", "bodyText": "Check the service codes.", "author": "t2gran", "createdAt": "2020-01-15T10:05:09Z", "path": "src/main/java/org/opentripplanner/model/impl/OtpTransitServiceBuilder.java", "diffHunk": "@@ -212,4 +218,101 @@ public void regenerateIndexes() {\n         this.routesById.reindex();\n         this.stopTimesByTrip.reindex();\n     }\n+\n+    /**\n+     * Limit the transit service to a time period removing calendar dates and services\n+     * outside the period. If a service is start before and/or ends after the period\n+     * then the service is modified to match the period.\n+     */\n+    public void limitServiceDays(ServiceDateInterval periodLimit) {\n+        if(periodLimit.isUnbounded()) {\n+            LOG.warn(\"Limiting transit service is skipped, the period is unbounded.\");\n+            return;\n+        }\n+\n+        LOG.warn(\"Limiting transit service days to time period: {}\", periodLimit);\n+\n+        int orgSize = calendarDates.size();\n+        calendarDates.removeIf(c -> !periodLimit.include(c.getDate()));\n+        logRemove(\"ServiceCalendarDate\", orgSize, calendarDates.size(), \"Outside time period.\");\n+\n+        List<ServiceCalendar> keepCal = new ArrayList<>();\n+        for (ServiceCalendar calendar : calendars) {\n+            if(calendar.getPeriod().overlap(periodLimit)) {\n+                calendar.setPeriod(calendar.getPeriod().union(periodLimit));\n+                keepCal.add(calendar);\n+            }\n+        }\n+\n+        orgSize = calendars.size();\n+        if(orgSize != keepCal.size()) {\n+            calendars.clear();\n+            calendars.addAll(keepCal);\n+            logRemove(\"ServiceCalendar\", orgSize, calendars.size(), \"Outside time period.\");\n+        }\n+        removeEntitiesWithInvalidReferences();\n+        LOG.info(\"Limiting transit service days to time period complete.\");\n+    }\n+\n+    /**\n+     * Check all relations and remove entities witch reference none existing entries. This\n+     * may happen as a result of inconsistent data or by deliberate removal of elements in the\n+     * builder.\n+     */\n+    private void removeEntitiesWithInvalidReferences() {\n+        removeTripsWithNoneExistingServiceIds();\n+        removeStopTimesForNoneExistingTrips();\n+        fixOrRemovePatternsWhichReferenceNoneExistingTrips();\n+        removeTransfersForNoneExistingTrips();\n+    }\n+\n+    /** Remove all trips witch reference none existing service ids */\n+    private void removeTripsWithNoneExistingServiceIds() {\n+        Set<FeedScopedId> serviceIds = findAllServiceIds();\n+        int orgSize = tripsById.size();\n+        tripsById.removeIf(t -> !serviceIds.contains(t.getServiceId()));\n+        logRemove(\"Trip\", orgSize, tripsById.size(), \"Trip service id does not exist.\");\n+    }\n+\n+    /** Remove all stopTimes witch reference none existing trips */\n+    private void removeStopTimesForNoneExistingTrips() {\n+        int orgSize = stopTimesByTrip.size();\n+        stopTimesByTrip.removeIf(t -> !tripsById.containsKey(t.getId()));\n+        logRemove(\"StopTime\", orgSize, stopTimesByTrip.size(), \"StopTime trip does not exist.\");\n+    }\n+\n+    /** Remove none existing trips from patterns and then remove empty patterns */\n+    private void fixOrRemovePatternsWhichReferenceNoneExistingTrips() {\n+        int orgSize = tripPatterns.size();", "originalCommit": "270577cb83cdd613610572d7c3891e04f19cb603", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg3MzQxOQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r366873419", "bodyText": "The should be intersection not union.", "author": "t2gran", "createdAt": "2020-01-15T13:26:58Z", "path": "src/main/java/org/opentripplanner/model/calendar/ServiceDateInterval.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.opentripplanner.model.calendar;\n+\n+import java.util.Objects;\n+\n+\n+/**\n+ * Value object witch represent an service date interval from a starting date\n+ * until an end date. Both start and end is inclusive.\n+ *\n+ * The {@code start} must be equals or before the {@code end} to form a valid\n+ * period.\n+ *\n+ * {@code null} is used to represent an unbounded interval. One or both the of the {@code start} and\n+ * {@code end} can be {@code null} (unbounded).\n+ */\n+public final class ServiceDateInterval {\n+\n+    /**\n+     * The unbounded values will represent an unbounded value internally in this class.\n+     * They are converted to {@code null} when exported outside the class. This little\n+     * trick make internal logic a bit simpler, since there is no need for {@code null} checks.\n+     */\n+    private static final ServiceDate UNBOUNDED_START = new ServiceDate(0, 1, 1);\n+    private static final ServiceDate UNBOUNDED_END = new ServiceDate(9999, 12, 31);\n+    private static final ServiceDateInterval UNBOUNDED = new ServiceDateInterval(null, null);\n+\n+    private final ServiceDate start;\n+    private final ServiceDate end;\n+\n+\n+    public ServiceDateInterval(ServiceDate start, ServiceDate end) {\n+        this.start = start == null ? UNBOUNDED_START : start;\n+        this.end = end == null ? UNBOUNDED_END : end;\n+\n+        // Guarantee that the start is before or equal the end.\n+        if(this.end.isBefore(this.start)) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid interval, the end \" + end + \" is before the start \" +  start\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Return a interval with start or end unbounded ({@code null}).\n+     */\n+    public static ServiceDateInterval unbounded() {\n+        return UNBOUNDED;\n+    }\n+\n+    public boolean isUnbounded() {\n+        return start.equals(UNBOUNDED_START) && end.equals(UNBOUNDED_END);\n+    }\n+\n+    public ServiceDate getStart() {\n+        return start == UNBOUNDED_START ? null : start;\n+    }\n+\n+    public ServiceDate getEnd() {\n+        return end == UNBOUNDED_END ? null : end;\n+    }\n+\n+    /**\n+     * The intervals have at least one day in common.\n+     * @see #union(ServiceDateInterval)\n+     */\n+    public boolean overlap(ServiceDateInterval other) {\n+        if(start.isBeforeOrEq(other.end)) {\n+            return end.isAfterOrEq(other.start);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Return a new service interval that contains the period witch is common for both periods\n+     * (common set of service days).\n+     *\n+     * @see #overlap(ServiceDateInterval) for checking an union exist.\n+     *\n+     * @throws IllegalArgumentException it the to periods do not overlap.\n+     */\n+    public ServiceDateInterval union(ServiceDateInterval other) {", "originalCommit": "270577cb83cdd613610572d7c3891e04f19cb603", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "882195c77a222161d5de84bd7ed58cc562f93159", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/882195c77a222161d5de84bd7ed58cc562f93159", "message": "Limit the transit service period(#2925) - code review:\n - Renamed `union` method to `intersection` and updated comments\n - Changed log level from warn to info in `OtpTransitServiceBuilder.limitServiceDays(..)`", "committedDate": "2020-01-15T13:33:59Z", "type": "commit"}, {"oid": "146ab5c043b722069b47a7c99798424542609a30", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/146ab5c043b722069b47a7c99798424542609a30", "message": "Merge branch 'dev-2.x' into otp2_limit_transit_service_period", "committedDate": "2020-01-17T15:32:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MTU3MA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369471570", "bodyText": "This method is modifying instances in place. It might be more consistent with our planned approach to immutability to copy any TripPattern that is changed by the filtering. Then again, we can also say that during building instances are mutable, in which case this could be fine.", "author": "abyrd", "createdAt": "2020-01-22T10:12:08Z", "path": "src/main/java/org/opentripplanner/model/TripPattern.java", "diffHunk": "@@ -294,6 +295,20 @@ public void add(FrequencyEntry freq) {\n         }\n     }\n \n+    /**\n+     * Remove all trips matching the given predicate.\n+     * @param removeTrip it the predicate returns true\n+     */\n+    public void removeTrips(Predicate<Trip> removeTrip) {", "originalCommit": "270577cb83cdd613610572d7c3891e04f19cb603", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMDIzMQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369620231", "bodyText": "I agree. I looked at changing it. I think it is a little too much work to do it now - I do not think it is worth it to just change this method. I did (in this PR) make the ServiceDate and ServiceDateInterval immutable, witch is a step toward the goal. I hope to go over the the transit model in the near future to clean it up. I think we should start with the leaf nodes and work towards the top. E.g. the TripPattern would be easier to fix when Trip is immutable.", "author": "t2gran", "createdAt": "2020-01-22T15:16:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MTU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MzUxOQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369473519", "bodyText": "This class seems like derived data, if the trips were filtered out early enough maybe they would never even be put into this map. We looked at where this TripStopTimes is used, and it seems to only be in org.opentripplanner.graph_builder.module.geometry.GeometryAndBlockProcessor#createGeometry, where it serves as an index for making trip geometries. The index could be constructed within the scope of that method, after trips have already been filtered, which would allow eliminating this filtering method.", "author": "abyrd", "createdAt": "2020-01-22T10:16:03Z", "path": "src/main/java/org/opentripplanner/model/TripStopTimes.java", "diffHunk": "@@ -50,14 +51,21 @@ public void put(Trip key, Collection<StopTime> list) {\n         map.put(key, sort(list));\n     }\n \n+    public void removeIf(Predicate<Trip> test) {", "originalCommit": "270577cb83cdd613610572d7c3891e04f19cb603", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzNzA1NQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369637055", "bodyText": "We (@abyrd, @gmellemstrand  and I) discussed this, and I too though this was derived data, but it is not - this is the trip to StopTime relation. There is not stopTimes on Trip. This is clearly something that could be improved, but it should be an issue/PR on its own.\nThe graph builder goes through the intermediate step keeping StopTimes in a map, then this is converted into a more efficient data structure later. The conversion is done in the GenerateTripPatternsOperation#buildTripPatternForTrip(Trip) witch access this data using the service builder.", "author": "t2gran", "createdAt": "2020-01-22T15:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MzUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY2MjUxNA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369662514", "bodyText": "The TripStopTimes should be removed from the OtpTransitService. That can be done by making the GeometryAndBlockProcessor operate on the builder or collections from the builder, and moving the GeometryAndBlockProcessor execution up before the builder is done. This require a bit of refactoring an I will add some TODOs in the code - it require to many changes to be part of this PR.", "author": "t2gran", "createdAt": "2020-01-22T16:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MzUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MjU5MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369482591", "bodyText": "Overall approach is good, another possibility that could work is just 20200113 for 2020-01-13. This is just easier to debug if we ever need to observe the code in operation.", "author": "abyrd", "createdAt": "2020-01-22T10:34:06Z", "path": "src/main/java/org/opentripplanner/model/calendar/ServiceDate.java", "diffHunk": "@@ -39,25 +39,46 @@\n     private final int day;\n \n     /**\n-     * Construct a new ServiceDate by specifying the numeric year, month, and day\n+     * A uniq increasing number for any valid day between 0000-01-01 and 9999-12-31.\n+     * Holes in the sequence is allowed to simplify the calculation.\n+     *\n+     * The value can safely be used for comparison, equals and hashCode.\n+     */\n+    private final int sequenceNumber;", "originalCommit": "146ab5c043b722069b47a7c99798424542609a30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4NDY2Mw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369484663", "bodyText": "It might even  be more readable to export the symbolic constants outside the class, instead of null. Either way is fine. It might be clearer for debugging and logging.", "author": "abyrd", "createdAt": "2020-01-22T10:38:27Z", "path": "src/main/java/org/opentripplanner/model/calendar/ServiceDateInterval.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.opentripplanner.model.calendar;\n+\n+import java.util.Objects;\n+\n+\n+/**\n+ * Value object witch represent an service date interval from a starting date\n+ * until an end date. Both start and end is inclusive.\n+ *\n+ * The {@code start} must be equals or before the {@code end} to form a valid\n+ * period.\n+ *\n+ * {@code null} is used to represent an unbounded interval. One or both the of the {@code start} and\n+ * {@code end} can be {@code null} (unbounded).\n+ */\n+public final class ServiceDateInterval {\n+\n+    /**\n+     * The unbounded values will represent an unbounded value internally in this class.\n+     * They are converted to {@code null} when exported outside the class. This little\n+     * trick make internal logic a bit simpler, since there is no need for {@code null} checks.\n+     */\n+    private static final ServiceDate UNBOUNDED_START = new ServiceDate(0, 1, 1);\n+    private static final ServiceDate UNBOUNDED_END = new ServiceDate(9999, 12, 31);\n+    private static final ServiceDateInterval UNBOUNDED = new ServiceDateInterval(null, null);\n+\n+    private final ServiceDate start;\n+    private final ServiceDate end;\n+\n+\n+    public ServiceDateInterval(ServiceDate start, ServiceDate end) {\n+        this.start = start == null ? UNBOUNDED_START : start;\n+        this.end = end == null ? UNBOUNDED_END : end;\n+\n+        // Guarantee that the start is before or equal the end.\n+        if(this.end.isBefore(this.start)) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid interval, the end \" + end + \" is before the start \" +  start\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Return a interval with start or end unbounded ({@code null}).\n+     */\n+    public static ServiceDateInterval unbounded() {\n+        return UNBOUNDED;\n+    }\n+\n+    public boolean isUnbounded() {\n+        return start.equals(UNBOUNDED_START) && end.equals(UNBOUNDED_END);\n+    }\n+\n+    public ServiceDate getStart() {\n+        return start == UNBOUNDED_START ? null : start;\n+    }\n+\n+    public ServiceDate getEnd() {\n+        return end == UNBOUNDED_END ? null : end;", "originalCommit": "146ab5c043b722069b47a7c99798424542609a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzOTY2Nw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369639667", "bodyText": "I made moved the constants to the ServiceDate class and made them public. Also made them exposed to the outsid, by not converting to null. The new names for these are MIN_DATE and MAX_DATE since the UNBOUNDED only make sence in the context of interval.", "author": "t2gran", "createdAt": "2020-01-22T15:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4NDY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4NTg1NQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369485855", "bodyText": "If these special values were defined in ServiceDate, and its toString knew about them, then ServiceDateInterval's toString could just recursively call ServiceDate's.", "author": "abyrd", "createdAt": "2020-01-22T10:41:00Z", "path": "src/main/java/org/opentripplanner/model/calendar/ServiceDateInterval.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.opentripplanner.model.calendar;\n+\n+import java.util.Objects;\n+\n+\n+/**\n+ * Value object witch represent an service date interval from a starting date\n+ * until an end date. Both start and end is inclusive.\n+ *\n+ * The {@code start} must be equals or before the {@code end} to form a valid\n+ * period.\n+ *\n+ * {@code null} is used to represent an unbounded interval. One or both the of the {@code start} and\n+ * {@code end} can be {@code null} (unbounded).\n+ */\n+public final class ServiceDateInterval {\n+\n+    /**\n+     * The unbounded values will represent an unbounded value internally in this class.\n+     * They are converted to {@code null} when exported outside the class. This little\n+     * trick make internal logic a bit simpler, since there is no need for {@code null} checks.\n+     */\n+    private static final ServiceDate UNBOUNDED_START = new ServiceDate(0, 1, 1);", "originalCommit": "146ab5c043b722069b47a7c99798424542609a30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "747b4b63e8a3743280a6a1ba9126071c674f728b", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/747b4b63e8a3743280a6a1ba9126071c674f728b", "message": "Limit the transit service period(#2925) - code review:\n - Some JavaDoc updates.\n - ServiceDate set to sequenceNumber = yyyymmdd (as int) - used for comparison.\n - ServiceDate constants for upper and lover bound added, and used by the ServiceDateInterval.\n - ServiceDateInterval unbounded start/end represented with MIN and MAX, not null.\n - Add TODOs to GeometryAndBlockProcessor and NetexModule.", "committedDate": "2020-01-22T16:50:07Z", "type": "commit"}]}