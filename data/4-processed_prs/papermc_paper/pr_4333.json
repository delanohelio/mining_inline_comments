{"pr_number": 4333, "pr_title": "Add StructureLocateEvent", "pr_createdAt": "2020-09-16T09:24:26Z", "pr_url": "https://github.com/PaperMC/Paper/pull/4333", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMwMjIwMw==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r489302203", "bodyText": "Do not add imports, use fully qualified names instead.", "author": "mikroskeem", "createdAt": "2020-09-16T09:36:26Z", "path": "Spigot-Server-Patches/0580-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,82 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Wed, 16 Sep 2020 01:12:29 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/net/minecraft/server/ChunkGenerator.java b/src/main/java/net/minecraft/server/ChunkGenerator.java\n+index 9a6fef215052f9c513b23024968995c97863a453..498a393cdc46cbab0f37a2396a7bba9fbdc6c3e7 100644\n+--- a/src/main/java/net/minecraft/server/ChunkGenerator.java\n++++ b/src/main/java/net/minecraft/server/ChunkGenerator.java\n+@@ -2,6 +2,13 @@ package net.minecraft.server;\n+ \n+ import com.google.common.collect.Lists;\n+ import com.mojang.serialization.Codec;\n++// Paper start", "originalCommit": "2a4c11ae9e4e36765bd7ab1f087c1b9d46ee690e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMwMjM0Nw==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r489302347", "bodyText": "Use Event#callEvent() instead.\nif (!event.callEvent()) {\n    return null;\n}", "author": "mikroskeem", "createdAt": "2020-09-16T09:36:40Z", "path": "Spigot-Server-Patches/0580-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,82 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Wed, 16 Sep 2020 01:12:29 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/net/minecraft/server/ChunkGenerator.java b/src/main/java/net/minecraft/server/ChunkGenerator.java\n+index 9a6fef215052f9c513b23024968995c97863a453..498a393cdc46cbab0f37a2396a7bba9fbdc6c3e7 100644\n+--- a/src/main/java/net/minecraft/server/ChunkGenerator.java\n++++ b/src/main/java/net/minecraft/server/ChunkGenerator.java\n+@@ -2,6 +2,13 @@ package net.minecraft.server;\n+ \n+ import com.google.common.collect.Lists;\n+ import com.mojang.serialization.Codec;\n++// Paper start\n++import org.bukkit.Bukkit;\n++import org.bukkit.Location;\n++import org.bukkit.StructureType;\n++import org.bukkit.event.world.StructureLocateEvent;\n++// Paper end\n++\n+ import java.util.BitSet;\n+ import java.util.Iterator;\n+ import java.util.List;\n+@@ -124,9 +131,34 @@ public abstract class ChunkGenerator {\n+ \n+     @Nullable\n+     public BlockPosition findNearestMapFeature(WorldServer worldserver, StructureGenerator<?> structuregenerator, BlockPosition blockposition, int i, boolean flag) {\n+-        if (!this.b.a(structuregenerator)) {\n++        // Paper start\n++        org.bukkit.World world = worldserver.getWorld();\n++        Location originLocation = new Location(world, blockposition.getX(), blockposition.getY(), blockposition.getZ());\n++\n++        StructureLocateEvent event = new StructureLocateEvent(world, originLocation, StructureType.getStructureTypes().get(structuregenerator.i()), i, flag);\n++        Bukkit.getPluginManager().callEvent(event);", "originalCommit": "2a4c11ae9e4e36765bd7ab1f087c1b9d46ee690e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMwMjk4MQ==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r489302981", "bodyText": "Whitespace", "author": "mikroskeem", "createdAt": "2020-09-16T09:37:43Z", "path": "Spigot-Server-Patches/0580-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,82 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Wed, 16 Sep 2020 01:12:29 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/net/minecraft/server/ChunkGenerator.java b/src/main/java/net/minecraft/server/ChunkGenerator.java\n+index 9a6fef215052f9c513b23024968995c97863a453..498a393cdc46cbab0f37a2396a7bba9fbdc6c3e7 100644\n+--- a/src/main/java/net/minecraft/server/ChunkGenerator.java\n++++ b/src/main/java/net/minecraft/server/ChunkGenerator.java\n+@@ -2,6 +2,13 @@ package net.minecraft.server;\n+ \n+ import com.google.common.collect.Lists;\n+ import com.mojang.serialization.Codec;\n++// Paper start\n++import org.bukkit.Bukkit;\n++import org.bukkit.Location;\n++import org.bukkit.StructureType;\n++import org.bukkit.event.world.StructureLocateEvent;\n++// Paper end\n++\n+ import java.util.BitSet;\n+ import java.util.Iterator;\n+ import java.util.List;\n+@@ -124,9 +131,34 @@ public abstract class ChunkGenerator {\n+ \n+     @Nullable\n+     public BlockPosition findNearestMapFeature(WorldServer worldserver, StructureGenerator<?> structuregenerator, BlockPosition blockposition, int i, boolean flag) {\n+-        if (!this.b.a(structuregenerator)) {\n++        // Paper start\n++        org.bukkit.World world = worldserver.getWorld();\n++        Location originLocation = new Location(world, blockposition.getX(), blockposition.getY(), blockposition.getZ());\n++\n++        StructureLocateEvent event = new StructureLocateEvent(world, originLocation, StructureType.getStructureTypes().get(structuregenerator.i()), i, flag);\n++        Bukkit.getPluginManager().callEvent(event);\n++\n++        if(event.isCancelled()) return null;\n++\n++        // If event call set a final location, skip structure finding and just return set result.\n++        Location finalLocation = event.getResult();\n++        if(finalLocation != null) {\n++            return new BlockPosition(finalLocation.getBlockX(), finalLocation.getBlockY(), finalLocation.getBlockZ());\n++        }\n++\n++        // Get origin location (re)defined by event call.\n++        Location newOriginLocation = event.getOrigin();\n++        BlockPosition newOriginPosition = new BlockPosition(newOriginLocation.getBlockX(), newOriginLocation.getBlockY(), newOriginLocation.getBlockZ());\n++\n++        // Get radius and whether to find unexplored structures (re)defined by event call.\n++        int radius = event.getRadius();\n++        boolean findUnexplored = event.shouldFindUnexplored();\n++        StructureGenerator<?> newGenerator = StructureGenerator.a.get(event.getType().getName());\n++        // Paper end\n++\n++        if(! this.b.a(newGenerator)) { // Paper", "originalCommit": "2a4c11ae9e4e36765bd7ab1f087c1b9d46ee690e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM3MDg1OQ==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r504370859", "bodyText": "whitespace issue still exists, but there is no reason why all of these fields need to be modified? just re-assign the existing field, less diff and less likely something will get missed in the future", "author": "electronicboy", "createdAt": "2020-10-14T02:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTMwMjk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM3MDk3NA==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r504370974", "bodyText": "same here, does this really need to be modified?", "author": "electronicboy", "createdAt": "2020-10-14T02:59:02Z", "path": "Spigot-Server-Patches/0580-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,61 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Wed, 16 Sep 2020 01:12:29 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/net/minecraft/server/ChunkGenerator.java b/src/main/java/net/minecraft/server/ChunkGenerator.java\n+index 9a6fef215052f9c513b23024968995c97863a453..16a477f2a99a5c8d68f0d1468d4cd79650a5a05d 100644\n+--- a/src/main/java/net/minecraft/server/ChunkGenerator.java\n++++ b/src/main/java/net/minecraft/server/ChunkGenerator.java\n+@@ -124,9 +124,27 @@ public abstract class ChunkGenerator {\n+ \n+     @Nullable\n+     public BlockPosition findNearestMapFeature(WorldServer worldserver, StructureGenerator<?> structuregenerator, BlockPosition blockposition, int i, boolean flag) {\n+-        if (!this.b.a(structuregenerator)) {\n++        // Paper start\n++        org.bukkit.World world = worldserver.getWorld();\n++        org.bukkit.Location originLocation = new org.bukkit.Location(world, blockposition.getX(), blockposition.getY(), blockposition.getZ());\n++        org.bukkit.event.world.StructureLocateEvent event = new org.bukkit.event.world.StructureLocateEvent(world, originLocation, org.bukkit.StructureType.getStructureTypes().get(structuregenerator.i()), i, flag);\n++        if(!event.callEvent()) return null;\n++        // If event call set a final location, skip structure finding and just return set result.\n++        org.bukkit.Location finalLocation = event.getResult();\n++        if(finalLocation != null) {\n++            return new BlockPosition(finalLocation.getBlockX(), finalLocation.getBlockY(), finalLocation.getBlockZ());\n++        }\n++        // Get origin location (re)defined by event call.\n++        org.bukkit.Location newOriginLocation = event.getOrigin();\n++        BlockPosition newOriginPosition = new BlockPosition(newOriginLocation.getBlockX(), newOriginLocation.getBlockY(), newOriginLocation.getBlockZ());\n++        // Get radius and whether to find unexplored structures (re)defined by event call.\n++        int radius = event.getRadius();\n++        boolean findUnexplored = event.shouldFindUnexplored();\n++        StructureGenerator<?> newGenerator = StructureGenerator.a.get(event.getType().getName());\n++        // Paper end\n++        if(! this.b.a(newGenerator)) { // Paper\n+             return null;\n+-        } else if (structuregenerator == StructureGenerator.STRONGHOLD) {\n++        } else if (newGenerator == StructureGenerator.STRONGHOLD) { // Paper\n+             this.g();\n+             BlockPosition blockposition1 = null;\n+             double d0 = Double.MAX_VALUE;\n+@@ -137,7 +155,7 @@ public abstract class ChunkGenerator {\n+                 ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();\n+ \n+                 blockposition_mutableblockposition.d((chunkcoordintpair.x << 4) + 8, 32, (chunkcoordintpair.z << 4) + 8);\n+-                double d1 = blockposition_mutableblockposition.j(blockposition);", "originalCommit": "ea9a03402a0cd6bf4ed4d5457c6d6386aaba1668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQxNDk1MA==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r504414950", "bodyText": "Thank you for the feedback, this is my first ever PR so any additional feedback is appreciated!\nThese issues have been resolved in my latest commit :)", "author": "dfsek", "createdAt": "2020-10-14T05:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM3MDk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1MjM3Mw==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523452373", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            +package org.bukkit.event.world;\n          \n          \n            \n            +package io.papermc.paper.event.world;", "author": "Proximyst", "createdAt": "2020-11-14T19:11:49Z", "path": "Spigot-API-Patches/0227-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,149 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Tue, 15 Sep 2020 21:59:16 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/org/bukkit/event/world/StructureLocateEvent.java b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+new file mode 100644\n+index 0000000000000000000000000000000000000000..1011b03fcc7be912e617a6fde3f62e68d70f2c1c\n+--- /dev/null\n++++ b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+@@ -0,0 +1,137 @@\n++package org.bukkit.event.world;", "originalCommit": "836f20dea3e02b6deb10e258363a602cd5316684", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgzOTU3NA==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523839574", "bodyText": "Shouldn't this be com.destroystokyo.paper, or are you guys moving away from that package?", "author": "dfsek", "createdAt": "2020-11-16T00:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1MjM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg0NjUwNw==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523846507", "bodyText": "Moving away", "author": "A248", "createdAt": "2020-11-16T00:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1MjM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1MjQ1OA==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523452458", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            + * This happens when:<br>\n          \n          \n            \n            + *   - The /locate command is used.<br>\n          \n          \n            \n            + *   - An Eye of Ender is used.<br>\n          \n          \n            \n            + *   - An Explorer/Treasure Map is activated.<br>\n          \n          \n            \n            + *   - {@link World#locateNearestStructure(Location, StructureType, int, boolean)} is invoked.\n          \n          \n            \n            + * This happens when:\n          \n          \n            \n            + * <ul>\n          \n          \n            \n            + *   <li>The /locate command is used.</li>\n          \n          \n            \n            + *   <li>An Eye of Ender is used.</li>\n          \n          \n            \n            + *   <li>An Explorer/Treasure Map is activated.</li>\n          \n          \n            \n            + *   <li>{@link World#locateNearestStructure(Location, StructureType, int, boolean)} is invoked.</li>\n          \n          \n            \n            + * </ul>", "author": "Proximyst", "createdAt": "2020-11-14T19:12:39Z", "path": "Spigot-API-Patches/0227-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,149 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Tue, 15 Sep 2020 21:59:16 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/org/bukkit/event/world/StructureLocateEvent.java b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+new file mode 100644\n+index 0000000000000000000000000000000000000000..1011b03fcc7be912e617a6fde3f62e68d70f2c1c\n+--- /dev/null\n++++ b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+@@ -0,0 +1,137 @@\n++package org.bukkit.event.world;\n++\n++import org.bukkit.Location;\n++import org.bukkit.StructureType;\n++import org.bukkit.World;\n++import org.bukkit.event.Cancellable;\n++import org.bukkit.event.HandlerList;\n++import org.jetbrains.annotations.NotNull;\n++import org.jetbrains.annotations.Nullable;\n++\n++/**\n++ * Called <b>before</b> a structure/feature is located.\n++ * This happens when:<br>\n++ *   - The /locate command is used.<br>\n++ *   - An Eye of Ender is used.<br>\n++ *   - An Explorer/Treasure Map is activated.<br>\n++ *   - {@link World#locateNearestStructure(Location, StructureType, int, boolean)} is invoked.", "originalCommit": "836f20dea3e02b6deb10e258363a602cd5316684", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1MjQ2NQ==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523452465", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            +    private boolean cancelled = false;\n          \n          \n            \n            +    public StructureLocateEvent(@NotNull World world, @NotNull Location origin, @NotNull StructureType structureType, int radius, boolean findUnexplored) {\n          \n          \n            \n            +    private boolean cancelled = false;\n          \n          \n            \n            +\n          \n          \n            \n            +    public StructureLocateEvent(@NotNull World world, @NotNull Location origin, @NotNull StructureType structureType, int radius, boolean findUnexplored) {", "author": "Proximyst", "createdAt": "2020-11-14T19:12:48Z", "path": "Spigot-API-Patches/0227-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,149 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Tue, 15 Sep 2020 21:59:16 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/org/bukkit/event/world/StructureLocateEvent.java b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+new file mode 100644\n+index 0000000000000000000000000000000000000000..1011b03fcc7be912e617a6fde3f62e68d70f2c1c\n+--- /dev/null\n++++ b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+@@ -0,0 +1,137 @@\n++package org.bukkit.event.world;\n++\n++import org.bukkit.Location;\n++import org.bukkit.StructureType;\n++import org.bukkit.World;\n++import org.bukkit.event.Cancellable;\n++import org.bukkit.event.HandlerList;\n++import org.jetbrains.annotations.NotNull;\n++import org.jetbrains.annotations.Nullable;\n++\n++/**\n++ * Called <b>before</b> a structure/feature is located.\n++ * This happens when:<br>\n++ *   - The /locate command is used.<br>\n++ *   - An Eye of Ender is used.<br>\n++ *   - An Explorer/Treasure Map is activated.<br>\n++ *   - {@link World#locateNearestStructure(Location, StructureType, int, boolean)} is invoked.\n++ */\n++public class StructureLocateEvent extends WorldEvent implements Cancellable {\n++    private static final HandlerList handlers = new HandlerList();\n++    private final Location origin;\n++    private Location result = null;\n++    private StructureType type;\n++    private int radius;\n++    private boolean findUnexplored;\n++    private boolean cancelled = false;\n++    public StructureLocateEvent(@NotNull World world, @NotNull Location origin, @NotNull StructureType structureType, int radius, boolean findUnexplored) {", "originalCommit": "836f20dea3e02b6deb10e258363a602cd5316684", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1MjU1OQ==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523452559", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            +    /**\n          \n          \n            \n            +     * Gets the location set as the structure location, if it was defined.<br>\n          \n          \n            \n            +     * Returns null if it has not been set by {@link StructureLocateEvent#setResult(Location)}.<br>\n          \n          \n            \n            +     * Since this event fires <i>before</i> the search is done, the actual location is unknown at this point.<br>\n          \n          \n            \n            +     * If you wish to manipulate the location, use {@link World#locateNearestStructure(Location, StructureType, int, boolean)}\n          \n          \n            \n            +     * @return The result location, if it has been set. null if it has not.\n          \n          \n            \n            +     */\n          \n          \n            \n            +    /**\n          \n          \n            \n            +     * Gets the location set as the structure location, if it was defined.\n          \n          \n            \n            +     * <p>\n          \n          \n            \n            +     * Returns {@code null} if it has not been set by {@link StructureLocateEvent#setResult(Location)}.\n          \n          \n            \n            +     * Since this event fires <i>before</i> the search is done, the actual location is unknown at this point.\n          \n          \n            \n            +     * If you wish to manipulate the location, use {@link World#locateNearestStructure(Location, StructureType, int, boolean)}.\n          \n          \n            \n            +     *\n          \n          \n            \n            +     * @return The result location, if it has been set. {@code null} if it has not.\n          \n          \n            \n            +     */", "author": "Proximyst", "createdAt": "2020-11-14T19:14:01Z", "path": "Spigot-API-Patches/0227-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,149 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Tue, 15 Sep 2020 21:59:16 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/org/bukkit/event/world/StructureLocateEvent.java b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+new file mode 100644\n+index 0000000000000000000000000000000000000000..1011b03fcc7be912e617a6fde3f62e68d70f2c1c\n+--- /dev/null\n++++ b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+@@ -0,0 +1,137 @@\n++package org.bukkit.event.world;\n++\n++import org.bukkit.Location;\n++import org.bukkit.StructureType;\n++import org.bukkit.World;\n++import org.bukkit.event.Cancellable;\n++import org.bukkit.event.HandlerList;\n++import org.jetbrains.annotations.NotNull;\n++import org.jetbrains.annotations.Nullable;\n++\n++/**\n++ * Called <b>before</b> a structure/feature is located.\n++ * This happens when:<br>\n++ *   - The /locate command is used.<br>\n++ *   - An Eye of Ender is used.<br>\n++ *   - An Explorer/Treasure Map is activated.<br>\n++ *   - {@link World#locateNearestStructure(Location, StructureType, int, boolean)} is invoked.\n++ */\n++public class StructureLocateEvent extends WorldEvent implements Cancellable {\n++    private static final HandlerList handlers = new HandlerList();\n++    private final Location origin;\n++    private Location result = null;\n++    private StructureType type;\n++    private int radius;\n++    private boolean findUnexplored;\n++    private boolean cancelled = false;\n++    public StructureLocateEvent(@NotNull World world, @NotNull Location origin, @NotNull StructureType structureType, int radius, boolean findUnexplored) {\n++        super(world);\n++        this.origin = origin;\n++        this.type = structureType;\n++        this.radius = radius;\n++        this.findUnexplored = findUnexplored;\n++    }\n++\n++    @NotNull\n++    @Override\n++    public HandlerList getHandlers() {\n++        return handlers;\n++    }\n++\n++    @NotNull\n++    public static HandlerList getHandlerList() {\n++        return handlers;\n++    }\n++\n++    /**\n++     * Gets the location set as the structure location, if it was defined.<br>\n++     * Returns null if it has not been set by {@link StructureLocateEvent#setResult(Location)}.<br>\n++     * Since this event fires <i>before</i> the search is done, the actual location is unknown at this point.<br>\n++     * If you wish to manipulate the location, use {@link World#locateNearestStructure(Location, StructureType, int, boolean)}\n++     * @return The result location, if it has been set. null if it has not.\n++     */", "originalCommit": "836f20dea3e02b6deb10e258363a602cd5316684", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1MjY0Mw==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523452643", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            +     * Sets the result Location. This causes the search to be skipped, and the location passed here to be used as the result.\n          \n          \n            \n            +     * @param result the Location of the structure.\n          \n          \n            \n            +     * Sets the result {@link Location}. This causes the search to be skipped, and the location passed here to be used as the result.\n          \n          \n            \n            +     *\n          \n          \n            \n            +     * @param result the {@link Location} of the structure.", "author": "Proximyst", "createdAt": "2020-11-14T19:14:42Z", "path": "Spigot-API-Patches/0227-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,149 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Tue, 15 Sep 2020 21:59:16 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/org/bukkit/event/world/StructureLocateEvent.java b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+new file mode 100644\n+index 0000000000000000000000000000000000000000..1011b03fcc7be912e617a6fde3f62e68d70f2c1c\n+--- /dev/null\n++++ b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+@@ -0,0 +1,137 @@\n++package org.bukkit.event.world;\n++\n++import org.bukkit.Location;\n++import org.bukkit.StructureType;\n++import org.bukkit.World;\n++import org.bukkit.event.Cancellable;\n++import org.bukkit.event.HandlerList;\n++import org.jetbrains.annotations.NotNull;\n++import org.jetbrains.annotations.Nullable;\n++\n++/**\n++ * Called <b>before</b> a structure/feature is located.\n++ * This happens when:<br>\n++ *   - The /locate command is used.<br>\n++ *   - An Eye of Ender is used.<br>\n++ *   - An Explorer/Treasure Map is activated.<br>\n++ *   - {@link World#locateNearestStructure(Location, StructureType, int, boolean)} is invoked.\n++ */\n++public class StructureLocateEvent extends WorldEvent implements Cancellable {\n++    private static final HandlerList handlers = new HandlerList();\n++    private final Location origin;\n++    private Location result = null;\n++    private StructureType type;\n++    private int radius;\n++    private boolean findUnexplored;\n++    private boolean cancelled = false;\n++    public StructureLocateEvent(@NotNull World world, @NotNull Location origin, @NotNull StructureType structureType, int radius, boolean findUnexplored) {\n++        super(world);\n++        this.origin = origin;\n++        this.type = structureType;\n++        this.radius = radius;\n++        this.findUnexplored = findUnexplored;\n++    }\n++\n++    @NotNull\n++    @Override\n++    public HandlerList getHandlers() {\n++        return handlers;\n++    }\n++\n++    @NotNull\n++    public static HandlerList getHandlerList() {\n++        return handlers;\n++    }\n++\n++    /**\n++     * Gets the location set as the structure location, if it was defined.<br>\n++     * Returns null if it has not been set by {@link StructureLocateEvent#setResult(Location)}.<br>\n++     * Since this event fires <i>before</i> the search is done, the actual location is unknown at this point.<br>\n++     * If you wish to manipulate the location, use {@link World#locateNearestStructure(Location, StructureType, int, boolean)}\n++     * @return The result location, if it has been set. null if it has not.\n++     */\n++    @Nullable\n++    public Location getResult() {\n++        return result;\n++    }\n++\n++    /**\n++     * Sets the result Location. This causes the search to be skipped, and the location passed here to be used as the result.\n++     * @param result the Location of the structure.", "originalCommit": "836f20dea3e02b6deb10e258363a602cd5316684", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1MjY2MQ==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523452661", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            +     * Gets the {@link StructureType} that is to be located.\n          \n          \n            \n            +     * @return the structure type.\n          \n          \n            \n            +     * Gets the {@link StructureType} that is to be located.\n          \n          \n            \n            +     *\n          \n          \n            \n            +     * @return the structure type.", "author": "Proximyst", "createdAt": "2020-11-14T19:14:54Z", "path": "Spigot-API-Patches/0227-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,149 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Tue, 15 Sep 2020 21:59:16 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/org/bukkit/event/world/StructureLocateEvent.java b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+new file mode 100644\n+index 0000000000000000000000000000000000000000..1011b03fcc7be912e617a6fde3f62e68d70f2c1c\n+--- /dev/null\n++++ b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+@@ -0,0 +1,137 @@\n++package org.bukkit.event.world;\n++\n++import org.bukkit.Location;\n++import org.bukkit.StructureType;\n++import org.bukkit.World;\n++import org.bukkit.event.Cancellable;\n++import org.bukkit.event.HandlerList;\n++import org.jetbrains.annotations.NotNull;\n++import org.jetbrains.annotations.Nullable;\n++\n++/**\n++ * Called <b>before</b> a structure/feature is located.\n++ * This happens when:<br>\n++ *   - The /locate command is used.<br>\n++ *   - An Eye of Ender is used.<br>\n++ *   - An Explorer/Treasure Map is activated.<br>\n++ *   - {@link World#locateNearestStructure(Location, StructureType, int, boolean)} is invoked.\n++ */\n++public class StructureLocateEvent extends WorldEvent implements Cancellable {\n++    private static final HandlerList handlers = new HandlerList();\n++    private final Location origin;\n++    private Location result = null;\n++    private StructureType type;\n++    private int radius;\n++    private boolean findUnexplored;\n++    private boolean cancelled = false;\n++    public StructureLocateEvent(@NotNull World world, @NotNull Location origin, @NotNull StructureType structureType, int radius, boolean findUnexplored) {\n++        super(world);\n++        this.origin = origin;\n++        this.type = structureType;\n++        this.radius = radius;\n++        this.findUnexplored = findUnexplored;\n++    }\n++\n++    @NotNull\n++    @Override\n++    public HandlerList getHandlers() {\n++        return handlers;\n++    }\n++\n++    @NotNull\n++    public static HandlerList getHandlerList() {\n++        return handlers;\n++    }\n++\n++    /**\n++     * Gets the location set as the structure location, if it was defined.<br>\n++     * Returns null if it has not been set by {@link StructureLocateEvent#setResult(Location)}.<br>\n++     * Since this event fires <i>before</i> the search is done, the actual location is unknown at this point.<br>\n++     * If you wish to manipulate the location, use {@link World#locateNearestStructure(Location, StructureType, int, boolean)}\n++     * @return The result location, if it has been set. null if it has not.\n++     */\n++    @Nullable\n++    public Location getResult() {\n++        return result;\n++    }\n++\n++    /**\n++     * Sets the result Location. This causes the search to be skipped, and the location passed here to be used as the result.\n++     * @param result the Location of the structure.\n++     */\n++    public void setResult(@Nullable Location result) {\n++        this.result = result;\n++    }\n++\n++    /**\n++     * Gets the {@link StructureType} that is to be located.\n++     * @return the structure type.", "originalCommit": "836f20dea3e02b6deb10e258363a602cd5316684", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1MjY5Mg==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523452692", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            +     * Sets the {@link StructureType} that is to be located.\n          \n          \n            \n            +     * @param type the structure type.\n          \n          \n            \n            +     * Sets the {@link StructureType} that is to be located.\n          \n          \n            \n            +     *\n          \n          \n            \n            +     * @param type the structure type.", "author": "Proximyst", "createdAt": "2020-11-14T19:15:06Z", "path": "Spigot-API-Patches/0227-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,149 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Tue, 15 Sep 2020 21:59:16 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/org/bukkit/event/world/StructureLocateEvent.java b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+new file mode 100644\n+index 0000000000000000000000000000000000000000..1011b03fcc7be912e617a6fde3f62e68d70f2c1c\n+--- /dev/null\n++++ b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+@@ -0,0 +1,137 @@\n++package org.bukkit.event.world;\n++\n++import org.bukkit.Location;\n++import org.bukkit.StructureType;\n++import org.bukkit.World;\n++import org.bukkit.event.Cancellable;\n++import org.bukkit.event.HandlerList;\n++import org.jetbrains.annotations.NotNull;\n++import org.jetbrains.annotations.Nullable;\n++\n++/**\n++ * Called <b>before</b> a structure/feature is located.\n++ * This happens when:<br>\n++ *   - The /locate command is used.<br>\n++ *   - An Eye of Ender is used.<br>\n++ *   - An Explorer/Treasure Map is activated.<br>\n++ *   - {@link World#locateNearestStructure(Location, StructureType, int, boolean)} is invoked.\n++ */\n++public class StructureLocateEvent extends WorldEvent implements Cancellable {\n++    private static final HandlerList handlers = new HandlerList();\n++    private final Location origin;\n++    private Location result = null;\n++    private StructureType type;\n++    private int radius;\n++    private boolean findUnexplored;\n++    private boolean cancelled = false;\n++    public StructureLocateEvent(@NotNull World world, @NotNull Location origin, @NotNull StructureType structureType, int radius, boolean findUnexplored) {\n++        super(world);\n++        this.origin = origin;\n++        this.type = structureType;\n++        this.radius = radius;\n++        this.findUnexplored = findUnexplored;\n++    }\n++\n++    @NotNull\n++    @Override\n++    public HandlerList getHandlers() {\n++        return handlers;\n++    }\n++\n++    @NotNull\n++    public static HandlerList getHandlerList() {\n++        return handlers;\n++    }\n++\n++    /**\n++     * Gets the location set as the structure location, if it was defined.<br>\n++     * Returns null if it has not been set by {@link StructureLocateEvent#setResult(Location)}.<br>\n++     * Since this event fires <i>before</i> the search is done, the actual location is unknown at this point.<br>\n++     * If you wish to manipulate the location, use {@link World#locateNearestStructure(Location, StructureType, int, boolean)}\n++     * @return The result location, if it has been set. null if it has not.\n++     */\n++    @Nullable\n++    public Location getResult() {\n++        return result;\n++    }\n++\n++    /**\n++     * Sets the result Location. This causes the search to be skipped, and the location passed here to be used as the result.\n++     * @param result the Location of the structure.\n++     */\n++    public void setResult(@Nullable Location result) {\n++        this.result = result;\n++    }\n++\n++    /**\n++     * Gets the {@link StructureType} that is to be located.\n++     * @return the structure type.\n++     */\n++    @NotNull\n++    public StructureType getType() {\n++        return type;\n++    }\n++\n++    /**\n++     * Sets the {@link StructureType} that is to be located.\n++     * @param type the structure type.", "originalCommit": "836f20dea3e02b6deb10e258363a602cd5316684", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1MjcwNw==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523452707", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            +     * Gets the location from which the search is to be conducted.\n          \n          \n            \n            +     * @return Location where search begins\n          \n          \n            \n            +     * Gets the location from which the search is to be conducted.\n          \n          \n            \n            +     *\n          \n          \n            \n            +     * @return Location where search begins", "author": "Proximyst", "createdAt": "2020-11-14T19:15:15Z", "path": "Spigot-API-Patches/0227-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,149 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Tue, 15 Sep 2020 21:59:16 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/org/bukkit/event/world/StructureLocateEvent.java b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+new file mode 100644\n+index 0000000000000000000000000000000000000000..1011b03fcc7be912e617a6fde3f62e68d70f2c1c\n+--- /dev/null\n++++ b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+@@ -0,0 +1,137 @@\n++package org.bukkit.event.world;\n++\n++import org.bukkit.Location;\n++import org.bukkit.StructureType;\n++import org.bukkit.World;\n++import org.bukkit.event.Cancellable;\n++import org.bukkit.event.HandlerList;\n++import org.jetbrains.annotations.NotNull;\n++import org.jetbrains.annotations.Nullable;\n++\n++/**\n++ * Called <b>before</b> a structure/feature is located.\n++ * This happens when:<br>\n++ *   - The /locate command is used.<br>\n++ *   - An Eye of Ender is used.<br>\n++ *   - An Explorer/Treasure Map is activated.<br>\n++ *   - {@link World#locateNearestStructure(Location, StructureType, int, boolean)} is invoked.\n++ */\n++public class StructureLocateEvent extends WorldEvent implements Cancellable {\n++    private static final HandlerList handlers = new HandlerList();\n++    private final Location origin;\n++    private Location result = null;\n++    private StructureType type;\n++    private int radius;\n++    private boolean findUnexplored;\n++    private boolean cancelled = false;\n++    public StructureLocateEvent(@NotNull World world, @NotNull Location origin, @NotNull StructureType structureType, int radius, boolean findUnexplored) {\n++        super(world);\n++        this.origin = origin;\n++        this.type = structureType;\n++        this.radius = radius;\n++        this.findUnexplored = findUnexplored;\n++    }\n++\n++    @NotNull\n++    @Override\n++    public HandlerList getHandlers() {\n++        return handlers;\n++    }\n++\n++    @NotNull\n++    public static HandlerList getHandlerList() {\n++        return handlers;\n++    }\n++\n++    /**\n++     * Gets the location set as the structure location, if it was defined.<br>\n++     * Returns null if it has not been set by {@link StructureLocateEvent#setResult(Location)}.<br>\n++     * Since this event fires <i>before</i> the search is done, the actual location is unknown at this point.<br>\n++     * If you wish to manipulate the location, use {@link World#locateNearestStructure(Location, StructureType, int, boolean)}\n++     * @return The result location, if it has been set. null if it has not.\n++     */\n++    @Nullable\n++    public Location getResult() {\n++        return result;\n++    }\n++\n++    /**\n++     * Sets the result Location. This causes the search to be skipped, and the location passed here to be used as the result.\n++     * @param result the Location of the structure.\n++     */\n++    public void setResult(@Nullable Location result) {\n++        this.result = result;\n++    }\n++\n++    /**\n++     * Gets the {@link StructureType} that is to be located.\n++     * @return the structure type.\n++     */\n++    @NotNull\n++    public StructureType getType() {\n++        return type;\n++    }\n++\n++    /**\n++     * Sets the {@link StructureType} that is to be located.\n++     * @param type the structure type.\n++     */\n++    public void setType(@NotNull StructureType type) {\n++        this.type = type;\n++    }\n++\n++    /**\n++     * Gets the location from which the search is to be conducted.\n++     * @return Location where search begins", "originalCommit": "836f20dea3e02b6deb10e258363a602cd5316684", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1Mjc0OQ==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523452749", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            +     * Gets the search radius in which to attempt locating the structure.<br>\n          \n          \n            \n            +     * This radius may not always be obeyed during the structure search!\n          \n          \n            \n            +     * @return the search radius.\n          \n          \n            \n            +     * Gets the search radius in which to attempt locating the structure.\n          \n          \n            \n            +     * <p>\n          \n          \n            \n            +     * This radius may not always be obeyed during the structure search!\n          \n          \n            \n            +     *\n          \n          \n            \n            +     * @return the search radius.", "author": "Proximyst", "createdAt": "2020-11-14T19:15:38Z", "path": "Spigot-API-Patches/0227-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,149 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Tue, 15 Sep 2020 21:59:16 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/org/bukkit/event/world/StructureLocateEvent.java b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+new file mode 100644\n+index 0000000000000000000000000000000000000000..1011b03fcc7be912e617a6fde3f62e68d70f2c1c\n+--- /dev/null\n++++ b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+@@ -0,0 +1,137 @@\n++package org.bukkit.event.world;\n++\n++import org.bukkit.Location;\n++import org.bukkit.StructureType;\n++import org.bukkit.World;\n++import org.bukkit.event.Cancellable;\n++import org.bukkit.event.HandlerList;\n++import org.jetbrains.annotations.NotNull;\n++import org.jetbrains.annotations.Nullable;\n++\n++/**\n++ * Called <b>before</b> a structure/feature is located.\n++ * This happens when:<br>\n++ *   - The /locate command is used.<br>\n++ *   - An Eye of Ender is used.<br>\n++ *   - An Explorer/Treasure Map is activated.<br>\n++ *   - {@link World#locateNearestStructure(Location, StructureType, int, boolean)} is invoked.\n++ */\n++public class StructureLocateEvent extends WorldEvent implements Cancellable {\n++    private static final HandlerList handlers = new HandlerList();\n++    private final Location origin;\n++    private Location result = null;\n++    private StructureType type;\n++    private int radius;\n++    private boolean findUnexplored;\n++    private boolean cancelled = false;\n++    public StructureLocateEvent(@NotNull World world, @NotNull Location origin, @NotNull StructureType structureType, int radius, boolean findUnexplored) {\n++        super(world);\n++        this.origin = origin;\n++        this.type = structureType;\n++        this.radius = radius;\n++        this.findUnexplored = findUnexplored;\n++    }\n++\n++    @NotNull\n++    @Override\n++    public HandlerList getHandlers() {\n++        return handlers;\n++    }\n++\n++    @NotNull\n++    public static HandlerList getHandlerList() {\n++        return handlers;\n++    }\n++\n++    /**\n++     * Gets the location set as the structure location, if it was defined.<br>\n++     * Returns null if it has not been set by {@link StructureLocateEvent#setResult(Location)}.<br>\n++     * Since this event fires <i>before</i> the search is done, the actual location is unknown at this point.<br>\n++     * If you wish to manipulate the location, use {@link World#locateNearestStructure(Location, StructureType, int, boolean)}\n++     * @return The result location, if it has been set. null if it has not.\n++     */\n++    @Nullable\n++    public Location getResult() {\n++        return result;\n++    }\n++\n++    /**\n++     * Sets the result Location. This causes the search to be skipped, and the location passed here to be used as the result.\n++     * @param result the Location of the structure.\n++     */\n++    public void setResult(@Nullable Location result) {\n++        this.result = result;\n++    }\n++\n++    /**\n++     * Gets the {@link StructureType} that is to be located.\n++     * @return the structure type.\n++     */\n++    @NotNull\n++    public StructureType getType() {\n++        return type;\n++    }\n++\n++    /**\n++     * Sets the {@link StructureType} that is to be located.\n++     * @param type the structure type.\n++     */\n++    public void setType(@NotNull StructureType type) {\n++        this.type = type;\n++    }\n++\n++    /**\n++     * Gets the location from which the search is to be conducted.\n++     * @return Location where search begins\n++     */\n++    @NotNull\n++    public Location getOrigin() {\n++        return origin;\n++    }\n++\n++    /**\n++     * Gets the search radius in which to attempt locating the structure.<br>\n++     * This radius may not always be obeyed during the structure search!\n++     * @return the search radius.", "originalCommit": "836f20dea3e02b6deb10e258363a602cd5316684", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1Mjc4Nw==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523452787", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            +     * Sets the search radius in which to attempt locating the structure.<br>\n          \n          \n            \n            +     * This radius may not always be obeyed during the structure search!\n          \n          \n            \n            +     * @param radius the search radius.\n          \n          \n            \n            +     * Sets the search radius in which to attempt locating the structure.\n          \n          \n            \n            +     * <p>\n          \n          \n            \n            +     * This radius may not always be obeyed during the structure search!\n          \n          \n            \n            +     *\n          \n          \n            \n            +     * @return the search radius.", "author": "Proximyst", "createdAt": "2020-11-14T19:16:02Z", "path": "Spigot-API-Patches/0227-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,149 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Tue, 15 Sep 2020 21:59:16 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/org/bukkit/event/world/StructureLocateEvent.java b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+new file mode 100644\n+index 0000000000000000000000000000000000000000..1011b03fcc7be912e617a6fde3f62e68d70f2c1c\n+--- /dev/null\n++++ b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+@@ -0,0 +1,137 @@\n++package org.bukkit.event.world;\n++\n++import org.bukkit.Location;\n++import org.bukkit.StructureType;\n++import org.bukkit.World;\n++import org.bukkit.event.Cancellable;\n++import org.bukkit.event.HandlerList;\n++import org.jetbrains.annotations.NotNull;\n++import org.jetbrains.annotations.Nullable;\n++\n++/**\n++ * Called <b>before</b> a structure/feature is located.\n++ * This happens when:<br>\n++ *   - The /locate command is used.<br>\n++ *   - An Eye of Ender is used.<br>\n++ *   - An Explorer/Treasure Map is activated.<br>\n++ *   - {@link World#locateNearestStructure(Location, StructureType, int, boolean)} is invoked.\n++ */\n++public class StructureLocateEvent extends WorldEvent implements Cancellable {\n++    private static final HandlerList handlers = new HandlerList();\n++    private final Location origin;\n++    private Location result = null;\n++    private StructureType type;\n++    private int radius;\n++    private boolean findUnexplored;\n++    private boolean cancelled = false;\n++    public StructureLocateEvent(@NotNull World world, @NotNull Location origin, @NotNull StructureType structureType, int radius, boolean findUnexplored) {\n++        super(world);\n++        this.origin = origin;\n++        this.type = structureType;\n++        this.radius = radius;\n++        this.findUnexplored = findUnexplored;\n++    }\n++\n++    @NotNull\n++    @Override\n++    public HandlerList getHandlers() {\n++        return handlers;\n++    }\n++\n++    @NotNull\n++    public static HandlerList getHandlerList() {\n++        return handlers;\n++    }\n++\n++    /**\n++     * Gets the location set as the structure location, if it was defined.<br>\n++     * Returns null if it has not been set by {@link StructureLocateEvent#setResult(Location)}.<br>\n++     * Since this event fires <i>before</i> the search is done, the actual location is unknown at this point.<br>\n++     * If you wish to manipulate the location, use {@link World#locateNearestStructure(Location, StructureType, int, boolean)}\n++     * @return The result location, if it has been set. null if it has not.\n++     */\n++    @Nullable\n++    public Location getResult() {\n++        return result;\n++    }\n++\n++    /**\n++     * Sets the result Location. This causes the search to be skipped, and the location passed here to be used as the result.\n++     * @param result the Location of the structure.\n++     */\n++    public void setResult(@Nullable Location result) {\n++        this.result = result;\n++    }\n++\n++    /**\n++     * Gets the {@link StructureType} that is to be located.\n++     * @return the structure type.\n++     */\n++    @NotNull\n++    public StructureType getType() {\n++        return type;\n++    }\n++\n++    /**\n++     * Sets the {@link StructureType} that is to be located.\n++     * @param type the structure type.\n++     */\n++    public void setType(@NotNull StructureType type) {\n++        this.type = type;\n++    }\n++\n++    /**\n++     * Gets the location from which the search is to be conducted.\n++     * @return Location where search begins\n++     */\n++    @NotNull\n++    public Location getOrigin() {\n++        return origin;\n++    }\n++\n++    /**\n++     * Gets the search radius in which to attempt locating the structure.<br>\n++     * This radius may not always be obeyed during the structure search!\n++     * @return the search radius.\n++     */\n++    public int getRadius() {\n++        return radius;\n++    }\n++\n++    /**\n++     * Sets the search radius in which to attempt locating the structure.<br>\n++     * This radius may not always be obeyed during the structure search!\n++     * @param radius the search radius.", "originalCommit": "836f20dea3e02b6deb10e258363a602cd5316684", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1MjgzNg==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523452836", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            +     * Gets whether to search exclusively for unexplored structures.<br>\n          \n          \n            \n            +     * As with the search radius, this value is not always obeyed.\n          \n          \n            \n            +     * @return Whether to search for only unexplored structures.\n          \n          \n            \n            +     * Gets whether to search exclusively for unexplored structures.\n          \n          \n            \n            +     * <p>\n          \n          \n            \n            +     * As with the search radius, this value is not always obeyed.\n          \n          \n            \n            +     *\n          \n          \n            \n            +     * @return Whether to search for only unexplored structures.", "author": "Proximyst", "createdAt": "2020-11-14T19:16:25Z", "path": "Spigot-API-Patches/0227-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,149 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Tue, 15 Sep 2020 21:59:16 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/org/bukkit/event/world/StructureLocateEvent.java b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+new file mode 100644\n+index 0000000000000000000000000000000000000000..1011b03fcc7be912e617a6fde3f62e68d70f2c1c\n+--- /dev/null\n++++ b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+@@ -0,0 +1,137 @@\n++package org.bukkit.event.world;\n++\n++import org.bukkit.Location;\n++import org.bukkit.StructureType;\n++import org.bukkit.World;\n++import org.bukkit.event.Cancellable;\n++import org.bukkit.event.HandlerList;\n++import org.jetbrains.annotations.NotNull;\n++import org.jetbrains.annotations.Nullable;\n++\n++/**\n++ * Called <b>before</b> a structure/feature is located.\n++ * This happens when:<br>\n++ *   - The /locate command is used.<br>\n++ *   - An Eye of Ender is used.<br>\n++ *   - An Explorer/Treasure Map is activated.<br>\n++ *   - {@link World#locateNearestStructure(Location, StructureType, int, boolean)} is invoked.\n++ */\n++public class StructureLocateEvent extends WorldEvent implements Cancellable {\n++    private static final HandlerList handlers = new HandlerList();\n++    private final Location origin;\n++    private Location result = null;\n++    private StructureType type;\n++    private int radius;\n++    private boolean findUnexplored;\n++    private boolean cancelled = false;\n++    public StructureLocateEvent(@NotNull World world, @NotNull Location origin, @NotNull StructureType structureType, int radius, boolean findUnexplored) {\n++        super(world);\n++        this.origin = origin;\n++        this.type = structureType;\n++        this.radius = radius;\n++        this.findUnexplored = findUnexplored;\n++    }\n++\n++    @NotNull\n++    @Override\n++    public HandlerList getHandlers() {\n++        return handlers;\n++    }\n++\n++    @NotNull\n++    public static HandlerList getHandlerList() {\n++        return handlers;\n++    }\n++\n++    /**\n++     * Gets the location set as the structure location, if it was defined.<br>\n++     * Returns null if it has not been set by {@link StructureLocateEvent#setResult(Location)}.<br>\n++     * Since this event fires <i>before</i> the search is done, the actual location is unknown at this point.<br>\n++     * If you wish to manipulate the location, use {@link World#locateNearestStructure(Location, StructureType, int, boolean)}\n++     * @return The result location, if it has been set. null if it has not.\n++     */\n++    @Nullable\n++    public Location getResult() {\n++        return result;\n++    }\n++\n++    /**\n++     * Sets the result Location. This causes the search to be skipped, and the location passed here to be used as the result.\n++     * @param result the Location of the structure.\n++     */\n++    public void setResult(@Nullable Location result) {\n++        this.result = result;\n++    }\n++\n++    /**\n++     * Gets the {@link StructureType} that is to be located.\n++     * @return the structure type.\n++     */\n++    @NotNull\n++    public StructureType getType() {\n++        return type;\n++    }\n++\n++    /**\n++     * Sets the {@link StructureType} that is to be located.\n++     * @param type the structure type.\n++     */\n++    public void setType(@NotNull StructureType type) {\n++        this.type = type;\n++    }\n++\n++    /**\n++     * Gets the location from which the search is to be conducted.\n++     * @return Location where search begins\n++     */\n++    @NotNull\n++    public Location getOrigin() {\n++        return origin;\n++    }\n++\n++    /**\n++     * Gets the search radius in which to attempt locating the structure.<br>\n++     * This radius may not always be obeyed during the structure search!\n++     * @return the search radius.\n++     */\n++    public int getRadius() {\n++        return radius;\n++    }\n++\n++    /**\n++     * Sets the search radius in which to attempt locating the structure.<br>\n++     * This radius may not always be obeyed during the structure search!\n++     * @param radius the search radius.\n++     */\n++    public void setRadius(int radius) {\n++        this.radius = radius;\n++    }\n++\n++    /**\n++     * Gets whether to search exclusively for unexplored structures.<br>\n++     * As with the search radius, this value is not always obeyed.\n++     * @return Whether to search for only unexplored structures.", "originalCommit": "836f20dea3e02b6deb10e258363a602cd5316684", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1Mjg2Mw==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523452863", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            +     * Sets whether to search exclusively for unexplored structures.<br>\n          \n          \n            \n            +     * As with the search radius, this value is not always obeyed.\n          \n          \n            \n            +     * @param findUnexplored Whether to search for only unexplored structures.\n          \n          \n            \n            +     * Sets whether to search exclusively for unexplored structures.\n          \n          \n            \n            +     * <p>\n          \n          \n            \n            +     * As with the search radius, this value is not always obeyed.\n          \n          \n            \n            +     *\n          \n          \n            \n            +     * @param findUnexplored Whether to search for only unexplored structures.", "author": "Proximyst", "createdAt": "2020-11-14T19:16:38Z", "path": "Spigot-API-Patches/0227-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,149 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Tue, 15 Sep 2020 21:59:16 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/org/bukkit/event/world/StructureLocateEvent.java b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+new file mode 100644\n+index 0000000000000000000000000000000000000000..1011b03fcc7be912e617a6fde3f62e68d70f2c1c\n+--- /dev/null\n++++ b/src/main/java/org/bukkit/event/world/StructureLocateEvent.java\n+@@ -0,0 +1,137 @@\n++package org.bukkit.event.world;\n++\n++import org.bukkit.Location;\n++import org.bukkit.StructureType;\n++import org.bukkit.World;\n++import org.bukkit.event.Cancellable;\n++import org.bukkit.event.HandlerList;\n++import org.jetbrains.annotations.NotNull;\n++import org.jetbrains.annotations.Nullable;\n++\n++/**\n++ * Called <b>before</b> a structure/feature is located.\n++ * This happens when:<br>\n++ *   - The /locate command is used.<br>\n++ *   - An Eye of Ender is used.<br>\n++ *   - An Explorer/Treasure Map is activated.<br>\n++ *   - {@link World#locateNearestStructure(Location, StructureType, int, boolean)} is invoked.\n++ */\n++public class StructureLocateEvent extends WorldEvent implements Cancellable {\n++    private static final HandlerList handlers = new HandlerList();\n++    private final Location origin;\n++    private Location result = null;\n++    private StructureType type;\n++    private int radius;\n++    private boolean findUnexplored;\n++    private boolean cancelled = false;\n++    public StructureLocateEvent(@NotNull World world, @NotNull Location origin, @NotNull StructureType structureType, int radius, boolean findUnexplored) {\n++        super(world);\n++        this.origin = origin;\n++        this.type = structureType;\n++        this.radius = radius;\n++        this.findUnexplored = findUnexplored;\n++    }\n++\n++    @NotNull\n++    @Override\n++    public HandlerList getHandlers() {\n++        return handlers;\n++    }\n++\n++    @NotNull\n++    public static HandlerList getHandlerList() {\n++        return handlers;\n++    }\n++\n++    /**\n++     * Gets the location set as the structure location, if it was defined.<br>\n++     * Returns null if it has not been set by {@link StructureLocateEvent#setResult(Location)}.<br>\n++     * Since this event fires <i>before</i> the search is done, the actual location is unknown at this point.<br>\n++     * If you wish to manipulate the location, use {@link World#locateNearestStructure(Location, StructureType, int, boolean)}\n++     * @return The result location, if it has been set. null if it has not.\n++     */\n++    @Nullable\n++    public Location getResult() {\n++        return result;\n++    }\n++\n++    /**\n++     * Sets the result Location. This causes the search to be skipped, and the location passed here to be used as the result.\n++     * @param result the Location of the structure.\n++     */\n++    public void setResult(@Nullable Location result) {\n++        this.result = result;\n++    }\n++\n++    /**\n++     * Gets the {@link StructureType} that is to be located.\n++     * @return the structure type.\n++     */\n++    @NotNull\n++    public StructureType getType() {\n++        return type;\n++    }\n++\n++    /**\n++     * Sets the {@link StructureType} that is to be located.\n++     * @param type the structure type.\n++     */\n++    public void setType(@NotNull StructureType type) {\n++        this.type = type;\n++    }\n++\n++    /**\n++     * Gets the location from which the search is to be conducted.\n++     * @return Location where search begins\n++     */\n++    @NotNull\n++    public Location getOrigin() {\n++        return origin;\n++    }\n++\n++    /**\n++     * Gets the search radius in which to attempt locating the structure.<br>\n++     * This radius may not always be obeyed during the structure search!\n++     * @return the search radius.\n++     */\n++    public int getRadius() {\n++        return radius;\n++    }\n++\n++    /**\n++     * Sets the search radius in which to attempt locating the structure.<br>\n++     * This radius may not always be obeyed during the structure search!\n++     * @param radius the search radius.\n++     */\n++    public void setRadius(int radius) {\n++        this.radius = radius;\n++    }\n++\n++    /**\n++     * Gets whether to search exclusively for unexplored structures.<br>\n++     * As with the search radius, this value is not always obeyed.\n++     * @return Whether to search for only unexplored structures.\n++     */\n++    public boolean shouldFindUnexplored() {\n++        return findUnexplored;\n++    }\n++\n++    /**\n++     * Sets whether to search exclusively for unexplored structures.<br>\n++     * As with the search radius, this value is not always obeyed.\n++     * @param findUnexplored Whether to search for only unexplored structures.", "originalCommit": "836f20dea3e02b6deb10e258363a602cd5316684", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1Mjk3OQ==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523452979", "bodyText": "What if the location has a different world?", "author": "Proximyst", "createdAt": "2020-11-14T19:18:00Z", "path": "Spigot-Server-Patches/0580-Add-StructureLocateEvent.patch", "diffHunk": "@@ -0,0 +1,31 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: dfsek <dfsek@protonmail.com>\n+Date: Wed, 16 Sep 2020 01:12:29 -0700\n+Subject: [PATCH] Add StructureLocateEvent\n+\n+\n+diff --git a/src/main/java/net/minecraft/server/ChunkGenerator.java b/src/main/java/net/minecraft/server/ChunkGenerator.java\n+index 9a6fef215052f9c513b23024968995c97863a453..5adc9dc871b22dfd76e298505db1b3f5385b554a 100644\n+--- a/src/main/java/net/minecraft/server/ChunkGenerator.java\n++++ b/src/main/java/net/minecraft/server/ChunkGenerator.java\n+@@ -124,6 +124,20 @@ public abstract class ChunkGenerator {\n+ \n+     @Nullable\n+     public BlockPosition findNearestMapFeature(WorldServer worldserver, StructureGenerator<?> structuregenerator, BlockPosition blockposition, int i, boolean flag) {\n++        // Paper start\n++        org.bukkit.World world = worldserver.getWorld();\n++        org.bukkit.Location originLocation = new org.bukkit.Location(world, blockposition.getX(), blockposition.getY(), blockposition.getZ());\n++        org.bukkit.event.world.StructureLocateEvent event = new org.bukkit.event.world.StructureLocateEvent(world, originLocation, org.bukkit.StructureType.getStructureTypes().get(structuregenerator.i()), i, flag);\n++        if(!event.callEvent()) return null;\n++        // If event call set a final location, skip structure finding and just return set result.\n++        if(event.getResult() != null) return new BlockPosition(event.getResult().getBlockX(), event.getResult().getBlockY(), event.getResult().getBlockZ());\n++        // Get origin location (re)defined by event call.\n++        blockposition = new BlockPosition(event.getOrigin().getBlockX(), event.getOrigin().getBlockY(), event.getOrigin().getBlockZ());", "originalCommit": "836f20dea3e02b6deb10e258363a602cd5316684", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkxNjE5NQ==", "url": "https://github.com/PaperMC/Paper/pull/4333#discussion_r523916195", "bodyText": "World is updated in latest commit.", "author": "dfsek", "createdAt": "2020-11-16T06:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ1Mjk3OQ=="}], "type": "inlineReview"}, {"oid": "68f019eae2d0a1e789eb69ee20e29c422c1c9803", "url": "https://github.com/PaperMC/Paper/commit/68f019eae2d0a1e789eb69ee20e29c422c1c9803", "message": "Add StructureLocateEvent\n\nSigned-off-by: MiniDigger <admin@minidigger.me>", "committedDate": "2021-01-16T17:21:05Z", "type": "commit"}]}