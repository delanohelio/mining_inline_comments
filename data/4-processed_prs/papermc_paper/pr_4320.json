{"pr_number": 4320, "pr_title": "Only consider chunks Loaded if at BORDER status", "pr_createdAt": "2020-09-13T02:28:15Z", "pr_url": "https://github.com/PaperMC/Paper/pull/4320", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE5NzQ0MA==", "url": "https://github.com/PaperMC/Paper/pull/4320#discussion_r490197440", "bodyText": "Empty if statement", "author": "unisteven", "createdAt": "2020-09-17T12:17:56Z", "path": "Spigot-Server-Patches/0580-Only-consider-chunks-Loaded-if-at-BORDER-status.patch", "diffHunk": "@@ -0,0 +1,158 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Aikar <aikar@aikar.co>\n+Date: Sat, 12 Sep 2020 22:20:55 -0400\n+Subject: [PATCH] Only consider chunks Loaded if at BORDER status\n+\n+This greatly improves performance as it drastically reduces the amount\n+of Entities and Tile Entities that are \"registered\" into the world, as\n+purely \"cached\" chunks will no longer have their entities hanging out in the world.\n+\n+Additionally this fixes our Entity Add To World and Entity Remove From World events\n+\n+Those events have not been firing correctly since MC changed how chunks work here.\n+\n+Now the server will only consider a chunk \"loaded\" if it's got a ticket putting\n+it at level 33 or lower, which matches the public Bukkit API.\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 299d7d7a55532930e2d4340a6cfe77a5fd8a0a0c..15c0a06139bffc6a7f83a1d47f2a708f14d264ec 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -791,6 +791,7 @@ public class Chunk implements IChunkAccess {\n+         int chunkX = this.loc.x;\n+         int chunkZ = this.loc.z;\n+         ChunkProviderServer chunkProvider = ((WorldServer)this.world).getChunkProvider();\n++        chunkProvider.playerChunkMap.loadChunk(this); // Paper - move load logic from the entering full status to when it enters border status instead\n+         for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {\n+             for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {\n+                 Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);\n+@@ -862,6 +863,11 @@ public class Chunk implements IChunkAccess {\n+         this.loadedTicketLevel = false;\n+         this.resetNeighbours();\n+         // Paper end\n++        // Paper start - move unload logic from the actual full unload to be when it leaves border status\n++        chunkProvider.playerChunkMap.loadedChunks.remove(loc.longKey);\n++        setLoaded(false);\n++        this.world.unloadChunk(this);\n++        // Paper end\n+     }\n+     // CraftBukkit end\n+ \n+diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+index 45c142c227bc258bbd5c8c03c6012663dccf8f3f..d119d68bb69baecdd7b896e6efb41251fa226adb 100644\n+--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java\n++++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+@@ -19,6 +19,7 @@ import java.util.function.Supplier;\n+ import javax.annotation.Nullable;\n+ import com.destroystokyo.paper.exception.ServerInternalException;\n+ import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper\n++import it.unimi.dsi.fastutil.longs.LongIterator; // Paper\n+ import org.apache.logging.log4j.LogManager;\n+ import org.apache.logging.log4j.Logger;\n+ \n+@@ -822,7 +823,9 @@ public class ChunkProviderServer extends IChunkProvider {\n+             //List<PlayerChunk> list = Lists.newArrayList(this.playerChunkMap.f()); // Paper\n+             //Collections.shuffle(list); // Paper\n+             // Paper - moved up\n+-            final int[] chunksTicked = {0}; this.playerChunkMap.forEachVisibleChunk((playerchunk) -> { // Paper - safe iterator incase chunk loads, also no wrapping\n++            final int[] chunksTicked = {0};\n++            for (LongIterator iterator = this.playerChunkMap.loadedChunks.iterator() ; iterator.hasNext() ; ) { // Paper - iterate only loaded chunks\n++                PlayerChunk playerchunk = this.playerChunkMap.getVisibleChunk(iterator.nextLong());// Paper - iterate only loaded chunks\n+                 Optional<Chunk> optional = ((Either) playerchunk.a().getNow(PlayerChunk.UNLOADED_CHUNK)).left();\n+ \n+                 if (optional.isPresent()) {\n+@@ -850,7 +853,7 @@ public class ChunkProviderServer extends IChunkProvider {\n+                         }\n+                     }\n+                 }\n+-            });\n++            };// Paper - use for instead of forEachVisibleChunk\n+             this.world.getMethodProfiler().enter(\"customSpawners\");\n+             if (flag1) {\n+                 try (co.aikar.timings.Timing ignored = this.world.timings.miscMobSpawning.startTiming()) { // Paper - timings\n+diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+index fcd3388d88aad6e897b73e2c823267ada327cbda..3f7da1a74eb881ddc30b20143c20fe162543c20f 100644\n+--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java\n++++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+@@ -1021,16 +1021,18 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+                 this.a(i, playerchunk);\n+             } else {\n+                 if (this.pendingUnload.remove(i, playerchunk) && ichunkaccess != null) {\n++                    // Paper start - coment out and move to ChunkUnloadEvent\n+                     if (ichunkaccess instanceof Chunk) {\n+-                        ((Chunk) ichunkaccess).setLoaded(false);", "originalCommit": "a50fd75caaf393aaff6bb57b2773569529116ca3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI1MDQ1NA==", "url": "https://github.com/PaperMC/Paper/pull/4320#discussion_r490250454", "bodyText": "we try to keep diff minimal, if they add something else here, it may then be needed to keep the chunk check.", "author": "aikar", "createdAt": "2020-09-17T13:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE5NzQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE5ODIyMA==", "url": "https://github.com/PaperMC/Paper/pull/4320#discussion_r490198220", "bodyText": "Commented out code could be removed.", "author": "unisteven", "createdAt": "2020-09-17T12:19:22Z", "path": "Spigot-Server-Patches/0580-Only-consider-chunks-Loaded-if-at-BORDER-status.patch", "diffHunk": "@@ -0,0 +1,158 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Aikar <aikar@aikar.co>\n+Date: Sat, 12 Sep 2020 22:20:55 -0400\n+Subject: [PATCH] Only consider chunks Loaded if at BORDER status\n+\n+This greatly improves performance as it drastically reduces the amount\n+of Entities and Tile Entities that are \"registered\" into the world, as\n+purely \"cached\" chunks will no longer have their entities hanging out in the world.\n+\n+Additionally this fixes our Entity Add To World and Entity Remove From World events\n+\n+Those events have not been firing correctly since MC changed how chunks work here.\n+\n+Now the server will only consider a chunk \"loaded\" if it's got a ticket putting\n+it at level 33 or lower, which matches the public Bukkit API.\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 299d7d7a55532930e2d4340a6cfe77a5fd8a0a0c..15c0a06139bffc6a7f83a1d47f2a708f14d264ec 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -791,6 +791,7 @@ public class Chunk implements IChunkAccess {\n+         int chunkX = this.loc.x;\n+         int chunkZ = this.loc.z;\n+         ChunkProviderServer chunkProvider = ((WorldServer)this.world).getChunkProvider();\n++        chunkProvider.playerChunkMap.loadChunk(this); // Paper - move load logic from the entering full status to when it enters border status instead\n+         for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {\n+             for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {\n+                 Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);\n+@@ -862,6 +863,11 @@ public class Chunk implements IChunkAccess {\n+         this.loadedTicketLevel = false;\n+         this.resetNeighbours();\n+         // Paper end\n++        // Paper start - move unload logic from the actual full unload to be when it leaves border status\n++        chunkProvider.playerChunkMap.loadedChunks.remove(loc.longKey);\n++        setLoaded(false);\n++        this.world.unloadChunk(this);\n++        // Paper end\n+     }\n+     // CraftBukkit end\n+ \n+diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+index 45c142c227bc258bbd5c8c03c6012663dccf8f3f..d119d68bb69baecdd7b896e6efb41251fa226adb 100644\n+--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java\n++++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java\n+@@ -19,6 +19,7 @@ import java.util.function.Supplier;\n+ import javax.annotation.Nullable;\n+ import com.destroystokyo.paper.exception.ServerInternalException;\n+ import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper\n++import it.unimi.dsi.fastutil.longs.LongIterator; // Paper\n+ import org.apache.logging.log4j.LogManager;\n+ import org.apache.logging.log4j.Logger;\n+ \n+@@ -822,7 +823,9 @@ public class ChunkProviderServer extends IChunkProvider {\n+             //List<PlayerChunk> list = Lists.newArrayList(this.playerChunkMap.f()); // Paper\n+             //Collections.shuffle(list); // Paper\n+             // Paper - moved up\n+-            final int[] chunksTicked = {0}; this.playerChunkMap.forEachVisibleChunk((playerchunk) -> { // Paper - safe iterator incase chunk loads, also no wrapping\n++            final int[] chunksTicked = {0};\n++            for (LongIterator iterator = this.playerChunkMap.loadedChunks.iterator() ; iterator.hasNext() ; ) { // Paper - iterate only loaded chunks\n++                PlayerChunk playerchunk = this.playerChunkMap.getVisibleChunk(iterator.nextLong());// Paper - iterate only loaded chunks\n+                 Optional<Chunk> optional = ((Either) playerchunk.a().getNow(PlayerChunk.UNLOADED_CHUNK)).left();\n+ \n+                 if (optional.isPresent()) {\n+@@ -850,7 +853,7 @@ public class ChunkProviderServer extends IChunkProvider {\n+                         }\n+                     }\n+                 }\n+-            });\n++            };// Paper - use for instead of forEachVisibleChunk\n+             this.world.getMethodProfiler().enter(\"customSpawners\");\n+             if (flag1) {\n+                 try (co.aikar.timings.Timing ignored = this.world.timings.miscMobSpawning.startTiming()) { // Paper - timings\n+diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+index fcd3388d88aad6e897b73e2c823267ada327cbda..3f7da1a74eb881ddc30b20143c20fe162543c20f 100644\n+--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java\n++++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+@@ -1021,16 +1021,18 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+                 this.a(i, playerchunk);\n+             } else {\n+                 if (this.pendingUnload.remove(i, playerchunk) && ichunkaccess != null) {\n++                    // Paper start - coment out and move to ChunkUnloadEvent\n+                     if (ichunkaccess instanceof Chunk) {\n+-                        ((Chunk) ichunkaccess).setLoaded(false);\n++                        //((Chunk) ichunkaccess).setLoaded(false);\n+                     }\n+ \n+                     //this.saveChunk(ichunkaccess);// Paper - delay\n+-                    if (this.loadedChunks.remove(i) && ichunkaccess instanceof Chunk) {\n+-                        Chunk chunk = (Chunk) ichunkaccess;\n+-\n+-                        this.world.unloadChunk(chunk);\n+-                    }\n++//                    if (this.loadedChunks.remove(i) && ichunkaccess instanceof Chunk) {", "originalCommit": "a50fd75caaf393aaff6bb57b2773569529116ca3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI1Mjc0NQ==", "url": "https://github.com/PaperMC/Paper/pull/4320#discussion_r490252745", "bodyText": "That is not how we do things, so that it can improve chance of conflict and see exactly what was moved.", "author": "aikar", "createdAt": "2020-09-17T13:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE5ODIyMA=="}], "type": "inlineReview"}, {"oid": "98934c11abb58070873332b73ff7ed3e982df59d", "url": "https://github.com/PaperMC/Paper/commit/98934c11abb58070873332b73ff7ed3e982df59d", "message": "Only consider chunks Loaded if at BORDER status\n\nThis greatly improves performance as it drastically reduces the amount\nof Entities and Tile Entities that are \"registered\" into the world, as\npurely \"cached\" chunks will no longer have their entities hanging out in the world.\n\nAdditionally this fixes our Entity Add To World and Entity Remove From World events\n\nThose events have not been firing correctly since MC changed how chunks work here.\n\nNow the server will only consider a chunk \"loaded\" if it's got a ticket putting\nit at level 33 or lower, which matches the public Bukkit API.", "committedDate": "2020-09-19T16:44:29Z", "type": "commit"}, {"oid": "a1839208ccf809cf0ff1c878826c9af227b89123", "url": "https://github.com/PaperMC/Paper/commit/a1839208ccf809cf0ff1c878826c9af227b89123", "message": "Optimize some methods for inlining\n\nAdds final to some methods to improve inlining ability", "committedDate": "2020-09-19T16:44:29Z", "type": "commit"}, {"oid": "a1839208ccf809cf0ff1c878826c9af227b89123", "url": "https://github.com/PaperMC/Paper/commit/a1839208ccf809cf0ff1c878826c9af227b89123", "message": "Optimize some methods for inlining\n\nAdds final to some methods to improve inlining ability", "committedDate": "2020-09-19T16:44:29Z", "type": "forcePushed"}]}