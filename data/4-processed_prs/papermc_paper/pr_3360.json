{"pr_number": 3360, "pr_title": "Workaround for Client Lag Spikes (MC-162253)", "pr_createdAt": "2020-05-12T21:39:01Z", "pr_url": "https://github.com/PaperMC/Paper/pull/3360", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1MzkwMg==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r425553902", "bodyText": "seven?", "author": "Spottedleaf", "createdAt": "2020-05-15T04:02:10Z", "path": "Spigot-Server-Patches/0521-Workaround-for-Client-Lag-Spikes-MC-16225.patch", "diffHunk": "@@ -0,0 +1,132 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: MeFisto94 <MeFisto94@users.noreply.github.com>\n+Date: Tue, 12 May 2020 23:02:43 +0200\n+Subject: [PATCH] Workaround for Client Lag Spikes (MC-16225) When crossing\n+ certain chunk boundaries, the client needlessly calculates light maps for\n+ chunk neighbours. In some specific map configurations, these calculations\n+ cause a 500ms+ freeze on the Client. This patch basically serves as a\n+ workaround by sending light maps to the client, so that it doesn't attempt to\n+ calculate them. This mitigates the frametime impact to a minimum (but it's\n+ still there).\n+\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 8c1f3290d23795b58a30274c9437dc7dc43fa3a1..33cca62d90bf037df1b0b4e901baedb91400aee7 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -277,7 +277,7 @@ public class Chunk implements IChunkAccess {\n+ \n+                     // broadcast\n+                     Object[] backingSet = inRange.getBackingSet();\n+-                    Packet[] chunkPackets = new Packet[2];\n++                    Packet[] chunkPackets = new Packet[10];\n+                     for (int index = 0, len = backingSet.length; index < len; ++index) {\n+                         Object temp = backingSet[index];\n+                         if (!(temp instanceof EntityPlayer)) {\n+diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+index 81bb26abc520f49de2e916cf2757ac4c710d02cd..de758f873b4736cdfb617d11fdb0d6f61e8f4a4d 100644\n+--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java\n++++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+@@ -376,7 +376,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+                     player.needsChunkCenterUpdate = false;\n+                     player.playerConnection.sendPacket(new PacketPlayOutViewCentre(currPosX, currPosZ));\n+                 }\n+-                PlayerChunkMap.this.sendChunk(player, new ChunkCoordIntPair(rangeX, rangeZ), new Packet[2], false, true); // unloaded, loaded\n++                PlayerChunkMap.this.sendChunk(player, new ChunkCoordIntPair(rangeX, rangeZ), new Packet[10], false, true); // unloaded, loaded\n+             },\n+             (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,\n+              com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {\n+@@ -1955,12 +1955,92 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+ \n+     }\n+ \n++    private static int getLightMask(final Chunk chunk) {\n++        final ChunkSection[] chunkSections = chunk.getSections();\n++        int mask = 0;\n++\n++        for (int i = 0; i < chunkSections.length; ++i) {\n++            mask |= (ChunkSection.a(chunkSections[i]) ? 0 : 7) << i; // ChunkSection.isEmpty", "originalCommit": "55e57c508842e4fec015989b5cf92bc55112e46a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4NTI3MQ==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r425685271", "bodyText": "Lightmasks have 18 bits, from the -1 (void) section until the 17th (air) section.\nSections go from 0..16. Now whenever a section is not empty, it can potentially change lighting for the section itself, the section below and the section above, hence the bitmask 111b, which is 7d.", "author": "MeFisto94", "createdAt": "2020-05-15T09:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1MzkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMjU3MQ==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r426022571", "bodyText": "I see\nInstead of commenting what the method is, we use obfhelpers (Like this https://github.com/PaperMC/Paper/blob/master/Spigot-Server-Patches/0004-MC-Utils.patch#L4241)", "author": "Spottedleaf", "createdAt": "2020-05-15T20:07:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1MzkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxNTM5MQ==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r426215391", "bodyText": "Added obf helper, and added comments made here about the 7 value.", "author": "aikar", "createdAt": "2020-05-17T04:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1MzkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU3MzI2Ng==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r425573266", "bodyText": "and this bithack is what? from my memory this looks like getHighestBit, but according to some documentation it appears getHighestBit is implemented differently...", "author": "Spottedleaf", "createdAt": "2020-05-15T05:26:28Z", "path": "Spigot-Server-Patches/0521-Workaround-for-Client-Lag-Spikes-MC-16225.patch", "diffHunk": "@@ -0,0 +1,132 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: MeFisto94 <MeFisto94@users.noreply.github.com>\n+Date: Tue, 12 May 2020 23:02:43 +0200\n+Subject: [PATCH] Workaround for Client Lag Spikes (MC-16225) When crossing\n+ certain chunk boundaries, the client needlessly calculates light maps for\n+ chunk neighbours. In some specific map configurations, these calculations\n+ cause a 500ms+ freeze on the Client. This patch basically serves as a\n+ workaround by sending light maps to the client, so that it doesn't attempt to\n+ calculate them. This mitigates the frametime impact to a minimum (but it's\n+ still there).\n+\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 8c1f3290d23795b58a30274c9437dc7dc43fa3a1..33cca62d90bf037df1b0b4e901baedb91400aee7 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -277,7 +277,7 @@ public class Chunk implements IChunkAccess {\n+ \n+                     // broadcast\n+                     Object[] backingSet = inRange.getBackingSet();\n+-                    Packet[] chunkPackets = new Packet[2];\n++                    Packet[] chunkPackets = new Packet[10];\n+                     for (int index = 0, len = backingSet.length; index < len; ++index) {\n+                         Object temp = backingSet[index];\n+                         if (!(temp instanceof EntityPlayer)) {\n+diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+index 81bb26abc520f49de2e916cf2757ac4c710d02cd..de758f873b4736cdfb617d11fdb0d6f61e8f4a4d 100644\n+--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java\n++++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+@@ -376,7 +376,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+                     player.needsChunkCenterUpdate = false;\n+                     player.playerConnection.sendPacket(new PacketPlayOutViewCentre(currPosX, currPosZ));\n+                 }\n+-                PlayerChunkMap.this.sendChunk(player, new ChunkCoordIntPair(rangeX, rangeZ), new Packet[2], false, true); // unloaded, loaded\n++                PlayerChunkMap.this.sendChunk(player, new ChunkCoordIntPair(rangeX, rangeZ), new Packet[10], false, true); // unloaded, loaded\n+             },\n+             (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,\n+              com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {\n+@@ -1955,12 +1955,92 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+ \n+     }\n+ \n++    private static int getLightMask(final Chunk chunk) {\n++        final ChunkSection[] chunkSections = chunk.getSections();\n++        int mask = 0;\n++\n++        for (int i = 0; i < chunkSections.length; ++i) {\n++            mask |= (ChunkSection.a(chunkSections[i]) ? 0 : 7) << i; // ChunkSection.isEmpty\n++        }\n++\n++        return mask;\n++    }\n++\n++    private static int getCeilingLightMask(final Chunk chunk) {\n++        int mask = getLightMask(chunk);\n++\n++        mask |= mask >> 1;", "originalCommit": "55e57c508842e4fec015989b5cf92bc55112e46a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4Nzg4MQ==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r425687881", "bodyText": "It is similar to get highest bit, it would turn an 001010 into an 001111 so basically the highest bit and all below.\nWe then invert this, so we'd have 110000 and compare that to the \"main\" chunk.\nThis is because the bug only appears when the current chunks lightmaps are higher than those of the neighbors, thus we can omit sending neighbors which are lower than the current chunks lights.\nso TLDR is that getCeilingLightMask returns a light mask with all bits set below the highest affected section. We could also count the number of leading zeros and invert them, somehow.", "author": "MeFisto94", "createdAt": "2020-05-15T09:43:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU3MzI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMTE0OA==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r426021148", "bodyText": "either use Integer#numberOfLeadingZeros or document what this bithack is supposed to be doing then", "author": "Spottedleaf", "createdAt": "2020-05-15T20:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU3MzI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxNTM3OQ==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r426215379", "bodyText": "I'm leaving these notes as a comment in the code, can maybe amend this in a future commit to use recommended strategy", "author": "aikar", "createdAt": "2020-05-17T04:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU3MzI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxOTYzOA==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r426219638", "bodyText": "public static long getMask(final long value) {\n    return ~(Long.MIN_VALUE >> (Long.numberOfLeadingZeros(value) - 1));\n}\n\nAlthough given we invert the mask later, could drop ~ from the function above and just not invert it later.", "author": "Spottedleaf", "createdAt": "2020-05-17T05:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU3MzI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU3MzM4OQ==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r425573389", "bodyText": "no diff should be here", "author": "Spottedleaf", "createdAt": "2020-05-15T05:26:55Z", "path": "Spigot-Server-Patches/0521-Workaround-for-Client-Lag-Spikes-MC-16225.patch", "diffHunk": "@@ -0,0 +1,132 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: MeFisto94 <MeFisto94@users.noreply.github.com>\n+Date: Tue, 12 May 2020 23:02:43 +0200\n+Subject: [PATCH] Workaround for Client Lag Spikes (MC-16225) When crossing\n+ certain chunk boundaries, the client needlessly calculates light maps for\n+ chunk neighbours. In some specific map configurations, these calculations\n+ cause a 500ms+ freeze on the Client. This patch basically serves as a\n+ workaround by sending light maps to the client, so that it doesn't attempt to\n+ calculate them. This mitigates the frametime impact to a minimum (but it's\n+ still there).\n+\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 8c1f3290d23795b58a30274c9437dc7dc43fa3a1..33cca62d90bf037df1b0b4e901baedb91400aee7 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -277,7 +277,7 @@ public class Chunk implements IChunkAccess {\n+ \n+                     // broadcast\n+                     Object[] backingSet = inRange.getBackingSet();\n+-                    Packet[] chunkPackets = new Packet[2];\n++                    Packet[] chunkPackets = new Packet[10];\n+                     for (int index = 0, len = backingSet.length; index < len; ++index) {\n+                         Object temp = backingSet[index];\n+                         if (!(temp instanceof EntityPlayer)) {\n+diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+index 81bb26abc520f49de2e916cf2757ac4c710d02cd..de758f873b4736cdfb617d11fdb0d6f61e8f4a4d 100644\n+--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java\n++++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+@@ -376,7 +376,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+                     player.needsChunkCenterUpdate = false;\n+                     player.playerConnection.sendPacket(new PacketPlayOutViewCentre(currPosX, currPosZ));\n+                 }\n+-                PlayerChunkMap.this.sendChunk(player, new ChunkCoordIntPair(rangeX, rangeZ), new Packet[2], false, true); // unloaded, loaded\n++                PlayerChunkMap.this.sendChunk(player, new ChunkCoordIntPair(rangeX, rangeZ), new Packet[10], false, true); // unloaded, loaded\n+             },\n+             (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,\n+              com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {\n+@@ -1955,12 +1955,92 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+ \n+     }\n+ \n++    private static int getLightMask(final Chunk chunk) {\n++        final ChunkSection[] chunkSections = chunk.getSections();\n++        int mask = 0;\n++\n++        for (int i = 0; i < chunkSections.length; ++i) {\n++            mask |= (ChunkSection.a(chunkSections[i]) ? 0 : 7) << i; // ChunkSection.isEmpty\n++        }\n++\n++        return mask;\n++    }\n++\n++    private static int getCeilingLightMask(final Chunk chunk) {\n++        int mask = getLightMask(chunk);\n++\n++        mask |= mask >> 1;\n++        mask |= mask >> 2;\n++        mask |= mask >> 4;\n++        mask |= mask >> 8;\n++        mask |= mask >> 16;\n++\n++        return mask;\n++    }\n++\n+     final void sendChunk(EntityPlayer entityplayer, Packet<?>[] apacket, Chunk chunk) { this.a(entityplayer, apacket, chunk); } // Paper - OBFHELPER\n+-    private void a(EntityPlayer entityplayer, Packet<?>[] apacket, Chunk chunk) {\n++    private void a(EntityPlayer entityplayer, Packet<?>[] apacket,  Chunk chunk) {", "originalCommit": "55e57c508842e4fec015989b5cf92bc55112e46a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4ODAxMQ==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r425688011", "bodyText": "yep, left over from testing, will be fixed.", "author": "MeFisto94", "createdAt": "2020-05-15T09:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU3MzM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxNTE3Mg==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r426215172", "bodyText": "handled", "author": "aikar", "createdAt": "2020-05-17T04:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU3MzM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMjc0OA==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r426022748", "bodyText": "needs paper comment", "author": "Spottedleaf", "createdAt": "2020-05-15T20:07:56Z", "path": "Spigot-Server-Patches/0521-Workaround-for-Client-Lag-Spikes-MC-16225.patch", "diffHunk": "@@ -0,0 +1,132 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: MeFisto94 <MeFisto94@users.noreply.github.com>\n+Date: Tue, 12 May 2020 23:02:43 +0200\n+Subject: [PATCH] Workaround for Client Lag Spikes (MC-16225) When crossing\n+ certain chunk boundaries, the client needlessly calculates light maps for\n+ chunk neighbours. In some specific map configurations, these calculations\n+ cause a 500ms+ freeze on the Client. This patch basically serves as a\n+ workaround by sending light maps to the client, so that it doesn't attempt to\n+ calculate them. This mitigates the frametime impact to a minimum (but it's\n+ still there).\n+\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 8c1f3290d23795b58a30274c9437dc7dc43fa3a1..33cca62d90bf037df1b0b4e901baedb91400aee7 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -277,7 +277,7 @@ public class Chunk implements IChunkAccess {\n+ \n+                     // broadcast\n+                     Object[] backingSet = inRange.getBackingSet();\n+-                    Packet[] chunkPackets = new Packet[2];", "originalCommit": "55e57c508842e4fec015989b5cf92bc55112e46a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxNDkzOA==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r426214938", "bodyText": "this was already paper code", "author": "aikar", "createdAt": "2020-05-17T04:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMjc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMzY5Nw==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r426023697", "bodyText": "these functions need to be enclosed with paper start and end", "author": "Spottedleaf", "createdAt": "2020-05-15T20:10:23Z", "path": "Spigot-Server-Patches/0521-Workaround-for-Client-Lag-Spikes-MC-16225.patch", "diffHunk": "@@ -0,0 +1,132 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: MeFisto94 <MeFisto94@users.noreply.github.com>\n+Date: Tue, 12 May 2020 23:02:43 +0200\n+Subject: [PATCH] Workaround for Client Lag Spikes (MC-16225) When crossing\n+ certain chunk boundaries, the client needlessly calculates light maps for\n+ chunk neighbours. In some specific map configurations, these calculations\n+ cause a 500ms+ freeze on the Client. This patch basically serves as a\n+ workaround by sending light maps to the client, so that it doesn't attempt to\n+ calculate them. This mitigates the frametime impact to a minimum (but it's\n+ still there).\n+\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 8c1f3290d23795b58a30274c9437dc7dc43fa3a1..33cca62d90bf037df1b0b4e901baedb91400aee7 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -277,7 +277,7 @@ public class Chunk implements IChunkAccess {\n+ \n+                     // broadcast\n+                     Object[] backingSet = inRange.getBackingSet();\n+-                    Packet[] chunkPackets = new Packet[2];\n++                    Packet[] chunkPackets = new Packet[10];\n+                     for (int index = 0, len = backingSet.length; index < len; ++index) {\n+                         Object temp = backingSet[index];\n+                         if (!(temp instanceof EntityPlayer)) {\n+diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+index 81bb26abc520f49de2e916cf2757ac4c710d02cd..de758f873b4736cdfb617d11fdb0d6f61e8f4a4d 100644\n+--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java\n++++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+@@ -376,7 +376,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+                     player.needsChunkCenterUpdate = false;\n+                     player.playerConnection.sendPacket(new PacketPlayOutViewCentre(currPosX, currPosZ));\n+                 }\n+-                PlayerChunkMap.this.sendChunk(player, new ChunkCoordIntPair(rangeX, rangeZ), new Packet[2], false, true); // unloaded, loaded\n++                PlayerChunkMap.this.sendChunk(player, new ChunkCoordIntPair(rangeX, rangeZ), new Packet[10], false, true); // unloaded, loaded\n+             },\n+             (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,\n+              com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {\n+@@ -1955,12 +1955,92 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+ \n+     }\n+ \n++    private static int getLightMask(final Chunk chunk) {", "originalCommit": "55e57c508842e4fec015989b5cf92bc55112e46a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxNTAzNA==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r426215034", "bodyText": "handling myself", "author": "aikar", "createdAt": "2020-05-17T04:10:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMzY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMzgwNg==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r426023806", "bodyText": "also needs paper comment", "author": "Spottedleaf", "createdAt": "2020-05-15T20:10:37Z", "path": "Spigot-Server-Patches/0521-Workaround-for-Client-Lag-Spikes-MC-16225.patch", "diffHunk": "@@ -0,0 +1,132 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: MeFisto94 <MeFisto94@users.noreply.github.com>\n+Date: Tue, 12 May 2020 23:02:43 +0200\n+Subject: [PATCH] Workaround for Client Lag Spikes (MC-16225) When crossing\n+ certain chunk boundaries, the client needlessly calculates light maps for\n+ chunk neighbours. In some specific map configurations, these calculations\n+ cause a 500ms+ freeze on the Client. This patch basically serves as a\n+ workaround by sending light maps to the client, so that it doesn't attempt to\n+ calculate them. This mitigates the frametime impact to a minimum (but it's\n+ still there).\n+\n+\n+diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java\n+index 8c1f3290d23795b58a30274c9437dc7dc43fa3a1..33cca62d90bf037df1b0b4e901baedb91400aee7 100644\n+--- a/src/main/java/net/minecraft/server/Chunk.java\n++++ b/src/main/java/net/minecraft/server/Chunk.java\n+@@ -277,7 +277,7 @@ public class Chunk implements IChunkAccess {\n+ \n+                     // broadcast\n+                     Object[] backingSet = inRange.getBackingSet();\n+-                    Packet[] chunkPackets = new Packet[2];\n++                    Packet[] chunkPackets = new Packet[10];\n+                     for (int index = 0, len = backingSet.length; index < len; ++index) {\n+                         Object temp = backingSet[index];\n+                         if (!(temp instanceof EntityPlayer)) {\n+diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+index 81bb26abc520f49de2e916cf2757ac4c710d02cd..de758f873b4736cdfb617d11fdb0d6f61e8f4a4d 100644\n+--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java\n++++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java\n+@@ -376,7 +376,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {\n+                     player.needsChunkCenterUpdate = false;\n+                     player.playerConnection.sendPacket(new PacketPlayOutViewCentre(currPosX, currPosZ));\n+                 }\n+-                PlayerChunkMap.this.sendChunk(player, new ChunkCoordIntPair(rangeX, rangeZ), new Packet[2], false, true); // unloaded, loaded\n++                PlayerChunkMap.this.sendChunk(player, new ChunkCoordIntPair(rangeX, rangeZ), new Packet[10], false, true); // unloaded, loaded", "originalCommit": "55e57c508842e4fec015989b5cf92bc55112e46a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxNTA2NA==", "url": "https://github.com/PaperMC/Paper/pull/3360#discussion_r426215064", "bodyText": "was already paper code", "author": "aikar", "createdAt": "2020-05-17T04:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMzgwNg=="}], "type": "inlineReview"}, {"oid": "72f89a076aa56a6f60cdda354e7ac5eb324daed7", "url": "https://github.com/PaperMC/Paper/commit/72f89a076aa56a6f60cdda354e7ac5eb324daed7", "message": "Workaround for Client Lag Spikes (MC-162253)\n\nWhen crossing certain chunk boundaries, the client needlessly\ncalculates light maps for chunk neighbours. In some specific map\nconfigurations, these calculations cause a 500ms+ freeze on the Client.\n\nThis patch basically serves as a workaround by sending light maps\nto the client, so that it doesn't attempt to calculate them.\nThis mitigates the frametime impact to a minimum (but it's still there).", "committedDate": "2020-05-17T04:21:42Z", "type": "commit"}, {"oid": "72f89a076aa56a6f60cdda354e7ac5eb324daed7", "url": "https://github.com/PaperMC/Paper/commit/72f89a076aa56a6f60cdda354e7ac5eb324daed7", "message": "Workaround for Client Lag Spikes (MC-162253)\n\nWhen crossing certain chunk boundaries, the client needlessly\ncalculates light maps for chunk neighbours. In some specific map\nconfigurations, these calculations cause a 500ms+ freeze on the Client.\n\nThis patch basically serves as a workaround by sending light maps\nto the client, so that it doesn't attempt to calculate them.\nThis mitigates the frametime impact to a minimum (but it's still there).", "committedDate": "2020-05-17T04:21:42Z", "type": "forcePushed"}]}