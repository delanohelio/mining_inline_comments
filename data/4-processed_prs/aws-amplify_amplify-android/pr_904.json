{"pr_number": 904, "pr_title": "feature: resolve conflicts according to strategies", "pr_createdAt": "2020-10-14T09:23:06Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/904", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU5MzMzOA==", "url": "https://github.com/aws-amplify/amplify-android/pull/904#discussion_r505593338", "bodyText": "There's the possibility here for a user key to conflict with a metadata key. Are we making it clear to the user somewhere what these reserved metadata keys are so they don't accidentally make a property with the same name?", "author": "TrekSoft", "createdAt": "2020-10-15T14:34:02Z", "path": "aws-api-appsync/src/main/java/com/amplifyframework/datastore/appsync/ModelWithMetadataAdapter.java", "diffHunk": "@@ -58,4 +64,24 @@ public static void register(@NonNull GsonBuilder builder) {\n         ModelMetadata metadata = context.deserialize(json, ModelMetadata.class);\n         return new ModelWithMetadata<>(model, metadata);\n     }\n+\n+    @Override\n+    public JsonElement serialize(\n+            ModelWithMetadata<? extends Model> src, Type typeOfSrc, JsonSerializationContext context) {\n+        JsonObject result = new JsonObject();\n+\n+        // Flatten out the fields of the model and its metadata into a flat key-value map.\n+        // To do this, serialize each individually, and then add the key/value pairs for each\n+        // object into a new container.\n+        JsonObject serializedMetadata = (JsonObject) context.serialize(src.getSyncMetadata());\n+        for (Map.Entry<java.lang.String, JsonElement> entry : serializedMetadata.entrySet()) {\n+            result.add(entry.getKey(), entry.getValue());\n+        }\n+        JsonObject serializedModel = (JsonObject) context.serialize(src.getModel());\n+        for (Map.Entry<java.lang.String, JsonElement> entry : serializedModel.entrySet()) {\n+            result.add(entry.getKey(), entry.getValue());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc0MDIzNw==", "url": "https://github.com/aws-amplify/amplify-android/pull/904#discussion_r505740237", "bodyText": "This is true! But, I think the conflict happens earlier in the system, than this point. By this point, we're already operating on a model that was generated by the CLI. So, the conflict would have been caught there.\nI did a quick audit of where/how these fields are mentioned, and I agree it could use improvement.\nAppSync & the CLI automatically include a range of fields. Some are prefixed with _ (e.g., _lastChangedAt, _deleted, _version), while others are not (updatedAt, createdAt.)\nWe have a few pieces of existing documentation about this:\nIn the GraphQL Directive usage:\n\nModel directive automatically adds createdAt and updatedAt timestamps to each entities.\n\n_lastChangedAt, _version, and _deleted are mentioned in a few places in the documentation, however, not explicitly as reserved words in the GraphQL schema that the user provides.\n\nDataStore \"How it works\" Guide to using the AppSync Console\nAppSync schema requirements for using versioned versioned data", "author": "jamesonwilliams", "createdAt": "2020-10-15T18:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU5MzMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMDQzOQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/904#discussion_r505610439", "bodyText": "Would it make sense to have the inverse of this, alwaysApplyLocal()?", "author": "TrekSoft", "createdAt": "2020-10-15T14:55:45Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/DataStoreConflictHandler.java", "diffHunk": "@@ -16,23 +16,288 @@\n package com.amplifyframework.datastore;\n \n import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.core.util.ObjectsCompat;\n \n import com.amplifyframework.core.Consumer;\n import com.amplifyframework.core.model.Model;\n \n+import java.util.Objects;\n+\n /**\n- * Handles conflicts between models observed during model synchronization in the DataStore.\n- * Such conflicts may arise between version of models kept locally, and competing versions\n- * found in the remote AppSync system.\n+ * A hook to handle a conflict between local and remote copies of a model.\n+ * The DataStore customer can implement their own version of this handler,\n+ * and provide that handler to the {@link DataStoreConfiguration} while constructing\n+ * the DataStore plugin using\n+ * {@link AWSDataStorePlugin#AWSDataStorePlugin(DataStoreConfiguration)}.\n  */\n public interface DataStoreConflictHandler {\n     /**\n-     * Resolves a DataStore conflict.\n-     * @param conflictData Data about the conflict.\n-     * @param onResult A callback that should be invoked when the conflict handling is complete.\n-     * @param <T> The type of model for which a conflict was observed\n+     * Factory to obtain a handler that always applies the remote copy\n+     * of the data.\n+     * @return A DataStore conflict handler that always applies the remote\n+     *         copy of the data.\n+     */\n+    static DataStoreConflictHandler alwaysApplyRemote() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMTQxOA==", "url": "https://github.com/aws-amplify/amplify-android/pull/904#discussion_r505611418", "bodyText": "Or is that what alwaysRetryLocal() does except that it won't apply if there is a new conflict since receiving the last one? If so, we may need to make that clearer.", "author": "TrekSoft", "createdAt": "2020-10-15T14:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMDQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc0MjY1OA==", "url": "https://github.com/aws-amplify/amplify-android/pull/904#discussion_r505742658", "bodyText": "There was a lot of deliberation on the naming back in April/May when iOS implemented this functionality. At this point, I'm just aligning to the other platforms.\nThe key difference is that \"apply remote\" just patches the local data, but doesn't talk to AppSync again. On the other hand, \"retry local\" will attempt another mutation, using the server's _version, but with the local data. If that mutation fails, the overall transaction fails.\n^ Maybe we can get this explanation into the docs site, somewhere.", "author": "jamesonwilliams", "createdAt": "2020-10-15T18:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMDQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzMjk5NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/904#discussion_r505632994", "bodyText": "It looks like this is done in all three cases below - don't understand the first part of the comment.", "author": "TrekSoft", "createdAt": "2020-10-15T15:23:39Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/ConflictResolver.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.datastore.DataStoreConfiguration;\n+import com.amplifyframework.datastore.DataStoreConfigurationProvider;\n+import com.amplifyframework.datastore.DataStoreConflictHandler;\n+import com.amplifyframework.datastore.DataStoreConflictHandler.ConflictData;\n+import com.amplifyframework.datastore.DataStoreConflictHandler.ConflictResolutionDecision;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.appsync.AppSync;\n+import com.amplifyframework.datastore.appsync.AppSyncConflictUnhandledError;\n+import com.amplifyframework.datastore.appsync.ModelMetadata;\n+import com.amplifyframework.datastore.appsync.ModelWithMetadata;\n+\n+import io.reactivex.rxjava3.core.Single;\n+\n+/**\n+ * ConflictResolver is a helper utility for the {@link MutationProcessor}.\n+ * It is built specifically to handle ConflictUnhandledError that may be\n+ * returned when the {@link MutationProcessor} attempts to publish\n+ * local data up to AppSync.\n+ *\n+ * ConflictResolver's primary entry point is the\n+ * {@link ConflictResolver#resolve(PendingMutation, AppSyncConflictUnhandledError)}.\n+ * This method will try to rectify state with AppSync by applying the conflict handler\n+ * in the {@link DataStoreConfigurationProvider#getConfiguration()}.\n+ *\n+ * The ConflictResolver will return a {@link ModelWithMetadata} that is understood\n+ * to be the final, resolved version of the data, to which both the server and local\n+ * database should agree.\n+ *\n+ * After {@link ConflictResolver#resolve(PendingMutation, AppSyncConflictUnhandledError)}\n+ * is invoked by the MutationProcessor, the MutationProcessor must merge the returned\n+ * {@link ModelWithMetadata} into the local store, unconditionally.\n+ */\n+final class ConflictResolver {\n+    private final DataStoreConfigurationProvider configurationProvider;\n+    private final AppSync appSync;\n+\n+    ConflictResolver(DataStoreConfigurationProvider configurationProvider, AppSync appSync) {\n+        this.configurationProvider = configurationProvider;\n+        this.appSync = appSync;\n+    }\n+\n+    @NonNull\n+    <T extends Model> Single<ModelWithMetadata<T>> resolve(\n+            @NonNull PendingMutation<T> pendingMutation,\n+            @NonNull AppSyncConflictUnhandledError<T> conflictUnhandledError) {\n+        final DataStoreConflictHandler conflictHandler;\n+        try {\n+            DataStoreConfiguration configuration = configurationProvider.getConfiguration();\n+            conflictHandler = configuration.getDataStoreConflictHandler();\n+        } catch (DataStoreException badConfigurationProvider) {\n+            return Single.error(badConfigurationProvider);\n+        }\n+\n+        ModelWithMetadata<T> serverData = conflictUnhandledError.getServerVersion();\n+        ModelMetadata metadata = serverData.getSyncMetadata();\n+        T remote = serverData.getModel();\n+        T local = pendingMutation.getMutatedItem();\n+        ConflictData<T> conflictData = ConflictData.create(local, remote);\n+\n+        return Single\n+            .<ConflictResolutionDecision<? extends Model>>create(emitter ->\n+                conflictHandler.onConflictDetected(conflictData, emitter::onSuccess)\n+            )\n+            .flatMap(decision -> {\n+                @SuppressWarnings(\"unchecked\")\n+                ConflictResolutionDecision<T> typedDecision = (ConflictResolutionDecision<T>) decision;\n+                return resolveModelAndMetadata(conflictData, metadata, typedDecision);\n+            });\n+    }\n+\n+    @NonNull\n+    private <T extends Model> Single<ModelWithMetadata<T>> resolveModelAndMetadata(\n+            @NonNull ConflictData<T> conflictData,\n+            @NonNull ModelMetadata metadata,\n+            @NonNull ConflictResolutionDecision<T> decision) {\n+        // If the strategy is apply remote or retry local, we already know the version we'll use.\n+        // We simply extract it from the conflict data.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc0MzM5MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/904#discussion_r505743390", "bodyText": "Good call! This comment looks like a stray. I'll remote it.", "author": "jamesonwilliams", "createdAt": "2020-10-15T18:12:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzMjk5NA=="}], "type": "inlineReview"}, {"oid": "b9535aa4958a6858bc3a384cdfe2fcb301811fc9", "url": "https://github.com/aws-amplify/amplify-android/commit/b9535aa4958a6858bc3a384cdfe2fcb301811fc9", "message": "feature: resolve conflicts according to strategies\n\nThe DataStore's sync engine will periodically try to publish local\nchanges up to AppSync. If AppSync already has a copy of the model\ninstance, a versioning conflict may occur. In this case, AppSync may\nreturn a `ConflictUnhandledError` to the client, in the GraphQL response\nerror list.\n\nAs a customer, you can supply a handler to define custom logic when such\na conflict occurs. To do so, you provide a `DataStoreConflictHandler` to\nthe `DataStoreConfiguration` when constructing the `AWSDataStorePlugin`:\n\n```java\nDataStoreConfiguration config = DataStoreConfiguration.builder()\n    .dataStoreConflictHandler(DataStoreConflictHandler.alwaysApplyRemote())\n    .build();\nAmplify.addPlugin(new AWSDataStorePlugin(config));\n```\n\nThe ultimate goal of the user-provided handler will be to identify a\n`ConflictResolutionDecision`, to be used to address the conflict:\n\n1. `ConflictResolutionDecision.applyRemote()`:\n   Just accept the remote copy of the data, and overwrite whatever we\n   have locally\n2. `ConflictResolutionDecision.retryLocal()`:\n   Try to publish the local mutation again. If it fails a second time,\n   surface an error, and do not rety additional times.\n3. `ConflictResolutionDecision.retry(T userProvidedModel)`:\n   Try to publish a new version of the model up to AppSync.\n   If using this decision, please take care to ensure the model ID\n   matches the ID of the data in conflict.\n\nIn the above configuration example, the\n`DataStoreConflictHandler.alwaysApplyRemote()` configures a handler that\nalways chosen to accept the server's version of the data. A similar\n`DataStoreConfigurationHandler.alwaysRetryLocal()` is also provided for\nconvenience. Fully-custom handlers may be provided as well, by\nimplementing the `DataSToreConfigurationHandler` interface's single\nmethod, `onConflictDetected`.\n\nOnce you have elected a strategy in the handler, the DataStore's sync\nengine will take over and fulfill the strategy you've requested. Prior\nto the current commit, the conflict handler didn't actually do anything\non your behalf -- you were expected to code all resolution logic\ndirectly in your handler. This is no longer necessary.\n\nResolves: https://github.com/aws-amplify/amplify-android/issues/841", "committedDate": "2020-10-15T18:34:18Z", "type": "commit"}, {"oid": "b9535aa4958a6858bc3a384cdfe2fcb301811fc9", "url": "https://github.com/aws-amplify/amplify-android/commit/b9535aa4958a6858bc3a384cdfe2fcb301811fc9", "message": "feature: resolve conflicts according to strategies\n\nThe DataStore's sync engine will periodically try to publish local\nchanges up to AppSync. If AppSync already has a copy of the model\ninstance, a versioning conflict may occur. In this case, AppSync may\nreturn a `ConflictUnhandledError` to the client, in the GraphQL response\nerror list.\n\nAs a customer, you can supply a handler to define custom logic when such\na conflict occurs. To do so, you provide a `DataStoreConflictHandler` to\nthe `DataStoreConfiguration` when constructing the `AWSDataStorePlugin`:\n\n```java\nDataStoreConfiguration config = DataStoreConfiguration.builder()\n    .dataStoreConflictHandler(DataStoreConflictHandler.alwaysApplyRemote())\n    .build();\nAmplify.addPlugin(new AWSDataStorePlugin(config));\n```\n\nThe ultimate goal of the user-provided handler will be to identify a\n`ConflictResolutionDecision`, to be used to address the conflict:\n\n1. `ConflictResolutionDecision.applyRemote()`:\n   Just accept the remote copy of the data, and overwrite whatever we\n   have locally\n2. `ConflictResolutionDecision.retryLocal()`:\n   Try to publish the local mutation again. If it fails a second time,\n   surface an error, and do not rety additional times.\n3. `ConflictResolutionDecision.retry(T userProvidedModel)`:\n   Try to publish a new version of the model up to AppSync.\n   If using this decision, please take care to ensure the model ID\n   matches the ID of the data in conflict.\n\nIn the above configuration example, the\n`DataStoreConflictHandler.alwaysApplyRemote()` configures a handler that\nalways chosen to accept the server's version of the data. A similar\n`DataStoreConfigurationHandler.alwaysRetryLocal()` is also provided for\nconvenience. Fully-custom handlers may be provided as well, by\nimplementing the `DataSToreConfigurationHandler` interface's single\nmethod, `onConflictDetected`.\n\nOnce you have elected a strategy in the handler, the DataStore's sync\nengine will take over and fulfill the strategy you've requested. Prior\nto the current commit, the conflict handler didn't actually do anything\non your behalf -- you were expected to code all resolution logic\ndirectly in your handler. This is no longer necessary.\n\nResolves: https://github.com/aws-amplify/amplify-android/issues/841", "committedDate": "2020-10-15T18:34:18Z", "type": "forcePushed"}]}