{"pr_number": 876, "pr_title": "fix(datastore):Prevent concurrent start/stop on orchestrator", "pr_createdAt": "2020-10-02T02:47:52Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/876", "timeline": [{"oid": "1d5df843d3748b3cc67efc079a87af86b8bbe4b1", "url": "https://github.com/aws-amplify/amplify-android/commit/1d5df843d3748b3cc67efc079a87af86b8bbe4b1", "message": "fix(datastore):Prevent concurrent start/stop on orchestrator", "committedDate": "2020-10-02T02:43:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyNzYzNw==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r498627637", "bodyText": "Given that you generally want calls to stop to be terminal maybe use acquire so calling thread blocks or tryAcquire with timeout for a softer approach?", "author": "saltonmassally", "createdAt": "2020-10-02T05:51:46Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -180,9 +189,16 @@ private Completable transitionCompletable() {\n      */\n     public Completable stop() {\n         LOG.info(\"DataStore orchestrator stopping. Current mode = \" + currentMode.get().name());\n+        if (!startStopSemaphore.tryAcquire()) {", "originalCommit": "1d5df843d3748b3cc67efc079a87af86b8bbe4b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgzNDA5MQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r498834091", "bodyText": "That's a good point. The only place where stop is called in a meaningful way is during a call to DataStore.clear. We'd want to block in that case, so I just went with the acquire option.", "author": "rjuliano", "createdAt": "2020-10-02T13:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyNzYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMDY4OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r500520689", "bodyText": "Thanks again for taking a look. I have refactored this to include a timeout.", "author": "rjuliano", "createdAt": "2020-10-06T18:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyNzYzNw=="}], "type": "inlineReview"}, {"oid": "b0ff24dddc6958027a5ebdce04b23069d43b5cd5", "url": "https://github.com/aws-amplify/amplify-android/commit/b0ff24dddc6958027a5ebdce04b23069d43b5cd5", "message": "Modify lock around stop operation", "committedDate": "2020-10-02T13:49:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NTI3NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r498995274", "bodyText": "We'll end up seeing this message from the returned exception, so there's probably no benefit to printing it immediately, too.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOG.warn(\"Unable to acquire orchestrator lock. Transition currently in progress.\");", "author": "jamesonwilliams", "createdAt": "2020-10-02T18:52:06Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -180,9 +189,20 @@ private Completable transitionCompletable() {\n      */\n     public Completable stop() {\n         LOG.info(\"DataStore orchestrator stopping. Current mode = \" + currentMode.get().name());\n+        try {\n+            startStopSemaphore.acquire();\n+\n+        } catch (InterruptedException exception) {\n+            LOG.warn(\"Unable to acquire orchestrator lock. Transition currently in progress.\");", "originalCommit": "b0ff24dddc6958027a5ebdce04b23069d43b5cd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NjUwMA==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r498996500", "bodyText": "I'm deliberating between whether this should be acquire() or tryAcquire(). Currently, I guess this will complete with error on subsequent invocations? Does the consuming code handle that gracefully?\nIf we did use acquire(), we'd just want to ensure that this completable chain has some kind of a timeout on it, somewhere (if not directly as arguments to the .acquire(timeout, ...), then elsewhere in the chain.)", "author": "jamesonwilliams", "createdAt": "2020-10-02T18:54:42Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -135,10 +138,16 @@ public boolean isStopped() {\n      * Start performing sync operations between the local storage adapter\n      * and the remote GraphQL endpoint.\n      */\n-    public void start() {\n+    public synchronized void start() {\n+        LOG.debug(\"Available permits = \" + startStopSemaphore.availablePermits());\n+        if (!startStopSemaphore.tryAcquire()) {", "originalCommit": "b0ff24dddc6958027a5ebdce04b23069d43b5cd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyMzIyNA==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r499123224", "bodyText": "The problem with using acquire is that CRUD operations will then block in beforeOperation as threads wait which can have a cascading effect.", "author": "saltonmassally", "createdAt": "2020-10-03T07:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NjUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5MzMwOA==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r499793308", "bodyText": "Correct. I arrived at the conclusion (I think) that the timeout behavior is dependent upon where the start method is being called from.\n\nIf it's from the initialize or clear methods, we can use the default timeout of 10 seconds. These are \"special\" calls and we're willing to wait as long as possible.\nIf it's from beforeOperation, we should use no timeout. That means it should fail right away if there is a transition in progress. We should throw an exception if the orchestrator is still going from STOPPED to LOCAL_ONLY; if it's transitioning between LOCAL_ONLY and SYNC_VIA API, we allow the call to proceed because we know the storage observer is already started.", "author": "rjuliano", "createdAt": "2020-10-05T18:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NjUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyNTY3Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r500525676", "bodyText": "To build on my last comment, I ended up changing the start method(s) on the orchestrator to return a Completable. This gives the calling more control over timeout and blocking vs non-blocking.\nAs a result of this change, the logic to trigger the DataStore's READY event is now triggered from the plugin instead of the orchestrator, which seems appropriate.", "author": "rjuliano", "createdAt": "2020-10-06T18:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NjUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyNTQxNg==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r502025416", "bodyText": "I removed the overloads that had timeouts since I was able to achieve the same result by re-working the construction of the completable.", "author": "rjuliano", "createdAt": "2020-10-08T21:33:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NjUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NzI0Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r498997242", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Completable stop() {\n          \n          \n            \n                public synchronized Completable stop() {", "author": "jamesonwilliams", "createdAt": "2020-10-02T18:56:15Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -180,9 +189,20 @@ private Completable transitionCompletable() {\n      */\n     public Completable stop() {", "originalCommit": "b0ff24dddc6958027a5ebdce04b23069d43b5cd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NzYyMw==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r498997623", "bodyText": "Does this have the potential to hang indefinitely? Should we add timeout arguments?", "author": "jamesonwilliams", "createdAt": "2020-10-02T18:57:05Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -180,9 +189,20 @@ private Completable transitionCompletable() {\n      */\n     public Completable stop() {\n         LOG.info(\"DataStore orchestrator stopping. Current mode = \" + currentMode.get().name());\n+        try {\n+            startStopSemaphore.acquire();", "originalCommit": "b0ff24dddc6958027a5ebdce04b23069d43b5cd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MDQ1Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r499060452", "bodyText": "Yup...I went ahead and added a timeout to this one.", "author": "rjuliano", "createdAt": "2020-10-02T21:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NzYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwMDQxNQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r499000415", "bodyText": "AppSyncMocking lives in com.amplifyframework.datastore.appsync since the AppSync interface does. Your new ApiMocking might be a testutility, since it mocks a core spec (the ApiCategoryBehavior.) In this view, it could live somewhere under testutils/src/main/java/com/amplifyframework/testutils. I don't feel 100% resolved in this, though. What do you think?", "author": "jamesonwilliams", "createdAt": "2020-10-02T19:03:28Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/ApiMocking.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;", "originalCommit": "b0ff24dddc6958027a5ebdce04b23069d43b5cd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MTA0Mw==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r499061043", "bodyText": "I think it makes sense. I thought about doing that and ended up not doing so (again, left brain not listening to right brain \ud83e\udd23 )", "author": "rjuliano", "createdAt": "2020-10-02T21:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwMDQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwMDgzMA==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r499000830", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                private ApiMocking(){\n          \n          \n            \n            \n          \n          \n            \n                }\n          \n          \n            \n                private ApiMocking() {}", "author": "jamesonwilliams", "createdAt": "2020-10-02T19:04:33Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/ApiMocking.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import com.amplifyframework.api.graphql.GraphQLBehavior;\n+import com.amplifyframework.api.graphql.GraphQLRequest;\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.api.graphql.PaginatedResult;\n+import com.amplifyframework.core.Consumer;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.temporal.Temporal;\n+import com.amplifyframework.testutils.random.RandomString;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.mockito.ArgumentMatcher;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import io.reactivex.rxjava3.core.Observable;\n+\n+import static org.junit.Assert.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.doAnswer;\n+\n+/**\n+ * Utility to mock behaviors of the API category.\n+ */\n+public final class ApiMocking {\n+\n+    private ApiMocking(){\n+\n+    }", "originalCommit": "b0ff24dddc6958027a5ebdce04b23069d43b5cd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwMTc5Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r499001797", "bodyText": "This method name is leaking an abstraction, I think. The API category doesn't know about \"sync\"ing, that's a datastore thing. However, the class is called ApiMocking. To stay pure to its charter, this should probably not mention \"sync\" anywhere, just \"query.\"\nAlso, since ModelWithMetadata is essentially a DataStore detail, I would pull that out of the implementation as well. Instead, you could provide them at the call site:\npublic static <T> void mockSuccessfulSyncQuery(GraphQLBehavior mockApi, T... results) {\n    ...\n    // Implementation no longer mentions ModelWithMetadata either\n    onResults.accept(new GraphQLResponse<PaginatedResult<T>>(\n                new PaginatedResult<T>(syncQueryResults, null));\n    ...\n}", "author": "jamesonwilliams", "createdAt": "2020-10-02T19:06:41Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/ApiMocking.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import com.amplifyframework.api.graphql.GraphQLBehavior;\n+import com.amplifyframework.api.graphql.GraphQLRequest;\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.api.graphql.PaginatedResult;\n+import com.amplifyframework.core.Consumer;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.temporal.Temporal;\n+import com.amplifyframework.testutils.random.RandomString;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.mockito.ArgumentMatcher;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import io.reactivex.rxjava3.core.Observable;\n+\n+import static org.junit.Assert.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.doAnswer;\n+\n+/**\n+ * Utility to mock behaviors of the API category.\n+ */\n+public final class ApiMocking {\n+\n+    private ApiMocking(){\n+\n+    }\n+\n+    /**\n+     * Mock successful subscription start calls.\n+     * @param mockApi Mock object of type {@link GraphQLBehavior}\n+     */\n+    public static void mockSubscriptionStart(GraphQLBehavior mockApi) {\n+        doAnswer(invocation -> {\n+            final int indexOfOnStart = 1;\n+            Consumer<String> onStart = invocation.getArgument(indexOfOnStart);\n+            onStart.accept(RandomString.string());\n+            return null;\n+        }).when(mockApi).subscribe(\n+            any(), // Class<T>\n+            any(), // Consumer<String>, onStart\n+            any(), // Consumer<GraphQLResponse<ModelWithMetadata<T>>>, onNextResponse\n+            any(), // Consumer<DataStoreException>, onSubscriptionFailure\n+            any() // Action, onSubscriptionCompleted\n+        );\n+    }\n+\n+    /**\n+     * Mock a successful mutation call made for a given model.\n+     * @param mockApi Mock object of type {@link GraphQLBehavior}\n+     * @param model The model for the mutation operation.\n+     * @param <M> The model type.\n+     */\n+    public static <M extends Model> void mockSuccessfulMutation(GraphQLBehavior mockApi, M model) {\n+        doAnswer(invocation -> {\n+            // Simulate a successful response callback from the create() method.\n+            final int indexOfModelBeingCreated = 0;\n+            final int indexOfResultConsumer = 1;\n+            GraphQLRequest<M> request = invocation.getArgument(indexOfModelBeingCreated);\n+\n+            // Pass back a ModelWithMetadata. Model is the one provided.\n+            ModelMetadata metadata =\n+                new ModelMetadata(model.getId(), false, 1, new Temporal.Timestamp());\n+            ModelWithMetadata<M> modelWithMetadata = new ModelWithMetadata<>(model, metadata);\n+            Consumer<GraphQLResponse<ModelWithMetadata<M>>> onResult =\n+                invocation.getArgument(indexOfResultConsumer);\n+            onResult.accept(new GraphQLResponse<>(modelWithMetadata, Collections.emptyList()));\n+\n+            // Technically, create() returns a Cancelable...\n+            return null;\n+        }).when(mockApi).mutate(\n+            argThat(getMatcherFor(model)), // Match the id of the model passed in to the function.\n+            any(), // onResponse\n+            any() // onFailure\n+        );\n+    }\n+\n+    /**\n+     * Mock the results of successful query operation triggered by the DataStore.\n+     * @param mockApi Mock object of type {@link GraphQLBehavior}\n+     * @param models A list of models to be returned in the result.\n+     * @param <M> The model type.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <M extends Model> void mockSuccessfulSyncQuery(GraphQLBehavior mockApi, M... models) {", "originalCommit": "b0ff24dddc6958027a5ebdce04b23069d43b5cd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MTQ1NQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r499061455", "bodyText": "Good call on this one. I'll update it.", "author": "rjuliano", "createdAt": "2020-10-02T21:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwMTc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwMzQ5NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r499003494", "bodyText": "Maybe just take the model ID as an arg, and rename it to:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static <M extends Model> ArgumentMatcher<GraphQLRequest<M>> getMatcherFor(M model) {\n          \n          \n            \n                private static <M extends Model> ArgumentMatcher<GraphQLRequest<M>> requestContainsModelId(String modelId) {", "author": "jamesonwilliams", "createdAt": "2020-10-02T19:10:49Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/ApiMocking.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import com.amplifyframework.api.graphql.GraphQLBehavior;\n+import com.amplifyframework.api.graphql.GraphQLRequest;\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.api.graphql.PaginatedResult;\n+import com.amplifyframework.core.Consumer;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.temporal.Temporal;\n+import com.amplifyframework.testutils.random.RandomString;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.mockito.ArgumentMatcher;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import io.reactivex.rxjava3.core.Observable;\n+\n+import static org.junit.Assert.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.doAnswer;\n+\n+/**\n+ * Utility to mock behaviors of the API category.\n+ */\n+public final class ApiMocking {\n+\n+    private ApiMocking(){\n+\n+    }\n+\n+    /**\n+     * Mock successful subscription start calls.\n+     * @param mockApi Mock object of type {@link GraphQLBehavior}\n+     */\n+    public static void mockSubscriptionStart(GraphQLBehavior mockApi) {\n+        doAnswer(invocation -> {\n+            final int indexOfOnStart = 1;\n+            Consumer<String> onStart = invocation.getArgument(indexOfOnStart);\n+            onStart.accept(RandomString.string());\n+            return null;\n+        }).when(mockApi).subscribe(\n+            any(), // Class<T>\n+            any(), // Consumer<String>, onStart\n+            any(), // Consumer<GraphQLResponse<ModelWithMetadata<T>>>, onNextResponse\n+            any(), // Consumer<DataStoreException>, onSubscriptionFailure\n+            any() // Action, onSubscriptionCompleted\n+        );\n+    }\n+\n+    /**\n+     * Mock a successful mutation call made for a given model.\n+     * @param mockApi Mock object of type {@link GraphQLBehavior}\n+     * @param model The model for the mutation operation.\n+     * @param <M> The model type.\n+     */\n+    public static <M extends Model> void mockSuccessfulMutation(GraphQLBehavior mockApi, M model) {\n+        doAnswer(invocation -> {\n+            // Simulate a successful response callback from the create() method.\n+            final int indexOfModelBeingCreated = 0;\n+            final int indexOfResultConsumer = 1;\n+            GraphQLRequest<M> request = invocation.getArgument(indexOfModelBeingCreated);\n+\n+            // Pass back a ModelWithMetadata. Model is the one provided.\n+            ModelMetadata metadata =\n+                new ModelMetadata(model.getId(), false, 1, new Temporal.Timestamp());\n+            ModelWithMetadata<M> modelWithMetadata = new ModelWithMetadata<>(model, metadata);\n+            Consumer<GraphQLResponse<ModelWithMetadata<M>>> onResult =\n+                invocation.getArgument(indexOfResultConsumer);\n+            onResult.accept(new GraphQLResponse<>(modelWithMetadata, Collections.emptyList()));\n+\n+            // Technically, create() returns a Cancelable...\n+            return null;\n+        }).when(mockApi).mutate(\n+            argThat(getMatcherFor(model)), // Match the id of the model passed in to the function.\n+            any(), // onResponse\n+            any() // onFailure\n+        );\n+    }\n+\n+    /**\n+     * Mock the results of successful query operation triggered by the DataStore.\n+     * @param mockApi Mock object of type {@link GraphQLBehavior}\n+     * @param models A list of models to be returned in the result.\n+     * @param <M> The model type.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <M extends Model> void mockSuccessfulSyncQuery(GraphQLBehavior mockApi, M... models) {\n+        doAnswer(invocation -> {\n+            final int onResultsIndex = 1;\n+            // Transform from an array of Model types to, to a list of ModelWithMetadata<M extends Model>\n+            List<ModelWithMetadata<M>> syncQueryResults =\n+                Observable.fromArray(models)\n+                          .map(model -> {\n+                              ModelMetadata metadata = new ModelMetadata(model.getId(),\n+                                                                         false,\n+                                                                         1,\n+                                                                         Temporal.Timestamp.now());\n+                              ModelWithMetadata<M> modelWithMetadata = new ModelWithMetadata<>(model, metadata);\n+                              return modelWithMetadata;\n+                          })\n+                          .toList()\n+                          .blockingGet();\n+\n+            // The callback function to be invoked with the results\n+            Consumer<GraphQLResponse<PaginatedResult<ModelWithMetadata<M>>>> onResults =\n+                invocation.getArgument(onResultsIndex);\n+            onResults.accept(new GraphQLResponse<PaginatedResult<ModelWithMetadata<M>>>(\n+                new PaginatedResult<ModelWithMetadata<M>>(syncQueryResults, null),\n+                Collections.emptyList()\n+            ));\n+            return null;\n+        }).when(mockApi).query(\n+            any(), // Request\n+            any(), // onResponse\n+            any()  // onFailure\n+        );\n+    }\n+\n+    private static <M extends Model> ArgumentMatcher<GraphQLRequest<M>> getMatcherFor(M model) {", "originalCommit": "b0ff24dddc6958027a5ebdce04b23069d43b5cd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwNTE3Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r499005172", "bodyText": "I forget exactly why I went with the static methods in the AppSyncMocking util. I think my goal was to get something that looked like Mockito:\nonCreate(appSync).callOnStart();\nIn hind-sight, it might have been a better design to create an object instance that encapsulated the appSync instance.\nOr, in other words, what if your utility worked like:\nApiMocking mocking = new ApiMocking(mock(GraphQLBehavior.class));\nOr even  just:\n// internally, encapsulates a `Mockito.mock(GraphQLBehavior.class)`\nMockGraphQLApi api = new MockGraphQLApi();", "author": "jamesonwilliams", "createdAt": "2020-10-02T19:14:49Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/OrchestratorTest.java", "diffHunk": "@@ -70,19 +73,18 @@ public void itemsPlacedInStorageArePublishedToNetwork() throws AmplifyException\n             .name(\"Susan Quimby\")\n             .build();\n \n-        HubAccumulator accumulator =\n-            HubAccumulator.create(HubChannel.DATASTORE, publicationOf(susan), 1)\n+        HubAccumulator orchestratorInitObserver =\n+            HubAccumulator.create(HubChannel.DATASTORE, DataStoreChannelEventName.READY, 1)\n                 .start();\n \n-        // Mock behaviors from AppSync\n-        AppSync appSync = mock(AppSync.class);\n-        ModelMetadata metadata = new ModelMetadata(susan.getId(), false, 1, Temporal.Timestamp.now());\n-        ModelWithMetadata<BlogOwner> modelWithMetadata = new ModelWithMetadata<>(susan, metadata);\n-        AppSyncMocking.create(appSync).mockResponse(susan);\n-        AppSyncMocking.sync(appSync).mockSuccessResponse(BlogOwner.class, modelWithMetadata);\n-        AppSyncMocking.onCreate(appSync).callOnStart();\n-        AppSyncMocking.onDelete(appSync).callOnStart();\n-        AppSyncMocking.onUpdate(appSync).callOnStart();\n+        // Mock behaviors from for the API category\n+        GraphQLBehavior mockApi = mock(GraphQLBehavior.class);\n+\n+        ApiMocking.mockSubscriptionStart(mockApi);", "originalCommit": "b0ff24dddc6958027a5ebdce04b23069d43b5cd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyNzAxNA==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r500527014", "bodyText": "Let me circle back on this one. Let me know what you think of the other changes.", "author": "rjuliano", "createdAt": "2020-10-06T18:57:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwNTE3Mg=="}], "type": "inlineReview"}, {"oid": "bf757a5878548d98712746ff974e496d6de15785", "url": "https://github.com/aws-amplify/amplify-android/commit/bf757a5878548d98712746ff974e496d6de15785", "message": "Apply suggestions from code review\n\nCo-authored-by: Jameson Williams <jhwill@amazon.com>", "committedDate": "2020-10-02T20:48:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE5Mjc4OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r499192789", "bodyText": "In the problem description here: #853 you mentioned that we should only We truly only need to block until the storage observer starts, in here it looks like we are still blocking everything , shall we release the startStopSemaphore as soon as startObservingStorageChanges() is done? something like:\nmutationOutbox.load()\n    .andThen(Completable.create(emitter -> {\n        storageObserver.startObservingStorageChanges(emitter::onComplete);\n        currentMode.set(Mode.LOCAL_ONLY);\n    }))\n    .doFinally(startStopSemaphore::release)\n    .blockingAwait(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);", "author": "richardissuperman", "createdAt": "2020-10-04T00:18:43Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -135,10 +138,16 @@ public boolean isStopped() {\n      * Start performing sync operations between the local storage adapter\n      * and the remote GraphQL endpoint.\n      */\n-    public void start() {\n+    public synchronized void start() {\n+        LOG.debug(\"Available permits = \" + startStopSemaphore.availablePermits());\n+        if (!startStopSemaphore.tryAcquire()) {\n+            LOG.warn(\"Unable to acquire orchestrator lock. Transition currently in progress.\");\n+            return;\n+        }\n         disposables.add(transitionCompletable()\n             .subscribeOn(startStopScheduler)\n             .doOnDispose(() -> LOG.debug(\"Orchestrator disposed a transition.\"))\n+            .doFinally(startStopSemaphore::release)", "originalCommit": "1d5df843d3748b3cc67efc079a87af86b8bbe4b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4OTY5NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r499789694", "bodyText": "The purpose of the semaphore is to prevent concurrent calls to start. If we release right after going into LOCAL_ONLY mode, it's possible that another call will come in, acquire a new lock and start the remote sync part of the process, which what we're trying to prevent.\nThat being said, I made some changes that will have the effect you described for a majority of DataStore calls (except for clear).", "author": "rjuliano", "createdAt": "2020-10-05T18:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE5Mjc4OQ=="}], "type": "inlineReview"}, {"oid": "3f3e511152ba4f2f60bd92a32801bc2012ef543f", "url": "https://github.com/aws-amplify/amplify-android/commit/3f3e511152ba4f2f60bd92a32801bc2012ef543f", "message": "Added overload of start to override timeout", "committedDate": "2020-10-05T18:23:26Z", "type": "commit"}, {"oid": "ff41ff03fa778646396946072091fbdb8938176f", "url": "https://github.com/aws-amplify/amplify-android/commit/ff41ff03fa778646396946072091fbdb8938176f", "message": "Moved ApiMocking class", "committedDate": "2020-10-06T14:19:51Z", "type": "commit"}, {"oid": "f9f54bcca8a2b523d666f6250d86251372fb243d", "url": "https://github.com/aws-amplify/amplify-android/commit/f9f54bcca8a2b523d666f6250d86251372fb243d", "message": "Make orchestrator return a completable", "committedDate": "2020-10-06T18:44:24Z", "type": "commit"}, {"oid": "3cc20e2f327a0909e351c4c494e2496963aadc4e", "url": "https://github.com/aws-amplify/amplify-android/commit/3cc20e2f327a0909e351c4c494e2496963aadc4e", "message": "Merge remote-tracking branch 'origin/main' into rjuliano/orchestrator-lock", "committedDate": "2020-10-08T13:43:21Z", "type": "commit"}, {"oid": "2646a0f75e4cdd48d1c868d938761c1d279bfb39", "url": "https://github.com/aws-amplify/amplify-android/commit/2646a0f75e4cdd48d1c868d938761c1d279bfb39", "message": "resolve merge issue", "committedDate": "2020-10-08T14:04:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgwNzE1Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r501807156", "bodyText": "succeeded*", "author": "raphkim", "createdAt": "2020-10-08T15:21:15Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -142,24 +142,53 @@ public boolean isStopped() {\n         return Mode.STOPPED.equals(currentMode.get());\n     }\n \n+    /**\n+     * Start the orchestrator with the default timeout of 10 seconds.\n+     * @return A completable that when subscribed to will attempt to start the orchestrator.\n+     */\n+    public synchronized Completable start() {\n+        return start(NETWORK_OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+    }\n+\n     /**\n      * Start performing sync operations between the local storage adapter\n-     * and the remote GraphQL endpoint.\n+     * and the remote GraphQL endpoint. The timeout parameters provided will be\n+     * used to block execution of the current thread until lock acquisition has\n+     * either failed or succeded, or the timeout is elapsed.", "originalCommit": "2646a0f75e4cdd48d1c868d938761c1d279bfb39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxMTA0NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r501811044", "bodyText": "I understand that you are testing the semaphore, but can we move this to a separate test case? Someone without context checking out this test might get confused why this step is necessary in testing that the \"items placed in storage are published to network\".", "author": "raphkim", "createdAt": "2020-10-08T15:26:16Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/OrchestratorTest.java", "diffHunk": "@@ -100,8 +113,17 @@ public void itemsPlacedInStorageArePublishedToNetwork() throws AmplifyException\n             );\n \n         // Arrange: orchestrator is running\n-        orchestrator.start();\n+        orchestrator.start().subscribe();\n+\n+        // Try to start it in a new thread.\n+        new Thread(() -> orchestrator.start().subscribe()).start();\n+        // Try to start it again on a current thread.\n+        orchestrator.start().subscribe();", "originalCommit": "2646a0f75e4cdd48d1c868d938761c1d279bfb39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk0NjY0OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r501946649", "bodyText": "That's a good point. I'm breaking this out.", "author": "rjuliano", "createdAt": "2020-10-08T19:00:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxMTA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxOTM5Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r501819397", "bodyText": "Considering that we are using this lock for mutual exclusion, isn't this log redundant?", "author": "raphkim", "createdAt": "2020-10-08T15:37:54Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -142,24 +142,53 @@ public boolean isStopped() {\n         return Mode.STOPPED.equals(currentMode.get());\n     }\n \n+    /**\n+     * Start the orchestrator with the default timeout of 10 seconds.\n+     * @return A completable that when subscribed to will attempt to start the orchestrator.\n+     */\n+    public synchronized Completable start() {\n+        return start(NETWORK_OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+    }\n+\n     /**\n      * Start performing sync operations between the local storage adapter\n-     * and the remote GraphQL endpoint.\n+     * and the remote GraphQL endpoint. The timeout parameters provided will be\n+     * used to block execution of the current thread until lock acquisition has\n+     * either failed or succeded, or the timeout is elapsed.\n+     *\n+     * @param opTimeout The desired timeout for the start operation.\n+     * @param timeUnit The unit of time of the opTimeout parameter.\n+     * @return A completable that when subscribed to will attempt to start the orchestrator.\n      */\n-    public void start() {\n-        disposables.add(transitionCompletable()\n-            .subscribeOn(startStopScheduler)\n-            .doOnDispose(() -> LOG.debug(\"Orchestrator disposed a transition.\"))\n-            .subscribe(\n-                () -> {\n-                    LOG.debug(\"Orchestrator completed a transition\");\n-                    if (isStarted()) {\n-                        Amplify.Hub.publish(HubChannel.DATASTORE,\n-                            HubEvent.create(DataStoreChannelEventName.READY));\n-                    }\n-                },\n-                failure -> LOG.warn(\"Orchestrator failed to transition.\")\n-            ));\n+    public synchronized Completable start(long opTimeout, TimeUnit timeUnit) {\n+        if (tryAcquireStartStopLock(opTimeout, timeUnit)) {\n+            return transitionCompletable()\n+                .doOnSubscribe(subscriber -> {\n+                    LOG.debug(\"Starting the orchestrator.\");\n+                })\n+                .doOnComplete(() -> LOG.debug(\"Orchestrator started.\"))\n+                .doOnDispose(() -> LOG.debug(\"Orchestrator disposed a transition.\"))\n+                .doFinally(startStopSemaphore::release)\n+                .subscribeOn(startStopScheduler);\n+        } else {\n+            return Completable.error(new DataStoreException(\"Unable to acquire orchestrator lock. \" +\n+                                                        \"Transition currently in progress.\",\n+                                                        \"Retry your operation.\"));\n+        }\n+    }\n+\n+    private boolean tryAcquireStartStopLock(long opTimeout, TimeUnit timeUnit) {\n+        LOG.debug(\"Attempting to acquire lock. Permits available = \" + startStopSemaphore.availablePermits());", "originalCommit": "2646a0f75e4cdd48d1c868d938761c1d279bfb39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzODM3Mw==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r501938373", "bodyText": "@raphkim I think your point is that this is a \"yes/no\" log, not a \"0...k\" log, right? Or in other words, the observation is that availablePermits() is either 0 or 1?", "author": "jamesonwilliams", "createdAt": "2020-10-08T18:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxOTM5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk0ODM0Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r501948347", "bodyText": "Yep! It's either available or not haha. Maybe \"redundant\" wasn't the right word for it... I think it's just unhelpful information that may end up cluttering up your log", "author": "raphkim", "createdAt": "2020-10-08T19:03:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxOTM5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk2MDQ4Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r501960486", "bodyText": "It's easy enough to make that true or false instead.", "author": "rjuliano", "createdAt": "2020-10-08T19:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxOTM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzNzExMA==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r501937110", "bodyText": "To the fullest extent possible, we should keep this logic within the Orchestrator itself. The plugin is (theoretically) intended to be a thin veneer, and the Orchestrator itself has the job of managing start/stop lifecycle.\nIs there a way to get the actions of the subscribe callbacks back into the Orchestrator, here?", "author": "jamesonwilliams", "createdAt": "2020-10-08T18:43:41Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -223,7 +225,22 @@ public void initialize(@NonNull Context context) throws AmplifyException {\n                 initError, AmplifyException.TODO_RECOVERY_SUGGESTION\n             );\n         }\n-        orchestrator.start();\n+        startOrchestratorAsync();\n+    }\n+\n+    private void startOrchestratorAsync() {", "originalCommit": "2646a0f75e4cdd48d1c868d938761c1d279bfb39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk3ODE5NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r501978194", "bodyText": "Yes...I was able to move this. The original thought was to have the orchestrator be controlled by the plugin, but it doesn't really buy us anything.", "author": "rjuliano", "createdAt": "2020-10-08T19:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzNzExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzNzQ2Mw==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r501937463", "bodyText": "I'm a little confused by this. What does it mean to have a 0 second timeout? Would it be better to just fork the start() API, and have startWithBehaviorFoo() and startWithBehaviorBar()?", "author": "jamesonwilliams", "createdAt": "2020-10-08T18:44:22Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -489,11 +506,8 @@ public void clear(@NonNull Action onComplete,\n \n     private void beforeOperation(@NonNull final Runnable runnable) {\n         try {\n-            Completable.fromAction(\n-                () -> {\n-                    categoryInitializationsPending.await();\n-                    orchestrator.start();\n-                })\n+            categoryInitializationsPending.await();\n+            orchestrator.start(BEFORE_OP_TIMEOUT_MS, TimeUnit.MILLISECONDS)", "originalCommit": "2646a0f75e4cdd48d1c868d938761c1d279bfb39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk1MTE4NQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r501951185", "bodyText": "Man I was confused when I first saw this, then saw his explanation and understood it, but now I'm confused again. If it's zero second timeout, does it not ALWAYS fail? and return false regardless of whether transition is already happening or not? Maybe it should be a small value like 200ms instead?", "author": "raphkim", "createdAt": "2020-10-08T19:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzNzQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAxOTg1MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r502019850", "bodyText": "Timeout of 0 means that the caller only wants the lock if one is available immediately. Basically a fail fast. That being said, I can achieve similar behavior after refactoring the way the completable is built inside the orchestrator.", "author": "rjuliano", "createdAt": "2020-10-08T21:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzNzQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyNjU3MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/876#discussion_r502026570", "bodyText": "I removed the new overload with the timeout parameter. Just had to re-work the completable a bit.", "author": "rjuliano", "createdAt": "2020-10-08T21:36:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzNzQ2Mw=="}], "type": "inlineReview"}, {"oid": "fb731873b28a1368af6951289e14a4b48fd44e39", "url": "https://github.com/aws-amplify/amplify-android/commit/fb731873b28a1368af6951289e14a4b48fd44e39", "message": "Split out test and fixed typo", "committedDate": "2020-10-08T19:28:48Z", "type": "commit"}, {"oid": "1e6c590e7429d6566eddfdbeabd2781abcdb9993", "url": "https://github.com/aws-amplify/amplify-android/commit/1e6c590e7429d6566eddfdbeabd2781abcdb9993", "message": "Remove the start method with timeouts", "committedDate": "2020-10-08T21:31:52Z", "type": "commit"}, {"oid": "18beb514684957bf8ee15dbb6c5b7e1d21679719", "url": "https://github.com/aws-amplify/amplify-android/commit/18beb514684957bf8ee15dbb6c5b7e1d21679719", "message": "cleanup", "committedDate": "2020-10-08T21:42:13Z", "type": "commit"}, {"oid": "8813514e8a25b238f45b8d4568ea998eafe90214", "url": "https://github.com/aws-amplify/amplify-android/commit/8813514e8a25b238f45b8d4568ea998eafe90214", "message": "more cleanup", "committedDate": "2020-10-08T21:56:59Z", "type": "commit"}, {"oid": "2c68d281f92a4ccdd11cdbab657a788440b0a178", "url": "https://github.com/aws-amplify/amplify-android/commit/2c68d281f92a4ccdd11cdbab657a788440b0a178", "message": "Merge remote-tracking branch 'origin/main' into rjuliano/orchestrator-lock", "committedDate": "2020-10-08T22:14:12Z", "type": "commit"}]}