{"pr_number": 398, "pr_title": "add support for non-model types in DataStore", "pr_createdAt": "2020-04-24T19:10:45Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/398", "timeline": [{"oid": "d18f6ff128e89453bb1372ba5034be13699651f5", "url": "https://github.com/aws-amplify/amplify-android/commit/d18f6ff128e89453bb1372ba5034be13699651f5", "message": "add support for non-model types in DataStore\n\n**Notes:**\n\n- GraphQL schemas can contain custom types that are not annotated with\n@model, these \"custom types\" are now handled and saved as JSON strings\nin SQLite and correctly deserialized when querying the models.\n- Cleanup of the value conversion logic, organized the standalone\nprivate methods into a `ModelFieldTypeConverter` interface with a\ndefault SQLite implementation\n- Added a new set of models for testing custom types", "committedDate": "2020-04-24T18:44:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1MTI0OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415251249", "bodyText": "For all of the assertEquals(.., ...) calls -- you have actual and expected backwards. The correct ordering is to put the expected value first, and the actual value second.\nIt doesn't make a huge different, except in how jUnit does reporting, when things go wrong. Right now, the message would print something like:\n\nWanted actual value! But actually, it was expected value.\n\nWhere-as it would ordinarily say:\n\nWanted the expected value, but actually, it was this actual value.", "author": "jamesonwilliams", "createdAt": "2020-04-26T08:20:07Z", "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterModelConverterTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.todo.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.todo.Todo;\n+import com.amplifyframework.testmodels.todo.TodoOwner;\n+import com.amplifyframework.testmodels.todo.TodoStatus;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public final class SQLiteStorageAdapterModelConverterTest {\n+\n+    private static final Date MAY_THE_FOURTH = new Date(1588627200000L);\n+\n+    private SynchronousStorageAdapter adapter;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        this.adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+    }\n+\n+    @After\n+    public void teardown() {\n+        if (adapter != null) {\n+            TestStorageAdapter.cleanup(adapter);\n+        }\n+    }\n+\n+    /**\n+     * Assert that save a model instance with fields of different types in the SQLite database correctly.\n+     * Then after save succeeds, query it and compare the values against the original model.\n+     *\n+     * @throws DataStoreException On unexpected failure manipulating items in/out of DataStore\n+     */\n+    @Test\n+    public void saveModelWithAllTypesThenQuery() throws DataStoreException {", "originalCommit": "d18f6ff128e89453bb1372ba5034be13699651f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwOTIwNQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r416009205", "bodyText": "that's great to know! thanks for pointing it out", "author": "drochetti", "createdAt": "2020-04-27T17:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1MTI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1MjI3Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415252277", "bodyText": "For any of these blocks where you drill down into an object's individual fields, it should be possible instead to do:\nassertEquals(\n   expectedHighLevelObject,\n    actualHighLevelObject\n);\n\nThis will work so long as the class implements a sane equals(...) function.\n(There's a few layers of complexity before it arrives here, but the assert* family all just basically check expected.equals(actual), here.", "author": "jamesonwilliams", "createdAt": "2020-04-26T08:25:12Z", "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapterModelConverterTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.StrictMode;\n+import com.amplifyframework.datastore.storage.SynchronousStorageAdapter;\n+import com.amplifyframework.testmodels.todo.AmplifyModelProvider;\n+import com.amplifyframework.testmodels.todo.Todo;\n+import com.amplifyframework.testmodels.todo.TodoOwner;\n+import com.amplifyframework.testmodels.todo.TodoStatus;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public final class SQLiteStorageAdapterModelConverterTest {\n+\n+    private static final Date MAY_THE_FOURTH = new Date(1588627200000L);\n+\n+    private SynchronousStorageAdapter adapter;\n+\n+    @BeforeClass\n+    public static void enableStrictMode() {\n+        StrictMode.enable();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        TestStorageAdapter.cleanup();\n+        this.adapter = TestStorageAdapter.create(AmplifyModelProvider.getInstance());\n+    }\n+\n+    @After\n+    public void teardown() {\n+        if (adapter != null) {\n+            TestStorageAdapter.cleanup(adapter);\n+        }\n+    }\n+\n+    /**\n+     * Assert that save a model instance with fields of different types in the SQLite database correctly.\n+     * Then after save succeeds, query it and compare the values against the original model.\n+     *\n+     * @throws DataStoreException On unexpected failure manipulating items in/out of DataStore\n+     */\n+    @Test\n+    public void saveModelWithAllTypesThenQuery() throws DataStoreException {\n+        final Todo todo = createTestTodoModel();\n+        this.adapter.save(todo);\n+\n+        final List<Todo> result = this.adapter.query(Todo.class, Todo.ID.eq(todo.getId()));\n+        assertEquals(result.size(), 1);\n+\n+        final Todo queriedTodo = result.get(0);\n+        assertNotNull(queriedTodo);\n+\n+        // Test common scalar types\n+        assertEquals(queriedTodo.getTitle(), todo.getTitle());", "originalCommit": "d18f6ff128e89453bb1372ba5034be13699651f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE0Njk4MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r416146980", "bodyText": "right now there are some issues with how dates are handled once they are persisted on SQL and then fetched, they don't exactly match (due to timezone adjustments: 2:00pm PST becomes 10:00pm GMT).\nThoughts on how to handle those cases? I think this is a general problem for equality check from customers as well.\n@richardmcclellan does your PR address this issue?", "author": "drochetti", "createdAt": "2020-04-27T21:03:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1MjI3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1MzcxNg==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r416153716", "bodyText": "Good question.  My PR is intended to address this.  I've created new classes to represent AWSDate, AWSTime, and AWSDateTime, and they all have a sane  equals(...) method\nHow does Datastore serialization work though?  Does it rely on a toString implementation?  Or is it custom for each type?", "author": "richardmcclellan", "createdAt": "2020-04-27T21:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1MjI3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcwODU4MQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r417708581", "bodyText": "It's per type, the logic is handled in datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java (as of this PR, previously the adapter itself had a few private methods handling (de)serialization)", "author": "drochetti", "createdAt": "2020-04-30T01:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1MjI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NTI2Mw==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415255263", "bodyText": "Most Java documents in this project are grouping instance variables together tightly, without newlines, right now.", "author": "jamesonwilliams", "createdAt": "2020-04-26T08:40:25Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");\n+\n+    private final Class<? extends Model> modelType;\n+\n+    private final ModelSchemaRegistry modelSchemaRegistry;\n+\n+    private final Gson gson;\n+\n+    private final Map<String, SQLiteColumn> columns;", "originalCommit": "d18f6ff128e89453bb1372ba5034be13699651f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NzEwNQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415257105", "bodyText": "So far, and in the interest of keeping the tag short, all of these just say \"amplify:aws-datastore\", right now. (Well okay, I lied. The integration tests use \"amplify:aws-datastore:test\". This strategy is a little bit different from the ordinary private static final Sting LOG = CurrentClassName.class.getName() that is often used. The thinking was that we could  thinking of logging in a more wholistic way across a module, and then everything under a shared slug would be self-consistent (and also, terse.)", "author": "jamesonwilliams", "createdAt": "2020-04-26T08:49:22Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");", "originalCommit": "d18f6ff128e89453bb1372ba5034be13699651f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxMTY3Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r416011676", "bodyText": "Interesting, I like that approach. Should we add a Amplify.Logging.forCategory(CategoryType.DATASTORE) to help enforce it?", "author": "drochetti", "createdAt": "2020-04-27T17:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NzEwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1MDI3Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r416150277", "bodyText": "That's a great idea!", "author": "jamesonwilliams", "createdAt": "2020-04-27T21:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NzEwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcwOTk5OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r417709999", "bodyText": "Done!", "author": "drochetti", "createdAt": "2020-04-30T01:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NzEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NzQzMg==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415257432", "bodyText": "It it possible to catch (AFewSpecific | KnownExceptionTypes conversionFailure) here, as opposed to catch (Exception allPossibleErrors)?", "author": "jamesonwilliams", "createdAt": "2020-04-26T08:51:12Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");\n+\n+    private final Class<? extends Model> modelType;\n+\n+    private final ModelSchemaRegistry modelSchemaRegistry;\n+\n+    private final Gson gson;\n+\n+    private final Map<String, SQLiteColumn> columns;\n+\n+    SQLiteModelFieldTypeConverter(\n+            @NonNull Class<? extends Model> modelType,\n+            @NonNull ModelSchemaRegistry modelSchemaRegistry,\n+            @NonNull Gson gson\n+    ) {\n+        this.modelSchemaRegistry = Objects.requireNonNull(modelSchemaRegistry);\n+        this.gson = Objects.requireNonNull(gson);\n+        this.modelType = modelType;\n+\n+        // load and store the SQL columns for the modelType\n+        final SQLiteTable sqliteTable = SQLiteTable.fromSchema(\n+                modelSchemaRegistry.getModelSchemaForModelClass(modelType.getSimpleName()));\n+        this.columns = sqliteTable.getColumns();\n+    }\n+\n+    @Override\n+    public Object convertValueFromSource(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+        try {\n+            // Skip if there is no equivalent column for field in object\n+            final SQLiteColumn column = columns.get(field.getName());\n+            if (column == null) {\n+                LOGGER.warn(\"Column with name \" + field.getName() + \" does not exist\");\n+                return null;\n+            }\n+\n+            final String columnName = column.getAliasedName();\n+            final int columnIndex = cursor.getColumnIndexOrThrow(columnName);\n+            // This check is necessary, because primitive values will return 0 even when null\n+            if (cursor.isNull(columnIndex)) {\n+                return null;\n+            }\n+\n+            switch (javaFieldType) {\n+                case STRING:\n+                    return cursor.getString(columnIndex);\n+                case MODEL:\n+                    return convertModelAssociationToTarget(cursor, field);\n+                case ENUM:\n+                case CUSTOM_TYPE:\n+                    return convertCustomTypeToTarget(cursor, field, columnIndex);\n+                case INTEGER:\n+                    return cursor.getInt(columnIndex);\n+                case BOOLEAN:\n+                    return cursor.getInt(columnIndex) != 0;\n+                case FLOAT:\n+                    return cursor.getFloat(columnIndex);\n+                case LONG:\n+                    return cursor.getLong(columnIndex);\n+                case DATE:\n+                    return convertDateToTarget(cursor, field, columnIndex);\n+                case TIME:\n+                    final long timeInLongFormat = cursor.getLong(columnIndex);\n+                    return new Time(timeInLongFormat);\n+                default:\n+                    LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                    return null;\n+            }\n+        } catch (Exception exception) {", "originalCommit": "d18f6ff128e89453bb1372ba5034be13699651f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE0NzQxMQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r416147411", "bodyText": "I believe I tried but the compiler warned me about API support. Let me double check it.\nDo we have other places in the codebase with multiple exception catch?", "author": "drochetti", "createdAt": "2020-04-27T21:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NzQzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc0MDUzOQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r417740539", "bodyText": "This \"multi-catch\" be okay in Java 7 and forward. There's got to be some around the code base, no? What was the warning you got from the compiler?", "author": "jamesonwilliams", "createdAt": "2020-04-30T04:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NzQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NzY3OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415257679", "bodyText": "Hmm. Maybe, check the schema? Or, report a bug to AWS? Or, check the type in the annotation in the model?", "author": "jamesonwilliams", "createdAt": "2020-04-26T08:52:20Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");\n+\n+    private final Class<? extends Model> modelType;\n+\n+    private final ModelSchemaRegistry modelSchemaRegistry;\n+\n+    private final Gson gson;\n+\n+    private final Map<String, SQLiteColumn> columns;\n+\n+    SQLiteModelFieldTypeConverter(\n+            @NonNull Class<? extends Model> modelType,\n+            @NonNull ModelSchemaRegistry modelSchemaRegistry,\n+            @NonNull Gson gson\n+    ) {\n+        this.modelSchemaRegistry = Objects.requireNonNull(modelSchemaRegistry);\n+        this.gson = Objects.requireNonNull(gson);\n+        this.modelType = modelType;\n+\n+        // load and store the SQL columns for the modelType\n+        final SQLiteTable sqliteTable = SQLiteTable.fromSchema(\n+                modelSchemaRegistry.getModelSchemaForModelClass(modelType.getSimpleName()));\n+        this.columns = sqliteTable.getColumns();\n+    }\n+\n+    @Override\n+    public Object convertValueFromSource(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+        try {\n+            // Skip if there is no equivalent column for field in object\n+            final SQLiteColumn column = columns.get(field.getName());\n+            if (column == null) {\n+                LOGGER.warn(\"Column with name \" + field.getName() + \" does not exist\");\n+                return null;\n+            }\n+\n+            final String columnName = column.getAliasedName();\n+            final int columnIndex = cursor.getColumnIndexOrThrow(columnName);\n+            // This check is necessary, because primitive values will return 0 even when null\n+            if (cursor.isNull(columnIndex)) {\n+                return null;\n+            }\n+\n+            switch (javaFieldType) {\n+                case STRING:\n+                    return cursor.getString(columnIndex);\n+                case MODEL:\n+                    return convertModelAssociationToTarget(cursor, field);\n+                case ENUM:\n+                case CUSTOM_TYPE:\n+                    return convertCustomTypeToTarget(cursor, field, columnIndex);\n+                case INTEGER:\n+                    return cursor.getInt(columnIndex);\n+                case BOOLEAN:\n+                    return cursor.getInt(columnIndex) != 0;\n+                case FLOAT:\n+                    return cursor.getFloat(columnIndex);\n+                case LONG:\n+                    return cursor.getLong(columnIndex);\n+                case DATE:\n+                    return convertDateToTarget(cursor, field, columnIndex);\n+                case TIME:\n+                    final long timeInLongFormat = cursor.getLong(columnIndex);\n+                    return new Time(timeInLongFormat);\n+                default:\n+                    LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                    return null;\n+            }\n+        } catch (Exception exception) {\n+            throw new DataStoreException(\n+                    \"Error converting field \" + field.getName() + \" from \" + modelType.getName(),\n+                    exception,\n+                    AmplifyException.TODO_RECOVERY_SUGGESTION", "originalCommit": "d18f6ff128e89453bb1372ba5034be13699651f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcwOTk1OA==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r417709958", "bodyText": "I added something similar to what we have on iOS to the Amplify Android: https://github.com/aws-amplify/amplify-ios/blob/master/Amplify/Core/Support/AmplifyErrorMessages.swift#L10\nBasically a default suggestion when the exception might be originated from potential bugs and/or programming mistakes. Let me know what you think.", "author": "drochetti", "createdAt": "2020-04-30T01:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NzY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc0MTMxMA==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r417741310", "bodyText": "Yea! I like that as a default. Looks good. Also, that Swift syntax file: StaticString = #file was new to me.", "author": "jamesonwilliams", "createdAt": "2020-04-30T04:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1NzY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1OTI1OA==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415259258", "bodyText": "What do you think about gson.toJson(fieldValue) as a default?", "author": "jamesonwilliams", "createdAt": "2020-04-26T09:00:27Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");\n+\n+    private final Class<? extends Model> modelType;\n+\n+    private final ModelSchemaRegistry modelSchemaRegistry;\n+\n+    private final Gson gson;\n+\n+    private final Map<String, SQLiteColumn> columns;\n+\n+    SQLiteModelFieldTypeConverter(\n+            @NonNull Class<? extends Model> modelType,\n+            @NonNull ModelSchemaRegistry modelSchemaRegistry,\n+            @NonNull Gson gson\n+    ) {\n+        this.modelSchemaRegistry = Objects.requireNonNull(modelSchemaRegistry);\n+        this.gson = Objects.requireNonNull(gson);\n+        this.modelType = modelType;\n+\n+        // load and store the SQL columns for the modelType\n+        final SQLiteTable sqliteTable = SQLiteTable.fromSchema(\n+                modelSchemaRegistry.getModelSchemaForModelClass(modelType.getSimpleName()));\n+        this.columns = sqliteTable.getColumns();\n+    }\n+\n+    @Override\n+    public Object convertValueFromSource(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+        try {\n+            // Skip if there is no equivalent column for field in object\n+            final SQLiteColumn column = columns.get(field.getName());\n+            if (column == null) {\n+                LOGGER.warn(\"Column with name \" + field.getName() + \" does not exist\");\n+                return null;\n+            }\n+\n+            final String columnName = column.getAliasedName();\n+            final int columnIndex = cursor.getColumnIndexOrThrow(columnName);\n+            // This check is necessary, because primitive values will return 0 even when null\n+            if (cursor.isNull(columnIndex)) {\n+                return null;\n+            }\n+\n+            switch (javaFieldType) {\n+                case STRING:\n+                    return cursor.getString(columnIndex);\n+                case MODEL:\n+                    return convertModelAssociationToTarget(cursor, field);\n+                case ENUM:\n+                case CUSTOM_TYPE:\n+                    return convertCustomTypeToTarget(cursor, field, columnIndex);\n+                case INTEGER:\n+                    return cursor.getInt(columnIndex);\n+                case BOOLEAN:\n+                    return cursor.getInt(columnIndex) != 0;\n+                case FLOAT:\n+                    return cursor.getFloat(columnIndex);\n+                case LONG:\n+                    return cursor.getLong(columnIndex);\n+                case DATE:\n+                    return convertDateToTarget(cursor, field, columnIndex);\n+                case TIME:\n+                    final long timeInLongFormat = cursor.getLong(columnIndex);\n+                    return new Time(timeInLongFormat);\n+                default:\n+                    LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                    return null;\n+            }\n+        } catch (Exception exception) {\n+            throw new DataStoreException(\n+                    \"Error converting field \" + field.getName() + \" from \" + modelType.getName(),\n+                    exception,\n+                    AmplifyException.TODO_RECOVERY_SUGGESTION\n+            );\n+        }\n+    }\n+\n+    private Object convertModelAssociationToTarget(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        // Eager load model if the necessary columns are present inside the cursor.\n+        // At the time of implementation, cursor should have been joined with these\n+        // columns IF AND ONLY IF the model is a foreign key to the inner model.\n+        // value has Class<?>, but we want Class<? extends Model>\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends Model> nestedModelType = (Class<? extends Model>) field.getType();\n+        String className = nestedModelType.getSimpleName();\n+        ModelSchema innerModelSchema = modelSchemaRegistry.getModelSchemaForModelClass(className);\n+\n+        SQLiteModelFieldTypeConverter nestedModelConverter =\n+                new SQLiteModelFieldTypeConverter(nestedModelType, modelSchemaRegistry, gson);\n+\n+        Map<String, Object> mapForInnerModel = new HashMap<>();\n+        for (Map.Entry<String, ModelField> entry : innerModelSchema.getFields().entrySet()) {\n+            mapForInnerModel.put(entry.getKey(), nestedModelConverter.convertValueFromSource(cursor, entry.getValue()));\n+        }\n+        final String modelInJsonFormat = gson.toJson(mapForInnerModel);\n+        try {\n+            return gson.getAdapter(nestedModelType).fromJson(modelInJsonFormat);\n+        } catch (IOException exception) {\n+            LOGGER.warn(\"\", exception);\n+            return null;\n+        }\n+    }\n+\n+    private Object convertCustomTypeToTarget(Cursor cursor, ModelField field, int columnIndex) throws IOException {\n+        final String stringValue = cursor.getString(columnIndex);\n+        return gson.getAdapter(field.getType()).fromJson(stringValue);\n+    }\n+\n+    private Object convertDateToTarget(Cursor cursor, ModelField field, int columnIndex) throws ParseException {\n+        // TODO wire up the new Date/Time handling here\n+        final String dateInStringFormat = cursor.getString(columnIndex);\n+        if (dateInStringFormat != null) {\n+            return SimpleDateFormat\n+                    .getDateInstance()\n+                    .parse(dateInStringFormat);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Object convertValueFromTarget(Model model, ModelField field) throws DataStoreException {\n+        final String fieldName = field.getName();\n+\n+        final Object fieldValue = getModelValue(model, fieldName);\n+        if (fieldValue == null) {\n+            return null;\n+        }\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+\n+        switch (javaFieldType) {\n+            case INTEGER:\n+            case LONG:\n+            case FLOAT:\n+            case STRING:\n+                // these types require no special treatment\n+                return fieldValue;\n+            case BOOLEAN:\n+                boolean booleanValue = (boolean) fieldValue;\n+                return booleanValue ? 1L : 0L;\n+            case MODEL:\n+                return ((Model) fieldValue).getId();\n+            case ENUM:\n+            case CUSTOM_TYPE:\n+                return gson.toJson(fieldValue);\n+            case DATE:\n+                // TODO integrate with new Date/Time handling\n+                final Date dateValue = (Date) fieldValue;\n+                return SimpleDateFormat\n+                        .getDateInstance()\n+                        .format(dateValue);\n+            case TIME:\n+                return ((Time) fieldValue).getTime();\n+            default:\n+                LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                return null;", "originalCommit": "d18f6ff128e89453bb1372ba5034be13699651f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxMjgxOA==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r416012818", "bodyText": "I think that's a good idea, as long as we keep the warn", "author": "drochetti", "createdAt": "2020-04-27T17:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1OTI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1MzIwNQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r417653205", "bodyText": "I gave this some thought after a few tests and would like your opinion.\nI believe we should fallback to null due to backward compatibility.\nWhen the code reaches that default it means that a field type we should support is not correctly supported (i.e. we did not exhaust the enum). If we assume JSON, when that's fixed we are at risk of breaking backward compatibility with existing data in case the correct format isn't the same as the one produced by the toJson()/fromJson() call.\nDoes that make sense? Thoughts?", "author": "drochetti", "createdAt": "2020-04-29T22:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1OTI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY3MzMyNA==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r417673324", "bodyText": "Ah, yea I get what you're saying. Makes sense. null sounds safer.", "author": "jamesonwilliams", "createdAt": "2020-04-29T23:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI1OTI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI2MDgyMg==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415260822", "bodyText": "If we assume that models only come from the code-generator, it might be over-kill to fall back on field inspection, here.\nIn practice, there's a whole set of expectations our code base has about M extends Model type classes. The interface says they need a method called getId(), but in reality, we have all of the (currently required) annotations, etc. Should we just assume they have getter methods? Or if we do the field access thing, should we respect the private access of the field? (I guess, tools like GSON don't, they just read the private field ...)\nAs a note on construction - can we avoid nesting the try/catch in a try/catch here?\nMaybe the flow could be like:\ntry {\n   return favorableApproach();\n} catch (DidntPanOutException favorableDidntWork) {\n    // ...\n}\ntry {\n    return fallbackApprach();\n} catch (FlalbackException alsoDidntWork) {\n    // ...\n}\n\n?", "author": "jamesonwilliams", "createdAt": "2020-04-26T09:08:23Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");\n+\n+    private final Class<? extends Model> modelType;\n+\n+    private final ModelSchemaRegistry modelSchemaRegistry;\n+\n+    private final Gson gson;\n+\n+    private final Map<String, SQLiteColumn> columns;\n+\n+    SQLiteModelFieldTypeConverter(\n+            @NonNull Class<? extends Model> modelType,\n+            @NonNull ModelSchemaRegistry modelSchemaRegistry,\n+            @NonNull Gson gson\n+    ) {\n+        this.modelSchemaRegistry = Objects.requireNonNull(modelSchemaRegistry);\n+        this.gson = Objects.requireNonNull(gson);\n+        this.modelType = modelType;\n+\n+        // load and store the SQL columns for the modelType\n+        final SQLiteTable sqliteTable = SQLiteTable.fromSchema(\n+                modelSchemaRegistry.getModelSchemaForModelClass(modelType.getSimpleName()));\n+        this.columns = sqliteTable.getColumns();\n+    }\n+\n+    @Override\n+    public Object convertValueFromSource(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+        try {\n+            // Skip if there is no equivalent column for field in object\n+            final SQLiteColumn column = columns.get(field.getName());\n+            if (column == null) {\n+                LOGGER.warn(\"Column with name \" + field.getName() + \" does not exist\");\n+                return null;\n+            }\n+\n+            final String columnName = column.getAliasedName();\n+            final int columnIndex = cursor.getColumnIndexOrThrow(columnName);\n+            // This check is necessary, because primitive values will return 0 even when null\n+            if (cursor.isNull(columnIndex)) {\n+                return null;\n+            }\n+\n+            switch (javaFieldType) {\n+                case STRING:\n+                    return cursor.getString(columnIndex);\n+                case MODEL:\n+                    return convertModelAssociationToTarget(cursor, field);\n+                case ENUM:\n+                case CUSTOM_TYPE:\n+                    return convertCustomTypeToTarget(cursor, field, columnIndex);\n+                case INTEGER:\n+                    return cursor.getInt(columnIndex);\n+                case BOOLEAN:\n+                    return cursor.getInt(columnIndex) != 0;\n+                case FLOAT:\n+                    return cursor.getFloat(columnIndex);\n+                case LONG:\n+                    return cursor.getLong(columnIndex);\n+                case DATE:\n+                    return convertDateToTarget(cursor, field, columnIndex);\n+                case TIME:\n+                    final long timeInLongFormat = cursor.getLong(columnIndex);\n+                    return new Time(timeInLongFormat);\n+                default:\n+                    LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                    return null;\n+            }\n+        } catch (Exception exception) {\n+            throw new DataStoreException(\n+                    \"Error converting field \" + field.getName() + \" from \" + modelType.getName(),\n+                    exception,\n+                    AmplifyException.TODO_RECOVERY_SUGGESTION\n+            );\n+        }\n+    }\n+\n+    private Object convertModelAssociationToTarget(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        // Eager load model if the necessary columns are present inside the cursor.\n+        // At the time of implementation, cursor should have been joined with these\n+        // columns IF AND ONLY IF the model is a foreign key to the inner model.\n+        // value has Class<?>, but we want Class<? extends Model>\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends Model> nestedModelType = (Class<? extends Model>) field.getType();\n+        String className = nestedModelType.getSimpleName();\n+        ModelSchema innerModelSchema = modelSchemaRegistry.getModelSchemaForModelClass(className);\n+\n+        SQLiteModelFieldTypeConverter nestedModelConverter =\n+                new SQLiteModelFieldTypeConverter(nestedModelType, modelSchemaRegistry, gson);\n+\n+        Map<String, Object> mapForInnerModel = new HashMap<>();\n+        for (Map.Entry<String, ModelField> entry : innerModelSchema.getFields().entrySet()) {\n+            mapForInnerModel.put(entry.getKey(), nestedModelConverter.convertValueFromSource(cursor, entry.getValue()));\n+        }\n+        final String modelInJsonFormat = gson.toJson(mapForInnerModel);\n+        try {\n+            return gson.getAdapter(nestedModelType).fromJson(modelInJsonFormat);\n+        } catch (IOException exception) {\n+            LOGGER.warn(\"\", exception);\n+            return null;\n+        }\n+    }\n+\n+    private Object convertCustomTypeToTarget(Cursor cursor, ModelField field, int columnIndex) throws IOException {\n+        final String stringValue = cursor.getString(columnIndex);\n+        return gson.getAdapter(field.getType()).fromJson(stringValue);\n+    }\n+\n+    private Object convertDateToTarget(Cursor cursor, ModelField field, int columnIndex) throws ParseException {\n+        // TODO wire up the new Date/Time handling here\n+        final String dateInStringFormat = cursor.getString(columnIndex);\n+        if (dateInStringFormat != null) {\n+            return SimpleDateFormat\n+                    .getDateInstance()\n+                    .parse(dateInStringFormat);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Object convertValueFromTarget(Model model, ModelField field) throws DataStoreException {\n+        final String fieldName = field.getName();\n+\n+        final Object fieldValue = getModelValue(model, fieldName);\n+        if (fieldValue == null) {\n+            return null;\n+        }\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+\n+        switch (javaFieldType) {\n+            case INTEGER:\n+            case LONG:\n+            case FLOAT:\n+            case STRING:\n+                // these types require no special treatment\n+                return fieldValue;\n+            case BOOLEAN:\n+                boolean booleanValue = (boolean) fieldValue;\n+                return booleanValue ? 1L : 0L;\n+            case MODEL:\n+                return ((Model) fieldValue).getId();\n+            case ENUM:\n+            case CUSTOM_TYPE:\n+                return gson.toJson(fieldValue);\n+            case DATE:\n+                // TODO integrate with new Date/Time handling\n+                final Date dateValue = (Date) fieldValue;\n+                return SimpleDateFormat\n+                        .getDateInstance()\n+                        .format(dateValue);\n+            case TIME:\n+                return ((Time) fieldValue).getTime();\n+            default:\n+                LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                return null;\n+        }\n+    }\n+\n+    private Object getModelValue(Model model, String fieldName) throws DataStoreException {\n+        Class<? extends Model> modelClass = model.getClass();\n+        final String getterName = \"get\" + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);\n+        try {\n+            final Method fieldGetter = modelClass.getMethod(getterName);\n+            return fieldGetter.invoke(model);\n+        } catch (Exception exception) {\n+            LOGGER.debug(\"Could not find \" + getterName + \"() on \" + modelClass.getName()\n+                    + \". Fallback to direct field access.\");\n+            // fallback to direct field access", "originalCommit": "d18f6ff128e89453bb1372ba5034be13699651f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MDA4Mw==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r417660083", "bodyText": "I'm not sure we should break in case customers decided (for any reason) to either change the generated model or even to write their own (e.g. with public fields instead, using Lombok or Kotlin data classes). I think we could be resilient here as long as it's a valid pojo.\nThat said, you raise an important question: is a pojo with private fields should have the access level respected as such? I don't know, but the argument that libraries like Gson, Jackson, Spring, etc bypass the access level seems like a strong one to do the same.\nNote that we have a few places with direct field access, this is just an initial attempt to standardize it. For the time being I'll refactor it into a more general-purpose helper and we can discuss the rules for field access and also remove field access duplication.", "author": "drochetti", "createdAt": "2020-04-29T22:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI2MDgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY3MzAwNQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r417673005", "bodyText": "Okay, cool. Yes I do agree with you, we should move in the direction of supporting arbitrary @Models, through-out. My argument was basically \"But we don't right now\"; however, that doesn't mean we should keep marching in that direction!", "author": "jamesonwilliams", "createdAt": "2020-04-29T23:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI2MDgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI2MTI1Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r415261252", "bodyText": "This is sort of a rule about the model classes. I wonder if we could make this a utility on one of them. Like ModelSchema.getterForField(fieldName)?  Maybe not ModelSchema itself...", "author": "jamesonwilliams", "createdAt": "2020-04-26T09:10:57Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelFieldTypeConverter.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.AmplifyException;\n+import com.amplifyframework.core.Amplify;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelField;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.types.JavaFieldType;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.ModelFieldTypeConverter;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteColumn;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.logging.Logger;\n+\n+import com.google.gson.Gson;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.sql.Time;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * <code>ModelField</code> value converter for SQLite. It converts from SQLite's <code>Cursor</code>\n+ * to <code>Model</code> properties and from <code>Model</code> properties to values that are\n+ * valid in a <code>SQLiteStatement</code>.\n+ */\n+final class SQLiteModelFieldTypeConverter implements ModelFieldTypeConverter<Cursor, Model> {\n+\n+    private static final Logger LOGGER = Amplify.Logging.forNamespace(\"amplify:aws-datastore:sqliteConverter\");\n+\n+    private final Class<? extends Model> modelType;\n+\n+    private final ModelSchemaRegistry modelSchemaRegistry;\n+\n+    private final Gson gson;\n+\n+    private final Map<String, SQLiteColumn> columns;\n+\n+    SQLiteModelFieldTypeConverter(\n+            @NonNull Class<? extends Model> modelType,\n+            @NonNull ModelSchemaRegistry modelSchemaRegistry,\n+            @NonNull Gson gson\n+    ) {\n+        this.modelSchemaRegistry = Objects.requireNonNull(modelSchemaRegistry);\n+        this.gson = Objects.requireNonNull(gson);\n+        this.modelType = modelType;\n+\n+        // load and store the SQL columns for the modelType\n+        final SQLiteTable sqliteTable = SQLiteTable.fromSchema(\n+                modelSchemaRegistry.getModelSchemaForModelClass(modelType.getSimpleName()));\n+        this.columns = sqliteTable.getColumns();\n+    }\n+\n+    @Override\n+    public Object convertValueFromSource(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+        try {\n+            // Skip if there is no equivalent column for field in object\n+            final SQLiteColumn column = columns.get(field.getName());\n+            if (column == null) {\n+                LOGGER.warn(\"Column with name \" + field.getName() + \" does not exist\");\n+                return null;\n+            }\n+\n+            final String columnName = column.getAliasedName();\n+            final int columnIndex = cursor.getColumnIndexOrThrow(columnName);\n+            // This check is necessary, because primitive values will return 0 even when null\n+            if (cursor.isNull(columnIndex)) {\n+                return null;\n+            }\n+\n+            switch (javaFieldType) {\n+                case STRING:\n+                    return cursor.getString(columnIndex);\n+                case MODEL:\n+                    return convertModelAssociationToTarget(cursor, field);\n+                case ENUM:\n+                case CUSTOM_TYPE:\n+                    return convertCustomTypeToTarget(cursor, field, columnIndex);\n+                case INTEGER:\n+                    return cursor.getInt(columnIndex);\n+                case BOOLEAN:\n+                    return cursor.getInt(columnIndex) != 0;\n+                case FLOAT:\n+                    return cursor.getFloat(columnIndex);\n+                case LONG:\n+                    return cursor.getLong(columnIndex);\n+                case DATE:\n+                    return convertDateToTarget(cursor, field, columnIndex);\n+                case TIME:\n+                    final long timeInLongFormat = cursor.getLong(columnIndex);\n+                    return new Time(timeInLongFormat);\n+                default:\n+                    LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                    return null;\n+            }\n+        } catch (Exception exception) {\n+            throw new DataStoreException(\n+                    \"Error converting field \" + field.getName() + \" from \" + modelType.getName(),\n+                    exception,\n+                    AmplifyException.TODO_RECOVERY_SUGGESTION\n+            );\n+        }\n+    }\n+\n+    private Object convertModelAssociationToTarget(\n+            @NonNull Cursor cursor,\n+            @NonNull ModelField field\n+    ) throws DataStoreException {\n+        // Eager load model if the necessary columns are present inside the cursor.\n+        // At the time of implementation, cursor should have been joined with these\n+        // columns IF AND ONLY IF the model is a foreign key to the inner model.\n+        // value has Class<?>, but we want Class<? extends Model>\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends Model> nestedModelType = (Class<? extends Model>) field.getType();\n+        String className = nestedModelType.getSimpleName();\n+        ModelSchema innerModelSchema = modelSchemaRegistry.getModelSchemaForModelClass(className);\n+\n+        SQLiteModelFieldTypeConverter nestedModelConverter =\n+                new SQLiteModelFieldTypeConverter(nestedModelType, modelSchemaRegistry, gson);\n+\n+        Map<String, Object> mapForInnerModel = new HashMap<>();\n+        for (Map.Entry<String, ModelField> entry : innerModelSchema.getFields().entrySet()) {\n+            mapForInnerModel.put(entry.getKey(), nestedModelConverter.convertValueFromSource(cursor, entry.getValue()));\n+        }\n+        final String modelInJsonFormat = gson.toJson(mapForInnerModel);\n+        try {\n+            return gson.getAdapter(nestedModelType).fromJson(modelInJsonFormat);\n+        } catch (IOException exception) {\n+            LOGGER.warn(\"\", exception);\n+            return null;\n+        }\n+    }\n+\n+    private Object convertCustomTypeToTarget(Cursor cursor, ModelField field, int columnIndex) throws IOException {\n+        final String stringValue = cursor.getString(columnIndex);\n+        return gson.getAdapter(field.getType()).fromJson(stringValue);\n+    }\n+\n+    private Object convertDateToTarget(Cursor cursor, ModelField field, int columnIndex) throws ParseException {\n+        // TODO wire up the new Date/Time handling here\n+        final String dateInStringFormat = cursor.getString(columnIndex);\n+        if (dateInStringFormat != null) {\n+            return SimpleDateFormat\n+                    .getDateInstance()\n+                    .parse(dateInStringFormat);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Object convertValueFromTarget(Model model, ModelField field) throws DataStoreException {\n+        final String fieldName = field.getName();\n+\n+        final Object fieldValue = getModelValue(model, fieldName);\n+        if (fieldValue == null) {\n+            return null;\n+        }\n+        final JavaFieldType javaFieldType = TypeConverter.getJavaFieldType(field);\n+\n+        switch (javaFieldType) {\n+            case INTEGER:\n+            case LONG:\n+            case FLOAT:\n+            case STRING:\n+                // these types require no special treatment\n+                return fieldValue;\n+            case BOOLEAN:\n+                boolean booleanValue = (boolean) fieldValue;\n+                return booleanValue ? 1L : 0L;\n+            case MODEL:\n+                return ((Model) fieldValue).getId();\n+            case ENUM:\n+            case CUSTOM_TYPE:\n+                return gson.toJson(fieldValue);\n+            case DATE:\n+                // TODO integrate with new Date/Time handling\n+                final Date dateValue = (Date) fieldValue;\n+                return SimpleDateFormat\n+                        .getDateInstance()\n+                        .format(dateValue);\n+            case TIME:\n+                return ((Time) fieldValue).getTime();\n+            default:\n+                LOGGER.warn(\"Field of type \" + javaFieldType + \" is not supported. Fallback to null.\");\n+                return null;\n+        }\n+    }\n+\n+    private Object getModelValue(Model model, String fieldName) throws DataStoreException {\n+        Class<? extends Model> modelClass = model.getClass();\n+        final String getterName = \"get\" + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);", "originalCommit": "d18f6ff128e89453bb1372ba5034be13699651f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcxMDQ0NQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r417710445", "bodyText": "I created a ModelHelper... I'm not a big fan of \"helper\", \"utils\" stuff in general, but sometimes I just find myself without a better alternative, like in this case. So, feel free to suggest something different :)", "author": "drochetti", "createdAt": "2020-04-30T01:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI2MTI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc0MjM5OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r417742399", "bodyText": "Ah gosh actually we have this FieldFinder already too, that I'd forgotten about. It extracts a value from an object, by looking up an instance variable by name.\nMaybe let's punt this for now. We could do a separate, targeted PR that lumps together some of the reflection utilities that are currently around the code-base.\nOh, but maybe the right name for this current utility we are discussing, is a ModelFieldFinder?", "author": "jamesonwilliams", "createdAt": "2020-04-30T04:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI2MTI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxMjUwMQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/398#discussion_r418612501", "bodyText": "Agree. I'll merge my code as is and follow up with a clean-up/consolidation of all the reflection related code DataStore has", "author": "drochetti", "createdAt": "2020-05-01T16:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI2MTI1Mg=="}], "type": "inlineReview"}, {"oid": "26089ae974050b8a5decca07d763eeea2ca5ca14", "url": "https://github.com/aws-amplify/amplify-android/commit/26089ae974050b8a5decca07d763eeea2ca5ca14", "message": "fix test assertion parameter order", "committedDate": "2020-04-28T23:01:23Z", "type": "commit"}, {"oid": "48cca716a82a17ed02759ab6f458f0944ea8a27e", "url": "https://github.com/aws-amplify/amplify-android/commit/48cca716a82a17ed02759ab6f458f0944ea8a27e", "message": "Merge remote-tracking branch 'origin/master' into feature/nonmodel-types", "committedDate": "2020-04-28T23:02:00Z", "type": "commit"}, {"oid": "25b4ee75356da0a52ed4ac7dbe36253ac7c0d493", "url": "https://github.com/aws-amplify/amplify-android/commit/25b4ee75356da0a52ed4ac7dbe36253ac7c0d493", "message": "address PR feedback\n\n**Notes:**\n\n- added a common \"report to aws\" exception suggestion\n- added a `forCategory` on `Amplify.Logging`\n- extracted the `getValue` to model helper class", "committedDate": "2020-04-30T01:05:15Z", "type": "commit"}, {"oid": "29b0d6d4c064c7a66f097d3b2488696fade444c6", "url": "https://github.com/aws-amplify/amplify-android/commit/29b0d6d4c064c7a66f097d3b2488696fade444c6", "message": "Merge remote-tracking branch 'origin/master' into feature/nonmodel-types", "committedDate": "2020-04-30T01:08:12Z", "type": "commit"}, {"oid": "482df3528d0103ac036c86583cdc25804953f551", "url": "https://github.com/aws-amplify/amplify-android/commit/482df3528d0103ac036c86583cdc25804953f551", "message": "fix checkstyle violations", "committedDate": "2020-04-30T01:38:06Z", "type": "commit"}, {"oid": "b661e03fa3cab486d15d901e8196b5dda54c6efd", "url": "https://github.com/aws-amplify/amplify-android/commit/b661e03fa3cab486d15d901e8196b5dda54c6efd", "message": "Merge remote-tracking branch 'origin/master' into feature/nonmodel-types", "committedDate": "2020-05-01T05:46:58Z", "type": "commit"}, {"oid": "4adaf6b65d690bb45f92dd9415c2ec71c85a192e", "url": "https://github.com/aws-amplify/amplify-android/commit/4adaf6b65d690bb45f92dd9415c2ec71c85a192e", "message": "fix datastore javadoc checkstyle", "committedDate": "2020-05-01T07:23:05Z", "type": "commit"}, {"oid": "2b87a6dfac02bd6172135d23a54b36297bbfd399", "url": "https://github.com/aws-amplify/amplify-android/commit/2b87a6dfac02bd6172135d23a54b36297bbfd399", "message": "fix javadoc class link", "committedDate": "2020-05-01T10:01:32Z", "type": "commit"}, {"oid": "0421d6347d04a3c5a324027a8ecab393bcf7503f", "url": "https://github.com/aws-amplify/amplify-android/commit/0421d6347d04a3c5a324027a8ecab393bcf7503f", "message": "Merge branch 'master' of https://github.com/aws-amplify/amplify-android into feature/nonmodel-types", "committedDate": "2020-05-01T16:07:31Z", "type": "commit"}]}