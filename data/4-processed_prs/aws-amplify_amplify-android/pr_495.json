{"pr_number": 495, "pr_title": "[aws-datastore] Mark mutations as in-flight while processing", "pr_createdAt": "2020-05-20T08:19:00Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/495", "timeline": [{"oid": "99a40c87e1c8508582d8c44eab9f9ac5517c1322", "url": "https://github.com/aws-amplify/amplify-android/commit/99a40c87e1c8508582d8c44eab9f9ac5517c1322", "message": "[aws-datastore] Mark mutations as in-flight while processing\n\nThe behavior of the Mutation Outbox is changed, to include an in-memory,\n\"in-flight\" state for its pending mutations.\n\nBefore we start to publish a mutation to AppSync, we will mark it as\n\"in-flight\", in the Mutation Outbox. This signifies that the mutation\nwill be treated as immutable for the duration of its life in-memory.\n\nThe mutation will continue to be marked as \"in-process\" until one of two\nthings happen:\n\n 1. The mutation is removed from the mutation outbox.\n\n 2. The system restarts, and the mutation is loaded from disk, again,\n    while rebuilding the mutation outbox. While loading, it will appear\n    as though this mutation did _not_ finish processing successfully,\n    and so should be retried.\n\nWhile enquing new mutations, existing, in-flight mutations will be\nignored. That is to say, new mutations will be queued behind the\nin-flight ones, and the in-flight ones will not be tampered with.", "committedDate": "2020-05-20T08:13:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NjU3NQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/495#discussion_r427946575", "bodyText": "Quick question - if somehow there's a failure between the server getting it and this remove from outbox step, will it gracefully ignore the duplicate transaction next time the outbox attempts to perform it?", "author": "TrekSoft", "createdAt": "2020-05-20T11:49:47Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationProcessor.java", "diffHunk": "@@ -115,13 +115,17 @@ private Completable drainMutationOutbox() {\n      * @return A Completable that emits success when the item is processed, emits failure, otherwise\n      */\n     private <T extends Model> Completable processOutboxItem(PendingMutation<T> mutationOutboxItem) {\n-        // First, publish the mutation over the network.\n-        return publishToNetwork(mutationOutboxItem)\n-            .flatMapCompletable(mutation ->\n-                // Once the server knows about it, it's safe to remove from the outbox.\n-                // This is done before merging, because the merger will refuse to merge\n-                // if there are outstanding mutations in the outbox.\n-                mutationOutbox.remove(mutationOutboxItem).andThen(merger.merge(mutation))\n+        // First, mark the item as in-flight.\n+        return mutationOutbox.markInFlight(mutationOutboxItem.getMutationId())\n+            // Then, put it \"into flight\"\n+            .andThen(publishToNetwork(mutationOutboxItem)\n+                .flatMapCompletable(modelWithMetadata ->\n+                    // Once the server knows about it, it's safe to remove from the outbox.\n+                    // This is done before merging, because the merger will refuse to merge\n+                    // if there are outstanding mutations in the outbox.\n+                    mutationOutbox.remove(mutationOutboxItem.getMutationId())", "originalCommit": "99a40c87e1c8508582d8c44eab9f9ac5517c1322", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MjI5MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/495#discussion_r427952290", "bodyText": "My suspicion is if we get into this state, the outbox will be indefinitely wedged. We have some work to do here to make the outbox a) concurrent b) resilient", "author": "jpignata", "createdAt": "2020-05-20T12:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NjU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk2MDYxNQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/495#discussion_r427960615", "bodyText": "I would think with the conditions on Updates and Deletes (or ID check on Create) it'd be fairly simple to avoid this being a problem if we aren't already. But yeah definitely not a launch blocker if we aren't since it's an edge case we could follow up with a fix for.", "author": "TrekSoft", "createdAt": "2020-05-20T12:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NjU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExOTk2OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/495#discussion_r428119969", "bodyText": "I'm afraid this will wedge things, too.\nThe likelihood of the local write failing should be very low, for what it's worth.\nThe likelihood of the network call failing is orders of magnitude higher.\nWe should come back to this.", "author": "jamesonwilliams", "createdAt": "2020-05-20T15:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NjU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0MTY4Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/495#discussion_r427941682", "bodyText": "There's only ever one in our current design, but I guess in the future that should not be true.", "author": "jpignata", "createdAt": "2020-05-20T11:39:53Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -51,14 +53,16 @@\n     private static final Logger LOG = Amplify.Logging.forNamespace(\"amplify:aws-datastore\");\n \n     private final LocalStorageAdapter storage;\n-    private final Queue<PendingMutation<? extends Model>> mutationQueue;\n+    private final LinkedList<PendingMutation<? extends Model>> mutationQueue;\n+    private final Set<TimeBasedUuid> inFlightMutations;", "originalCommit": "99a40c87e1c8508582d8c44eab9f9ac5517c1322", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNDk2OA==", "url": "https://github.com/aws-amplify/amplify-android/pull/495#discussion_r428114968", "bodyText": "Since we have serialized all of our calls into this class, I think that's true, right now, yea. Set may not have been the most appropriate choice for the current usage / behavior.", "author": "jamesonwilliams", "createdAt": "2020-05-20T15:41:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0MTY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0ODA5Mw==", "url": "https://github.com/aws-amplify/amplify-android/pull/495#discussion_r427948093", "bodyText": "Curious - for LinkedList I imagine these are identical and probably implemented using each other. What was the intent for this change for my education?", "author": "jpignata", "createdAt": "2020-05-20T11:52:42Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -229,12 +251,13 @@ private void removeFromQueue(String modelId) {\n     public Completable load() {\n         return Completable.defer(() -> Completable.create(emitter -> {\n             semaphore.acquire();\n+            inFlightMutations.clear();\n             mutationQueue.clear();\n             storage.query(PendingMutation.PersistentRecord.class,\n                 results -> {\n                     while (results.hasNext()) {\n                         try {\n-                            mutationQueue.offer(converter.fromRecord(results.next()));\n+                            mutationQueue.addLast(converter.fromRecord(results.next()));", "originalCommit": "99a40c87e1c8508582d8c44eab9f9ac5517c1322", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNjYyMQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/495#discussion_r428126621", "bodyText": "Since LinkedList implements/extends a few different base types, it is actually kind of a mess. I believe these four methods all behave identically:\n\nadd()\naddLast()\nofferLast()\noffer()\n\nJava Queue itself provides the add() and offer(). The two methods differ subtly in how they communicate failure modes.\nI decided to use addLast() because its enqueuing behavior is communicated with the least ambiguity, of the four.", "author": "jamesonwilliams", "createdAt": "2020-05-20T15:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0ODA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MTU2Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/495#discussion_r427951566", "bodyText": "The name updateQueue is kind of right (in that many operations against a queue will change it), but I wonder if there's a more expressive name that would be more obvious to a future reader such as addOrUpdateQueueItem.", "author": "jpignata", "createdAt": "2020-05-20T11:59:11Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -188,17 +189,39 @@ private Completable unknownMutationType(PendingMutation.Type unknownType) {\n         }));\n     }\n \n+    private <T extends Model> void updateQueue(PendingMutation<T> pendingMutation) {", "originalCommit": "99a40c87e1c8508582d8c44eab9f9ac5517c1322", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExODQ1Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/495#discussion_r428118457", "bodyText": "Agree! \"Update the foo\" is never very descriptive. Will rephrase.", "author": "jamesonwilliams", "createdAt": "2020-05-20T15:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk1MTU2Ng=="}], "type": "inlineReview"}, {"oid": "d5105383665e4dde2edc23e0c0286157f0a4685e", "url": "https://github.com/aws-amplify/amplify-android/commit/d5105383665e4dde2edc23e0c0286157f0a4685e", "message": "fixup", "committedDate": "2020-05-20T15:59:50Z", "type": "commit"}]}