{"pr_number": 1059, "pr_title": "fix(aws-datastore): publish each cascading delete", "pr_createdAt": "2020-12-17T01:28:06Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/1059", "timeline": [{"oid": "0a8f3e8de2d635ab2dcc7d71bea4da1db35a743a", "url": "https://github.com/aws-amplify/amplify-android/commit/0a8f3e8de2d635ab2dcc7d71bea4da1db35a743a", "message": "publish each cascading delete", "committedDate": "2020-12-17T01:21:29Z", "type": "commit"}, {"oid": "6e07debee203e3903e616dedba34fc0c6eecce83", "url": "https://github.com/aws-amplify/amplify-android/commit/6e07debee203e3903e616dedba34fc0c6eecce83", "message": "Merge branch 'main' of https://github.com/aws-amplify/amplify-android into publish-cascading-delete", "committedDate": "2020-12-21T21:02:43Z", "type": "commit"}, {"oid": "4ecc894bb677e59d245a3029b8b5b7f8f827510d", "url": "https://github.com/aws-amplify/amplify-android/commit/4ecc894bb677e59d245a3029b8b5b7f8f827510d", "message": "add match none query predicate", "committedDate": "2020-12-23T01:02:31Z", "type": "commit"}, {"oid": "ba6247719205fbff02ac71c895398e8186d4971b", "url": "https://github.com/aws-amplify/amplify-android/commit/ba6247719205fbff02ac71c895398e8186d4971b", "message": "move model tree traversing logic out of sqlite storage adapter", "committedDate": "2020-12-23T01:02:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcxOTI1OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r547719259", "bodyText": "Can this be private?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Cursor getQueryAllCursor(@NonNull String tableName,\n          \n          \n            \n                private Cursor getQueryAllCursor(@NonNull String tableName,", "author": "jamesonwilliams", "createdAt": "2020-12-23T06:46:13Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapter.java", "diffHunk": "@@ -941,7 +876,6 @@ private String getModelName(@NonNull Model model) {\n     }\n \n     @SuppressWarnings(\"WeakerAccess\")\n-    @VisibleForTesting\n     Cursor getQueryAllCursor(@NonNull String tableName,", "originalCommit": "ba6247719205fbff02ac71c895398e8186d4971b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcxOTg0Mw==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r547719843", "bodyText": "Can we get these relationship strings into an enum somewhere?\nAlso, the contents of the case statements looks like a good candidate for some smaller helper method(s). That will also help to reduce the nesting.", "author": "jamesonwilliams", "createdAt": "2020-12-23T06:46:54Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/ModelTreeHelper.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelAssociation;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.query.QueryOptions;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.core.model.query.predicate.QueryField;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicate;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicateOperation;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicates;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.util.Empty;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Utility class to help traverse a tree of models by relationship.\n+ */\n+final class ModelTreeHelper {\n+    private final ModelSchemaRegistry registry;\n+    private final SQLiteStorageAdapter storage;\n+\n+    /**\n+     * Constructs a model family tree traversing utility.\n+     * @param registry model registry to search schema from\n+     * @param storage SQLite storage engine\n+     */\n+    ModelTreeHelper(ModelSchemaRegistry registry,\n+                    SQLiteStorageAdapter storage) {\n+        this.registry = registry;\n+        this.storage = storage;\n+    }\n+\n+    /**\n+     * Returns a map of descendants of a set of models (of same type).\n+     * A model is a child of its parent if it uses its parent's ID as foreign key.\n+     * @param root Collection of models to query its descendants of.\n+     * @return Map of descendants keyed by model schema. The value contains a set of\n+     *          descendants' IDs for that model type.\n+     */\n+    <T extends Model> Map<ModelSchema, Set<String>> descendantsOf(Collection<T> root) {\n+        if (Empty.check(root)) {\n+            throw new IllegalArgumentException(\"Cannot traverse tree from an empty root.\");\n+        }\n+        Map<ModelSchema, Set<String>> descendants = new LinkedHashMap<>();\n+        ModelSchema rootSchema = registry.getModelSchemaForModelInstance(root.iterator().next());\n+        Set<String> rootIds = new HashSet<>();\n+        for (T model : root) {\n+            rootIds.add(model.getId());\n+        }\n+        recurseTree(descendants, rootSchema, rootIds);\n+        return descendants;\n+    }\n+\n+    private void recurseTree(\n+            Map<ModelSchema, Set<String>> tree,\n+            ModelSchema modelSchema,\n+            Collection<String> parentIds\n+    ) {\n+        SQLiteTable parentTable = SQLiteTable.fromSchema(modelSchema);\n+        for (ModelAssociation association : modelSchema.getAssociations().values()) {\n+            switch (association.getName()) {\n+                case \"HasOne\":\n+                case \"HasMany\":", "originalCommit": "ba6247719205fbff02ac71c895398e8186d4971b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEzNjQ1OA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552136458", "bodyText": "The content of the case statement does feel long, but I believe it may be even more difficult to follow if they are comparmentalized into helper methods. With how many local variables there are being used in each step, it will become messier to try to move them away from the main body.", "author": "raphkim", "createdAt": "2021-01-05T19:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcxOTg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcyMTIzNQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r547721235", "bodyText": "This SQLiteStorageAdapter looks like a bad coupling. The adapter owns a model tree helper, and the model tree helper owns a storage. But in reality, you're only ever using it to access a SQL cursor. So, a step better would be to pass just that, directly.", "author": "jamesonwilliams", "createdAt": "2020-12-23T06:48:54Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/ModelTreeHelper.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelAssociation;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.query.QueryOptions;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.core.model.query.predicate.QueryField;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicate;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicateOperation;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicates;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.util.Empty;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Utility class to help traverse a tree of models by relationship.\n+ */\n+final class ModelTreeHelper {\n+    private final ModelSchemaRegistry registry;\n+    private final SQLiteStorageAdapter storage;\n+\n+    /**\n+     * Constructs a model family tree traversing utility.\n+     * @param registry model registry to search schema from\n+     * @param storage SQLite storage engine\n+     */\n+    ModelTreeHelper(ModelSchemaRegistry registry,\n+                    SQLiteStorageAdapter storage) {", "originalCommit": "ba6247719205fbff02ac71c895398e8186d4971b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc3MjkxMQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r551772911", "bodyText": "Replaced storage adapter with database handle.", "author": "raphkim", "createdAt": "2021-01-05T08:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcyMTIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcyMTg2NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r547721864", "bodyText": "Now that you have this in its own unit, it will be a lot easier to write a unit test!\n\nSQLiteModelTree?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            final class ModelTreeHelper {\n          \n          \n            \n            final class SQLiteModelTree {", "author": "jamesonwilliams", "createdAt": "2020-12-23T06:49:46Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/ModelTreeHelper.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelAssociation;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.query.QueryOptions;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.core.model.query.predicate.QueryField;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicate;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicateOperation;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicates;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.util.Empty;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Utility class to help traverse a tree of models by relationship.\n+ */\n+final class ModelTreeHelper {", "originalCommit": "ba6247719205fbff02ac71c895398e8186d4971b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcyMzU5MQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r547723591", "bodyText": "This type still kind of looks like a data structure in-and-of itself. You could make a class Descendent, and then return a List<Descendent>, here.\n    Map<ModelSchema, Set<String>>\n\nAny Map other than Map<PrimitiveA, PrimitiveB> is usually waiting to be made into a complex type of its own.", "author": "jamesonwilliams", "createdAt": "2020-12-23T06:52:19Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/ModelTreeHelper.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelAssociation;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.query.QueryOptions;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.core.model.query.predicate.QueryField;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicate;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicateOperation;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicates;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.util.Empty;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Utility class to help traverse a tree of models by relationship.\n+ */\n+final class ModelTreeHelper {\n+    private final ModelSchemaRegistry registry;\n+    private final SQLiteStorageAdapter storage;\n+\n+    /**\n+     * Constructs a model family tree traversing utility.\n+     * @param registry model registry to search schema from\n+     * @param storage SQLite storage engine\n+     */\n+    ModelTreeHelper(ModelSchemaRegistry registry,\n+                    SQLiteStorageAdapter storage) {\n+        this.registry = registry;\n+        this.storage = storage;\n+    }\n+\n+    /**\n+     * Returns a map of descendants of a set of models (of same type).\n+     * A model is a child of its parent if it uses its parent's ID as foreign key.\n+     * @param root Collection of models to query its descendants of.\n+     * @return Map of descendants keyed by model schema. The value contains a set of\n+     *          descendants' IDs for that model type.\n+     */\n+    <T extends Model> Map<ModelSchema, Set<String>> descendantsOf(Collection<T> root) {", "originalCommit": "ba6247719205fbff02ac71c895398e8186d4971b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc3MjgxNA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r551772814", "bodyText": "I still do need to be able to search for the set of IDs by model, which warrants the use of a map. Only way to simplify this further would be to use Map<PrimitiveA, NewType> where NewType wraps a set, but that would be an overkill. I think a \"Map of Collections\" is an intuitive enough data structure that it won't need another level of simplification.", "author": "raphkim", "createdAt": "2021-01-05T08:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcyMzU5MQ=="}], "type": "inlineReview"}, {"oid": "9fdac6d167b2092ab04c8abb3a21734427767597", "url": "https://github.com/aws-amplify/amplify-android/commit/9fdac6d167b2092ab04c8abb3a21734427767597", "message": "address pr comments", "committedDate": "2021-01-05T09:17:16Z", "type": "commit"}, {"oid": "0889f70447823b7eef7931baac75f6aedd2ebe85", "url": "https://github.com/aws-amplify/amplify-android/commit/0889f70447823b7eef7931baac75f6aedd2ebe85", "message": "Merge branch 'main' of https://github.com/aws-amplify/amplify-android into publish-cascading-delete", "committedDate": "2021-01-05T09:55:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE2ODU5OA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552168598", "bodyText": "Quotes around %s?", "author": "richardmcclellan", "createdAt": "2021-01-05T20:13:07Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapter.java", "diffHunk": "@@ -503,47 +515,28 @@ public void query(\n                     return;\n                 }\n \n-                LOG.debug(\"Deleting item in table: \" + sqliteTable.getName() +\n-                    \" identified by ID: \" + item.getId());\n-\n-                // delete always checks for ID first\n-                final QueryPredicateOperation<?> idCheck =\n-                    QueryField.field(primaryKeyName).eq(item.getId());\n-                final QueryPredicate condition = !QueryPredicates.all().equals(predicate)\n-                    ? idCheck.and(predicate)\n-                    : idCheck;\n-                final SqlCommand sqlCommand = sqlCommandFactory.deleteFor(modelSchema, condition);\n-                if (sqlCommand.sqlStatement() == null || !sqlCommand.hasCompiledSqlStatement()) {\n-                    onError.accept(new DataStoreException(\n-                        \"No delete statement found for the Model: \" + modelSchema.getName(),\n-                        AmplifyException.TODO_RECOVERY_SUGGESTION\n-                    ));\n-                    return;\n-                }\n-\n-                synchronized (sqlCommand.getCompiledSqlStatement()) {\n-                    final SQLiteStatement compiledSqlStatement = sqlCommand.getCompiledSqlStatement();\n-                    compiledSqlStatement.clearBindings();\n-                    bindStatementToValues(sqlCommand, null);\n-                    // executeUpdateDelete returns the number of rows affected.\n-                    final int rowsDeleted = compiledSqlStatement.executeUpdateDelete();\n-                    compiledSqlStatement.clearBindings();\n-                    if (rowsDeleted == 0) {\n-                        throw new DataStoreException(\n-                            \"Failed to meet condition. Model was not deleted.\",\n-                            \"Please verify the current state of saved item.\"\n-                        );\n+                // Use ModelTreeHelper to identify the models affected by cascading delete.\n+                Map<ModelSchema, Set<String>> modelFamilyTree =\n+                        sqLiteModelTree.descendantsOf(Collections.singleton(item));\n+\n+                for (ModelSchema schema : modelFamilyTree.keySet()) {\n+                    for (String id : modelFamilyTree.get(schema)) {\n+                        // Publish DELETE mutation for each affected item.\n+                        String dummyJson = String.format(\"{\\\"id\\\":%s}\", id);", "originalCommit": "0889f70447823b7eef7931baac75f6aedd2ebe85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4NDI5Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552184296", "bodyText": "Actually, instead of manually writing JSON, create a Map, and then use gson to convert it to a String, like this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    String dummyJson = String.format(\"{\\\"id\\\":%s}\", id);\n          \n          \n            \n                                    String dummyJson = gson.toJson(Collections.singletonMap(\"id\", id));", "author": "richardmcclellan", "createdAt": "2021-01-05T20:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE2ODU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyMTMzMQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552921331", "bodyText": "clever! I prefer this approach more.", "author": "raphkim", "createdAt": "2021-01-06T19:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE2ODU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5NTIwOA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552195208", "bodyText": "Does this method need to take a Collection<T>?  It looks like it is only ever taking a Collection of 1 item, so maybe you could just pass a T here?", "author": "richardmcclellan", "createdAt": "2021-01-05T21:07:53Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelTree.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelAssociation;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.query.QueryOptions;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.core.model.query.predicate.QueryField;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicate;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicateOperation;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicates;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.util.Empty;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Utility class to help traverse a tree of models by relationship.\n+ */\n+final class SQLiteModelTree {\n+    private final ModelSchemaRegistry registry;\n+    private final SQLCommandFactory commandFactory;\n+    private final SQLiteDatabase database;\n+\n+    /**\n+     * Constructs a model family tree traversing utility.\n+     * @param registry model registry to search schema from\n+     * @param commandFactory SQL command factory\n+     * @param database SQLite database connection handle\n+     */\n+    SQLiteModelTree(ModelSchemaRegistry registry,\n+                    SQLCommandFactory commandFactory,\n+                    SQLiteDatabase database) {\n+        this.registry = registry;\n+        this.commandFactory = commandFactory;\n+        this.database = database;\n+    }\n+\n+    /**\n+     * Returns a map of descendants of a set of models (of same type).\n+     * A model is a child of its parent if it uses its parent's ID as foreign key.\n+     * @param root Collection of models to query its descendants of.\n+     * @return Map of descendants keyed by model schema. The value contains a set of\n+     *          descendants' IDs for that model type.\n+     */\n+    <T extends Model> Map<ModelSchema, Set<String>> descendantsOf(Collection<T> root) {", "originalCommit": "0889f70447823b7eef7931baac75f6aedd2ebe85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2MzIyOA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552263228", "bodyText": "I want to reuse this algorithm when implementing 1..n deletion, which also needs to account for publishing cascaded deletes.", "author": "raphkim", "createdAt": "2021-01-05T23:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5NTIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5ODgwMg==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552198802", "bodyText": "Instead of a raw String here, could you do HasOne.class.getSimpleName()? (and similar for HasMany, and BelongsTo?", "author": "richardmcclellan", "createdAt": "2021-01-05T21:15:19Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelTree.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelAssociation;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.query.QueryOptions;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.core.model.query.predicate.QueryField;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicate;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicateOperation;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicates;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.util.Empty;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Utility class to help traverse a tree of models by relationship.\n+ */\n+final class SQLiteModelTree {\n+    private final ModelSchemaRegistry registry;\n+    private final SQLCommandFactory commandFactory;\n+    private final SQLiteDatabase database;\n+\n+    /**\n+     * Constructs a model family tree traversing utility.\n+     * @param registry model registry to search schema from\n+     * @param commandFactory SQL command factory\n+     * @param database SQLite database connection handle\n+     */\n+    SQLiteModelTree(ModelSchemaRegistry registry,\n+                    SQLCommandFactory commandFactory,\n+                    SQLiteDatabase database) {\n+        this.registry = registry;\n+        this.commandFactory = commandFactory;\n+        this.database = database;\n+    }\n+\n+    /**\n+     * Returns a map of descendants of a set of models (of same type).\n+     * A model is a child of its parent if it uses its parent's ID as foreign key.\n+     * @param root Collection of models to query its descendants of.\n+     * @return Map of descendants keyed by model schema. The value contains a set of\n+     *          descendants' IDs for that model type.\n+     */\n+    <T extends Model> Map<ModelSchema, Set<String>> descendantsOf(Collection<T> root) {\n+        if (Empty.check(root)) {\n+            throw new IllegalArgumentException(\"Cannot traverse tree from an empty root.\");\n+        }\n+        Map<ModelSchema, Set<String>> descendants = new LinkedHashMap<>();\n+        ModelSchema rootSchema = registry.getModelSchemaForModelInstance(root.iterator().next());\n+        Set<String> rootIds = new HashSet<>();\n+        for (T model : root) {\n+            rootIds.add(model.getId());\n+        }\n+        recurseTree(descendants, rootSchema, rootIds);\n+        return descendants;\n+    }\n+\n+    private void recurseTree(\n+            Map<ModelSchema, Set<String>> tree,\n+            ModelSchema modelSchema,\n+            Collection<String> parentIds\n+    ) {\n+        SQLiteTable parentTable = SQLiteTable.fromSchema(modelSchema);\n+        for (ModelAssociation association : modelSchema.getAssociations().values()) {\n+            switch (association.getName()) {\n+                case \"HasOne\":", "originalCommit": "0889f70447823b7eef7931baac75f6aedd2ebe85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1NjA5MQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552256091", "bodyText": "Java compiler doesn't allow that because it needs to be a simple constant value", "author": "raphkim", "createdAt": "2021-01-05T23:18:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5ODgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxMzEzMg==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552213132", "bodyText": "Can you add a test that exercises this predicate building logic?  I think your current test is too simple to verify it.   Maybe add another test that deletes a Blog, which has 3 Posts, each of which has 3 Comments, and then verify that a total of 13 StorageItemChange items are observed?", "author": "richardmcclellan", "createdAt": "2021-01-05T21:34:56Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelTree.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelAssociation;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.query.QueryOptions;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.core.model.query.predicate.QueryField;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicate;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicateOperation;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicates;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.util.Empty;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Utility class to help traverse a tree of models by relationship.\n+ */\n+final class SQLiteModelTree {\n+    private final ModelSchemaRegistry registry;\n+    private final SQLCommandFactory commandFactory;\n+    private final SQLiteDatabase database;\n+\n+    /**\n+     * Constructs a model family tree traversing utility.\n+     * @param registry model registry to search schema from\n+     * @param commandFactory SQL command factory\n+     * @param database SQLite database connection handle\n+     */\n+    SQLiteModelTree(ModelSchemaRegistry registry,\n+                    SQLCommandFactory commandFactory,\n+                    SQLiteDatabase database) {\n+        this.registry = registry;\n+        this.commandFactory = commandFactory;\n+        this.database = database;\n+    }\n+\n+    /**\n+     * Returns a map of descendants of a set of models (of same type).\n+     * A model is a child of its parent if it uses its parent's ID as foreign key.\n+     * @param root Collection of models to query its descendants of.\n+     * @return Map of descendants keyed by model schema. The value contains a set of\n+     *          descendants' IDs for that model type.\n+     */\n+    <T extends Model> Map<ModelSchema, Set<String>> descendantsOf(Collection<T> root) {\n+        if (Empty.check(root)) {\n+            throw new IllegalArgumentException(\"Cannot traverse tree from an empty root.\");\n+        }\n+        Map<ModelSchema, Set<String>> descendants = new LinkedHashMap<>();\n+        ModelSchema rootSchema = registry.getModelSchemaForModelInstance(root.iterator().next());\n+        Set<String> rootIds = new HashSet<>();\n+        for (T model : root) {\n+            rootIds.add(model.getId());\n+        }\n+        recurseTree(descendants, rootSchema, rootIds);\n+        return descendants;\n+    }\n+\n+    private void recurseTree(\n+            Map<ModelSchema, Set<String>> tree,\n+            ModelSchema modelSchema,\n+            Collection<String> parentIds\n+    ) {\n+        SQLiteTable parentTable = SQLiteTable.fromSchema(modelSchema);\n+        for (ModelAssociation association : modelSchema.getAssociations().values()) {\n+            switch (association.getName()) {\n+                case \"HasOne\":\n+                case \"HasMany\":\n+                    String childModel = association.getAssociatedType(); // model name\n+                    ModelSchema childSchema = registry.getModelSchemaForModelClass(childModel);\n+                    SQLiteTable childTable = SQLiteTable.fromSchema(childSchema);\n+                    String childPrimaryKey = childTable.getPrimaryKey().getAliasedName();\n+                    QueryField queryField = QueryField.field(parentTable.getPrimaryKeyColumnName());\n+\n+                    // Chain predicates with OR operator.", "originalCommit": "0889f70447823b7eef7931baac75f6aedd2ebe85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNzIyMQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552217221", "bodyText": "Does this need to be a LinkedHashMap, or would a regular HashMap work the same way?", "author": "richardmcclellan", "createdAt": "2021-01-05T21:43:35Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelTree.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelAssociation;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.query.QueryOptions;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.core.model.query.predicate.QueryField;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicate;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicateOperation;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicates;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.util.Empty;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Utility class to help traverse a tree of models by relationship.\n+ */\n+final class SQLiteModelTree {\n+    private final ModelSchemaRegistry registry;\n+    private final SQLCommandFactory commandFactory;\n+    private final SQLiteDatabase database;\n+\n+    /**\n+     * Constructs a model family tree traversing utility.\n+     * @param registry model registry to search schema from\n+     * @param commandFactory SQL command factory\n+     * @param database SQLite database connection handle\n+     */\n+    SQLiteModelTree(ModelSchemaRegistry registry,\n+                    SQLCommandFactory commandFactory,\n+                    SQLiteDatabase database) {\n+        this.registry = registry;\n+        this.commandFactory = commandFactory;\n+        this.database = database;\n+    }\n+\n+    /**\n+     * Returns a map of descendants of a set of models (of same type).\n+     * A model is a child of its parent if it uses its parent's ID as foreign key.\n+     * @param root Collection of models to query its descendants of.\n+     * @return Map of descendants keyed by model schema. The value contains a set of\n+     *          descendants' IDs for that model type.\n+     */\n+    <T extends Model> Map<ModelSchema, Set<String>> descendantsOf(Collection<T> root) {\n+        if (Empty.check(root)) {\n+            throw new IllegalArgumentException(\"Cannot traverse tree from an empty root.\");\n+        }\n+        Map<ModelSchema, Set<String>> descendants = new LinkedHashMap<>();", "originalCommit": "0889f70447823b7eef7931baac75f6aedd2ebe85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2MzkyNQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552263925", "bodyText": "Ah, I used to think the order matters, but later realized that the order does not matter. I don't think it's a big deal anyways, and it is nice that the map happens to present the entries in the order of generation.", "author": "raphkim", "createdAt": "2021-01-05T23:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNzIyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2ODQwOQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552268409", "bodyText": "Fair point.  The fact that it is ordered makes it deterministic, which might make unit tests easier to write.", "author": "richardmcclellan", "createdAt": "2021-01-05T23:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxNzIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyMTY3OA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552221678", "bodyText": "Looks like this will only be thrown if SQLPredicate::parsePredicate encounters a QueryPredicate that it can't parse, which should only happen if there is a bug in the library.  Wouldn't it be better to throw an exception back to the user, so they can report the bug to us, instead of failing silently?", "author": "richardmcclellan", "createdAt": "2021-01-05T21:53:35Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelTree.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelAssociation;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.query.QueryOptions;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.core.model.query.predicate.QueryField;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicate;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicateOperation;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicates;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.util.Empty;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Utility class to help traverse a tree of models by relationship.\n+ */\n+final class SQLiteModelTree {\n+    private final ModelSchemaRegistry registry;\n+    private final SQLCommandFactory commandFactory;\n+    private final SQLiteDatabase database;\n+\n+    /**\n+     * Constructs a model family tree traversing utility.\n+     * @param registry model registry to search schema from\n+     * @param commandFactory SQL command factory\n+     * @param database SQLite database connection handle\n+     */\n+    SQLiteModelTree(ModelSchemaRegistry registry,\n+                    SQLCommandFactory commandFactory,\n+                    SQLiteDatabase database) {\n+        this.registry = registry;\n+        this.commandFactory = commandFactory;\n+        this.database = database;\n+    }\n+\n+    /**\n+     * Returns a map of descendants of a set of models (of same type).\n+     * A model is a child of its parent if it uses its parent's ID as foreign key.\n+     * @param root Collection of models to query its descendants of.\n+     * @return Map of descendants keyed by model schema. The value contains a set of\n+     *          descendants' IDs for that model type.\n+     */\n+    <T extends Model> Map<ModelSchema, Set<String>> descendantsOf(Collection<T> root) {\n+        if (Empty.check(root)) {\n+            throw new IllegalArgumentException(\"Cannot traverse tree from an empty root.\");\n+        }\n+        Map<ModelSchema, Set<String>> descendants = new LinkedHashMap<>();\n+        ModelSchema rootSchema = registry.getModelSchemaForModelInstance(root.iterator().next());\n+        Set<String> rootIds = new HashSet<>();\n+        for (T model : root) {\n+            rootIds.add(model.getId());\n+        }\n+        recurseTree(descendants, rootSchema, rootIds);\n+        return descendants;\n+    }\n+\n+    private void recurseTree(\n+            Map<ModelSchema, Set<String>> tree,\n+            ModelSchema modelSchema,\n+            Collection<String> parentIds\n+    ) {\n+        SQLiteTable parentTable = SQLiteTable.fromSchema(modelSchema);\n+        for (ModelAssociation association : modelSchema.getAssociations().values()) {\n+            switch (association.getName()) {\n+                case \"HasOne\":\n+                case \"HasMany\":\n+                    String childModel = association.getAssociatedType(); // model name\n+                    ModelSchema childSchema = registry.getModelSchemaForModelClass(childModel);\n+                    SQLiteTable childTable = SQLiteTable.fromSchema(childSchema);\n+                    String childPrimaryKey = childTable.getPrimaryKey().getAliasedName();\n+                    QueryField queryField = QueryField.field(parentTable.getPrimaryKeyColumnName());\n+\n+                    // Chain predicates with OR operator.\n+                    // No predicate = Match NONE.\n+                    // 1 predicate = Match SELF.\n+                    // 2 or more predicates = Match ANY.\n+                    QueryPredicate predicate = QueryPredicates.none();\n+                    for (String parentId : parentIds) {\n+                        QueryPredicateOperation<Object> operation = queryField.eq(parentId);\n+                        if (QueryPredicates.none().equals(predicate)) {\n+                            predicate = operation;\n+                        } else {\n+                            predicate = operation.or(predicate);\n+                        }\n+                    }\n+\n+                    // Collect every children one level deeper than current level\n+                    // SELECT * FROM <CHILD_TABLE> WHERE <PARENT> = <ID_1> OR <PARENT> = <ID_2> OR ...\n+                    QueryOptions options = Where.matches(predicate);\n+                    Set<String> childrenIds = new HashSet<>();\n+                    try (Cursor cursor = queryAll(childModel, options)) {\n+                        if (cursor != null && cursor.moveToFirst()) {\n+                            int index = cursor.getColumnIndexOrThrow(childPrimaryKey);\n+                            do {\n+                                childrenIds.add(cursor.getString(index));\n+                            } while (cursor.moveToNext());\n+                        }\n+                    } catch (DataStoreException exception) {\n+                        // Don't cut the search short. Populate rest of the tree.", "originalCommit": "0889f70447823b7eef7931baac75f6aedd2ebe85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2MDUxOA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552260518", "bodyText": "it can also happen from failure to query the SQLite database, which can result from various situations (cursor size overflow, too many cursors, corrupt row in cursor, etc.). I wanted to ignore these query failures during recursion", "author": "raphkim", "createdAt": "2021-01-05T23:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyMTY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3MjA3Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552272072", "bodyText": "Hmm.  I still think a customer would probably want to know about all of those failures, so they can report them to us, so we can fix those issues.  How about adding a LOG.error here?", "author": "richardmcclellan", "createdAt": "2021-01-06T00:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyMTY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyMjQ2NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552922464", "bodyText": "Sure thing. It's never bad to provide some more insight i guess", "author": "raphkim", "createdAt": "2021-01-06T19:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyMTY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyODA1Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552228056", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    QueryPredicateOperation<Object> operation = queryField.eq(parentId);\n          \n          \n            \n                                    QueryPredicateOperation<String> operation = queryField.eq(parentId);\n          \n      \n    \n    \n  \n\nThis should be the data type of the field being evaluates, which is String for the model id.", "author": "richardmcclellan", "createdAt": "2021-01-05T22:08:10Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelTree.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelAssociation;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.query.QueryOptions;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.core.model.query.predicate.QueryField;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicate;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicateOperation;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicates;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.util.Empty;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Utility class to help traverse a tree of models by relationship.\n+ */\n+final class SQLiteModelTree {\n+    private final ModelSchemaRegistry registry;\n+    private final SQLCommandFactory commandFactory;\n+    private final SQLiteDatabase database;\n+\n+    /**\n+     * Constructs a model family tree traversing utility.\n+     * @param registry model registry to search schema from\n+     * @param commandFactory SQL command factory\n+     * @param database SQLite database connection handle\n+     */\n+    SQLiteModelTree(ModelSchemaRegistry registry,\n+                    SQLCommandFactory commandFactory,\n+                    SQLiteDatabase database) {\n+        this.registry = registry;\n+        this.commandFactory = commandFactory;\n+        this.database = database;\n+    }\n+\n+    /**\n+     * Returns a map of descendants of a set of models (of same type).\n+     * A model is a child of its parent if it uses its parent's ID as foreign key.\n+     * @param root Collection of models to query its descendants of.\n+     * @return Map of descendants keyed by model schema. The value contains a set of\n+     *          descendants' IDs for that model type.\n+     */\n+    <T extends Model> Map<ModelSchema, Set<String>> descendantsOf(Collection<T> root) {\n+        if (Empty.check(root)) {\n+            throw new IllegalArgumentException(\"Cannot traverse tree from an empty root.\");\n+        }\n+        Map<ModelSchema, Set<String>> descendants = new LinkedHashMap<>();\n+        ModelSchema rootSchema = registry.getModelSchemaForModelInstance(root.iterator().next());\n+        Set<String> rootIds = new HashSet<>();\n+        for (T model : root) {\n+            rootIds.add(model.getId());\n+        }\n+        recurseTree(descendants, rootSchema, rootIds);\n+        return descendants;\n+    }\n+\n+    private void recurseTree(\n+            Map<ModelSchema, Set<String>> tree,\n+            ModelSchema modelSchema,\n+            Collection<String> parentIds\n+    ) {\n+        SQLiteTable parentTable = SQLiteTable.fromSchema(modelSchema);\n+        for (ModelAssociation association : modelSchema.getAssociations().values()) {\n+            switch (association.getName()) {\n+                case \"HasOne\":\n+                case \"HasMany\":\n+                    String childModel = association.getAssociatedType(); // model name\n+                    ModelSchema childSchema = registry.getModelSchemaForModelClass(childModel);\n+                    SQLiteTable childTable = SQLiteTable.fromSchema(childSchema);\n+                    String childPrimaryKey = childTable.getPrimaryKey().getAliasedName();\n+                    QueryField queryField = QueryField.field(parentTable.getPrimaryKeyColumnName());\n+\n+                    // Chain predicates with OR operator.\n+                    // No predicate = Match NONE.\n+                    // 1 predicate = Match SELF.\n+                    // 2 or more predicates = Match ANY.\n+                    QueryPredicate predicate = QueryPredicates.none();\n+                    for (String parentId : parentIds) {\n+                        QueryPredicateOperation<Object> operation = queryField.eq(parentId);", "originalCommit": "0889f70447823b7eef7931baac75f6aedd2ebe85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2MTA2MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552261060", "bodyText": "I want to put String there as well, but because QueryField#eq(Object) was originally declared that way, we can't do that. I considered refactoring QueryField class to use generics instead of Object, but that is potentially a breaking change, and also outside of this PR's scope.", "author": "raphkim", "createdAt": "2021-01-05T23:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyODA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjY3MTc0MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552671740", "bodyText": "Got it, makes sense!  I like the idea of refactoring QueryField to use generics as well.  There was a customer recently who tried to pass a String where they should have passed a Temporal.DateTime object.  If QueryField was generic, it would help customers avoid errors like that.  Like you said, it would be a breaking change though.", "author": "richardmcclellan", "createdAt": "2021-01-06T14:39:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyODA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyOTI2Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552229262", "bodyText": "This is just a Map, not a tree, so maybe call it map?.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Map<ModelSchema, Set<String>> tree,\n          \n          \n            \n                        Map<ModelSchema, Set<String>> map,", "author": "richardmcclellan", "createdAt": "2021-01-05T22:10:54Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelTree.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelAssociation;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.query.QueryOptions;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.core.model.query.predicate.QueryField;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicate;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicateOperation;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicates;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.util.Empty;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Utility class to help traverse a tree of models by relationship.\n+ */\n+final class SQLiteModelTree {\n+    private final ModelSchemaRegistry registry;\n+    private final SQLCommandFactory commandFactory;\n+    private final SQLiteDatabase database;\n+\n+    /**\n+     * Constructs a model family tree traversing utility.\n+     * @param registry model registry to search schema from\n+     * @param commandFactory SQL command factory\n+     * @param database SQLite database connection handle\n+     */\n+    SQLiteModelTree(ModelSchemaRegistry registry,\n+                    SQLCommandFactory commandFactory,\n+                    SQLiteDatabase database) {\n+        this.registry = registry;\n+        this.commandFactory = commandFactory;\n+        this.database = database;\n+    }\n+\n+    /**\n+     * Returns a map of descendants of a set of models (of same type).\n+     * A model is a child of its parent if it uses its parent's ID as foreign key.\n+     * @param root Collection of models to query its descendants of.\n+     * @return Map of descendants keyed by model schema. The value contains a set of\n+     *          descendants' IDs for that model type.\n+     */\n+    <T extends Model> Map<ModelSchema, Set<String>> descendantsOf(Collection<T> root) {\n+        if (Empty.check(root)) {\n+            throw new IllegalArgumentException(\"Cannot traverse tree from an empty root.\");\n+        }\n+        Map<ModelSchema, Set<String>> descendants = new LinkedHashMap<>();\n+        ModelSchema rootSchema = registry.getModelSchemaForModelInstance(root.iterator().next());\n+        Set<String> rootIds = new HashSet<>();\n+        for (T model : root) {\n+            rootIds.add(model.getId());\n+        }\n+        recurseTree(descendants, rootSchema, rootIds);\n+        return descendants;\n+    }\n+\n+    private void recurseTree(\n+            Map<ModelSchema, Set<String>> tree,", "originalCommit": "0889f70447823b7eef7931baac75f6aedd2ebe85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyOTM3MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552229370", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // Add queried result to the tree\n          \n          \n            \n                                // Add queried result to the map", "author": "richardmcclellan", "createdAt": "2021-01-05T22:11:08Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteModelTree.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.storage.sqlite;\n+\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import androidx.annotation.NonNull;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.ModelAssociation;\n+import com.amplifyframework.core.model.ModelSchema;\n+import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.core.model.query.QueryOptions;\n+import com.amplifyframework.core.model.query.Where;\n+import com.amplifyframework.core.model.query.predicate.QueryField;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicate;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicateOperation;\n+import com.amplifyframework.core.model.query.predicate.QueryPredicates;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.storage.sqlite.adapter.SQLiteTable;\n+import com.amplifyframework.util.Empty;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Utility class to help traverse a tree of models by relationship.\n+ */\n+final class SQLiteModelTree {\n+    private final ModelSchemaRegistry registry;\n+    private final SQLCommandFactory commandFactory;\n+    private final SQLiteDatabase database;\n+\n+    /**\n+     * Constructs a model family tree traversing utility.\n+     * @param registry model registry to search schema from\n+     * @param commandFactory SQL command factory\n+     * @param database SQLite database connection handle\n+     */\n+    SQLiteModelTree(ModelSchemaRegistry registry,\n+                    SQLCommandFactory commandFactory,\n+                    SQLiteDatabase database) {\n+        this.registry = registry;\n+        this.commandFactory = commandFactory;\n+        this.database = database;\n+    }\n+\n+    /**\n+     * Returns a map of descendants of a set of models (of same type).\n+     * A model is a child of its parent if it uses its parent's ID as foreign key.\n+     * @param root Collection of models to query its descendants of.\n+     * @return Map of descendants keyed by model schema. The value contains a set of\n+     *          descendants' IDs for that model type.\n+     */\n+    <T extends Model> Map<ModelSchema, Set<String>> descendantsOf(Collection<T> root) {\n+        if (Empty.check(root)) {\n+            throw new IllegalArgumentException(\"Cannot traverse tree from an empty root.\");\n+        }\n+        Map<ModelSchema, Set<String>> descendants = new LinkedHashMap<>();\n+        ModelSchema rootSchema = registry.getModelSchemaForModelInstance(root.iterator().next());\n+        Set<String> rootIds = new HashSet<>();\n+        for (T model : root) {\n+            rootIds.add(model.getId());\n+        }\n+        recurseTree(descendants, rootSchema, rootIds);\n+        return descendants;\n+    }\n+\n+    private void recurseTree(\n+            Map<ModelSchema, Set<String>> tree,\n+            ModelSchema modelSchema,\n+            Collection<String> parentIds\n+    ) {\n+        SQLiteTable parentTable = SQLiteTable.fromSchema(modelSchema);\n+        for (ModelAssociation association : modelSchema.getAssociations().values()) {\n+            switch (association.getName()) {\n+                case \"HasOne\":\n+                case \"HasMany\":\n+                    String childModel = association.getAssociatedType(); // model name\n+                    ModelSchema childSchema = registry.getModelSchemaForModelClass(childModel);\n+                    SQLiteTable childTable = SQLiteTable.fromSchema(childSchema);\n+                    String childPrimaryKey = childTable.getPrimaryKey().getAliasedName();\n+                    QueryField queryField = QueryField.field(parentTable.getPrimaryKeyColumnName());\n+\n+                    // Chain predicates with OR operator.\n+                    // No predicate = Match NONE.\n+                    // 1 predicate = Match SELF.\n+                    // 2 or more predicates = Match ANY.\n+                    QueryPredicate predicate = QueryPredicates.none();\n+                    for (String parentId : parentIds) {\n+                        QueryPredicateOperation<Object> operation = queryField.eq(parentId);\n+                        if (QueryPredicates.none().equals(predicate)) {\n+                            predicate = operation;\n+                        } else {\n+                            predicate = operation.or(predicate);\n+                        }\n+                    }\n+\n+                    // Collect every children one level deeper than current level\n+                    // SELECT * FROM <CHILD_TABLE> WHERE <PARENT> = <ID_1> OR <PARENT> = <ID_2> OR ...\n+                    QueryOptions options = Where.matches(predicate);\n+                    Set<String> childrenIds = new HashSet<>();\n+                    try (Cursor cursor = queryAll(childModel, options)) {\n+                        if (cursor != null && cursor.moveToFirst()) {\n+                            int index = cursor.getColumnIndexOrThrow(childPrimaryKey);\n+                            do {\n+                                childrenIds.add(cursor.getString(index));\n+                            } while (cursor.moveToNext());\n+                        }\n+                    } catch (DataStoreException exception) {\n+                        // Don't cut the search short. Populate rest of the tree.\n+                    }\n+\n+                    // Add queried result to the tree", "originalCommit": "0889f70447823b7eef7931baac75f6aedd2ebe85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNzA0MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552237040", "bodyText": "Unrelated to this PR, but this seems wrong.  Shouldn't we not set changeId to anything here, so that StorageItemChange::build just randomly generates one?  From the changeId Javadoc, this is supposed to be a UUID representing this change, not the id of the model that it relates to.\nMaybe this is something that we could follow up on in a separate PR.", "author": "richardmcclellan", "createdAt": "2021-01-05T22:28:18Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapter.java", "diffHunk": "@@ -503,47 +515,28 @@ public void query(\n                     return;\n                 }\n \n-                LOG.debug(\"Deleting item in table: \" + sqliteTable.getName() +\n-                    \" identified by ID: \" + item.getId());\n-\n-                // delete always checks for ID first\n-                final QueryPredicateOperation<?> idCheck =\n-                    QueryField.field(primaryKeyName).eq(item.getId());\n-                final QueryPredicate condition = !QueryPredicates.all().equals(predicate)\n-                    ? idCheck.and(predicate)\n-                    : idCheck;\n-                final SqlCommand sqlCommand = sqlCommandFactory.deleteFor(modelSchema, condition);\n-                if (sqlCommand.sqlStatement() == null || !sqlCommand.hasCompiledSqlStatement()) {\n-                    onError.accept(new DataStoreException(\n-                        \"No delete statement found for the Model: \" + modelSchema.getName(),\n-                        AmplifyException.TODO_RECOVERY_SUGGESTION\n-                    ));\n-                    return;\n-                }\n-\n-                synchronized (sqlCommand.getCompiledSqlStatement()) {\n-                    final SQLiteStatement compiledSqlStatement = sqlCommand.getCompiledSqlStatement();\n-                    compiledSqlStatement.clearBindings();\n-                    bindStatementToValues(sqlCommand, null);\n-                    // executeUpdateDelete returns the number of rows affected.\n-                    final int rowsDeleted = compiledSqlStatement.executeUpdateDelete();\n-                    compiledSqlStatement.clearBindings();\n-                    if (rowsDeleted == 0) {\n-                        throw new DataStoreException(\n-                            \"Failed to meet condition. Model was not deleted.\",\n-                            \"Please verify the current state of saved item.\"\n-                        );\n+                // Use ModelTreeHelper to identify the models affected by cascading delete.\n+                Map<ModelSchema, Set<String>> modelFamilyTree =\n+                        sqLiteModelTree.descendantsOf(Collections.singleton(item));\n+\n+                for (ModelSchema schema : modelFamilyTree.keySet()) {\n+                    for (String id : modelFamilyTree.get(schema)) {\n+                        // Publish DELETE mutation for each affected item.\n+                        String dummyJson = String.format(\"{\\\"id\\\":%s}\", id);\n+                        Model dummyItem = gson.fromJson(dummyJson, schema.getModelClass());\n+                        itemChangeSubject.onNext(StorageItemChange.builder()\n+                                .changeId(id)", "originalCommit": "0889f70447823b7eef7931baac75f6aedd2ebe85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2MjA2Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552262062", "bodyText": "hmm, i also noticed that but it seems that other operations seem to treat change ID as model ID as well. I'll leave it as is for now and we can revisit it later as you said.", "author": "raphkim", "createdAt": "2021-01-05T23:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNzA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzNzU0NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552237544", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"QueryPredicateOperation, QueryPredicateGroup.\"\n          \n          \n            \n                                    \"QueryPredicateOperation, QueryPredicateGroup, MatchAllQueryPredicate, MatchNoneQueryPredicate\"", "author": "richardmcclellan", "createdAt": "2021-01-05T22:29:32Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/adapter/SQLPredicate.java", "diffHunk": "@@ -106,19 +108,25 @@ private void addBinding(Object value) {\n \n     // Utility method to recursively parse a given predicate.\n     private StringBuilder parsePredicate(QueryPredicate queryPredicate) throws DataStoreException {\n+        if (queryPredicate instanceof MatchAllQueryPredicate) {\n+            return new StringBuilder(\"1 = 1\");\n+        }\n+        if (queryPredicate instanceof MatchNoneQueryPredicate) {\n+            return new StringBuilder(\"1 = 0\");\n+        }\n         if (queryPredicate instanceof QueryPredicateOperation) {\n             QueryPredicateOperation<?> qpo = (QueryPredicateOperation) queryPredicate;\n             return parsePredicateOperation(qpo);\n-        } else if (queryPredicate instanceof QueryPredicateGroup) {\n+        }\n+        if (queryPredicate instanceof QueryPredicateGroup) {\n             QueryPredicateGroup qpg = (QueryPredicateGroup) queryPredicate;\n             return parsePredicateGroup(qpg);\n-        } else {\n-            throw new DataStoreException(\n-                    \"Tried to parse an unsupported QueryPredicate\",\n-                    \"Try changing to one of the supported values: \" +\n-                            \"QueryPredicateOperation, QueryPredicateGroup.\"\n-            );\n         }\n+        throw new DataStoreException(\n+                \"Tried to parse an unsupported QueryPredicate\",\n+                \"Try changing to one of the supported values: \" +\n+                        \"QueryPredicateOperation, QueryPredicateGroup.\"", "originalCommit": "0889f70447823b7eef7931baac75f6aedd2ebe85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzODQzMw==", "url": "https://github.com/aws-amplify/amplify-android/pull/1059#discussion_r552238433", "bodyText": "This is a Map not a tree, so maybe just call it descendants or modelFamilyMap or something?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Map<ModelSchema, Set<String>> modelFamilyTree =\n          \n          \n            \n                            Map<ModelSchema, Set<String>> descendants =", "author": "richardmcclellan", "createdAt": "2021-01-05T22:31:41Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/storage/sqlite/SQLiteStorageAdapter.java", "diffHunk": "@@ -503,47 +515,28 @@ public void query(\n                     return;\n                 }\n \n-                LOG.debug(\"Deleting item in table: \" + sqliteTable.getName() +\n-                    \" identified by ID: \" + item.getId());\n-\n-                // delete always checks for ID first\n-                final QueryPredicateOperation<?> idCheck =\n-                    QueryField.field(primaryKeyName).eq(item.getId());\n-                final QueryPredicate condition = !QueryPredicates.all().equals(predicate)\n-                    ? idCheck.and(predicate)\n-                    : idCheck;\n-                final SqlCommand sqlCommand = sqlCommandFactory.deleteFor(modelSchema, condition);\n-                if (sqlCommand.sqlStatement() == null || !sqlCommand.hasCompiledSqlStatement()) {\n-                    onError.accept(new DataStoreException(\n-                        \"No delete statement found for the Model: \" + modelSchema.getName(),\n-                        AmplifyException.TODO_RECOVERY_SUGGESTION\n-                    ));\n-                    return;\n-                }\n-\n-                synchronized (sqlCommand.getCompiledSqlStatement()) {\n-                    final SQLiteStatement compiledSqlStatement = sqlCommand.getCompiledSqlStatement();\n-                    compiledSqlStatement.clearBindings();\n-                    bindStatementToValues(sqlCommand, null);\n-                    // executeUpdateDelete returns the number of rows affected.\n-                    final int rowsDeleted = compiledSqlStatement.executeUpdateDelete();\n-                    compiledSqlStatement.clearBindings();\n-                    if (rowsDeleted == 0) {\n-                        throw new DataStoreException(\n-                            \"Failed to meet condition. Model was not deleted.\",\n-                            \"Please verify the current state of saved item.\"\n-                        );\n+                // Use ModelTreeHelper to identify the models affected by cascading delete.\n+                Map<ModelSchema, Set<String>> modelFamilyTree =", "originalCommit": "0889f70447823b7eef7931baac75f6aedd2ebe85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b080957e2b7ab9f36d54ee118489258ab94fad17", "url": "https://github.com/aws-amplify/amplify-android/commit/b080957e2b7ab9f36d54ee118489258ab94fad17", "message": "address more pr comments", "committedDate": "2021-01-05T23:40:09Z", "type": "commit"}, {"oid": "53d0d52fde32a7d79b77398535fe4b9a723545d4", "url": "https://github.com/aws-amplify/amplify-android/commit/53d0d52fde32a7d79b77398535fe4b9a723545d4", "message": "unused import", "committedDate": "2021-01-05T23:49:47Z", "type": "commit"}, {"oid": "ba4dc0ffc88f8d949bbcfa8b288919345ad8d8b0", "url": "https://github.com/aws-amplify/amplify-android/commit/ba4dc0ffc88f8d949bbcfa8b288919345ad8d8b0", "message": "more pr commments to address", "committedDate": "2021-01-06T19:36:49Z", "type": "commit"}, {"oid": "d32de5628628d89cd7ea887cb875724f9757824b", "url": "https://github.com/aws-amplify/amplify-android/commit/d32de5628628d89cd7ea887cb875724f9757824b", "message": "Merge branch 'main' of https://github.com/aws-amplify/amplify-android into publish-cascading-delete", "committedDate": "2021-01-06T23:41:13Z", "type": "commit"}]}