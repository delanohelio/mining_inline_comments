{"pr_number": 613, "pr_title": "fix(DataStore): use a LinkedList and HashMap to improve the time comp\u2026", "pr_createdAt": "2020-06-28T00:25:06Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/613", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc4OTYzMA==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r446789630", "bodyText": "After your refactor, you have several wrapper methods left inside of PersistentMutationOutbox, which are ~one line long. I would remove these, and just call your dat astructure directly, instead of through these wrapper methods:\n\nupdateExitingQueueItemOrAppendNew\nnextMutationForModelId\nremoveFromQueue\nfindPendingMutationById", "author": "jamesonwilliams", "createdAt": "2020-06-29T06:01:41Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -137,16 +132,7 @@ public boolean hasPendingMutation(@NonNull String modelId) {\n     }\n \n     private <T extends Model> void updateExistingQueueItemOrAppendNew(PendingMutation<T> pendingMutation) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExNTc4Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r447115782", "bodyText": "@jamesonwilliams sure will revise", "author": "richardissuperman", "createdAt": "2020-06-29T16:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc4OTYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MDUyNA==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r446790524", "bodyText": "How about private final MutationQueue mutationQueue, as the data structure's name.", "author": "jamesonwilliams", "createdAt": "2020-06-29T06:04:50Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -55,15 +55,15 @@\n     private static final Logger LOG = Amplify.Logging.forNamespace(\"amplify:aws-datastore\");\n \n     private final LocalStorageAdapter storage;\n-    private final LinkedList<PendingMutation<? extends Model>> mutationQueue;\n+    private final MutationLinkedList mutationQueue;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExNjAyMg==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r447116022", "bodyText": "@jamesonwilliams good call. will revise", "author": "richardissuperman", "createdAt": "2020-06-29T16:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MDUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MTA4Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r446791086", "bodyText": "Should you implement any of the standard Java contracts? extends LinkedHashMap,  implements List, ... implements Comparable<T>, implements Collection<T>, etc.?\n\nAlso for name, I'd use MutationQueue. The PersistentMutationOutbox documentation should be updated to desribe how it differs from a MutationQueue -- that is, the outbox applies (what?) rules about populating the queue, etc.\n\nThis new class should have a corresponding MutationQueueTest.java which tests it as an isolated unit.", "author": "jamesonwilliams", "createdAt": "2020-06-29T06:06:22Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationLinkedList.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.HashMap;\n+\n+/*\n+ * The {@link MutationLinkedList} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ */\n+public class MutationLinkedList {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExNjUyMw==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r447116523", "bodyText": "@jamesonwilliams will add some tests for this new class. I didnt implement collections' interface methods as they are not needed at MutationOutBox's use case, but i can add them", "author": "richardissuperman", "createdAt": "2020-06-29T16:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MTA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MjE5MQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r446792191", "bodyText": "Instead of maintaining your own head and tail, can you use a linked list/map or some kind directly? \"Mutation linked list has a (some type of) list, composed into it?\"", "author": "jamesonwilliams", "createdAt": "2020-06-29T06:09:47Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationLinkedList.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.HashMap;\n+\n+/*\n+ * The {@link MutationLinkedList} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ */\n+public class MutationLinkedList {\n+\n+    private HashMap<TimeBasedUuid, Node> mutationMap = new HashMap<>();\n+    private Node dummyHead = new Node();\n+    private Node dummyTail = new Node();\n+\n+    public MutationLinkedList() {\n+        dummyHead.next = dummyTail;\n+        dummyTail.prev = dummyHead;\n+    }\n+\n+    public synchronized PendingMutation<? extends Model> nextMutationForModelId(String modelId) {\n+        Node head = dummyHead.next;\n+        if (head == dummyTail) {\n+            return null;\n+        }\n+        while (head != dummyTail) {\n+            if (head.mutation.getMutatedItem().getId().equals(modelId)) {\n+                return head.mutation;\n+            }\n+            head = head.next;\n+        }\n+        return null;\n+    }\n+\n+    public synchronized void remove(TimeBasedUuid id) {\n+        if (mutationMap.containsKey(id)) {\n+            Node removingNode = mutationMap.get(id);\n+            Node removingPrev = removingNode.prev;\n+            Node removingNext = removingNode.next;\n+            //remove from map\n+            mutationMap.remove(id);\n+            //remove from current linkedlist\n+            removingPrev.next = removingNext;\n+            removingNext.prev = removingPrev;\n+        }\n+    }\n+\n+    public synchronized void clear() {\n+        dummyHead.next = dummyTail;\n+        dummyTail.prev = dummyHead;\n+        mutationMap.clear();\n+    }\n+\n+    public synchronized boolean isEmpty() {\n+        return mutationMap.isEmpty();\n+    }\n+\n+    public synchronized void addLast(PendingMutation<? extends Model> pendingMutation) {\n+        //constructing a new node\n+        Node pendingNode = new Node();\n+        pendingNode.id = pendingMutation.getMutationId();\n+        pendingNode.mutation = pendingMutation;\n+        //insert the new node into the current linkedlist\n+        Node addingPrev = dummyTail.prev;\n+        addingPrev.next = pendingNode;\n+        dummyTail.prev = pendingNode;\n+        pendingNode.prev = addingPrev;\n+        pendingNode.next = dummyTail;\n+        //put the mutation into the mutationmap\n+        mutationMap.put(pendingMutation.getMutationId(), pendingNode);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExOTgyMg==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r447119822", "bodyText": "@jamesonwilliams i was thinking about using LinkedListHashMap which internally does the same thing as my new data structure , but LinkedListHashMap doesnt expose the api to iterate the linkedlist from head to tail. Also same for LinkedList java standard implementation , if you try to remove it it will traverse through the entire LinkedList and find the target which is again O(N) time complexity.\nThis data structure is actually inspired by a leetcode question i did before:\nhttps://leetcode.com/problems/lru-cache/\nIts for LRU cache but does the same thing.", "author": "richardissuperman", "createdAt": "2020-06-29T17:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MjE5MQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExMzc0OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448113749", "bodyText": "^ Please include standard copyright header (same for any new file in this PR.)", "author": "jamesonwilliams", "createdAt": "2020-07-01T04:50:51Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNDM5MQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448114391", "bodyText": "A better pattern in test code would be:\n@Before\npublic void setup() {\n    this.mutationQueue = new MutationQueue(...);\n    this.outbox = new MutationOutbox(..., mutationQueue, ...);\n}\n\n@Test\npublic void someTest() {\n    // Access the queue directly instead of exposing a getter on the outbox\n    mutationQueue.doSomething();\n}", "author": "jamesonwilliams", "createdAt": "2020-07-01T04:53:36Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutboxTest.java", "diffHunk": "@@ -764,7 +764,7 @@ public void nextItemForModelIdReturnsFirstEnqueued() throws DataStoreException {\n \n         assertEquals(\n             firstMutation,\n-            mutationOutbox.nextMutationForModelId(originalJoe.getId())\n+            mutationOutbox.getMutationQueue().nextMutationForModelId(originalJoe.getId())", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3NTM0Mw==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448675343", "bodyText": "@jamesonwilliams agree this is a better pattern, especially when it comes to dependency injection in testing, but it requires us to update the constructor which is a breaking change to all its consumers.  It also make all its consumer import the MutationQueue class hence couple with it, which those consumers may not even care about. Let me know what you think,", "author": "richardissuperman", "createdAt": "2020-07-01T23:57:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNDM5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4MTUxNg==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448681516", "bodyText": "but it requires us to update the constructor which is a breaking change to all its consumers. It also make all its consumer import the MutationQueue class hence couple with it, which those consumers may not even care about.\n\nfinal class Foo {\n    private final Dependency dependency;\n\n    Foo() {\n        this(new ProductionConfiguredDependency());\n    }\n\n    @VisibleForTesting\n    Foo(Dependency dependency) {\n        this.dependency = dependency;\n    }\n}\n\nfinal class Bar {\n    private final Foo foo;\n\n    Bar() {\n        this.foo = new Foo();\n    }\n}\n\npublic final class FooTest {\n    @Before public void setup() {\n        this.mockDependency = mock(Dependency.class);\n        this.foo = new Foo(mockDependency);\n    }\n}", "author": "jamesonwilliams", "createdAt": "2020-07-02T00:21:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNDM5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5MzYyMQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448693621", "bodyText": "@jamesonwilliams revise as suggested", "author": "richardissuperman", "createdAt": "2020-07-02T01:09:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNDM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNDkyOA==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448114928", "bodyText": "I believe the checkstyle will want a separate import group between java.* and io.*. You can check by running ./gradlew check. Our build treats checkstyle issues as errors, not warnings.", "author": "jamesonwilliams", "createdAt": "2020-07-01T04:55:37Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import io.reactivex.Observable;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5MzU3NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448693574", "bodyText": "@jamesonwilliams thanks, have revised all the checkstyle erros", "author": "richardissuperman", "createdAt": "2020-07-02T01:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNDkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTIwNQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448115205", "bodyText": "minor: by convention, the rest of the code base separates declaration and assignment. So, these assignments would be moved to the constructor, to match the existing code style.\nAll of these variables can be marked as final.\nThe mutationMap can be just a private final Map<TimeBasedUuid, Node> mutationMap unless you need some special functionality of the HashMap when you interact with it, in particular.", "author": "jamesonwilliams", "createdAt": "2020-07-01T04:56:49Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import io.reactivex.Observable;\n+import io.reactivex.functions.Function;\n+\n+/*\n+ * The {@link MutationQueue} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ *\n+ * MutationQueue is implementing the Queue interface and provide most of the queue operations,\n+ */\n+public class MutationQueue implements Queue<PendingMutation<? extends Model>> {\n+\n+    private HashMap<TimeBasedUuid, Node> mutationMap = new HashMap<>();\n+    private Node dummyHead = new Node();\n+    private Node dummyTail = new Node();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3NTU1Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448675556", "bodyText": "@jamesonwilliams Make sense, will revise", "author": "richardissuperman", "createdAt": "2020-07-01T23:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTU3MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448115570", "bodyText": "Capital F, end with .. Fill out @param and @return -- same for all.", "author": "jamesonwilliams", "createdAt": "2020-07-01T04:58:21Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import io.reactivex.Observable;\n+import io.reactivex.functions.Function;\n+\n+/*\n+ * The {@link MutationQueue} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ *\n+ * MutationQueue is implementing the Queue interface and provide most of the queue operations,\n+ */\n+public class MutationQueue implements Queue<PendingMutation<? extends Model>> {\n+\n+    private HashMap<TimeBasedUuid, Node> mutationMap = new HashMap<>();\n+    private Node dummyHead = new Node();\n+    private Node dummyTail = new Node();\n+\n+    public MutationQueue() {\n+        dummyHead.next = dummyTail;\n+        dummyTail.prev = dummyHead;\n+    }\n+\n+    /**\n+     * find the first Pending Mutation which its model has the same id", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTc2MQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448115761", "bodyText": "I would invert this, to be:\nif (!mutationMap.containsKey(id)) {\n    return false;\n}\n// Save 4 columns for the remainder ....\nreturn true;", "author": "jamesonwilliams", "createdAt": "2020-07-01T04:59:16Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import io.reactivex.Observable;\n+import io.reactivex.functions.Function;\n+\n+/*\n+ * The {@link MutationQueue} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ *\n+ * MutationQueue is implementing the Queue interface and provide most of the queue operations,\n+ */\n+public class MutationQueue implements Queue<PendingMutation<? extends Model>> {\n+\n+    private HashMap<TimeBasedUuid, Node> mutationMap = new HashMap<>();\n+    private Node dummyHead = new Node();\n+    private Node dummyTail = new Node();\n+\n+    public MutationQueue() {\n+        dummyHead.next = dummyTail;\n+        dummyTail.prev = dummyHead;\n+    }\n+\n+    /**\n+     * find the first Pending Mutation which its model has the same id\n+     * @param modelId\n+     * @return\n+     */\n+    public synchronized PendingMutation<? extends Model> nextMutationForModelId(String modelId) {\n+        Node head = dummyHead.next;\n+        if (head == dummyTail) {\n+            return null;\n+        }\n+        while (head != dummyTail) {\n+            if (head.mutation.getMutatedItem().getId().equals(modelId)) {\n+                return head.mutation;\n+            }\n+            head = head.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * remove the {@link PendingMutation} from {@link MutationQueue} by its Id.\n+     * this operation should be consuming constant time\n+     * @param id uuid\n+     * @return\n+     */\n+    public synchronized boolean removeById(TimeBasedUuid id) {\n+        if (mutationMap.containsKey(id)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5MzQ5MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448693490", "bodyText": "@jamesonwilliams revise already", "author": "richardissuperman", "createdAt": "2020-07-02T01:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTg4Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448115886", "bodyText": "You use public in a number of places in this PR. Do you need to? Can you reduce the access to package-private?", "author": "jamesonwilliams", "createdAt": "2020-07-01T04:59:50Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import io.reactivex.Observable;\n+import io.reactivex.functions.Function;\n+\n+/*\n+ * The {@link MutationQueue} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ *\n+ * MutationQueue is implementing the Queue interface and provide most of the queue operations,\n+ */\n+public class MutationQueue implements Queue<PendingMutation<? extends Model>> {\n+\n+    private HashMap<TimeBasedUuid, Node> mutationMap = new HashMap<>();\n+    private Node dummyHead = new Node();\n+    private Node dummyTail = new Node();\n+\n+    public MutationQueue() {\n+        dummyHead.next = dummyTail;\n+        dummyTail.prev = dummyHead;\n+    }\n+\n+    /**\n+     * find the first Pending Mutation which its model has the same id\n+     * @param modelId\n+     * @return\n+     */\n+    public synchronized PendingMutation<? extends Model> nextMutationForModelId(String modelId) {\n+        Node head = dummyHead.next;\n+        if (head == dummyTail) {\n+            return null;\n+        }\n+        while (head != dummyTail) {\n+            if (head.mutation.getMutatedItem().getId().equals(modelId)) {\n+                return head.mutation;\n+            }\n+            head = head.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * remove the {@link PendingMutation} from {@link MutationQueue} by its Id.\n+     * this operation should be consuming constant time\n+     * @param id uuid\n+     * @return\n+     */\n+    public synchronized boolean removeById(TimeBasedUuid id) {\n+        if (mutationMap.containsKey(id)) {\n+            Node removingNode = mutationMap.get(id);\n+            Node removingPrev = removingNode.prev;\n+            Node removingNext = removingNode.next;\n+            //remove from map\n+            mutationMap.remove(id);\n+            //remove from current linkedlist\n+            removingPrev.next = removingNext;\n+            removingNext.prev = removingPrev;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * add a {@link PendingMutation} to the tail of this Queue\n+     * @param pendingMutation\n+     * @return\n+     */\n+    private synchronized boolean addToTail(PendingMutation<? extends Model> pendingMutation) {\n+        //constructing a new node\n+        Node pendingNode = new Node();\n+        pendingNode.id = pendingMutation.getMutationId();\n+        pendingNode.mutation = pendingMutation;\n+        //insert the new node into the current linkedlist\n+        Node addingPrev = dummyTail.prev;\n+        addingPrev.next = pendingNode;\n+        dummyTail.prev = pendingNode;\n+        pendingNode.prev = addingPrev;\n+        pendingNode.next = dummyTail;\n+        //put the mutation into the mutationmap\n+        mutationMap.put(pendingMutation.getMutationId(), pendingNode);\n+        return true;\n+    }\n+\n+    /**\n+     * replace an existing {@link PendingMutation} inside the Queue\n+     * @param id\n+     * @param pendingMutation\n+     */\n+    public synchronized void updateExistingQueueItemOrAppendNew(TimeBasedUuid id, PendingMutation<? extends Model> pendingMutation) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4MTk0NQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448681945", "bodyText": "@jamesonwilliams will revise", "author": "richardissuperman", "createdAt": "2020-07-02T00:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTk2MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448115960", "bodyText": "Can be a final class, most likely.\nThe Queue<...> ends up bringing in a lot of methods, actually. Now that you've investigate that route, do you think they add value? Or not? It was an interesting idea, to implement the Queue interface, but perhaps it is overkill. Particularly if many will just throw an exception.", "author": "jamesonwilliams", "createdAt": "2020-07-01T05:00:02Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.core.model.Model;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Queue;\n+import io.reactivex.Observable;\n+import io.reactivex.functions.Function;\n+\n+/*\n+ * The {@link MutationQueue} is a LinkedHashMap like container , the goal of using this container is to\n+ * achieve O(1) time complexity for both getting a {@link PendingMutation} and update an existing mutation with\n+ * valid id.\n+ *\n+ * MutationQueue is implementing the Queue interface and provide most of the queue operations,\n+ */\n+public class MutationQueue implements Queue<PendingMutation<? extends Model>> {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEzMjMzNw==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r448132337", "bodyText": "@jamesonwilliams  will revise according to your comments, you are actually right that using a Queue interface is a overkill, especially we cant even reference this object in MutationOutBox as a Queue because we need the findMutationById() method to be exposed which is not a standard Queue operation,", "author": "richardissuperman", "createdAt": "2020-07-01T05:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ0NTE2Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r450445167", "bodyText": "@jamesonwilliams made needed change in the latest commit :)", "author": "richardissuperman", "createdAt": "2020-07-06T19:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODExNTk2MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "03e52bc07a0c3c9626a5a23f8da476b4e92db731", "url": "https://github.com/aws-amplify/amplify-android/commit/03e52bc07a0c3c9626a5a23f8da476b4e92db731", "message": "fix(DataStore): use a LinkedList and HashMap to improve the time complexity\n\nPreviously we need to traverse the entire mutation list to perform lots of pending mutation operation, which results in a O(N) time complexity\n\n        updateExistingQueueItemOrAppendNew\n        removeFromQueue\n        findPendingMutationById\n        Use above mentioned data structure to optimise them , which uses O(1) time complexity\n\nAll tests passed.", "committedDate": "2020-08-04T03:42:54Z", "type": "commit"}, {"oid": "23787778f61f2cd76ea04a08b007bf648706f284", "url": "https://github.com/aws-amplify/amplify-android/commit/23787778f61f2cd76ea04a08b007bf648706f284", "message": "fix(DataStore): add unit test class for MutationQueue data structure", "committedDate": "2020-08-04T03:42:54Z", "type": "commit"}, {"oid": "23787778f61f2cd76ea04a08b007bf648706f284", "url": "https://github.com/aws-amplify/amplify-android/commit/23787778f61f2cd76ea04a08b007bf648706f284", "message": "fix(DataStore): add unit test class for MutationQueue data structure", "committedDate": "2020-08-04T03:42:54Z", "type": "forcePushed"}, {"oid": "40baf17e00f03c00d1a8eda8ef97f9f0f190e46c", "url": "https://github.com/aws-amplify/amplify-android/commit/40baf17e00f03c00d1a8eda8ef97f9f0f190e46c", "message": "fix(Auth):  fix a broken unit test, user agent was included in prod code but not in the unit test", "committedDate": "2020-08-04T04:15:53Z", "type": "commit"}, {"oid": "40baf17e00f03c00d1a8eda8ef97f9f0f190e46c", "url": "https://github.com/aws-amplify/amplify-android/commit/40baf17e00f03c00d1a8eda8ef97f9f0f190e46c", "message": "fix(Auth):  fix a broken unit test, user agent was included in prod code but not in the unit test", "committedDate": "2020-08-04T04:15:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ0NjU1OA==", "url": "https://github.com/aws-amplify/amplify-android/pull/613#discussion_r450446558", "bodyText": "2020", "author": "jamesonwilliams", "createdAt": "2020-07-06T19:54:06Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationQueue.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}