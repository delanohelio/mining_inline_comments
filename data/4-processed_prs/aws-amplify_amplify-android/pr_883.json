{"pr_number": 883, "pr_title": "feature(aws-datastore): handle mutation conflicts", "pr_createdAt": "2020-10-07T07:49:21Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/883", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1NDQzMQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501254431", "bodyText": "Could we create an enum with all the error types like iOS?   I had intended to do it when I created AppSyncExtensions, but didn't get that far.", "author": "richardmcclellan", "createdAt": "2020-10-07T19:22:03Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/appsync/ConflictUnhandledError.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.util.Empty;\n+import com.amplifyframework.util.GsonFactory;\n+import com.amplifyframework.util.TypeMaker;\n+\n+import com.google.gson.Gson;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * It is possible for the client and server to have two copies of one logical entity,\n+ * each containing different contents, but each believing that it is the latest\n+ * copy of the data. When the client tries to mutate the server's data, AppSync's response\n+ * may contain a GraphQLError with errorType as ConflictUnhandled.\n+ *\n+ * This ConflictUnhandledError class models that response data.\n+ *\n+ * @param <T> Type of model for which a conflict occurred between client & server versions.\n+ * @see <a href=\"https://docs.aws.amazon.com/appsync/latest/devguide/conflict-detection-and-sync.html#errors\">\n+ *     AppSync Conflict Detection & Sync Errors\n+ *     </a>\n+ */\n+public final class ConflictUnhandledError<T extends Model> {\n+    private final ModelWithMetadata<T> serverVersion;\n+\n+    private ConflictUnhandledError(ModelWithMetadata<T> serverVersion) {\n+        this.serverVersion = serverVersion;\n+    }\n+\n+    /**\n+     * Iterates over a list of GraphQL.Error, checking to see if any of them\n+     * contain 'ConflictUnhandled' as the errorType.\n+     * @param typeOfConflictingData The class of the model experiencing conflict\n+     * @param errors A list of GraphQL errors, as received in response to a mutation\n+     * @param <T> The type of model experiencing conflict, if applicable\n+     * @return A model of the first ConflictUnhandled error found in the GraphQL error list.\n+     *         If there is no ConflictUnhandledError in the list, returns null.\n+     */\n+    @Nullable\n+    public static <T extends Model> ConflictUnhandledError<T> findFirst(\n+            @NonNull Class<T> typeOfConflictingData,\n+            @Nullable List<GraphQLResponse.Error> errors) {\n+        if (Empty.check(errors)) {\n+            return null;\n+        }\n+\n+        Gson gson = GsonFactory.instance();\n+\n+        for (GraphQLResponse.Error error : errors) {\n+            if (Empty.check(error.getExtensions())) {\n+                continue;\n+            }\n+\n+            AppSyncExtensions appSyncExtensions =\n+                new AppSyncExtensions(error.getExtensions());\n+            if (!\"ConflictUnhandled\".equals(appSyncExtensions.getErrorType())) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyNjQyMA==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501526420", "bodyText": "Done!", "author": "jamesonwilliams", "createdAt": "2020-10-08T08:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1NDQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2NDQ0Mw==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501264443", "bodyText": "Neat! \ud83c\udf89", "author": "richardmcclellan", "createdAt": "2020-10-07T19:40:54Z", "path": "testutils/src/main/java/com/amplifyframework/testutils/Varargs.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.testutils;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.util.Immutable;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * A utility to convert an (possibly null) array into\n+ * an immutable list.\n+ */\n+public final class Varargs {\n+    private Varargs() {}\n+\n+    /**\n+     * Converts a (possibly null) array into a non-null (possibly empty) list.\n+     * @param items A possibly null array of items\n+     * @param <T> Type of items in the array\n+     * @return A non-null, possibly empty collection\n+     */\n+    @NonNull\n+    public static <T> List<T> toList(@Nullable T[] items) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2NDk5NQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501264995", "bodyText": "Much needed, looks good.", "author": "richardmcclellan", "createdAt": "2020-10-07T19:41:54Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationProcessor.java", "diffHunk": "@@ -284,4 +371,114 @@ void publish(\n             Consumer<DataStoreException> onFailure\n         );\n     }\n+\n+    static final class Builder implements", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2NTQzOA==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501265438", "bodyText": "Can you change this to take a Builder instead of a bunch of parameters?", "author": "richardmcclellan", "createdAt": "2020-10-07T19:42:48Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationProcessor.java", "diffHunk": "@@ -47,24 +57,40 @@\n     private static final Logger LOG = Amplify.Logging.forNamespace(\"amplify:aws-datastore\");\n     private static final long ITEM_PROCESSING_TIMEOUT_MS = TimeUnit.SECONDS.toMillis(10);\n \n-    private final VersionRepository versionRepository;\n     private final Merger merger;\n-    private final AppSync appSync;\n+    private final VersionRepository versionRepository;\n+    private final SyncTimeRegistry syncTimeRegistry;\n     private final MutationOutbox mutationOutbox;\n+    private final AppSync appSync;\n+    private final DataStoreConfigurationProvider configurationProvider;\n     private final CompositeDisposable ongoingOperationsDisposable;\n \n-    MutationProcessor(\n+    private MutationProcessor(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxMzcyMA==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501513720", "bodyText": "Done!", "author": "jamesonwilliams", "createdAt": "2020-10-08T07:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2NTQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2ODA3NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501268074", "bodyText": "Temporal.Timestamp should always be in seconds, not milliseconds.", "author": "richardmcclellan", "createdAt": "2020-10-07T19:47:43Z", "path": "aws-datastore/src/test/resources/conflict-unhandled-response.json", "diffHunk": "@@ -0,0 +1,29 @@\n+{\n+  \"data\": {\n+    \"updateNote\": null\n+  },\n+  \"errors\": [\n+    {\n+      \"path\": [\n+        \"updateNote\"\n+      ],\n+      \"data\": {\n+        \"id\": \"KoolId22\",\n+        \"content\": \"Resurecting the dataz\",\n+        \"_version\": 7,\n+        \"_deleted\": true,\n+        \"_lastChangedAt\": 1601499066604", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyNjk0Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501526942", "bodyText": "I believe this value was observed in the wild, in a real response from AppSync. Will confirm.", "author": "jamesonwilliams", "createdAt": "2020-10-08T08:09:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2ODA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg5MTc4NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501891784", "bodyText": "We discussed this offline. Our findings:\n\nAppSync returns this field in milliseconds, when present in a ConflictUnhandled-type GraphQL error.\nBut, in a generated schema, _lastChangedAt  is represented as an AWSTimestamp.  And an AWSTimestamp is defined as number of seconds since 1970.", "author": "jamesonwilliams", "createdAt": "2020-10-08T17:30:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2ODA3NA=="}], "type": "inlineReview"}, {"oid": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "url": "https://github.com/aws-amplify/amplify-android/commit/fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "message": "feature(aws-datastore): support conflict unhandled error\n\nIt is possible for the local SQLite database to disagree with the\nAppSync backend on the state of a given model.\n\nWhen this occurs, the user may like to provide their own handler, to\nsuggest a strategy for resolving the conflict.\n\nPreviously, a handler interface for this functionality had been added to\nthe code, however, it was not being called.", "committedDate": "2020-10-08T10:25:34Z", "type": "commit"}, {"oid": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "url": "https://github.com/aws-amplify/amplify-android/commit/fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "message": "feature(aws-datastore): support conflict unhandled error\n\nIt is possible for the local SQLite database to disagree with the\nAppSync backend on the state of a given model.\n\nWhen this occurs, the user may like to provide their own handler, to\nsuggest a strategy for resolving the conflict.\n\nPreviously, a handler interface for this functionality had been added to\nthe code, however, it was not being called.", "committedDate": "2020-10-08T10:25:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxNjkxNg==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501716916", "bodyText": "\ud83e\udd2f", "author": "rjuliano", "createdAt": "2020-10-08T13:23:51Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import androidx.core.util.ObjectsCompat;\n+\n+import com.amplifyframework.api.graphql.GraphQLRequest;\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.api.graphql.PaginatedResult;\n+import com.amplifyframework.core.Consumer;\n+import com.amplifyframework.core.NoOpConsumer;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.query.predicate.MatchAllQueryPredicate;\n+import com.amplifyframework.core.model.temporal.Temporal;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.appsync.AppSyncMocking.SyncConfigurator;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+import com.amplifyframework.testutils.EmptyAction;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.reactivex.rxjava3.core.Completable;\n+import io.reactivex.rxjava3.core.Observable;\n+import io.reactivex.rxjava3.core.Single;\n+import io.reactivex.rxjava3.functions.Predicate;\n+\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Tests the {@link AppSyncMocking} test utility.", "originalCommit": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1NDA3Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501754072", "bodyText": "How about we move this inside of AppSyncExtensions and just make the getter return the enum?\nInstead of this current code:\npublic String getErrorType() {\n    return errorType;\n}\n\ndo something like:\npublic AppSyncErrorType getErrorType() {\n    return AppSyncErrorType.fromErrorType(errorType);\n}", "author": "richardmcclellan", "createdAt": "2020-10-08T14:12:54Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/appsync/ConflictUnhandledError.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.util.Empty;\n+import com.amplifyframework.util.GsonFactory;\n+import com.amplifyframework.util.TypeMaker;\n+\n+import com.google.gson.Gson;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * It is possible for the client and server to have two copies of one logical entity,\n+ * each containing different contents, but each believing that it is the latest\n+ * copy of the data. When the client tries to mutate the server's data, AppSync's response\n+ * may contain a GraphQLError with errorType as ConflictUnhandled.\n+ *\n+ * This ConflictUnhandledError class models that response data.\n+ *\n+ * @param <T> Type of model for which a conflict occurred between client & server versions.\n+ * @see <a href=\"https://docs.aws.amazon.com/appsync/latest/devguide/conflict-detection-and-sync.html#errors\">\n+ *     AppSync Conflict Detection & Sync Errors\n+ *     </a>\n+ */\n+public final class ConflictUnhandledError<T extends Model> {\n+    private final ModelWithMetadata<T> serverVersion;\n+\n+    private ConflictUnhandledError(ModelWithMetadata<T> serverVersion) {\n+        this.serverVersion = serverVersion;\n+    }\n+\n+    /**\n+     * Iterates over a list of GraphQL.Error, checking to see if any of them\n+     * contain 'ConflictUnhandled' as the errorType.\n+     * @param typeOfConflictingData The class of the model experiencing conflict\n+     * @param errors A list of GraphQL errors, as received in response to a mutation\n+     * @param <T> The type of model experiencing conflict, if applicable\n+     * @return A model of the first ConflictUnhandled error found in the GraphQL error list.\n+     *         If there is no ConflictUnhandledError in the list, returns null.\n+     */\n+    @Nullable\n+    public static <T extends Model> ConflictUnhandledError<T> findFirst(\n+            @NonNull Class<T> typeOfConflictingData,\n+            @Nullable List<GraphQLResponse.Error> errors) {\n+        if (Empty.check(errors)) {\n+            return null;\n+        }\n+\n+        Gson gson = GsonFactory.instance();\n+\n+        for (GraphQLResponse.Error error : errors) {\n+            if (Empty.check(error.getExtensions())) {\n+                continue;\n+            }\n+\n+            AppSyncExtensions appSyncExtensions = new AppSyncExtensions(error.getExtensions());\n+            AppSyncErrorType errorType = AppSyncErrorType.fromErrorType(appSyncExtensions.getErrorType());", "originalCommit": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg1NDQ1NQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501854455", "bodyText": "Good call. I will do this.", "author": "jamesonwilliams", "createdAt": "2020-10-08T16:29:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1NDA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc3OTU2NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501779564", "bodyText": "Ick... so what's the issue exactly for needing this workaround?", "author": "richardmcclellan", "createdAt": "2020-10-08T14:45:14Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMockingTest.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.appsync;\n+\n+import androidx.core.util.ObjectsCompat;\n+\n+import com.amplifyframework.api.graphql.GraphQLRequest;\n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.api.graphql.PaginatedResult;\n+import com.amplifyframework.core.Consumer;\n+import com.amplifyframework.core.NoOpConsumer;\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.query.predicate.MatchAllQueryPredicate;\n+import com.amplifyframework.core.model.temporal.Temporal;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.appsync.AppSyncMocking.SyncConfigurator;\n+import com.amplifyframework.testmodels.commentsblog.BlogOwner;\n+import com.amplifyframework.testutils.EmptyAction;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.reactivex.rxjava3.core.Completable;\n+import io.reactivex.rxjava3.core.Observable;\n+import io.reactivex.rxjava3.core.Single;\n+import io.reactivex.rxjava3.functions.Predicate;\n+\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Tests the {@link AppSyncMocking} test utility.\n+ */\n+public final class AppSyncMockingTest {\n+    private static final long TIMEOUT_SECONDS = 2;\n+\n+    private AppSync appSync;\n+\n+    /**\n+     * Sets up an AppSync mock.\n+     */\n+    @Before\n+    public void setup() {\n+        this.appSync = mock(AppSync.class);\n+    }\n+\n+    /**\n+     * When mockFailure() is called on the SyncConfigurator, the AppSync mock\n+     * will emit the provided failure.\n+     * @throws DataStoreException On failure to get a SyncConfigurator via sync()\n+     */\n+    @Test\n+    public void mockFailureForSync() throws DataStoreException {\n+        DataStoreException failure = new DataStoreException(\"Foo\", \"Bar\");\n+        AppSyncMocking.sync(appSync).mockFailure(failure);\n+\n+        GraphQLRequest<PaginatedResult<ModelWithMetadata<BlogOwner>>> request =\n+            appSync.buildSyncRequest(BlogOwner.class, null, 100);\n+        Single\n+            .create(emitter -> appSync.sync(request, emitter::onSuccess, emitter::onError))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertError(failure);\n+    }\n+\n+    /**\n+     * The {@link SyncConfigurator#mockSuccessResponse(Class, ModelWithMetadata[])}\n+     * method allows you to configure a collection of {@link ModelWithMetadata} to be\n+     * included in a successful {@link GraphQLResponse}, emitted from the\n+     * {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)} operation.\n+     * @throws DataStoreException On failure to configure the mock behavior\n+     */\n+    @Test\n+    public void mockSuccessResponsesForSync() throws DataStoreException {\n+        // Act: configure the mock\n+        AppSyncMocking.sync(appSync)\n+            .mockSuccessResponse(BlogOwner.class, StrawMen.JOE, StrawMen.TONY);\n+\n+        // Build a request object. This will itself test the mockSuccessResponse(),\n+        // since that method configures this call to return a meaningful result.\n+        GraphQLRequest<PaginatedResult<ModelWithMetadata<BlogOwner>>> request =\n+            appSync.buildSyncRequest(BlogOwner.class, null, 100);\n+\n+        // Lastly, when we actually call sync, we should see the expected response,\n+        // As a result of the mockSuccessResponse() on the AppSyncMocking.\n+        Single\n+            .<GraphQLResponse<PaginatedResult<ModelWithMetadata<BlogOwner>>>>create(emitter ->\n+                appSync.sync(request, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertComplete()\n+            // TODO: response items change order. Why?\n+            .assertValue(response -> {\n+                if (response.hasErrors() || !response.hasData()) {\n+                    return false;\n+                }\n+                return Observable.fromIterable(response.getData().getItems())\n+                    .toList()\n+                    .map(HashSet::new)\n+                    .blockingGet()\n+                    .equals(new HashSet<>(Arrays.asList(StrawMen.JOE, StrawMen.TONY)));\n+            });\n+    }\n+\n+    /**\n+     * When mockSuccessResponse() is called on the CreateConfigurator,\n+     * the AppSync mock will return a successful creation response\n+     * whenever AppSync's create() API is called.\n+     */\n+    @Test\n+    public void mockSuccessResponseForCreate() {\n+        AppSyncMocking.create(appSync).mockSuccessResponse(StrawMen.JOE_MODEL);\n+        GraphQLResponse<ModelWithMetadata<BlogOwner>> expectedResponse =\n+            new GraphQLResponse<>(StrawMen.JOE, Collections.emptyList());\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.create(StrawMen.JOE_MODEL, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(equalsRelaxingTimestamp(expectedResponse));\n+    }\n+\n+    /**\n+     * When mockErrorResponse() is called on the CreateConfigurator,\n+     * the AppSync mock will emit a response containing the provided GraphQL errors\n+     * whenever AppSync's create() API is called.\n+     */\n+    @Test\n+    public void mockErrorResponseForCreate() {\n+        GraphQLResponse.Error error = new GraphQLResponse.Error(\n+            \"Uh oh!\", Collections.emptyList(), Collections.emptyList(), Collections.emptyMap()\n+        );\n+        AppSyncMocking.create(appSync).mockErrorResponse(StrawMen.JOE_MODEL, error);\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.create(StrawMen.JOE_MODEL, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(new GraphQLResponse<>(null, Collections.singletonList(error)));\n+    }\n+\n+    /**\n+     * When mockSuccessResponse() is called on the UpdateConfigurator,\n+     * the bound AppSync instance will reply with a successful response\n+     * whenever its update() API is invoked.\n+     */\n+    @Test\n+    public void mockSuccessResponseForUpdate() {\n+        AppSyncMocking.update(appSync)\n+            .mockSuccessResponse(StrawMen.TONY_MODEL, 1);\n+        ModelMetadata updatedMetadata =\n+            new ModelMetadata(StrawMen.TONY_MODEL.getId(), false, 2, StrawMen.JOE_METADATA.getLastChangedAt());\n+        ModelWithMetadata<BlogOwner> tonyWithUpdatedMetadata =\n+            new ModelWithMetadata<>(StrawMen.TONY_MODEL, updatedMetadata);\n+        GraphQLResponse<ModelWithMetadata<BlogOwner>> expectedResponse =\n+            new GraphQLResponse<>(tonyWithUpdatedMetadata, Collections.emptyList());\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.update(StrawMen.TONY_MODEL, 1, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(equalsRelaxingTimestamp(expectedResponse));\n+    }\n+\n+    /**\n+     * mockErrorResponse() on the UpdateConfigurator will prepare the\n+     * bound AppSync instance to return an error response whenever\n+     * its update() API is invoked.\n+     */\n+    @Test\n+    public void mockErrorResponseForUpdate() {\n+        GraphQLResponse.Error error = new GraphQLResponse.Error(\n+            \"Uh oh!\", Collections.emptyList(), Collections.emptyList(), Collections.emptyMap()\n+        );\n+        AppSyncMocking.update(appSync)\n+            .mockErrorResponse(StrawMen.JOE_MODEL, 1, error);\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.update(StrawMen.JOE_MODEL, 1, emitter::onSuccess, emitter::onError)\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(new GraphQLResponse<>(null, Collections.singletonList(error)));\n+    }\n+\n+    /**\n+     * When mockSuccessResponse() is called on the DeleteConfigurator,\n+     * the bound AppSync instance will reply with a successful response\n+     * whenever its delete() API is invoked.\n+     */\n+    @Test\n+    public void mockSuccessResponseForDelete() {\n+        AppSyncMocking.delete(appSync)\n+            .mockSuccessResponse(StrawMen.TONY_MODEL, 1);\n+        ModelMetadata deletedMetadata =\n+            new ModelMetadata(StrawMen.TONY_MODEL.getId(), true, 2, StrawMen.JOE_METADATA.getLastChangedAt());\n+        ModelWithMetadata<BlogOwner> tonyWithDeleteMetadata =\n+            new ModelWithMetadata<>(StrawMen.TONY_MODEL, deletedMetadata);\n+        GraphQLResponse<ModelWithMetadata<BlogOwner>> expectedResponse =\n+            new GraphQLResponse<>(tonyWithDeleteMetadata, Collections.emptyList());\n+        Single\n+            .<GraphQLResponse<ModelWithMetadata<BlogOwner>>>create(emitter ->\n+                appSync.delete(\n+                    BlogOwner.class,\n+                    StrawMen.TONY_MODEL.getId(),\n+                    1,\n+                    MatchAllQueryPredicate.instance(),\n+                    emitter::onSuccess,\n+                    emitter::onError\n+                )\n+            )\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(equalsRelaxingTimestamp(expectedResponse));\n+    }\n+\n+    /**\n+     * When mockErrorResponse() is called on the DeleteConfigurator,\n+     * the bound AppSync instance will be configured to emit an error\n+     * response whenever its delete() API is invoked.\n+     */\n+    @Test\n+    public void mockErrorResponseForDelete() {\n+        GraphQLResponse.Error error = new GraphQLResponse.Error(\n+            \"Uh oh!\", Collections.emptyList(), Collections.emptyList(), Collections.emptyMap()\n+        );\n+        AppSyncMocking.delete(appSync)\n+            .mockErrorResponse(StrawMen.JOE_MODEL, 1, error);\n+        Single\n+            .create(emitter -> appSync.delete(\n+                BlogOwner.class,\n+                StrawMen.JOE_MODEL.getId(),\n+                1,\n+                MatchAllQueryPredicate.instance(),\n+                emitter::onSuccess,\n+                emitter::onError\n+            ))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertValue(new GraphQLResponse<>(null, Collections.singletonList(error)));\n+    }\n+\n+    /**\n+     * callOnStart() arranges a mock behavior on the provided AppSync instance.\n+     * When the mock is called upon to create a subscription for creations events,\n+     * the mock will immediately callback on the provided onStart callback.\n+     */\n+    @Test\n+    public void onStartCallbackIsCalledForMockOnCreate() {\n+        AppSyncMocking.onCreate(appSync).callOnStart();\n+        Completable\n+            .create(subscriber -> appSync.onCreate(\n+                Model.class,\n+                subscriptionToken -> subscriber.onComplete(),\n+                NoOpConsumer.create(),\n+                NoOpConsumer.create(),\n+                EmptyAction.create()\n+            ))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertComplete();\n+    }\n+\n+    /**\n+     * callOnStart() arranges a mock behavior on the provided AppSync instance.\n+     * When the mock is called upon to create a subscription for update events,\n+     * the mock will immediately callback on the provided onStart callback.\n+     */\n+    @Test\n+    public void onStartCallbackIsCalledForMockOnUpdate() {\n+        AppSyncMocking.onUpdate(appSync).callOnStart();\n+        Completable\n+            .create(subscriber -> appSync.onUpdate(\n+                Model.class,\n+                subscriptionToken -> subscriber.onComplete(),\n+                NoOpConsumer.create(),\n+                NoOpConsumer.create(),\n+                EmptyAction.create()\n+            ))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertComplete();\n+    }\n+\n+    /**\n+     * callOnStart() arranges a mock behavior on the provided AppSync instance.\n+     * When the mock is called upon to create a subscription for delete events,\n+     * the mock will immediately callback on the provided onStart callback.\n+     */\n+    @Test\n+    public void onStartCallbackIsCalledForMockOnDelete() {\n+        AppSyncMocking.onDelete(appSync).callOnStart();\n+        Completable\n+            .create(subscriber -> appSync.onDelete(\n+                Model.class,\n+                subscriptionToken -> subscriber.onComplete(),\n+                NoOpConsumer.create(),\n+                NoOpConsumer.create(),\n+                EmptyAction.create()\n+            ))\n+            .test()\n+            .awaitDone(TIMEOUT_SECONDS, TimeUnit.SECONDS)\n+            .assertComplete();\n+    }\n+\n+    private static Predicate<GraphQLResponse<ModelWithMetadata<BlogOwner>>> equalsRelaxingTimestamp(\n+            GraphQLResponse<ModelWithMetadata<BlogOwner>> expectedResponse) {\n+        return response -> {\n+            if (!ObjectsCompat.equals(expectedResponse.getErrors(), response.getErrors())) {\n+                return false;\n+            }\n+            ModelWithMetadata<BlogOwner> expectedMwm = expectedResponse.getData();\n+            ModelWithMetadata<BlogOwner> mwm = response.getData();\n+            return equalsRelaxingTimestamp(expectedMwm).test(mwm);\n+        };\n+    }\n+\n+    private static Predicate<ModelWithMetadata<BlogOwner>> equalsRelaxingTimestamp(", "originalCommit": "fa07d9e2317e6c0025b7e7031a66bcc2804a47af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg1NDA1Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/883#discussion_r501854052", "bodyText": "In AppSyncMocking, I have a couple of flavors of the mockSuccessResponse(...) which internally create their own Temporal.Timestamp.now(). (So, I can't know what it is, outside, in this unit test.)\nHowever, I just realized that I could test the other flavors of mockSuccessResponse(...), instead -- the ones that will allow me to supply a known timestamp. That would get rid of these kludges and clean things up quite a bit. I'll do that.", "author": "jamesonwilliams", "createdAt": "2020-10-08T16:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc3OTU2NA=="}], "type": "inlineReview"}, {"oid": "f501a891a4f6befb36a838354f1e123d11d04175", "url": "https://github.com/aws-amplify/amplify-android/commit/f501a891a4f6befb36a838354f1e123d11d04175", "message": "FIXUP: address PR feedback from Richard", "committedDate": "2020-10-08T17:21:24Z", "type": "commit"}, {"oid": "2e58127b0c4b0a6b9d8a4575f0f96c60a27ab61e", "url": "https://github.com/aws-amplify/amplify-android/commit/2e58127b0c4b0a6b9d8a4575f0f96c60a27ab61e", "message": "Merge remote-tracking branch 'origin/main' into conflict_handler", "committedDate": "2020-10-08T17:26:37Z", "type": "commit"}]}