{"pr_number": 339, "pr_title": "[aws-datastore] Persist model sync time to enable delta sync", "pr_createdAt": "2020-04-01T10:43:45Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/339", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5MjA4Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401892087", "bodyText": "Hmm, it seems like this will throw an exception if it sees any key in the config it doesn't support, not just if it's missing the required keys. I think it would be better not to do this since (a) It doesn't hurt us in any way if there's extra information so why throw an error? and (b) I could see a time in the future where in transitioning between versions of our code in a non-breaking way there ends up being extraneous information in people's old config files which shouldn't be a problem but this would make into a problem.", "author": "TrekSoft", "createdAt": "2020-04-01T20:33:23Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePluginConfiguration.java", "diffHunk": "@@ -18,53 +18,134 @@\n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n \n-import com.amplifyframework.AmplifyException;\n-\n import org.json.JSONException;\n import org.json.JSONObject;\n \n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n /**\n  * Configuration options for the {@link AWSDataStorePlugin}.\n  * Contains settings for remote synchronization, if enabled.\n  */\n-final class AWSDataStorePluginConfiguration {\n+public final class AWSDataStorePluginConfiguration {\n+    /**\n+     * At most one base sync may be performed within the period (now() - base sync interval).\n+     * This interval has a default value provided, in case the user doesn't elect one.\n+     */\n+    public static final long DEFAULT_BASE_SYNC_INTERVAL_MS = TimeUnit.HOURS.toMillis(24);\n+    private static final SyncMode DEFAULT_SYNC_MODE = SyncMode.LOCAL_ONLY;\n \n     private final SyncMode syncMode;\n+    private final long baseSyncIntervalMs;\n \n-    private AWSDataStorePluginConfiguration(final SyncMode syncMode) {\n+    private AWSDataStorePluginConfiguration(SyncMode syncMode, long baseSyncIntervalMs) {\n         this.syncMode = syncMode;\n+        this.baseSyncIntervalMs = baseSyncIntervalMs;\n     }\n \n     static AWSDataStorePluginConfiguration fromJson(JSONObject pluginJson) throws DataStoreException {\n-        // If no sync mode is specified, we just use the default (no sync) and continue\n-        if (pluginJson == null || !pluginJson.has(\"syncMode\")) {\n-            return new AWSDataStorePluginConfiguration(SyncMode.LOCAL_ONLY);\n-        }\n+        SyncMode syncMode = DEFAULT_SYNC_MODE;\n+        long baseSyncIntervalMs = DEFAULT_BASE_SYNC_INTERVAL_MS;\n \n-        try {\n-            // If user has specified a sync mode, find out what it was.\n-            final SyncMode syncMode = SyncMode.fromJsonPropertyValue(pluginJson.getString(\"syncMode\"));\n+        if (pluginJson == null) {\n+            return new AWSDataStorePluginConfiguration(syncMode, baseSyncIntervalMs);\n+        }\n \n-            return new AWSDataStorePluginConfiguration(syncMode);\n-        } catch (JSONException exception) {\n-            throw new DataStoreException(\n+        final Iterator<String> jsonKeys = pluginJson.keys();\n+        while (jsonKeys.hasNext()) {\n+            final String keyString = jsonKeys.next();\n+            final ConfigKey configKey;\n+            try {\n+                configKey = ConfigKey.fromString(keyString);\n+            } catch (IllegalArgumentException noSuchConfigKey) {\n+                throw new DataStoreException(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5MjY3Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401892672", "bodyText": "It also makes performance worse because you have to loop through the keys vs just check if it has the ones you want (not significant but still, given the above reasons, it adds fuel to the fire of removing it)", "author": "TrekSoft", "createdAt": "2020-04-01T20:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5MjA4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NDM0Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401964342", "bodyText": "Assuming I check all of the keys, the number of computations should be the same with or without the control flow.\nI did intentionally code this to dis-allow unknown keys. The reasoning is that I don't want a user to have like a \"syncMODE\" and think it's okay. I want them to get a warning like \"Hey bud, what's a syncMODE? The valid keys are: (acceptable keys including syncMode).\"\nI agree with the comments about transitioning keys in the future, but let's cross that bridge when we get to it. A different way of addressing it would be to have like:\n// This is a 100% contrived, hypothetical example of us supporting keys during a graceful deprecation.\nenum ConfigKey {\n    /**\n     * @deprecated Use {@link #SYNCHRONIZATION_MODE} instead.\n     */\n    @Deprecated\n    SYNC_MODE(\"syncMode\"),\n\n    /**\n     * How to synchronize data with the cloud?\n     */\n    SYNCHRONIZATION_MODE(\"syncrhonizationMode\")\n}\n\nThen somewhere:\nwhile (keyIterator.hasNext()) {\n    ConfigKey configKey;\n    try {\n        configKey = ConfigKey.fromString(keyIterator.next());\n    } catch (IllegalArgumentException noKnownConfigKey) {\n        // Tell user what are the acceptable keys ....\n    }\n    switch (configKey) {\n        case SYNC_MODE /* deprecated, but allowed for now... */:\n        case SYNCHRONIZATION_MODE /* transitioning to this... */:\n            // handle sync mode value\n            break;\n    }\n}", "author": "jamesonwilliams", "createdAt": "2020-04-01T23:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5MjA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5Mzg5OA==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401893898", "bodyText": "What was the reason behind dropping the get verb prefix? I debated this on my current Auth work and landed on keeping the get at the beginning of the method name since, in addition to being consistent with our pattern of starting method names with verbs, I also think it's a better experience for the developer if all getter methods start with get and thus are grouped together in autosuggest.", "author": "TrekSoft", "createdAt": "2020-04-01T20:36:52Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePluginConfiguration.java", "diffHunk": "@@ -18,53 +18,134 @@\n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n \n-import com.amplifyframework.AmplifyException;\n-\n import org.json.JSONException;\n import org.json.JSONObject;\n \n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n /**\n  * Configuration options for the {@link AWSDataStorePlugin}.\n  * Contains settings for remote synchronization, if enabled.\n  */\n-final class AWSDataStorePluginConfiguration {\n+public final class AWSDataStorePluginConfiguration {\n+    /**\n+     * At most one base sync may be performed within the period (now() - base sync interval).\n+     * This interval has a default value provided, in case the user doesn't elect one.\n+     */\n+    public static final long DEFAULT_BASE_SYNC_INTERVAL_MS = TimeUnit.HOURS.toMillis(24);\n+    private static final SyncMode DEFAULT_SYNC_MODE = SyncMode.LOCAL_ONLY;\n \n     private final SyncMode syncMode;\n+    private final long baseSyncIntervalMs;\n \n-    private AWSDataStorePluginConfiguration(final SyncMode syncMode) {\n+    private AWSDataStorePluginConfiguration(SyncMode syncMode, long baseSyncIntervalMs) {\n         this.syncMode = syncMode;\n+        this.baseSyncIntervalMs = baseSyncIntervalMs;\n     }\n \n     static AWSDataStorePluginConfiguration fromJson(JSONObject pluginJson) throws DataStoreException {\n-        // If no sync mode is specified, we just use the default (no sync) and continue\n-        if (pluginJson == null || !pluginJson.has(\"syncMode\")) {\n-            return new AWSDataStorePluginConfiguration(SyncMode.LOCAL_ONLY);\n-        }\n+        SyncMode syncMode = DEFAULT_SYNC_MODE;\n+        long baseSyncIntervalMs = DEFAULT_BASE_SYNC_INTERVAL_MS;\n \n-        try {\n-            // If user has specified a sync mode, find out what it was.\n-            final SyncMode syncMode = SyncMode.fromJsonPropertyValue(pluginJson.getString(\"syncMode\"));\n+        if (pluginJson == null) {\n+            return new AWSDataStorePluginConfiguration(syncMode, baseSyncIntervalMs);\n+        }\n \n-            return new AWSDataStorePluginConfiguration(syncMode);\n-        } catch (JSONException exception) {\n-            throw new DataStoreException(\n+        final Iterator<String> jsonKeys = pluginJson.keys();\n+        while (jsonKeys.hasNext()) {\n+            final String keyString = jsonKeys.next();\n+            final ConfigKey configKey;\n+            try {\n+                configKey = ConfigKey.fromString(keyString);\n+            } catch (IllegalArgumentException noSuchConfigKey) {\n+                throw new DataStoreException(\n+                    \"Saw unexpected config key: \" + keyString,\n+                    \"Make sure your amplifyconfiguration.json is valid.\"\n+                );\n+            }\n+            try {\n+                switch (configKey) {\n+                    case SYNC_MODE:\n+                        String jsonValue = pluginJson.getString(ConfigKey.SYNC_MODE.toString());\n+                        syncMode = SyncMode.fromJsonPropertyValue(jsonValue);\n+                        break;\n+                    case BASE_SYNC_INTERVAL_MS:\n+                        baseSyncIntervalMs = pluginJson.getLong(ConfigKey.BASE_SYNC_INTERVAL_MS.toString());\n+                        break;\n+                    default:\n+                        throw new IllegalArgumentException(\"Unsupported config key = \" + configKey.toString());\n+                }\n+            } catch (JSONException jsonException) {\n+                throw new DataStoreException(\n                     \"Issue encountered while parsing configuration JSON\",\n-                    exception,\n-                    \"Check the attached exception for more details.\"\n-            );\n+                    jsonException, \"Ensure your amplifyconfiguration.json is valid.\"\n+                );\n+            }\n         }\n \n+        return new AWSDataStorePluginConfiguration(syncMode, baseSyncIntervalMs);\n     }\n \n     /**\n      * Gets the synchronization mode.\n      * @return Synchronization mode\n      */\n     @NonNull\n-    SyncMode getSyncMode() {\n+    SyncMode syncMode() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2MTU2Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401961566", "bodyText": "Thanks for bringing this up.\nCurrently, we have inconsistent naming across the codebase for accessor methods. Some use the \"OkHttp style\" foo() (no get), and some use the style of prefixing by getFoo().\nOur builders mostly use the .someValue(...) configurator style, instead of the .withSomeValue(...), but this is probably another area where we have some inconsistency.\nAligning the accessor methods to one naming style is going to be a large change in our code base. Let's discuss the preferred style amongst the team. For methods that simply returned a cached field value, I do prefer the version without get...(), personally.", "author": "jamesonwilliams", "createdAt": "2020-04-01T23:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5Mzg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAxMjMwNA==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r402012304", "bodyText": "Resolution: starting to move these things to include get...(), as per kotlin interop doc:\nhttps://kotlinlang.org/docs/reference/java-interop.html#getters-and-setters", "author": "jamesonwilliams", "createdAt": "2020-04-02T02:09:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5Mzg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5Njg5OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401896899", "bodyText": "There's probably a good reason for this I'm just missing here but would it not have worked to just supplement the existing metadata object with a lastSyncTime field?", "author": "TrekSoft", "createdAt": "2020-04-01T20:42:36Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/LastSyncMetadata.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.core.util.ObjectsCompat;\n+\n+import com.amplifyframework.core.model.Model;\n+import com.amplifyframework.core.model.annotations.ModelField;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+/**\n+ * Metadata about the last time that a model class was sync'd with AppSync backend.\n+ * This metadata is persisted locally as a system model. This metadata is inspected\n+ * whenever the Sync Engine starts up. The system consider the value of\n+ * {@link LastSyncMetadata#getLastSyncTime()} to decide whether or not it should\n+ * perform a \"Base Sync\" or a \"Delta Sync\".\n+ */\n+public final class LastSyncMetadata implements Model {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2MDI1NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401960254", "bodyText": "The ModelMetadata deals with metadata for a single instance of a model.\nThe LastSyncMetadata deals with metadata for the model type, inclusive of any/all instances there-of.\nHowever, in the biggest picture, I agree with what you're saying, and I do think we could probably simplify our metadata / system models a bit.\nHere are the ones we have right now, complete with (decent) doco.", "author": "jamesonwilliams", "createdAt": "2020-04-01T23:03:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5Njg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5OTEwNg==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401899106", "bodyText": "Thanks for getting rid of this - I'm a huge proponent of not overly separating things out since it leads to endless rabbit trails to find the code you're looking for as a future dev working on the project so I fully support consolidating this functionality into the SyncProcessor.", "author": "TrekSoft", "createdAt": "2020-04-01T20:46:46Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -46,25 +46,35 @@\n      *                       durably store offline changes until\n      *                       then can be written to the network\n      * @param appSync An AppSync Endpoint\n+     * @param baseSyncIntervalProvider Provider the interval in which at most\n+     *                                 one base sync may occur\n      */\n     public Orchestrator(\n             @NonNull final ModelProvider modelProvider,\n             @NonNull final ModelSchemaRegistry modelSchemaRegistry,\n             @NonNull final LocalStorageAdapter localStorageAdapter,\n-            @NonNull final AppSync appSync) {\n+            @NonNull final AppSync appSync,\n+            @NonNull final SyncProcessor.BaseSyncIntervalProvider baseSyncIntervalProvider) {\n         Objects.requireNonNull(modelSchemaRegistry);\n         Objects.requireNonNull(modelProvider);\n         Objects.requireNonNull(appSync);\n         Objects.requireNonNull(localStorageAdapter);\n \n         RemoteModelMutations remoteModelMutations = new RemoteModelMutations(appSync, modelProvider);\n-        RemoteModelState remoteModelState = new RemoteModelState(appSync, modelProvider);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1OTM3Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401959372", "bodyText": "This one did take it too far. The Sync Processor and Remote Model State concepts had a lot of the same concerns. This became clear when I needed to lookup/save sync times. Basically, I was going to have to weave two Rx chains together. So I just flattened all the crap into the same Java document.", "author": "jamesonwilliams", "createdAt": "2020-04-01T23:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5OTEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMDIzNw==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401900237", "bodyText": "What is the need for this vs just passing in the interval?", "author": "TrekSoft", "createdAt": "2020-04-01T20:48:59Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncProcessor.java", "diffHunk": "@@ -15,49 +15,70 @@\n \n package com.amplifyframework.datastore.syncengine;\n \n+import android.annotation.SuppressLint;\n import androidx.annotation.NonNull;\n \n+import com.amplifyframework.api.graphql.GraphQLResponse;\n+import com.amplifyframework.core.Consumer;\n+import com.amplifyframework.core.async.Cancelable;\n import com.amplifyframework.core.model.Model;\n import com.amplifyframework.core.model.ModelProvider;\n import com.amplifyframework.core.model.ModelSchema;\n import com.amplifyframework.core.model.ModelSchemaRegistry;\n+import com.amplifyframework.datastore.DataStoreException;\n+import com.amplifyframework.datastore.appsync.AppSync;\n import com.amplifyframework.datastore.appsync.ModelWithMetadata;\n+import com.amplifyframework.util.Time;\n \n+import java.util.HashSet;\n import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import io.reactivex.Completable;\n+import io.reactivex.Observable;\n+import io.reactivex.Single;\n+import io.reactivex.SingleEmitter;\n+import io.reactivex.disposables.Disposable;\n import io.reactivex.schedulers.Schedulers;\n \n /**\n  * \"Hydrates\" the local DataStore, using model metadata receive from the\n- * {@link RemoteModelState}. Hydration refers to populating the local storage\n- * with values from a remote system.\n+ * {@link AppSync#sync(Class, Long, Consumer, Consumer)}.\n+ * Hydration refers to populating the local storage with values from a remote system.\n  *\n  * For all items returned by the sync, merge them back into local storage through\n  * the {@link Merger}.\n  */\n final class SyncProcessor {\n-    private final RemoteModelState remoteModelState;\n-    private final Merger merger;\n     private final ModelProvider modelProvider;\n     private final ModelSchemaRegistry modelSchemaRegistry;\n+    private final SyncTimeRegistry syncTimeRegistry;\n+    private final AppSync appSync;\n+    private final Merger merger;\n+    private final BaseSyncIntervalProvider syncIntervalProvider;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1ODYyMA==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401958620", "bodyText": "When the plugin gets created, I want that to cascade down to call new Gizmo() for all the things that the plugin is going to need. However, I don't have a configuration object available yet, since configure(...) hasn't been called, yet.\nThe BaseSyncIntervalProvider is a \"provider delegate.\" Delegates can be used for exactly this situation. It allows me to create my object, and specify a function that can be called to lookup the sync interval in a lazy way, later when:\n\nThis code actually needs it (not in the constructor, it won't, yet)\nAnd it actually happens to be available (we presume configure(...) might have occurred by then.)\n\nIn other words, the sequence is like:\n\nEverything gets new'd.\nconfigure(...) gets called.\nAs a result of that, SyncProcessor starts doing its job in the background. When it does, it queries the provider delegate, to find out what value had been made available in configuration.\n\nThe (ideologically simpler) approach to this sequencing problem would be to defer construction of the SyncEngine until after configure(...) had been called. This way, we could simply pass the configuration values into the SyncEngine, without the provider delegate. This has two down-sides:\n\nSyncEngine is constructed in an ideologically wrong part of the lifecycle. Dependencies should be instantiated as part of the plugin construction. Configuration is meant to deal only with loading the runtime config.\nIf we constructed it ind configure(...), it would need to become a non-final field in the plugin. This means that sometimes the plugin has a null SyncProcessor, sometimes it doesn't. Possibly, the object instance could change at any time. null, instanceA, instanceB, whatever. This means we would need to code defensively for these scenarios in the plugin. Whereas, if we just have one non-null instance, as an invariant, we don't need to manage all of the amguity around state.", "author": "jamesonwilliams", "createdAt": "2020-04-01T22:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMDIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMTg3Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401901876", "bodyText": "Ooof, the fact we have to have this class due to RX hurts my eyes - I like the idea of moving it to a static inner class.", "author": "TrekSoft", "createdAt": "2020-04-01T20:52:13Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncTime.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.datastore.syncengine;\n+\n+import androidx.annotation.Nullable;\n+import androidx.core.util.ObjectsCompat;\n+\n+import com.amplifyframework.util.Time;\n+\n+/**\n+ * Represents the time at which a type of model was last sync'd.\n+ * Why isn't that just an @Nullable Long (capital 'L')?\n+ * Rx doesn't allow nulls, so we have to encapsulate the Long value into this\n+ * class. TODO: move this to become a static inner class of {@link LastSyncMetadata}?\n+ */\n+final class SyncTime {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1MzcyNA==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401953724", "bodyText": "In recent times, there has been a shift in programming languages, and null-able values have gone out of style. The Reactive Programming paradigm adopted this philosophy while moving from the Rx1 to Rx2 specification. But, it is hardly an Rx thing. All programming languages of the current generation have made this change, too. In Swift and Kotlin, nullable types must be declared explicitly through the addition of a ? symbol. Well, alright, Rx2 simpliy disallowing it is maybe a little heavy-handed.\nBut, I think this is something I've tried to feed into our code base, as well. null usually means \"not specified.\" But sometimes, it takes on other meanings. The most self-documenting way to address this is to not use null, but use a meaningful object. Here, null really means \"the thing was never synced.\" Which is explicit when communicated as SyncTime.never().\n\nDitto on the inner class -- it involves having final class SyncTime extends Model, and then I'd have to figure out how-to link the field associations. (AFAIK, we still don't have our Amplify Model Schema DSL documented anywhere.)", "author": "jamesonwilliams", "createdAt": "2020-04-01T22:45:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMTg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk0OTA1MQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/339#discussion_r401949051", "bodyText": "Note to self: undo the changes in this file. This JavaDoc change is actually a regression.", "author": "jamesonwilliams", "createdAt": "2020-04-01T22:33:13Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/storage/InMemoryStorageAdapter.java", "diffHunk": "@@ -217,7 +217,7 @@ public void terminate() {\n     }\n \n     /**\n-     * Get the items that are in the storage.\n+     * Lists the items that are in the storage.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "fbbe1f31f52bd077ef780137bc4dc52bc82c476e", "url": "https://github.com/aws-amplify/amplify-android/commit/fbbe1f31f52bd077ef780137bc4dc52bc82c476e", "message": "[aws-datastore] Persist model sync time to enable delta sync\n\nWhen sync for a model type compeltes, save the time.  Next time a sync\nattempted, the last sync time is inspected. If this value is within the\ndelta sync window, perform a delta sync. Otherwise, perform a base sync.", "committedDate": "2020-04-02T08:15:18Z", "type": "commit"}, {"oid": "fbbe1f31f52bd077ef780137bc4dc52bc82c476e", "url": "https://github.com/aws-amplify/amplify-android/commit/fbbe1f31f52bd077ef780137bc4dc52bc82c476e", "message": "[aws-datastore] Persist model sync time to enable delta sync\n\nWhen sync for a model type compeltes, save the time.  Next time a sync\nattempted, the last sync time is inspected. If this value is within the\ndelta sync window, perform a delta sync. Otherwise, perform a base sync.", "committedDate": "2020-04-02T08:15:18Z", "type": "forcePushed"}]}