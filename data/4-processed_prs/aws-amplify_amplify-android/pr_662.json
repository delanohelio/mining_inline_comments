{"pr_number": 662, "pr_title": "fix: start orchestrator before any datastore operations", "pr_createdAt": "2020-07-23T06:05:30Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/662", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTMyOQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459231329", "bodyText": "This is the single most important line -- the core purpose -- of this PR.", "author": "jamesonwilliams", "createdAt": "2020-07-23T06:07:42Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -472,14 +471,16 @@ public void clear(@NonNull Action onComplete,\n \n     private void beforeOperation(@NonNull final Runnable runnable) {\n         Throwable throwable = Completable.fromAction(categoryInitializationsPending::await)\n+            .timeout(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n+            .andThen(initializeOrchestrator())", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM5ODQ2NQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459398465", "bodyText": "What's the effect of the timeout operator? Does it wait for the categoryInitializationsPending to be counted down up to PLUGIN_INIT_TIMEOUT_MSms and then tries to start the orchestrator?\nIf there's no connectivity, will this be retried on any interaction with the DataStore?", "author": "rjuliano", "createdAt": "2020-07-23T12:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzNDM1Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459434356", "bodyText": "What's the effect of the timeout operator? Does it wait for the categoryInitializationsPending to be counted down up to PLUGIN_INIT_TIMEOUT_MSms and then tries to start the orchestrator?\n\nI think that's how it's working, yes. That was the intent, anyway.\n\nIf there's no connectivity, will this be retried on any interaction with the DataStore?\n\nYes, offline or not signed in. I guess we probably don't want to block on its completion?", "author": "jamesonwilliams", "createdAt": "2020-07-23T13:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ5MTg1OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459491859", "bodyText": "I believe so...at least when calling from beforeOperation. I think the only piece of the orchestrator that is necessary before we can allow interaction with the DataStore is the StorageObserver. Without that, any save operations against the DataStore would not be queued up for sync.\nThe other components can probably be treated as fire-and-forget. For the SubscriptionProcessor, I added a retry mechanism. Maybe that's something we should do for the SyncProcessor and MutationProcessor?", "author": "rjuliano", "createdAt": "2020-07-23T14:28:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzODc0Mw==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459538743", "bodyText": "I believe so...at least when calling from beforeOperation. I think the only piece of the orchestrator that is necessary before we can allow interaction with the DataStore is the StorageObserver. Without that, any save operations against the DataStore would not be queued up for sync. The other components can probably be treated as fire-and-forget.\n\nAgree; this makes sense.\n\nFor the SubscriptionProcessor, I added a retry mechanism. Maybe that's something we should do for the SyncProcessor and MutationProcessor?\n\nActually, simply adding retries to the sync processor might be the quickest solution to solving the problem at hand.\nIdeally, though, I think we want to retry orchestrator setup as an atomic entity, not just the individual components. The order in which the components come online and start modifying data is import, for maintaining data integrity.", "author": "jamesonwilliams", "createdAt": "2020-07-23T15:31:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNTYzMg==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r461315632", "bodyText": "Resolution: I ended up doing the second thing re: \"atomic entity.\"", "author": "jamesonwilliams", "createdAt": "2020-07-28T04:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTU0NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459231544", "bodyText": "If we don't have a clean start, we should teardown again, so we're back to a deterministic stop state.", "author": "jamesonwilliams", "createdAt": "2020-07-23T06:08:27Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -165,7 +167,14 @@ public synchronized Completable start(Action onLocalStorageReady) {\n                 LOG.debug(\"Orchestrator started.\");\n                 announceRemoteSyncStarted();\n             })\n-        ).doFinally(startStopSemaphore::release);\n+        )\n+        .doOnError(error -> {\n+            LOG.warn(\"Orchestrator failed to start.\", error);\n+            startStopSemaphore.release();\n+            //noinspection ResultOfMethodCallIgnored\n+            stop().blockingAwait(ACQUIRE_PERMIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQwMDYxNg==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459400616", "bodyText": "This makes sense. Only concern I have is similar to what I mentioned earlier. If a connection is not available what the impact on calls to the DataStore APIs?", "author": "rjuliano", "createdAt": "2020-07-23T12:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzMTU0Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459431547", "bodyText": "If a connection is not available what the impact on calls to the DataStore APIs?\n\nThanks for bringing this case to my attention. This is an indeed an issue:\n\nDevice is offline;\nUser is not signed in;\nA call to save(...) is made;\nNo response is rendered until initializeOrchestrator() fails.\nAt that point, the onResult consumer is triggered as desired, indicating successful use of the local storage.\n\n(4) is a problem.", "author": "jamesonwilliams", "createdAt": "2020-07-23T13:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxOTEyNQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459519125", "bodyText": "To build on my response to the other comment, I think we only need to block interactions with the local DataStore until the StorageObserver is ready.\nMaybe we need to account for more than just started/stopped for the orchestrator.\nif Orchestrator is STOPPED => // need to start everything and signal when StorageObserver is ready.\n   triggerStartAndWaitForStorageObserver\n   if StorageObserver STARTED =>\n      emit storageObserverReady //This unlocks callers\n   else\n      Set Orchestrator back to STOPPED\n      throw error back to caller.      \n   [MutationProcessor, SubscriptionProcessor, SyncProcessor].asyncStart \n   if [MutationProcessor, SubscriptionProcessor, SyncProcessor] STARTED\n     set Orchestrator STARTED\n   else\n     set Orchestrator FAILED\n\nif STARTED => nothing to do, it's ready to go\n\nif FAILED => trigger non-blocking retry.\n   [MutationProcessor, SubscriptionProcessor, SyncProcessor].asyncStart \n   if [MutationProcessor, SubscriptionProcessor, SyncProcessor] STARTED\n     set Orchestrator STARTED\n   else\n     set Orchestrator FAILED", "author": "rjuliano", "createdAt": "2020-07-23T15:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNjEyNw==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r461316127", "bodyText": "Resolution: I decoupled the initialization of the API synchronization code, from the code which observes the storage. Now, there is always a storage observer when beforeOperation() completes, and so any customer-provided data will be observed. The API sync may start at a later time.", "author": "jamesonwilliams", "createdAt": "2020-07-28T04:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTYyNA==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459231624", "bodyText": "According to Lint, the handler is never null.", "author": "jamesonwilliams", "createdAt": "2020-07-23T06:08:51Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncProcessor.java", "diffHunk": "@@ -118,18 +118,15 @@ Completable hydrate() {\n                         LOG.warn(\"Initial cloud sync failed.\", failureToSync);\n                         DataStoreErrorHandler dataStoreErrorHandler =\n                             dataStoreConfigurationProvider.getConfiguration().getDataStoreErrorHandler();\n-                        if (dataStoreErrorHandler != null) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMTgxMg==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459231812", "bodyText": "I need the hydrate() call to surface its failures, so that the orchestrator can respond to them by cleaning up and shutting down.", "author": "jamesonwilliams", "createdAt": "2020-07-23T06:09:34Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncProcessor.java", "diffHunk": "@@ -118,18 +118,15 @@ Completable hydrate() {\n                         LOG.warn(\"Initial cloud sync failed.\", failureToSync);\n                         DataStoreErrorHandler dataStoreErrorHandler =\n                             dataStoreConfigurationProvider.getConfiguration().getDataStoreErrorHandler();\n-                        if (dataStoreErrorHandler != null) {\n-                            dataStoreErrorHandler.accept(\n-                                new DataStoreException(\n-                                    \"Initial cloud sync failed.\",\n-                                    failureToSync,\n-                                    \"Check your internet connection.\"));\n-                        }\n+                        dataStoreErrorHandler.accept(\n+                            new DataStoreException(\n+                                \"Initial cloud sync failed.\",\n+                                failureToSync,\n+                                \"Check your internet connection.\"));\n                     })\n                     .doOnComplete(() ->\n                         LOG.info(\"Successfully sync'd down model state from cloud.\")\n                     )\n-                    .onErrorComplete()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMjU2Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r459232567", "bodyText": "(This used to be at the end of hydrate().)", "author": "jamesonwilliams", "createdAt": "2020-07-23T06:11:51Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -499,9 +500,10 @@ private Completable initializeOrchestrator() {\n                 // This callback is invoked when the local storage observer gets initialized.\n                 isOrchestratorReady.set(true);\n             })\n-            .repeatUntil(() -> isOrchestratorReady.get())\n+            .repeatUntil(isOrchestratorReady::get)\n             .observeOn(Schedulers.io())\n-            .subscribeOn(Schedulers.io());\n+            .subscribeOn(Schedulers.io())\n+            .onErrorComplete();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "d7364bbe2a9d5d95ed8da42ebc68a6de76d106a6", "url": "https://github.com/aws-amplify/amplify-android/commit/d7364bbe2a9d5d95ed8da42ebc68a6de76d106a6", "message": "Daemon-style orchestrator logic\n\n1. The AWSDataStorePlugin had strated to take on sync engine\n   orchestration concerns. All orchestration concerns are removed from\n   the plugin, and moved into the Orchestrator, again.\n\n2. The orchestrator is worked into a kernel driver / system daemon style\n   init / teardown component. Init and teardown are idempotent. If init\n   fails at any point, teardown knows how to cleanup from that point.\n\n3. The orchestrator is changed to use a state machine, with three\n   states:\n\n   a. STOPPED      No sync component is running, and local changes are not\n                   being queued into an offline mutations queue.\n   b. LOCAL_ONLY   Local changes are being buffered into an offline\n                   mutations queue, but are not being transacte with the\n                   cloud\n   c. SYNC_VIA_API Data is syncrhonizing to and from the cloud.\n\n   Logic is added to transition safely between any pair of these states\n   (there are six possible transitions.)\n\n4. Retry logic is _removed_ from the subscription processor. Instead, if\n   a subscription fails, the failure is communicated back to the\n   Orchestrator. The Orchestrator should then exist API sync mode.\n\n5. The Orchestrator will atempt to reach the desired target state\n   (LOCAL_ONLY or SYNC_VIA_API) again, before any call to the client\n   DataStore APIs. One guarantee is that the storage observer will be\n   active before the user's data reaches the database. This way, it will\n   deterministically be included into the offline mutations queue. If\n   the target state is SYNC_VIA_API, the initialization continues in the\n   background.\n\nFuture work will further address transient network failures. Instead of\nindividual sync engine components owning their own retries, the\nOrchestrator's lifecycle as a whole will be retried. When the network\ngoes down, or when auth fails -- any transient failure -- should result\nin the Orchestrator backing off into LOCAL_ONLY mode. Additional retry\nlogic added to the orchestrator will ensure that it intelligently\nattempts to reach the target mode, again.", "committedDate": "2020-07-24T06:27:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3Mjc0NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r460272744", "bodyText": "One issue I ran into here was that if I add the DataStore plugin before the API plugin, the Orchestrator goes into LOCAL_ONLY mode:\n// Starts in LOCAL_ONLY\n Amplify.addPlugin(AWSDataStorePlugin())\nAmplify.addPlugin(AWSApiPlugin())\n\nas compared to:\n// Starts in SYNC_VIA_API\nAmplify.addPlugin(AWSApiPlugin())\nAmplify.addPlugin(AWSDataStorePlugin())\n\nIt's kind of a similar situation that we ran into for pluginConfiguration, where we ended up going with a provider-style configuration to delay evaluation of the expression.", "author": "rjuliano", "createdAt": "2020-07-24T20:28:28Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -75,34 +74,28 @@\n     // Keeps track of whether of not the category is initialized yet\n     private final CountDownLatch categoryInitializationsPending;\n \n-    private final AtomicBoolean isOrchestratorReady;\n-\n-    // Used to interrogate plugins, to understand if sync should be automatically turned on\n-    private final ApiCategory api;\n-\n     // User-provided configuration for the plugin.\n     private final DataStoreConfiguration userProvidedConfiguration;\n \n     // Configuration for the plugin that contains settings from the JSON file plus any\n     // overrides provided via the userProvidedConfiguration\n     private DataStoreConfiguration pluginConfiguration;\n \n-    @SuppressLint(\"CheckResult\")\n     private AWSDataStorePlugin(\n             @NonNull ModelProvider modelProvider,\n             @NonNull ModelSchemaRegistry modelSchemaRegistry,\n             @NonNull ApiCategory api,\n             @Nullable DataStoreConfiguration userProvidedConfiguration) {\n         this.sqliteStorageAdapter = SQLiteStorageAdapter.forModels(modelSchemaRegistry, modelProvider);\n         this.categoryInitializationsPending = new CountDownLatch(1);\n-        this.isOrchestratorReady = new AtomicBoolean(false);\n-        this.api = api;\n+        // Used to interrogate plugins, to understand if sync should be automatically turned on\n         this.orchestrator = new Orchestrator(\n             modelProvider,\n             modelSchemaRegistry,\n             sqliteStorageAdapter,\n             AppSyncClient.via(api),\n-            () -> pluginConfiguration\n+            () -> pluginConfiguration,\n+            api.getPlugins().isEmpty() ? Orchestrator.Mode.LOCAL_ONLY : Orchestrator.Mode.SYNC_VIA_API", "originalCommit": "d7364bbe2a9d5d95ed8da42ebc68a6de76d106a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI4ODk0Mw==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r460288943", "bodyText": "Ahhh, yup, absolutely. Great catch.", "author": "jamesonwilliams", "createdAt": "2020-07-24T21:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3Mjc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNzAzNA==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r460837034", "bodyText": "Need a blank line.", "author": "rjuliano", "createdAt": "2020-07-27T11:54:56Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -109,168 +106,231 @@ public Orchestrator(\n             .build();\n         this.subscriptionProcessor = new SubscriptionProcessor(appSync, modelProvider, merger);\n         this.storageObserver = new StorageObserver(localStorageAdapter, mutationOutbox);\n-        this.startStopSemaphore = new Semaphore(1);\n+        this.currentMode = new AtomicReference<>(Mode.STOPPED);\n+        this.targetMode = targetMode;\n+        this.disposables = new CompositeDisposable();\n     }\n \n     /**\n-     * Checks whether the orchestrator is {@link OrchestratorStatus#STARTED}.\n-     * @return True if the orchestrator is started, false otherwise.\n+     * Checks if the orchestrator is running in the desired target state.\n+     * @return true if so, false otherwise.\n      */\n     public boolean isStarted() {\n-        return OrchestratorStatus.STARTED.equals(status.get());\n+        return ObjectsCompat.equals(targetMode.get(), currentMode.get());\n+    }\n+\n+    /**\n+     * Checks if the orchestrator is stopped.\n+     * @return true if so, false otherwise.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    public boolean isStopped() {\n+        return Mode.STOPPED.equals(currentMode.get());\n     }\n \n     /**\n      * Start performing sync operations between the local storage adapter\n      * and the remote GraphQL endpoint.\n-     * @param onLocalStorageReady Callback to signal that it is safe to start interacting with the DataStore.\n-     * @return A Completable operation to start the sync engine orchestrator.\n      */\n-    @NonNull\n-    public synchronized Completable start(Action onLocalStorageReady) {\n-        if (!transitionToState(OrchestratorStatus.STARTED)) {\n-            return Completable.error(new DataStoreException(\n-                \"Unable to start the orchestrator because an operation is already in progress.\",\n-                AmplifyException.TODO_RECOVERY_SUGGESTION)\n-            );\n+    public void start() {\n+        disposables.add(transitionCompletable()\n+            .subscribeOn(Schedulers.io())\n+            .observeOn(Schedulers.io())\n+            .doOnDispose(() -> LOG.info(\"Disposed a transition.\"))\n+            .subscribe(\n+                () -> LOG.info(\"Completed a transition\"),\n+                failure -> LOG.warn(\"Transition failure.\")\n+            ));\n+    }\n+\n+    private Completable transitionCompletable() {\n+        Mode current = currentMode.get();\n+        Mode target = targetMode.get();\n+        LOG.info(String.format(Locale.US,\n+            \"DataStore orchestrator starting. Current mode = %s, target mode = %s.\", current, target\n+        ));\n+        switch (target) {\n+            case STOPPED:\n+                return transitionToStopped(current);\n+            case LOCAL_ONLY:\n+                return transitionToLocalOnly(current);\n+            case SYNC_VIA_API:\n+                return transitionToApiSync(current);\n+            default:\n+                return unknownMode(target);\n         }\n-        return mutationOutbox.load().andThen(\n-            Completable.fromAction(() -> {\n-                LOG.debug(\"Starting the orchestrator.\");\n-                if (!storageObserver.isObservingStorageChanges()) {\n-                    LOG.debug(\"Starting local storage observer.\");\n-                    // At the very least, we need the local storage observer running. Don't need to block\n-                    // for the others. The onLocalStorageReady is invoked to indicate that.\n-                    storageObserver.startObservingStorageChanges(onLocalStorageReady);\n-                }\n-                if (!subscriptionProcessor.isObservingSubscriptionEvents()) {\n-                    LOG.debug(\"Starting subscription processor.\");\n-                    subscriptionProcessor.startSubscriptions();\n-                }\n-                if (!syncProcessor.hydrate().blockingAwait(SYNC_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {\n-                    throw new DataStoreException(\n-                        \"Initial sync during DataStore initialization exceeded timeout of \" + SYNC_TIMEOUT_MS,\n-                        AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n-                    );\n-                }\n-                if (!mutationProcessor.isDrainingMutationOutbox()) {\n-                    LOG.debug(\"Starting mutation processor.\");\n-                    mutationProcessor.startDrainingMutationOutbox();\n-                }\n-                if (!subscriptionProcessor.isDrainingMutationBuffer()) {\n-                    LOG.debug(\"Starting draining mutation buffer.\");\n-                    subscriptionProcessor.startDrainingMutationBuffer();\n-                }\n-                status.compareAndSet(OrchestratorStatus.STARTING, OrchestratorStatus.STARTED);\n-                LOG.debug(\"Orchestrator started.\");\n-                announceRemoteSyncStarted();\n-            })\n-        ).doFinally(startStopSemaphore::release);\n     }\n \n     /**\n-     * Stop all model synchronization.\n-     * @return A completable with the activities\n+     * Stop the orchestrator.\n+     * @return A completable which emits success when orchestrator stops\n      */\n-    public synchronized Completable stop() {\n-        if (!transitionToState(OrchestratorStatus.STOPPED)) {\n-            return Completable.error(new DataStoreException(\n-                \"Unable to stop the orchestrator because an operation is already in progress.\",\n-                AmplifyException.TODO_RECOVERY_SUGGESTION)\n-            );\n+    public Completable stop() {\n+        LOG.info(\"DataStore orchestrator stopping. Current mode = \" + currentMode.get().name());\n+        disposables.clear();\n+        return transitionToStopped(currentMode.get());\n+    }\n+\n+    private static Completable unknownMode(Mode mode) {\n+        return Completable.error(new DataStoreException(\n+            \"Orchestrator state machine made reference to unknown mode = \" + mode.name(),\n+            AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n+        ));\n+    }\n+\n+    private Completable transitionToStopped(Mode current) {\n+        switch (current) {\n+            case SYNC_VIA_API:\n+                return stopApiSync().doFinally(this::stopObservingStorageChanges);\n+            case LOCAL_ONLY:\n+                stopObservingStorageChanges();\n+                return Completable.complete();\n+            case STOPPED:\n+                return Completable.complete();\n+            default:\n+                return unknownMode(current);\n         }\n-        return Completable.fromAction(() -> {\n-            LOG.info(\"Intentionally stopping cloud synchronization, now.\");\n-            subscriptionProcessor.stopAllSubscriptionActivity();\n-            storageObserver.stopObservingStorageChanges();\n-            mutationProcessor.stopDrainingMutationOutbox();\n-            status.compareAndSet(OrchestratorStatus.STOPPING, OrchestratorStatus.STOPPED);\n-            LOG.debug(\"Stopped remote synchronization.\");\n-            announceRemoteSyncStopped();\n-        })\n-        .doFinally(startStopSemaphore::release);\n     }\n \n-    private synchronized boolean transitionToState(OrchestratorStatus targetStatus) {\n-        OrchestratorStatus expectedCurrentStatus;\n-        switch (targetStatus) {\n-            case STARTED:\n-                expectedCurrentStatus = OrchestratorStatus.STOPPED;\n-                break;\n+    private Completable transitionToLocalOnly(Mode current) {\n+        switch (current) {\n             case STOPPED:\n-                expectedCurrentStatus = OrchestratorStatus.STARTED;\n-                break;\n+                startObservingStorageChanges();\n+                return Completable.complete();\n+            case LOCAL_ONLY:\n+                return Completable.complete();\n+            case SYNC_VIA_API:\n+                return stopApiSync();\n             default:\n-                LOG.warn(\"Invalid attempt to transition orchestrator to \" + targetStatus.name());\n-                return false;\n+                return unknownMode(current);\n         }\n-        try {\n-            LOG.debug(\"Requesting permit to set the orchestrator status to:\" + targetStatus.name());\n-            boolean permitAcquired = startStopSemaphore.tryAcquire(ACQUIRE_PERMIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-            if (!permitAcquired) {\n-                LOG.warn(\"Unable to acquire permit to set the orchestrator status to:\" + targetStatus.name());\n-                return false;\n-            }\n-            boolean statusSet = status.compareAndSet(expectedCurrentStatus, targetStatus);\n-            // only stop if it's started AND if we can get a permit.\n-            if (!statusSet) {\n-                LOG.warn(String.format(\"Failed to set orchestrator status to: %s. Current status: %s\",\n-                    targetStatus.name(),\n-                    status.get())\n-                );\n-                // Since we acquired the permit but failed to set the status, let's release the permit.\n-                startStopSemaphore.release();\n-                return false;\n-            }\n-        } catch (InterruptedException exception) {\n-            LOG.warn(\"Orchestrator was interrupted while setting status to \" + targetStatus.name());\n-            return false;\n+    }\n+\n+    private Completable transitionToApiSync(Mode current) {\n+        switch (current) {\n+            case SYNC_VIA_API:\n+                return Completable.complete();\n+            case LOCAL_ONLY:\n+                return startApiSync();\n+            case STOPPED:\n+                startObservingStorageChanges();\n+                return startApiSync();\n+            default:\n+                return unknownMode(current);\n         }\n-        return true;\n     }\n \n-    private void announceRemoteSyncStarted() {\n-        Amplify.Hub.publish(\n-            HubChannel.DATASTORE,\n-            HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STARTED)\n-        );\n+    /**\n+     * Start observing the local storage adapter for changes;\n+     * enqueue them into the mutation outbox.\n+     */\n+    private void startObservingStorageChanges() {\n+        LOG.info(\"Starting to observe local storage changes.\");\n+        Throwable throwable = mutationOutbox.load()\n+            .andThen(Completable.create(emitter -> {\n+                storageObserver.startObservingStorageChanges(emitter::onComplete);\n+                currentMode.set(Mode.LOCAL_ONLY);\n+            })).blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        if (throwable != null) {\n+            LOG.warn(\"Failed to start observing storage changes.\", throwable);\n+        }\n     }\n \n-    private void announceRemoteSyncStopped() {\n-        Amplify.Hub.publish(\n-            HubChannel.DATASTORE,\n-            HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STOPPED)\n-        );\n+    /**\n+     * Stop observing the local storage. Do not enqueue changes to the outbox.\n+     */\n+    private void stopObservingStorageChanges() {\n+        LOG.info(\"Stopping observation of local storage changes.\");\n+        storageObserver.stopObservingStorageChanges();\n+        currentMode.set(Mode.STOPPED);\n     }\n \n     /**\n-     * Represents possible status of the orchestrator.\n+     * Start syncing models to and from a remote API.\n+     * @return A Completable that succeeds when API sync is enabled.\n      */\n-    enum OrchestratorStatus {\n-        /**\n-         * The orchestrator is in the process of shutting down all the necessary components. Any requests to\n-         * start it will be ignored.\n-         *\n-         * Upon completion, the state should be changed to {@link #STOPPED}.\n-         */\n-        STOPPING,\n+    private Completable startApiSync() {\n+        return Completable.fromAction(() -> {\n+            LOG.info(\"Starting API synchronization mode.\");\n+\n+            subscriptionProcessor.startSubscriptions();\n+\n+            LOG.info(\"About to hydrate...\");\n+            Throwable failure = syncProcessor.hydrate()\n+                .subscribeOn(Schedulers.io())\n+                .observeOn(Schedulers.io())\n+                .blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            if (failure != null) {\n+                throw new DataStoreException(\n+                    \"Initial sync during DataStore initialization failed.\", failure,\n+                    AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n+                );\n+            }\n+\n+            LOG.info(\"Draining outbox...\");\n+            mutationProcessor.startDrainingMutationOutbox();\n+\n+            LOG.info(\"Draining subscription buffer...\");\n+            subscriptionProcessor.startDrainingMutationBuffer(this::stopApiSyncBlocking);\n+\n+            LOG.info(\"Publishing to hub...\");\n+            Amplify.Hub.publish(\n+                HubChannel.DATASTORE,\n+                HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STARTED)\n+            );\n+        })\n+        .doOnComplete(() -> currentMode.set(Mode.SYNC_VIA_API))\n+        .doOnError(error -> {\n+            LOG.error(\"Failure encountered while attempting to start API sync.\", error);\n+            stopApiSyncBlocking();\n+        })\n+        .onErrorComplete()\n+        .subscribeOn(Schedulers.io())\n+        .observeOn(Schedulers.io());\n+    }\n+\n+    private void stopApiSyncBlocking() {\n+        Throwable failure = stopApiSync().blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        if (failure != null) {\n+            LOG.warn(\"Failed to stop API sync.\", failure);\n+        }\n+    }\n+    /**", "originalCommit": "e89b7a1ebf6cbaa64d6b17f51161e8b1c0d0c179", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA4MjQyMA==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r461082420", "bodyText": "Thanks!", "author": "jamesonwilliams", "createdAt": "2020-07-27T18:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNzAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzODI5NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r460838294", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Orchestrator.Mode.SYNC_VIA_API\n          \n          \n            \n                            () -> Orchestrator.Mode.SYNC_VIA_API", "author": "rjuliano", "createdAt": "2020-07-27T11:57:25Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/OrchestratorTest.java", "diffHunk": "@@ -84,15 +84,17 @@ public void itemsPlacedInStorageArePublishedToNetwork() throws AmplifyException\n                 modelSchemaRegistry,\n                 localStorageAdapter,\n                 appSync,\n-                DataStoreConfiguration::defaults\n+                DataStoreConfiguration::defaults,\n+                Orchestrator.Mode.SYNC_VIA_API", "originalCommit": "e89b7a1ebf6cbaa64d6b17f51161e8b1c0d0c179", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA4MzAwOA==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r461083008", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /**\n          \n          \n            \n            \n          \n          \n            \n                /**", "author": "jamesonwilliams", "createdAt": "2020-07-27T18:22:52Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Orchestrator.java", "diffHunk": "@@ -109,168 +106,231 @@ public Orchestrator(\n             .build();\n         this.subscriptionProcessor = new SubscriptionProcessor(appSync, modelProvider, merger);\n         this.storageObserver = new StorageObserver(localStorageAdapter, mutationOutbox);\n-        this.startStopSemaphore = new Semaphore(1);\n+        this.currentMode = new AtomicReference<>(Mode.STOPPED);\n+        this.targetMode = targetMode;\n+        this.disposables = new CompositeDisposable();\n     }\n \n     /**\n-     * Checks whether the orchestrator is {@link OrchestratorStatus#STARTED}.\n-     * @return True if the orchestrator is started, false otherwise.\n+     * Checks if the orchestrator is running in the desired target state.\n+     * @return true if so, false otherwise.\n      */\n     public boolean isStarted() {\n-        return OrchestratorStatus.STARTED.equals(status.get());\n+        return ObjectsCompat.equals(targetMode.get(), currentMode.get());\n+    }\n+\n+    /**\n+     * Checks if the orchestrator is stopped.\n+     * @return true if so, false otherwise.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    public boolean isStopped() {\n+        return Mode.STOPPED.equals(currentMode.get());\n     }\n \n     /**\n      * Start performing sync operations between the local storage adapter\n      * and the remote GraphQL endpoint.\n-     * @param onLocalStorageReady Callback to signal that it is safe to start interacting with the DataStore.\n-     * @return A Completable operation to start the sync engine orchestrator.\n      */\n-    @NonNull\n-    public synchronized Completable start(Action onLocalStorageReady) {\n-        if (!transitionToState(OrchestratorStatus.STARTED)) {\n-            return Completable.error(new DataStoreException(\n-                \"Unable to start the orchestrator because an operation is already in progress.\",\n-                AmplifyException.TODO_RECOVERY_SUGGESTION)\n-            );\n+    public void start() {\n+        disposables.add(transitionCompletable()\n+            .subscribeOn(Schedulers.io())\n+            .observeOn(Schedulers.io())\n+            .doOnDispose(() -> LOG.info(\"Disposed a transition.\"))\n+            .subscribe(\n+                () -> LOG.info(\"Completed a transition\"),\n+                failure -> LOG.warn(\"Transition failure.\")\n+            ));\n+    }\n+\n+    private Completable transitionCompletable() {\n+        Mode current = currentMode.get();\n+        Mode target = targetMode.get();\n+        LOG.info(String.format(Locale.US,\n+            \"DataStore orchestrator starting. Current mode = %s, target mode = %s.\", current, target\n+        ));\n+        switch (target) {\n+            case STOPPED:\n+                return transitionToStopped(current);\n+            case LOCAL_ONLY:\n+                return transitionToLocalOnly(current);\n+            case SYNC_VIA_API:\n+                return transitionToApiSync(current);\n+            default:\n+                return unknownMode(target);\n         }\n-        return mutationOutbox.load().andThen(\n-            Completable.fromAction(() -> {\n-                LOG.debug(\"Starting the orchestrator.\");\n-                if (!storageObserver.isObservingStorageChanges()) {\n-                    LOG.debug(\"Starting local storage observer.\");\n-                    // At the very least, we need the local storage observer running. Don't need to block\n-                    // for the others. The onLocalStorageReady is invoked to indicate that.\n-                    storageObserver.startObservingStorageChanges(onLocalStorageReady);\n-                }\n-                if (!subscriptionProcessor.isObservingSubscriptionEvents()) {\n-                    LOG.debug(\"Starting subscription processor.\");\n-                    subscriptionProcessor.startSubscriptions();\n-                }\n-                if (!syncProcessor.hydrate().blockingAwait(SYNC_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {\n-                    throw new DataStoreException(\n-                        \"Initial sync during DataStore initialization exceeded timeout of \" + SYNC_TIMEOUT_MS,\n-                        AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n-                    );\n-                }\n-                if (!mutationProcessor.isDrainingMutationOutbox()) {\n-                    LOG.debug(\"Starting mutation processor.\");\n-                    mutationProcessor.startDrainingMutationOutbox();\n-                }\n-                if (!subscriptionProcessor.isDrainingMutationBuffer()) {\n-                    LOG.debug(\"Starting draining mutation buffer.\");\n-                    subscriptionProcessor.startDrainingMutationBuffer();\n-                }\n-                status.compareAndSet(OrchestratorStatus.STARTING, OrchestratorStatus.STARTED);\n-                LOG.debug(\"Orchestrator started.\");\n-                announceRemoteSyncStarted();\n-            })\n-        ).doFinally(startStopSemaphore::release);\n     }\n \n     /**\n-     * Stop all model synchronization.\n-     * @return A completable with the activities\n+     * Stop the orchestrator.\n+     * @return A completable which emits success when orchestrator stops\n      */\n-    public synchronized Completable stop() {\n-        if (!transitionToState(OrchestratorStatus.STOPPED)) {\n-            return Completable.error(new DataStoreException(\n-                \"Unable to stop the orchestrator because an operation is already in progress.\",\n-                AmplifyException.TODO_RECOVERY_SUGGESTION)\n-            );\n+    public Completable stop() {\n+        LOG.info(\"DataStore orchestrator stopping. Current mode = \" + currentMode.get().name());\n+        disposables.clear();\n+        return transitionToStopped(currentMode.get());\n+    }\n+\n+    private static Completable unknownMode(Mode mode) {\n+        return Completable.error(new DataStoreException(\n+            \"Orchestrator state machine made reference to unknown mode = \" + mode.name(),\n+            AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n+        ));\n+    }\n+\n+    private Completable transitionToStopped(Mode current) {\n+        switch (current) {\n+            case SYNC_VIA_API:\n+                return stopApiSync().doFinally(this::stopObservingStorageChanges);\n+            case LOCAL_ONLY:\n+                stopObservingStorageChanges();\n+                return Completable.complete();\n+            case STOPPED:\n+                return Completable.complete();\n+            default:\n+                return unknownMode(current);\n         }\n-        return Completable.fromAction(() -> {\n-            LOG.info(\"Intentionally stopping cloud synchronization, now.\");\n-            subscriptionProcessor.stopAllSubscriptionActivity();\n-            storageObserver.stopObservingStorageChanges();\n-            mutationProcessor.stopDrainingMutationOutbox();\n-            status.compareAndSet(OrchestratorStatus.STOPPING, OrchestratorStatus.STOPPED);\n-            LOG.debug(\"Stopped remote synchronization.\");\n-            announceRemoteSyncStopped();\n-        })\n-        .doFinally(startStopSemaphore::release);\n     }\n \n-    private synchronized boolean transitionToState(OrchestratorStatus targetStatus) {\n-        OrchestratorStatus expectedCurrentStatus;\n-        switch (targetStatus) {\n-            case STARTED:\n-                expectedCurrentStatus = OrchestratorStatus.STOPPED;\n-                break;\n+    private Completable transitionToLocalOnly(Mode current) {\n+        switch (current) {\n             case STOPPED:\n-                expectedCurrentStatus = OrchestratorStatus.STARTED;\n-                break;\n+                startObservingStorageChanges();\n+                return Completable.complete();\n+            case LOCAL_ONLY:\n+                return Completable.complete();\n+            case SYNC_VIA_API:\n+                return stopApiSync();\n             default:\n-                LOG.warn(\"Invalid attempt to transition orchestrator to \" + targetStatus.name());\n-                return false;\n+                return unknownMode(current);\n         }\n-        try {\n-            LOG.debug(\"Requesting permit to set the orchestrator status to:\" + targetStatus.name());\n-            boolean permitAcquired = startStopSemaphore.tryAcquire(ACQUIRE_PERMIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n-            if (!permitAcquired) {\n-                LOG.warn(\"Unable to acquire permit to set the orchestrator status to:\" + targetStatus.name());\n-                return false;\n-            }\n-            boolean statusSet = status.compareAndSet(expectedCurrentStatus, targetStatus);\n-            // only stop if it's started AND if we can get a permit.\n-            if (!statusSet) {\n-                LOG.warn(String.format(\"Failed to set orchestrator status to: %s. Current status: %s\",\n-                    targetStatus.name(),\n-                    status.get())\n-                );\n-                // Since we acquired the permit but failed to set the status, let's release the permit.\n-                startStopSemaphore.release();\n-                return false;\n-            }\n-        } catch (InterruptedException exception) {\n-            LOG.warn(\"Orchestrator was interrupted while setting status to \" + targetStatus.name());\n-            return false;\n+    }\n+\n+    private Completable transitionToApiSync(Mode current) {\n+        switch (current) {\n+            case SYNC_VIA_API:\n+                return Completable.complete();\n+            case LOCAL_ONLY:\n+                return startApiSync();\n+            case STOPPED:\n+                startObservingStorageChanges();\n+                return startApiSync();\n+            default:\n+                return unknownMode(current);\n         }\n-        return true;\n     }\n \n-    private void announceRemoteSyncStarted() {\n-        Amplify.Hub.publish(\n-            HubChannel.DATASTORE,\n-            HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STARTED)\n-        );\n+    /**\n+     * Start observing the local storage adapter for changes;\n+     * enqueue them into the mutation outbox.\n+     */\n+    private void startObservingStorageChanges() {\n+        LOG.info(\"Starting to observe local storage changes.\");\n+        Throwable throwable = mutationOutbox.load()\n+            .andThen(Completable.create(emitter -> {\n+                storageObserver.startObservingStorageChanges(emitter::onComplete);\n+                currentMode.set(Mode.LOCAL_ONLY);\n+            })).blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        if (throwable != null) {\n+            LOG.warn(\"Failed to start observing storage changes.\", throwable);\n+        }\n     }\n \n-    private void announceRemoteSyncStopped() {\n-        Amplify.Hub.publish(\n-            HubChannel.DATASTORE,\n-            HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STOPPED)\n-        );\n+    /**\n+     * Stop observing the local storage. Do not enqueue changes to the outbox.\n+     */\n+    private void stopObservingStorageChanges() {\n+        LOG.info(\"Stopping observation of local storage changes.\");\n+        storageObserver.stopObservingStorageChanges();\n+        currentMode.set(Mode.STOPPED);\n     }\n \n     /**\n-     * Represents possible status of the orchestrator.\n+     * Start syncing models to and from a remote API.\n+     * @return A Completable that succeeds when API sync is enabled.\n      */\n-    enum OrchestratorStatus {\n-        /**\n-         * The orchestrator is in the process of shutting down all the necessary components. Any requests to\n-         * start it will be ignored.\n-         *\n-         * Upon completion, the state should be changed to {@link #STOPPED}.\n-         */\n-        STOPPING,\n+    private Completable startApiSync() {\n+        return Completable.fromAction(() -> {\n+            LOG.info(\"Starting API synchronization mode.\");\n+\n+            subscriptionProcessor.startSubscriptions();\n+\n+            LOG.info(\"About to hydrate...\");\n+            Throwable failure = syncProcessor.hydrate()\n+                .subscribeOn(Schedulers.io())\n+                .observeOn(Schedulers.io())\n+                .blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            if (failure != null) {\n+                throw new DataStoreException(\n+                    \"Initial sync during DataStore initialization failed.\", failure,\n+                    AmplifyException.REPORT_BUG_TO_AWS_SUGGESTION\n+                );\n+            }\n+\n+            LOG.info(\"Draining outbox...\");\n+            mutationProcessor.startDrainingMutationOutbox();\n+\n+            LOG.info(\"Draining subscription buffer...\");\n+            subscriptionProcessor.startDrainingMutationBuffer(this::stopApiSyncBlocking);\n+\n+            LOG.info(\"Publishing to hub...\");\n+            Amplify.Hub.publish(\n+                HubChannel.DATASTORE,\n+                HubEvent.create(DataStoreChannelEventName.REMOTE_SYNC_STARTED)\n+            );\n+        })\n+        .doOnComplete(() -> currentMode.set(Mode.SYNC_VIA_API))\n+        .doOnError(error -> {\n+            LOG.error(\"Failure encountered while attempting to start API sync.\", error);\n+            stopApiSyncBlocking();\n+        })\n+        .onErrorComplete()\n+        .subscribeOn(Schedulers.io())\n+        .observeOn(Schedulers.io());\n+    }\n+\n+    private void stopApiSyncBlocking() {\n+        Throwable failure = stopApiSync().blockingGet(OP_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+        if (failure != null) {\n+            LOG.warn(\"Failed to stop API sync.\", failure);\n+        }\n+    }\n+    /**", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4OTkwNg==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r462489906", "bodyText": "TLDR version: The DataStore.clear call may have to wait for the orchestrator to start. We might need to do something like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!isCategoryInitialized) {\n          \n          \n            \n                    if (!isCategoryInitialized || !orchestrator.isStarted()) {\n          \n      \n    \n    \n  \n\nIf the clear API is called immediately after calling Amplify.configure but before the Orchestrator has a chance to fully start (i.e. it's in LOCAL_ONLY mode and in the process doing stuff before going into SYNC_VIA_API), the call to DataStore.clear() does the following:\n\nCall orchestrator.stop() (which is correct); however, the call to transitionToStopped only stops the storage observer because the current status of the orchestrator is LOCAL_ONLY.\nSubscription attempt is interrupted but the rest of the startApiSync continues because we're not re-throwing the interrupted exception.\nOrchestrator status is set to STOPPED.\nDataStore is cleared. (also correct)\n[Original call to orchestrator.start()] Somehow, the startApiSync call completes and sets the status SYNC_VIA_API\nCalls orchestrator.start() but this results in a no-op because the status is already SYNC_VIA_API. The problem is that at this point, the SubscriptionProcessor and MutationProcessor are in an unknown state.\n\nUsing my sample app, the app does not crash but mutations are not being sent and subscriptions are not started.", "author": "rjuliano", "createdAt": "2020-07-29T18:07:52Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -438,70 +424,50 @@ public void observe(\n      * @param onComplete Invoked if the call is successful.\n      * @param onError Invoked if not successful\n      */\n+    @SuppressWarnings(\"unused\")\n     @Override\n     public void clear(@NonNull Action onComplete,\n                       @NonNull Consumer<DataStoreException> onError) {\n         // We shouldn't call beforeOperation when clearing the DataStore. The\n         // only thing we have to wait for is the category initialization latch.\n         boolean isCategoryInitialized = false;\n         try {\n-            isCategoryInitialized = categoryInitializationsPending.await(PLUGIN_INIT_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+            isCategoryInitialized = categoryInitializationsPending.await(LIFECYCLE_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n         } catch (InterruptedException exception) {\n             LOG.warn(\"Execution interrupted while waiting for DataStore to be initialized.\");\n         }\n         if (!isCategoryInitialized) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNDYwMQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r462624601", "bodyText": "Thanks for this detailed analysis!\nI started looking at additional steps that could be taken to tighten up the serialization guarantees in the Orchestrator. I think we can still do that.\nBut, in the interest of delivering this current fix, I will go with the !orchestrator.isStarted() approach you suggest. It isn't ideal, but as you note, we've solved most of the problems by now and are into the long tail.", "author": "jamesonwilliams", "createdAt": "2020-07-29T22:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4OTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1ODA3OA==", "url": "https://github.com/aws-amplify/amplify-android/pull/662#discussion_r462958078", "bodyText": "Totally agree with this. I think we can continue to iterate on this as needed, but I also feel that with that change, this PR should be considered ready to go.", "author": "rjuliano", "createdAt": "2020-07-30T12:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4OTkwNg=="}], "type": "inlineReview"}, {"oid": "a6e3845b490998b9b6944a515b35e59c538469ea", "url": "https://github.com/aws-amplify/amplify-android/commit/a6e3845b490998b9b6944a515b35e59c538469ea", "message": "fix: daemon style lifecycle for orchestrator\n\nThe state machine in the orchestrator is changed. The three possible\nstates are now:\n\n  a. STOPPED      No sync component is running, and local changes are not\n                  being queued into an offline mutations queue.\n  b. LOCAL_ONLY   Local changes are being buffered into an offline\n                  mutations queue, but are not being transacte with the\n                  cloud\n  c. SYNC_VIA_API Data is syncrhonizing to and from the cloud.\n\nLogic is added to transition safely between any pair of these states\n(there are six possible transitions.)\n\nIf the Orchestrator fails to start up cleanly, then tear down any/all\ncopmonents that were started, and enter offline-only mode.\n\n0. Retry logic is _removed_ from the subscription processor. Instead, if\n   a subscription fails, the failure is communicated back to the\n   Orchestrator. The Orchestrator should then exist API sync mode.\n\n1. The AWSDataStorePlugin had strated to take on sync engine\n   orchestration concerns. All orchestration concerns are removed from\n   the plugin, and moved into the Orchestrator, again.\n\n2. Surface exceptions from the hydrate() call on the SyncProcessor. This\n   way, if the sync fails, the orchestrator will catch the exception,\n   and begin a graceful shutdown sequence.\n\nSome changes amde in the test code include:\n\n0. Mock AppSync behaviors in the OrchestratorTest. Previously, the\n   subcription code was not being included in the test. Once exercised,\n   it became necessarily to fulfill the missing mocks.\n\n1. Start listening for HubEvents in AWSDataStorePluginTest _before_ they\n   will be published. This will help to ensure we always can catch them,\n   in th tests.\n\n2. Since the SyncEngine errors are no longer gobbled, the behavior of\n   userProvidedErrorCallbackInvokedOnFailure has changed. We now\n   expect only a single call to the user-provided error callback,\n   instead of _many_ consecutives ones, as before.\n\n3. Add a version of Latch#await(int, TimeUnit) which allows a custom\n   wait time to be provided. This is useful in the orchestrator code,\n   where longer-than-usual timeouts are encountered.\n\nFuture work will address transient network failures, further. Instead of\nindividual sync engine components owning their own retries, the\nOrchestrator's lifecycle *as a whole* should be retried. When the\nnetwork goes down, or when auth fails -- any transient failure -- the\nOrchestrator should back off and enter LOCAL_ONLY mode. Additional retry\nlogic added to the orchestrator will ensure that it intelligently\nattempts to reach the target mode, again.\n\nResolves: https://github.com/aws-amplify/amplify-android/issues/636", "committedDate": "2020-07-29T22:24:07Z", "type": "commit"}, {"oid": "a6e3845b490998b9b6944a515b35e59c538469ea", "url": "https://github.com/aws-amplify/amplify-android/commit/a6e3845b490998b9b6944a515b35e59c538469ea", "message": "fix: daemon style lifecycle for orchestrator\n\nThe state machine in the orchestrator is changed. The three possible\nstates are now:\n\n  a. STOPPED      No sync component is running, and local changes are not\n                  being queued into an offline mutations queue.\n  b. LOCAL_ONLY   Local changes are being buffered into an offline\n                  mutations queue, but are not being transacte with the\n                  cloud\n  c. SYNC_VIA_API Data is syncrhonizing to and from the cloud.\n\nLogic is added to transition safely between any pair of these states\n(there are six possible transitions.)\n\nIf the Orchestrator fails to start up cleanly, then tear down any/all\ncopmonents that were started, and enter offline-only mode.\n\n0. Retry logic is _removed_ from the subscription processor. Instead, if\n   a subscription fails, the failure is communicated back to the\n   Orchestrator. The Orchestrator should then exist API sync mode.\n\n1. The AWSDataStorePlugin had strated to take on sync engine\n   orchestration concerns. All orchestration concerns are removed from\n   the plugin, and moved into the Orchestrator, again.\n\n2. Surface exceptions from the hydrate() call on the SyncProcessor. This\n   way, if the sync fails, the orchestrator will catch the exception,\n   and begin a graceful shutdown sequence.\n\nSome changes amde in the test code include:\n\n0. Mock AppSync behaviors in the OrchestratorTest. Previously, the\n   subcription code was not being included in the test. Once exercised,\n   it became necessarily to fulfill the missing mocks.\n\n1. Start listening for HubEvents in AWSDataStorePluginTest _before_ they\n   will be published. This will help to ensure we always can catch them,\n   in th tests.\n\n2. Since the SyncEngine errors are no longer gobbled, the behavior of\n   userProvidedErrorCallbackInvokedOnFailure has changed. We now\n   expect only a single call to the user-provided error callback,\n   instead of _many_ consecutives ones, as before.\n\n3. Add a version of Latch#await(int, TimeUnit) which allows a custom\n   wait time to be provided. This is useful in the orchestrator code,\n   where longer-than-usual timeouts are encountered.\n\nFuture work will address transient network failures, further. Instead of\nindividual sync engine components owning their own retries, the\nOrchestrator's lifecycle *as a whole* should be retried. When the\nnetwork goes down, or when auth fails -- any transient failure -- the\nOrchestrator should back off and enter LOCAL_ONLY mode. Additional retry\nlogic added to the orchestrator will ensure that it intelligently\nattempts to reach the target mode, again.\n\nResolves: https://github.com/aws-amplify/amplify-android/issues/636", "committedDate": "2020-07-29T22:24:07Z", "type": "forcePushed"}]}