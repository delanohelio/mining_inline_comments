{"pr_number": 720, "pr_title": "Support Top/Rare Command In PPL", "pr_createdAt": "2020-08-28T17:40:17Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720", "timeline": [{"oid": "5fe5aa77df04373f483da127ebc7fd690cacf868", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/5fe5aa77df04373f483da127ebc7fd690cacf868", "message": "ast - rare and top command", "committedDate": "2020-08-17T21:28:26Z", "type": "commit"}, {"oid": "4c2000afbff13760abb719b9c129568334c1ab18", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/4c2000afbff13760abb719b9c129568334c1ab18", "message": "fix build failure", "committedDate": "2020-08-18T00:25:48Z", "type": "commit"}, {"oid": "2d98f316718ef08d03f4142c2dd81662a1886d66", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/2d98f316718ef08d03f4142c2dd81662a1886d66", "message": "fix build failure - test coverage ratio for ppl", "committedDate": "2020-08-18T00:44:11Z", "type": "commit"}, {"oid": "740a9f04177154cd307a05dfd8f6a5c692dc4c88", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/740a9f04177154cd307a05dfd8f6a5c692dc4c88", "message": "Merge branch 'develop' of https://github.com/rupal-bq/sql into ppl/rare-top", "committedDate": "2020-08-18T19:45:35Z", "type": "commit"}, {"oid": "016a886fe57dad1662b4bb54aef10f046cb930e9", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/016a886fe57dad1662b4bb54aef10f046cb930e9", "message": "add logical, physical plan for rare & top", "committedDate": "2020-08-26T03:40:44Z", "type": "commit"}, {"oid": "574cadb3921094138f91e13f82ff1b6cd7d5db58", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/574cadb3921094138f91e13f82ff1b6cd7d5db58", "message": "Merge branch 'develop' of https://github.com/rupal-bq/sql into ppl/rare-top", "committedDate": "2020-08-26T03:49:12Z", "type": "commit"}, {"oid": "b4aa9151583114345f057b84d3f24f009bcfb034", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/b4aa9151583114345f057b84d3f24f009bcfb034", "message": "merge rare & top operator since both commands operate identical to each other", "committedDate": "2020-08-26T20:59:39Z", "type": "commit"}, {"oid": "372bf314472a53bfe7dcb0ef46bc41352e5acb9b", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/372bf314472a53bfe7dcb0ef46bc41352e5acb9b", "message": "add tests", "committedDate": "2020-08-28T02:55:19Z", "type": "commit"}, {"oid": "01245a3a71dedac6d8bb636cab2e62700c401ef4", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/01245a3a71dedac6d8bb636cab2e62700c401ef4", "message": "update docs", "committedDate": "2020-08-28T04:09:31Z", "type": "commit"}, {"oid": "97cef7f1bca51240ab6fb15a4600046dfbca2241", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/97cef7f1bca51240ab6fb15a4600046dfbca2241", "message": "Merge branch 'develop' of https://github.com/rupal-bq/sql into ppl/rare-top", "committedDate": "2020-08-28T04:10:39Z", "type": "commit"}, {"oid": "c41319b976392d3394642d4b627404c80bb2c074", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/c41319b976392d3394642d4b627404c80bb2c074", "message": "add comments", "committedDate": "2020-08-28T17:29:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1MjAxMw==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479452013", "bodyText": "Some use a constant like DEFAULT_NO_OF_RESULTS and some have 10 hardcoded. Should probably be consistent with the constant.", "author": "raymond-lum-zz", "createdAt": "2020-08-28T17:50:51Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalPlanDSL.java", "diffHunk": "@@ -83,6 +84,16 @@ public static LogicalPlan dedupe(\n         input, Arrays.asList(fields), allowedDuplication, keepEmpty, consecutive);\n   }\n \n+  public static LogicalPlan rareTopN(LogicalPlan input, Boolean rareTopFlag,\n+      List<Expression> groupByList, Expression... fields) {\n+    return rareTopN(input, rareTopFlag, 10, groupByList, fields);", "originalCommit": "c41319b976392d3394642d4b627404c80bb2c074", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3OTM4MQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479579381", "bodyText": "Used the variable/function to get default value wherever required. hardcoded values are used for the test purpose.", "author": "rupal-bq", "createdAt": "2020-08-29T00:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1MjAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MTA3NQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479471075", "bodyText": "Missing license header.", "author": "jduo", "createdAt": "2020-08-28T18:32:22Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalRareTopN.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.logical;", "originalCommit": "c41319b976392d3394642d4b627404c80bb2c074", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NTA1NA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479575054", "bodyText": "added", "author": "rupal-bq", "createdAt": "2020-08-28T23:38:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MTA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MjA0Mg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479472042", "bodyText": "In a different method we use ImmutableList.of() here. Let's be consistent.", "author": "jduo", "createdAt": "2020-08-28T18:34:43Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/logical/LogicalRareTopN.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.logical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Logical Rare and TopN Plan.\n+ */\n+@Getter\n+@ToString\n+@EqualsAndHashCode(callSuper = false)\n+@RequiredArgsConstructor\n+public class LogicalRareTopN extends LogicalPlan {\n+\n+  private final LogicalPlan child;\n+  private final Boolean rareTopFlag;\n+  private final Integer noOfResults;\n+  private final List<Expression> fieldList;\n+  private final List<Expression> groupByList;\n+\n+  @Override\n+  public List<LogicalPlan> getChild() {\n+    return Collections.singletonList(child);", "originalCommit": "c41319b976392d3394642d4b627404c80bb2c074", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NjE3Mg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479576172", "bodyText": "Replaced ImmutableList.of(child) in RareTopN.java with Collections.singletonList(child)", "author": "rupal-bq", "createdAt": "2020-08-28T23:44:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MjA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MjQzMg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479472432", "bodyText": "We are missing the license header here.", "author": "jduo", "createdAt": "2020-08-28T18:35:41Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;", "originalCommit": "c41319b976392d3394642d4b627404c80bb2c074", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NTk0Mg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479575942", "bodyText": "added", "author": "rupal-bq", "createdAt": "2020-08-28T23:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MjQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3NzYxNg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479477616", "bodyText": "findTop() and findRare() have the same implementation, except the comparator is different. We could just have a single find() function that takes in a comparator instead.", "author": "jduo", "createdAt": "2020-08-28T18:46:53Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {", "originalCommit": "c41319b976392d3394642d4b627404c80bb2c074", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3ODI4NQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479578285", "bodyText": "replaced with find() function", "author": "rupal-bq", "createdAt": "2020-08-28T23:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3NzYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4MDE4Ng==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479480186", "bodyText": "This algorithm for building this list is too complicated. I think you can model this more easily with streams.\nmap.entrySet().stream()\n.sort(ValueComparator)\n.limit(noOfResults)\nPass in different comparator for rare vs. top.\n.", "author": "jduo", "createdAt": "2020-08-28T18:53:04Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e1) - map.get(e2);\n+        }\n+      });\n+\n+      return getList(map, topQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of rare values.\n+     */\n+    public List<FieldKey> findRare(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> rareQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e2) - map.get(e1);\n+        }\n+      });\n+\n+      return getList(map, rareQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> getList(HashMap<FieldKey, Integer> map, PriorityQueue<FieldKey> queue,", "originalCommit": "c41319b976392d3394642d4b627404c80bb2c074", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3ODQzNg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479578436", "bodyText": "Thanks. Added this in find() function.", "author": "rupal-bq", "createdAt": "2020-08-28T23:56:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4MDE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4MjM0MA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479482340", "bodyText": "Usually you don't want to return the specific type and instead return the interface unless the caller really needs to work with LinkedHashMap in particular.", "author": "jduo", "createdAt": "2020-08-28T18:58:11Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e1) - map.get(e2);\n+        }\n+      });\n+\n+      return getList(map, topQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of rare values.\n+     */\n+    public List<FieldKey> findRare(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> rareQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e2) - map.get(e1);\n+        }\n+      });\n+\n+      return getList(map, rareQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> getList(HashMap<FieldKey, Integer> map, PriorityQueue<FieldKey> queue,\n+        Integer size) {\n+      for (Map.Entry<FieldKey, Integer> entry : map.entrySet()) {\n+        queue.add(entry.getKey());\n+        if (queue.size() > size) {\n+          queue.poll();\n+        }\n+      }\n+\n+      List<FieldKey> list = new ArrayList<>();\n+      while (!queue.isEmpty()) {\n+        list.add(queue.poll());\n+      }\n+\n+      Collections.reverse(list);\n+      return list;\n+    }\n+\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public LinkedHashMap<String, ExprValue> fieldKeyMap() {", "originalCommit": "c41319b976392d3394642d4b627404c80bb2c074", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3OTY1MQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479579651", "bodyText": "Thanks. Changed return type to Map.", "author": "rupal-bq", "createdAt": "2020-08-29T00:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ4MjM0MA=="}], "type": "inlineReview"}, {"oid": "c9e4353428d8edbfe9f13e13b5e48516e21edef9", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/c9e4353428d8edbfe9f13e13b5e48516e21edef9", "message": "addressing PR comments", "committedDate": "2020-08-28T23:34:56Z", "type": "commit"}, {"oid": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/8582d37c3946a510786be7c9ce8cc09a4ae0a08c", "message": "fix build error", "committedDate": "2020-08-28T23:47:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3Mzc4MA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479673780", "bodyText": "Missing the license header.", "author": "jduo", "createdAt": "2020-08-29T17:54:59Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/ast/tree/RareTopN.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.amazon.opendistroforelasticsearch.sql.ast.tree;", "originalCommit": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MjEyNg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r480382126", "bodyText": "added", "author": "rupal-bq", "createdAt": "2020-08-31T20:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3Mzc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDA1OQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674059", "bodyText": "Lets use fieldExprList.stream().map(...).collect(Collectors.toList())", "author": "jduo", "createdAt": "2020-08-29T17:58:01Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {", "originalCommit": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MjkyNw==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r480382927", "bodyText": "Switched to stream", "author": "rupal-bq", "createdAt": "2020-08-31T20:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDgwNw==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674807", "bodyText": "Are you using guava? Can you use Streams.zip().collect(Collectors.toMap(...))?", "author": "jduo", "createdAt": "2020-08-29T18:06:28Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public Map<String, ExprValue> fieldKeyMap() {\n+      Map<String, ExprValue> map = new LinkedHashMap<>();\n+      for (int i = 0; i < fieldExprList.size(); i++) {", "originalCommit": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MzU1NA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r480383554", "bodyText": "Replaced with Streams.zip()...", "author": "rupal-bq", "createdAt": "2020-08-31T20:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDg5NA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674894", "bodyText": "Switch to stream", "author": "jduo", "createdAt": "2020-08-29T18:07:21Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public Map<String, ExprValue> fieldKeyMap() {\n+      Map<String, ExprValue> map = new LinkedHashMap<>();\n+      for (int i = 0; i < fieldExprList.size(); i++) {\n+        map.put(fieldExprList.get(i).toString(), fieldByValueList.get(i));\n+      }\n+      return map;\n+    }\n+  }\n+\n+  /**\n+   * Group Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class GroupKey {\n+\n+    private final List<ExprValue> groupByValueList;\n+\n+    /**\n+     * GroupKey constructor.\n+     */\n+    public GroupKey(ExprValue value) {\n+      this.groupByValueList = new ArrayList<>();\n+      for (Expression groupExpr : groupByExprList) {", "originalCommit": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MzY5Mg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r480383692", "bodyText": "done", "author": "rupal-bq", "createdAt": "2020-08-31T20:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDkxNA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674914", "bodyText": "Switch to stream.", "author": "jduo", "createdAt": "2020-08-29T18:07:43Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        Map<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+          List<FieldKey> result = find(fieldMap);\n+          result.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> find(HashMap<FieldKey, Integer> map) {\n+      Comparator<Map.Entry<FieldKey, Integer>> valueComparator;\n+      if (rareTopFlag) {\n+        valueComparator = Map.Entry.comparingByValue(Comparator.reverseOrder());\n+      } else {\n+        valueComparator = Map.Entry.comparingByValue();\n+      }\n+\n+      return map.entrySet().stream().sorted(valueComparator).limit(noOfResults)\n+          .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+  }\n+\n+  /**\n+   * Field Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class FieldKey {\n+\n+    private final List<ExprValue> fieldByValueList;\n+\n+    /**\n+     * FieldKey constructor.\n+     */\n+    public FieldKey(ExprValue value) {\n+      this.fieldByValueList = new ArrayList<>();\n+      for (Expression fieldExpr : fieldExprList) {\n+        this.fieldByValueList.add(fieldExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of field and field value.\n+     */\n+    public Map<String, ExprValue> fieldKeyMap() {\n+      Map<String, ExprValue> map = new LinkedHashMap<>();\n+      for (int i = 0; i < fieldExprList.size(); i++) {\n+        map.put(fieldExprList.get(i).toString(), fieldByValueList.get(i));\n+      }\n+      return map;\n+    }\n+  }\n+\n+  /**\n+   * Group Key.\n+   */\n+  @EqualsAndHashCode\n+  @VisibleForTesting\n+  public class GroupKey {\n+\n+    private final List<ExprValue> groupByValueList;\n+\n+    /**\n+     * GroupKey constructor.\n+     */\n+    public GroupKey(ExprValue value) {\n+      this.groupByValueList = new ArrayList<>();\n+      for (Expression groupExpr : groupByExprList) {\n+        this.groupByValueList.add(groupExpr.valueOf(value.bindingTuples()));\n+      }\n+    }\n+\n+    /**\n+     * Return the Map of group field and group field value.\n+     */\n+    public Map<String, ExprValue> groupKeyMap() {", "originalCommit": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDk5Mg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479674992", "bodyText": "This is the same logic and return type as for FieldKey#fieldKeyMap. Can they derive from a common base, or use a generic parameter?\nThe constructor is also pretty much the same.", "author": "jduo", "createdAt": "2020-08-29T18:08:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4NDAxOA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r480384018", "bodyText": "Used common class for finding group & field key", "author": "rupal-bq", "createdAt": "2020-08-31T20:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NDkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NTkxNg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479675916", "bodyText": "Code is the same for these two methods, except differing by the flag. Can they be combined into a helper? If the two context classes have the same methods...", "author": "jduo", "createdAt": "2020-08-29T18:18:59Z", "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "diffHunk": "@@ -197,6 +203,62 @@ public UnresolvedPlan visitEvalCommand(EvalCommandContext ctx) {\n     );\n   }\n \n+  /**\n+   * Rare command.\n+   */\n+  @Override\n+  public UnresolvedPlan visitRareCommand(RareCommandContext ctx) {\n+    List<UnresolvedExpression> groupList = ctx.byClause() == null ? Collections.emptyList() :\n+        ctx.byClause()\n+            .fieldList()\n+            .fieldExpression()\n+            .stream()\n+            .map(this::visitExpression)\n+            .collect(Collectors.toList());\n+    return new RareTopN(\n+\n+        /**\n+         * Setting rareTopFlag to FALSE will return list of rare values\n+         */\n+        Boolean.FALSE,\n+        ArgumentFactory.getArgumentList(ctx),\n+        ctx.fieldList()\n+            .fieldExpression()\n+            .stream()\n+            .map(field -> (Field) visitExpression(field))\n+            .collect(Collectors.toList()),\n+        groupList\n+    );\n+  }\n+\n+  /**\n+   * Top command.\n+   */\n+  @Override\n+  public UnresolvedPlan visitTopCommand(TopCommandContext ctx) {", "originalCommit": "8582d37c3946a510786be7c9ce8cc09a4ae0a08c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4Njk0Nw==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r480386947", "bodyText": "Added helper methods for getting a list of groups & fields. Can't add other arguments in helper since that requires respective command context object", "author": "rupal-bq", "createdAt": "2020-08-31T20:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3NTkxNg=="}], "type": "inlineReview"}, {"oid": "a802b55e56f40655b03ca2325128a7f83fda7534", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/a802b55e56f40655b03ca2325128a7f83fda7534", "message": "address PR comments", "committedDate": "2020-08-31T20:09:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjY2Ng==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481402666", "bodyText": "how many value for each field will be returned? 10?", "author": "penghuo", "createdAt": "2020-09-01T20:10:50Z", "path": "docs/experiment/ppl/cmd/rare.rst", "diffHunk": "@@ -0,0 +1,78 @@\n+=============\n+rare\n+=============\n+\n+.. rubric:: Table of contents\n+\n+.. contents::\n+   :local:\n+   :depth: 2\n+\n+\n+Description\n+============\n+| Using ``rare`` command to find the least common tuple of values of all fields in the field list.\n+\n+\n+Syntax\n+============\n+rare <field-list> [by-clause]\n+\n+\n+* field-list: mandatory. comma-delimited list of field names.\n+* by-clause: optional. one or more fields to group the results by.\n+\n+\n+Example 1: Find the least common values in a field\n+===========================================\n+\n+The example finds least common gender of all the accounts.\n+\n+PPL query::\n+\n+    od> source=accounts | rare gender;\n+    fetched rows / total rows = 2/2\n+    +------------+\n+    | gender     |\n+    |------------|\n+    | F          |\n+    |------------|\n+    | M          |\n+    +------------+\n+\n+\n+Example 2: Find the least common values organized by gender\n+====================================================\n+\n+The example finds least common age of all the accounts group by gender.\n+\n+PPL query::\n+\n+    od> source=accounts | rare age by gender;", "originalCommit": "a802b55e56f40655b03ca2325128a7f83fda7534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NjYwMg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481446602", "bodyText": "10 values per group for each field", "author": "rupal-bq", "createdAt": "2020-09-01T21:37:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MTA1MA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481491050", "bodyText": "could you add this to the doc? I think the max value = 10, right?", "author": "penghuo", "createdAt": "2020-09-01T23:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNjM5NQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481506395", "bodyText": "Yes, the max is 10. Added in the Description section.", "author": "rupal-bq", "createdAt": "2020-09-02T00:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMzQ4Mw==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481403483", "bodyText": "why the rare command doesn't has thsi paramater?", "author": "penghuo", "createdAt": "2020-09-01T20:12:32Z", "path": "docs/experiment/ppl/cmd/top.rst", "diffHunk": "@@ -0,0 +1,74 @@\n+=============\n+top\n+=============\n+\n+.. rubric:: Table of contents\n+\n+.. contents::\n+   :local:\n+   :depth: 2\n+\n+\n+Description\n+============\n+| Using ``top`` command to find the most frequent tuple of values of all fields in the field list.\n+\n+\n+Syntax\n+============\n+top [N] <field-list> [by-clause]\n+\n+* N: number of results to return. **Default**: 10", "originalCommit": "a802b55e56f40655b03ca2325128a7f83fda7534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NTkwNA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481445904", "bodyText": "Rare doesn't have N because it's not in the syntax given in this documentation: https://docs.splunk.com/Documentation/Splunk/8.0.2/SearchReference/Rare", "author": "rupal-bq", "createdAt": "2020-09-01T21:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMzQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0ODM4MA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481448380", "bodyText": "limit controls the number of results for rare but support for top-options isn't covered in this PR.\nShould I add parameter N for rare?", "author": "rupal-bq", "createdAt": "2020-09-01T21:42:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMzQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MTExNw==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481491117", "bodyText": "no need now, just confirm,", "author": "penghuo", "createdAt": "2020-09-01T23:41:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMzQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTQyNg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481405426", "bodyText": "could you also change the stats command to use these genric method?", "author": "penghuo", "createdAt": "2020-09-01T20:16:09Z", "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "diffHunk": "@@ -197,6 +206,56 @@ public UnresolvedPlan visitEvalCommand(EvalCommandContext ctx) {\n     );\n   }\n \n+  private List<UnresolvedExpression> getGroupByList(ByClauseContext ctx) {", "originalCommit": "a802b55e56f40655b03ca2325128a7f83fda7534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NTA4Ng==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481445086", "bodyText": "will do", "author": "rupal-bq", "createdAt": "2020-09-01T21:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3ODA4NQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481478085", "bodyText": "used getGroupByList in stats command", "author": "rupal-bq", "createdAt": "2020-09-01T23:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTQ4NQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481405485", "bodyText": "ditto", "author": "penghuo", "createdAt": "2020-09-01T20:16:15Z", "path": "ppl/src/main/java/com/amazon/opendistroforelasticsearch/sql/ppl/parser/AstBuilder.java", "diffHunk": "@@ -197,6 +206,56 @@ public UnresolvedPlan visitEvalCommand(EvalCommandContext ctx) {\n     );\n   }\n \n+  private List<UnresolvedExpression> getGroupByList(ByClauseContext ctx) {\n+    return ctx.fieldList().fieldExpression().stream().map(this::visitExpression)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private List<Field> getFieldList(FieldListContext ctx) {", "originalCommit": "a802b55e56f40655b03ca2325128a7f83fda7534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3ODI3NA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481478274", "bodyText": "used getFieldList for dedup command", "author": "rupal-bq", "createdAt": "2020-09-01T23:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNTQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNDI3MA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481414270", "bodyText": "why the value is List instead of just Map?", "author": "penghuo", "createdAt": "2020-09-01T20:33:27Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<Key, List<HashMap<Key, Integer>>> groupListMap = new HashMap<>();", "originalCommit": "a802b55e56f40655b03ca2325128a7f83fda7534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1MzU1MQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481453551", "bodyText": "Thanks for noticing. The list is not required here. I will remove it.\nI had list<list<ExprValue>> before I understood every input has values for the entire row and not just for a cell. Looks like I missed this while updating the structure.", "author": "rupal-bq", "createdAt": "2020-09-01T21:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNDI3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3ODc3Mw==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r481478773", "bodyText": "removed list", "author": "rupal-bq", "createdAt": "2020-09-01T23:02:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNDI3MA=="}], "type": "inlineReview"}, {"oid": "0fe9d9baa59577fd1733a16bee716e84014f7a08", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/0fe9d9baa59577fd1733a16bee716e84014f7a08", "message": "address PR comments:\n- remove list\n- use generic getGroupByList function for stats\n- use generic getFieldList function for dedup", "committedDate": "2020-09-01T22:35:26Z", "type": "commit"}, {"oid": "8c3300618281f939d0fdc96099b14e8893a5611b", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/8c3300618281f939d0fdc96099b14e8893a5611b", "message": "use interface instead of specific type for input of find()", "committedDate": "2020-09-01T22:48:11Z", "type": "commit"}, {"oid": "1612815dc5fc4edb4f392d8f87fae06955586560", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/1612815dc5fc4edb4f392d8f87fae06955586560", "message": "update doc", "committedDate": "2020-09-02T00:32:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MDM2MQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482250361", "bodyText": "Should this be a boolean instead of Boolean? Would an enum with values RARE or TOP be better? I can't tell if setting this to true means rare or top.", "author": "jduo", "createdAt": "2020-09-02T17:39:42Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/ast/tree/RareTopN.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.ast.tree;\n+\n+import com.amazon.opendistroforelasticsearch.sql.ast.AbstractNodeVisitor;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.Argument;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.Field;\n+import com.amazon.opendistroforelasticsearch.sql.ast.expression.UnresolvedExpression;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.ToString;\n+\n+/**\n+ * AST node represent RareTopN operation.\n+ */\n+@Getter\n+@Setter\n+@ToString\n+@EqualsAndHashCode(callSuper = false)\n+@RequiredArgsConstructor\n+@AllArgsConstructor\n+public class RareTopN extends UnresolvedPlan {\n+\n+  private UnresolvedPlan child;\n+  private final Boolean rareTopFlag;", "originalCommit": "1612815dc5fc4edb4f392d8f87fae06955586560", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUwODI3NA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482508274", "bodyText": "Will add enum", "author": "rupal-bq", "createdAt": "2020-09-02T21:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MDM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU2NzQyNw==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482567427", "bodyText": "replaced with enum", "author": "rupal-bq", "createdAt": "2020-09-02T22:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MDM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MTU5NQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482251595", "bodyText": "Can this and noOfResults just be primitive ints?", "author": "jduo", "createdAt": "2020-09-02T17:41:55Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;", "originalCommit": "1612815dc5fc4edb4f392d8f87fae06955586560", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUxMDUzOA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482510538", "bodyText": "Yes, I can replace it with primitive ints. All other operators had an object of Integer so I just followed the same structure. Should I use primitive instead?", "author": "rupal-bq", "createdAt": "2020-09-02T21:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MTU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjE5Mg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482252192", "bodyText": "Let's add a precondition check here and on next() to verify open() has been called.", "author": "jduo", "createdAt": "2020-09-02T17:43:00Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();", "originalCommit": "1612815dc5fc4edb4f392d8f87fae06955586560", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUzNjgwNQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482536805", "bodyText": "Can you elaborate more? Like what should we return if a condition fails? Maybe Null?\nI have simply followed the logic of AggregationOperator here. It might not be required since open() is updating an iterator and if open() isn't called then hasNext() will simply return false since there are no elements. And when hasNext() will return false, next() won't be called.", "author": "rupal-bq", "createdAt": "2020-09-02T22:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMTk0Mg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482601942", "bodyText": "I would add Precondition.checkNotNull(iterator) here. But really depends on what coding style is preferred.", "author": "jduo", "createdAt": "2020-09-02T23:41:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjYyOA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482252628", "bodyText": "Should we do something to indicate that input is no longer usable or throw an error if open() is called more than once?", "author": "jduo", "createdAt": "2020-09-02T17:43:47Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ *   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Streams;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }", "originalCommit": "1612815dc5fc4edb4f392d8f87fae06955586560", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUxOTU2Ng==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482519566", "bodyText": "I am not sure if it is possible to call open() more than once for a single request. AggregationOperator & SortOperator also override open() and it doesn't throw an error so I assumed it's not required.", "author": "rupal-bq", "createdAt": "2020-09-02T22:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMjI2MQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r482602261", "bodyText": "I would suggest using Precondition.checkNull(iterator) here to fail fast if open() accidentally gets called more than once.", "author": "jduo", "createdAt": "2020-09-02T23:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1MjcxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r483752711", "bodyText": "open() gets called only once", "author": "rupal-bq", "createdAt": "2020-09-04T17:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1MjYyOA=="}], "type": "inlineReview"}, {"oid": "77d6bf32a868174b6dfa314c2d722c15d393696f", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/77d6bf32a868174b6dfa314c2d722c15d393696f", "message": "replace rareTopFlag with enum", "committedDate": "2020-09-02T22:49:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1MjE4Ng==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479452186", "bodyText": "Same comment on constant for 10.", "author": "raymond-lum-zz", "createdAt": "2020-08-28T17:51:12Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/PhysicalPlanDSL.java", "diffHunk": "@@ -80,6 +80,17 @@ public static DedupeOperator dedupe(\n         input, Arrays.asList(expressions), allowedDuplication, keepEmpty, consecutive);\n   }\n \n+  public static RareTopNOperator rareTopN(PhysicalPlan input, Boolean rareTopFlag,\n+      List<Expression> groups, Expression... expressions) {\n+    return rareTopN(input, rareTopFlag, 10, groups, expressions);", "originalCommit": "c41319b976392d3394642d4b627404c80bb2c074", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NDQwMg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479454402", "bodyText": "We should use tags like @return and such when doing java docs for return values. Similar comment for @param for parameter. Would generally have this nit across the code.", "author": "raymond-lum-zz", "createdAt": "2020-08-28T17:55:49Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.", "originalCommit": "c41319b976392d3394642d4b627404c80bb2c074", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2ODI0NQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/720#discussion_r479468245", "bodyText": "This javadoc isn't very useful. Comments should help the developer understand the code and provide value like \"what, why, how\".", "author": "raymond-lum-zz", "createdAt": "2020-08-28T18:25:57Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/RareTopNOperator.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.ToString;\n+\n+/**\n+ * Group the all the input {@link BindingTuple} by {@link RareTopNOperator#groupByExprList},\n+ * Calculate the rare result by using the {@link RareTopNOperator#fieldExprList}.\n+ */\n+@ToString\n+@EqualsAndHashCode\n+public class RareTopNOperator extends PhysicalPlan {\n+  @Getter\n+  private final PhysicalPlan input;\n+\n+  /**\n+   * If rareTopFlag is true, result for top will be returned.\n+   * If rareTopFlag is false, result for rare will be returned.\n+   */\n+  @Getter\n+  private final Boolean rareTopFlag;\n+  @Getter\n+  private final Integer noOfResults;\n+  @Getter\n+  private final List<Expression> fieldExprList;\n+  @Getter\n+  private final List<Expression> groupByExprList;\n+\n+  @EqualsAndHashCode.Exclude\n+  private final Group group;\n+  @EqualsAndHashCode.Exclude\n+  private Iterator<ExprValue> iterator;\n+\n+  private static final Integer DEFAULT_NO_OF_RESULTS = 10;\n+\n+\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this(input, rareTopFlag, DEFAULT_NO_OF_RESULTS, fieldExprList, groupByExprList);\n+  }\n+\n+  /**\n+   * RareTopNOperator Constructor.\n+   *\n+   * @param input           Input {@link PhysicalPlan}\n+   * @param rareTopFlag     Flag for Rare/TopN command.\n+   * @param noOfResults     Number of results\n+   * @param fieldExprList   List of {@link Expression}\n+   * @param groupByExprList List of group by {@link Expression}\n+   */\n+  public RareTopNOperator(PhysicalPlan input, Boolean rareTopFlag, int noOfResults,\n+      List<Expression> fieldExprList,\n+      List<Expression> groupByExprList) {\n+    this.input = input;\n+    this.rareTopFlag = rareTopFlag;\n+    this.noOfResults = noOfResults;\n+    this.fieldExprList = fieldExprList;\n+    this.groupByExprList = groupByExprList;\n+    this.group = new Group();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitRareTopN(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return iterator.hasNext();\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return iterator.next();\n+  }\n+\n+  @Override\n+  public void open() {\n+    super.open();\n+    while (input.hasNext()) {\n+      group.push(input.next());\n+    }\n+    iterator = group.result().iterator();\n+  }\n+\n+  @VisibleForTesting\n+  @RequiredArgsConstructor\n+  public class Group {\n+\n+    private final Map<GroupKey, List<HashMap<FieldKey, Integer>>> groupListMap = new HashMap<>();\n+\n+    /**\n+     * Push the BindingTuple to Group. Two functions will be applied to each BindingTuple to\n+     * generate the {@link GroupKey} and {@link FieldKey} GroupKey = GroupKey(bindingTuple),\n+     * FieldKey = FieldKey(bindingTuple)\n+     */\n+    public void push(ExprValue inputValue) {\n+      GroupKey groupKey = new GroupKey(inputValue);\n+      FieldKey fieldKey = new FieldKey(inputValue);\n+      groupListMap.computeIfAbsent(groupKey, k -> {\n+        List<HashMap<FieldKey, Integer>> list = new ArrayList<>();\n+        HashMap<FieldKey, Integer> map = new HashMap<>();\n+        map.put(fieldKey, 1);\n+        list.add(map);\n+        return list;\n+      });\n+      groupListMap.computeIfPresent(groupKey, (key, fieldList) -> {\n+        fieldList.forEach(map -> {\n+          map.computeIfAbsent(fieldKey, f -> 1);\n+          map.computeIfPresent(fieldKey, (field, count) -> {\n+            return count + 1;\n+          });\n+        });\n+        return fieldList;\n+      });\n+    }\n+\n+    /**\n+     * Get the list of {@link BindingTuple} for each group.\n+     */\n+    public List<ExprValue> result() {\n+      ImmutableList.Builder<ExprValue> resultBuilder = new ImmutableList.Builder<>();\n+\n+      groupListMap.forEach((groups, list) -> {\n+        LinkedHashMap<String, ExprValue> map = new LinkedHashMap<>();\n+        list.forEach(fieldMap -> {\n+\n+          List<FieldKey> resultlist = new ArrayList<>();\n+          if (rareTopFlag) {\n+            resultlist = findTop(fieldMap);\n+          } else {\n+            resultlist = findRare(fieldMap);\n+          }\n+          resultlist.forEach(field -> {\n+            map.putAll(groups.groupKeyMap());\n+            map.putAll(field.fieldKeyMap());\n+            resultBuilder.add(ExprTupleValue.fromExprValueMap(map));\n+          });\n+        });\n+      });\n+\n+      return resultBuilder.build();\n+    }\n+\n+    /**\n+     * Get a list of top values.\n+     */\n+    public List<FieldKey> findTop(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> topQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e1) - map.get(e2);\n+        }\n+      });\n+\n+      return getList(map, topQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of rare values.\n+     */\n+    public List<FieldKey> findRare(HashMap<FieldKey, Integer> map) {\n+      PriorityQueue<FieldKey> rareQueue = new PriorityQueue<>(new Comparator<FieldKey>() {\n+        @Override\n+        public int compare(FieldKey e1, FieldKey e2) {\n+          return map.get(e2) - map.get(e1);\n+        }\n+      });\n+\n+      return getList(map, rareQueue, noOfResults);\n+    }\n+\n+    /**\n+     * Get a list of result.\n+     */\n+    public List<FieldKey> getList(HashMap<FieldKey, Integer> map, PriorityQueue<FieldKey> queue,\n+        Integer size) {\n+      for (Map.Entry<FieldKey, Integer> entry : map.entrySet()) {\n+        queue.add(entry.getKey());\n+        if (queue.size() > size) {\n+          queue.poll();\n+        }\n+      }\n+\n+      List<FieldKey> list = new ArrayList<>();\n+      while (!queue.isEmpty()) {\n+        list.add(queue.poll());\n+      }\n+\n+      Collections.reverse(list);\n+      return list;\n+    }\n+\n+  }\n+\n+  /**\n+   * Field Key.", "originalCommit": "c41319b976392d3394642d4b627404c80bb2c074", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}