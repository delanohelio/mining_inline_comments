{"pr_number": 485, "pr_title": "[PPL] Support dedup command", "pr_createdAt": "2020-05-22T22:10:33Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/sql/pull/485", "timeline": [{"oid": "c1bee6851989c1ea769a82ae46a74550002e85b1", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/c1bee6851989c1ea769a82ae46a74550002e85b1", "message": "dedup operator", "committedDate": "2020-05-22T21:58:55Z", "type": "commit"}, {"oid": "88b71d75917655c98063ad16a997ac2f71f29b88", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/88b71d75917655c98063ad16a997ac2f71f29b88", "message": "update deduper", "committedDate": "2020-05-22T21:58:56Z", "type": "commit"}, {"oid": "bfe17d20097853aae167839cd79c2e4a586fc2fe", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/bfe17d20097853aae167839cd79c2e4a586fc2fe", "message": "add dedup ast node", "committedDate": "2020-05-22T21:59:02Z", "type": "commit"}, {"oid": "9f9ffcc5e362fea7ccef3f389b3be059250fb24d", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/9f9ffcc5e362fea7ccef3f389b3be059250fb24d", "message": "add logical dedup", "committedDate": "2020-05-22T21:59:05Z", "type": "commit"}, {"oid": "0659600ede34751777786623ca206ea5f1cb9ecc", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/0659600ede34751777786623ca206ea5f1cb9ecc", "message": "add dedup operator to ElasticsearchIndex", "committedDate": "2020-05-22T22:09:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NDcyOQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/485#discussion_r429484729", "bodyText": "Notice that HistoricalDeduper is using ConcurrentHashMap, so just wonder if thread safe is also needed here by synchronized or AtomicReference?", "author": "dai-chen", "createdAt": "2020-05-22T23:05:40Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/DedupeOperator.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Predicate;\n+import lombok.EqualsAndHashCode;\n+\n+/**\n+ * Dedupe operator. Dedupe the input {@link ExprValue} by using the {@link\n+ * DedupeOperator#dedupeList} The result order follow the input order.\n+ */\n+@EqualsAndHashCode\n+public class DedupeOperator extends PhysicalPlan {\n+  private final PhysicalPlan input;\n+  private final List<Expression> dedupeList;\n+  private final Integer allowedDuplication;\n+  private final Boolean keepEmpty;\n+  private final Boolean consecutive;\n+\n+  @EqualsAndHashCode.Exclude private final Deduper<List<ExprValue>> deduper;\n+  @EqualsAndHashCode.Exclude private ExprValue next;\n+\n+  private static final Integer ALL_ONE_DUPLICATION = 1;\n+  private static final Boolean IGNORE_EMPTY = false;\n+  private static final Boolean NON_CONSECUTIVE = false;\n+\n+  private static final Predicate<ExprValue> NULL_OR_MISSING = v -> v.isNull() || v.isMissing();\n+\n+  public DedupeOperator(PhysicalPlan input, List<Expression> dedupeList) {\n+    this(input, dedupeList, ALL_ONE_DUPLICATION, IGNORE_EMPTY, NON_CONSECUTIVE);\n+  }\n+\n+  public DedupeOperator(\n+      PhysicalPlan input,\n+      List<Expression> dedupeList,\n+      Integer allowedDuplication,\n+      Boolean keepEmpty,\n+      Boolean consecutive) {\n+    this.input = input;\n+    this.dedupeList = dedupeList;\n+    this.allowedDuplication = allowedDuplication;\n+    this.keepEmpty = keepEmpty;\n+    this.consecutive = consecutive;\n+    this.deduper = this.consecutive ? new ConsecutiveDeduper<>() : new HistoricalDeduper<>();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitDedupe(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    while (input.hasNext()) {\n+      ExprValue next = input.next();\n+      if (keep(next)) {\n+        this.next = next;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return this.next;\n+  }\n+\n+  /**\n+   * Test the {@link ExprValue} should be keep or ignore\n+   *\n+   * <p>If any value evaluted by {@link DedupeOperator#dedupeList} is NULL or MISSING, then the *\n+   * return value is decided by keepEmpty option, default value is ignore.\n+   *\n+   * @param value\n+   * @return true: keep, false: ignore\n+   */\n+  public boolean keep(ExprValue value) {\n+    BindingTuple bindingTuple = value.bindingTuples();\n+    ImmutableList.Builder<ExprValue> dedupeKeyBuilder = new ImmutableList.Builder<>();\n+    for (Expression expression : dedupeList) {\n+      ExprValue exprValue = expression.valueOf(bindingTuple);\n+      if (NULL_OR_MISSING.test(exprValue)) {\n+        return keepEmpty;\n+      }\n+      dedupeKeyBuilder.add(exprValue);\n+    }\n+    List<ExprValue> dedupeKey = dedupeKeyBuilder.build();\n+    int seenTimes = deduper.seenTimes(dedupeKey);\n+    return seenTimes <= allowedDuplication;\n+  }\n+\n+  /**\n+   * Return how many times the dedupeKey has been seen before. The side effect is the seen times\n+   * will add 1 times after calling this function.\n+   *\n+   * @param <K> dedupe key\n+   */\n+  interface Deduper<K> {\n+\n+    int seenTimes(K dedupeKey);\n+  }\n+\n+  /** The Historical Deduper monitor the duplicated element with all the seen value. */\n+  static class HistoricalDeduper<K> implements Deduper<K> {\n+    private final Map<K, Integer> seenMap = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public int seenTimes(K dedupeKey) {\n+      seenMap.putIfAbsent(dedupeKey, 0);\n+      return seenMap.computeIfPresent(dedupeKey, (k, v) -> v + 1);\n+    }\n+  }\n+\n+  /**\n+   * The Consecutive Deduper monitor the duplicated element with consecutive seen value. It means\n+   * only the consecutive duplicated value will be counted.\n+   */\n+  static class ConsecutiveDeduper<K> implements Deduper<K> {\n+    private K lastSeenDedupeKey = null;\n+    private Integer consecutiveCount = 0;\n+\n+    @Override\n+    public int seenTimes(K dedupeKey) {", "originalCommit": "0659600ede34751777786623ca206ea5f1cb9ecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNjkzMg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/485#discussion_r430536932", "bodyText": "Done. Refactor the Deduper. Get rid of hierarchy", "author": "penghuo", "createdAt": "2020-05-26T16:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NDcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2NTk3OQ==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/485#discussion_r430565979", "bodyText": "Thanks!", "author": "dai-chen", "createdAt": "2020-05-26T16:56:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NDcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NTc5Mg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/485#discussion_r429485792", "bodyText": "Probably safer to do null check before return in case this Boolean is null? Or verify this in constructor and save as boolean if it's required non-null?", "author": "dai-chen", "createdAt": "2020-05-22T23:11:58Z", "path": "core/src/main/java/com/amazon/opendistroforelasticsearch/sql/planner/physical/DedupeOperator.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.planner.physical;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.expression.Expression;\n+import com.amazon.opendistroforelasticsearch.sql.storage.bindingtuple.BindingTuple;\n+import com.google.common.collect.ImmutableList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Predicate;\n+import lombok.EqualsAndHashCode;\n+\n+/**\n+ * Dedupe operator. Dedupe the input {@link ExprValue} by using the {@link\n+ * DedupeOperator#dedupeList} The result order follow the input order.\n+ */\n+@EqualsAndHashCode\n+public class DedupeOperator extends PhysicalPlan {\n+  private final PhysicalPlan input;\n+  private final List<Expression> dedupeList;\n+  private final Integer allowedDuplication;\n+  private final Boolean keepEmpty;\n+  private final Boolean consecutive;\n+\n+  @EqualsAndHashCode.Exclude private final Deduper<List<ExprValue>> deduper;\n+  @EqualsAndHashCode.Exclude private ExprValue next;\n+\n+  private static final Integer ALL_ONE_DUPLICATION = 1;\n+  private static final Boolean IGNORE_EMPTY = false;\n+  private static final Boolean NON_CONSECUTIVE = false;\n+\n+  private static final Predicate<ExprValue> NULL_OR_MISSING = v -> v.isNull() || v.isMissing();\n+\n+  public DedupeOperator(PhysicalPlan input, List<Expression> dedupeList) {\n+    this(input, dedupeList, ALL_ONE_DUPLICATION, IGNORE_EMPTY, NON_CONSECUTIVE);\n+  }\n+\n+  public DedupeOperator(\n+      PhysicalPlan input,\n+      List<Expression> dedupeList,\n+      Integer allowedDuplication,\n+      Boolean keepEmpty,\n+      Boolean consecutive) {\n+    this.input = input;\n+    this.dedupeList = dedupeList;\n+    this.allowedDuplication = allowedDuplication;\n+    this.keepEmpty = keepEmpty;\n+    this.consecutive = consecutive;\n+    this.deduper = this.consecutive ? new ConsecutiveDeduper<>() : new HistoricalDeduper<>();\n+  }\n+\n+  @Override\n+  public <R, C> R accept(PhysicalPlanNodeVisitor<R, C> visitor, C context) {\n+    return visitor.visitDedupe(this, context);\n+  }\n+\n+  @Override\n+  public List<PhysicalPlan> getChild() {\n+    return Collections.singletonList(input);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    while (input.hasNext()) {\n+      ExprValue next = input.next();\n+      if (keep(next)) {\n+        this.next = next;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public ExprValue next() {\n+    return this.next;\n+  }\n+\n+  /**\n+   * Test the {@link ExprValue} should be keep or ignore\n+   *\n+   * <p>If any value evaluted by {@link DedupeOperator#dedupeList} is NULL or MISSING, then the *\n+   * return value is decided by keepEmpty option, default value is ignore.\n+   *\n+   * @param value\n+   * @return true: keep, false: ignore\n+   */\n+  public boolean keep(ExprValue value) {\n+    BindingTuple bindingTuple = value.bindingTuples();\n+    ImmutableList.Builder<ExprValue> dedupeKeyBuilder = new ImmutableList.Builder<>();\n+    for (Expression expression : dedupeList) {\n+      ExprValue exprValue = expression.valueOf(bindingTuple);\n+      if (NULL_OR_MISSING.test(exprValue)) {\n+        return keepEmpty;", "originalCommit": "0659600ede34751777786623ca206ea5f1cb9ecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ5Mjg1MA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/485#discussion_r430492850", "bodyText": "Done. add the @nonnull at the constructor.", "author": "penghuo", "createdAt": "2020-05-26T15:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NTc5Mg=="}], "type": "inlineReview"}, {"oid": "842837031dd67e5dc4fee637bb5d7d0df2602532", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/842837031dd67e5dc4fee637bb5d7d0df2602532", "message": "address comments", "committedDate": "2020-05-26T16:12:22Z", "type": "commit"}]}