{"pr_number": 3854, "pr_title": "Define glb more precisely for the Nullness Checker", "pr_createdAt": "2020-11-04T04:40:14Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3854", "timeline": [{"oid": "0ef1371d55d53f5ed00aad99bdb6148e68759471", "url": "https://github.com/typetools/checker-framework/commit/0ef1371d55d53f5ed00aad99bdb6148e68759471", "message": "Define glb more precisely for the Nullness Checker", "committedDate": "2020-11-04T03:55:32Z", "type": "commit"}, {"oid": "085c21389f84fd023aaf8ecf44887fe06887b973", "url": "https://github.com/typetools/checker-framework/commit/085c21389f84fd023aaf8ecf44887fe06887b973", "message": "Fix cut-and-paste typo", "committedDate": "2020-11-04T04:06:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUzNDk1MQ==", "url": "https://github.com/typetools/checker-framework/pull/3854#discussion_r517534951", "bodyText": "If a and b are unrelated, then this will return an intersection type or an error type.  createUnderInitializationAnnotation uses the erased type of the intersection type and will throw an exception on the error type (I think).  Should bottom be returned instead?", "author": "smillst", "createdAt": "2020-11-04T18:06:57Z", "path": "checker/src/main/java/org/checkerframework/checker/initialization/InitializationAnnotatedTypeFactory.java", "diffHunk": "@@ -888,5 +888,75 @@ protected TypeMirror lubTypeFrame(TypeMirror a, TypeMirror b) {\n \n             return TypesUtils.leastUpperBound(a, b, processingEnv);\n         }\n+\n+        /**\n+         * Compute the greatest lower bound of two initialization qualifiers. Returns null if one of\n+         * the qualifiers is not in the initialization hierarachy. Subclasses should override\n+         * greatestLowerBound and call this method for initialization qualifiers.\n+         *\n+         * @param anno1 an initialization qualifier\n+         * @param qual1 a qualifier kind\n+         * @param anno2 an initialization qualifier\n+         * @param qual2 a qualifier kind\n+         * @return the glb of anno1 and anno2\n+         */\n+        protected AnnotationMirror greatestLowerBoundInitialization(\n+                AnnotationMirror anno1,\n+                QualifierKind qual1,\n+                AnnotationMirror anno2,\n+                QualifierKind qual2) {\n+            if (!isInitializationAnnotation(anno1) || !isInitializationAnnotation(anno2)) {\n+                return null;\n+            }\n+\n+            // Handle the case where one is a subtype of the other.\n+            if (isSubtypeInitialization(anno1, qual1, anno2, qual2)) {\n+                return anno1;\n+            } else if (isSubtypeInitialization(anno2, qual2, anno1, qual1)) {\n+                return anno2;\n+            }\n+            boolean unknowninit1 = isUnknownInitialization(anno1);\n+            boolean unknowninit2 = isUnknownInitialization(anno2);\n+            boolean underinit1 = isUnderInitialization(anno1);\n+            boolean underinit2 = isUnderInitialization(anno2);\n+\n+            // Handle @Initialized.\n+            if (isInitialized(anno1)) {\n+                assert underinit2;\n+                return FBCBOTTOM;\n+            } else if (isInitialized(anno2)) {\n+                assert underinit1;\n+                return FBCBOTTOM;\n+            }\n+\n+            if (underinit1 && underinit2) {\n+                return createUnderInitializationAnnotation(\n+                        glbTypeFrame(\n+                                getTypeFrameFromAnnotation(anno1),\n+                                getTypeFrameFromAnnotation(anno2)));\n+            }\n+\n+            assert (unknowninit1 || underinit1) && (unknowninit2 || underinit2);\n+            return createUnderInitializationAnnotation(\n+                    glbTypeFrame(\n+                            getTypeFrameFromAnnotation(anno1), getTypeFrameFromAnnotation(anno2)));\n+        }\n+\n+        /**\n+         * Returns the greatest lower bound of two types.\n+         *\n+         * @param a the first argument\n+         * @param b the second argument\n+         * @return the glb of the two arguments\n+         */\n+        protected TypeMirror glbTypeFrame(TypeMirror a, TypeMirror b) {\n+            if (types.isSubtype(a, b)) {\n+                return a;\n+            } else if (types.isSubtype(b, a)) {\n+                return b;\n+            }\n+\n+            return TypesUtils.greatestLowerBound(a, b, processingEnv);", "originalCommit": "085c21389f84fd023aaf8ecf44887fe06887b973", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY0MTc5OQ==", "url": "https://github.com/typetools/checker-framework/pull/3854#discussion_r517641799", "bodyText": "By \"bottom\", do you mean the type of void?  That doesn't seem like a good argument/element to @UnderInitialization.\nMaybe it would be better to do this computation and then issue a warning if the result is an intersection or error type.", "author": "mernst", "createdAt": "2020-11-04T21:29:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUzNDk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY2NjkzNw==", "url": "https://github.com/typetools/checker-framework/pull/3854#discussion_r517666937", "bodyText": "I mean that the glb of the two annotation mirrors should be @FBCBottom if the glb of the elements of the annotation mirrors is an intersection or an error type.", "author": "smillst", "createdAt": "2020-11-04T22:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUzNDk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc2MDczMQ==", "url": "https://github.com/typetools/checker-framework/pull/3854#discussion_r517760731", "bodyText": "That makes sense, thanks.", "author": "mernst", "createdAt": "2020-11-05T02:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUzNDk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUzNTY4MQ==", "url": "https://github.com/typetools/checker-framework/pull/3854#discussion_r517535681", "bodyText": "This is duplicated in TypesUtils.greatestLowerBound, so you could just call it directly.", "author": "smillst", "createdAt": "2020-11-04T18:08:16Z", "path": "checker/src/main/java/org/checkerframework/checker/initialization/InitializationAnnotatedTypeFactory.java", "diffHunk": "@@ -888,5 +888,75 @@ protected TypeMirror lubTypeFrame(TypeMirror a, TypeMirror b) {\n \n             return TypesUtils.leastUpperBound(a, b, processingEnv);\n         }\n+\n+        /**\n+         * Compute the greatest lower bound of two initialization qualifiers. Returns null if one of\n+         * the qualifiers is not in the initialization hierarachy. Subclasses should override\n+         * greatestLowerBound and call this method for initialization qualifiers.\n+         *\n+         * @param anno1 an initialization qualifier\n+         * @param qual1 a qualifier kind\n+         * @param anno2 an initialization qualifier\n+         * @param qual2 a qualifier kind\n+         * @return the glb of anno1 and anno2\n+         */\n+        protected AnnotationMirror greatestLowerBoundInitialization(\n+                AnnotationMirror anno1,\n+                QualifierKind qual1,\n+                AnnotationMirror anno2,\n+                QualifierKind qual2) {\n+            if (!isInitializationAnnotation(anno1) || !isInitializationAnnotation(anno2)) {\n+                return null;\n+            }\n+\n+            // Handle the case where one is a subtype of the other.\n+            if (isSubtypeInitialization(anno1, qual1, anno2, qual2)) {\n+                return anno1;\n+            } else if (isSubtypeInitialization(anno2, qual2, anno1, qual1)) {\n+                return anno2;\n+            }\n+            boolean unknowninit1 = isUnknownInitialization(anno1);\n+            boolean unknowninit2 = isUnknownInitialization(anno2);\n+            boolean underinit1 = isUnderInitialization(anno1);\n+            boolean underinit2 = isUnderInitialization(anno2);\n+\n+            // Handle @Initialized.\n+            if (isInitialized(anno1)) {\n+                assert underinit2;\n+                return FBCBOTTOM;\n+            } else if (isInitialized(anno2)) {\n+                assert underinit1;\n+                return FBCBOTTOM;\n+            }\n+\n+            if (underinit1 && underinit2) {\n+                return createUnderInitializationAnnotation(\n+                        glbTypeFrame(\n+                                getTypeFrameFromAnnotation(anno1),\n+                                getTypeFrameFromAnnotation(anno2)));\n+            }\n+\n+            assert (unknowninit1 || underinit1) && (unknowninit2 || underinit2);\n+            return createUnderInitializationAnnotation(\n+                    glbTypeFrame(\n+                            getTypeFrameFromAnnotation(anno1), getTypeFrameFromAnnotation(anno2)));\n+        }\n+\n+        /**\n+         * Returns the greatest lower bound of two types.\n+         *\n+         * @param a the first argument\n+         * @param b the second argument\n+         * @return the glb of the two arguments\n+         */\n+        protected TypeMirror glbTypeFrame(TypeMirror a, TypeMirror b) {\n+            if (types.isSubtype(a, b)) {", "originalCommit": "085c21389f84fd023aaf8ecf44887fe06887b973", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYzMjMxNg==", "url": "https://github.com/typetools/checker-framework/pull/3854#discussion_r517632316", "bodyText": "I don't see this special case in TypesUtils.greatestLowerBound.  Am I missing something?", "author": "mernst", "createdAt": "2020-11-04T21:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUzNTY4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY2NTgwNQ==", "url": "https://github.com/typetools/checker-framework/pull/3854#discussion_r517665805", "bodyText": "TypesUtils.greatestLowerBound calls com.sun.tools.javac.code.Types#glb(com.sun.tools.javac.code.Type, com.sun.tools.javac.code.Type) which has the special case.", "author": "smillst", "createdAt": "2020-11-04T22:22:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUzNTY4MQ=="}], "type": "inlineReview"}, {"oid": "085c21389f84fd023aaf8ecf44887fe06887b973", "url": "https://github.com/typetools/checker-framework/commit/085c21389f84fd023aaf8ecf44887fe06887b973", "message": "Fix cut-and-paste typo", "committedDate": "2020-11-04T04:06:39Z", "type": "forcePushed"}, {"oid": "de9d5b467d60d5b646988cd4f07585630f96b497", "url": "https://github.com/typetools/checker-framework/commit/de9d5b467d60d5b646988cd4f07585630f96b497", "message": "Simplify code, handle when glb is not a typeframe", "committedDate": "2020-11-05T02:49:21Z", "type": "commit"}, {"oid": "de9d5b467d60d5b646988cd4f07585630f96b497", "url": "https://github.com/typetools/checker-framework/commit/de9d5b467d60d5b646988cd4f07585630f96b497", "message": "Simplify code, handle when glb is not a typeframe", "committedDate": "2020-11-05T02:49:21Z", "type": "forcePushed"}, {"oid": "df543899fda14bb2bfeea74bed737f7e6cc6f44c", "url": "https://github.com/typetools/checker-framework/commit/df543899fda14bb2bfeea74bed737f7e6cc6f44c", "message": "Merge ../checker-framework-branch-master into nullness-glb", "committedDate": "2020-11-05T07:30:25Z", "type": "commit"}]}