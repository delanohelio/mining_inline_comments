{"pr_number": 3445, "pr_title": "Deprecate *TypeVariable methods in QualifierHierarchy and improve documentation", "pr_createdAt": "2020-07-07T22:04:59Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3445", "timeline": [{"oid": "bb123be206adbad1559383af9355c3199bc84759", "url": "https://github.com/typetools/checker-framework/commit/bb123be206adbad1559383af9355c3199bc84759", "message": "QualifierHierarchy documentation improvements", "committedDate": "2020-07-04T15:44:42Z", "type": "commit"}, {"oid": "471673274c2990e8fbf114a62ac48a70d7b88b38", "url": "https://github.com/typetools/checker-framework/commit/471673274c2990e8fbf114a62ac48a70d7b88b38", "message": "Fix spelling", "committedDate": "2020-07-04T15:48:26Z", "type": "commit"}, {"oid": "d5eb34b709101ed4e77db1e9bc37391978625e53", "url": "https://github.com/typetools/checker-framework/commit/d5eb34b709101ed4e77db1e9bc37391978625e53", "message": "Add Javadoc", "committedDate": "2020-07-06T21:18:26Z", "type": "commit"}, {"oid": "ecdd67ffac7d9918d945483b0aa4790c082d226d", "url": "https://github.com/typetools/checker-framework/commit/ecdd67ffac7d9918d945483b0aa4790c082d226d", "message": "Merge remote-tracking branch 'origin/master' into qualifierhierarchy", "committedDate": "2020-07-07T19:41:31Z", "type": "commit"}, {"oid": "b3e2dccd0d49e6ad0af0e727f68fc42ef97b7f67", "url": "https://github.com/typetools/checker-framework/commit/b3e2dccd0d49e6ad0af0e727f68fc42ef97b7f67", "message": "Clean up isSubtype methods.", "committedDate": "2020-07-07T20:28:14Z", "type": "commit"}, {"oid": "0de9b5e2d14cbae89207363100c74cc2ea866f85", "url": "https://github.com/typetools/checker-framework/commit/0de9b5e2d14cbae89207363100c74cc2ea866f85", "message": "Clean up lub methods.", "committedDate": "2020-07-07T20:38:07Z", "type": "commit"}, {"oid": "d1ec84d313b6966c2fec59747f73898a33563023", "url": "https://github.com/typetools/checker-framework/commit/d1ec84d313b6966c2fec59747f73898a33563023", "message": "Clean up glb methods.", "committedDate": "2020-07-07T20:48:47Z", "type": "commit"}, {"oid": "d6151fdcb7ab7e0dd9e60a34084e422aea25e625", "url": "https://github.com/typetools/checker-framework/commit/d6151fdcb7ab7e0dd9e60a34084e422aea25e625", "message": "Move deprecated methods to bottom.", "committedDate": "2020-07-07T20:51:29Z", "type": "commit"}, {"oid": "143c30c8b5fec1979e33dbeca0304e920a07b61a", "url": "https://github.com/typetools/checker-framework/commit/143c30c8b5fec1979e33dbeca0304e920a07b61a", "message": "Javadoc.", "committedDate": "2020-07-07T21:00:36Z", "type": "commit"}, {"oid": "97c342451185420193bc050e417b8edc78fd5410", "url": "https://github.com/typetools/checker-framework/commit/97c342451185420193bc050e417b8edc78fd5410", "message": "More Javadoc.", "committedDate": "2020-07-07T21:18:13Z", "type": "commit"}, {"oid": "75ac95f90b35ea4d7bf167d74b5522e601f9eca4", "url": "https://github.com/typetools/checker-framework/commit/75ac95f90b35ea4d7bf167d74b5522e601f9eca4", "message": "Fix.", "committedDate": "2020-07-07T21:55:24Z", "type": "commit"}, {"oid": "9d4f754e27e62dd5d8d769c885b9f3df1d1710c6", "url": "https://github.com/typetools/checker-framework/commit/9d4f754e27e62dd5d8d769c885b9f3df1d1710c6", "message": "Javadoc.", "committedDate": "2020-07-07T22:00:05Z", "type": "commit"}, {"oid": "68f955b285bb18c6c385601d95d9160ed128f4dd", "url": "https://github.com/typetools/checker-framework/commit/68f955b285bb18c6c385601d95d9160ed128f4dd", "message": "Merge remote-tracking branch 'origin/master' into qualifierhierarchy", "committedDate": "2020-07-07T22:00:34Z", "type": "commit"}, {"oid": "c9febb8b7ebb93f74e38a437ace2788e128b9c64", "url": "https://github.com/typetools/checker-framework/commit/c9febb8b7ebb93f74e38a437ace2788e128b9c64", "message": "Merge ../checker-framework-branch-master into refactorQualifierHierarchy", "committedDate": "2020-07-08T00:56:08Z", "type": "commit"}, {"oid": "af27fce38e3230571bd76cecc6f4774ae306a8fb", "url": "https://github.com/typetools/checker-framework/commit/af27fce38e3230571bd76cecc6f4774ae306a8fb", "message": "Tweaks", "committedDate": "2020-07-08T01:03:33Z", "type": "commit"}, {"oid": "4ec1a06b3ae0940ba4664351feab67b5fa2d1d78", "url": "https://github.com/typetools/checker-framework/commit/4ec1a06b3ae0940ba4664351feab67b5fa2d1d78", "message": "Add Javadoc.", "committedDate": "2020-07-08T15:44:06Z", "type": "commit"}, {"oid": "f5408fdb81c5e43b27714c0e89b850a0a08de209", "url": "https://github.com/typetools/checker-framework/commit/f5408fdb81c5e43b27714c0e89b850a0a08de209", "message": "Merge branch 'refactorQualifierHierarchy' of github.com:smillst/checker-framework into refactorQualifierHierarchy", "committedDate": "2020-07-08T15:44:20Z", "type": "commit"}, {"oid": "4d8e4446be3daca94db7beb3eed9f8f63e1f660f", "url": "https://github.com/typetools/checker-framework/commit/4d8e4446be3daca94db7beb3eed9f8f63e1f660f", "message": "Add @Nullable.", "committedDate": "2020-07-08T16:18:49Z", "type": "commit"}, {"oid": "a8adbb69583e307966ebf32ef13b0659418315e0", "url": "https://github.com/typetools/checker-framework/commit/a8adbb69583e307966ebf32ef13b0659418315e0", "message": "Merge ../checker-framework-branch-master into refactorQualifierHierarchy", "committedDate": "2020-07-09T15:18:32Z", "type": "commit"}, {"oid": "11db258445db77a387a2b5524fd0daddc643c969", "url": "https://github.com/typetools/checker-framework/commit/11db258445db77a387a2b5524fd0daddc643c969", "message": "Merge remote-tracking branch 'origin/master' into refactorQualifierHierarchy", "committedDate": "2020-07-10T19:19:03Z", "type": "commit"}, {"oid": "8e9c425abfceb2eed6ae10c5b660edc8782d2a5e", "url": "https://github.com/typetools/checker-framework/commit/8e9c425abfceb2eed6ae10c5b660edc8782d2a5e", "message": "Add @AnnotatedFor to QualifierHierarchy.", "committedDate": "2020-07-10T19:48:23Z", "type": "commit"}, {"oid": "f654d7f3c89a2dd1e4205e421b0c8acf4931a3d9", "url": "https://github.com/typetools/checker-framework/commit/f654d7f3c89a2dd1e4205e421b0c8acf4931a3d9", "message": "Tweaks", "committedDate": "2020-07-10T20:28:16Z", "type": "commit"}, {"oid": "854d259553d847142ddfa388fffebd431103149c", "url": "https://github.com/typetools/checker-framework/commit/854d259553d847142ddfa388fffebd431103149c", "message": "Merge branch 'refactorQualifierHierarchy' of github.com:smillst/checker-framework into refactorQualifierHierarchy", "committedDate": "2020-07-10T20:28:55Z", "type": "commit"}, {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123", "url": "https://github.com/typetools/checker-framework/commit/86a4037ee6fd5f6af8f43174bec6231da102c123", "message": "Typeo.", "committedDate": "2020-07-10T21:52:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1ODgwOA==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456658808", "bodyText": "Should these be {@link QualifierHierarchy}?", "author": "wmdietl", "createdAt": "2020-07-17T20:27:14Z", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -111,9 +111,9 @@ protected boolean shouldCheckTopLevelDeclaredType(AnnotatedTypeMirror type, Tree\n      *\n      * <ol>\n      *   <li>There should not be multiple annotations from the same hierarchy.\n-     *   <li>There should not be more annotations than the width of the qualifier hierarchy.\n+     *   <li>There should not be more annotations than the width of the QualifierHierarchy.", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3Nzk0Mw==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r460277943", "bodyText": "I don't think it needs to be linked every place it is referring to the QualifierHierarchy.", "author": "smillst", "createdAt": "2020-07-24T20:41:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1ODgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1ODkzNw==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456658937", "bodyText": "Should the hierarchy here also be {@link QH}?", "author": "wmdietl", "createdAt": "2020-07-17T20:27:34Z", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -111,9 +111,9 @@ protected boolean shouldCheckTopLevelDeclaredType(AnnotatedTypeMirror type, Tree\n      *\n      * <ol>\n      *   <li>There should not be multiple annotations from the same hierarchy.", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3NzYwNA==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r460277604", "bodyText": "No, this is a qualifier hierarchy.", "author": "smillst", "createdAt": "2020-07-24T20:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1ODkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM2MTI2OA==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462361268", "bodyText": "Then why not change the ambiguous \"hierarchy\" to \"qualifier hierarchy\"? That would make the bullet points more consistent with each other and highlight the distinction between the two concepts.", "author": "wmdietl", "createdAt": "2020-07-29T14:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1ODkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2NTUyNg==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456665526", "bodyText": "Do you like this distinction? Do we follow this in the documentation? I would have assumed we say \"qualifier hierarchy\" whenever we mean a \"QualifierHierarchy\", which can always be multiple tops/bottoms.\nSo maybe in #3404 we should also look into cleaning that up.", "author": "wmdietl", "createdAt": "2020-07-17T20:44:05Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -5,23 +5,32 @@\n import java.util.Set;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.type.TypeKind;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n import org.checkerframework.javacutil.AnnotationUtils;\n import org.checkerframework.javacutil.BugInCF;\n \n /**\n- * Represents a type qualifier hierarchy.\n+ * Represents multiple type qualifier hierarchies. {@link #getWidth} gives the number of hierarchies\n+ * that this object represents. Each hierarchy has its own top and bottom, and subtyping\n+ * relationships exist only within each hierarchy.\n  *\n- * <p>All method parameter annotations need to be type qualifiers recognized within this hierarchy.\n+ * <p>Note the distinction in terminology between a qualifier hierarchy, which has one top and one", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5Mzc4Ng==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r457693786", "bodyText": "We discussed this.", "author": "wmdietl", "createdAt": "2020-07-20T21:10:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2NTUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2Njk0Ng==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456666946", "bodyText": "Is it worth saying what happens when qualifier isn't in any of the hierarchies?", "author": "wmdietl", "createdAt": "2020-07-17T20:47:18Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -38,40 +47,48 @@ public int getWidth() {\n     }\n \n     /**\n-     * Returns the top (ultimate super) type qualifiers in the type system.\n+     * Returns the top (ultimate super) type qualifiers in the type system. The size of this set is\n+     * equal to {@link #getWidth}.\n      *\n      * @return the top (ultimate super) type qualifiers in the type system\n      */\n     public abstract Set<? extends AnnotationMirror> getTopAnnotations();\n \n     /**\n      * Return the top qualifier for the given qualifier, that is, the qualifier that is a supertype\n-     * of start but no further supertypes exist.\n+     * of {@code qualifier} but no further supertypes exist.\n+     *\n+     * @param qualifier any qualifier from one of the type hierarchies represented by this", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3NzI3OA==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r460277278", "bodyText": "My thought was to leave it undefined.", "author": "smillst", "createdAt": "2020-07-24T20:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2Njk0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4MjU4OQ==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462482589", "bodyText": "At some point it would probably be good to resolve all such undefined behavior, but I'm fine with ignoring it for now.", "author": "wmdietl", "createdAt": "2020-07-29T17:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2Njk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2NzU2Mg==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456667562", "bodyText": "Should this be possible sub qualifier of, like in the @return?\nSomewhere later, I see subqualifier. So maybe these sub/super qualifiers should be made consistent.", "author": "wmdietl", "createdAt": "2020-07-17T20:49:00Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -88,45 +105,88 @@ public int getWidth() {\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subQualifier of {@code superQualifier}", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2ODc1OQ==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456668759", "bodyText": "the null -> that null?", "author": "wmdietl", "createdAt": "2020-07-17T20:52:07Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -88,45 +105,88 @@ public int getWidth() {\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subQualifier of {@code superQualifier}\n+     * @param superQualifier possible superQualifier of {@code subQualifier}\n+     * @return true iff {@code subQualifier} is a sub qualifier of, or equal to, {@code\n+     *     superQualifier}\n      */\n-    public abstract boolean isSubtype(AnnotationMirror rhs, AnnotationMirror lhs);\n+    public abstract boolean isSubtype(\n+            AnnotationMirror subQualifier, AnnotationMirror superQualifier);\n \n     /**\n-     * Tests whether there is any annotation in lhs that is a super qualifier of, or equal to, some\n-     * annotation in rhs. lhs and rhs contain only the annotations, not the Java type.\n+     * Tests whether all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     * qualifier in the same hierarchy in {@code superQualifiers}.\n      *\n-     * @return true iff an annotation in lhs is a super of one in rhs\n+     * @param subQualifiers set of qualifiers; exactly one per hierarchy\n+     * @param superQualifiers set of qualifiers; exactly one per hierarchy\n+     * @return true iff all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     *     qualifier in the same hierarchy in {@code superQualifiers}\n      */\n     public abstract boolean isSubtype(\n-            Collection<? extends AnnotationMirror> rhs, Collection<? extends AnnotationMirror> lhs);\n+            Collection<? extends AnnotationMirror> subQualifiers,\n+            Collection<? extends AnnotationMirror> superQualifiers);\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n+     * Returns the least upper bound (LUB) of the qualifiers {@code qualifier1} and {@code\n+     * qualifier2}. Returns {@code null} if the qualifiers are not from the same qualifier\n+     * hierarchy.\n      *\n      * <p>Examples:\n      *\n      * <ul>\n      *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rArr; Nullable\n      * </ul>\n      *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * @param qualifier1 the first qualifier; may not be in the same hierarchy as {@code qualifier2}\n+     * @param qualifier2 the second qualifier; may not be in the same hierarchy as {@code\n+     *     qualifier1}\n+     * @return the least upper bound of the qualifiers, or {@code null} if the qualifiers are from\n+     *     different hierarchies\n+     */\n+    // The fact the null is returned if the qualifiers are not in the same hierarchy is used by the", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2ODg4OA==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456668888", "bodyText": "of two the two?", "author": "wmdietl", "createdAt": "2020-07-17T20:52:29Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -88,45 +105,88 @@ public int getWidth() {\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subQualifier of {@code superQualifier}\n+     * @param superQualifier possible superQualifier of {@code subQualifier}\n+     * @return true iff {@code subQualifier} is a sub qualifier of, or equal to, {@code\n+     *     superQualifier}\n      */\n-    public abstract boolean isSubtype(AnnotationMirror rhs, AnnotationMirror lhs);\n+    public abstract boolean isSubtype(\n+            AnnotationMirror subQualifier, AnnotationMirror superQualifier);\n \n     /**\n-     * Tests whether there is any annotation in lhs that is a super qualifier of, or equal to, some\n-     * annotation in rhs. lhs and rhs contain only the annotations, not the Java type.\n+     * Tests whether all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     * qualifier in the same hierarchy in {@code superQualifiers}.\n      *\n-     * @return true iff an annotation in lhs is a super of one in rhs\n+     * @param subQualifiers set of qualifiers; exactly one per hierarchy\n+     * @param superQualifiers set of qualifiers; exactly one per hierarchy\n+     * @return true iff all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     *     qualifier in the same hierarchy in {@code superQualifiers}\n      */\n     public abstract boolean isSubtype(\n-            Collection<? extends AnnotationMirror> rhs, Collection<? extends AnnotationMirror> lhs);\n+            Collection<? extends AnnotationMirror> subQualifiers,\n+            Collection<? extends AnnotationMirror> superQualifiers);\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n+     * Returns the least upper bound (LUB) of the qualifiers {@code qualifier1} and {@code\n+     * qualifier2}. Returns {@code null} if the qualifiers are not from the same qualifier\n+     * hierarchy.\n      *\n      * <p>Examples:\n      *\n      * <ul>\n      *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rArr; Nullable\n      * </ul>\n      *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * @param qualifier1 the first qualifier; may not be in the same hierarchy as {@code qualifier2}\n+     * @param qualifier2 the second qualifier; may not be in the same hierarchy as {@code\n+     *     qualifier1}\n+     * @return the least upper bound of the qualifiers, or {@code null} if the qualifiers are from\n+     *     different hierarchies\n+     */\n+    // The fact the null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror leastUpperBound(\n+            AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n+\n+    /**\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2OTc5Mw==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456669793", "bodyText": "and -> as?", "author": "wmdietl", "createdAt": "2020-07-17T20:54:46Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MDA2MA==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456670060", "bodyText": "and -> as?", "author": "wmdietl", "createdAt": "2020-07-17T20:55:16Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MDcxMw==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456670713", "bodyText": "leastUpperBound earlier renamed the parameters to qualifier1 and qualifier2. Same would be good here?", "author": "wmdietl", "createdAt": "2020-07-17T20:56:57Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MTIwNg==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456671206", "bodyText": "set -> collection. Maybe also add @see between the different versions that belong together, here and earlier?", "author": "wmdietl", "createdAt": "2020-07-17T20:58:04Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MTM3Mw==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456671373", "bodyText": "two the two sets", "author": "wmdietl", "createdAt": "2020-07-17T20:58:25Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MTU3NQ==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456671575", "bodyText": "set -> collection? Or should the parameter types be changed?", "author": "wmdietl", "createdAt": "2020-07-17T20:59:02Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MTc1Mg==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456671752", "bodyText": "two the two Maybe I missed other occurrences of this...", "author": "wmdietl", "createdAt": "2020-07-17T20:59:29Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of two the two sets of qualifiers", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MjQ3NA==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456672474", "bodyText": "Should it be fully annotated?", "author": "wmdietl", "createdAt": "2020-07-17T21:01:12Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of two the two sets of qualifiers\n      */\n     public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return an empty\n+     * set even if the type has been fully-annotated.", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MzE2MA==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456673160", "bodyText": "Is it really whether it can be an empty set? Shouldn't it be whether fewer than the qualifier hierarchy width qualifiers appear on the type?\nFor example in nullness, a <T> @Nullable T foo()... is valid, even though the qualifier hierarchy has width 2.", "author": "wmdietl", "createdAt": "2020-07-17T21:03:04Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of two the two sets of qualifiers\n      */\n     public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return an empty", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3NDE2Nw==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456674167", "bodyText": "Would using @KeyFor(#1) T key as parameter type work instead?", "author": "wmdietl", "createdAt": "2020-07-17T21:05:33Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of two the two sets of qualifiers\n      */\n     public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return an empty\n+     * set even if the type has been fully-annotated.\n      *\n-     * @param subAnno a qualifier that might be a subtype\n-     * @param superAnno a qualifier that might be a subtype\n-     * @return true iff {@code subAnno} is a sub qualifier of, or equal to, {@code superAnno}\n+     * @param type annotated type mirror\n+     * @return true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return an empty\n+     *     set\n      */\n-    public abstract boolean isSubtypeTypeVariable(\n-            AnnotationMirror subAnno, AnnotationMirror superAnno);\n+    public static boolean canHaveEmptyAnnotationSet(AnnotatedTypeMirror type) {\n+        return type.getKind() == TypeKind.TYPEVAR\n+                || type.getKind() == TypeKind.WILDCARD\n+                ||\n+                // TODO: or should the union/intersection be the LUB of the alternatives?\n+                type.getKind() == TypeKind.UNION\n+                || type.getKind() == TypeKind.INTERSECTION;\n+    }\n \n     /**\n-     * Tests whether there is any annotation in superAnnos that is a super qualifier of or equal to\n-     * some annotation in subAnnos. superAnnos and subAnnos contain only the annotations, not the\n-     * Java type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the same hierarchy as annotationMirror.\n      *\n-     * @return true iff an annotation in superAnnos is a supertype of, or equal to, one in subAnnos\n+     * @param annos set of annotations to search\n+     * @param annotationMirror annotation that is in the same hierarchy as the returned annotation\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    // This method requires more revision.\n-    public abstract boolean isSubtypeTypeVariable(\n-            Collection<? extends AnnotationMirror> subAnnos,\n-            Collection<? extends AnnotationMirror> superAnnos);\n+    public @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        AnnotationMirror top = this.getTopAnnotation(annotationMirror);\n+        return findAnnotationInHierarchy(annos, top);\n+    }\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n-     *\n-     * <p>Examples:\n-     *\n-     * <ul>\n-     *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rarr; Nullable\n-     * </ul>\n-     *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the hierarchy for which annotationMirror is top.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param annos set of annotations to search\n+     * @param top the top annotation in the hierarchy to which the returned annotation belongs\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    public abstract AnnotationMirror leastUpperBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    public @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        for (AnnotationMirror anno : annos) {\n+            if (isSubtype(anno, top)) {\n+                return anno;\n+            }\n+        }\n+        return null;\n+    }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Update a mapping from {@code key} to a set of AnnotationMirrors. If {@code key} is not\n+     * already in the map, then put it in the map with a value of a new set containing {@code\n+     * qualifier}. If the map contains {@code key}, then add {@code qualifier} to the set to which\n+     * {@code key} maps. If that set contains a qualifier in the same hierarchy as {@code\n+     * qualifier}, then don't add it and return false.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n+     * @param map the mapping to modify\n+     * @param key the key to update\n+     * @param qualifier the value to add\n+     * @param <T> type of the map's keys\n+     * @return true if the update was done; false if there was a qualifier hierarchy collision\n      */\n-    public abstract AnnotationMirror greatestLowerBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    public <T> boolean updateMappingToMutableSet(\n+            Map<T, Set<AnnotationMirror>> map, T key, AnnotationMirror qualifier) {\n+        @SuppressWarnings(\"nullness:argument.type.incompatible\") // key is of type T.\n+        boolean mapContainsKey = map.containsKey(key);\n+        if (mapContainsKey) {\n+            @SuppressWarnings(\"nullness:assignment.type.incompatible\") // key is a key for map.", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUyMjUzMA==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r457522530", "bodyText": "No, key does not be a key in map.", "author": "smillst", "createdAt": "2020-07-20T16:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3NDE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3ODQ0Mw==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462478443", "bodyText": "Could you update the description of the key parameter then? The the key to update description would be clearer as the key to update or add.", "author": "wmdietl", "createdAt": "2020-07-29T17:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3NDE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3NjE4Ng==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456676186", "bodyText": "Is this equivalent and a bit clearer:\nif (anno1 != null && anno2 != null) {\n    AnnotationMirror glb = qualifierHierarchy.greatestLowerBound(anno1, anno2);\n    lubLowerBound.replaceAnnotation(glb);\n}\nAs anno1 and anno2 are from the same hierarchy, their glb must exist. The two ifs are confusing the logic for me.", "author": "wmdietl", "createdAt": "2020-07-17T21:10:59Z", "path": "framework/src/main/java/org/checkerframework/framework/util/AtmLubVisitor.java", "diffHunk": "@@ -245,12 +245,14 @@ private void lubWildcard(\n         visit(type1LowerBound, type2LowerBound, lubLowerBound);\n \n         for (AnnotationMirror top : qualifierHierarchy.getTopAnnotations()) {\n-            AnnotationMirror glb =\n-                    qualifierHierarchy.greatestLowerBound(\n-                            type1LowerBound,\n-                            type2LowerBound,\n-                            type1LowerBound.getAnnotationInHierarchy(top),\n-                            type2LowerBound.getAnnotationInHierarchy(top));\n+            AnnotationMirror anno1 = type1LowerBound.getAnnotationInHierarchy(top);\n+            AnnotationMirror anno2 = type2LowerBound.getAnnotationInHierarchy(top);\n+\n+            AnnotationMirror glb = null;\n+            if (anno1 != null && anno2 != null) {", "originalCommit": "86a4037ee6fd5f6af8f43174bec6231da102c123", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bbd9e7e2520d5c26b2b89ff7cff6a5487b08bc2a", "url": "https://github.com/typetools/checker-framework/commit/bbd9e7e2520d5c26b2b89ff7cff6a5487b08bc2a", "message": "Code review.", "committedDate": "2020-07-20T16:03:46Z", "type": "commit"}, {"oid": "20780e5979a6784d6d62214d847f7f179fe23826", "url": "https://github.com/typetools/checker-framework/commit/20780e5979a6784d6d62214d847f7f179fe23826", "message": "Code review.", "committedDate": "2020-07-24T20:41:35Z", "type": "commit"}, {"oid": "46a089543dee13a447766681598255831b5da93a", "url": "https://github.com/typetools/checker-framework/commit/46a089543dee13a447766681598255831b5da93a", "message": "Merge remote-tracking branch 'origin/master' into refactorQualifierHierarchy", "committedDate": "2020-07-24T20:41:43Z", "type": "commit"}, {"oid": "301c6ae25f9e43ada7758bed34edb385c68f4314", "url": "https://github.com/typetools/checker-framework/commit/301c6ae25f9e43ada7758bed34edb385c68f4314", "message": "Make QualifierHierarchy an interface.", "committedDate": "2020-07-28T16:40:16Z", "type": "commit"}, {"oid": "f7e39a321e2aaf1a63aaf81a9b9e9c136a898081", "url": "https://github.com/typetools/checker-framework/commit/f7e39a321e2aaf1a63aaf81a9b9e9c136a898081", "message": "Merge remote-tracking branch 'origin/master' into refactorQualifierHierarchy", "committedDate": "2020-07-28T16:40:31Z", "type": "commit"}, {"oid": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802", "url": "https://github.com/typetools/checker-framework/commit/20809ebb5f1341ade01f3f5f43e05b7d2cef9802", "message": "Add Javadoc.", "committedDate": "2020-07-28T17:02:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM2MTU3Mg==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462361572", "bodyText": "Linking to the type of the parameter is redundant, as the parameter itself already is a link.", "author": "wmdietl", "createdAt": "2020-07-29T14:52:25Z", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -136,7 +136,7 @@ protected boolean shouldCheckTopLevelDeclaredType(AnnotatedTypeMirror type, Tree\n      * Checks every property listed in {@link #isValidType}, but only for the top level type. If\n      * successful, returns an empty list. If not successful, returns diagnostics.\n      *\n-     * @param qualifierHierarchy the qualifier hierarchy\n+     * @param qualifierHierarchy the {@link QualifierHierarchy}", "originalCommit": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1OTk5Mg==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462459992", "bodyText": "Here and in a few other comments, should the \"type hierarchies\" be replaced with \"qualifier hierarchies\", to not confuse with TypeHierarchy instances? Sometimes it's the combined \"type qualifier hierarchies\".", "author": "wmdietl", "createdAt": "2020-07-29T17:17:59Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -32,46 +41,56 @@\n     /**\n      * Returns the width of this hierarchy, i.e. the expected number of annotations on any valid\n      * type.\n+     *\n+     * @return the width of this QualifierHierarchy\n      */\n-    public int getWidth() {\n+    default int getWidth() {\n         return getTopAnnotations().size();\n     }\n \n     /**\n-     * Returns the top (ultimate super) type qualifiers in the type system.\n+     * Returns the top (ultimate super) type qualifiers in the type system. The size of this set is\n+     * equal to {@link #getWidth}.\n      *\n      * @return the top (ultimate super) type qualifiers in the type system\n      */\n-    public abstract Set<? extends AnnotationMirror> getTopAnnotations();\n+    Set<? extends AnnotationMirror> getTopAnnotations();\n \n     /**\n      * Return the top qualifier for the given qualifier, that is, the qualifier that is a supertype\n-     * of start but no further supertypes exist.\n+     * of {@code qualifier} but no further supertypes exist.\n+     *\n+     * @param qualifier any qualifier from one of the type hierarchies represented by this", "originalCommit": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3MzIxNw==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462473217", "bodyText": "Just repeating the type doesn't add much. \"the type to test\"?", "author": "wmdietl", "createdAt": "2020-07-29T17:40:09Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -81,361 +100,351 @@ public int getWidth() {\n      * @return {@code true} if the qualifier is a polymorphic qualifier; otherwise, returns {@code\n      *     false}.\n      */\n-    public abstract boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n+    boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n \n     // **********************************************************************\n     // Qualifier Hierarchy Queries\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subqualifier of {@code superQualifier}\n+     * @param superQualifier possible superqualifier of {@code subQualifier}\n+     * @return true iff {@code subQualifier} is a subqualifier of, or equal to, {@code\n+     *     superQualifier}\n      */\n-    public abstract boolean isSubtype(AnnotationMirror rhs, AnnotationMirror lhs);\n+    boolean isSubtype(AnnotationMirror subQualifier, AnnotationMirror superQualifier);\n \n     /**\n-     * Tests whether there is any annotation in lhs that is a super qualifier of, or equal to, some\n-     * annotation in rhs. lhs and rhs contain only the annotations, not the Java type.\n+     * Tests whether all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     * qualifier in the same hierarchy in {@code superQualifiers}.\n      *\n-     * @return true iff an annotation in lhs is a super of one in rhs\n+     * @param subQualifiers set of qualifiers; exactly one per hierarchy\n+     * @param superQualifiers set of qualifiers; exactly one per hierarchy\n+     * @return true iff all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     *     qualifier in the same hierarchy in {@code superQualifiers}\n      */\n-    public abstract boolean isSubtype(\n-            Collection<? extends AnnotationMirror> rhs, Collection<? extends AnnotationMirror> lhs);\n+    boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subQualifiers,\n+            Collection<? extends AnnotationMirror> superQualifiers);\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n+     * Returns the least upper bound (LUB) of the qualifiers {@code qualifier1} and {@code\n+     * qualifier2}. Returns {@code null} if the qualifiers are not from the same qualifier\n+     * hierarchy.\n      *\n      * <p>Examples:\n      *\n      * <ul>\n      *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rArr; Nullable\n      * </ul>\n      *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * @param qualifier1 the first qualifier; may not be in the same hierarchy as {@code qualifier2}\n+     * @param qualifier2 the second qualifier; may not be in the same hierarchy as {@code\n+     *     qualifier1}\n+     * @return the least upper bound of the qualifiers, or {@code null} if the qualifiers are from\n+     *     different hierarchies\n+     */\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror leastUpperBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n+\n+    /**\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public abstract AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2);\n+    default Set<? extends AnnotationMirror> leastUpperBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n+            throw new BugInCF(\n+                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n+        }\n+\n+        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n+                AnnotationMirror lub = leastUpperBound(a1, a2);\n+                if (lub != null) {\n+                    result.add(lub);\n+                }\n+            }\n+        }\n+\n+        assertSameSize(result, qualifiers1);\n+        return result;\n+    }\n \n     /**\n      * Returns the number of iterations dataflow should perform before {@link\n      * #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should never be\n      * called.\n      *\n-     * <p>Subclasses overriding this method should return some positive number or -1.\n-     *\n      * @return the number of iterations dataflow should perform before {@link\n      *     #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should\n      *     never be called.\n      */\n-    public int numberOfIterationsBeforeWidening() {\n+    default int numberOfIterationsBeforeWidening() {\n         return -1;\n     }\n \n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy as {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy as {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n-    public AnnotationMirror widenedUpperBound(\n+    default AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers qualifier1 and qualifier2. Returns null\n+     * if the qualifiers are not from the same qualifier hierarchy.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @param qualifier1 first qualifier\n+     * @param qualifier2 second qualifier\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror greatestLowerBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+    default Set<? extends AnnotationMirror> greatestLowerBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     * with fewer qualifiers than the width of the QualifierHierarchy.\n      *\n-     * @param subAnno a qualifier that might be a subtype\n-     * @param superAnno a qualifier that might be a subtype\n-     * @return true iff {@code subAnno} is a sub qualifier of, or equal to, {@code superAnno}\n+     * @param type annotated type mirror", "originalCommit": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3OTMwOA==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462479308", "bodyText": "I'm confused about the suppression. Both the variable key and the key-type of map are T, so just saying key is of type T, doesn't explain why there is an error that can be suppressed.", "author": "wmdietl", "createdAt": "2020-07-29T17:49:45Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -81,361 +100,351 @@ public int getWidth() {\n      * @return {@code true} if the qualifier is a polymorphic qualifier; otherwise, returns {@code\n      *     false}.\n      */\n-    public abstract boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n+    boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n \n     // **********************************************************************\n     // Qualifier Hierarchy Queries\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subqualifier of {@code superQualifier}\n+     * @param superQualifier possible superqualifier of {@code subQualifier}\n+     * @return true iff {@code subQualifier} is a subqualifier of, or equal to, {@code\n+     *     superQualifier}\n      */\n-    public abstract boolean isSubtype(AnnotationMirror rhs, AnnotationMirror lhs);\n+    boolean isSubtype(AnnotationMirror subQualifier, AnnotationMirror superQualifier);\n \n     /**\n-     * Tests whether there is any annotation in lhs that is a super qualifier of, or equal to, some\n-     * annotation in rhs. lhs and rhs contain only the annotations, not the Java type.\n+     * Tests whether all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     * qualifier in the same hierarchy in {@code superQualifiers}.\n      *\n-     * @return true iff an annotation in lhs is a super of one in rhs\n+     * @param subQualifiers set of qualifiers; exactly one per hierarchy\n+     * @param superQualifiers set of qualifiers; exactly one per hierarchy\n+     * @return true iff all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     *     qualifier in the same hierarchy in {@code superQualifiers}\n      */\n-    public abstract boolean isSubtype(\n-            Collection<? extends AnnotationMirror> rhs, Collection<? extends AnnotationMirror> lhs);\n+    boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subQualifiers,\n+            Collection<? extends AnnotationMirror> superQualifiers);\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n+     * Returns the least upper bound (LUB) of the qualifiers {@code qualifier1} and {@code\n+     * qualifier2}. Returns {@code null} if the qualifiers are not from the same qualifier\n+     * hierarchy.\n      *\n      * <p>Examples:\n      *\n      * <ul>\n      *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rArr; Nullable\n      * </ul>\n      *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * @param qualifier1 the first qualifier; may not be in the same hierarchy as {@code qualifier2}\n+     * @param qualifier2 the second qualifier; may not be in the same hierarchy as {@code\n+     *     qualifier1}\n+     * @return the least upper bound of the qualifiers, or {@code null} if the qualifiers are from\n+     *     different hierarchies\n+     */\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror leastUpperBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n+\n+    /**\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public abstract AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2);\n+    default Set<? extends AnnotationMirror> leastUpperBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n+            throw new BugInCF(\n+                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n+        }\n+\n+        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n+                AnnotationMirror lub = leastUpperBound(a1, a2);\n+                if (lub != null) {\n+                    result.add(lub);\n+                }\n+            }\n+        }\n+\n+        assertSameSize(result, qualifiers1);\n+        return result;\n+    }\n \n     /**\n      * Returns the number of iterations dataflow should perform before {@link\n      * #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should never be\n      * called.\n      *\n-     * <p>Subclasses overriding this method should return some positive number or -1.\n-     *\n      * @return the number of iterations dataflow should perform before {@link\n      *     #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should\n      *     never be called.\n      */\n-    public int numberOfIterationsBeforeWidening() {\n+    default int numberOfIterationsBeforeWidening() {\n         return -1;\n     }\n \n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy as {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy as {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n-    public AnnotationMirror widenedUpperBound(\n+    default AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers qualifier1 and qualifier2. Returns null\n+     * if the qualifiers are not from the same qualifier hierarchy.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @param qualifier1 first qualifier\n+     * @param qualifier2 second qualifier\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror greatestLowerBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+    default Set<? extends AnnotationMirror> greatestLowerBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     * with fewer qualifiers than the width of the QualifierHierarchy.\n      *\n-     * @param subAnno a qualifier that might be a subtype\n-     * @param superAnno a qualifier that might be a subtype\n-     * @return true iff {@code subAnno} is a sub qualifier of, or equal to, {@code superAnno}\n+     * @param type annotated type mirror\n+     * @return true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     *     with fewer qualifiers than the width of the QualifierHierarchy\n      */\n-    public abstract boolean isSubtypeTypeVariable(\n-            AnnotationMirror subAnno, AnnotationMirror superAnno);\n+    public static boolean canHaveEmptyAnnotationSet(AnnotatedTypeMirror type) {\n+        return type.getKind() == TypeKind.TYPEVAR\n+                || type.getKind() == TypeKind.WILDCARD\n+                ||\n+                // TODO: or should the union/intersection be the LUB of the alternatives?\n+                type.getKind() == TypeKind.UNION\n+                || type.getKind() == TypeKind.INTERSECTION;\n+    }\n \n     /**\n-     * Tests whether there is any annotation in superAnnos that is a super qualifier of or equal to\n-     * some annotation in subAnnos. superAnnos and subAnnos contain only the annotations, not the\n-     * Java type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the same hierarchy as annotationMirror.\n      *\n-     * @return true iff an annotation in superAnnos is a supertype of, or equal to, one in subAnnos\n+     * @param annos set of annotations to search\n+     * @param annotationMirror annotation that is in the same hierarchy as the returned annotation\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    // This method requires more revision.\n-    public abstract boolean isSubtypeTypeVariable(\n-            Collection<? extends AnnotationMirror> subAnnos,\n-            Collection<? extends AnnotationMirror> superAnnos);\n+    default @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        AnnotationMirror top = this.getTopAnnotation(annotationMirror);\n+        return findAnnotationInHierarchy(annos, top);\n+    }\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n-     *\n-     * <p>Examples:\n-     *\n-     * <ul>\n-     *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rarr; Nullable\n-     * </ul>\n-     *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the hierarchy for which annotationMirror is top.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param annos set of annotations to search\n+     * @param top the top annotation in the hierarchy to which the returned annotation belongs\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    public abstract AnnotationMirror leastUpperBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    default @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        for (AnnotationMirror anno : annos) {\n+            if (isSubtype(anno, top)) {\n+                return anno;\n+            }\n+        }\n+        return null;\n+    }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Update a mapping from {@code key} to a set of AnnotationMirrors. If {@code key} is not\n+     * already in the map, then put it in the map with a value of a new set containing {@code\n+     * qualifier}. If the map contains {@code key}, then add {@code qualifier} to the set to which\n+     * {@code key} maps. If that set contains a qualifier in the same hierarchy as {@code\n+     * qualifier}, then don't add it and return false.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n+     * @param map the mapping to modify\n+     * @param key the key to update\n+     * @param qualifier the value to add\n+     * @param <T> type of the map's keys\n+     * @return true if the update was done; false if there was a qualifier hierarchy collision\n      */\n-    public abstract AnnotationMirror greatestLowerBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    default <T> boolean updateMappingToMutableSet(\n+            Map<T, Set<AnnotationMirror>> map, T key, AnnotationMirror qualifier) {\n+        @SuppressWarnings(\"nullness:argument.type.incompatible\") // key is of type T.", "originalCommit": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU2MDgwMQ==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462560801", "bodyText": "The type of the parameter of containsKey is @NonNull Object.  Call is legal because key is of type T.  I added a reference to #2000.", "author": "smillst", "createdAt": "2020-07-29T20:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3OTMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4MDgzNg==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462480836", "bodyText": "For all the deprecated methods, can you point to the methods that should be used instead?", "author": "wmdietl", "createdAt": "2020-07-29T17:52:18Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -81,361 +100,351 @@ public int getWidth() {\n      * @return {@code true} if the qualifier is a polymorphic qualifier; otherwise, returns {@code\n      *     false}.\n      */\n-    public abstract boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n+    boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n \n     // **********************************************************************\n     // Qualifier Hierarchy Queries\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subqualifier of {@code superQualifier}\n+     * @param superQualifier possible superqualifier of {@code subQualifier}\n+     * @return true iff {@code subQualifier} is a subqualifier of, or equal to, {@code\n+     *     superQualifier}\n      */\n-    public abstract boolean isSubtype(AnnotationMirror rhs, AnnotationMirror lhs);\n+    boolean isSubtype(AnnotationMirror subQualifier, AnnotationMirror superQualifier);\n \n     /**\n-     * Tests whether there is any annotation in lhs that is a super qualifier of, or equal to, some\n-     * annotation in rhs. lhs and rhs contain only the annotations, not the Java type.\n+     * Tests whether all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     * qualifier in the same hierarchy in {@code superQualifiers}.\n      *\n-     * @return true iff an annotation in lhs is a super of one in rhs\n+     * @param subQualifiers set of qualifiers; exactly one per hierarchy\n+     * @param superQualifiers set of qualifiers; exactly one per hierarchy\n+     * @return true iff all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     *     qualifier in the same hierarchy in {@code superQualifiers}\n      */\n-    public abstract boolean isSubtype(\n-            Collection<? extends AnnotationMirror> rhs, Collection<? extends AnnotationMirror> lhs);\n+    boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subQualifiers,\n+            Collection<? extends AnnotationMirror> superQualifiers);\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n+     * Returns the least upper bound (LUB) of the qualifiers {@code qualifier1} and {@code\n+     * qualifier2}. Returns {@code null} if the qualifiers are not from the same qualifier\n+     * hierarchy.\n      *\n      * <p>Examples:\n      *\n      * <ul>\n      *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rArr; Nullable\n      * </ul>\n      *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * @param qualifier1 the first qualifier; may not be in the same hierarchy as {@code qualifier2}\n+     * @param qualifier2 the second qualifier; may not be in the same hierarchy as {@code\n+     *     qualifier1}\n+     * @return the least upper bound of the qualifiers, or {@code null} if the qualifiers are from\n+     *     different hierarchies\n+     */\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror leastUpperBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n+\n+    /**\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public abstract AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2);\n+    default Set<? extends AnnotationMirror> leastUpperBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n+            throw new BugInCF(\n+                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n+        }\n+\n+        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n+                AnnotationMirror lub = leastUpperBound(a1, a2);\n+                if (lub != null) {\n+                    result.add(lub);\n+                }\n+            }\n+        }\n+\n+        assertSameSize(result, qualifiers1);\n+        return result;\n+    }\n \n     /**\n      * Returns the number of iterations dataflow should perform before {@link\n      * #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should never be\n      * called.\n      *\n-     * <p>Subclasses overriding this method should return some positive number or -1.\n-     *\n      * @return the number of iterations dataflow should perform before {@link\n      *     #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should\n      *     never be called.\n      */\n-    public int numberOfIterationsBeforeWidening() {\n+    default int numberOfIterationsBeforeWidening() {\n         return -1;\n     }\n \n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy as {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy as {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n-    public AnnotationMirror widenedUpperBound(\n+    default AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers qualifier1 and qualifier2. Returns null\n+     * if the qualifiers are not from the same qualifier hierarchy.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @param qualifier1 first qualifier\n+     * @param qualifier2 second qualifier\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror greatestLowerBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+    default Set<? extends AnnotationMirror> greatestLowerBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     * with fewer qualifiers than the width of the QualifierHierarchy.\n      *\n-     * @param subAnno a qualifier that might be a subtype\n-     * @param superAnno a qualifier that might be a subtype\n-     * @return true iff {@code subAnno} is a sub qualifier of, or equal to, {@code superAnno}\n+     * @param type annotated type mirror\n+     * @return true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     *     with fewer qualifiers than the width of the QualifierHierarchy\n      */\n-    public abstract boolean isSubtypeTypeVariable(\n-            AnnotationMirror subAnno, AnnotationMirror superAnno);\n+    public static boolean canHaveEmptyAnnotationSet(AnnotatedTypeMirror type) {\n+        return type.getKind() == TypeKind.TYPEVAR\n+                || type.getKind() == TypeKind.WILDCARD\n+                ||\n+                // TODO: or should the union/intersection be the LUB of the alternatives?\n+                type.getKind() == TypeKind.UNION\n+                || type.getKind() == TypeKind.INTERSECTION;\n+    }\n \n     /**\n-     * Tests whether there is any annotation in superAnnos that is a super qualifier of or equal to\n-     * some annotation in subAnnos. superAnnos and subAnnos contain only the annotations, not the\n-     * Java type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the same hierarchy as annotationMirror.\n      *\n-     * @return true iff an annotation in superAnnos is a supertype of, or equal to, one in subAnnos\n+     * @param annos set of annotations to search\n+     * @param annotationMirror annotation that is in the same hierarchy as the returned annotation\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    // This method requires more revision.\n-    public abstract boolean isSubtypeTypeVariable(\n-            Collection<? extends AnnotationMirror> subAnnos,\n-            Collection<? extends AnnotationMirror> superAnnos);\n+    default @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        AnnotationMirror top = this.getTopAnnotation(annotationMirror);\n+        return findAnnotationInHierarchy(annos, top);\n+    }\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n-     *\n-     * <p>Examples:\n-     *\n-     * <ul>\n-     *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rarr; Nullable\n-     * </ul>\n-     *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the hierarchy for which annotationMirror is top.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param annos set of annotations to search\n+     * @param top the top annotation in the hierarchy to which the returned annotation belongs\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    public abstract AnnotationMirror leastUpperBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    default @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        for (AnnotationMirror anno : annos) {\n+            if (isSubtype(anno, top)) {\n+                return anno;\n+            }\n+        }\n+        return null;\n+    }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Update a mapping from {@code key} to a set of AnnotationMirrors. If {@code key} is not\n+     * already in the map, then put it in the map with a value of a new set containing {@code\n+     * qualifier}. If the map contains {@code key}, then add {@code qualifier} to the set to which\n+     * {@code key} maps. If that set contains a qualifier in the same hierarchy as {@code\n+     * qualifier}, then don't add it and return false.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n+     * @param map the mapping to modify\n+     * @param key the key to update\n+     * @param qualifier the value to add\n+     * @param <T> type of the map's keys\n+     * @return true if the update was done; false if there was a qualifier hierarchy collision\n      */\n-    public abstract AnnotationMirror greatestLowerBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    default <T> boolean updateMappingToMutableSet(\n+            Map<T, Set<AnnotationMirror>> map, T key, AnnotationMirror qualifier) {\n+        @SuppressWarnings(\"nullness:argument.type.incompatible\") // key is of type T.\n+        boolean mapContainsKey = map.containsKey(key);\n+        if (mapContainsKey) {\n+            @SuppressWarnings(\"nullness:assignment.type.incompatible\") // key is a key for map.\n+            @NonNull Set<AnnotationMirror> prevs = map.get(key);\n+            AnnotationMirror old = findAnnotationInSameHierarchy(prevs, qualifier);\n+            if (old != null) {\n+                return false;\n+            }\n+            prevs.add(qualifier);\n+            map.put(key, prevs);\n+        } else {\n+            Set<AnnotationMirror> set = AnnotationUtils.createAnnotationSet();\n+            set.add(qualifier);\n+            map.put(key, set);\n+        }\n+        return true;\n+    }\n \n     /**\n-     * Returns the type qualifiers that are the least upper bound of the qualifiers in annos1 and\n-     * annos2.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Throws an exception if the given collections do not have the same size.\n      *\n-     * @return the least upper bound of annos1 and annos2\n+     * @param c1 the first collection\n+     * @param c2 the second collection\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBoundsTypeVariable(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror top : getTopAnnotations()) {\n-            AnnotationMirror anno1ForTop = null;\n-            for (AnnotationMirror anno1 : annos1) {\n-                if (isSubtypeTypeVariable(anno1, top)) {\n-                    anno1ForTop = anno1;\n-                }\n-            }\n-            AnnotationMirror anno2ForTop = null;\n-            for (AnnotationMirror anno2 : annos2) {\n-                if (isSubtypeTypeVariable(anno2, top)) {\n-                    anno2ForTop = anno2;\n-                }\n-            }\n-            AnnotationMirror t = leastUpperBoundTypeVariable(anno1ForTop, anno2ForTop);\n-            if (t != null) {\n-                result.add(t);\n-            }\n+    static void assertSameSize(Collection<?> c1, Collection<?> c2) {\n+        if (c1.size() != c2.size()) {\n+            throw new BugInCF(\n+                    \"inconsistent sizes (%d, %d):%n  %s%n  %s\", c1.size(), c2.size(), c1, c2);\n         }\n-        return result;\n     }\n \n     /**\n-     * Returns the type qualifiers that are the greatest lower bound of the qualifiers in annos1 and\n-     * annos2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Throws an exception if the result does not have the same size as the inputs (which are\n+     * assumed to have the same size as one another).\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return greatest lower bound of the two collections of qualifiers\n+     * @param c1 the first collection\n+     * @param c2 the second collection\n+     * @param result the result collection\n      */\n-    public Set<? extends AnnotationMirror> greatestLowerBoundsTypeVariable(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror top : getTopAnnotations()) {\n-            AnnotationMirror anno1ForTop = null;\n-            for (AnnotationMirror anno1 : annos1) {\n-                if (isSubtypeTypeVariable(anno1, top)) {\n-                    anno1ForTop = anno1;\n-                }\n-            }\n-            AnnotationMirror anno2ForTop = null;\n-            for (AnnotationMirror anno2 : annos2) {\n-                if (isSubtypeTypeVariable(anno2, top)) {\n-                    anno2ForTop = anno2;\n-                }\n-            }\n-            AnnotationMirror t = greatestLowerBoundTypeVariable(anno1ForTop, anno2ForTop);\n-            if (t != null) {\n-                result.add(t);\n-            }\n+    static void assertSameSize(Collection<?> c1, Collection<?> c2, Collection<?> result) {\n+        if (c1.size() != result.size()) {\n+            throw new BugInCF(\n+                    \"inconsistent sizes (%d, %d, %d):%n  %s%n  %s%n  %s\",\n+                    c1.size(), c2.size(), result.size(), c1, c2, result);\n         }\n-        return result;\n     }\n \n+    // **********************************************************************\n+    // Deprecated methods\n+    // **********************************************************************\n+\n     /**\n-     * Returns true if and only if the given type can have empty annotation sets (and thus the\n-     * *TypeVariable methods need to be used).\n-     */\n-    public static boolean canHaveEmptyAnnotationSet(AnnotatedTypeMirror type) {\n-        return type.getKind() == TypeKind.TYPEVAR\n-                || type.getKind() == TypeKind.WILDCARD\n-                ||\n-                // TODO: or should the union/intersection be the LUB of the alternatives?\n-                type.getKind() == TypeKind.UNION\n-                || type.getKind() == TypeKind.INTERSECTION;\n+     * Tests whether {@code subQualifier} is a sub-qualifier of, or equal to, {@code\n+     * superQualifier}, according to the type qualifier hierarchy.\n+     *\n+     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n+     * 'null' AnnotationMirror is a legal argument that represents no annotation.\n+     *\n+     * @param subQualifier a qualifier that might be a subtype\n+     * @param superQualifier a qualifier that might be a subtype\n+     * @return true iff {@code subQualifier} is a subqualifier of, or equal to, {@code\n+     *     superQualifier}\n+     * @deprecated Without the bounds of the type variable, it is not possible to correctly compute", "originalCommit": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4NDA4OA==", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462484088", "bodyText": "Other methods in this interface would call these qualifiers and qualifier, I think. Let's try to use consistent names within a class/interface. A few other places below.", "author": "wmdietl", "createdAt": "2020-07-29T17:57:48Z", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -81,361 +100,351 @@ public int getWidth() {\n      * @return {@code true} if the qualifier is a polymorphic qualifier; otherwise, returns {@code\n      *     false}.\n      */\n-    public abstract boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n+    boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n \n     // **********************************************************************\n     // Qualifier Hierarchy Queries\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subqualifier of {@code superQualifier}\n+     * @param superQualifier possible superqualifier of {@code subQualifier}\n+     * @return true iff {@code subQualifier} is a subqualifier of, or equal to, {@code\n+     *     superQualifier}\n      */\n-    public abstract boolean isSubtype(AnnotationMirror rhs, AnnotationMirror lhs);\n+    boolean isSubtype(AnnotationMirror subQualifier, AnnotationMirror superQualifier);\n \n     /**\n-     * Tests whether there is any annotation in lhs that is a super qualifier of, or equal to, some\n-     * annotation in rhs. lhs and rhs contain only the annotations, not the Java type.\n+     * Tests whether all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     * qualifier in the same hierarchy in {@code superQualifiers}.\n      *\n-     * @return true iff an annotation in lhs is a super of one in rhs\n+     * @param subQualifiers set of qualifiers; exactly one per hierarchy\n+     * @param superQualifiers set of qualifiers; exactly one per hierarchy\n+     * @return true iff all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     *     qualifier in the same hierarchy in {@code superQualifiers}\n      */\n-    public abstract boolean isSubtype(\n-            Collection<? extends AnnotationMirror> rhs, Collection<? extends AnnotationMirror> lhs);\n+    boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subQualifiers,\n+            Collection<? extends AnnotationMirror> superQualifiers);\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n+     * Returns the least upper bound (LUB) of the qualifiers {@code qualifier1} and {@code\n+     * qualifier2}. Returns {@code null} if the qualifiers are not from the same qualifier\n+     * hierarchy.\n      *\n      * <p>Examples:\n      *\n      * <ul>\n      *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rArr; Nullable\n      * </ul>\n      *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * @param qualifier1 the first qualifier; may not be in the same hierarchy as {@code qualifier2}\n+     * @param qualifier2 the second qualifier; may not be in the same hierarchy as {@code\n+     *     qualifier1}\n+     * @return the least upper bound of the qualifiers, or {@code null} if the qualifiers are from\n+     *     different hierarchies\n+     */\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror leastUpperBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n+\n+    /**\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public abstract AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2);\n+    default Set<? extends AnnotationMirror> leastUpperBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n+            throw new BugInCF(\n+                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n+        }\n+\n+        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n+                AnnotationMirror lub = leastUpperBound(a1, a2);\n+                if (lub != null) {\n+                    result.add(lub);\n+                }\n+            }\n+        }\n+\n+        assertSameSize(result, qualifiers1);\n+        return result;\n+    }\n \n     /**\n      * Returns the number of iterations dataflow should perform before {@link\n      * #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should never be\n      * called.\n      *\n-     * <p>Subclasses overriding this method should return some positive number or -1.\n-     *\n      * @return the number of iterations dataflow should perform before {@link\n      *     #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should\n      *     never be called.\n      */\n-    public int numberOfIterationsBeforeWidening() {\n+    default int numberOfIterationsBeforeWidening() {\n         return -1;\n     }\n \n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy as {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy as {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n-    public AnnotationMirror widenedUpperBound(\n+    default AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers qualifier1 and qualifier2. Returns null\n+     * if the qualifiers are not from the same qualifier hierarchy.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @param qualifier1 first qualifier\n+     * @param qualifier2 second qualifier\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror greatestLowerBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+    default Set<? extends AnnotationMirror> greatestLowerBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     * with fewer qualifiers than the width of the QualifierHierarchy.\n      *\n-     * @param subAnno a qualifier that might be a subtype\n-     * @param superAnno a qualifier that might be a subtype\n-     * @return true iff {@code subAnno} is a sub qualifier of, or equal to, {@code superAnno}\n+     * @param type annotated type mirror\n+     * @return true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     *     with fewer qualifiers than the width of the QualifierHierarchy\n      */\n-    public abstract boolean isSubtypeTypeVariable(\n-            AnnotationMirror subAnno, AnnotationMirror superAnno);\n+    public static boolean canHaveEmptyAnnotationSet(AnnotatedTypeMirror type) {\n+        return type.getKind() == TypeKind.TYPEVAR\n+                || type.getKind() == TypeKind.WILDCARD\n+                ||\n+                // TODO: or should the union/intersection be the LUB of the alternatives?\n+                type.getKind() == TypeKind.UNION\n+                || type.getKind() == TypeKind.INTERSECTION;\n+    }\n \n     /**\n-     * Tests whether there is any annotation in superAnnos that is a super qualifier of or equal to\n-     * some annotation in subAnnos. superAnnos and subAnnos contain only the annotations, not the\n-     * Java type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the same hierarchy as annotationMirror.\n      *\n-     * @return true iff an annotation in superAnnos is a supertype of, or equal to, one in subAnnos\n+     * @param annos set of annotations to search\n+     * @param annotationMirror annotation that is in the same hierarchy as the returned annotation\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    // This method requires more revision.\n-    public abstract boolean isSubtypeTypeVariable(\n-            Collection<? extends AnnotationMirror> subAnnos,\n-            Collection<? extends AnnotationMirror> superAnnos);\n+    default @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {", "originalCommit": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "324239b8ff905c6927c43641dbdf293781fb96d4", "url": "https://github.com/typetools/checker-framework/commit/324239b8ff905c6927c43641dbdf293781fb96d4", "message": "Address code review.", "committedDate": "2020-07-29T20:18:42Z", "type": "commit"}]}