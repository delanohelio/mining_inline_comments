{"pr_number": 3306, "pr_title": "Add a generic accumulation checker", "pr_createdAt": "2020-05-12T22:06:03Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3306", "timeline": [{"oid": "52abc210698334562fe89c1d6f1fba36b185935d", "url": "https://github.com/typetools/checker-framework/commit/52abc210698334562fe89c1d6f1fba36b185935d", "message": "Edits from code review", "committedDate": "2020-06-09T02:44:22Z", "type": "commit"}, {"oid": "196d0c35adc7624f835edb8cddf0c209fed6433d", "url": "https://github.com/typetools/checker-framework/commit/196d0c35adc7624f835edb8cddf0c209fed6433d", "message": "Merge branch 'master' of github.com:typetools/checker-framework into accumulation-analysis", "committedDate": "2020-06-09T16:41:30Z", "type": "commit"}, {"oid": "c70776e018626fd8ca7a08618fab22cb52f5e423", "url": "https://github.com/typetools/checker-framework/commit/c70776e018626fd8ca7a08618fab22cb52f5e423", "message": "fix typo", "committedDate": "2020-06-09T16:44:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNzAzOQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r437107039", "bodyText": "Is there a test case that shows this halting at a non-receiver-returning method invocation?", "author": "mernst", "createdAt": "2020-06-09T02:45:28Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue as long as\n+     * each receiver is itself a receiver-returning method invocation.", "originalCommit": "52abc210698334562fe89c1d6f1fba36b185935d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM5NTU2OA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r440395568", "bodyText": "Yes. See ~line 35 of SimpleFluent.java, for example.", "author": "kelloggm", "createdAt": "2020-06-15T19:24:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNzAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNzE3NA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r437107174", "bodyText": "Could you add this test case?  Probably there will be a comment saying the code is safe and the checker currently issues a false positive warning.", "author": "mernst", "createdAt": "2020-06-09T02:45:59Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue as long as\n+     * each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. Then all of the expressions {@code a.b().c()}, {@code a.b()}, and\n+     * {@code a} would have their estimates updated to include \"foo\". Note that due to what kind of\n+     * values can be held in the store, this information is lost outside the method chain. That is,\n+     * the returns-receiver propagated information is lost outside the expression in which the\n+     * returns-receiver method invocations are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the", "originalCommit": "52abc210698334562fe89c1d6f1fba36b185935d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM5Njc2Mg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r440396762", "bodyText": "The test case exists, in SimpleFluent.java. It passes, because the Test Accumulation called-methods checker includes the other rules that allows the code to typecheck. I'll clarify this documentation to explicitly mention the need for another rule from the user if they want to handle this kind of case.", "author": "kelloggm", "createdAt": "2020-06-15T19:26:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNzE3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1MjE1MQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r441152151", "bodyText": "The test case I had in mind contained a non-@This-returning method in the middle of a chain of @This-returning methods.  That is, there appear @This-returning methods both before and after it.  I added such a test case, and it fails.  It is poorly named m8 and you might want to rename it.", "author": "mernst", "createdAt": "2020-06-16T21:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNzE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNzQxMQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r437107411", "bodyText": "The reason that a.b().c() gets updated is different from why the other two expressions get updated.  I think that is worth calling out in the example.", "author": "mernst", "createdAt": "2020-06-09T02:46:57Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue as long as\n+     * each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. Then all of the expressions {@code a.b().c()}, {@code a.b()}, and", "originalCommit": "52abc210698334562fe89c1d6f1fba36b185935d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwODMwOQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r437108309", "bodyText": "Please add a test case for this.", "author": "mernst", "createdAt": "2020-06-09T02:50:32Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue as long as\n+     * each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. Then all of the expressions {@code a.b().c()}, {@code a.b()}, and\n+     * {@code a} would have their estimates updated to include \"foo\". Note that due to what kind of\n+     * values can be held in the store, this information is lost outside the method chain. That is,\n+     * the returns-receiver propagated information is lost outside the expression in which the\n+     * returns-receiver method invocations are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the\n+     * store does not keep the information that a, b, and c have been called outside the chain.\n+     * {@code foo}'s type will be {@code CalledMethods(\"a\")}, because only {@code a()} was called on\n+     * {@code foo} directly.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getUnionAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            Node receiver = methodInvocationNode.getTarget().getReceiver();\n+            MethodInvocationTree invokedMethod = (MethodInvocationTree) tree;\n+\n+            while (receiver != null && typeFactory.returnsThis(invokedMethod)) {\n+                // Note that this call doesn't do anything if receiver is a method call\n+                // that is not deterministic, though it can still continue to recurse.", "originalCommit": "52abc210698334562fe89c1d6f1fba36b185935d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwODMyMQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r437108321", "bodyText": "invokedMethod is not a method.  It's a call.  Therefore, the name is confusing.  It's also confusing that although methodInvocationNode and invokedMethod represent the same thing (just as different types), their names do not reflect this relationship.", "author": "mernst", "createdAt": "2020-06-09T02:50:35Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue as long as\n+     * each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. Then all of the expressions {@code a.b().c()}, {@code a.b()}, and\n+     * {@code a} would have their estimates updated to include \"foo\". Note that due to what kind of\n+     * values can be held in the store, this information is lost outside the method chain. That is,\n+     * the returns-receiver propagated information is lost outside the expression in which the\n+     * returns-receiver method invocations are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the\n+     * store does not keep the information that a, b, and c have been called outside the chain.\n+     * {@code foo}'s type will be {@code CalledMethods(\"a\")}, because only {@code a()} was called on\n+     * {@code foo} directly.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getUnionAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            Node receiver = methodInvocationNode.getTarget().getReceiver();\n+            MethodInvocationTree invokedMethod = (MethodInvocationTree) tree;", "originalCommit": "52abc210698334562fe89c1d6f1fba36b185935d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwODMzMQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r437108331", "bodyText": "Please document the relationship between these variables.  It isn't obvious from the code.\nCan you convert any of them from loop-carried dependencies into local variables within the loop?  If you can reduce the number of variables that the loop maintains, the loop will be easier to understand.", "author": "mernst", "createdAt": "2020-06-09T02:50:37Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue as long as\n+     * each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. Then all of the expressions {@code a.b().c()}, {@code a.b()}, and\n+     * {@code a} would have their estimates updated to include \"foo\". Note that due to what kind of\n+     * values can be held in the store, this information is lost outside the method chain. That is,\n+     * the returns-receiver propagated information is lost outside the expression in which the\n+     * returns-receiver method invocations are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the\n+     * store does not keep the information that a, b, and c have been called outside the chain.\n+     * {@code foo}'s type will be {@code CalledMethods(\"a\")}, because only {@code a()} was called on\n+     * {@code foo} directly.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getUnionAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;", "originalCommit": "52abc210698334562fe89c1d6f1fba36b185935d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ba894ccb05b1311e461b5aac9c5dd30b22471716", "url": "https://github.com/typetools/checker-framework/commit/ba894ccb05b1311e461b5aac9c5dd30b22471716", "message": "Merge branch 'master' of github.com:typetools/checker-framework into accumulation-analysis", "committedDate": "2020-06-15T19:23:05Z", "type": "commit"}, {"oid": "367e41eedbae2fc410f64f20945ffbe54a33123a", "url": "https://github.com/typetools/checker-framework/commit/367e41eedbae2fc410f64f20945ffbe54a33123a", "message": "address code review feedback", "committedDate": "2020-06-15T20:44:15Z", "type": "commit"}, {"oid": "20bbd632ea069517952f076398662cfa91d2fe75", "url": "https://github.com/typetools/checker-framework/commit/20bbd632ea069517952f076398662cfa91d2fe75", "message": "Merge ../checker-framework-branch-master into accumulation-analysis", "committedDate": "2020-06-16T20:08:33Z", "type": "commit"}, {"oid": "3f105f888bbbfe266514590a1234d28b1fda1b04", "url": "https://github.com/typetools/checker-framework/commit/3f105f888bbbfe266514590a1234d28b1fda1b04", "message": "Comment tweaks", "committedDate": "2020-06-16T21:10:29Z", "type": "commit"}, {"oid": "a6a93752704ac29f6cfd32883d3022463f1f5b44", "url": "https://github.com/typetools/checker-framework/commit/a6a93752704ac29f6cfd32883d3022463f1f5b44", "message": "Comment tweak", "committedDate": "2020-06-16T21:24:04Z", "type": "commit"}, {"oid": "c5e1c5f3b4c3712913efeb6c85647352a32d8c48", "url": "https://github.com/typetools/checker-framework/commit/c5e1c5f3b4c3712913efeb6c85647352a32d8c48", "message": "Add failing test case", "committedDate": "2020-06-16T21:24:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1MzUyNg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r441153526", "bodyText": "Should the remainder of this loop be equivalent to a recursive call to accumulate, just more efficient?\nIf so, could you add a comment to that effect?  (Or maybe even make it a recursive call to accumulate, which will be shorter and simpler code, though a bit less efficient.  If you do that, you can remove the while loop.)", "author": "mernst", "createdAt": "2020-06-16T21:30:02Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue backward as\n+     * long as each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. This method will directly update the estimate of {@code a.b().c()} to\n+     * include \"foo\". In addition, the estimates for the expressions {@code a.b()} and {@code a}\n+     * would have their estimates updated to include \"foo\", because c and b (respectively) return\n+     * their receivers. Note that due to what kind of values can be held in the store, this\n+     * information is lost outside the method chain. That is, the returns-receiver propagated\n+     * information is lost outside the expression in which the returns-receiver method invocations\n+     * are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the\n+     * store does not keep the information that a, b, and c have been called outside the chain.\n+     * {@code foo}'s type will be {@code CalledMethods(\"a\")}, because only {@code a()} was called\n+     * directly on {@code foo}. For such code to typecheck, the Called Methods accumulation checker\n+     * uses an additional rule: the return type of a receiver-returning method {@code rr()} is\n+     * {@code CalledMethods(\"rr\")}. This rule is implemented directly in the {@link\n+     * org.checkerframework.framework.type.treeannotator.TreeAnnotator} subclass defined in the\n+     * Called Methods type factory.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getUnionAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            while (methodInvocationNode != null) {\n+\n+                Node receiver = methodInvocationNode.getTarget().getReceiver();\n+\n+                if (receiver == null || !typeFactory.returnsThis((MethodInvocationTree) tree)) {\n+                    break;\n+                }\n+", "originalCommit": "c5e1c5f3b4c3712913efeb6c85647352a32d8c48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1NDgwNw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r441154807", "bodyText": "This use of newAnno looks wrong to me.  newAnno was computed earlier for a later method call, and if the recursion goes past a non-@This-returning call, then the value should be reset rather than carried across that call.  I added a failing test case, m8, that illustrates incorrect behavior.\nShould the recursion go through non-@This returning methods at all?\nIt is also a bit suspicious that no call of getUnionAnno occurs.  Could you write a comment saying why it is not needed, and it's OK to do complete replacement rather than GLB?", "author": "mernst", "createdAt": "2020-06-16T21:32:57Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue backward as\n+     * long as each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. This method will directly update the estimate of {@code a.b().c()} to\n+     * include \"foo\". In addition, the estimates for the expressions {@code a.b()} and {@code a}\n+     * would have their estimates updated to include \"foo\", because c and b (respectively) return\n+     * their receivers. Note that due to what kind of values can be held in the store, this\n+     * information is lost outside the method chain. That is, the returns-receiver propagated\n+     * information is lost outside the expression in which the returns-receiver method invocations\n+     * are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the\n+     * store does not keep the information that a, b, and c have been called outside the chain.\n+     * {@code foo}'s type will be {@code CalledMethods(\"a\")}, because only {@code a()} was called\n+     * directly on {@code foo}. For such code to typecheck, the Called Methods accumulation checker\n+     * uses an additional rule: the return type of a receiver-returning method {@code rr()} is\n+     * {@code CalledMethods(\"rr\")}. This rule is implemented directly in the {@link\n+     * org.checkerframework.framework.type.treeannotator.TreeAnnotator} subclass defined in the\n+     * Called Methods type factory.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getUnionAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            while (methodInvocationNode != null) {\n+\n+                Node receiver = methodInvocationNode.getTarget().getReceiver();\n+\n+                if (receiver == null || !typeFactory.returnsThis((MethodInvocationTree) tree)) {\n+                    break;\n+                }\n+\n+                // Note that this call doesn't do anything if receiver is a method call\n+                // that is not deterministic, though the code below can still continue to recurse.\n+                // (The code above tested that `tree` returns `this` but did not test `receiver`.)\n+                insertIntoStores(result, receiver, newAnno);", "originalCommit": "c5e1c5f3b4c3712913efeb6c85647352a32d8c48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1b20b2a50022875e66a3e7d2ad1f96520d7d9683", "url": "https://github.com/typetools/checker-framework/commit/1b20b2a50022875e66a3e7d2ad1f96520d7d9683", "message": "rewrite accumulate to be recursive, and to use dataflow facts directly rather than the ATF", "committedDate": "2020-06-16T23:10:17Z", "type": "commit"}, {"oid": "4052ee7f9c681f342a41cfc4c64d56c254732d22", "url": "https://github.com/typetools/checker-framework/commit/4052ee7f9c681f342a41cfc4c64d56c254732d22", "message": "Fix formatting", "committedDate": "2020-06-16T23:49:34Z", "type": "commit"}, {"oid": "cac0323e0495a11957b6a7b441d8a9b37179f496", "url": "https://github.com/typetools/checker-framework/commit/cac0323e0495a11957b6a7b441d8a9b37179f496", "message": "Tweaks", "committedDate": "2020-06-17T00:05:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwOTEwNg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r441209106", "bodyText": "Is this for loop guaranteed to execute exactly 0 or 1 times?  Should it assert that about the size of flowAnnos?  I think that each one must be either the accumulator or bottom; is that correct?  Is that worth verifying?", "author": "mernst", "createdAt": "2020-06-17T00:10:35Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue backward as\n+     * long as each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. This method will directly update the estimate of {@code a.b().c()} to\n+     * include \"foo\". In addition, the estimates for the expressions {@code a.b()} and {@code a}\n+     * would have their estimates updated to include \"foo\", because c and b (respectively) return\n+     * their receivers. Note that due to what kind of values can be held in the store, this\n+     * information is lost outside the method chain. That is, the returns-receiver propagated\n+     * information is lost outside the expression in which the returns-receiver method invocations\n+     * are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the\n+     * store does not keep the information that a, b, and c have been called outside the chain.\n+     * {@code foo}'s type will be {@code CalledMethods(\"a\")}, because only {@code a()} was called\n+     * directly on {@code foo}. For such code to typecheck, the Called Methods accumulation checker\n+     * uses an additional rule: the return type of a receiver-returning method {@code rr()} is\n+     * {@code CalledMethods(\"rr\")}. This rule is implemented directly in the {@link\n+     * org.checkerframework.framework.type.treeannotator.TreeAnnotator} subclass defined in the\n+     * Called Methods type factory.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        List<String> valuesAsList = Arrays.asList(values);\n+        // If dataflow has already recorded information about the target, fetch it and integrate\n+        // it into the list of values in the new annotation.\n+        CFValue flowValue = result.getResultValue();\n+        if (flowValue != null) {\n+            Set<AnnotationMirror> flowAnnos = flowValue.getAnnotations();\n+            for (AnnotationMirror anno : flowAnnos) {", "originalCommit": "cac0323e0495a11957b6a7b441d8a9b37179f496", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTcyMjY0OQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r441722649", "bodyText": "Is this for loop guaranteed to execute exactly 0 or 1 times\n\nYes. I added an assertion.\n\nI think that each one must be either the accumulator or bottom; is that correct?\n\nYes. My original version of this code included a test for it, but it was redundant with checking that the result of the call to getValueOfAnnotationWithStringArgument is non-null, so I removed it.", "author": "kelloggm", "createdAt": "2020-06-17T17:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwOTEwNg=="}], "type": "inlineReview"}, {"oid": "4a3d5c6d9666fd089f3dc20e3548760ac100c71c", "url": "https://github.com/typetools/checker-framework/commit/4a3d5c6d9666fd089f3dc20e3548760ac100c71c", "message": "try to make comment a bit more readable, and add an assertion about the size of the list", "committedDate": "2020-06-17T17:56:54Z", "type": "commit"}, {"oid": "2be3ff9d8e36a87d9c42dad99379e16e5a44002c", "url": "https://github.com/typetools/checker-framework/commit/2be3ff9d8e36a87d9c42dad99379e16e5a44002c", "message": "merge conflict with Mike's fix for the weird formatting", "committedDate": "2020-06-17T17:58:00Z", "type": "commit"}, {"oid": "beffa549428ba139408bb29bcdb899941b33294b", "url": "https://github.com/typetools/checker-framework/commit/beffa549428ba139408bb29bcdb899941b33294b", "message": "Initialization", "committedDate": "2020-03-25T18:16:00Z", "type": "commit"}, {"oid": "9b63699b1dcb6aa74e0913a770a3b4012f774428", "url": "https://github.com/typetools/checker-framework/commit/9b63699b1dcb6aa74e0913a770a3b4012f774428", "message": "resolved comments", "committedDate": "2020-03-26T19:35:59Z", "type": "commit"}, {"oid": "bc4298b92e91330a1c62f162bb32956c2018c756", "url": "https://github.com/typetools/checker-framework/commit/bc4298b92e91330a1c62f162bb32956c2018c756", "message": "resolved comments", "committedDate": "2020-03-26T19:41:34Z", "type": "commit"}, {"oid": "a77dd34f6a7a54defb7a186be322f7d276ece232", "url": "https://github.com/typetools/checker-framework/commit/a77dd34f6a7a54defb7a186be322f7d276ece232", "message": "resolved comments", "committedDate": "2020-03-26T20:01:21Z", "type": "commit"}, {"oid": "71f08dc67b501f0072ec03a27fa3892c4801d3e1", "url": "https://github.com/typetools/checker-framework/commit/71f08dc67b501f0072ec03a27fa3892c4801d3e1", "message": "test git", "committedDate": "2020-03-27T17:17:25Z", "type": "commit"}, {"oid": "f9f9e3fd725fcca36f0a09656fcb771229d4200d", "url": "https://github.com/typetools/checker-framework/commit/f9f9e3fd725fcca36f0a09656fcb771229d4200d", "message": "test git", "committedDate": "2020-03-27T17:20:38Z", "type": "commit"}, {"oid": "4d347ef8e293aa126c4cdf05d8f91e65d50b860e", "url": "https://github.com/typetools/checker-framework/commit/4d347ef8e293aa126c4cdf05d8f91e65d50b860e", "message": "resolved issues and passed git pre-commit hooks", "committedDate": "2020-03-28T02:05:04Z", "type": "commit"}, {"oid": "aa5e28fdd814f8ca415872b2cb13d3282455c2ed", "url": "https://github.com/typetools/checker-framework/commit/aa5e28fdd814f8ca415872b2cb13d3282455c2ed", "message": "fixed issue with checkBasicStyle task", "committedDate": "2020-03-28T05:21:31Z", "type": "commit"}, {"oid": "415adda9cee3ff9ad56a0e6d1f2cd9ce9734366e", "url": "https://github.com/typetools/checker-framework/commit/415adda9cee3ff9ad56a0e6d1f2cd9ce9734366e", "message": "fixed all-test-jdk8 and all-test-jdk11 jobs in pipeline", "committedDate": "2020-03-28T06:36:20Z", "type": "commit"}, {"oid": "91d0d101663a5731c4d4751c9275fef4a6c7f3ea", "url": "https://github.com/typetools/checker-framework/commit/91d0d101663a5731c4d4751c9275fef4a6c7f3ea", "message": "git test", "committedDate": "2020-03-28T06:50:42Z", "type": "commit"}, {"oid": "e005df3b5c841dbe272b502dc07bab3d2a41af98", "url": "https://github.com/typetools/checker-framework/commit/e005df3b5c841dbe272b502dc07bab3d2a41af98", "message": "fixed checkInterning task", "committedDate": "2020-03-28T07:37:32Z", "type": "commit"}, {"oid": "7690604d845c8331ce3e03232f192a5525f601b6", "url": "https://github.com/typetools/checker-framework/commit/7690604d845c8331ce3e03232f192a5525f601b6", "message": "misc_jdk8", "committedDate": "2020-03-28T08:27:05Z", "type": "commit"}, {"oid": "b98126aa8349b0b61f00841a2bc6f7f6e4d56dc0", "url": "https://github.com/typetools/checker-framework/commit/b98126aa8349b0b61f00841a2bc6f7f6e4d56dc0", "message": "misc_jdk8", "committedDate": "2020-03-28T08:39:37Z", "type": "commit"}, {"oid": "27843ff602ba06a52db49498675e3be561fa1828", "url": "https://github.com/typetools/checker-framework/commit/27843ff602ba06a52db49498675e3be561fa1828", "message": "Merge branch 'master' into returnsrcvr-checker", "committedDate": "2020-03-28T19:08:15Z", "type": "commit"}, {"oid": "5b27d78bfe2a9a74d570a2eac2865b19a5724fad", "url": "https://github.com/typetools/checker-framework/commit/5b27d78bfe2a9a74d570a2eac2865b19a5724fad", "message": "fix javadoc", "committedDate": "2020-03-28T19:17:38Z", "type": "commit"}, {"oid": "8b9f5f03bc186fb0cf0629eb44745ffb90f21346", "url": "https://github.com/typetools/checker-framework/commit/8b9f5f03bc186fb0cf0629eb44745ffb90f21346", "message": "returns receiver manual", "committedDate": "2020-03-28T21:33:17Z", "type": "commit"}, {"oid": "ed02ca65fd427780a729589976818098433543f1", "url": "https://github.com/typetools/checker-framework/commit/ed02ca65fd427780a729589976818098433543f1", "message": "trailing whitespace", "committedDate": "2020-03-28T21:34:03Z", "type": "commit"}, {"oid": "9b5171fe0730113b1248680c19a97e5c3c75c953", "url": "https://github.com/typetools/checker-framework/commit/9b5171fe0730113b1248680c19a97e5c3c75c953", "message": "Add final newline", "committedDate": "2020-03-29T00:28:07Z", "type": "commit"}, {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "url": "https://github.com/typetools/checker-framework/commit/5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "message": "Capitalization fixes", "committedDate": "2020-03-29T00:37:00Z", "type": "commit"}, {"oid": "f4532df793fc199e7a440efa35c3051b0abc2e6b", "url": "https://github.com/typetools/checker-framework/commit/f4532df793fc199e7a440efa35c3051b0abc2e6b", "message": "Improve naming.  Make switch statements report errors.", "committedDate": "2020-03-29T15:24:30Z", "type": "commit"}, {"oid": "ce4f098f11080d20257088603aae6c1b4a23bc51", "url": "https://github.com/typetools/checker-framework/commit/ce4f098f11080d20257088603aae6c1b4a23bc51", "message": "Remove unnecessary text", "committedDate": "2020-03-29T15:41:40Z", "type": "commit"}, {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5", "url": "https://github.com/typetools/checker-framework/commit/eff17315021c4d2899189b30c6a25149548d5fe5", "message": "Improve naming", "committedDate": "2020-03-29T15:41:54Z", "type": "commit"}, {"oid": "d13fe35aeee5b038c375da84e9377835b2dd5a84", "url": "https://github.com/typetools/checker-framework/commit/d13fe35aeee5b038c375da84e9377835b2dd5a84", "message": "Fixed contructor throw RuntimeException and javadoc", "committedDate": "2020-03-30T16:24:48Z", "type": "commit"}, {"oid": "fd8c8609a4541267ce05fe26dd3ec335a2823ea4", "url": "https://github.com/typetools/checker-framework/commit/fd8c8609a4541267ce05fe26dd3ec335a2823ea4", "message": "fix misc-jdk8 and misc-jdk11", "committedDate": "2020-03-30T19:33:55Z", "type": "commit"}, {"oid": "85682f77cf4b561fb948799f672369f9238d2fd3", "url": "https://github.com/typetools/checker-framework/commit/85682f77cf4b561fb948799f672369f9238d2fd3", "message": "working on manual", "committedDate": "2020-04-01T17:28:07Z", "type": "commit"}, {"oid": "f897ece84d1d0742df8a5d44218f975ff0a800c0", "url": "https://github.com/typetools/checker-framework/commit/f897ece84d1d0742df8a5d44218f975ff0a800c0", "message": "pass on manual", "committedDate": "2020-04-01T17:38:52Z", "type": "commit"}, {"oid": "2c326d568f2b94e6e3417c27fefac8ad955dab9b", "url": "https://github.com/typetools/checker-framework/commit/2c326d568f2b94e6e3417c27fefac8ad955dab9b", "message": "changed framework support to enums", "committedDate": "2020-04-01T17:41:45Z", "type": "commit"}, {"oid": "65e4454b2d36b6e9a6809ba9b1b2cbadb83aabfd", "url": "https://github.com/typetools/checker-framework/commit/65e4454b2d36b6e9a6809ba9b1b2cbadb83aabfd", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker", "committedDate": "2020-04-01T17:42:00Z", "type": "commit"}, {"oid": "748a84c18498ee263accd07d5107af4927db474d", "url": "https://github.com/typetools/checker-framework/commit/748a84c18498ee263accd07d5107af4927db474d", "message": "remove paragraph on disabling framework support", "committedDate": "2020-04-01T17:50:09Z", "type": "commit"}, {"oid": "30c2d5eb1b0ae317c00bdd89d8fb5c96299d4d34", "url": "https://github.com/typetools/checker-framework/commit/30c2d5eb1b0ae317c00bdd89d8fb5c96299d4d34", "message": "Merge branch 'master' into returnsrcvr-checker", "committedDate": "2020-04-01T21:10:47Z", "type": "commit"}, {"oid": "d1c028fade3062f9cba9fbb3019984ca38b30171", "url": "https://github.com/typetools/checker-framework/commit/d1c028fade3062f9cba9fbb3019984ca38b30171", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker", "committedDate": "2020-04-02T01:13:35Z", "type": "commit"}, {"oid": "482809a6694b522ffd7c97ca7676a5db936c4866", "url": "https://github.com/typetools/checker-framework/commit/482809a6694b522ffd7c97ca7676a5db936c4866", "message": "Rename MaybeThis to UnknownThis.\n\nThe name MaybeThis isn't bad, but the rest of the Checker Framework uses\nthe naming convention \"Unknown\" for the top type.", "committedDate": "2020-04-02T01:28:44Z", "type": "commit"}, {"oid": "cc7a321c3c288e4e3a377edf683fe8f0559b6026", "url": "https://github.com/typetools/checker-framework/commit/cc7a321c3c288e4e3a377edf683fe8f0559b6026", "message": "Improve Javadoc: add explanations, examples, links", "committedDate": "2020-04-02T01:51:44Z", "type": "commit"}, {"oid": "cf31b932ea22fb758a113f144732cb39bdab46fa", "url": "https://github.com/typetools/checker-framework/commit/cf31b932ea22fb758a113f144732cb39bdab46fa", "message": "Edits to manual section", "committedDate": "2020-04-02T02:17:57Z", "type": "commit"}, {"oid": "b8e6b7290aad40d59affcf1e0e2113be79188368", "url": "https://github.com/typetools/checker-framework/commit/b8e6b7290aad40d59affcf1e0e2113be79188368", "message": "Mention terminology \"fluent API\"", "committedDate": "2020-04-02T02:19:05Z", "type": "commit"}, {"oid": "941d35b64856461dca9c5ae04b253f3f9ec66b4e", "url": "https://github.com/typetools/checker-framework/commit/941d35b64856461dca9c5ae04b253f3f9ec66b4e", "message": "Tweak message", "committedDate": "2020-04-02T03:56:38Z", "type": "commit"}, {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "url": "https://github.com/typetools/checker-framework/commit/daafb8f1937dcf9ba1c78f58a69a675465cc62be", "message": "Edits from code review", "committedDate": "2020-04-02T05:19:49Z", "type": "commit"}, {"oid": "fa3c48b363b6f243f9a98ccf356324f8f9d1cdae", "url": "https://github.com/typetools/checker-framework/commit/fa3c48b363b6f243f9a98ccf356324f8f9d1cdae", "message": "Update changelog", "committedDate": "2020-04-02T19:28:31Z", "type": "commit"}, {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "url": "https://github.com/typetools/checker-framework/commit/84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "message": "removed frameworkSupport Interface and resolved comments", "committedDate": "2020-04-03T07:28:13Z", "type": "commit"}, {"oid": "acfb71a082e2aa5ed579bcad04447d36be7ef724", "url": "https://github.com/typetools/checker-framework/commit/acfb71a082e2aa5ed579bcad04447d36be7ef724", "message": "Don't replace existing annotations.", "committedDate": "2020-04-05T18:20:05Z", "type": "commit"}, {"oid": "d7baf84d2ae3a3ffa40f1df39ff5215f7206ccf0", "url": "https://github.com/typetools/checker-framework/commit/d7baf84d2ae3a3ffa40f1df39ff5215f7206ccf0", "message": "fix misc_jdk8", "committedDate": "2020-04-06T02:20:13Z", "type": "commit"}, {"oid": "b51b9199f33112538d3ecad583c7934248b13495", "url": "https://github.com/typetools/checker-framework/commit/b51b9199f33112538d3ecad583c7934248b13495", "message": "removed FrameworkSupportUtils", "committedDate": "2020-04-06T23:24:54Z", "type": "commit"}, {"oid": "71b5578d5cff91a4a1553eb2ed5a14dc671c9795", "url": "https://github.com/typetools/checker-framework/commit/71b5578d5cff91a4a1553eb2ed5a14dc671c9795", "message": "removed dependecies to AutoValue", "committedDate": "2020-04-07T01:36:46Z", "type": "commit"}, {"oid": "606a7a14aee1fe93c4c80fee489df5a8f7d290e7", "url": "https://github.com/typetools/checker-framework/commit/606a7a14aee1fe93c4c80fee489df5a8f7d290e7", "message": "clean up some logic in type factory", "committedDate": "2020-04-07T03:46:33Z", "type": "commit"}, {"oid": "1d1edad52a2a714e186296fa82a25dac118d6cd1", "url": "https://github.com/typetools/checker-framework/commit/1d1edad52a2a714e186296fa82a25dac118d6cd1", "message": "partial work", "committedDate": "2020-04-09T22:52:48Z", "type": "commit"}, {"oid": "231bf447bc4d9ffd81a0aef529e1c7b6d1888d13", "url": "https://github.com/typetools/checker-framework/commit/231bf447bc4d9ffd81a0aef529e1c7b6d1888d13", "message": "use the merged version of the RR checker", "committedDate": "2020-05-01T00:15:06Z", "type": "commit"}, {"oid": "6bc521df9a9666ecbc866d17b680910b282f41d3", "url": "https://github.com/typetools/checker-framework/commit/6bc521df9a9666ecbc866d17b680910b282f41d3", "message": "basic testing infrastructure", "committedDate": "2020-05-01T00:50:50Z", "type": "commit"}, {"oid": "943996c9d0efb55aaeb35b1a86adb96b64ae1232", "url": "https://github.com/typetools/checker-framework/commit/943996c9d0efb55aaeb35b1a86adb96b64ae1232", "message": "add another test case that checks that RR support works as intended", "committedDate": "2020-05-12T00:02:53Z", "type": "commit"}, {"oid": "0840bf3f8e7b1008f192a44050528534e2ba7579", "url": "https://github.com/typetools/checker-framework/commit/0840bf3f8e7b1008f192a44050528534e2ba7579", "message": "add all remaining basic OCC tests that are relevant to a general accumulation analysis", "committedDate": "2020-05-12T20:41:34Z", "type": "commit"}, {"oid": "946d6d6442adb8e41b4780fb399f69c181c21dde", "url": "https://github.com/typetools/checker-framework/commit/946d6d6442adb8e41b4780fb399f69c181c21dde", "message": "add docs and remove debugging code", "committedDate": "2020-05-12T21:33:10Z", "type": "commit"}, {"oid": "d03694e66f8863db5bd150ebfebd2436c8cb3db8", "url": "https://github.com/typetools/checker-framework/commit/d03694e66f8863db5bd150ebfebd2436c8cb3db8", "message": "actually test the accumulate method, too, by making the test checker a very simple CM checker", "committedDate": "2020-05-12T21:51:13Z", "type": "commit"}, {"oid": "47920cd0e14c09689718a15200c218b570b41772", "url": "https://github.com/typetools/checker-framework/commit/47920cd0e14c09689718a15200c218b570b41772", "message": "remove code that should have been deleted", "committedDate": "2020-05-12T21:57:07Z", "type": "commit"}, {"oid": "ca07011fcb0544d27a221921381fc9e870e8767f", "url": "https://github.com/typetools/checker-framework/commit/ca07011fcb0544d27a221921381fc9e870e8767f", "message": "more docs, make Accumulation ATF constructor protected", "committedDate": "2020-05-12T22:00:57Z", "type": "commit"}, {"oid": "8f723f6a609bf94a472189b3a9062c82686564f0", "url": "https://github.com/typetools/checker-framework/commit/8f723f6a609bf94a472189b3a9062c82686564f0", "message": "add all-systems tests", "committedDate": "2020-05-12T22:02:20Z", "type": "commit"}, {"oid": "aa7dc292d3d8f72e0158d3394d24f0467afd81e8", "url": "https://github.com/typetools/checker-framework/commit/aa7dc292d3d8f72e0158d3394d24f0467afd81e8", "message": "Merge ../checker-framework-branch-master into accumulation-analysis", "committedDate": "2020-05-12T22:59:12Z", "type": "commit"}, {"oid": "cabfb0dfd9d462bd9f13c00615e6bc9ab22e9e9a", "url": "https://github.com/typetools/checker-framework/commit/cabfb0dfd9d462bd9f13c00615e6bc9ab22e9e9a", "message": "use Java 8 syntax", "committedDate": "2020-05-13T17:26:10Z", "type": "commit"}, {"oid": "eb4c0fbd7f797d4dcbca64f78c51f24e1495407d", "url": "https://github.com/typetools/checker-framework/commit/eb4c0fbd7f797d4dcbca64f78c51f24e1495407d", "message": "Merge branch 'accumulation-analysis' of github.com:kelloggm/checker-framework into accumulation-analysis", "committedDate": "2020-05-13T17:26:36Z", "type": "commit"}, {"oid": "da1ab9cbc6fb159908c68a87acfd79caa4ff3835", "url": "https://github.com/typetools/checker-framework/commit/da1ab9cbc6fb159908c68a87acfd79caa4ff3835", "message": "add draft of manual section for building an accumulation checker", "committedDate": "2020-05-13T18:17:05Z", "type": "commit"}, {"oid": "16d5df6a2d08fb499909ea642a8c77d0f4ccf114", "url": "https://github.com/typetools/checker-framework/commit/16d5df6a2d08fb499909ea642a8c77d0f4ccf114", "message": "fix EP warning", "committedDate": "2020-05-13T18:55:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4NzYyMQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424687621", "bodyText": "with -> has", "author": "msridhar", "createdAt": "2020-05-13T19:43:20Z", "path": "docs/manual/accumulation-checker.tex", "diffHunk": "@@ -0,0 +1,80 @@\n+\\htmlhr\n+\\chapterAndLabel{Building an accumulation checker}{accumulation-checker}\n+\n+%% This chapter should appear after the \"creating a checker\" chapter, or perhaps as part of it,\n+%% once accumulation support is complete.\n+\n+This chapter describes how to build a particular kind of checker---an accumulation\n+checker. If you want to \\emph{use} an existing checker, you do not need to read this chapter.\n+\n+An \\emph{accumulation analysis} is a program analysis where the\n+analysis abstraction is a monotonically increasing set, and some operation is legal\n+only when the set is large enough---that is, the estimate has accumulated\n+sufficiently many items.\n+Accumulation analysis is a special case of typestate analysis in which\n+(1) the order in which operations are performed does not affect what is subsequently legal,\n+and (2) the accumulation does not add restrictions; that is, as\n+more operations are performed, more operations become legal.\n+\n+Unlike a traditional typestate analysis, an accumulation analysis does\n+not require an alias analysis for soundness. It can therefore be implemented\n+as a flow-sensitive type system.\n+\n+The Checker Framework contains a generic accumulation analysis that can\n+be extended to implement any particular accumulation analysis. We refer to\n+such an extension as an \"accumulation checker\" in this chapter.\n+\n+Before reading the rest of this chapter, you should\n+read the section on creating a checker (Chapter~\\ref{creating-a-checker}).\n+The rest of this chapter assumes you have done so.\n+\n+\\paragraphAndLabel{Defining type qualifiers}{accumulation-qualifiers}\n+\n+The first step in building an accumulation checker is to decide what it is\n+your checker will accumulate, and how to represent it. The Checker Framework's\n+support for accumulation analysis requires you to accumulate a string representation\n+of whatever you are accumulating. For example, when accumulating which methods have\n+been called on an object, you might choose to accumulate method names.\n+\n+Define a type qualifier that with a single argument: a \\<String[]> named \\<value>.", "originalCommit": "16d5df6a2d08fb499909ea642a8c77d0f4ccf114", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4OTIwMA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424689200", "bodyText": "FWIW I can't really read this lattice.  Is this a standard notation?", "author": "msridhar", "createdAt": "2020-05-13T19:46:24Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement their own version of the\n+ * constructor, which should take a {@link BaseTypeChecker} and pass constants for the annotation\n+ * classes required by the constructor defined in this class.\n+ *\n+ * <p>New subclasses must also call {@link #postInit()} in their constructors.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top and bottom annotations for this accumulation checker. */\n+    public final AnnotationMirror TOP, BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create a new accumulation checker's annotated type factory.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param t the top type in the hierarchy\n+     * @param bot the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> t,\n+            Class<? extends Annotation> bot) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, t);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bot);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with values's arguments,\n+     *     or top is {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Utility method that returns whether the return type of the given method invocation tree has\n+     * an @This annotation from the Returns Receiver Checker.\n+     *\n+     * @param tree the method invocation tree to check\n+     * @return whether the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return whether the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            // Check to see if the ReturnsReceiver Checker has a @This annotation\n+            // on the return type of the method.\n+            if (returnsThis(tree)) {\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <p>top / \\ acc(x) acc(y) ... \\ / acc(x,y) ... | bottom", "originalCommit": "16d5df6a2d08fb499909ea642a8c77d0f4ccf114", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxNzA1Mg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424717052", "bodyText": "The formatter messed this up. Sorry about that.", "author": "kelloggm", "createdAt": "2020-05-13T20:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4OTIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4OTkzOA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424689938", "bodyText": "Is it possible someone might want to build an accumulation checker that does not require returns-receiver reasoning?  Or shall we just assume any accumulation checker is also dealing with fluent APIs?", "author": "msridhar", "createdAt": "2020-05-13T19:47:47Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationChecker.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.checkerframework.common.accumulation;\n+\n+import java.util.LinkedHashSet;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+\n+/**\n+ * An accumulation checker is one that accumulates some property: method calls, keys into maps, etc.\n+ * All accumulation analyses share some common features: their type systems are similar in\n+ * structure, they need to reason about fluent APIs, and they need some way to easily add facts to\n+ * the accumulation they are tracking. This accumulation analysis represents all facts as Strings.\n+ *\n+ * <p>Accumulation checkers are particularly interesting because they can represent many\n+ * typestate-like properties, but do not require a precise alias analysis for soundness.\n+ *\n+ * <p>This class provides a basic accumulation checker that can be extended to implement a\n+ * particular accumulation type system. The primary extension point is the constructor of {@link\n+ * AccumulationAnnotatedTypeFactory}, which every subclass should override to provide custom\n+ * annotations.\n+ */\n+public abstract class AccumulationChecker extends BaseTypeChecker {\n+\n+    @Override\n+    protected LinkedHashSet<Class<? extends BaseTypeChecker>> getImmediateSubcheckerClasses() {\n+        LinkedHashSet<Class<? extends BaseTypeChecker>> checkers =\n+                super.getImmediateSubcheckerClasses();\n+        checkers.add(ReturnsReceiverChecker.class);", "originalCommit": "16d5df6a2d08fb499909ea642a8c77d0f4ccf114", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcyMDE0Ng==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424720146", "bodyText": "I assumed that anyone building an accumulation checker would want RR reasoning - there's not much reason to not include it. I suppose we could make it configurable, somehow (but then again, it already is - someone who didn't want the RR checker could override this method again!).\nI'll add something to the javadoc that mentions it.", "author": "kelloggm", "createdAt": "2020-05-13T20:45:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4OTkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcyOTc2NQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424729765", "bodyText": "There is the whole including a sub-checker doubles the overall checking time issue... \ud83d\ude42But this is fine for now", "author": "msridhar", "createdAt": "2020-05-13T21:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4OTkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5MDYzMA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424690630", "bodyText": "This will only be true if methods b and c are deterministic.  If they are not, only the estimate of a will be updated, and the types of a.b() and a.b().c() are computed in the type factory.  We should update the documentation to be clearer about this", "author": "msridhar", "createdAt": "2020-05-13T19:49:05Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things node has accumulated to include all the values.\n+     *\n+     * @param node the node whose estimate should be adjusted\n+     * @param result the result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",", "originalCommit": "16d5df6a2d08fb499909ea642a8c77d0f4ccf114", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5MzI5Ng==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424693296", "bodyText": "As noted above, this call will do nothing when receiver is a method call that is not deterministic.  Not sure if we should change the implementation logic to reflect this more clearly.  Nothing incorrect happens now, but it may confuse future readers of the code", "author": "msridhar", "createdAt": "2020-05-13T19:53:53Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things node has accumulated to include all the values.\n+     *\n+     * @param node the node whose estimate should be adjusted\n+     * @param result the result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",\n+     * and b and c return their receiver, all of the expressions {@code a}, {@code a.b()}, and\n+     * {@code a.b().c()} would have their estimates updated to include \"foo\".\n+     *\n+     * @param node a method invocation whose receiver is to be updated\n+     * @param result the result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(\n+            MethodInvocationNode node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Node receiver = node.getTarget().getReceiver();\n+        AnnotatedTypeMirror oldType = typeFactory.getReceiverType(node.getTree());\n+        // e.g. if the node being visited is static\n+        if (oldType == null) {\n+            return;\n+        }\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        while (receiver != null) {\n+            insertIntoStores(result, receiver, newAnno);", "originalCommit": "16d5df6a2d08fb499909ea642a8c77d0f4ccf114", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "354ac0da65ffa956127454bd0e3308aee249838b", "url": "https://github.com/typetools/checker-framework/commit/354ac0da65ffa956127454bd0e3308aee249838b", "message": "some javadoc that I missed before", "committedDate": "2020-05-13T19:55:45Z", "type": "commit"}, {"oid": "2f81727d201bb9335f6992609dc89777f8c783c2", "url": "https://github.com/typetools/checker-framework/commit/2f81727d201bb9335f6992609dc89777f8c783c2", "message": "address some code review comments", "committedDate": "2020-05-13T20:54:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczMTA2Mg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424731062", "bodyText": "Can we add a bit more detail on what this tree annotator is actually doing?  Like the example we give in the transfer function documentation.  This can be in the class documentation or the docs of visitMethodInvocation().", "author": "msridhar", "createdAt": "2020-05-13T21:06:31Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,288 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement their own version of the\n+ * constructor, which should take a {@link BaseTypeChecker} and pass constants for the annotation\n+ * classes required by the constructor defined in this class.\n+ *\n+ * <p>New subclasses must also call {@link #postInit()} in their constructors.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top and bottom annotations for this accumulation checker. */\n+    public final AnnotationMirror TOP, BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create a new accumulation checker's annotated type factory.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param t the top type in the hierarchy\n+     * @param bot the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> t,\n+            Class<? extends Annotation> bot) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, t);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bot);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with values's arguments,\n+     *     or top is {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Utility method that returns whether the return type of the given method invocation tree has\n+     * an @This annotation from the Returns Receiver Checker.\n+     *\n+     * @param tree the method invocation tree to check\n+     * @return whether the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return whether the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */", "originalCommit": "2f81727d201bb9335f6992609dc89777f8c783c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI2MzEwMA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r425263100", "bodyText": "I added it to the docs for getMethodInvocation()", "author": "kelloggm", "createdAt": "2020-05-14T16:18:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczMTA2Mg=="}], "type": "inlineReview"}, {"oid": "02bba698cb153df0a4a4d47d30862e7445edad44", "url": "https://github.com/typetools/checker-framework/commit/02bba698cb153df0a4a4d47d30862e7445edad44", "message": "improve docs on the tree annotator", "committedDate": "2020-05-14T16:19:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI2NTM0MA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r425265340", "bodyText": "Wait, isn't the point that this annotator takes the receiver type and \"accumulates in\" the current method invocation?", "author": "msridhar", "createdAt": "2020-05-14T16:21:28Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -135,6 +135,14 @@ public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n             super(factory);\n         }\n \n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the", "originalCommit": "02bba698cb153df0a4a4d47d30862e7445edad44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI5MjA2Nw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r425292067", "bodyText": "Only the Object Construction Checker does that. This version is simpler - all it does it make the return type match the receiver type if the method returns this. The TestAccumulationChecker handles actually accumulating method calls differently than the OCC, also - note that it does the actual accumulation in the Transfer class.", "author": "kelloggm", "createdAt": "2020-05-14T16:59:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI2NTM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI5NzExMA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r425297110", "bodyText": "I get it now.  Since the transfer function computes the complete accumulated type for the most deeply-nested receiver, all the type factory has to do is to copy that type to the return value for each call and it will get bubbled up.", "author": "msridhar", "createdAt": "2020-05-14T17:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI2NTM0MA=="}], "type": "inlineReview"}, {"oid": "01cde05dbdf07f3202cb535b83de44e590435939", "url": "https://github.com/typetools/checker-framework/commit/01cde05dbdf07f3202cb535b83de44e590435939", "message": "Merge ../checker-framework-branch-master into accumulation-analysis", "committedDate": "2020-05-15T16:59:19Z", "type": "commit"}, {"oid": "48b0bc06b3447299ccf73bd01605d00b28807341", "url": "https://github.com/typetools/checker-framework/commit/48b0bc06b3447299ccf73bd01605d00b28807341", "message": "Edits to manual", "committedDate": "2020-05-15T17:36:12Z", "type": "commit"}, {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "url": "https://github.com/typetools/checker-framework/commit/1db3bcf35ce34724fbb2f868601ab10f198ead13", "message": "Changes from code review", "committedDate": "2020-05-15T19:26:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwOTc1OQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426009759", "bodyText": "What are the requirements for top and bottom?\n\nMust they be instances of accumulator?  If top must be, I don't see the point of passing it explicitly.\nMust they be distinct from accumulator?\nMust they have a value field of String[] type?  The code seems to assume that top does, but I wonder if that assumption is warranted.", "author": "mernst", "createdAt": "2020-05-15T19:38:48Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDU1Nw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426010557", "bodyText": "values is used/aliased without being copied.  That can be OK, but is worth documenting (or changing if it is not an intended part of the design).", "author": "mernst", "createdAt": "2020-05-15T19:40:34Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2NTg1Nw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426065857", "bodyText": "I think that is only the case if an explicit array is passed. I added a note to the documentation.", "author": "kelloggm", "createdAt": "2020-05-15T22:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDY5NA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426010694", "bodyText": "How about abstracting this into a field, to slightly improve efficiency?", "author": "mernst", "createdAt": "2020-05-15T19:40:53Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2NjY2NQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426066665", "bodyText": "AnnotatedTypeFactories must not put subchecker type factories into fields. I have learned this the hard way before. In many other checkers, I've created a getSpecificSubchecker() method for each subchecker, but I didn't think that was really necessary here. See the documentation for getTypeFactoryOfSubchecker(): https://github.com/typetools/checker-framework/blob/master/framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java#L1585", "author": "kelloggm", "createdAt": "2020-05-15T22:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTAyOQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426011029", "bodyText": "How is this related to TOP and BOTTOM?  Is it definitely true of TOP, or only possibly true?  Is it definitely false of BOTTOM?", "author": "mernst", "createdAt": "2020-05-15T19:41:40Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2NjkzNg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426066936", "bodyText": "It is definitely false of both. I think the documentation is clear, with the changes I've made elsewhere to make clear that the top, bottom, and accumulator annotations are expected to be distinct.", "author": "kelloggm", "createdAt": "2020-05-15T22:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTE1OQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426011159", "bodyText": "Please use a more specific verb than \"handles\".", "author": "mernst", "createdAt": "2020-05-15T19:42:00Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTI1OQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426011259", "bodyText": "What does \"Mandatory\" mean here?", "author": "mernst", "createdAt": "2020-05-15T19:42:12Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2NzkwOQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426067909", "bodyText": "Java requires you to write a constructor for classes that don't have a default constructor. It is therefore \"mandatory\" to write one. More to the point, there's nothing to say about this constructor - it just calls super - but Javadoc is required. I never know what to write in these cases, so I write something inane to satisfy the checker.", "author": "kelloggm", "createdAt": "2020-05-15T22:07:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTYxMg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426011612", "bodyText": "This comment may be true, but it doesn't say what the method does.  should it be \"... then give a method invocation the same type as the receiver\"?", "author": "mernst", "createdAt": "2020-05-15T19:42:58Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2ODA5NQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426068095", "bodyText": "I removed the comment on the method, and moved this into a list of the rules the annotator is responsible for implementing.", "author": "kelloggm", "createdAt": "2020-05-15T22:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTk4NQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426011985", "bodyText": "\"i.e.\" implies they are the same.  They are .equals(), but not ==, I think:  the side effects won't affect the invoked method.", "author": "mernst", "createdAt": "2020-05-15T19:43:45Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMjI2Ng==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426012266", "bodyText": "The comment about the return type of the invorked method is not true for polymorphic methods.", "author": "mernst", "createdAt": "2020-05-15T19:44:27Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMjkzNA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426012934", "bodyText": "I have a strong negative reaction to assignments within conditionals.\n\nThey are surprising and therefore liable to be overlooked or misinterpreted, especially given that \"=\" is a mathematical symbol for equality.\nThey are hard to reason about.\n\nPlease rewrite this code to avoid assignments within conditionals.", "author": "mernst", "createdAt": "2020-05-15T19:45:51Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2OTgzNg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426069836", "bodyText": "This particular code snippet is hard to read either way, and using an assignment within a conditional less verbose. Nevertheless, I've changed it to comply with the Checker Framework's typical code style, because an assignment within a conditional will be more confusing if they are not commonly used in a particular code base.", "author": "kelloggm", "createdAt": "2020-05-15T22:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMjkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMzUzNw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426013537", "bodyText": "I am concerned about this call.  It is possible that receiverAnno is higher in the hierarchy than type, and so this would move the type up in the hierarchy (and override the method specification) rather than refining it.  Should this be GLB instead?", "author": "mernst", "createdAt": "2020-05-15T19:47:07Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3MDExMQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426070111", "bodyText": "Good catch!", "author": "kelloggm", "createdAt": "2020-05-15T22:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMzUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMzg2Mw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426013863", "bodyText": "top is either identical to, or equivalent in the type hierarchy to, acc().  So I would add \"= acc()\" here.", "author": "mernst", "createdAt": "2020-05-15T19:47:49Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *       top", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNDk2Ng==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426014966", "bodyText": "This is assumes that TOP has no value field, or might have no value field.\nThat's rather subtle.  To make this (and other) code easier to read, please create a method isTop and use it.", "author": "mernst", "createdAt": "2020-05-15T19:50:14Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *       top\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return TOP;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM) || AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return BOTTOM;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNjY5OQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426016699", "bodyText": "The use of LinkedHashSet seems pointless here, because a1Val will be in the wrong order afterward -- and anyway, createAccumulatorAnnotation always sorts its argument.\nHow about one of these?\n\nmake a1Val a TreeSet\nmake a1Val a LinkedList and instead of doing addAll, do a mergesort merge step?  That can be done efficiently in O(n) time.\n\nWith either of these approaches, you can have a private createAccumulatorAnnotationFromSorted routine that takes a sorted list and doesn't need to call sort.", "author": "mernst", "createdAt": "2020-05-15T19:54:00Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *       top\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return TOP;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM) || AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return BOTTOM;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NTIxOQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426075219", "bodyText": "With either of these approaches, you can have a private createAccumulatorAnnotationFromSorted routine that takes a sorted list and doesn't need to call sort.\n\nI don't think this is a good idea. Arrays#sort is extremely optimized, and isn't going to spend very long to verify that an input array is sorted (O(n)) time, especially with such small arrays. I would prefer the safety of guaranteeing that the values of accumulator annotations are always sorted, even in the presence of bugs in the implementation, to the (extremely small) speedup you're proposing.", "author": "kelloggm", "createdAt": "2020-05-15T22:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNjY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA4MjE3OQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426082179", "bodyText": "To follow up on this, I just looked through how the Value Checker handles subtyping, etc. between @StringVal annotations, and I'm going to do the same thing here. It uses List rather than converting to sets in the QualifierHierarchy, and sorts and removes at the same time by converting to a TreeSet and back in the method that produces new StringVal annotations.", "author": "kelloggm", "createdAt": "2020-05-15T23:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNjY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNzcyMw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426017723", "bodyText": "This does not have to be a LinkedHashSet.  A HashSet will give the same results.  Though with a LinkedHashSet (or just a LinkedList for both variables is more efficient), you can do an O(n) instead of O(n log n) pass to remove duplicates, and then call a createAccumulatorAnnotationFromSorted routine to avoid subsequent calls to sort.\n(More generally, it seems the code is trying to retain order to reduce the need for sorting, but then it does not take advantage of that (except insofar as sort may run faster on a partially-sorted array).", "author": "mernst", "createdAt": "2020-05-15T19:56:20Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *       top\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return TOP;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM) || AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return BOTTOM;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2));\n+                a1Val.addAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val.toArray(new String[0]));\n+            } else {\n+                return BOTTOM;\n+            }\n+        }\n+\n+        /**\n+         * LUB in this type system is set intersection of the arguments of the two annotations,\n+         * unless one of them is bottom, in which case the result is the other annotation.\n+         */\n+        @Override\n+        public AnnotationMirror leastUpperBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM)) {\n+                return a2;\n+            } else if (AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return a1;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxODE4Mw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426018183", "bodyText": "This uses a different test for top than !AnnotationUtils.hasElementValue(a1, \"value\") above.  Abstract it out into a method call, throughout.", "author": "mernst", "createdAt": "2020-05-15T19:57:23Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *       top\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return TOP;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM) || AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return BOTTOM;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2));\n+                a1Val.addAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val.toArray(new String[0]));\n+            } else {\n+                return BOTTOM;\n+            }\n+        }\n+\n+        /**\n+         * LUB in this type system is set intersection of the arguments of the two annotations,\n+         * unless one of them is bottom, in which case the result is the other annotation.\n+         */\n+        @Override\n+        public AnnotationMirror leastUpperBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM)) {\n+                return a2;\n+            } else if (AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return a1;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2));\n+                a1Val.retainAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val.toArray(new String[0]));\n+            } else {\n+                return TOP;\n+            }\n+        }\n+\n+        /** isSubtype in this type system is subset. */\n+        @Override\n+        public boolean isSubtype(final AnnotationMirror subAnno, final AnnotationMirror superAnno) {\n+            if (AnnotationUtils.areSame(subAnno, BOTTOM)) {\n+                return true;\n+            }\n+            if (AnnotationUtils.areSame(superAnno, BOTTOM)) {\n+                return false;\n+            }\n+\n+            if (AnnotationUtils.areSame(superAnno, TOP)) {", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NzU1OA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426077558", "bodyText": "For consistency with how bottom is tested here and throughout, I changed all the checks for top to this one. I don't see the point of another procedure call that is just a wrapper for this call to AnnotationUtils#areSame", "author": "kelloggm", "createdAt": "2020-05-15T22:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxODE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxODUzOQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426018539", "bodyText": "Since both lists are sorted, this can use an O(n) algorithm rather than the O(n^2) algorithm in List.containsAll.", "author": "mernst", "createdAt": "2020-05-15T19:58:13Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *       top\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return TOP;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM) || AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return BOTTOM;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2));\n+                a1Val.addAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val.toArray(new String[0]));\n+            } else {\n+                return BOTTOM;\n+            }\n+        }\n+\n+        /**\n+         * LUB in this type system is set intersection of the arguments of the two annotations,\n+         * unless one of them is bottom, in which case the result is the other annotation.\n+         */\n+        @Override\n+        public AnnotationMirror leastUpperBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM)) {\n+                return a2;\n+            } else if (AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return a1;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2));\n+                a1Val.retainAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val.toArray(new String[0]));\n+            } else {\n+                return TOP;\n+            }\n+        }\n+\n+        /** isSubtype in this type system is subset. */\n+        @Override\n+        public boolean isSubtype(final AnnotationMirror subAnno, final AnnotationMirror superAnno) {\n+            if (AnnotationUtils.areSame(subAnno, BOTTOM)) {\n+                return true;\n+            }\n+            if (AnnotationUtils.areSame(superAnno, BOTTOM)) {\n+                return false;\n+            }\n+\n+            if (AnnotationUtils.areSame(superAnno, TOP)) {\n+                return true;\n+            }\n+            if (AnnotationUtils.areSame(subAnno, TOP)) {\n+                return false;\n+            }\n+\n+            List<String> subVal = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(subAnno);\n+            List<String> superVal =\n+                    ValueCheckerUtils.getValueOfAnnotationWithStringArgument(superAnno);\n+            return subVal.containsAll(superVal);", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxODY5Mw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426018693", "bodyText": "What does \"Required\" mean to convey here?", "author": "mernst", "createdAt": "2020-05-15T19:58:37Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Required constructor.", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA4MzQwNw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426083407", "bodyText": "see my comment about \"mandatory\" above. In my opinion, there's no need for Javadoc for these constructors.", "author": "kelloggm", "createdAt": "2020-05-15T23:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxODY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxOTIzMw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426019233", "bodyText": "The first sentence says this method is about receivers, but a.b().c() is not the receiver nor within the reciever.", "author": "mernst", "createdAt": "2020-05-15T19:59:55Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Required constructor.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",\n+     * and b and c return their receiver (and are deterministic), all of the expressions {@code a},\n+     * {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include \"foo\". If", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5MTMwNQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426091305", "bodyText": "Thanks for pointing this out. This method didn't actually do what it said it did. I've consolidated the two accumulate methods, and their documentation should now be accurate. There was a corresponding error in TestAccumulationTransfer where accumulate was called on the method invocation (i.e. the return type), not the receiver, as it should have been. These two errors together allowed the tests to pass.", "author": "kelloggm", "createdAt": "2020-05-15T23:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxOTIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxOTgwOQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426019809", "bodyText": "Does \"not affected\" mean they are not updated, or they are updated as if all the methods had been deterministic, or they are updated (not \"not updated\"), but maybe in a different way than if all the methods had been deterministic?", "author": "mernst", "createdAt": "2020-05-15T20:01:13Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Required constructor.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",\n+     * and b and c return their receiver (and are deterministic), all of the expressions {@code a},\n+     * {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include \"foo\". If\n+     * any method in the chain is non-deterministic, its estimate will not be updated (but the rest\n+     * of the chain is not affected).", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxOTg5Mg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426019892", "bodyText": "Please be more specific.  Is this union?", "author": "mernst", "createdAt": "2020-05-15T20:01:26Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Required constructor.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",\n+     * and b and c return their receiver (and are deterministic), all of the expressions {@code a},\n+     * {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include \"foo\". If\n+     * any method in the chain is non-deterministic, its estimate will not be updated (but the rest\n+     * of the chain is not affected).\n+     *\n+     * @param node a method invocation whose receiver is to be updated\n+     * @param result the result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(\n+            MethodInvocationNode node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Node receiver = node.getTarget().getReceiver();\n+        AnnotatedTypeMirror oldType = typeFactory.getReceiverType(node.getTree());\n+        // e.g. if the node being visited is static\n+        if (oldType == null) {\n+            return;\n+        }\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        while (receiver != null) {\n+            // Note that this call doesn't do anything if receiver is a method call\n+            // that is not deterministic, though it can still continue to recurse.\n+            insertIntoStores(result, receiver, newAnno);\n+\n+            Tree receiverTree = receiver.getTree();\n+            // Possibly recurse: if the receiver is itself a method call,\n+            // then we need to also propagate this new information to its receiver\n+            // if the method being called has an @This return type.\n+            //\n+            // Note that we must check for null, because the tree could be\n+            // implicit (when calling an instance method on the class itself).\n+            // In that case, do not attempt to refine either - the receiver is\n+            // not a method invocation, anyway.\n+            if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                // Do not continue, because the receiver isn't a method invocation itself. The\n+                // end of the chain of calls has been reached.\n+                break;\n+            }\n+\n+            MethodInvocationTree receiverAsMethodInvocation =\n+                    (MethodInvocationTree) receiver.getTree();\n+\n+            if (typeFactory.returnsThis(receiverAsMethodInvocation)) {\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            } else {\n+                // Do not continue, because the method does not return @This.\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Combines the values in oldType with the values in newValues to produce a single accumulator", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMDI1NQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426020255", "bodyText": "getNewAnno is a vague name that I found confusing at call sites.  Please rename it.  Should \"New\" in the name be replaced by \"Glb\"?  (Or possibly by \"Union\"?)", "author": "mernst", "createdAt": "2020-05-15T20:02:22Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Required constructor.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",\n+     * and b and c return their receiver (and are deterministic), all of the expressions {@code a},\n+     * {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include \"foo\". If\n+     * any method in the chain is non-deterministic, its estimate will not be updated (but the rest\n+     * of the chain is not affected).\n+     *\n+     * @param node a method invocation whose receiver is to be updated\n+     * @param result the result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(\n+            MethodInvocationNode node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Node receiver = node.getTarget().getReceiver();\n+        AnnotatedTypeMirror oldType = typeFactory.getReceiverType(node.getTree());\n+        // e.g. if the node being visited is static\n+        if (oldType == null) {\n+            return;\n+        }\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        while (receiver != null) {\n+            // Note that this call doesn't do anything if receiver is a method call\n+            // that is not deterministic, though it can still continue to recurse.\n+            insertIntoStores(result, receiver, newAnno);\n+\n+            Tree receiverTree = receiver.getTree();\n+            // Possibly recurse: if the receiver is itself a method call,\n+            // then we need to also propagate this new information to its receiver\n+            // if the method being called has an @This return type.\n+            //\n+            // Note that we must check for null, because the tree could be\n+            // implicit (when calling an instance method on the class itself).\n+            // In that case, do not attempt to refine either - the receiver is\n+            // not a method invocation, anyway.\n+            if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                // Do not continue, because the receiver isn't a method invocation itself. The\n+                // end of the chain of calls has been reached.\n+                break;\n+            }\n+\n+            MethodInvocationTree receiverAsMethodInvocation =\n+                    (MethodInvocationTree) receiver.getTree();\n+\n+            if (typeFactory.returnsThis(receiverAsMethodInvocation)) {\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            } else {\n+                // Do not continue, because the method does not return @This.\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Combines the values in oldType with the values in newValues to produce a single accumulator\n+     * type qualifier.\n+     *\n+     * @param oldType an annotated type mirror whose values should be included\n+     * @param newValues new values to include\n+     * @return an annotation representing all the values\n+     */\n+    private AnnotationMirror getNewAnno(AnnotatedTypeMirror oldType, String[] newValues) {", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5MTc0Nw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426091747", "bodyText": "I prefer \"combined\", but if that's still confusing I can change it to \"union\", which I think sounds weird when you say it out loud", "author": "kelloggm", "createdAt": "2020-05-15T23:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMDI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMDcyMw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426020723", "bodyText": "How can !typeFactory.isAccumulatorAnnotation(oldAnno) be true?  Is that an error?  Or is it a funny way to test for BOTTOM and (in some type systems) TOP?", "author": "mernst", "createdAt": "2020-05-15T20:03:26Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Required constructor.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",\n+     * and b and c return their receiver (and are deterministic), all of the expressions {@code a},\n+     * {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include \"foo\". If\n+     * any method in the chain is non-deterministic, its estimate will not be updated (but the rest\n+     * of the chain is not affected).\n+     *\n+     * @param node a method invocation whose receiver is to be updated\n+     * @param result the result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(\n+            MethodInvocationNode node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Node receiver = node.getTarget().getReceiver();\n+        AnnotatedTypeMirror oldType = typeFactory.getReceiverType(node.getTree());\n+        // e.g. if the node being visited is static\n+        if (oldType == null) {\n+            return;\n+        }\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        while (receiver != null) {\n+            // Note that this call doesn't do anything if receiver is a method call\n+            // that is not deterministic, though it can still continue to recurse.\n+            insertIntoStores(result, receiver, newAnno);\n+\n+            Tree receiverTree = receiver.getTree();\n+            // Possibly recurse: if the receiver is itself a method call,\n+            // then we need to also propagate this new information to its receiver\n+            // if the method being called has an @This return type.\n+            //\n+            // Note that we must check for null, because the tree could be\n+            // implicit (when calling an instance method on the class itself).\n+            // In that case, do not attempt to refine either - the receiver is\n+            // not a method invocation, anyway.\n+            if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                // Do not continue, because the receiver isn't a method invocation itself. The\n+                // end of the chain of calls has been reached.\n+                break;\n+            }\n+\n+            MethodInvocationTree receiverAsMethodInvocation =\n+                    (MethodInvocationTree) receiver.getTree();\n+\n+            if (typeFactory.returnsThis(receiverAsMethodInvocation)) {\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            } else {\n+                // Do not continue, because the method does not return @This.\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Combines the values in oldType with the values in newValues to produce a single accumulator\n+     * type qualifier.\n+     *\n+     * @param oldType an annotated type mirror whose values should be included\n+     * @param newValues new values to include\n+     * @return an annotation representing all the values\n+     */\n+    private AnnotationMirror getNewAnno(AnnotatedTypeMirror oldType, String[] newValues) {\n+        AnnotationMirror oldAnno;\n+        if (oldType == null) {\n+            oldAnno = typeFactory.TOP;\n+        } else {\n+            oldAnno = oldType.getAnnotationInHierarchy(typeFactory.TOP);\n+            if (oldAnno == null || !typeFactory.isAccumulatorAnnotation(oldAnno)) {", "originalCommit": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5MjA0Mg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426092042", "bodyText": "It was a funny way to test for bottom or top. It turns out it isn't even necessary, so I removed it.", "author": "kelloggm", "createdAt": "2020-05-15T23:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMDcyMw=="}], "type": "inlineReview"}, {"oid": "bb5efe95df0d097be0721dc3b93c8aba41ca475e", "url": "https://github.com/typetools/checker-framework/commit/bb5efe95df0d097be0721dc3b93c8aba41ca475e", "message": "correct capitalization of almost-constants :)", "committedDate": "2020-05-15T21:31:49Z", "type": "commit"}, {"oid": "ecaa1e0c5a7203ea779504339f7390d15d9524c7", "url": "https://github.com/typetools/checker-framework/commit/ecaa1e0c5a7203ea779504339f7390d15d9524c7", "message": "make explicit the requirements on the top and bottom types", "committedDate": "2020-05-15T21:50:41Z", "type": "commit"}, {"oid": "018bd1412720667387d8921a87a1b11b70bdd7a4", "url": "https://github.com/typetools/checker-framework/commit/018bd1412720667387d8921a87a1b11b70bdd7a4", "message": "address todos in manual section", "committedDate": "2020-05-15T21:56:50Z", "type": "commit"}, {"oid": "e99b0557eafb3bb6a2ef1b292cdb02cc08902323", "url": "https://github.com/typetools/checker-framework/commit/e99b0557eafb3bb6a2ef1b292cdb02cc08902323", "message": "address remaining code review comments", "committedDate": "2020-05-16T00:00:39Z", "type": "commit"}, {"oid": "92430a9ef17881cea00737a17bed1c5db843c50a", "url": "https://github.com/typetools/checker-framework/commit/92430a9ef17881cea00737a17bed1c5db843c50a", "message": "Merge branch 'master' of github.com:typetools/checker-framework into accumulation-analysis", "committedDate": "2020-05-18T16:18:49Z", "type": "commit"}, {"oid": "ac7e9dd3a9832dee698dd4daa8859bc848d98ad0", "url": "https://github.com/typetools/checker-framework/commit/ac7e9dd3a9832dee698dd4daa8859bc848d98ad0", "message": "fix docS", "committedDate": "2020-05-18T16:30:55Z", "type": "commit"}, {"oid": "5a31f3904b80bd78307d891af77e700c42a45534", "url": "https://github.com/typetools/checker-framework/commit/5a31f3904b80bd78307d891af77e700c42a45534", "message": "Add comment", "committedDate": "2020-05-18T18:11:16Z", "type": "commit"}, {"oid": "33f5bc1f6c43935251779356cf29c40ae141c170", "url": "https://github.com/typetools/checker-framework/commit/33f5bc1f6c43935251779356cf29c40ae141c170", "message": "Split a paragraph", "committedDate": "2020-05-18T18:12:41Z", "type": "commit"}, {"oid": "8401eb53c2eb37f39e5bd68b4b6ac9365f3113cd", "url": "https://github.com/typetools/checker-framework/commit/8401eb53c2eb37f39e5bd68b4b6ac9365f3113cd", "message": "Comment tweaks and a few logic simplifications", "committedDate": "2020-05-18T19:49:55Z", "type": "commit"}, {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "url": "https://github.com/typetools/checker-framework/commit/6047e3987fbc00fbbf23b6b115a40086d86eea57", "message": "Merge branch 'accumulation-analysis' of github.com:kelloggm/checker-framework into accumulation-analysis", "committedDate": "2020-05-18T19:50:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1OTI2OQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426859269", "bodyText": "I don't see the need for a distinct top annotation.  I think that users can use @Accum() instead of @AccumTop.\n\nFewer annotations means less work for implementers and less for users to learn (less documentation to read).\n\"Top\" is type system jargon.  Let's avoid that were possible.\nIt's confusing to users to have two different ways to express the same concept: @Accum() and @AccumTop.  I am also concerned that error messages will refer to @AccumTop when the users wrote @Accum(), which may confuse them.", "author": "mernst", "createdAt": "2020-05-18T19:53:32Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy, which must be a supertype of {@code accumulator}.", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwOTA3MQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r432709071", "bodyText": "This is a good idea. I modeled the general accumulation type system on @CalledMethods, which has a separate top type, but I'm no longer convinced it's needed there, either.", "author": "kelloggm", "createdAt": "2020-05-29T20:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1OTI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1OTc1Mw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426859753", "bodyText": "Facts like the existence of a single argument named \"value\" are testable in this method.  Users are likely to violate the requirements, unfortunately.", "author": "mernst", "createdAt": "2020-05-18T19:54:32Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyMjI1NA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r432722254", "bodyText": "That's a good point. I've added tests for all these requirements.", "author": "kelloggm", "createdAt": "2020-05-29T20:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1OTc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MDc4MA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426860780", "bodyText": "What is the reason for permitting null as a value?  It is not used in the given code.  I think client code will be clearer if it uses Collections.emptyList(); it isn't obvious what null would be a special value for (a user might think it means bottom).  And, having two ways to accomplish the same goal can be confusing.", "author": "mernst", "createdAt": "2020-05-18T19:56:35Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy, which must be a supertype of {@code accumulator}.\n+     *     The top type should be an annotation with no arguments.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.top = AnnotationBuilder.fromClass(elements, top);\n+        this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n+        this.accumulator = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values}.\n+     *\n+     * @param values the arguments to the annotation. The values can contain duplicates and can be\n+     *     in any order.\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is null or empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(@Nullable List<String> values) {", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MTE1Ng==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426861156", "bodyText": "It's usually clearer to name rules rather than number them.  That also insulates against renumbering or reordering.", "author": "mernst", "createdAt": "2020-05-18T19:57:24Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy, which must be a supertype of {@code accumulator}.\n+     *     The top type should be an annotation with no arguments.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.top = AnnotationBuilder.fromClass(elements, top);\n+        this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n+        this.accumulator = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values}.\n+     *\n+     * @param values the arguments to the annotation. The values can contain duplicates and can be\n+     *     in any order.\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is null or empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(@Nullable List<String> values) {\n+        if (values == null || values.size() == 0) {\n+            return top;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, accumulator);\n+        builder.setValue(\"value\", ValueCheckerUtils.removeDuplicates(values));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        // Must call `getTypeFactoryOfSubchecker` each time, not store and reuse.\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, accumulator);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /**\n+     * This tree annotator implements the following rule(s): 1. If a method returns its receiver,\n+     * and the receiver has an accumulation type, then the default type of the method's return value\n+     * is the type of the receiver.\n+     */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Creates an instance of this tree annotator for the given type factory.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * Implements rule 1.", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MjA2Ng==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426862066", "bodyText": "Minor: leastUpperBound uses else if rather than a second if.  We might as well make them consistent to avoid readers doing a double-take.", "author": "mernst", "createdAt": "2020-05-18T19:59:20Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy, which must be a supertype of {@code accumulator}.\n+     *     The top type should be an annotation with no arguments.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.top = AnnotationBuilder.fromClass(elements, top);\n+        this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n+        this.accumulator = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values}.\n+     *\n+     * @param values the arguments to the annotation. The values can contain duplicates and can be\n+     *     in any order.\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is null or empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(@Nullable List<String> values) {\n+        if (values == null || values.size() == 0) {\n+            return top;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, accumulator);\n+        builder.setValue(\"value\", ValueCheckerUtils.removeDuplicates(values));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        // Must call `getTypeFactoryOfSubchecker` each time, not store and reuse.\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, accumulator);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /**\n+     * This tree annotator implements the following rule(s): 1. If a method returns its receiver,\n+     * and the receiver has an accumulation type, then the default type of the method's return value\n+     * is the type of the receiver.\n+     */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Creates an instance of this tree annotator for the given type factory.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * Implements rule 1.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type {@code tree} (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType =\n+                        receiverTree == null ? null : getAnnotatedType(receiverTree);\n+                // The current type of the receiver, or top if none exists.\n+                AnnotationMirror receiverAnno =\n+                        receiverType == null ? top : receiverType.getAnnotationInHierarchy(top);\n+\n+                AnnotationMirror returnAnno = type.getAnnotationInHierarchy(top);\n+                type.replaceAnnotation(qualHierarchy.greatestLowerBound(returnAnno, receiverAnno));\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *    top = acc()\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return top;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, bottom) || AnnotationUtils.areSame(a2, bottom)) {\n+                return bottom;\n+            }\n+\n+            if (AnnotationUtils.areSame(a1, top)) {\n+                return a2;\n+            }\n+\n+            if (AnnotationUtils.areSame(a2, top)) {", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MzA2NA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426863064", "bodyText": "How can this happen?  (Maybe if there are other types than top, accumulator, and bottom?  But in that case clients should either use a different type hierarchy or should ensure that other types never flow to here.)\nI suggest making this throw an exception rather than silently returning bottom.", "author": "mernst", "createdAt": "2020-05-18T20:01:23Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy, which must be a supertype of {@code accumulator}.\n+     *     The top type should be an annotation with no arguments.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.top = AnnotationBuilder.fromClass(elements, top);\n+        this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n+        this.accumulator = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values}.\n+     *\n+     * @param values the arguments to the annotation. The values can contain duplicates and can be\n+     *     in any order.\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is null or empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(@Nullable List<String> values) {\n+        if (values == null || values.size() == 0) {\n+            return top;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, accumulator);\n+        builder.setValue(\"value\", ValueCheckerUtils.removeDuplicates(values));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        // Must call `getTypeFactoryOfSubchecker` each time, not store and reuse.\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, accumulator);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /**\n+     * This tree annotator implements the following rule(s): 1. If a method returns its receiver,\n+     * and the receiver has an accumulation type, then the default type of the method's return value\n+     * is the type of the receiver.\n+     */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Creates an instance of this tree annotator for the given type factory.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * Implements rule 1.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type {@code tree} (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType =\n+                        receiverTree == null ? null : getAnnotatedType(receiverTree);\n+                // The current type of the receiver, or top if none exists.\n+                AnnotationMirror receiverAnno =\n+                        receiverType == null ? top : receiverType.getAnnotationInHierarchy(top);\n+\n+                AnnotationMirror returnAnno = type.getAnnotationInHierarchy(top);\n+                type.replaceAnnotation(qualHierarchy.greatestLowerBound(returnAnno, receiverAnno));\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *    top = acc()\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return top;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, bottom) || AnnotationUtils.areSame(a2, bottom)) {\n+                return bottom;\n+            }\n+\n+            if (AnnotationUtils.areSame(a1, top)) {\n+                return a2;\n+            }\n+\n+            if (AnnotationUtils.areSame(a2, top)) {\n+                return a1;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                List<String> a1Val = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1);\n+                List<String> a2Val = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2);\n+                a1Val.addAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val);\n+            } else {\n+                return bottom;", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MzI0MQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426863241", "bodyText": "Same question as above about whether this should be an error.", "author": "mernst", "createdAt": "2020-05-18T20:01:49Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy, which must be a supertype of {@code accumulator}.\n+     *     The top type should be an annotation with no arguments.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.top = AnnotationBuilder.fromClass(elements, top);\n+        this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n+        this.accumulator = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values}.\n+     *\n+     * @param values the arguments to the annotation. The values can contain duplicates and can be\n+     *     in any order.\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is null or empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(@Nullable List<String> values) {\n+        if (values == null || values.size() == 0) {\n+            return top;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, accumulator);\n+        builder.setValue(\"value\", ValueCheckerUtils.removeDuplicates(values));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        // Must call `getTypeFactoryOfSubchecker` each time, not store and reuse.\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, accumulator);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /**\n+     * This tree annotator implements the following rule(s): 1. If a method returns its receiver,\n+     * and the receiver has an accumulation type, then the default type of the method's return value\n+     * is the type of the receiver.\n+     */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Creates an instance of this tree annotator for the given type factory.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * Implements rule 1.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type {@code tree} (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType =\n+                        receiverTree == null ? null : getAnnotatedType(receiverTree);\n+                // The current type of the receiver, or top if none exists.\n+                AnnotationMirror receiverAnno =\n+                        receiverType == null ? top : receiverType.getAnnotationInHierarchy(top);\n+\n+                AnnotationMirror returnAnno = type.getAnnotationInHierarchy(top);\n+                type.replaceAnnotation(qualHierarchy.greatestLowerBound(returnAnno, receiverAnno));\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *    top = acc()\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return top;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, bottom) || AnnotationUtils.areSame(a2, bottom)) {\n+                return bottom;\n+            }\n+\n+            if (AnnotationUtils.areSame(a1, top)) {\n+                return a2;\n+            }\n+\n+            if (AnnotationUtils.areSame(a2, top)) {\n+                return a1;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                List<String> a1Val = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1);\n+                List<String> a2Val = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2);\n+                a1Val.addAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val);\n+            } else {\n+                return bottom;\n+            }\n+        }\n+\n+        /**\n+         * LUB in this type system is set intersection of the arguments of the two annotations,\n+         * unless one of them is bottom, in which case the result is the other annotation.\n+         */\n+        @Override\n+        public AnnotationMirror leastUpperBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, bottom)) {\n+                return a2;\n+            } else if (AnnotationUtils.areSame(a2, bottom)) {\n+                return a1;\n+            }\n+\n+            if (AnnotationUtils.areSame(a1, top) || AnnotationUtils.areSame(a2, top)) {\n+                return top;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                List<String> a1Val = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1);\n+                List<String> a2Val = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2);\n+                a1Val.retainAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val);\n+            } else {\n+                return top;", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MDMxMg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426960312", "bodyText": "\"any deterministic methods\": they might follow it, as in a.b().nondet().c().d() where b, c, and d are deterministic.  Do the values go through nondet() and affect all of b(), c(), and d()?", "author": "mernst", "createdAt": "2020-05-19T00:18:54Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyOTQxNQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r432729415", "bodyText": "yes, as long as nondet returns @This. I think this is just an imprecision caused by the dataflow framework rather than something fundamental, since the RR information should make the fact that the method isn't known to be deterministic irrelevant.", "author": "kelloggm", "createdAt": "2020-05-29T20:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MDMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MDU2Mg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426960562", "bodyText": "\"the ultimate receiver\": this isn't clear.  I think you mean a in your examples, but I'm not sure.  The receiver value is identical, so I'm not sure what this means.  It's only the expressions that differ.", "author": "mernst", "createdAt": "2020-05-19T00:19:55Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMDIxMQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r432730211", "bodyText": "I do mean a. Really, what was meant was the first receiver expression that isn't an invocation of a method that returns its receiver. I'll update the text.", "author": "kelloggm", "createdAt": "2020-05-29T20:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MDU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MDg3OQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426960879", "bodyText": "Why is asList called?  The callee, getCombinedAnno, will make a copy anyway.", "author": "mernst", "createdAt": "2020-05-19T00:20:59Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getCombinedAnno(oldType, Arrays.asList(values));", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwODY5Mg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r432708692", "bodyText": "This is no longer a concern with the other changes I've made.", "author": "kelloggm", "createdAt": "2020-05-29T20:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MDg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MTMwNw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426961307", "bodyText": "The documentation is clear, but I still find \"getCombinedAnno\" unclear since it's not the annotations that are being combined (lubbed) but the values that are being combined (unioned).  I would change \"Combined\" in the method name to \"glb\" or \"union\" or \"accumulated\".", "author": "mernst", "createdAt": "2020-05-19T00:22:20Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getCombinedAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            Node receiver = methodInvocationNode.getTarget().getReceiver();\n+            MethodInvocationTree invokedMethod = (MethodInvocationTree) tree;\n+\n+            while (receiver != null && typeFactory.returnsThis(invokedMethod)) {\n+                // Note that this call doesn't do anything if receiver is a method call\n+                // that is not deterministic, though it can still continue to recurse.\n+                insertIntoStores(result, receiver, newAnno);\n+\n+                Tree receiverTree = receiver.getTree();\n+                // Possibly recurse: if the receiver is itself a method call,\n+                // then we need to also propagate this new information to its receiver\n+                // if the method being called has an @This return type.\n+                //\n+                // Note that we must check for null, because the tree could be\n+                // implicit (when calling an instance method on the class itself).\n+                // In that case, do not attempt to refine either - the receiver is\n+                // not a method invocation, anyway.\n+                if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                    // Do not continue, because the receiver isn't a method invocation itself. The\n+                    // end of the chain of calls has been reached.\n+                    break;\n+                }\n+\n+                invokedMethod = (MethodInvocationTree) receiver.getTree();\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unions the values in oldType with the values in newValues to produce a single accumulator\n+     * type qualifier.\n+     *\n+     * @param oldType an annotated type mirror whose values should be included, or null which is\n+     *     treated as top\n+     * @param newValues new values to include\n+     * @return an annotation representing all the values\n+     */\n+    private AnnotationMirror getCombinedAnno(", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MTY0MQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426961641", "bodyText": "Why does this method treat null specially?  Are there places that null is more convenient to call?", "author": "mernst", "createdAt": "2020-05-19T00:23:32Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getCombinedAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            Node receiver = methodInvocationNode.getTarget().getReceiver();\n+            MethodInvocationTree invokedMethod = (MethodInvocationTree) tree;\n+\n+            while (receiver != null && typeFactory.returnsThis(invokedMethod)) {\n+                // Note that this call doesn't do anything if receiver is a method call\n+                // that is not deterministic, though it can still continue to recurse.\n+                insertIntoStores(result, receiver, newAnno);\n+\n+                Tree receiverTree = receiver.getTree();\n+                // Possibly recurse: if the receiver is itself a method call,\n+                // then we need to also propagate this new information to its receiver\n+                // if the method being called has an @This return type.\n+                //\n+                // Note that we must check for null, because the tree could be\n+                // implicit (when calling an instance method on the class itself).\n+                // In that case, do not attempt to refine either - the receiver is\n+                // not a method invocation, anyway.\n+                if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                    // Do not continue, because the receiver isn't a method invocation itself. The\n+                    // end of the chain of calls has been reached.\n+                    break;\n+                }\n+\n+                invokedMethod = (MethodInvocationTree) receiver.getTree();\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unions the values in oldType with the values in newValues to produce a single accumulator\n+     * type qualifier.\n+     *\n+     * @param oldType an annotated type mirror whose values should be included, or null which is", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MTk2NA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426961964", "bodyText": "Is the logic in these lines similar to that in visitMethodInvocation?  If so, consider abstracting it out.\nOr, since getCombinedAnnotation is only called once, you could create a method getAnnotationMirror that calls getAnnotatedType and then calls this logic.  That seems like a logical place for it, and then this method could just take an AnnotationMirror as an argument.", "author": "mernst", "createdAt": "2020-05-19T00:24:51Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getCombinedAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            Node receiver = methodInvocationNode.getTarget().getReceiver();\n+            MethodInvocationTree invokedMethod = (MethodInvocationTree) tree;\n+\n+            while (receiver != null && typeFactory.returnsThis(invokedMethod)) {\n+                // Note that this call doesn't do anything if receiver is a method call\n+                // that is not deterministic, though it can still continue to recurse.\n+                insertIntoStores(result, receiver, newAnno);\n+\n+                Tree receiverTree = receiver.getTree();\n+                // Possibly recurse: if the receiver is itself a method call,\n+                // then we need to also propagate this new information to its receiver\n+                // if the method being called has an @This return type.\n+                //\n+                // Note that we must check for null, because the tree could be\n+                // implicit (when calling an instance method on the class itself).\n+                // In that case, do not attempt to refine either - the receiver is\n+                // not a method invocation, anyway.\n+                if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                    // Do not continue, because the receiver isn't a method invocation itself. The\n+                    // end of the chain of calls has been reached.\n+                    break;\n+                }\n+\n+                invokedMethod = (MethodInvocationTree) receiver.getTree();\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unions the values in oldType with the values in newValues to produce a single accumulator\n+     * type qualifier.\n+     *\n+     * @param oldType an annotated type mirror whose values should be included, or null which is\n+     *     treated as top\n+     * @param newValues new values to include\n+     * @return an annotation representing all the values\n+     */\n+    private AnnotationMirror getCombinedAnno(\n+            @Nullable AnnotatedTypeMirror oldType, List<String> newValues) {\n+        AnnotationMirror oldAnno;\n+        if (oldType == null) {", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwNTQ0Mw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r432705443", "bodyText": "I rewrote the logic here to make it clear that they're not quite the same - in the annotated type factory, it's not necessary to check for the annotation mirror being null, but here it is. So I don't think there's any need to abstract the one or two lines they share.", "author": "kelloggm", "createdAt": "2020-05-29T19:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MTk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MjQzMQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426962431", "bodyText": "I think this is a way of saying \"not top or bottom\".  It's surprising that combining any A with top has the same effect as combining A with bottom.  Is that intentional?  Should combining A with bottom lead to bottom?", "author": "mernst", "createdAt": "2020-05-19T00:26:38Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getCombinedAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            Node receiver = methodInvocationNode.getTarget().getReceiver();\n+            MethodInvocationTree invokedMethod = (MethodInvocationTree) tree;\n+\n+            while (receiver != null && typeFactory.returnsThis(invokedMethod)) {\n+                // Note that this call doesn't do anything if receiver is a method call\n+                // that is not deterministic, though it can still continue to recurse.\n+                insertIntoStores(result, receiver, newAnno);\n+\n+                Tree receiverTree = receiver.getTree();\n+                // Possibly recurse: if the receiver is itself a method call,\n+                // then we need to also propagate this new information to its receiver\n+                // if the method being called has an @This return type.\n+                //\n+                // Note that we must check for null, because the tree could be\n+                // implicit (when calling an instance method on the class itself).\n+                // In that case, do not attempt to refine either - the receiver is\n+                // not a method invocation, anyway.\n+                if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                    // Do not continue, because the receiver isn't a method invocation itself. The\n+                    // end of the chain of calls has been reached.\n+                    break;\n+                }\n+\n+                invokedMethod = (MethodInvocationTree) receiver.getTree();\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unions the values in oldType with the values in newValues to produce a single accumulator\n+     * type qualifier.\n+     *\n+     * @param oldType an annotated type mirror whose values should be included, or null which is\n+     *     treated as top\n+     * @param newValues new values to include\n+     * @return an annotation representing all the values\n+     */\n+    private AnnotationMirror getCombinedAnno(\n+            @Nullable AnnotatedTypeMirror oldType, List<String> newValues) {\n+        AnnotationMirror oldAnno;\n+        if (oldType == null) {\n+            oldAnno = typeFactory.top;\n+        } else {\n+            oldAnno = oldType.getAnnotationInHierarchy(typeFactory.top);\n+            if (oldAnno == null) {\n+                oldAnno = typeFactory.top;\n+            }\n+        }\n+        List<String> allValues = new ArrayList<>(newValues);\n+        if (typeFactory.isAccumulatorAnnotation(oldAnno)) {", "originalCommit": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwMDkzMg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r432700932", "bodyText": "I rewrote this method to make this test unnecessary (it now uses GLB).", "author": "kelloggm", "createdAt": "2020-05-29T19:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MjQzMQ=="}], "type": "inlineReview"}, {"oid": "01cbbe4d2783e65c2506d32b0cc2740a4eedcf00", "url": "https://github.com/typetools/checker-framework/commit/01cbbe4d2783e65c2506d32b0cc2740a4eedcf00", "message": "Merge branch 'master' of github.com:typetools/checker-framework into accumulation-analysis", "committedDate": "2020-05-28T16:00:07Z", "type": "commit"}, {"oid": "6550096079dd147767ab37d95025cbb5250f5a09", "url": "https://github.com/typetools/checker-framework/commit/6550096079dd147767ab37d95025cbb5250f5a09", "message": "remove the need for a separate top type, and other miscellaneous improvements that go along with that", "committedDate": "2020-05-28T23:00:24Z", "type": "commit"}, {"oid": "b6aa5275b5ef1f91dd8ba11bdcef87f0d5661500", "url": "https://github.com/typetools/checker-framework/commit/b6aa5275b5ef1f91dd8ba11bdcef87f0d5661500", "message": "remove unnecessary null check", "committedDate": "2020-05-29T20:05:06Z", "type": "commit"}, {"oid": "5160f6978690c19dd51336995f76f7c1ba17ba34", "url": "https://github.com/typetools/checker-framework/commit/5160f6978690c19dd51336995f76f7c1ba17ba34", "message": "add defensive logic to AccATF constructor to check that the accumulator annotation matches the requirements", "committedDate": "2020-05-29T20:32:44Z", "type": "commit"}, {"oid": "ba0c2ea62a7fcc2795b8825f65144839f8b1bd03", "url": "https://github.com/typetools/checker-framework/commit/ba0c2ea62a7fcc2795b8825f65144839f8b1bd03", "message": "address remaining CR comments", "committedDate": "2020-05-29T20:58:42Z", "type": "commit"}, {"oid": "a62ac9d69c8ba43aa8cea1ef1b530c1ececdc6ed", "url": "https://github.com/typetools/checker-framework/commit/a62ac9d69c8ba43aa8cea1ef1b530c1ececdc6ed", "message": "thanks interning checkeR", "committedDate": "2020-05-29T23:09:08Z", "type": "commit"}, {"oid": "bd7e2283ffbdca30d18559ecb330c9428575ce8d", "url": "https://github.com/typetools/checker-framework/commit/bd7e2283ffbdca30d18559ecb330c9428575ce8d", "message": "Merge ../checker-framework-branch-master into accumulation-analysis", "committedDate": "2020-05-31T23:53:15Z", "type": "commit"}, {"oid": "8f94fd08d98c987fe5929fe940f486fb5fd4e7ab", "url": "https://github.com/typetools/checker-framework/commit/8f94fd08d98c987fe5929fe940f486fb5fd4e7ab", "message": "Documentation tweaks from code review", "committedDate": "2020-06-02T00:27:18Z", "type": "commit"}, {"oid": "a2652f871316a3dfc9f90b6bf77898942e2347a6", "url": "https://github.com/typetools/checker-framework/commit/a2652f871316a3dfc9f90b6bf77898942e2347a6", "message": "Code review changes, mostly to documentation", "committedDate": "2020-06-02T04:23:11Z", "type": "commit"}, {"oid": "0c117619af274d50d2ec3681a5b2560d3a1faed3", "url": "https://github.com/typetools/checker-framework/commit/0c117619af274d50d2ec3681a5b2560d3a1faed3", "message": "Merge ../checker-framework-branch-master into accumulation-analysis", "committedDate": "2020-06-02T05:20:54Z", "type": "commit"}, {"oid": "b0411993d94b694592dd4789b9a8bd7d1072de05", "url": "https://github.com/typetools/checker-framework/commit/b0411993d94b694592dd4789b9a8bd7d1072de05", "message": "Tweak a test", "committedDate": "2020-06-02T05:29:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyMTE2OQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433621169", "bodyText": "\"argument\" should be \"element\".\nThe test also fails if it has zero elements, so the message may be misleading.", "author": "mernst", "createdAt": "2020-06-02T05:02:13Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,311 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The canonical top annotation for this accumulation checker: an instance of the accumulator\n+     * annotation with no arguments.\n+     */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.accumulator = accumulator;\n+\n+        // Check that the requirements of the accumulator are met.\n+        Method[] accDeclaredMethods = accumulator.getDeclaredMethods();\n+        if (accDeclaredMethods.length != 1) {\n+            rejectMalformedAccumulator(\"not have more than one argument\");", "originalCommit": "bd7e2283ffbdca30d18559ecb330c9428575ce8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyMTQzMw==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433621433", "bodyText": "This check, and the next one, are not about the annotation but about its value element, so the string created by rejectMalformedAccumulator is imprecise and possibly confusing.", "author": "mernst", "createdAt": "2020-06-02T05:03:13Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,311 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The canonical top annotation for this accumulation checker: an instance of the accumulator\n+     * annotation with no arguments.\n+     */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.accumulator = accumulator;\n+\n+        // Check that the requirements of the accumulator are met.\n+        Method[] accDeclaredMethods = accumulator.getDeclaredMethods();\n+        if (accDeclaredMethods.length != 1) {\n+            rejectMalformedAccumulator(\"not have more than one argument\");\n+        }\n+        Method value = accDeclaredMethods[0];\n+        if (value.getName() != \"value\") {\n+            rejectMalformedAccumulator(\"name its argument \\\"value\\\"\");\n+        }\n+        if (!value.getReturnType().isInstance(new String[0])) {\n+            rejectMalformedAccumulator(\"have an argument of type String[]\");", "originalCommit": "bd7e2283ffbdca30d18559ecb330c9428575ce8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyMTgyNA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433621824", "bodyText": "A UserError is when a user passed wrong arguments to the Checker Framework.  It can be corrected by changing the run-time invocation.  A bug in the source code of a checker should be thrown as a BugInCF., even if that source code was written by someone other than the main Checker Framework developers.", "author": "mernst", "createdAt": "2020-06-02T05:04:48Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,311 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The canonical top annotation for this accumulation checker: an instance of the accumulator\n+     * annotation with no arguments.\n+     */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.accumulator = accumulator;\n+\n+        // Check that the requirements of the accumulator are met.\n+        Method[] accDeclaredMethods = accumulator.getDeclaredMethods();\n+        if (accDeclaredMethods.length != 1) {\n+            rejectMalformedAccumulator(\"not have more than one argument\");\n+        }\n+        Method value = accDeclaredMethods[0];\n+        if (value.getName() != \"value\") {\n+            rejectMalformedAccumulator(\"name its argument \\\"value\\\"\");\n+        }\n+        if (!value.getReturnType().isInstance(new String[0])) {\n+            rejectMalformedAccumulator(\"have an argument of type String[]\");\n+        }\n+        if (((String[]) value.getDefaultValue()).length != 0) {\n+            rejectMalformedAccumulator(\"must have the empty string array {} as its default value\");\n+        }\n+\n+        this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n+        this.top = createAccumulatorAnnotation(Collections.emptyList());\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Common error message for malformed accumulator annotation.\n+     *\n+     * @param missing what is missing from the accumulator, suitable for use in this string to\n+     *     replace $MISSING$: \"The accumulator annotation Foo must $MISSING$.\"\n+     */\n+    private void rejectMalformedAccumulator(String missing) {\n+        throw new UserError(", "originalCommit": "bd7e2283ffbdca30d18559ecb330c9428575ce8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNTA5NA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433625094", "bodyText": "\"the chain\" isn't really defined.  Can you define that term before you start discussing the behavior of the method?", "author": "mernst", "createdAt": "2020-06-02T05:17:52Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the", "originalCommit": "bd7e2283ffbdca30d18559ecb330c9428575ce8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNTgzMg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433625832", "bodyText": "Why is it important to mention that the method is deterministic?\nI think every method that returns its receiver is deterministic, so this would be a vacuous test and it's confusing why it is mentioned as an extra condition.", "author": "mernst", "createdAt": "2020-06-02T05:20:27Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions", "originalCommit": "bd7e2283ffbdca30d18559ecb330c9428575ce8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5NDUyNg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r434794526", "bodyText": "I think Manu made this point at some point, which is why we added it to the documentation. I agree it is distracting. @msridhar do you think removing any mention of determinism is okay here - it is a general fact about how dataflow works rather than something specific to how accumulation analysis works.", "author": "kelloggm", "createdAt": "2020-06-03T19:13:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNTgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgwMTY5NQ==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r434801695", "bodyText": "Yes we can remove the mention of determinism", "author": "msridhar", "createdAt": "2020-06-03T19:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNTgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNjY2OA==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433626668", "bodyText": "Please remove these comments, or indicate how they are actionable.  For example, is the programmer supposed to keep the two versions of the test in sync by making a duplicate pull request on the other repository?", "author": "mernst", "createdAt": "2020-06-02T05:23:16Z", "path": "framework/tests/accumulation/Generics.java", "diffHunk": "@@ -0,0 +1,45 @@\n+// Copied from the Object Construction Checker.", "originalCommit": "bd7e2283ffbdca30d18559ecb330c9428575ce8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyODQwMg==", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433628402", "bodyText": "Are there tests of this functionality?  Test SimpleFluent.java does not seem to test it.  I expect a test would look like\n  s.a().b().c();\n  s.build();", "author": "mernst", "createdAt": "2020-06-02T05:29:10Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a", "originalCommit": "bd7e2283ffbdca30d18559ecb330c9428575ce8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d2abe73a6512ca901f516d94d08bbefcdd8fea55", "url": "https://github.com/typetools/checker-framework/commit/d2abe73a6512ca901f516d94d08bbefcdd8fea55", "message": "Merge ../checker-framework-branch-master into accumulation-analysis", "committedDate": "2020-06-03T16:54:23Z", "type": "commit"}, {"oid": "f71ee15c7552e35817990281d5943613989185f8", "url": "https://github.com/typetools/checker-framework/commit/f71ee15c7552e35817990281d5943613989185f8", "message": "efficiency improvements Mike asked for, as best as I can tell", "committedDate": "2020-06-03T19:05:24Z", "type": "commit"}, {"oid": "20ef5525fcb14218821b3b6cc4ede71ee14bfaaa", "url": "https://github.com/typetools/checker-framework/commit/20ef5525fcb14218821b3b6cc4ede71ee14bfaaa", "message": "address most code review comments", "committedDate": "2020-06-03T19:21:28Z", "type": "commit"}, {"oid": "d6840005eb094e926f9cb69bde8304eafbdade16", "url": "https://github.com/typetools/checker-framework/commit/d6840005eb094e926f9cb69bde8304eafbdade16", "message": "update some comments, add failing test", "committedDate": "2020-06-04T19:45:42Z", "type": "commit"}, {"oid": "8f2de7e8fd0bed28e9e8062ebccdb1dd782b5806", "url": "https://github.com/typetools/checker-framework/commit/8f2de7e8fd0bed28e9e8062ebccdb1dd782b5806", "message": "handle failing test", "committedDate": "2020-06-05T18:41:00Z", "type": "commit"}, {"oid": "d13111da146e97cc91dd0bd290d00e1e2d36ef0c", "url": "https://github.com/typetools/checker-framework/commit/d13111da146e97cc91dd0bd290d00e1e2d36ef0c", "message": "fix javadoc", "committedDate": "2020-06-05T19:57:08Z", "type": "commit"}, {"oid": "03e87ece7e1fa945da00cd94009e4fb6ef279ec6", "url": "https://github.com/typetools/checker-framework/commit/03e87ece7e1fa945da00cd94009e4fb6ef279ec6", "message": "don't include literal @", "committedDate": "2020-06-05T21:00:20Z", "type": "commit"}, {"oid": "3109b72ad30f592298391d7e39ad50913b3ec420", "url": "https://github.com/typetools/checker-framework/commit/3109b72ad30f592298391d7e39ad50913b3ec420", "message": "Merge ../checker-framework-branch-master into accumulation-analysis", "committedDate": "2020-06-08T20:39:17Z", "type": "commit"}]}