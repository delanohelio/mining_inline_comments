{"pr_number": 3847, "pr_title": "Define classes `SubtypeIsSubsetQualifierHierarchy` and `SubtypeIsSupersetQualifierHierarchy`", "pr_createdAt": "2020-11-02T21:25:21Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3847", "timeline": [{"oid": "534747c54a3128e0ba19e5a59c7f580c8bae6f2e", "url": "https://github.com/typetools/checker-framework/commit/534747c54a3128e0ba19e5a59c7f580c8bae6f2e", "message": "Document why nested class is not static", "committedDate": "2020-10-29T21:30:59Z", "type": "commit"}, {"oid": "85a767ea734ba453115498fbb605ea3075bf6d21", "url": "https://github.com/typetools/checker-framework/commit/85a767ea734ba453115498fbb605ea3075bf6d21", "message": "Merge branch 'master' of github.com:mernst/checker-framework", "committedDate": "2020-11-02T16:04:29Z", "type": "commit"}, {"oid": "170b589dbc48bea5243743789205d9795a74f719", "url": "https://github.com/typetools/checker-framework/commit/170b589dbc48bea5243743789205d9795a74f719", "message": "Add argument to MostlyNoElementQualifierHierarchy operations", "committedDate": "2020-11-02T19:03:49Z", "type": "commit"}, {"oid": "9c48a6678228de47a8eee2e029c477d452fda36a", "url": "https://github.com/typetools/checker-framework/commit/9c48a6678228de47a8eee2e029c477d452fda36a", "message": "Remove undesired comment", "committedDate": "2020-11-02T19:05:40Z", "type": "commit"}, {"oid": "7604690fd2743ea74d984c00bead6497893fbe16", "url": "https://github.com/typetools/checker-framework/commit/7604690fd2743ea74d984c00bead6497893fbe16", "message": "Add changelog entry", "committedDate": "2020-11-02T19:13:37Z", "type": "commit"}, {"oid": "643364dc3e7748aa385e43060ad0ffba9717f209", "url": "https://github.com/typetools/checker-framework/commit/643364dc3e7748aa385e43060ad0ffba9717f209", "message": "Use SubtypeIsSupersetQualifierHierarchy", "committedDate": "2020-11-02T19:14:19Z", "type": "commit"}, {"oid": "8340227a8623c01990e8b25acfa9c0ff19db0363", "url": "https://github.com/typetools/checker-framework/commit/8340227a8623c01990e8b25acfa9c0ff19db0363", "message": "Merge ../checker-framework-fork-mernst-branch-MostlyNoElementQualifierHierarchy-add-argument into subtype-set-operations", "committedDate": "2020-11-02T19:15:54Z", "type": "commit"}, {"oid": "afe605fb92881aeec69a45656f5666050c3da531", "url": "https://github.com/typetools/checker-framework/commit/afe605fb92881aeec69a45656f5666050c3da531", "message": "Add class SubtypeIsSubsetQualifierHierarchy", "committedDate": "2020-11-02T19:19:08Z", "type": "commit"}, {"oid": "e16e2b6ba65f9d8a7bc7fb650386b1a4b32733b5", "url": "https://github.com/typetools/checker-framework/commit/e16e2b6ba65f9d8a7bc7fb650386b1a4b32733b5", "message": "Add Javadoc", "committedDate": "2020-11-02T20:23:26Z", "type": "commit"}, {"oid": "06f6423ed3db335f5442795460c4ae0d2947f9b1", "url": "https://github.com/typetools/checker-framework/commit/06f6423ed3db335f5442795460c4ae0d2947f9b1", "message": "Merge remote-tracking branch 'origin/master' into subtype-set-operations", "committedDate": "2020-11-03T17:27:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg4MDk2NA==", "url": "https://github.com/typetools/checker-framework/pull/3847#discussion_r516880964", "bodyText": "arguments should be elements.", "author": "smillst", "createdAt": "2020-11-03T18:44:04Z", "path": "framework/src/main/java/org/checkerframework/framework/type/SubtypeIsSubsetQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.checkerframework.framework.type;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.util.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A {@link org.checkerframework.framework.type.QualifierHierarchy} where, when a qualifier has\n+ * arguments, the subtype relation is determined by a subset test on the arguments.", "originalCommit": "06f6423ed3db335f5442795460c4ae0d2947f9b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg4Mjc1OQ==", "url": "https://github.com/typetools/checker-framework/pull/3847#discussion_r516882759", "bodyText": "This class could be changed to operate on lists of Objects rather than Strings. If you don't want to make that change, then the class comment should mention that the annotation element but be an array of strings.\n\\", "author": "smillst", "createdAt": "2020-11-03T18:47:00Z", "path": "framework/src/main/java/org/checkerframework/framework/type/SubtypeIsSubsetQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package org.checkerframework.framework.type;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.util.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A {@link org.checkerframework.framework.type.QualifierHierarchy} where, when a qualifier has\n+ * arguments, the subtype relation is determined by a subset test on the arguments.\n+ *\n+ * <p>This assumes that if the lub or glb of two qualifiers has elements, then both of the arguments\n+ * had the same kind as the result does.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class SubtypeIsSubsetQualifierHierarchy extends MostlyNoElementQualifierHierarchy {\n+\n+    /** The processing environment; used for creating annotations. */\n+    ProcessingEnvironment processingEnv;\n+\n+    /**\n+     * Creates a SubtypeIsSubsetQualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers for this hierarchy\n+     * @param processingEnv processing environment\n+     */\n+    public SubtypeIsSubsetQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            ProcessingEnvironment processingEnv) {\n+        super(qualifierClasses, processingEnv.getElementUtils());\n+        this.processingEnv = processingEnv;\n+    }\n+\n+    @Override\n+    protected boolean isSubtypeWithElements(\n+            AnnotationMirror subAnno,\n+            QualifierKind subKind,\n+            AnnotationMirror superAnno,\n+            QualifierKind superKind) {\n+        if (subKind == superKind) {\n+            List<String> superValues = extractValues(superAnno);\n+            List<String> subValues = extractValues(subAnno);\n+            return superValues.containsAll(subValues);\n+        }\n+        return subKind.isSubtypeOf(superKind);\n+    }\n+\n+    @Override\n+    protected AnnotationMirror leastUpperBoundWithElements(\n+            AnnotationMirror a1,\n+            QualifierKind qualifierKind1,\n+            AnnotationMirror a2,\n+            QualifierKind qualifierKind2,\n+            QualifierKind lubKind) {\n+        if (qualifierKind1 == qualifierKind2) {\n+            List<String> a1Values = extractValues(a1);\n+            List<String> a2Values = extractValues(a2);\n+            LinkedHashSet<String> set = new LinkedHashSet<>(a1Values);\n+            set.addAll(a2Values);\n+            return createAnnotationMirrorWithValue(lubKind, set);\n+        } else if (lubKind == qualifierKind1) {\n+            return a1;\n+        } else if (lubKind == qualifierKind2) {\n+            return a2;\n+        } else {\n+            throw new BugInCF(\n+                    \"Unexpected QualifierKinds %s %s\", qualifierKind1, qualifierKind2, lubKind);\n+        }\n+    }\n+\n+    @Override\n+    protected AnnotationMirror greatestLowerBoundWithElements(\n+            AnnotationMirror a1,\n+            QualifierKind qualifierKind1,\n+            AnnotationMirror a2,\n+            QualifierKind qualifierKind2,\n+            QualifierKind glbKind) {\n+        if (qualifierKind1 == qualifierKind2) {\n+            List<String> a1Values = extractValues(a1);\n+            List<String> a2Values = extractValues(a2);\n+            LinkedHashSet<String> set = new LinkedHashSet<>(a1Values);\n+            set.retainAll(a2Values);\n+            return createAnnotationMirrorWithValue(glbKind, set);\n+        } else if (glbKind == qualifierKind1) {\n+            return a1;\n+        } else if (glbKind == qualifierKind2) {\n+            return a2;\n+        } else {\n+            throw new BugInCF(\n+                    \"Unexpected QualifierKinds %s %s\", qualifierKind1, qualifierKind2, glbKind);\n+        }\n+    }\n+\n+    /**\n+     * Returns a mutable list containing the {@code values} element of the given annotation.\n+     *\n+     * @param anno an annotation\n+     * @return a mutable list containing the {@code values} element; may be the empty list\n+     */\n+    private List<String> extractValues(AnnotationMirror anno) {", "originalCommit": "06f6423ed3db335f5442795460c4ae0d2947f9b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cbc612e5f68c9cf1ee7eb25bf79bbeaa190275b3", "url": "https://github.com/typetools/checker-framework/commit/cbc612e5f68c9cf1ee7eb25bf79bbeaa190275b3", "message": "Improve documentation", "committedDate": "2020-11-03T19:04:12Z", "type": "commit"}]}