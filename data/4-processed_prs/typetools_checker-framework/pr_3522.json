{"pr_number": 3522, "pr_title": "Routines to format AnalysisResult objects for debugging/logging", "pr_createdAt": "2020-07-29T04:45:13Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3522", "timeline": [{"oid": "90cdc60c3f8da2b200f67d7a378d5890d0b2782a", "url": "https://github.com/typetools/checker-framework/commit/90cdc60c3f8da2b200f67d7a378d5890d0b2782a", "message": "Routines to format AnalysisResult objects", "committedDate": "2020-07-29T01:23:20Z", "type": "commit"}, {"oid": "62376b72e828ddcd2e1d86abe4111e64f3499666", "url": "https://github.com/typetools/checker-framework/commit/62376b72e828ddcd2e1d86abe4111e64f3499666", "message": "Merge ../checker-framework-branch-master into analysisresult-repr", "committedDate": "2020-07-29T01:26:53Z", "type": "commit"}, {"oid": "c057cdf2b15de8ab67a8bc488c2831acef81f16b", "url": "https://github.com/typetools/checker-framework/commit/c057cdf2b15de8ab67a8bc488c2831acef81f16b", "message": "Fix issues", "committedDate": "2020-07-29T03:50:21Z", "type": "commit"}, {"oid": "fe18877d5c2d1d9b7d8bbae0f415f590d5be0d25", "url": "https://github.com/typetools/checker-framework/commit/fe18877d5c2d1d9b7d8bbae0f415f590d5be0d25", "message": "Javadoc fixes", "committedDate": "2020-07-29T04:24:37Z", "type": "commit"}, {"oid": "702f803d8d4afa900a0bdd5be907b8a68e05c3c3", "url": "https://github.com/typetools/checker-framework/commit/702f803d8d4afa900a0bdd5be907b8a68e05c3c3", "message": "Add a repr() method for ControlFlowGraph", "committedDate": "2020-07-29T20:49:15Z", "type": "commit"}, {"oid": "2f6efa5b7525c0b0fbb629b54541ede2ec4648cf", "url": "https://github.com/typetools/checker-framework/commit/2f6efa5b7525c0b0fbb629b54541ede2ec4648cf", "message": "Add SystemUtil.sleep method", "committedDate": "2020-07-29T21:35:13Z", "type": "commit"}, {"oid": "d1045e1f5b2e7b01f51a3feab1f06c1486712949", "url": "https://github.com/typetools/checker-framework/commit/d1045e1f5b2e7b01f51a3feab1f06c1486712949", "message": "Remove stray character", "committedDate": "2020-07-29T23:31:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NTU0Mg==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r462655542", "bodyText": "Is there a reason to not simply override toString? That would be easier to find for people.", "author": "wmdietl", "createdAt": "2020-07-29T23:56:58Z", "path": "dataflow/src/main/java/org/checkerframework/dataflow/analysis/AnalysisResult.java", "diffHunk": "@@ -443,4 +445,124 @@ public S getStoreAfter(Block block) {\n         return transferInput.analysis.runAnalysisFor(\n                 node, before, transferInput, nodeValues, analysisCaches);\n     }\n+\n+    /**\n+     * Returns a string representation of this.\n+     *\n+     * @return a string representation of this\n+     */\n+    public String repr() {", "originalCommit": "d1045e1f5b2e7b01f51a3feab1f06c1486712949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5MjczOQ==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463192739", "bodyText": "This is much more verbose.  It would clutter most output and is useful for debugging.  I have updated the description.", "author": "mernst", "createdAt": "2020-07-30T18:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NTU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzNDIyNg==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463334226", "bodyText": "At the moment there is no toString method, so currently nothing useful is output at all.\nSo it's not clear what output this would clutter - at the moment any output is brief but useless.\nWhat output are you concerned about?", "author": "wmdietl", "createdAt": "2020-07-30T23:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NTU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NTIwNg==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463345206", "bodyText": "It is not the case that nothing useful is output.  Object.toString outputs the run-time class name and a unique identifier.  Users may prefer that to dozens of lines of output.  If toString is overridden, users don't have a way to get less information.  Creating a different method gives each user the option of how much output to put in logs.", "author": "mernst", "createdAt": "2020-07-31T00:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NTU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NjcxNQ==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463346715", "bodyText": "Another customary difference between toString() and repr() is that toString() reflects the abstraction or client view, whereas repr() shows the implementation or representation.  (Not every implementation of toString() and repr() follows the convention perfectly.)", "author": "mernst", "createdAt": "2020-07-31T00:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NTU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxMzA2Ng==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463813066", "bodyText": "This is the first class where we add a repr method, so I would like to understand what the motivation is and don't understand what you mean with \"customary\".\nI see 483 matches for such a repr function on GitHub for Java code. This seems popular in Python code.\nIn general it seems more useful to output concrete information instead of what Object.toString gives. If the behavior of Object.toString is really desired in some place, one can simply call getClass and hashCode instead.\nSo far in similar classes we have overriden toString. What makes these classes special to not do the same?", "author": "wmdietl", "createdAt": "2020-07-31T20:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NTU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3ODIxMw==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463878213", "bodyText": "This is the first class where we add a repr method, so I would like to understand what the motivation is\n\nI added text from this conversation to the developer manual.\n\nIn general it seems more useful to output concrete information instead of what Object.toString gives.\n\nIt is useful to give clients a choice about what information to output.\n\nSo far in similar classes we have overriden toString. What makes these classes special to not do the same?\n\nThe difference is not the classes, the difference is the methods.", "author": "mernst", "createdAt": "2020-07-31T22:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NTU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1Njc3Mw==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r462656773", "bodyText": "Any reason for not making this Node.toString?", "author": "wmdietl", "createdAt": "2020-07-30T00:00:56Z", "path": "dataflow/src/main/java/org/checkerframework/dataflow/analysis/AnalysisResult.java", "diffHunk": "@@ -443,4 +445,124 @@ public S getStoreAfter(Block block) {\n         return transferInput.analysis.runAnalysisFor(\n                 node, before, transferInput, nodeValues, analysisCaches);\n     }\n+\n+    /**\n+     * Returns a string representation of this.\n+     *\n+     * @return a string representation of this\n+     */\n+    public String repr() {\n+        StringJoiner result =\n+                new StringJoiner(\n+                        String.format(\"%n  \"),\n+                        String.format(\"AnalysisResult{%n  \"),\n+                        String.format(\"%n}\"));\n+        result.add(\"nodeValues = \" + nodeValuesRepr(nodeValues));\n+        result.add(\"treeLookup = \" + treeLookupRepr(treeLookup));\n+        result.add(\"unaryAssignNodeLookup = \" + unaryAssignNodeLookup);\n+        result.add(\"finalLocalValues = \" + finalLocalValues);\n+        result.add(\"stores = \" + stores);\n+        result.add(\"analysisCaches = \" + analysisCaches);\n+        return result.toString();\n+    }\n+\n+    /**\n+     * Return a printed representation of a map with the same type as the {@code nodeValues} field.\n+     *\n+     * @param <V> the type of values in the map\n+     * @param nodeValues a map to format\n+     * @return a printed representation of the given map\n+     */\n+    public static <V> String nodeValuesRepr(Map<Node, V> nodeValues) {\n+        if (nodeValues.isEmpty()) {\n+            return \"{}\";\n+        }\n+        StringJoiner result = new StringJoiner(String.format(\"%n    \"));\n+        result.add(\"{\");\n+        for (Map.Entry<Node, V> entry : nodeValues.entrySet()) {\n+            Node key = entry.getKey();\n+            result.add(String.format(\"%s => %s\", nodeRepr(key), entry.getValue()));\n+        }\n+        result.add(\"}\");\n+        return result.toString();\n+    }\n+\n+    /**\n+     * Return a printed representation of a node.\n+     *\n+     * @param n a node to format\n+     * @return a printed representation of the given node\n+     */\n+    public static String nodeRepr(Node n) {", "originalCommit": "d1045e1f5b2e7b01f51a3feab1f06c1486712949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5Mjc1OA==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463192758", "bodyText": "Same reason.", "author": "mernst", "createdAt": "2020-07-30T18:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1Njc3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzNDQ4Mg==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463334482", "bodyText": "Node currently doesn't have a toString method and nobody will look for a method here.\nI would be for either moving this to Node.toString or at least to Node.repr to have the implementation in the corresponding class.", "author": "wmdietl", "createdAt": "2020-07-30T23:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1Njc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NzAwMg==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r462657002", "bodyText": "You wouldn't need this if you moved nodeRepr into Node.toString, right?", "author": "wmdietl", "createdAt": "2020-07-30T00:01:41Z", "path": "dataflow/src/main/java/org/checkerframework/dataflow/analysis/AnalysisResult.java", "diffHunk": "@@ -443,4 +445,124 @@ public S getStoreAfter(Block block) {\n         return transferInput.analysis.runAnalysisFor(\n                 node, before, transferInput, nodeValues, analysisCaches);\n     }\n+\n+    /**\n+     * Returns a string representation of this.\n+     *\n+     * @return a string representation of this\n+     */\n+    public String repr() {\n+        StringJoiner result =\n+                new StringJoiner(\n+                        String.format(\"%n  \"),\n+                        String.format(\"AnalysisResult{%n  \"),\n+                        String.format(\"%n}\"));\n+        result.add(\"nodeValues = \" + nodeValuesRepr(nodeValues));\n+        result.add(\"treeLookup = \" + treeLookupRepr(treeLookup));\n+        result.add(\"unaryAssignNodeLookup = \" + unaryAssignNodeLookup);\n+        result.add(\"finalLocalValues = \" + finalLocalValues);\n+        result.add(\"stores = \" + stores);\n+        result.add(\"analysisCaches = \" + analysisCaches);\n+        return result.toString();\n+    }\n+\n+    /**\n+     * Return a printed representation of a map with the same type as the {@code nodeValues} field.\n+     *\n+     * @param <V> the type of values in the map\n+     * @param nodeValues a map to format\n+     * @return a printed representation of the given map\n+     */\n+    public static <V> String nodeValuesRepr(Map<Node, V> nodeValues) {\n+        if (nodeValues.isEmpty()) {\n+            return \"{}\";\n+        }\n+        StringJoiner result = new StringJoiner(String.format(\"%n    \"));\n+        result.add(\"{\");\n+        for (Map.Entry<Node, V> entry : nodeValues.entrySet()) {\n+            Node key = entry.getKey();\n+            result.add(String.format(\"%s => %s\", nodeRepr(key), entry.getValue()));\n+        }\n+        result.add(\"}\");\n+        return result.toString();\n+    }\n+\n+    /**\n+     * Return a printed representation of a node.\n+     *\n+     * @param n a node to format\n+     * @return a printed representation of the given node\n+     */\n+    public static String nodeRepr(Node n) {\n+        return String.format(\n+                \"%s [%s %s %s]\",\n+                n, n.getClass().getSimpleName(), n.hashCode(), System.identityHashCode(n));\n+    }\n+\n+    /**\n+     * Return a printed representation of a collection of nodes.\n+     *\n+     * @param nodes a collection of nodes to format\n+     * @return a printed representation of the given collection\n+     */\n+    public static String nodeCollectionRepr(Collection<? extends Node> nodes) {", "originalCommit": "d1045e1f5b2e7b01f51a3feab1f06c1486712949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5MjYzOQ==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463192639", "bodyText": "Yes, I agree.  However, that would make general use of toString excessively verbose.", "author": "mernst", "createdAt": "2020-07-30T18:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NzAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzNDY0OA==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463334648", "bodyText": "What \"general uses\" are you concerned about?", "author": "wmdietl", "createdAt": "2020-07-30T23:58:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NzAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1ODA1NQ==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r462658055", "bodyText": "I'm a bit confused why you would need that here. We throw BugInCF in many places, so if this is a general problem, should that be solved where BugInCF is output?", "author": "wmdietl", "createdAt": "2020-07-30T00:05:15Z", "path": "dataflow/src/main/java/org/checkerframework/dataflow/analysis/AnalysisResult.java", "diffHunk": "@@ -443,4 +445,124 @@ public S getStoreAfter(Block block) {\n         return transferInput.analysis.runAnalysisFor(\n                 node, before, transferInput, nodeValues, analysisCaches);\n     }\n+\n+    /**\n+     * Returns a string representation of this.\n+     *\n+     * @return a string representation of this\n+     */\n+    public String repr() {\n+        StringJoiner result =\n+                new StringJoiner(\n+                        String.format(\"%n  \"),\n+                        String.format(\"AnalysisResult{%n  \"),\n+                        String.format(\"%n}\"));\n+        result.add(\"nodeValues = \" + nodeValuesRepr(nodeValues));\n+        result.add(\"treeLookup = \" + treeLookupRepr(treeLookup));\n+        result.add(\"unaryAssignNodeLookup = \" + unaryAssignNodeLookup);\n+        result.add(\"finalLocalValues = \" + finalLocalValues);\n+        result.add(\"stores = \" + stores);\n+        result.add(\"analysisCaches = \" + analysisCaches);\n+        return result.toString();\n+    }\n+\n+    /**\n+     * Return a printed representation of a map with the same type as the {@code nodeValues} field.\n+     *\n+     * @param <V> the type of values in the map\n+     * @param nodeValues a map to format\n+     * @return a printed representation of the given map\n+     */\n+    public static <V> String nodeValuesRepr(Map<Node, V> nodeValues) {\n+        if (nodeValues.isEmpty()) {\n+            return \"{}\";\n+        }\n+        StringJoiner result = new StringJoiner(String.format(\"%n    \"));\n+        result.add(\"{\");\n+        for (Map.Entry<Node, V> entry : nodeValues.entrySet()) {\n+            Node key = entry.getKey();\n+            result.add(String.format(\"%s => %s\", nodeRepr(key), entry.getValue()));\n+        }\n+        result.add(\"}\");\n+        return result.toString();\n+    }\n+\n+    /**\n+     * Return a printed representation of a node.\n+     *\n+     * @param n a node to format\n+     * @return a printed representation of the given node\n+     */\n+    public static String nodeRepr(Node n) {\n+        return String.format(\n+                \"%s [%s %s %s]\",\n+                n, n.getClass().getSimpleName(), n.hashCode(), System.identityHashCode(n));\n+    }\n+\n+    /**\n+     * Return a printed representation of a collection of nodes.\n+     *\n+     * @param nodes a collection of nodes to format\n+     * @return a printed representation of the given collection\n+     */\n+    public static String nodeCollectionRepr(Collection<? extends Node> nodes) {\n+        StringJoiner result = new StringJoiner(\", \", \"[\", \"]\");\n+        for (Node n : nodes) {\n+            result.add(nodeRepr(n));\n+        }\n+        return result.toString();\n+    }\n+\n+    /**\n+     * Return a printed representation of a map with the same type as the {@code treeLookup} field.\n+     *\n+     * @param treeLookup a map to format\n+     * @return a printed representation of the given map\n+     */\n+    public static String treeLookupRepr(Map<Tree, Set<Node>> treeLookup) {\n+        if (treeLookup.isEmpty()) {\n+            return \"{}\";\n+        }\n+        StringJoiner result = new StringJoiner(String.format(\"%n    \"));\n+        result.add(\"{\");\n+        for (Map.Entry<Tree, Set<Node>> entry : treeLookup.entrySet()) {\n+            Tree key = entry.getKey();\n+            String treeString = key.toString().replaceAll(\"[ \\n\\t]+\", \" \");\n+            if (treeString.length() > 65) {\n+                treeString = \"\\\"\" + treeString.substring(0, 60) + \"...\\\"\";\n+            }\n+            result.add(treeString + \" => \" + nodeCollectionRepr(entry.getValue()));\n+        }\n+        result.add(\"}\");\n+        return result.toString();\n+    }\n+\n+    /** Checks representation invariants on this. */\n+    public void checkRep() {\n+        // Require that each node in treeLookup exists in nodeValues.\n+        for (Map.Entry<Tree, Set<Node>> entry : treeLookup.entrySet()) {\n+            for (Node n : entry.getValue()) {\n+                if (!nodeValues.containsKey(n)) {\n+                    sleep(100);", "originalCommit": "d1045e1f5b2e7b01f51a3feab1f06c1486712949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5MjUwMg==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463192502", "bodyText": "That doesn't work.  I'm not sure why.  Without this, printf output is interspersed.  Understanding why would be useful, but is outside the scope of this pull request.", "author": "mernst", "createdAt": "2020-07-30T18:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1ODA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzNTc4OA==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463335788", "bodyText": "Can you at least add a TODO comment here to remark why it is here? This is very surprising and should be highlighted and fixed.", "author": "wmdietl", "createdAt": "2020-07-31T00:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1ODA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1ODkwNg==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r462658906", "bodyText": "I don't understand the new comment. The method returns a copy of that one field, like getUnaryAssignNodeLookup returns a copy of that field.\nIs this more a to-do comment that we need a method to also access the convertedTreeLookup?", "author": "wmdietl", "createdAt": "2020-07-30T00:08:03Z", "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/ControlFlowGraph.java", "diffHunk": "@@ -235,7 +237,7 @@ public UnderlyingAST getUnderlyingAST() {\n     }\n \n     /**\n-     * Returns the copied tree-lookup map.\n+     * Returns the copied tree-lookup map. Ignores convertedTreeLookup.", "originalCommit": "d1045e1f5b2e7b01f51a3feab1f06c1486712949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5MjQ0Ng==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463192446", "bodyText": "The way that the tree-lookup map is accessed is via getNodesCorrespondingToTree.  That method makes use of both convertedTreeLookup and treeLookup.  I'm not sure why there is a need for a public method that makes a copy of treeLookup, but any client will be inconsistent with getNodesCorrespondingToTree.  So it is useful to provide a warning to clients.", "author": "mernst", "createdAt": "2020-07-30T18:32:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1ODkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1OTQ1NQ==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r462659455", "bodyText": "If stringGraph is null, you could use repr instead of the un-helpful super implementation.", "author": "wmdietl", "createdAt": "2020-07-30T00:10:05Z", "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/ControlFlowGraph.java", "diffHunk": "@@ -303,4 +305,32 @@ public String toString() {\n         String stringGraph = (String) res.get(\"stringGraph\");\n         return stringGraph == null ? super.toString() : stringGraph;", "originalCommit": "d1045e1f5b2e7b01f51a3feab1f06c1486712949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NzM5NQ==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463347395", "bodyText": "That's a change to toString(), and repr() is more about the internal implementation.  (Also, this pull request doesn't make any changes to toString().)  Should the code instead throw BugInCF if stringGraph is null?  A separate pull request could do that.", "author": "mernst", "createdAt": "2020-07-31T00:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1OTQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1OTQ4MQ==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r462659481", "bodyText": "There already is a toString method in this class. Can you add cross-references and explain when to use which?", "author": "wmdietl", "createdAt": "2020-07-30T00:10:10Z", "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/ControlFlowGraph.java", "diffHunk": "@@ -303,4 +305,32 @@ public String toString() {\n         String stringGraph = (String) res.get(\"stringGraph\");\n         return stringGraph == null ? super.toString() : stringGraph;\n     }\n+\n+    /**\n+     * Returns a string representation of this.\n+     *\n+     * @return a string representation of this\n+     */\n+    public String repr() {", "originalCommit": "d1045e1f5b2e7b01f51a3feab1f06c1486712949", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4c9b3cdeb7d4aaa34c2d0bc4725e4a35819df448", "url": "https://github.com/typetools/checker-framework/commit/4c9b3cdeb7d4aaa34c2d0bc4725e4a35819df448", "message": "Address code review feedback", "committedDate": "2020-07-30T17:58:12Z", "type": "commit"}, {"oid": "b4a3db74a8ea70ae6f649ee99a86841422b729d5", "url": "https://github.com/typetools/checker-framework/commit/b4a3db74a8ea70ae6f649ee99a86841422b729d5", "message": "Merge ../checker-framework-branch-master into analysisresult-repr", "committedDate": "2020-07-30T17:58:31Z", "type": "commit"}, {"oid": "3e37f6f38c46ab6e04e5d347a83142787ae0e1e5", "url": "https://github.com/typetools/checker-framework/commit/3e37f6f38c46ab6e04e5d347a83142787ae0e1e5", "message": "Merge ../checker-framework-fork-mernst-branch-javacutil-sleep into analysisresult-repr", "committedDate": "2020-07-30T17:58:38Z", "type": "commit"}, {"oid": "31f73b834d729bb1a129254dc36c15eba8c6f321", "url": "https://github.com/typetools/checker-framework/commit/31f73b834d729bb1a129254dc36c15eba8c6f321", "message": "Fix import statement", "committedDate": "2020-07-30T18:00:06Z", "type": "commit"}, {"oid": "cf227e1546f99530972b1958fade1d49ce6c56d3", "url": "https://github.com/typetools/checker-framework/commit/cf227e1546f99530972b1958fade1d49ce6c56d3", "message": "Merge ../checker-framework-branch-master into javacutil-sleep", "committedDate": "2020-07-30T18:34:12Z", "type": "commit"}, {"oid": "ffc8fc96e1c6208587ef5dd00d1d1942bb7fa557", "url": "https://github.com/typetools/checker-framework/commit/ffc8fc96e1c6208587ef5dd00d1d1942bb7fa557", "message": "Fix typo, remove throw", "committedDate": "2020-07-30T18:35:29Z", "type": "commit"}, {"oid": "b5f101be41777cbca9b2059e0dd27ac42d3974b6", "url": "https://github.com/typetools/checker-framework/commit/b5f101be41777cbca9b2059e0dd27ac42d3974b6", "message": "Merge ../checker-framework-fork-mernst-branch-javacutil-sleep into analysisresult-repr", "committedDate": "2020-07-30T18:36:19Z", "type": "commit"}, {"oid": "1f01fcd77768143c925702ba09704d219d6be386", "url": "https://github.com/typetools/checker-framework/commit/1f01fcd77768143c925702ba09704d219d6be386", "message": "Address code review feedback", "committedDate": "2020-07-31T00:39:10Z", "type": "commit"}, {"oid": "6b00d1ee87f4a700f8d559e43f43408791b5c560", "url": "https://github.com/typetools/checker-framework/commit/6b00d1ee87f4a700f8d559e43f43408791b5c560", "message": "Merge ../checker-framework-branch-master into analysisresult-repr", "committedDate": "2020-07-31T00:39:32Z", "type": "commit"}, {"oid": "6d76803c20c7eaa3626f30392e374576007d3507", "url": "https://github.com/typetools/checker-framework/commit/6d76803c20c7eaa3626f30392e374576007d3507", "message": "More changes from code review", "committedDate": "2020-07-31T00:42:01Z", "type": "commit"}, {"oid": "0453ce127f30b155ad3f286203631fd668a34231", "url": "https://github.com/typetools/checker-framework/commit/0453ce127f30b155ad3f286203631fd668a34231", "message": "Merge ../checker-framework-branch-master into analysisresult-repr", "committedDate": "2020-07-31T00:47:13Z", "type": "commit"}, {"oid": "20f244c9e235dd2d2a7399147dc2d132db133371", "url": "https://github.com/typetools/checker-framework/commit/20f244c9e235dd2d2a7399147dc2d132db133371", "message": "Merge ../checker-framework-branch-master into analysisresult-repr", "committedDate": "2020-07-31T05:43:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgwODgzNA==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r463808834", "bodyText": "What printf output is this referring to? Throwing a BugInCF outputs the message using the compiler messager and should happen one at a time. In general, the compiler is single-threaded and a sleep seems very inappropriate.\nIs this maybe from running gradle concurrently?\nHow can I reproduce this issue?\nAs this checkRep method isn't called anywhere, how about moving this method to a separate PR?", "author": "wmdietl", "createdAt": "2020-07-31T20:04:12Z", "path": "dataflow/src/main/java/org/checkerframework/dataflow/analysis/AnalysisResult.java", "diffHunk": "@@ -443,4 +445,85 @@ public S getStoreAfter(Block block) {\n         return transferInput.analysis.runAnalysisFor(\n                 node, before, transferInput, nodeValues, analysisCaches);\n     }\n+\n+    /**\n+     * Returns a verbose string representation of this, useful for debugging.\n+     *\n+     * @return a string representation of this\n+     */\n+    public String repr() {\n+        StringJoiner result =\n+                new StringJoiner(\n+                        String.format(\"%n  \"),\n+                        String.format(\"AnalysisResult{%n  \"),\n+                        String.format(\"%n}\"));\n+        result.add(\"nodeValues = \" + nodeValuesRepr(nodeValues));\n+        result.add(\"treeLookup = \" + treeLookupRepr(treeLookup));\n+        result.add(\"unaryAssignNodeLookup = \" + unaryAssignNodeLookup);\n+        result.add(\"finalLocalValues = \" + finalLocalValues);\n+        result.add(\"stores = \" + stores);\n+        result.add(\"analysisCaches = \" + analysisCaches);\n+        return result.toString();\n+    }\n+\n+    /**\n+     * Returns a verbose printed representation, useful for debugging. The map has the same type as\n+     * the {@code nodeValues} field.\n+     *\n+     * @param <V> the type of values in the map\n+     * @param nodeValues a map to format\n+     * @return a printed representation of the given map\n+     */\n+    public static <V> String nodeValuesRepr(Map<Node, V> nodeValues) {\n+        if (nodeValues.isEmpty()) {\n+            return \"{}\";\n+        }\n+        StringJoiner result = new StringJoiner(String.format(\"%n    \"));\n+        result.add(\"{\");\n+        for (Map.Entry<Node, V> entry : nodeValues.entrySet()) {\n+            Node key = entry.getKey();\n+            result.add(String.format(\"%s => %s\", key.repr(), entry.getValue()));\n+        }\n+        result.add(\"}\");\n+        return result.toString();\n+    }\n+\n+    /**\n+     * Returns a verbose printed representation of a map, useful for debugging. The map has the same\n+     * type as the {@code treeLookup} field.\n+     *\n+     * @param treeLookup a map to format\n+     * @return a printed representation of the given map\n+     */\n+    public static String treeLookupRepr(Map<Tree, Set<Node>> treeLookup) {\n+        if (treeLookup.isEmpty()) {\n+            return \"{}\";\n+        }\n+        StringJoiner result = new StringJoiner(String.format(\"%n    \"));\n+        result.add(\"{\");\n+        for (Map.Entry<Tree, Set<Node>> entry : treeLookup.entrySet()) {\n+            Tree key = entry.getKey();\n+            String treeString = key.toString().replaceAll(\"[ \\n\\t]+\", \" \");\n+            if (treeString.length() > 65) {\n+                treeString = \"\\\"\" + treeString.substring(0, 60) + \"...\\\"\";\n+            }\n+            result.add(treeString + \" => \" + Node.nodeCollectionRepr(entry.getValue()));\n+        }\n+        result.add(\"}\");\n+        return result.toString();\n+    }\n+\n+    /** Checks representation invariants on this. */\n+    public void checkRep() {\n+        // Require that each node in treeLookup exists in nodeValues.\n+        for (Map.Entry<Tree, Set<Node>> entry : treeLookup.entrySet()) {\n+            for (Node n : entry.getValue()) {\n+                if (!nodeValues.containsKey(n)) {\n+                    SystemUtil.sleep(100); // without this, printf output is sometimes interleaved", "originalCommit": "20f244c9e235dd2d2a7399147dc2d132db133371", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6b2cec3252aeb1e078345affb8d79a87e7fdedc6", "url": "https://github.com/typetools/checker-framework/commit/6b2cec3252aeb1e078345affb8d79a87e7fdedc6", "message": "Merge ../checker-framework-branch-master into analysisresult-repr", "committedDate": "2020-07-31T21:40:39Z", "type": "commit"}, {"oid": "ca602606430fcf115810dfd2435a0282a9157614", "url": "https://github.com/typetools/checker-framework/commit/ca602606430fcf115810dfd2435a0282a9157614", "message": "Remove AnalysisResult.checkRep", "committedDate": "2020-07-31T21:43:56Z", "type": "commit"}, {"oid": "6e10edb05ba229d7867dd02f50e13731f66ee819", "url": "https://github.com/typetools/checker-framework/commit/6e10edb05ba229d7867dd02f50e13731f66ee819", "message": "Merge ../checker-framework-branch-master into analysisresult-repr", "committedDate": "2020-07-31T21:46:09Z", "type": "commit"}, {"oid": "835d152d29d901ea133ea03a60fe8f4c05f644b8", "url": "https://github.com/typetools/checker-framework/commit/835d152d29d901ea133ea03a60fe8f4c05f644b8", "message": "Explain repr()", "committedDate": "2020-07-31T22:51:09Z", "type": "commit"}, {"oid": "f0fc6cc3938f2f0927be91b65e9f6ee01cd8a11f", "url": "https://github.com/typetools/checker-framework/commit/f0fc6cc3938f2f0927be91b65e9f6ee01cd8a11f", "message": "Tweak wording", "committedDate": "2020-07-31T23:28:07Z", "type": "commit"}, {"oid": "cbdde4bb6e265d1da1cb22ad4e2a5bb0972364cc", "url": "https://github.com/typetools/checker-framework/commit/cbdde4bb6e265d1da1cb22ad4e2a5bb0972364cc", "message": "Fix HTML tag", "committedDate": "2020-08-01T14:31:23Z", "type": "commit"}, {"oid": "4bcb7efb22ebffe76411e9e7c53faee037a28b6e", "url": "https://github.com/typetools/checker-framework/commit/4bcb7efb22ebffe76411e9e7c53faee037a28b6e", "message": "Merge ../checker-framework-branch-master into analysisresult-repr", "committedDate": "2020-08-01T17:55:26Z", "type": "commit"}, {"oid": "49548c0a8a64087f88d93a16a0536a0d04464f4e", "url": "https://github.com/typetools/checker-framework/commit/49548c0a8a64087f88d93a16a0536a0d04464f4e", "message": "Merge ../checker-framework-branch-master into analysisresult-repr", "committedDate": "2020-08-03T22:22:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2OTUzNA==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r465369534", "bodyText": "For consistency, in a few places in this PR, I would replace the printed with string.", "author": "wmdietl", "createdAt": "2020-08-04T22:39:44Z", "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/node/Node.java", "diffHunk": "@@ -157,4 +158,32 @@ public void setAssignmentContext(AssignmentContext assignmentContext) {\n         }\n         return transitiveOperands;\n     }\n+\n+    /**\n+     * Returns a verbose printed representation of this, useful for debugging.", "originalCommit": "49548c0a8a64087f88d93a16a0536a0d04464f4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyNDAzMg==", "url": "https://github.com/typetools/checker-framework/pull/3522#discussion_r465424032", "bodyText": "I agree.  That was for consistency with existing methods' documentation, but I have changed those too.", "author": "mernst", "createdAt": "2020-08-05T01:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2OTUzNA=="}], "type": "inlineReview"}, {"oid": "06a1b9a6cb49f9ad94a72ad49319ec36aee62cc1", "url": "https://github.com/typetools/checker-framework/commit/06a1b9a6cb49f9ad94a72ad49319ec36aee62cc1", "message": "Merge ../checker-framework-branch-master into analysisresult-repr", "committedDate": "2020-08-05T01:45:32Z", "type": "commit"}, {"oid": "bc2dc10e8b41e436c36c428dfb4a0a9b6eb00e19", "url": "https://github.com/typetools/checker-framework/commit/bc2dc10e8b41e436c36c428dfb4a0a9b6eb00e19", "message": "\"printed\" => \"string\"", "committedDate": "2020-08-05T01:45:57Z", "type": "commit"}, {"oid": "1eb6ddd579b9a016c257f614ecfcbba221fb0749", "url": "https://github.com/typetools/checker-framework/commit/1eb6ddd579b9a016c257f614ecfcbba221fb0749", "message": "\"repr()\" => \"toStringDebug()\"", "committedDate": "2020-08-05T03:34:31Z", "type": "commit"}, {"oid": "9741aff12ba7f66aec1fec04b1afef6f49b95e9d", "url": "https://github.com/typetools/checker-framework/commit/9741aff12ba7f66aec1fec04b1afef6f49b95e9d", "message": "Add Javadoc", "committedDate": "2020-08-05T04:21:02Z", "type": "commit"}, {"oid": "3e84c679607856b4c52a5895cb57f36c6f24f75d", "url": "https://github.com/typetools/checker-framework/commit/3e84c679607856b4c52a5895cb57f36c6f24f75d", "message": "Merge ../checker-framework-branch-master into analysisresult-repr", "committedDate": "2020-08-05T04:21:31Z", "type": "commit"}, {"oid": "07a431334bfe83bea736a9bdcf74382d721f1eaf", "url": "https://github.com/typetools/checker-framework/commit/07a431334bfe83bea736a9bdcf74382d721f1eaf", "message": "Fix Javadoc", "committedDate": "2020-08-05T10:22:50Z", "type": "commit"}]}