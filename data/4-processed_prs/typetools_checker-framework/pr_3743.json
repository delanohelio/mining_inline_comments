{"pr_number": 3743, "pr_title": "Support disabling returns receiver checker in an accumulation checker", "pr_createdAt": "2020-10-07T00:47:09Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3743", "timeline": [{"oid": "dc94243fac0578aee52d395bb22bf08a10e57c11", "url": "https://github.com/typetools/checker-framework/commit/dc94243fac0578aee52d395bb22bf08a10e57c11", "message": "support disabling RR checker in an accumulation checker", "committedDate": "2020-10-07T00:44:14Z", "type": "commit"}, {"oid": "87431a194a3a462629ee3547be60481a1aae81bb", "url": "https://github.com/typetools/checker-framework/commit/87431a194a3a462629ee3547be60481a1aae81bb", "message": "fix minor issue in CalledMethodsChecker that this PR exposed", "committedDate": "2020-10-07T18:28:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4MzM5NA==", "url": "https://github.com/typetools/checker-framework/pull/3743#discussion_r501383394", "bodyText": "This is coded as if enabling any AliasAnalysis will require enabling a sub-checker.  Is that the intention?  I'm not really sure how future alias reasoning might look.  In any case, this code might be clearer for now by just checking if aliasAnalyses contains RETURNS_RECEIVER, rather than looping and doing a switch.", "author": "msridhar", "createdAt": "2020-10-08T00:27:34Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationChecker.java", "diffHunk": "@@ -10,20 +13,71 @@\n  * An accumulation checker is one that accumulates some property: method calls, map keys, etc.\n  *\n  * <p>This class provides a basic accumulation analysis that can be extended to implement an\n- * accumulation type system. This accumulation analysis represents all facts as Strings. It\n- * automatically includes returns-receiver aliasing to precisely handle fluent APIs, but otherwise\n- * uses no alias analysis.\n+ * accumulation type system. This accumulation analysis represents all facts as Strings.\n+ *\n+ * <p>This class supports modular alias analyses. To choose the alias analyses that your\n+ * accumulation checker uses, override the {@link #createAliasAnalyses()} method. By default, the\n+ * only alias analysis used is Returns Receiver.\n  *\n  * <p>The primary extension point is the constructor of {@link AccumulationAnnotatedTypeFactory},\n  * which every subclass should override to provide custom annotations.\n  */\n public abstract class AccumulationChecker extends BaseTypeChecker {\n \n+    /**\n+     * Set of alias analyses that are enabled in this particular accumulation checker. Set to\n+     * non-null the first time {@link #isEnabled(AliasAnalysis)} is called, to allow the\n+     * implementation of {@link #createAliasAnalyses()} to be as simple as possible.\n+     */\n+    private @MonotonicNonNull EnumSet<AliasAnalysis> aliasAnalyses;\n+\n     @Override\n     protected LinkedHashSet<Class<? extends BaseTypeChecker>> getImmediateSubcheckerClasses() {\n         LinkedHashSet<Class<? extends BaseTypeChecker>> checkers =\n                 super.getImmediateSubcheckerClasses();\n-        checkers.add(ReturnsReceiverChecker.class);\n+        AliasAnalysis[] aliasAnalyses = createAliasAnalyses();", "originalCommit": "87431a194a3a462629ee3547be60481a1aae81bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg3ODUxNg==", "url": "https://github.com/typetools/checker-framework/pull/3743#discussion_r501878516", "bodyText": "That's a fair point. I'll change this.", "author": "kelloggm", "createdAt": "2020-10-08T17:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4MzM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4MzU5Ng==", "url": "https://github.com/typetools/checker-framework/pull/3743#discussion_r501383596", "bodyText": "Should this return an EnumSet?", "author": "msridhar", "createdAt": "2020-10-08T00:28:25Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationChecker.java", "diffHunk": "@@ -10,20 +13,71 @@\n  * An accumulation checker is one that accumulates some property: method calls, map keys, etc.\n  *\n  * <p>This class provides a basic accumulation analysis that can be extended to implement an\n- * accumulation type system. This accumulation analysis represents all facts as Strings. It\n- * automatically includes returns-receiver aliasing to precisely handle fluent APIs, but otherwise\n- * uses no alias analysis.\n+ * accumulation type system. This accumulation analysis represents all facts as Strings.\n+ *\n+ * <p>This class supports modular alias analyses. To choose the alias analyses that your\n+ * accumulation checker uses, override the {@link #createAliasAnalyses()} method. By default, the\n+ * only alias analysis used is Returns Receiver.\n  *\n  * <p>The primary extension point is the constructor of {@link AccumulationAnnotatedTypeFactory},\n  * which every subclass should override to provide custom annotations.\n  */\n public abstract class AccumulationChecker extends BaseTypeChecker {\n \n+    /**\n+     * Set of alias analyses that are enabled in this particular accumulation checker. Set to\n+     * non-null the first time {@link #isEnabled(AliasAnalysis)} is called, to allow the\n+     * implementation of {@link #createAliasAnalyses()} to be as simple as possible.\n+     */\n+    private @MonotonicNonNull EnumSet<AliasAnalysis> aliasAnalyses;\n+\n     @Override\n     protected LinkedHashSet<Class<? extends BaseTypeChecker>> getImmediateSubcheckerClasses() {\n         LinkedHashSet<Class<? extends BaseTypeChecker>> checkers =\n                 super.getImmediateSubcheckerClasses();\n-        checkers.add(ReturnsReceiverChecker.class);\n+        AliasAnalysis[] aliasAnalyses = createAliasAnalyses();\n+        for (AliasAnalysis aliasAnalysis : aliasAnalyses) {\n+            switch (aliasAnalysis) {\n+                case RETURNS_RECEIVER:\n+                    checkers.add(ReturnsReceiverChecker.class);\n+                    break;\n+            }\n+        }\n         return checkers;\n     }\n+\n+    /**\n+     * The alias analyses that an accumulation checker can support. To add support for a new alias\n+     * analysis, add a new item to this enum, modify the loop in #getImmediateSubcheckerClasses, and\n+     * then implement whatever functionality in the annotated type factory or transfer function that\n+     * your new alias analysis permits.\n+     */\n+    public enum AliasAnalysis {\n+        RETURNS_RECEIVER\n+    }\n+\n+    /**\n+     * Get the alias analyses that this checker should employ.\n+     *\n+     * @return the alias analyses\n+     */\n+    protected AliasAnalysis[] createAliasAnalyses(@UnderInitialization AccumulationChecker this) {", "originalCommit": "87431a194a3a462629ee3547be60481a1aae81bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg3ODMyMA==", "url": "https://github.com/typetools/checker-framework/pull/3743#discussion_r501878320", "bodyText": "It returns an array rather than an enumset by design, so that overriding it is as easy as possible. With this signature, you can use the array constant syntax (as this version of the method does), which means that regardless of how many alias analyses you want to enable the method will always be very short and understandable. An enumset wouldn't be that much harder, of course, so if we think that's a lot clearer than I can change it.", "author": "kelloggm", "createdAt": "2020-10-08T17:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4MzU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk5MjczNA==", "url": "https://github.com/typetools/checker-framework/pull/3743#discussion_r501992734", "bodyText": "This is fine as is I think", "author": "msridhar", "createdAt": "2020-10-08T20:27:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4MzU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2MjczMw==", "url": "https://github.com/typetools/checker-framework/pull/3743#discussion_r502162733", "bodyText": "I had the same question as Manu when I read the code.  I think that using an array makes this less rather than more concise -- the EnumSet.of() and EnumSet.allOf() calls are slightly more concise.  Furthermore, it feels a bit convoluted, and clutters the code, to use an array that will be immediately converted to an EnumSet.", "author": "mernst", "createdAt": "2020-10-09T03:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4MzU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU3NzQ2Nw==", "url": "https://github.com/typetools/checker-framework/pull/3743#discussion_r502577467", "bodyText": "Since this was confusing for both of you, I'll change it to use an EnumSet throughout.", "author": "kelloggm", "createdAt": "2020-10-09T17:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4MzU5Ng=="}], "type": "inlineReview"}, {"oid": "2916c9f6261385f5fc84186c8582a70b482c41c1", "url": "https://github.com/typetools/checker-framework/commit/2916c9f6261385f5fc84186c8582a70b482c41c1", "message": "Merge branch 'master' of github.com:typetools/checker-framework into alias-analysis-flag", "committedDate": "2020-10-08T17:09:13Z", "type": "commit"}, {"oid": "460edd75a66553f009138e7c6631e0568ef9b6db", "url": "https://github.com/typetools/checker-framework/commit/460edd75a66553f009138e7c6631e0568ef9b6db", "message": "simplification suggested in PR", "committedDate": "2020-10-08T17:11:47Z", "type": "commit"}, {"oid": "4b774f3d879992374d6ef017b2af785cef32a3c4", "url": "https://github.com/typetools/checker-framework/commit/4b774f3d879992374d6ef017b2af785cef32a3c4", "message": "Merge ../checker-framework-branch-master into alias-analysis-flag", "committedDate": "2020-10-09T03:09:58Z", "type": "commit"}, {"oid": "f2fe417ab31376fc5e307f7b6f412da94241f931", "url": "https://github.com/typetools/checker-framework/commit/f2fe417ab31376fc5e307f7b6f412da94241f931", "message": "Documentation tweaks", "committedDate": "2020-10-09T03:22:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTQ4Mg==", "url": "https://github.com/typetools/checker-framework/pull/3743#discussion_r502165482", "bodyText": "I think this should be TypeSystemError instead.", "author": "mernst", "createdAt": "2020-10-09T03:32:03Z", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -84,6 +88,13 @@ protected AccumulationAnnotatedTypeFactory(\n             Class<? extends Annotation> bottom,\n             @Nullable Class<? extends Annotation> predicate) {\n         super(checker);\n+        if (!(checker instanceof AccumulationChecker)) {\n+            throw new BugInCF(", "originalCommit": "f2fe417ab31376fc5e307f7b6f412da94241f931", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0fd745ce4ad2680852c8306ff33ffc192134a2b1", "url": "https://github.com/typetools/checker-framework/commit/0fd745ce4ad2680852c8306ff33ffc192134a2b1", "message": "more simplifications from review", "committedDate": "2020-10-09T17:37:51Z", "type": "commit"}, {"oid": "e39d1b0ebf5d801cab770c7a8bb62b5631c15e49", "url": "https://github.com/typetools/checker-framework/commit/e39d1b0ebf5d801cab770c7a8bb62b5631c15e49", "message": "fix merge conflict", "committedDate": "2020-10-09T17:45:38Z", "type": "commit"}, {"oid": "16a5b5eeb189e295fa37c115dc2225b51011fb49", "url": "https://github.com/typetools/checker-framework/commit/16a5b5eeb189e295fa37c115dc2225b51011fb49", "message": "public -> protected for abstract class constructor", "committedDate": "2020-10-09T19:27:27Z", "type": "commit"}, {"oid": "bf64be4d493014ec51aacdf977876940a49ea586", "url": "https://github.com/typetools/checker-framework/commit/bf64be4d493014ec51aacdf977876940a49ea586", "message": "fix test checker", "committedDate": "2020-10-09T20:54:38Z", "type": "commit"}, {"oid": "f0410464f129961c0c76f1621ca2d20ec892cae9", "url": "https://github.com/typetools/checker-framework/commit/f0410464f129961c0c76f1621ca2d20ec892cae9", "message": "forgotten javadoc", "committedDate": "2020-10-09T21:43:15Z", "type": "commit"}]}