{"pr_number": 3678, "pr_title": "Mention TreeAnnotator and TypeAnnotator in \"creating a checker\"", "pr_createdAt": "2020-09-22T22:06:23Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3678", "timeline": [{"oid": "f281f11cd2fbe22964fc1d60bb6078cb84671416", "url": "https://github.com/typetools/checker-framework/commit/f281f11cd2fbe22964fc1d60bb6078cb84671416", "message": "Mention TreeAnnotator and TypeAnnotator in \"creating a checker\"", "committedDate": "2020-09-22T20:57:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3ODA5Ng==", "url": "https://github.com/typetools/checker-framework/pull/3678#discussion_r493778096", "bodyText": "PropagationTreeAnnotator isn't the only annotator that super runs.", "author": "smillst", "createdAt": "2020-09-23T17:49:06Z", "path": "docs/manual/creating-a-checker.tex", "diffHunk": "@@ -1182,29 +1182,77 @@\n \\subsectionAndLabel{Procedurally specifying type introduction rules}{creating-procedurally-specifying-implicit-annotations}\n \n If the meta-annotations are not sufficiently expressive, then you\n-can write your own type introduction rules.  To do so, create a subclass of\n-\\refclass{framework/type}{AnnotatedTypeFactory} and override its\n-two \\<addComputedTypeAnnotations> methods.\n-\n-\\<AnnotatedTypeFactory>, when given a program\n-expression, returns the expression's type.  This should include not only\n-the qualifiers that the programmer explicitly wrote in the source code, but\n-also default annotations and type\n-refinement (see Section~\\ref{effective-qualifier} for explanations of these\n-concepts).\n-\n-To add type introduction rules, you should override\n-\\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror)}\n-(or\n-\\refmethodanchortext{framework/type}{GenericAnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-boolean-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror,boolean)}\n-if extending \\code{GenericAnnotatedTypeFactory})\n-and\n-\\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-javax.lang.model.element.Element-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Element,AnnotatedTypeMirror)}.\n-The methods operate on \\refclass{framework/type}{AnnotatedTypeMirror},\n-which is the Checker Framework's representation of an annotated type.\n-The methods can make arbitrary changes to the annotations on a type.\n+can write your own type introduction rules.  There are three ways to do so.\n+\n+\\begin{enumerate}\n+\\item\n+  Define a subclass of\n+  \\refclass{org/checkerframework/framework/type/treeannotator}{TreeAnnotator},\n+  typically as a private inner class of your \\<AnnotatedTypeFactory>.\n+  There is a method of \\<TreeAnnotator> for every AST node, and the visitor\n+  has access to both the tree (the AST node) and its type.  In your\n+  subclass of \\<AnnotatedTypeFactory>, override \\<createTreeAnnotator> to\n+  return a \\<ListTreeAnnotator> containing that annotator, as in\n \n-%TODO: document tree and type annotators here, which should be used instead of override addComputedTypeAnnotations if possible.\n+\\begin{Verbatim}\n+  @Override\n+  protected TreeAnnotator createTreeAnnotator() {\n+      return new ListTreeAnnotator(super.createTreeAnnotator(), new MyTreeAnnotator(this));\n+  }\n+\\end{Verbatim}\n+\n+  \\noindent\n+  (or put your TreeAnnotator first; note that \\<PropagationTreeAnnotator>,", "originalCommit": "f281f11cd2fbe22964fc1d60bb6078cb84671416", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3OTAzNg==", "url": "https://github.com/typetools/checker-framework/pull/3678#discussion_r493779036", "bodyText": "It adds annotations to AnnotatedTypeMirrors that do not have an annotation.", "author": "smillst", "createdAt": "2020-09-23T17:50:28Z", "path": "docs/manual/creating-a-checker.tex", "diffHunk": "@@ -1182,29 +1182,77 @@\n \\subsectionAndLabel{Procedurally specifying type introduction rules}{creating-procedurally-specifying-implicit-annotations}\n \n If the meta-annotations are not sufficiently expressive, then you\n-can write your own type introduction rules.  To do so, create a subclass of\n-\\refclass{framework/type}{AnnotatedTypeFactory} and override its\n-two \\<addComputedTypeAnnotations> methods.\n-\n-\\<AnnotatedTypeFactory>, when given a program\n-expression, returns the expression's type.  This should include not only\n-the qualifiers that the programmer explicitly wrote in the source code, but\n-also default annotations and type\n-refinement (see Section~\\ref{effective-qualifier} for explanations of these\n-concepts).\n-\n-To add type introduction rules, you should override\n-\\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror)}\n-(or\n-\\refmethodanchortext{framework/type}{GenericAnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-boolean-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror,boolean)}\n-if extending \\code{GenericAnnotatedTypeFactory})\n-and\n-\\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-javax.lang.model.element.Element-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Element,AnnotatedTypeMirror)}.\n-The methods operate on \\refclass{framework/type}{AnnotatedTypeMirror},\n-which is the Checker Framework's representation of an annotated type.\n-The methods can make arbitrary changes to the annotations on a type.\n+can write your own type introduction rules.  There are three ways to do so.\n+\n+\\begin{enumerate}\n+\\item\n+  Define a subclass of\n+  \\refclass{org/checkerframework/framework/type/treeannotator}{TreeAnnotator},\n+  typically as a private inner class of your \\<AnnotatedTypeFactory>.\n+  There is a method of \\<TreeAnnotator> for every AST node, and the visitor\n+  has access to both the tree (the AST node) and its type.  In your\n+  subclass of \\<AnnotatedTypeFactory>, override \\<createTreeAnnotator> to\n+  return a \\<ListTreeAnnotator> containing that annotator, as in\n \n-%TODO: document tree and type annotators here, which should be used instead of override addComputedTypeAnnotations if possible.\n+\\begin{Verbatim}\n+  @Override\n+  protected TreeAnnotator createTreeAnnotator() {\n+      return new ListTreeAnnotator(super.createTreeAnnotator(), new MyTreeAnnotator(this));\n+  }\n+\\end{Verbatim}\n+\n+  \\noindent\n+  (or put your TreeAnnotator first; note that \\<PropagationTreeAnnotator>,\n+  which is run by default, adds annotations to unannotated trees, but has", "originalCommit": "f281f11cd2fbe22964fc1d60bb6078cb84671416", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc4MDE5NQ==", "url": "https://github.com/typetools/checker-framework/pull/3678#discussion_r493780195", "bodyText": "I think you should have deleted the rest of this section?", "author": "smillst", "createdAt": "2020-09-23T17:52:24Z", "path": "docs/manual/creating-a-checker.tex", "diffHunk": "@@ -1182,29 +1182,77 @@\n \\subsectionAndLabel{Procedurally specifying type introduction rules}{creating-procedurally-specifying-implicit-annotations}\n \n If the meta-annotations are not sufficiently expressive, then you\n-can write your own type introduction rules.  To do so, create a subclass of\n-\\refclass{framework/type}{AnnotatedTypeFactory} and override its\n-two \\<addComputedTypeAnnotations> methods.\n-\n-\\<AnnotatedTypeFactory>, when given a program\n-expression, returns the expression's type.  This should include not only\n-the qualifiers that the programmer explicitly wrote in the source code, but\n-also default annotations and type\n-refinement (see Section~\\ref{effective-qualifier} for explanations of these\n-concepts).\n-\n-To add type introduction rules, you should override\n-\\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror)}\n-(or\n-\\refmethodanchortext{framework/type}{GenericAnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-boolean-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror,boolean)}\n-if extending \\code{GenericAnnotatedTypeFactory})\n-and\n-\\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-javax.lang.model.element.Element-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Element,AnnotatedTypeMirror)}.\n-The methods operate on \\refclass{framework/type}{AnnotatedTypeMirror},\n-which is the Checker Framework's representation of an annotated type.\n-The methods can make arbitrary changes to the annotations on a type.\n+can write your own type introduction rules.  There are three ways to do so.\n+\n+\\begin{enumerate}\n+\\item\n+  Define a subclass of\n+  \\refclass{org/checkerframework/framework/type/treeannotator}{TreeAnnotator},\n+  typically as a private inner class of your \\<AnnotatedTypeFactory>.\n+  There is a method of \\<TreeAnnotator> for every AST node, and the visitor\n+  has access to both the tree (the AST node) and its type.  In your\n+  subclass of \\<AnnotatedTypeFactory>, override \\<createTreeAnnotator> to\n+  return a \\<ListTreeAnnotator> containing that annotator, as in\n \n-%TODO: document tree and type annotators here, which should be used instead of override addComputedTypeAnnotations if possible.\n+\\begin{Verbatim}\n+  @Override\n+  protected TreeAnnotator createTreeAnnotator() {\n+      return new ListTreeAnnotator(super.createTreeAnnotator(), new MyTreeAnnotator(this));\n+  }\n+\\end{Verbatim}\n+\n+  \\noindent\n+  (or put your TreeAnnotator first; note that \\<PropagationTreeAnnotator>,\n+  which is run by default, adds annotations to unannotated trees, but has\n+  no effect on trees that have an annotation).\n+\n+\\item\n+  Define a subclass of a\n+  \\refclass{org/checkerframework/framework/type/treeannotator}{TypeAnnotator},\n+  typically as a private inner class of your \\<AnnotatedTypeFactory>.\n+  There is a method of \\<TypeAnnotator> for every kind of type, and the\n+  visitor has access to only the type.  In your subclass of\n+  \\<AnnotatedTypeFactory>, override \\<createTypeAnnotator> to return a\n+  \\<ListTypeAnnotator> containing that annotator, as in\n+\n+\\begin{Verbatim}\n+  @Override\n+  protected TypeAnnotator createTypeAnnotator() {\n+      return new ListTypeAnnotator(new MyTypeAnnotator(this), super.createTypeAnnotator());\n+  }\n+\\end{Verbatim}\n+\n+  \\noindent\n+  (or put your TypeAnnotator last).\n+\n+\\item\n+  Create a subclass of \\refclass{framework/type}{AnnotatedTypeFactory} and\n+  override its two \\<addComputedTypeAnnotations> methods.  This is a last\n+  resort, if your logic cannot be implemented using a TreeAnnotator or a\n+  TypeAnnotator.  The implementation of \\<addComputedTypeAnnotations> in\n+  \\<GenericAnnotatedTypeFactory> calls the tree annotator and the type\n+  annotator (in that order), but by overriding the method you can cause\n+  your logic to be run even earlier or even later.\n+\n+  \\<AnnotatedTypeFactory>, when given a program\n+  expression, returns the expression's type.  This should include not only\n+  the qualifiers that the programmer explicitly wrote in the source code, but\n+  also default annotations and type\n+  refinement (see Section~\\ref{effective-qualifier} for explanations of these\n+  concepts).\n+\n+  To add type introduction rules, you should override", "originalCommit": "f281f11cd2fbe22964fc1d60bb6078cb84671416", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NjcwNA==", "url": "https://github.com/typetools/checker-framework/pull/3678#discussion_r493856704", "bodyText": "That text is unchanged from the previous manual (just indented).  I think it adds information and should be retained.  But maybe I'm missing a reason it should be deleted.  Could you clarify?", "author": "mernst", "createdAt": "2020-09-23T19:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc4MDE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkzNTQ2MA==", "url": "https://github.com/typetools/checker-framework/pull/3678#discussion_r493935460", "bodyText": "I noticed it is unchanged, that's why I thought you meant to delete it.  The text reads as if it is the only way to add type introduction rules when it is just one of three ways to do so.  It's helpful to explicitly state the methods to override.\nI think you can just delete the sentence below or move it earlier in the section.  The other two items in the lists assume the read knows what an AnnotatedTypeMirror is.\n\nThe methods operate on \\refclass{framework/type}{AnnotatedTypeMirror},\nwhich is the Checker Framework's representation of an annotated type.", "author": "smillst", "createdAt": "2020-09-23T22:42:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc4MDE5NQ=="}], "type": "inlineReview"}, {"oid": "568a4fe88e674bebd0806e90723eef34fe73118b", "url": "https://github.com/typetools/checker-framework/commit/568a4fe88e674bebd0806e90723eef34fe73118b", "message": "Tweaks", "committedDate": "2020-09-23T19:52:35Z", "type": "commit"}, {"oid": "c1438f4dabca5a4d9e9cc29d8e3b92e2b339ff78", "url": "https://github.com/typetools/checker-framework/commit/c1438f4dabca5a4d9e9cc29d8e3b92e2b339ff78", "message": "Clarify writing", "committedDate": "2020-09-23T23:04:19Z", "type": "commit"}, {"oid": "2820769589ee224ddc0f7c9b4d0c48464b1d9edb", "url": "https://github.com/typetools/checker-framework/commit/2820769589ee224ddc0f7c9b4d0c48464b1d9edb", "message": "Merge ../checker-framework-branch-master into documentation", "committedDate": "2020-09-23T23:04:28Z", "type": "commit"}]}