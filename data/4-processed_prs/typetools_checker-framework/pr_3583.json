{"pr_number": 3583, "pr_title": "Decode annotations on enclosing types correctly", "pr_createdAt": "2020-08-10T21:31:55Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3583", "timeline": [{"oid": "00a10e2bf460d16d79bb5805f66804400b508e62", "url": "https://github.com/typetools/checker-framework/commit/00a10e2bf460d16d79bb5805f66804400b508e62", "message": "Handling annotations on enclosing types correctly.", "committedDate": "2020-08-10T21:15:54Z", "type": "commit"}, {"oid": "7dab64649fda0aa2bb5019ee79a5e36b9cfa0c03", "url": "https://github.com/typetools/checker-framework/commit/7dab64649fda0aa2bb5019ee79a5e36b9cfa0c03", "message": "Tweak comment", "committedDate": "2020-08-10T21:29:53Z", "type": "commit"}, {"oid": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260", "url": "https://github.com/typetools/checker-framework/commit/ff082138822dbf5f4da04c8b41bf0c5ce23b4260", "message": "Tweak comments", "committedDate": "2020-08-11T20:50:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1NzE2OQ==", "url": "https://github.com/typetools/checker-framework/pull/3583#discussion_r468857169", "bodyText": "\"For example\" sounds like it is following up on a previous point, but I think here it might be introducing a new point.", "author": "mernst", "createdAt": "2020-08-11T20:51:10Z", "path": "framework/src/main/java/org/checkerframework/framework/type/TypeFromMemberVisitor.java", "diffHunk": "@@ -26,17 +30,52 @@\n \n     @Override\n     public AnnotatedTypeMirror visitVariable(VariableTree node, AnnotatedTypeFactory f) {\n+        Element elt = TreeUtils.elementFromDeclaration(node);\n+\n         // Create the ATM and add non-primary annotations\n-        // (node.getType() does not include primary annotations, those are in\n-        // node.getModifier()\n+        // (node.getType() does not include the annotation before the type, so those\n+        // are added to the type below).\n         AnnotatedTypeMirror result = TypeFromTree.fromTypeTree(f, node.getType());\n \n-        // Add primary annotations\n+        // Handle any annotations in node.getModifiers().\n+        List<AnnotationMirror> modifierAnnos;\n         List<? extends AnnotationTree> annoTrees = node.getModifiers().getAnnotations();\n         if (annoTrees != null && !annoTrees.isEmpty()) {\n-            List<AnnotationMirror> annos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+            modifierAnnos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+        } else {\n+            modifierAnnos = new ArrayList<>();\n+        }\n+\n+        if (result.getKind() == TypeKind.DECLARED\n+                &&\n+                // Annotations on enum constants are not in the TypeMirror and always apply to the\n+                // innermost type, so handle them in the else block.\n+                elt.getKind() != ElementKind.ENUM_CONSTANT) {\n+\n+            // Decode the annotations from the type mirror because the annotations are already in\n+            // the correct place for enclosing types. For example, @Tainted Outer.Inner and @Tainted", "originalCommit": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1NzYwOA==", "url": "https://github.com/typetools/checker-framework/pull/3583#discussion_r468857608", "bodyText": "Are they stored on the same node (that is, both are stored on the node for Inner)?  If so, I would say that.  If not, the fact that they apply to different types may not be so surprising.", "author": "mernst", "createdAt": "2020-08-11T20:52:01Z", "path": "framework/src/main/java/org/checkerframework/framework/type/TypeFromMemberVisitor.java", "diffHunk": "@@ -26,17 +30,52 @@\n \n     @Override\n     public AnnotatedTypeMirror visitVariable(VariableTree node, AnnotatedTypeFactory f) {\n+        Element elt = TreeUtils.elementFromDeclaration(node);\n+\n         // Create the ATM and add non-primary annotations\n-        // (node.getType() does not include primary annotations, those are in\n-        // node.getModifier()\n+        // (node.getType() does not include the annotation before the type, so those\n+        // are added to the type below).\n         AnnotatedTypeMirror result = TypeFromTree.fromTypeTree(f, node.getType());\n \n-        // Add primary annotations\n+        // Handle any annotations in node.getModifiers().\n+        List<AnnotationMirror> modifierAnnos;\n         List<? extends AnnotationTree> annoTrees = node.getModifiers().getAnnotations();\n         if (annoTrees != null && !annoTrees.isEmpty()) {\n-            List<AnnotationMirror> annos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+            modifierAnnos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+        } else {\n+            modifierAnnos = new ArrayList<>();\n+        }\n+\n+        if (result.getKind() == TypeKind.DECLARED\n+                &&\n+                // Annotations on enum constants are not in the TypeMirror and always apply to the\n+                // innermost type, so handle them in the else block.\n+                elt.getKind() != ElementKind.ENUM_CONSTANT) {\n+\n+            // Decode the annotations from the type mirror because the annotations are already in\n+            // the correct place for enclosing types. For example, @Tainted Outer.Inner and @Tainted\n+            // Inner. For both types @Tainted is stored in node.getModifiers(), but they apply to", "originalCommit": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1Nzk1Mw==", "url": "https://github.com/typetools/checker-framework/pull/3583#discussion_r468857953", "bodyText": "I don't understand why this comment is attached to the curly brace rather than on a separate line.  Can you clarify why?", "author": "mernst", "createdAt": "2020-08-11T20:52:41Z", "path": "framework/src/main/java/org/checkerframework/framework/type/TypeFromMemberVisitor.java", "diffHunk": "@@ -26,17 +30,52 @@\n \n     @Override\n     public AnnotatedTypeMirror visitVariable(VariableTree node, AnnotatedTypeFactory f) {\n+        Element elt = TreeUtils.elementFromDeclaration(node);\n+\n         // Create the ATM and add non-primary annotations\n-        // (node.getType() does not include primary annotations, those are in\n-        // node.getModifier()\n+        // (node.getType() does not include the annotation before the type, so those\n+        // are added to the type below).\n         AnnotatedTypeMirror result = TypeFromTree.fromTypeTree(f, node.getType());\n \n-        // Add primary annotations\n+        // Handle any annotations in node.getModifiers().\n+        List<AnnotationMirror> modifierAnnos;\n         List<? extends AnnotationTree> annoTrees = node.getModifiers().getAnnotations();\n         if (annoTrees != null && !annoTrees.isEmpty()) {\n-            List<AnnotationMirror> annos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+            modifierAnnos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+        } else {\n+            modifierAnnos = new ArrayList<>();\n+        }\n+\n+        if (result.getKind() == TypeKind.DECLARED\n+                &&\n+                // Annotations on enum constants are not in the TypeMirror and always apply to the\n+                // innermost type, so handle them in the else block.\n+                elt.getKind() != ElementKind.ENUM_CONSTANT) {\n+\n+            // Decode the annotations from the type mirror because the annotations are already in\n+            // the correct place for enclosing types. For example, @Tainted Outer.Inner and @Tainted\n+            // Inner. For both types @Tainted is stored in node.getModifiers(), but they apply to\n+            // different types.\n+            AnnotatedDeclaredType annotatedDeclaredType = (AnnotatedDeclaredType) result;\n+            // The underlying type of result does not have all annotations, but the TypeMirror of\n+            // node.getType() does.\n+            DeclaredType declaredType = (DeclaredType) TreeUtils.typeOf(node.getType());\n+            AnnotatedTypes.applyAnnotationsFromDeclaredType(annotatedDeclaredType, declaredType);\n+\n+            // Handle declaration annotations\n+            for (AnnotationMirror anno : modifierAnnos) {\n+                if (AnnotationUtils.isDeclarationAnnotation(anno)) {\n+                    // This does not treat Checker Framework compatqual annotations differently,\n+                    // because it's not clear whether the annotation should apply to the outermost\n+                    // enclosing type or the innermost.\n+                    result.addAnnotation(anno);\n+                } // If anno is not a declaration annotation, it should have been applied in the", "originalCommit": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1ODk3Ng==", "url": "https://github.com/typetools/checker-framework/pull/3583#discussion_r468858976", "bodyText": "Maybe state explictly that this includes both declaration and type annotations.", "author": "mernst", "createdAt": "2020-08-11T20:54:35Z", "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "diffHunk": "@@ -1444,4 +1445,25 @@ public static void copyOnlyExplicitConstructorAnnotations(\n             }\n         }\n     }\n+\n+    /**\n+     * Add all the annotations in {@code declaredType} to {@code annotatedDeclaredType}.", "originalCommit": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "be2e0d6cfc62fa4612d30cc5e8a9c27a55600d7c", "url": "https://github.com/typetools/checker-framework/commit/be2e0d6cfc62fa4612d30cc5e8a9c27a55600d7c", "message": "Code review.", "committedDate": "2020-08-12T16:58:47Z", "type": "commit"}]}