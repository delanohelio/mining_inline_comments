{"pr_number": 3503, "pr_title": "Improve defaults for local variables with a qualifier parameter", "pr_createdAt": "2020-07-24T03:13:57Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3503", "timeline": [{"oid": "73357bd7e9463c4d36fef2cbebe26945f0be9e24", "url": "https://github.com/typetools/checker-framework/commit/73357bd7e9463c4d36fef2cbebe26945f0be9e24", "message": "Change initial values for qual param classes", "committedDate": "2020-07-15T20:16:12Z", "type": "commit"}, {"oid": "92297be8dba5d37a0cb64d3fca2cd9774cee8b6b", "url": "https://github.com/typetools/checker-framework/commit/92297be8dba5d37a0cb64d3fca2cd9774cee8b6b", "message": "Add check for local variable", "committedDate": "2020-07-15T20:24:10Z", "type": "commit"}, {"oid": "717a395a402663ed5a0189cbb39b6f4088631220", "url": "https://github.com/typetools/checker-framework/commit/717a395a402663ed5a0189cbb39b6f4088631220", "message": "Merge branch 'master' into var-init", "committedDate": "2020-07-21T04:57:51Z", "type": "commit"}, {"oid": "c324793331bb46af4ad940f1860b0a0015cc13d1", "url": "https://github.com/typetools/checker-framework/commit/c324793331bb46af4ad940f1860b0a0015cc13d1", "message": "Fix defaulting for local variables with a qualifier parameter", "committedDate": "2020-07-22T02:02:44Z", "type": "commit"}, {"oid": "0d1b46552947296b6e180acba86ddfd858f68c85", "url": "https://github.com/typetools/checker-framework/commit/0d1b46552947296b6e180acba86ddfd858f68c85", "message": "Add documentation for qualifier parameter methods", "committedDate": "2020-07-22T02:10:33Z", "type": "commit"}, {"oid": "79abcbbc11e6ac3c8918b5fa533321969b299ebe", "url": "https://github.com/typetools/checker-framework/commit/79abcbbc11e6ac3c8918b5fa533321969b299ebe", "message": "Merge branch 'master' into var-init", "committedDate": "2020-07-22T02:10:46Z", "type": "commit"}, {"oid": "2d62094e46ae5d6b78a8bf150ba80aa64d7e961c", "url": "https://github.com/typetools/checker-framework/commit/2d62094e46ae5d6b78a8bf150ba80aa64d7e961c", "message": "Fix wording", "committedDate": "2020-07-22T02:17:44Z", "type": "commit"}, {"oid": "6c2d72d25abf19440d67a151f3071c0935366de3", "url": "https://github.com/typetools/checker-framework/commit/6c2d72d25abf19440d67a151f3071c0935366de3", "message": "Finish defaulting feature for qualifier parameters\n\nUse new mechanism for preventing circular dependencies when calculating\ntypes that works in all cases.\n\nWrite manual section", "committedDate": "2020-07-24T02:55:30Z", "type": "commit"}, {"oid": "e754f50d43cf9ba64273671f17c0f56ad0503029", "url": "https://github.com/typetools/checker-framework/commit/e754f50d43cf9ba64273671f17c0f56ad0503029", "message": "Rename variable", "committedDate": "2020-07-24T03:11:55Z", "type": "commit"}, {"oid": "d005f353fa769ab376b87258f73c0197e9e2cc61", "url": "https://github.com/typetools/checker-framework/commit/d005f353fa769ab376b87258f73c0197e9e2cc61", "message": "Add check to improve efficiency", "committedDate": "2020-07-24T20:45:25Z", "type": "commit"}, {"oid": "7d85ec170e62e52f1270531dc665b615d119e34a", "url": "https://github.com/typetools/checker-framework/commit/7d85ec170e62e52f1270531dc665b615d119e34a", "message": "Add a cache for initializer types", "committedDate": "2020-07-24T21:14:58Z", "type": "commit"}, {"oid": "de3e93440f1f7c69bb4a0870ce6a4e48a5d202f3", "url": "https://github.com/typetools/checker-framework/commit/de3e93440f1f7c69bb4a0870ce6a4e48a5d202f3", "message": "Merge branch 'master' into var-init", "committedDate": "2020-07-24T22:46:12Z", "type": "commit"}, {"oid": "8dca7438bfd3cf364a2b06d34668e5dcff4995fc", "url": "https://github.com/typetools/checker-framework/commit/8dca7438bfd3cf364a2b06d34668e5dcff4995fc", "message": "Use dataflow results when getting the initializer.", "committedDate": "2020-07-28T21:03:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwMjAxOA==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r461902018", "bodyText": "Did you have to add this cache so that the Daikon test would not time-out?  We have avoided caching expressions because dataflow can change the type of an expression; see #602.  I don't think this cache makes the problem worse than it already is though.", "author": "smillst", "createdAt": "2020-07-28T21:47:48Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -162,6 +162,29 @@\n      */\n     private boolean shouldDefaultTypeVarLocals;\n \n+    /**\n+     * Elements representing variables for which the type of the initializer is being determined in\n+     * order to apply qualifier parameter defaults.\n+     *\n+     * <p>Local variables with a qualifier parameter get their declared type from the type of their\n+     * initializer. Sometimes the initializer's type depends on the type of the variable, such as\n+     * during type variable inference or when a variable is used in its own initializer as in\n+     * \"Object o = (o = null)\". This creates a circular dependency resulting in infinite recursion.\n+     * To prevent this, variables in this set should not be typed based on their initializer, but by\n+     * using normal defaults.\n+     *\n+     * @see GenericAnnotatedTypeFactory#applyLocalVariableQualifierParameterDefaults\n+     */\n+    private Set<Element> variablesUnderInitialization;\n+\n+    /**\n+     * Caches types of initializers for local variables with a qualifier parameter, so that they\n+     * aren't computed each time the type of a variable is looked up.\n+     *\n+     * @see GenericAnnotatedTypeFactory#applyLocalVariableQualifierParameterDefaults\n+     */\n+    private Map<Tree, AnnotatedTypeMirror> initializerCache;", "originalCommit": "8dca7438bfd3cf364a2b06d34668e5dcff4995fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwNzgyMg==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r461907822", "bodyText": "Yes, the Daikon test timed out before Jason added this cache.", "author": "mernst", "createdAt": "2020-07-28T21:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwMjAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkyODA3OQ==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r461928079", "bodyText": "I actually added two optimizations. The first was to not calculate the type of the initializer if the type of the local variable it's assigned to has no qualifier parameter in any hierarchy. Previously, it calculated the type of the initializer for every local variable and then filtered to retain only the annotations in hierarchies with a qualifier parameter. The second  optimization was to add a cache.\nThe first fix alone would have been sufficient to fix the CI because it's likely that no types in the daikon test use a qualifier parameter. However, it indicates that there's some performance penalty for this check when used. Retaining the cache would probably be helpful for situations when writing @HasQualifierParameter on a package, which applies it to all classes in the package.", "author": "jwaataja", "createdAt": "2020-07-28T22:25:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwMjAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQxNDIzMQ==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462414231", "bodyText": "Thanks for the explanation!", "author": "smillst", "createdAt": "2020-07-29T16:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwMjAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwMzE1Mg==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r461903152", "bodyText": "types are written should be annotations are written.", "author": "smillst", "createdAt": "2020-07-28T21:49:23Z", "path": "docs/manual/generics.tex", "diffHunk": "@@ -950,6 +950,40 @@\n qualifier on the upper bound).  That is, the qualifier on \\<myBuffer.field>\n is that same as that on \\<myBuffer>.\n \n+\\subsectionAndLabel{Local variable defaults for types with qualifier parameters}{local-vars-qual-param-defaults}\n+\n+Normally, local variables default to the top type. Type refinement determines if\n+a variable can be treated as a suitable subtype, and annotations on local\n+variables are rarely needed as a result. However, since qualifier parameters add\n+invariant subtyping, type refinement is no longer valid. For example, suppose in\n+the following code that \\<StringBuffer> is annotated with\n+\\<@HasQualifierParameter(Tainted.class)>.\n+\n+\\begin{Verbatim}\n+    void method(@Untainted StringBuffer buffer) {\n+        StringBuffer local = buffer;\n+        executeSql(local.toString());\n+    }\n+\n+    void executeSql(@Untainted String code) {\n+        // ...\n+    }\n+\\end{Verbatim}\n+\n+Normally, the framework would determine that \\<local> has type \\<@Untainted\n+StringBuffer> and the call to \\<executeSql> would be valid. However, since by\n+default \\<local> has type \\<@Tainted StringBuffer>, and\n+\\<@Untainted StringBuffer> is not a subtype, no type refinement would be\n+performed, leading to an error. Fixing this would require manually annotating\n+\\<local> as an \\<@Untainted StringBuffer>, increasing the annotation burden on\n+programmers.\n+\n+For this reason, local variables with types that have a qualifier parameter use\n+different defaulting rules. When a local variable has an initializer, the type\n+of that initializer is used as the default type of that variable if no other\n+types are written. For example, in the above code, the type of \\<local> would be", "originalCommit": "8dca7438bfd3cf364a2b06d34668e5dcff4995fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "18ab206dacacac51fba54e312534543a290dead9", "url": "https://github.com/typetools/checker-framework/commit/18ab206dacacac51fba54e312534543a290dead9", "message": "Fix phrasing in manual", "committedDate": "2020-07-28T22:28:12Z", "type": "commit"}, {"oid": "6e8296f15ec129f3624a70e2d1ba5df947109b07", "url": "https://github.com/typetools/checker-framework/commit/6e8296f15ec129f3624a70e2d1ba5df947109b07", "message": "Merge branch 'var-init' of https://github.com/jwaataja/checker-framework into var-init", "committedDate": "2020-07-28T22:28:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQxODczNQ==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462418735", "bodyText": "Move this call to line 1666 and pass in tops rather than recomputing it.   Then in applyLocalVariableQualifierParameterDefaults you don't need to check that type has a qualifier parameter.", "author": "smillst", "createdAt": "2020-07-29T16:11:13Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1617,6 +1652,8 @@ protected void applyQualifierParameterDefaults(\n                 return;\n         }\n \n+        applyLocalVariableQualifierParameterDefaults(elt, type);", "originalCommit": "6e8296f15ec129f3624a70e2d1ba5df947109b07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ5OTY0OA==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462499648", "bodyText": "The tops variable seems to store qualifier parameter hierarchies for the enclosing class of the local variable, rather than on the type of the local variable itself. So in\nClassWithQualParam1 {\n    void m() {\n        ClassWithQualParam2 local;\n    }\n}\nWe would need to apply the defaults to local regardless of the qualifier parameters on ClassWithQualParam1. I think this means moving it might be incorrect, because the enclosing class might not have a qualifier parameter at all and we would still apply the new defaults.", "author": "jwaataja", "createdAt": "2020-07-29T18:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQxODczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU2MzI3Ng==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462563276", "bodyText": "The differenting defaulting sounds odd. How about different defaulting?", "author": "wmdietl", "createdAt": "2020-07-29T20:18:44Z", "path": "checker/tests/tainting/HasQualParamDefaults.java", "diffHunk": "@@ -83,4 +98,39 @@ void creation() {\n             @PolyTainted Buffer b3 = new @PolyTainted Buffer();\n         }\n     }\n+\n+    // For classes with @HasQualifierParameter, differenting defaulting rules are applied on that", "originalCommit": "6e8296f15ec129f3624a70e2d1ba5df947109b07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU2ODcxNQ==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462568715", "bodyText": "Add a cross-reference to the CLIMB section?", "author": "wmdietl", "createdAt": "2020-07-29T20:28:55Z", "path": "docs/manual/generics.tex", "diffHunk": "@@ -950,6 +950,41 @@\n qualifier on the upper bound).  That is, the qualifier on \\<myBuffer.field>\n is that same as that on \\<myBuffer>.\n \n+\\subsectionAndLabel{Local variable defaults for types with qualifier parameters}{local-vars-qual-param-defaults}\n+\n+Normally, local variables default to the top type. Type refinement determines if", "originalCommit": "6e8296f15ec129f3624a70e2d1ba5df947109b07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5ODEzOA==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462598138", "bodyText": "Can you use the more precise VariableElement?", "author": "wmdietl", "createdAt": "2020-07-29T21:24:28Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -162,6 +162,29 @@\n      */\n     private boolean shouldDefaultTypeVarLocals;\n \n+    /**\n+     * Elements representing variables for which the type of the initializer is being determined in\n+     * order to apply qualifier parameter defaults.\n+     *\n+     * <p>Local variables with a qualifier parameter get their declared type from the type of their\n+     * initializer. Sometimes the initializer's type depends on the type of the variable, such as\n+     * during type variable inference or when a variable is used in its own initializer as in\n+     * \"Object o = (o = null)\". This creates a circular dependency resulting in infinite recursion.\n+     * To prevent this, variables in this set should not be typed based on their initializer, but by\n+     * using normal defaults.\n+     *\n+     * @see GenericAnnotatedTypeFactory#applyLocalVariableQualifierParameterDefaults\n+     */\n+    private Set<Element> variablesUnderInitialization;", "originalCommit": "6e8296f15ec129f3624a70e2d1ba5df947109b07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3NTUxNg==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462675516", "bodyText": "The documentation on this seems sketchy, the javadoc for this doesn't seem guarantee that e.getKind() == ElementKind.LOCAL_VARIABLE implies e instanceof VariableElement. However, the only line in the jdk source code return ElementKind.LOCAL_VARIABLE is within a VariableElement implementation, so I think your suggestion makes sense.", "author": "jwaataja", "createdAt": "2020-07-30T01:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5ODEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5OTgyMg==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462599822", "bodyText": "How about adding a test with a local variable without initializer, showing how that will produce an expected error when the default and the RHS-type mismatch?", "author": "wmdietl", "createdAt": "2020-07-29T21:27:50Z", "path": "checker/tests/tainting/HasQualParamDefaults.java", "diffHunk": "@@ -44,6 +44,21 @@ public Buffer append(@PolyTainted String s) {\n             someString = s;\n             return s;\n         }\n+\n+        void initializeLocalTainted(@Tainted Buffer b) {\n+            Buffer local = b;\n+            @Tainted Buffer copy = local;\n+        }\n+\n+        void initializeLocalUntainted(@Untainted Buffer b) {\n+            Buffer local = b;\n+            @Untainted Buffer copy = local;", "originalCommit": "6e8296f15ec129f3624a70e2d1ba5df947109b07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwMDEyNA==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462600124", "bodyText": "More generally, maybe a test with an expected error would be good, to show that the expected type is inferred.", "author": "wmdietl", "createdAt": "2020-07-29T21:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5OTgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwMTUwOQ==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462601509", "bodyText": "Maybe instead of top say the default for local variables, as a type system could change that default.", "author": "wmdietl", "createdAt": "2020-07-29T21:31:04Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1588,6 +1615,10 @@ protected void applyInferredAnnotations(AnnotatedTypeMirror type, Value as) {\n     /**\n      * Applies defaults for types in a class with an qualifier parameter.\n      *\n+     * <p>Within a class with {@code @HasQualifierParameter}, types with that class default to the\n+     * polymorphic qualifier rather than the typical default. Local variables with a type that has a\n+     * qualifier parameter are initialized to the type of their initializer, rather than top.", "originalCommit": "6e8296f15ec129f3624a70e2d1ba5df947109b07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwMTczNw==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462601737", "bodyText": "Same comment about top.", "author": "wmdietl", "createdAt": "2020-07-29T21:31:32Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1598,6 +1629,10 @@ protected void applyQualifierParameterDefaults(Tree tree, AnnotatedTypeMirror ty\n     /**\n      * Applies defaults for types in a class with an qualifier parameter.\n      *\n+     * <p>Within a class with {@code @HasQualifierParameter}, types with that class default to the\n+     * polymorphic qualifier rather than the typical default. Local variables with a type that has a\n+     * qualifier parameter are initialized to the type of their initializer, rather than top.", "originalCommit": "6e8296f15ec129f3624a70e2d1ba5df947109b07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwMjQyNA==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462602424", "bodyText": "\"to type\" should be \"to the type\".", "author": "wmdietl", "createdAt": "2020-07-29T21:33:03Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1645,6 +1682,59 @@ public Void visitDeclared(AnnotatedDeclaredType type, Void aVoid) {\n         }.visit(type);\n     }\n \n+    /**\n+     * Defaults local variables with types that have a qualifier parameter to type of their", "originalCommit": "6e8296f15ec129f3624a70e2d1ba5df947109b07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwMjcwOA==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462602708", "bodyText": "Add \", if an initializer is present\" and explain what happens for local variables without initializers?", "author": "wmdietl", "createdAt": "2020-07-29T21:33:37Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1645,6 +1682,59 @@ public Void visitDeclared(AnnotatedDeclaredType type, Void aVoid) {\n         }.visit(type);\n     }\n \n+    /**\n+     * Defaults local variables with types that have a qualifier parameter to type of their\n+     * initializer.", "originalCommit": "6e8296f15ec129f3624a70e2d1ba5df947109b07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwMzI2MA==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462603260", "bodyText": "\"call\" -> \"called\".", "author": "wmdietl", "createdAt": "2020-07-29T21:34:50Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1645,6 +1682,59 @@ public Void visitDeclared(AnnotatedDeclaredType type, Void aVoid) {\n         }.visit(type);\n     }\n \n+    /**\n+     * Defaults local variables with types that have a qualifier parameter to type of their\n+     * initializer.\n+     *\n+     * @param elt Element whose type is {@code type}\n+     * @param type where the defaults are applied\n+     */\n+    private void applyLocalVariableQualifierParameterDefaults(\n+            Element elt, AnnotatedTypeMirror type) {\n+        if (elt.getKind() != ElementKind.LOCAL_VARIABLE\n+                || getQualifierParameterHierarchies(type).isEmpty()\n+                || variablesUnderInitialization.contains(elt)) {\n+            return;\n+        }\n+\n+        Tree declTree = declarationFromElement(elt);\n+        if (declTree == null || declTree.getKind() != Kind.VARIABLE) {\n+            return;\n+        }\n+\n+        ExpressionTree initializer = ((VariableTree) declTree).getInitializer();\n+        if (initializer == null) {\n+            return;\n+        }\n+\n+        variablesUnderInitialization.add(elt);\n+        AnnotatedTypeMirror initializerType;\n+        if (shouldCache && initializerCache.containsKey(initializer)) {\n+            initializerType = initializerCache.get(initializer);\n+        } else {\n+            // When this method is call by getAnnotatedTypeLhs, flow is turned off.", "originalCommit": "6e8296f15ec129f3624a70e2d1ba5df947109b07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwMzgxMg==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462603812", "bodyText": "We're usually careful and put such code in try/finally blocks, to ensure that the pre-state is restored even if there is an error.", "author": "wmdietl", "createdAt": "2020-07-29T21:35:58Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1645,6 +1682,59 @@ public Void visitDeclared(AnnotatedDeclaredType type, Void aVoid) {\n         }.visit(type);\n     }\n \n+    /**\n+     * Defaults local variables with types that have a qualifier parameter to type of their\n+     * initializer.\n+     *\n+     * @param elt Element whose type is {@code type}\n+     * @param type where the defaults are applied\n+     */\n+    private void applyLocalVariableQualifierParameterDefaults(\n+            Element elt, AnnotatedTypeMirror type) {\n+        if (elt.getKind() != ElementKind.LOCAL_VARIABLE\n+                || getQualifierParameterHierarchies(type).isEmpty()\n+                || variablesUnderInitialization.contains(elt)) {\n+            return;\n+        }\n+\n+        Tree declTree = declarationFromElement(elt);\n+        if (declTree == null || declTree.getKind() != Kind.VARIABLE) {\n+            return;\n+        }\n+\n+        ExpressionTree initializer = ((VariableTree) declTree).getInitializer();\n+        if (initializer == null) {\n+            return;\n+        }\n+\n+        variablesUnderInitialization.add(elt);\n+        AnnotatedTypeMirror initializerType;\n+        if (shouldCache && initializerCache.containsKey(initializer)) {\n+            initializerType = initializerCache.get(initializer);\n+        } else {\n+            // When this method is call by getAnnotatedTypeLhs, flow is turned off.\n+            // Turn it back on so the type of the initializer is the refined type.\n+            boolean oldUseFlow = useFlow;\n+            useFlow = everUseFlow;\n+            initializerType = getAnnotatedType(initializer);", "originalCommit": "6e8296f15ec129f3624a70e2d1ba5df947109b07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwNjAwOA==", "url": "https://github.com/typetools/checker-framework/pull/3503#discussion_r462606008", "bodyText": "Maybe add a comment why this set doesn't need to be cleared out: it's expected to be empty outside an variable initializer, right?", "author": "wmdietl", "createdAt": "2020-07-29T21:40:34Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -162,6 +162,29 @@\n      */\n     private boolean shouldDefaultTypeVarLocals;\n \n+    /**\n+     * Elements representing variables for which the type of the initializer is being determined in\n+     * order to apply qualifier parameter defaults.\n+     *\n+     * <p>Local variables with a qualifier parameter get their declared type from the type of their\n+     * initializer. Sometimes the initializer's type depends on the type of the variable, such as\n+     * during type variable inference or when a variable is used in its own initializer as in\n+     * \"Object o = (o = null)\". This creates a circular dependency resulting in infinite recursion.\n+     * To prevent this, variables in this set should not be typed based on their initializer, but by\n+     * using normal defaults.\n+     *", "originalCommit": "6e8296f15ec129f3624a70e2d1ba5df947109b07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7651b84c58f975405ff96a3351070c8bb899187a", "url": "https://github.com/typetools/checker-framework/commit/7651b84c58f975405ff96a3351070c8bb899187a", "message": "Address code review comments", "committedDate": "2020-07-30T01:40:13Z", "type": "commit"}]}