{"pr_number": 3336, "pr_title": "Support unique classes (Fixes #3313)", "pr_createdAt": "2020-05-28T17:32:19Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3336", "timeline": [{"oid": "fd536c4de755dc1c53adbca9ad2b684e9b39a055", "url": "https://github.com/typetools/checker-framework/commit/fd536c4de755dc1c53adbca9ad2b684e9b39a055", "message": "Fix for feature request #3313 in Aliasing Checker", "committedDate": "2020-05-28T06:30:02Z", "type": "commit"}, {"oid": "126014d85e00bb2d2b28f29093a4962c2f396929", "url": "https://github.com/typetools/checker-framework/commit/126014d85e00bb2d2b28f29093a4962c2f396929", "message": "Fix for explicit annotation check in Aliasing Checker", "committedDate": "2020-05-28T06:53:33Z", "type": "commit"}, {"oid": "b2b91eb9dabe2957301cd8826c4aad8ad979c9da", "url": "https://github.com/typetools/checker-framework/commit/b2b91eb9dabe2957301cd8826c4aad8ad979c9da", "message": "Adding test cases for removal of explicit annotation check", "committedDate": "2020-05-28T16:36:29Z", "type": "commit"}, {"oid": "1b756c0e75b3f54615f5f86c8a096789e296ee06", "url": "https://github.com/typetools/checker-framework/commit/1b756c0e75b3f54615f5f86c8a096789e296ee06", "message": "Ensuring all framework tests are passed", "committedDate": "2020-05-29T14:36:01Z", "type": "commit"}, {"oid": "4edfc68f7855f851755ff9037e318df62592a1c0", "url": "https://github.com/typetools/checker-framework/commit/4edfc68f7855f851755ff9037e318df62592a1c0", "message": "Formatting changes", "committedDate": "2020-05-29T16:05:36Z", "type": "commit"}, {"oid": "dde03eff890f26f6266d4480150f8590fbf72a61", "url": "https://github.com/typetools/checker-framework/commit/dde03eff890f26f6266d4480150f8590fbf72a61", "message": "Merge ../checker-framework-branch-master into 3313-explicit-annotation-fix", "committedDate": "2020-06-03T16:53:16Z", "type": "commit"}, {"oid": "22462e0c3106a97353ababcbcb9c547d061f9809", "url": "https://github.com/typetools/checker-framework/commit/22462e0c3106a97353ababcbcb9c547d061f9809", "message": "Fix for feature request #3313 in Aliasing Checker", "committedDate": "2020-06-05T10:48:41Z", "type": "commit"}, {"oid": "017082b1f6ac5598dfe80fad535acccebde22901", "url": "https://github.com/typetools/checker-framework/commit/017082b1f6ac5598dfe80fad535acccebde22901", "message": "Revert \"Fix for feature request #3313 in Aliasing Checker\"\n\nThis reverts commit fd536c4de755dc1c53adbca9ad2b684e9b39a055.", "committedDate": "2020-06-05T10:48:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwMzk0Nw==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r436203947", "bodyText": "You should try to avoid operations on strings. Is there no TypeKind to compare against?", "author": "wmdietl", "createdAt": "2020-06-05T23:21:01Z", "path": "framework/src/main/java/org/checkerframework/common/aliasing/AliasingVisitor.java", "diffHunk": "@@ -271,7 +271,13 @@ private boolean canBeLeaked(Tree exp) {\n         AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);\n         boolean isMethodInvocation = exp.getKind() == Kind.METHOD_INVOCATION;\n         boolean isNewClass = exp.getKind() == Kind.NEW_CLASS;\n-        return type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        boolean isArray = type.getUnderlyingType().getKind().toString().equalsIgnoreCase(\"array\");", "originalCommit": "dde03eff890f26f6266d4480150f8590fbf72a61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzNzAzOA==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r440437038", "bodyText": "Ping.", "author": "wmdietl", "createdAt": "2020-06-15T20:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwMzk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEyOTAyNw==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r443129027", "bodyText": "I have used your suggested logic in my latest commit. There is no need for array TypeKind comparison in the code.", "author": "aditya3434", "createdAt": "2020-06-20T12:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwMzk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDExOQ==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r436204119", "bodyText": "What is the motivation for this special logic? You should explain the logic here or at least in the PR description.", "author": "wmdietl", "createdAt": "2020-06-05T23:21:50Z", "path": "framework/src/main/java/org/checkerframework/common/aliasing/AliasingVisitor.java", "diffHunk": "@@ -271,7 +271,13 @@ private boolean canBeLeaked(Tree exp) {\n         AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);\n         boolean isMethodInvocation = exp.getKind() == Kind.METHOD_INVOCATION;\n         boolean isNewClass = exp.getKind() == Kind.NEW_CLASS;\n-        return type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        boolean isArray = type.getUnderlyingType().getKind().toString().equalsIgnoreCase(\"array\");\n+        boolean isNull = exp.getKind() == Kind.NULL_LITERAL;\n+        if (type.getUnderlyingType().toString().startsWith(\"java.lang\") || isArray || isNull) {", "originalCommit": "dde03eff890f26f6266d4480150f8590fbf72a61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDU4Mw==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r436204583", "bodyText": "Also, do add tests that cover such special logic, in at least a few important cases.", "author": "wmdietl", "createdAt": "2020-06-05T23:24:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI2NTk3MA==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r436265970", "bodyText": "The main logic I was following that the Aliasing Checker doesn't check for explicit annotations for user defined classes. So only those classes that the user has specifically annotated as @unique would construct @unique classes. This would also prevent all trivial objects like strings, int, object, float, etc. from always becoming @unique (it is more convenient to explicitly annotate them).\nHowever, I couldn't figure out how to make the AliasingVisitor check whether a class was user-defined or not. So, instead I listed classes and data types for which one would need explicit annotations. These included java.lang classes, arrays and null values. All this complicated conditions could be avoided if the Visitor could check for user-defined classes.\nif (annotated class is user defined) {\nreturn type.hasAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n}\nelse {\nreturn type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n}", "author": "aditya3434", "createdAt": "2020-06-06T12:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4NDc2Mg==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r436384762", "bodyText": "Can you clarify what you mean with \"user defined\"?\nWhy should the handling of explicit annotations depend on whether the class is \"user defined\"?", "author": "wmdietl", "createdAt": "2020-06-07T17:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5NTYzMg==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r436895632", "bodyText": "In the stub file stubfile.astub in tests/aliasing, Object and String classes are annotated as @unique by default. So, if I don't check for explicit annotations for all classes, then, even trivial operations like string assignments give a \"unique.leaked\" error in the test cases.\n// part of TypeRefinementTest.java in tests/aliasing\nvoid rule1() {\nString unique = new String();\nisUnique(unique);\nString notUnique = unique;  // gives unique.leaked error even though @unique is never used\n}\nSo I decided to limit this checking for \"user-defined\" classes (classes that are not part of any in-built java library, like java.lang or java.util). For example, in the code in the feature request #3313 (#3313), class Data and Demo are user-defined classes, and since Data is annotated as @unique, all its instances don't require explicit annotations to be unique as well.", "author": "aditya3434", "createdAt": "2020-06-08T18:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0MzUzNg==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r440443536", "bodyText": "We do not want different behavior for built-in classes and user-defined classes. The same logic should be applied to all source code, regardless of who wrote the code.\nThere is a difference between classes String and Data in these two examples.\nIn String the default constructor is annotated as returning a unique object. The class declaration is not annotated. Therefore, it is fine in the test case to have a non-unique String reference.\nOn the other hand class Data in this new test case is annotated as @Unique requiring that only @Unique references exist.\nSo your check should be for that difference between the two classes.\nAlso can you move the annotations from framework/tests/aliasing/stubfile.astub into typetools/jdk#52?", "author": "wmdietl", "createdAt": "2020-06-15T20:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEzMDk3Nw==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r443130977", "bodyText": "I have added a new method for the above requested logic. Now the code doesn't need to deal with the special cases of arrays, null and java.lang classes. I have used the getDeclAnnotations method to get the set of declared annotations of the class as a whole, and then searched for the unique annotation mirror in the set. The code now gives leaked errors without explicit annotations only when the class is annotated as @unique. Annotating just the constructor will allow non-unique object references.", "author": "aditya3434", "createdAt": "2020-06-20T13:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDQ5OQ==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r436204499", "bodyText": "Is the type of the left-hand side important? Can you add another method that does\nObject check2(Data p) { return p; }\nwhich I guess should also give a unique.leaked error.", "author": "wmdietl", "createdAt": "2020-06-05T23:23:42Z", "path": "framework/tests/aliasing/ExplicitAnnotationTest.java", "diffHunk": "@@ -0,0 +1,13 @@\n+import org.checkerframework.common.aliasing.qual.Unique;\n+\n+@Unique class Data {\n+    @SuppressWarnings(\"unique.leaked\")\n+    Data() {} // All objects of Data are now @Unique\n+}\n+\n+class Demo {\n+    void check(Data p) { // p is @Unique Data Object\n+        // :: error: (unique.leaked)\n+        Data y = p; // @Unique p is leaked", "originalCommit": "dde03eff890f26f6266d4480150f8590fbf72a61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0MzcwNQ==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r440443705", "bodyText": "Ping.", "author": "wmdietl", "createdAt": "2020-06-15T20:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEzMDMxNA==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r443130314", "bodyText": "No, the type of the left-hand side isn't important. However, the method doesn't give an error, even when Data is explicitly annotated as @unique.", "author": "aditya3434", "createdAt": "2020-06-20T13:18:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5MjE4Ng==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r445592186", "bodyText": "I'm not sure how you mean this. Does Object z = p; not raise an error? Shouldn't it?", "author": "wmdietl", "createdAt": "2020-06-25T14:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5ODg2NQ==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r446798865", "bodyText": "@Unique\nclass Data {\n\n    Object check2(Data p) { return p; }\n\n    void check(Data p) {\n        Object z = p;\n    }\n}\n\nIn the code given above, Object z = p; does raise an error. Hence, the left hand side isn't important. However, the check2 function (where you are returning a @unique Data as an Object) doesn't raise an error both in the typetools/master and in my modified code, even if the Data p is explicitly annotated as @unique Data p.", "author": "aditya3434", "createdAt": "2020-06-29T06:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYzNjc5Mg==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r457636792", "bodyText": "Ok, can you expand this test case with the Object local variable and the expected error.\nThen file an issue that shows the problem with the return version.", "author": "wmdietl", "createdAt": "2020-07-20T19:19:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNDQ5OQ=="}], "type": "inlineReview"}, {"oid": "4b366093df5bdd65651b309bce609b429d00bd73", "url": "https://github.com/typetools/checker-framework/commit/4b366093df5bdd65651b309bce609b429d00bd73", "message": "Merge branch 'master' into 3313-explicit-annotation-fix", "committedDate": "2020-06-06T10:42:36Z", "type": "commit"}, {"oid": "fa032466041da8dc09f29495e779f6c70835b57d", "url": "https://github.com/typetools/checker-framework/commit/fa032466041da8dc09f29495e779f6c70835b57d", "message": "Merge branch '3313-explicit-annotation-fix' of https://github.com/aditya3434/checker-framework into 3313-explicit-annotation-fix", "committedDate": "2020-06-06T10:50:57Z", "type": "commit"}, {"oid": "97ff12d4b6dbfbfcb62d7d52815f1c90ea6900b9", "url": "https://github.com/typetools/checker-framework/commit/97ff12d4b6dbfbfcb62d7d52815f1c90ea6900b9", "message": "Fix for feature request #3313 in Aliasing Checker", "committedDate": "2020-06-11T07:53:26Z", "type": "commit"}, {"oid": "629a1a971c44ee9e2b268854f3767b91b28c2da0", "url": "https://github.com/typetools/checker-framework/commit/629a1a971c44ee9e2b268854f3767b91b28c2da0", "message": "Revert \"Fix for feature request #3313 in Aliasing Checker\"\n\nThis reverts commit fd536c4de755dc1c53adbca9ad2b684e9b39a055.", "committedDate": "2020-06-11T07:53:26Z", "type": "commit"}, {"oid": "25b602a276a6d40e8510aeab62e952b6a1c2b44e", "url": "https://github.com/typetools/checker-framework/commit/25b602a276a6d40e8510aeab62e952b6a1c2b44e", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-06-16T11:49:22Z", "type": "commit"}, {"oid": "91d83722b66b2cd69d9e92eb37485deb219a3fe7", "url": "https://github.com/typetools/checker-framework/commit/91d83722b66b2cd69d9e92eb37485deb219a3fe7", "message": "Merge branch 'master' into 3313-explicit-annotation-fix", "committedDate": "2020-06-16T12:43:09Z", "type": "commit"}, {"oid": "eb424fd817490cc389323adf5d721d39b0ad8533", "url": "https://github.com/typetools/checker-framework/commit/eb424fd817490cc389323adf5d721d39b0ad8533", "message": "Fix for feature request #3313 in Aliasing Checker", "committedDate": "2020-06-17T16:20:58Z", "type": "commit"}, {"oid": "c3240948aa8891c016b04e627e15f0505cfaf18f", "url": "https://github.com/typetools/checker-framework/commit/c3240948aa8891c016b04e627e15f0505cfaf18f", "message": "Revert \"Fix for feature request #3313 in Aliasing Checker\"\n\nThis reverts commit fd536c4de755dc1c53adbca9ad2b684e9b39a055.", "committedDate": "2020-06-17T16:20:58Z", "type": "commit"}, {"oid": "941cab0d71c66e682d99347b2604d104331d34b8", "url": "https://github.com/typetools/checker-framework/commit/941cab0d71c66e682d99347b2604d104331d34b8", "message": "Fix for feature request #3313 in Aliasing Checker", "committedDate": "2020-06-17T16:20:58Z", "type": "commit"}, {"oid": "d71f60820a8e44e21b9f1cc542cb798958006dc3", "url": "https://github.com/typetools/checker-framework/commit/d71f60820a8e44e21b9f1cc542cb798958006dc3", "message": "Revert \"Fix for feature request #3313 in Aliasing Checker\"\n\nThis reverts commit fd536c4de755dc1c53adbca9ad2b684e9b39a055.", "committedDate": "2020-06-17T16:20:58Z", "type": "commit"}, {"oid": "53a6c12b02f9cbde8742bf4e1f69f2139eed1b94", "url": "https://github.com/typetools/checker-framework/commit/53a6c12b02f9cbde8742bf4e1f69f2139eed1b94", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-06-19T16:01:19Z", "type": "commit"}, {"oid": "ff1b9e49a634ae727c379633220cf251ec7a60aa", "url": "https://github.com/typetools/checker-framework/commit/ff1b9e49a634ae727c379633220cf251ec7a60aa", "message": "Merge branch 'master' into 3313-explicit-annotation-fix", "committedDate": "2020-06-19T16:03:50Z", "type": "commit"}, {"oid": "135b2667e2033910907b7ff55d8d96f82ead0267", "url": "https://github.com/typetools/checker-framework/commit/135b2667e2033910907b7ff55d8d96f82ead0267", "message": "Resolving review comments", "committedDate": "2020-06-19T16:28:53Z", "type": "commit"}, {"oid": "db149b9707d2a84ce919275f79429afc4720f958", "url": "https://github.com/typetools/checker-framework/commit/db149b9707d2a84ce919275f79429afc4720f958", "message": "Removing redundant variables", "committedDate": "2020-06-19T19:38:09Z", "type": "commit"}, {"oid": "e64f002019f132d05ab4d96c1493a327bf1710de", "url": "https://github.com/typetools/checker-framework/commit/e64f002019f132d05ab4d96c1493a327bf1710de", "message": "Modifying documentation", "committedDate": "2020-06-19T20:40:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0OTkxMw==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r445549913", "bodyText": "Do not star import.", "author": "wmdietl", "createdAt": "2020-06-25T13:17:00Z", "path": "framework/src/main/java/org/checkerframework/common/aliasing/AliasingVisitor.java", "diffHunk": "@@ -1,17 +1,11 @@\n package org.checkerframework.common.aliasing;\n \n-import com.sun.source.tree.ExpressionTree;\n-import com.sun.source.tree.MethodInvocationTree;\n-import com.sun.source.tree.MethodTree;\n-import com.sun.source.tree.NewArrayTree;\n-import com.sun.source.tree.ThrowTree;\n-import com.sun.source.tree.Tree;\n+import com.sun.source.tree.*;", "originalCommit": "e64f002019f132d05ab4d96c1493a327bf1710de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MTg4Mg==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r446791882", "bodyText": "Instead of star import, I listed the library data types that were required in my latest commit", "author": "aditya3434", "createdAt": "2020-06-29T06:08:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0OTkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU3NDQ0Mw==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r445574443", "bodyText": "The caller already computed type and you don't seem to use exp in this method. So why not just pass the type as parameter?", "author": "wmdietl", "createdAt": "2020-06-25T13:51:47Z", "path": "framework/src/main/java/org/checkerframework/common/aliasing/AliasingVisitor.java", "diffHunk": "@@ -271,7 +265,37 @@ private boolean canBeLeaked(Tree exp) {\n         AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);\n         boolean isMethodInvocation = exp.getKind() == Kind.METHOD_INVOCATION;\n         boolean isNewClass = exp.getKind() == Kind.NEW_CLASS;\n-        return type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        boolean isUniqueClassFlag = isUniqueClass(exp);\n+        if (isUniqueClassFlag) {\n+            return type.hasAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        } else {\n+            return type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        }\n+    }\n+\n+    /**\n+     * Returns true if class of tree expression {@code exp} has type {@code @Unique}\n+     *\n+     * @param exp the Tree to check\n+     * @return boolean true if class if unique and false otherwise\n+     */\n+    private boolean isUniqueClass(Tree exp) {\n+        AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);", "originalCommit": "e64f002019f132d05ab4d96c1493a327bf1710de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MTY4Nw==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r446791687", "bodyText": "I replaced exp with type as an argument in the isUniqueClass in my latest commit", "author": "aditya3434", "createdAt": "2020-06-29T06:08:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU3NDQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU4NjE5OA==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r445586198", "bodyText": "It might be easier as if (el == null) { return false; } and then the same for annoMirrors.", "author": "wmdietl", "createdAt": "2020-06-25T14:08:11Z", "path": "framework/src/main/java/org/checkerframework/common/aliasing/AliasingVisitor.java", "diffHunk": "@@ -271,7 +265,37 @@ private boolean canBeLeaked(Tree exp) {\n         AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);\n         boolean isMethodInvocation = exp.getKind() == Kind.METHOD_INVOCATION;\n         boolean isNewClass = exp.getKind() == Kind.NEW_CLASS;\n-        return type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        boolean isUniqueClassFlag = isUniqueClass(exp);\n+        if (isUniqueClassFlag) {\n+            return type.hasAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        } else {\n+            return type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        }\n+    }\n+\n+    /**\n+     * Returns true if class of tree expression {@code exp} has type {@code @Unique}\n+     *\n+     * @param exp the Tree to check\n+     * @return boolean true if class if unique and false otherwise\n+     */\n+    private boolean isUniqueClass(Tree exp) {\n+        AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);\n+        Element el = types.asElement(type.getUnderlyingType());\n+        if (el != null) {", "originalCommit": "e64f002019f132d05ab4d96c1493a327bf1710de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MTQyNg==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r446791426", "bodyText": "I have separated out el and annoMirrors checks instead of the nested if conditions. If either of them is null, the method returns false", "author": "aditya3434", "createdAt": "2020-06-29T06:07:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU4NjE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5MDU3Ng==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r445590576", "bodyText": "Again, don't use Strings for things like this. Can you use AnnotationUtils.containsSameByClass https://github.com/typetools/checker-framework/blob/master/javacutil/src/main/java/org/checkerframework/javacutil/AnnotationUtils.java#L230 ? Then you don't need the for loop.", "author": "wmdietl", "createdAt": "2020-06-25T14:14:04Z", "path": "framework/src/main/java/org/checkerframework/common/aliasing/AliasingVisitor.java", "diffHunk": "@@ -271,7 +265,37 @@ private boolean canBeLeaked(Tree exp) {\n         AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);\n         boolean isMethodInvocation = exp.getKind() == Kind.METHOD_INVOCATION;\n         boolean isNewClass = exp.getKind() == Kind.NEW_CLASS;\n-        return type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        boolean isUniqueClassFlag = isUniqueClass(exp);\n+        if (isUniqueClassFlag) {\n+            return type.hasAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        } else {\n+            return type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        }\n+    }\n+\n+    /**\n+     * Returns true if class of tree expression {@code exp} has type {@code @Unique}\n+     *\n+     * @param exp the Tree to check\n+     * @return boolean true if class if unique and false otherwise\n+     */\n+    private boolean isUniqueClass(Tree exp) {\n+        AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);\n+        Element el = types.asElement(type.getUnderlyingType());\n+        if (el != null) {\n+            Set<AnnotationMirror> annoMirrors = atypeFactory.getDeclAnnotations(el);\n+            if (annoMirrors != null) {\n+                for (AnnotationMirror mirror : annoMirrors) {\n+                    if (mirror.getAnnotationType()\n+                            .asElement()\n+                            .getSimpleName()\n+                            .contentEquals(\"Unique\")) {", "originalCommit": "e64f002019f132d05ab4d96c1493a327bf1710de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MTA4NA==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r446791084", "bodyText": "I have used the AnnotationUtils.containtsSameByClass method in my latest commit", "author": "aditya3434", "createdAt": "2020-06-29T06:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5MDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5MzEwMw==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r445593103", "bodyText": "Why do you need the type.hasAnnotation again, if you already know that isUniqueClass?", "author": "wmdietl", "createdAt": "2020-06-25T14:17:24Z", "path": "framework/src/main/java/org/checkerframework/common/aliasing/AliasingVisitor.java", "diffHunk": "@@ -271,7 +265,37 @@ private boolean canBeLeaked(Tree exp) {\n         AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);\n         boolean isMethodInvocation = exp.getKind() == Kind.METHOD_INVOCATION;\n         boolean isNewClass = exp.getKind() == Kind.NEW_CLASS;\n-        return type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        boolean isUniqueClassFlag = isUniqueClass(exp);\n+        if (isUniqueClassFlag) {\n+            return type.hasAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;", "originalCommit": "e64f002019f132d05ab4d96c1493a327bf1710de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MjE4OQ==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r446792189", "bodyText": "Yes, I see that was a redundant check. I have not used it in my latest commits", "author": "aditya3434", "createdAt": "2020-06-29T06:09:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5MzEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5MzM1Nw==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r445593357", "bodyText": "Remove the Flag part. Notice the style for the other is variables.", "author": "wmdietl", "createdAt": "2020-06-25T14:17:44Z", "path": "framework/src/main/java/org/checkerframework/common/aliasing/AliasingVisitor.java", "diffHunk": "@@ -271,7 +265,37 @@ private boolean canBeLeaked(Tree exp) {\n         AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);\n         boolean isMethodInvocation = exp.getKind() == Kind.METHOD_INVOCATION;\n         boolean isNewClass = exp.getKind() == Kind.NEW_CLASS;\n-        return type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        boolean isUniqueClassFlag = isUniqueClass(exp);", "originalCommit": "e64f002019f132d05ab4d96c1493a327bf1710de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MDY1MQ==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r446790651", "bodyText": "I have removed the flag part from the variable name in my latest commit", "author": "aditya3434", "createdAt": "2020-06-29T06:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5MzM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5NDQ1Ng==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r445594456", "bodyText": "Could this just be return !isMethodInvocation && !isNewClass && (isUniqueClass || type.hasExplicitAnnotation(Unique.class));", "author": "wmdietl", "createdAt": "2020-06-25T14:19:18Z", "path": "framework/src/main/java/org/checkerframework/common/aliasing/AliasingVisitor.java", "diffHunk": "@@ -271,7 +265,37 @@ private boolean canBeLeaked(Tree exp) {\n         AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);\n         boolean isMethodInvocation = exp.getKind() == Kind.METHOD_INVOCATION;\n         boolean isNewClass = exp.getKind() == Kind.NEW_CLASS;\n-        return type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        boolean isUniqueClassFlag = isUniqueClass(exp);\n+        if (isUniqueClassFlag) {", "originalCommit": "e64f002019f132d05ab4d96c1493a327bf1710de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5NDkxNw==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r445594917", "bodyText": "Maybe extract the (isUniqueClass || type.hasExplicitAnnotation(Unique.class) into a separate local and document why that is the logic.", "author": "wmdietl", "createdAt": "2020-06-25T14:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5NDQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MDQ1OQ==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r446790459", "bodyText": "I have separated the (isUniqueClass || type.hasExplicitAnnotation(Unique.class) into a separate local variable and documented the logic.", "author": "aditya3434", "createdAt": "2020-06-29T06:04:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5NDQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5NTU0MA==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r445595540", "bodyText": "You should also update the javadoc with the change in behavior.\nDo you understand what canBeLeaked expresses? The documentation is rather unclear.", "author": "wmdietl", "createdAt": "2020-06-25T14:20:49Z", "path": "framework/src/main/java/org/checkerframework/common/aliasing/AliasingVisitor.java", "diffHunk": "@@ -271,7 +265,37 @@ private boolean canBeLeaked(Tree exp) {\n         AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);", "originalCommit": "e64f002019f132d05ab4d96c1493a327bf1710de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5MDE1MA==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r446790150", "bodyText": "I have changed the documentation for the canBeLeaked method in my latest commit", "author": "aditya3434", "createdAt": "2020-06-29T06:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5NTU0MA=="}], "type": "inlineReview"}, {"oid": "167d9cc2e165a54dcfb83f1895a9b54832b3d381", "url": "https://github.com/typetools/checker-framework/commit/167d9cc2e165a54dcfb83f1895a9b54832b3d381", "message": "Merge branch 'master' into 3313-explicit-annotation-fix", "committedDate": "2020-06-27T15:34:49Z", "type": "commit"}, {"oid": "cf45fd642ed3dcfc7a47359153931db8dfcefb07", "url": "https://github.com/typetools/checker-framework/commit/cf45fd642ed3dcfc7a47359153931db8dfcefb07", "message": "Making requested changes", "committedDate": "2020-06-27T15:43:16Z", "type": "commit"}, {"oid": "f3d2479f72bb0993524035f5935ed6ad4eb7b93e", "url": "https://github.com/typetools/checker-framework/commit/f3d2479f72bb0993524035f5935ed6ad4eb7b93e", "message": "Modifying documentation", "committedDate": "2020-06-27T17:43:37Z", "type": "commit"}, {"oid": "9b60d8267437cd403164c6d5b0cf5e057e3e2453", "url": "https://github.com/typetools/checker-framework/commit/9b60d8267437cd403164c6d5b0cf5e057e3e2453", "message": "Deleting stubfile.astub", "committedDate": "2020-06-28T13:34:22Z", "type": "commit"}, {"oid": "1335ba2f18da1ca50c052d8a6774edce0f586cd4", "url": "https://github.com/typetools/checker-framework/commit/1335ba2f18da1ca50c052d8a6774edce0f586cd4", "message": "Removing stubfile.astub references", "committedDate": "2020-06-28T14:42:40Z", "type": "commit"}, {"oid": "1da41037e4707a913529a9fdd48ca5f522787325", "url": "https://github.com/typetools/checker-framework/commit/1da41037e4707a913529a9fdd48ca5f522787325", "message": "Merge branch 'master' into 3313-explicit-annotation-fix", "committedDate": "2020-07-11T09:28:32Z", "type": "commit"}, {"oid": "7b191e9ee37e0d31cdc3da69747cdd69162627cd", "url": "https://github.com/typetools/checker-framework/commit/7b191e9ee37e0d31cdc3da69747cdd69162627cd", "message": "Merge branch 'master' into 3313-explicit-annotation-fix", "committedDate": "2020-07-13T10:36:10Z", "type": "commit"}, {"oid": "bd1fe05b76132550a695141b826c6c0a70edf06c", "url": "https://github.com/typetools/checker-framework/commit/bd1fe05b76132550a695141b826c6c0a70edf06c", "message": "Merge branch 'master' into 3313-explicit-annotation-fix", "committedDate": "2020-07-15T07:35:43Z", "type": "commit"}, {"oid": "37976e86f016234919218e0413132c858505b064", "url": "https://github.com/typetools/checker-framework/commit/37976e86f016234919218e0413132c858505b064", "message": "Merge branch 'master' into 3313-explicit-annotation-fix", "committedDate": "2020-07-17T06:00:53Z", "type": "commit"}, {"oid": "152389766e5bce9d266c1662e184c9768ea44c29", "url": "https://github.com/typetools/checker-framework/commit/152389766e5bce9d266c1662e184c9768ea44c29", "message": "Merge branch 'master' into 3313-explicit-annotation-fix", "committedDate": "2020-07-18T06:53:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQwODMyNQ==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r457408325", "bodyText": "Do not use wildcard imports.", "author": "wmdietl", "createdAt": "2020-07-20T13:56:33Z", "path": "framework/src/main/java/org/checkerframework/common/aliasing/AliasingVisitor.java", "diffHunk": "@@ -10,8 +10,8 @@\n import com.sun.source.tree.VariableTree;\n import com.sun.source.util.TreePath;\n import java.util.List;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.VariableElement;\n+import java.util.Set;\n+import javax.lang.model.element.*;", "originalCommit": "152389766e5bce9d266c1662e184c9768ea44c29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYzNzUwNw==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r457637507", "bodyText": "We had this before: #3336 (comment)\nLook how to change your IDE configuration to not make such changes.", "author": "wmdietl", "createdAt": "2020-07-20T19:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQwODMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkwMzI4OQ==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r457903289", "bodyText": "I have changed the import statement in my latest commit. Turns out my IDE automatically * imports whenever it imports more than 3 packages.", "author": "aditya3434", "createdAt": "2020-07-21T07:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQwODMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2Nzk1Nw==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r457567957", "bodyText": "The summary should end with a period.", "author": "wmdietl", "createdAt": "2020-07-20T17:16:41Z", "path": "framework/src/main/java/org/checkerframework/common/aliasing/AliasingVisitor.java", "diffHunk": "@@ -263,15 +264,39 @@ protected void checkThisOrSuperConstructorCall(\n \n     /**\n      * Returns true if {@code exp} has type {@code @Unique} and is not a method invocation nor a new\n-     * class expression.\n+     * class expression. It checks whether the tree expression is unique by either checking for an\n+     * explicit annotation or checking whether the class of the tree expression {@code exp} has type\n+     * {@code @Unique}\n      *\n      * @param exp the Tree to check\n      */\n     private boolean canBeLeaked(Tree exp) {\n         AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);\n         boolean isMethodInvocation = exp.getKind() == Kind.METHOD_INVOCATION;\n         boolean isNewClass = exp.getKind() == Kind.NEW_CLASS;\n-        return type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        boolean isUniqueType = (isUniqueClass(type) || type.hasExplicitAnnotation(Unique.class));\n+        return isUniqueType && !isMethodInvocation && !isNewClass;\n+    }\n+\n+    /**\n+     * Returns true if class of annotated type {@code type} has annotation {@code @Unique}", "originalCommit": "152389766e5bce9d266c1662e184c9768ea44c29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYzNjA5OA==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r457636098", "bodyText": "Maybe use: Return true if the class declaration for annotated type ...", "author": "wmdietl", "createdAt": "2020-07-20T19:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2Nzk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkwMzQ3Mw==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r457903473", "bodyText": "I have adjusted the summary in my latest commit", "author": "aditya3434", "createdAt": "2020-07-21T07:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2Nzk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYzMzgwMA==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r457633800", "bodyText": "The outer parenthesis aren't necessary.", "author": "wmdietl", "createdAt": "2020-07-20T19:14:02Z", "path": "framework/src/main/java/org/checkerframework/common/aliasing/AliasingVisitor.java", "diffHunk": "@@ -263,15 +264,39 @@ protected void checkThisOrSuperConstructorCall(\n \n     /**\n      * Returns true if {@code exp} has type {@code @Unique} and is not a method invocation nor a new\n-     * class expression.\n+     * class expression. It checks whether the tree expression is unique by either checking for an\n+     * explicit annotation or checking whether the class of the tree expression {@code exp} has type\n+     * {@code @Unique}\n      *\n      * @param exp the Tree to check\n      */\n     private boolean canBeLeaked(Tree exp) {\n         AnnotatedTypeMirror type = atypeFactory.getAnnotatedType(exp);\n         boolean isMethodInvocation = exp.getKind() == Kind.METHOD_INVOCATION;\n         boolean isNewClass = exp.getKind() == Kind.NEW_CLASS;\n-        return type.hasExplicitAnnotation(Unique.class) && !isMethodInvocation && !isNewClass;\n+        boolean isUniqueType = (isUniqueClass(type) || type.hasExplicitAnnotation(Unique.class));", "originalCommit": "152389766e5bce9d266c1662e184c9768ea44c29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkwMzYzOA==", "url": "https://github.com/typetools/checker-framework/pull/3336#discussion_r457903638", "bodyText": "I have removed the parenthesis in my latest commit.", "author": "aditya3434", "createdAt": "2020-07-21T07:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYzMzgwMA=="}], "type": "inlineReview"}, {"oid": "79f35f1e341595575ab57dbe256670cd7863eb14", "url": "https://github.com/typetools/checker-framework/commit/79f35f1e341595575ab57dbe256670cd7863eb14", "message": "Merge branch 'master' into 3313-explicit-annotation-fix", "committedDate": "2020-07-21T06:13:30Z", "type": "commit"}, {"oid": "f6e67cc336dfff814dd8c6f916cc610479274639", "url": "https://github.com/typetools/checker-framework/commit/f6e67cc336dfff814dd8c6f916cc610479274639", "message": "Making requested changes", "committedDate": "2020-07-21T06:33:59Z", "type": "commit"}]}