{"pr_number": 3199, "pr_title": "[Issue 3063] Sync historical blocks", "pr_createdAt": "2020-11-11T21:33:58Z", "pr_url": "https://github.com/ConsenSys/teku/pull/3199", "timeline": [{"oid": "bdb07863d1ed5b87f8209e9d1fe164c05f697ea5", "url": "https://github.com/ConsenSys/teku/commit/bdb07863d1ed5b87f8209e9d1fe164c05f697ea5", "message": "Fix count calculation", "committedDate": "2020-11-11T22:30:57Z", "type": "forcePushed"}, {"oid": "b0b5dd74c7ef7d1140ecc0a845cbf3930a861e09", "url": "https://github.com/ConsenSys/teku/commit/b0b5dd74c7ef7d1140ecc0a845cbf3930a861e09", "message": "Add ability to subscribe to SyncState changes", "committedDate": "2020-11-12T22:11:51Z", "type": "commit"}, {"oid": "f18add2c93b4a3a600e05c2ba54f6a5be3066de3", "url": "https://github.com/ConsenSys/teku/commit/f18add2c93b4a3a600e05c2ba54f6a5be3066de3", "message": "Add API's for pulling the earliest available finalized block", "committedDate": "2020-11-12T22:11:52Z", "type": "commit"}, {"oid": "5732e04a4e185902a09d9d3565698acd5dab781e", "url": "https://github.com/ConsenSys/teku/commit/5732e04a4e185902a09d9d3565698acd5dab781e", "message": "Add UInt64.safeMinus() utility methods", "committedDate": "2020-11-12T22:11:52Z", "type": "commit"}, {"oid": "c2a4fa04b914540c76d24188a21f1ed1ed00b240", "url": "https://github.com/ConsenSys/teku/commit/c2a4fa04b914540c76d24188a21f1ed1ed00b240", "message": "Add API's to save historical blocks", "committedDate": "2020-11-12T22:11:52Z", "type": "commit"}, {"oid": "0583e2d3520d5eb93e0194818873b5b89fa2e36d", "url": "https://github.com/ConsenSys/teku/commit/0583e2d3520d5eb93e0194818873b5b89fa2e36d", "message": "Add HistoricalBlockSyncService", "committedDate": "2020-11-12T22:11:52Z", "type": "commit"}, {"oid": "91aedbbe2ce6d81654e57041f92af538b4bdd043", "url": "https://github.com/ConsenSys/teku/commit/91aedbbe2ce6d81654e57041f92af538b4bdd043", "message": "Add metrics", "committedDate": "2020-11-12T22:11:52Z", "type": "commit"}, {"oid": "f0c9ffa5e1a8d68d68ed2eb8bf1375e70a287207", "url": "https://github.com/ConsenSys/teku/commit/f0c9ffa5e1a8d68d68ed2eb8bf1375e70a287207", "message": "Fix count calculation", "committedDate": "2020-11-12T22:11:52Z", "type": "commit"}, {"oid": "2359596a23f31ebc68ff44bc903c512a396b057d", "url": "https://github.com/ConsenSys/teku/commit/2359596a23f31ebc68ff44bc903c512a396b057d", "message": "Add RespondingEth2Peer test utility", "committedDate": "2020-11-12T22:11:52Z", "type": "commit"}, {"oid": "f611eef77338dd1f8bc343aa02a31067ddab338d", "url": "https://github.com/ConsenSys/teku/commit/f611eef77338dd1f8bc343aa02a31067ddab338d", "message": "Tweak logs, error handling, range calculation, peer handling", "committedDate": "2020-11-12T22:11:52Z", "type": "commit"}, {"oid": "667bcdb638817834b3294b7b3153a8ebd0dfd20c", "url": "https://github.com/ConsenSys/teku/commit/667bcdb638817834b3294b7b3153a8ebd0dfd20c", "message": "Add HistoricalBatchFetcherTest implementation", "committedDate": "2020-11-12T22:11:52Z", "type": "commit"}, {"oid": "d5fd768754f85a9a2f4c2e8bfac7cf3152b04d05", "url": "https://github.com/ConsenSys/teku/commit/d5fd768754f85a9a2f4c2e8bfac7cf3152b04d05", "message": "Add logging around bad peers", "committedDate": "2020-11-12T22:11:52Z", "type": "commit"}, {"oid": "2e27cbd54f0a885089e2b92e8b5a48acc85b1e14", "url": "https://github.com/ConsenSys/teku/commit/2e27cbd54f0a885089e2b92e8b5a48acc85b1e14", "message": "Fix batch fetcher processing of extra blocks, add test", "committedDate": "2020-11-12T22:11:52Z", "type": "commit"}, {"oid": "9b6151813d796c78f74c04dac79dcbb6783cc8fe", "url": "https://github.com/ConsenSys/teku/commit/9b6151813d796c78f74c04dac79dcbb6783cc8fe", "message": "Add HistoricalBlockSyncServiceTest", "committedDate": "2020-11-12T22:11:52Z", "type": "commit"}, {"oid": "9b6151813d796c78f74c04dac79dcbb6783cc8fe", "url": "https://github.com/ConsenSys/teku/commit/9b6151813d796c78f74c04dac79dcbb6783cc8fe", "message": "Add HistoricalBlockSyncServiceTest", "committedDate": "2020-11-12T22:11:52Z", "type": "forcePushed"}, {"oid": "1cdad6b9d21f820501ccfcd892f06eab7e558940", "url": "https://github.com/ConsenSys/teku/commit/1cdad6b9d21f820501ccfcd892f06eab7e558940", "message": "Add javadoc", "committedDate": "2020-11-12T22:46:22Z", "type": "commit"}, {"oid": "9066f6941ed7f8f099dbb0d9334de4e6be895bd2", "url": "https://github.com/ConsenSys/teku/commit/9066f6941ed7f8f099dbb0d9334de4e6be895bd2", "message": "Fix edge cases around syncing genesis and handling missing earliest block", "committedDate": "2020-11-12T23:02:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk2MTk1OQ==", "url": "https://github.com/ConsenSys/teku/pull/3199#discussion_r522961959", "bodyText": "I would add own interface than using one from log4j", "author": "Nashatyrev", "createdAt": "2020-11-13T13:51:27Z", "path": "infrastructure/subscribers/src/main/java/tech/pegasys/teku/infrastructure/subscribers/Subscribers.java", "diffHunk": "@@ -20,6 +20,7 @@\n import java.util.function.Consumer;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.util.TriConsumer;", "originalCommit": "9066f6941ed7f8f099dbb0d9334de4e6be895bd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA2OTQ0Nw==", "url": "https://github.com/ConsenSys/teku/pull/3199#discussion_r523069447", "bodyText": "oops - good catch, thought this was from the java.util.function package", "author": "mbaxter", "createdAt": "2020-11-13T16:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk2MTk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk2MzM2Mg==", "url": "https://github.com/ConsenSys/teku/pull/3199#discussion_r522963362", "bodyText": "I found this method used just in a test. Do we really need to add this method instead of just using forEach() (see comment for RespondingEth2Peer)?", "author": "Nashatyrev", "createdAt": "2020-11-13T13:54:01Z", "path": "infrastructure/subscribers/src/main/java/tech/pegasys/teku/infrastructure/subscribers/Subscribers.java", "diffHunk": "@@ -117,6 +118,20 @@ public void forEach(final Consumer<T> action) {\n     forEach(subscriber -> eventMethod.accept(subscriber, event));\n   }\n \n+  /**\n+   * Deliver an event to each subscriber by calling eventMethod.\n+   *\n+   * @param eventMethod the method to call\n+   * @param arg1 the first event argument to provide as a parameter\n+   * @param arg2 the second event argument to provide as a parameter\n+   * @param <A1> the type of the first argument\n+   * @param <A2> the type of the second argument\n+   */\n+  public <A1, A2> void deliver(\n+      final TriConsumer<T, A1, A2> eventMethod, final A1 arg1, final A2 arg2) {\n+    forEach(subscriber -> eventMethod.accept(subscriber, arg1, arg2));\n+  }\n+", "originalCommit": "9066f6941ed7f8f099dbb0d9334de4e6be895bd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk2NDI2Ng==", "url": "https://github.com/ConsenSys/teku/pull/3199#discussion_r522964266", "bodyText": "May be this way to avoid adding a new method to Subscribers?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                disconnectSubscribers.deliver(\n          \n          \n            \n                    PeerDisconnectedSubscriber::onDisconnected, reason, locallyInitiated);\n          \n          \n            \n                disconnectSubscribers\n          \n          \n            \n                    .forEach(subscriber -> subscriber.onDisconnected(reason, locallyInitiated));", "author": "Nashatyrev", "createdAt": "2020-11-13T13:55:32Z", "path": "networking/eth2/src/testFixtures/java/tech/pegasys/teku/networking/eth2/peers/RespondingEth2Peer.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.peers;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.core.ChainBuilder;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.teku.datastructures.blocks.StateAndBlockSummary;\n+import tech.pegasys.teku.datastructures.networking.libp2p.rpc.MetadataMessage;\n+import tech.pegasys.teku.datastructures.networking.libp2p.rpc.RpcRequest;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.subscribers.Subscribers;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.networking.eth2.rpc.core.Eth2RpcMethod;\n+import tech.pegasys.teku.networking.eth2.rpc.core.ResponseCallback;\n+import tech.pegasys.teku.networking.eth2.rpc.core.ResponseStreamListener;\n+import tech.pegasys.teku.networking.eth2.rpc.core.RpcException;\n+import tech.pegasys.teku.networking.p2p.mock.MockNodeIdGenerator;\n+import tech.pegasys.teku.networking.p2p.network.PeerAddress;\n+import tech.pegasys.teku.networking.p2p.peer.DisconnectReason;\n+import tech.pegasys.teku.networking.p2p.peer.DisconnectRequestHandler;\n+import tech.pegasys.teku.networking.p2p.peer.NodeId;\n+import tech.pegasys.teku.networking.p2p.peer.Peer;\n+import tech.pegasys.teku.networking.p2p.peer.PeerDisconnectedSubscriber;\n+import tech.pegasys.teku.networking.p2p.reputation.ReputationAdjustment;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcMethod;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcRequestHandler;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitvector;\n+import tech.pegasys.teku.ssz.SSZTypes.Bytes4;\n+\n+public class RespondingEth2Peer implements Eth2Peer {\n+  private static final MockNodeIdGenerator idGenerator = new MockNodeIdGenerator();\n+  private static final Bytes4 forkDigest = Bytes4.fromHexString(\"0x11223344\");\n+\n+  private final ChainBuilder chain;\n+  private final List<ChainBuilder> forks;\n+\n+  private final NodeId nodeId;\n+  private final Subscribers<PeerStatusSubscriber> statusSubscribers = Subscribers.create(false);\n+  private final Subscribers<PeerDisconnectedSubscriber> disconnectSubscribers =\n+      Subscribers.create(false);\n+\n+  private PeerStatus status;\n+  private boolean disconnected = false;\n+\n+  private final List<PendingBlockRequest<?>> pendingRequests = new ArrayList<>();\n+  private Function<List<SignedBeaconBlock>, List<SignedBeaconBlock>> blockRequestFilter =\n+      Function.identity();\n+\n+  private RespondingEth2Peer(\n+      final ChainBuilder chain, final List<ChainBuilder> forks, final PeerStatus status) {\n+    this.chain = chain;\n+    this.forks = forks;\n+    this.status = status;\n+\n+    this.nodeId = idGenerator.next();\n+  }\n+\n+  public static RespondingEth2Peer create(\n+      final ChainBuilder chain, final ChainBuilder... forkChains) {\n+    return new RespondingEth2Peer(\n+        chain, Arrays.asList(forkChains), createStatus(chain.getLatestBlockAndState()));\n+  }\n+\n+  private static PeerStatus createStatus(final StateAndBlockSummary head) {\n+    final Checkpoint finalizedCheckpoint = head.getState().getFinalized_checkpoint();\n+    return new PeerStatus(\n+        forkDigest,\n+        finalizedCheckpoint.getRoot(),\n+        finalizedCheckpoint.getEpoch(),\n+        head.getRoot(),\n+        head.getSlot());\n+  }\n+\n+  private static PeerStatus createStatus(final Checkpoint head, final Checkpoint finalized) {\n+    return new PeerStatus(\n+        forkDigest,\n+        finalized.getRoot(),\n+        finalized.getEpoch(),\n+        head.getRoot(),\n+        head.getEpochStartSlot());\n+  }\n+\n+  public void updateStatus(final Checkpoint head, final Checkpoint finalized) {\n+    updateStatus(createStatus(head, finalized));\n+  }\n+\n+  @Override\n+  public int getOutstandingRequests() {\n+    return pendingRequests.size();\n+  }\n+\n+  public void completePendingRequests() {\n+    final List<PendingBlockRequest<?>> requests = new ArrayList<>(pendingRequests);\n+\n+    for (PendingBlockRequest<?> request : requests) {\n+      request.complete();\n+      pendingRequests.remove(request);\n+    }\n+  }\n+\n+  public void setBlockRequestFilter(\n+      Function<List<SignedBeaconBlock>, List<SignedBeaconBlock>> filter) {\n+    this.blockRequestFilter = filter;\n+  }\n+\n+  @Override\n+  public void updateStatus(final PeerStatus status) {\n+    this.status = status;\n+    statusSubscribers.deliver(PeerStatusSubscriber::onPeerStatus, status);\n+  }\n+\n+  @Override\n+  public void updateMetadataSeqNumber(final UInt64 seqNumber) {}\n+\n+  @Override\n+  public void subscribeInitialStatus(final PeerStatusSubscriber subscriber) {\n+    subscriber.onPeerStatus(status);\n+  }\n+\n+  @Override\n+  public void subscribeStatusUpdates(final PeerStatusSubscriber subscriber) {\n+    statusSubscribers.subscribe(subscriber);\n+  }\n+\n+  @Override\n+  public PeerStatus getStatus() {\n+    return status;\n+  }\n+\n+  @Override\n+  public Optional<Bitvector> getRemoteAttestationSubnets() {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public UInt64 finalizedEpoch() {\n+    return status.getFinalizedEpoch();\n+  }\n+\n+  @Override\n+  public boolean hasStatus() {\n+    return true;\n+  }\n+\n+  @Override\n+  public SafeFuture<PeerStatus> sendStatus() {\n+    return SafeFuture.completedFuture(status);\n+  }\n+\n+  @Override\n+  public SafeFuture<Void> sendGoodbye(final UInt64 reason) {\n+    return SafeFuture.COMPLETE;\n+  }\n+\n+  @Override\n+  public SafeFuture<Void> requestBlocksByRange(\n+      final UInt64 startSlot,\n+      final UInt64 count,\n+      final UInt64 step,\n+      final ResponseStreamListener<SignedBeaconBlock> listener) {\n+    final long lastSlotExclusive = startSlot.longValue() + count.longValue() * step.longValue();\n+\n+    final PendingBlockRequestHandler<Void> handler =\n+        PendingBlockRequestHandler.createForBatchRequest(\n+            listener,\n+            () ->\n+                chain\n+                    .streamBlocksAndStates(startSlot.longValue(), lastSlotExclusive + 1)\n+                    .filter(b -> b.getSlot().minus(startSlot).mod(step).equals(UInt64.ZERO))\n+                    .map(SignedBlockAndState::getBlock)\n+                    .collect(Collectors.toList()));\n+    return createPendingRequest(handler);\n+  }\n+\n+  @Override\n+  public SafeFuture<Void> requestBlocksByRoot(\n+      final List<Bytes32> blockRoots, final ResponseStreamListener<SignedBeaconBlock> listener)\n+      throws RpcException {\n+    final PendingBlockRequestHandler<Void> handler =\n+        PendingBlockRequestHandler.createForBatchRequest(\n+            listener,\n+            () ->\n+                blockRoots.stream()\n+                    .map(this::findBlockByRoot)\n+                    .flatMap(Optional::stream)\n+                    .collect(Collectors.toList()));\n+\n+    return createPendingRequest(handler);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<SignedBeaconBlock>> requestBlockBySlot(final UInt64 slot) {\n+    final PendingBlockRequestHandler<Optional<SignedBeaconBlock>> handler =\n+        PendingBlockRequestHandler.createForSingleBlockRequest(\n+            () -> Optional.ofNullable(chain.getBlockAtSlot(slot)));\n+\n+    return createPendingRequest(handler);\n+  }\n+\n+  @Override\n+  public SafeFuture<Optional<SignedBeaconBlock>> requestBlockByRoot(final Bytes32 blockRoot) {\n+    final PendingBlockRequestHandler<Optional<SignedBeaconBlock>> handler =\n+        PendingBlockRequestHandler.createForSingleBlockRequest(() -> findBlockByRoot(blockRoot));\n+\n+    return createPendingRequest(handler);\n+  }\n+\n+  private <T> SafeFuture<T> createPendingRequest(PendingBlockRequestHandler<T> handler) {\n+    final PendingBlockRequestHandler<T> filteredHandler =\n+        PendingBlockRequestHandler.filterRequest(handler, blockRequestFilter);\n+    final PendingBlockRequest<T> request = new PendingBlockRequest<>(filteredHandler);\n+\n+    pendingRequests.add(request);\n+    return request.getFuture();\n+  }\n+\n+  @Override\n+  public SafeFuture<MetadataMessage> requestMetadata() {\n+    return SafeFuture.completedFuture(MetadataMessage.createDefault());\n+  }\n+\n+  @Override\n+  public <I extends RpcRequest, O> SafeFuture<O> requestSingleItem(\n+      final Eth2RpcMethod<I, O> method, final I request) {\n+    return SafeFuture.failedFuture(new UnsupportedOperationException());\n+  }\n+\n+  @Override\n+  public boolean wantToReceiveObjects(\n+      final ResponseCallback<SignedBeaconBlock> callback, final long objectCount) {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean wantToMakeRequest() {\n+    return true;\n+  }\n+\n+  @Override\n+  public SafeFuture<UInt64> sendPing() {\n+    return SafeFuture.completedFuture(UInt64.ONE);\n+  }\n+\n+  @Override\n+  public int getOutstandingPings() {\n+    return 0;\n+  }\n+\n+  @Override\n+  public NodeId getId() {\n+    return nodeId;\n+  }\n+\n+  @Override\n+  public PeerAddress getAddress() {\n+    return new PeerAddress(nodeId);\n+  }\n+\n+  @Override\n+  public boolean isConnected() {\n+    return !disconnected;\n+  }\n+\n+  @Override\n+  public void disconnectImmediately(\n+      final Optional<DisconnectReason> reason, final boolean locallyInitiated) {\n+    disconnect(reason, locallyInitiated);\n+  }\n+\n+  @Override\n+  public SafeFuture<Void> disconnectCleanly(final DisconnectReason reason) {\n+    disconnect(Optional.of(reason), true);\n+    return SafeFuture.COMPLETE;\n+  }\n+\n+  private void disconnect(Optional<DisconnectReason> reason, boolean locallyInitiated) {\n+    disconnected = true;\n+    disconnectSubscribers.deliver(\n+        PeerDisconnectedSubscriber::onDisconnected, reason, locallyInitiated);", "originalCommit": "9066f6941ed7f8f099dbb0d9334de4e6be895bd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk4NTIyMA==", "url": "https://github.com/ConsenSys/teku/pull/3199#discussion_r522985220", "bodyText": "Sorry, couldn't follow the logic: if have LatestFinalizedBlock why don't we have EarliestAvailableBlock?", "author": "Nashatyrev", "createdAt": "2020-11-13T14:30:12Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -238,6 +240,38 @@ public void update(final StorageUpdate event) {\n     doUpdate(event);\n   }\n \n+  @Override\n+  public void storeFinalizedBlocks(final Collection<SignedBeaconBlock> blocks) {\n+    if (blocks.isEmpty()) {\n+      return;\n+    }\n+\n+    // Sort blocks and verify that they are contiguous with the oldestBlock\n+    final List<SignedBeaconBlock> sorted =\n+        blocks.stream()\n+            .sorted(Comparator.comparing(SignedBeaconBlock::getSlot).reversed())\n+            .collect(Collectors.toList());\n+\n+    // The new block should be just prior to our earliest block if available, and otherwise should\n+    // match our latest finalized block", "originalCommit": "9066f6941ed7f8f099dbb0d9334de4e6be895bd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA3Nzk1Mw==", "url": "https://github.com/ConsenSys/teku/pull/3199#discussion_r523077953", "bodyText": "The method getLatestFinalizedBlock name isn't very clear - should probably be getLatestFinalizedBlockOrSummary.  Basically we always have a latestFinalizedState and latest finalized checkpoint available in the hot db.  But if we start up from a state alone, we won't have the latest finalized block.  So, getLatestFinalizedBlock tries to look up the latest finalized block by root, and if that fails it returns the latest block header from the latest finalized state.\nI'll try to clean this up - should probably add a method that directly returns the block header from the latest finalized state.", "author": "mbaxter", "createdAt": "2020-11-13T16:53:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk4NTIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk4OTkzNw==", "url": "https://github.com/ConsenSys/teku/pull/3199#discussion_r522989937", "bodyText": "May be better that way?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return initialize().thenAccept(__ -> requestBlocksIfAppropriate());\n          \n          \n            \n                return initialize().thenRun(this::requestBlocksIfAppropriate);", "author": "Nashatyrev", "createdAt": "2020-11-13T14:37:32Z", "path": "sync/src/main/java/tech/pegasys/teku/sync/historical/HistoricalBlockSyncService.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.sync.historical;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.cache.CacheBuilder;\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.hyperledger.besu.plugin.services.MetricsSystem;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlockSummary;\n+import tech.pegasys.teku.infrastructure.async.AsyncRunner;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.metrics.SettableGauge;\n+import tech.pegasys.teku.infrastructure.metrics.TekuMetricCategory;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.networking.eth2.peers.Eth2Peer;\n+import tech.pegasys.teku.networking.p2p.network.P2PNetwork;\n+import tech.pegasys.teku.networking.p2p.peer.NodeId;\n+import tech.pegasys.teku.service.serviceutils.Service;\n+import tech.pegasys.teku.storage.api.StorageUpdateChannel;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.sync.events.SyncStateProvider;\n+\n+/**\n+ * Service responsible for syncing missing historical blocks. Blocks are pulled in order from the\n+ * newest unknown block back to genesis.\n+ */\n+public class HistoricalBlockSyncService extends Service {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private static final Duration RETRY_TIMEOUT = Duration.ofMinutes(1);\n+  private static final UInt64 BATCH_SIZE = UInt64.valueOf(50);\n+\n+  private final SettableGauge historicSyncGauge;\n+  private final StorageUpdateChannel storageUpdateChannel;\n+  private final AsyncRunner asyncRunner;\n+  private final P2PNetwork<Eth2Peer> network;\n+  private final CombinedChainDataClient chainData;\n+  private final SyncStateProvider syncStateProvider;\n+  private final UInt64 batchSize;\n+\n+  private final AtomicLong syncStateSubscription = new AtomicLong(-1);\n+  private final AtomicBoolean requestInProgress = new AtomicBoolean(false);\n+\n+  private volatile BeaconBlockSummary earliestBlock;\n+  final Set<NodeId> badPeerCache;\n+\n+  @VisibleForTesting\n+  HistoricalBlockSyncService(\n+      final MetricsSystem metricsSystem,\n+      final StorageUpdateChannel storageUpdateChannel,\n+      final AsyncRunner asyncRunner,\n+      final P2PNetwork<Eth2Peer> network,\n+      final CombinedChainDataClient chainData,\n+      final SyncStateProvider syncStateProvider,\n+      final UInt64 batchSize) {\n+    this.storageUpdateChannel = storageUpdateChannel;\n+\n+    this.asyncRunner = asyncRunner;\n+    this.network = network;\n+    this.chainData = chainData;\n+    this.syncStateProvider = syncStateProvider;\n+    this.batchSize = batchSize;\n+\n+    this.badPeerCache =\n+        Collections.newSetFromMap(\n+            CacheBuilder.newBuilder()\n+                .maximumSize(100)\n+                .expireAfterWrite(Duration.ofMinutes(5))\n+                .removalListener(__ -> logBadPeerCacheSize(false))\n+                .<NodeId, Boolean>build()\n+                .asMap());\n+\n+    this.historicSyncGauge =\n+        SettableGauge.create(\n+            metricsSystem,\n+            TekuMetricCategory.BEACON,\n+            \"historical_block_sync_earliest_block\",\n+            \"The slot of the earliest block retrieved by the historical block sync service\");\n+  }\n+\n+  public static HistoricalBlockSyncService create(\n+      final MetricsSystem metricsSystem,\n+      final StorageUpdateChannel storageUpdateChannel,\n+      final AsyncRunner asyncRunner,\n+      final P2PNetwork<Eth2Peer> network,\n+      final CombinedChainDataClient chainData,\n+      final SyncStateProvider syncStateProvider) {\n+    return new HistoricalBlockSyncService(\n+        metricsSystem,\n+        storageUpdateChannel,\n+        asyncRunner,\n+        network,\n+        chainData,\n+        syncStateProvider,\n+        BATCH_SIZE);\n+  }\n+\n+  @Override\n+  protected SafeFuture<?> doStart() {\n+    LOG.debug(\"Start {}\", getClass().getSimpleName());\n+    return initialize().thenAccept(__ -> requestBlocksIfAppropriate());", "originalCommit": "9066f6941ed7f8f099dbb0d9334de4e6be895bd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk5Nzc5NA==", "url": "https://github.com/ConsenSys/teku/pull/3199#discussion_r522997794", "bodyText": "Maybe move thenAccept() before exceptionally() and remove newValue != null condition? Would look a bit more clear imho.", "author": "Nashatyrev", "createdAt": "2020-11-13T14:49:35Z", "path": "sync/src/main/java/tech/pegasys/teku/sync/historical/HistoricalBlockSyncService.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.sync.historical;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.cache.CacheBuilder;\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.hyperledger.besu.plugin.services.MetricsSystem;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlockSummary;\n+import tech.pegasys.teku.infrastructure.async.AsyncRunner;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.metrics.SettableGauge;\n+import tech.pegasys.teku.infrastructure.metrics.TekuMetricCategory;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.networking.eth2.peers.Eth2Peer;\n+import tech.pegasys.teku.networking.p2p.network.P2PNetwork;\n+import tech.pegasys.teku.networking.p2p.peer.NodeId;\n+import tech.pegasys.teku.service.serviceutils.Service;\n+import tech.pegasys.teku.storage.api.StorageUpdateChannel;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.sync.events.SyncStateProvider;\n+\n+/**\n+ * Service responsible for syncing missing historical blocks. Blocks are pulled in order from the\n+ * newest unknown block back to genesis.\n+ */\n+public class HistoricalBlockSyncService extends Service {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private static final Duration RETRY_TIMEOUT = Duration.ofMinutes(1);\n+  private static final UInt64 BATCH_SIZE = UInt64.valueOf(50);\n+\n+  private final SettableGauge historicSyncGauge;\n+  private final StorageUpdateChannel storageUpdateChannel;\n+  private final AsyncRunner asyncRunner;\n+  private final P2PNetwork<Eth2Peer> network;\n+  private final CombinedChainDataClient chainData;\n+  private final SyncStateProvider syncStateProvider;\n+  private final UInt64 batchSize;\n+\n+  private final AtomicLong syncStateSubscription = new AtomicLong(-1);\n+  private final AtomicBoolean requestInProgress = new AtomicBoolean(false);\n+\n+  private volatile BeaconBlockSummary earliestBlock;\n+  final Set<NodeId> badPeerCache;\n+\n+  @VisibleForTesting\n+  HistoricalBlockSyncService(\n+      final MetricsSystem metricsSystem,\n+      final StorageUpdateChannel storageUpdateChannel,\n+      final AsyncRunner asyncRunner,\n+      final P2PNetwork<Eth2Peer> network,\n+      final CombinedChainDataClient chainData,\n+      final SyncStateProvider syncStateProvider,\n+      final UInt64 batchSize) {\n+    this.storageUpdateChannel = storageUpdateChannel;\n+\n+    this.asyncRunner = asyncRunner;\n+    this.network = network;\n+    this.chainData = chainData;\n+    this.syncStateProvider = syncStateProvider;\n+    this.batchSize = batchSize;\n+\n+    this.badPeerCache =\n+        Collections.newSetFromMap(\n+            CacheBuilder.newBuilder()\n+                .maximumSize(100)\n+                .expireAfterWrite(Duration.ofMinutes(5))\n+                .removalListener(__ -> logBadPeerCacheSize(false))\n+                .<NodeId, Boolean>build()\n+                .asMap());\n+\n+    this.historicSyncGauge =\n+        SettableGauge.create(\n+            metricsSystem,\n+            TekuMetricCategory.BEACON,\n+            \"historical_block_sync_earliest_block\",\n+            \"The slot of the earliest block retrieved by the historical block sync service\");\n+  }\n+\n+  public static HistoricalBlockSyncService create(\n+      final MetricsSystem metricsSystem,\n+      final StorageUpdateChannel storageUpdateChannel,\n+      final AsyncRunner asyncRunner,\n+      final P2PNetwork<Eth2Peer> network,\n+      final CombinedChainDataClient chainData,\n+      final SyncStateProvider syncStateProvider) {\n+    return new HistoricalBlockSyncService(\n+        metricsSystem,\n+        storageUpdateChannel,\n+        asyncRunner,\n+        network,\n+        chainData,\n+        syncStateProvider,\n+        BATCH_SIZE);\n+  }\n+\n+  @Override\n+  protected SafeFuture<?> doStart() {\n+    LOG.debug(\"Start {}\", getClass().getSimpleName());\n+    return initialize().thenAccept(__ -> requestBlocksIfAppropriate());\n+  }\n+\n+  @Override\n+  protected SafeFuture<?> doStop() {\n+    LOG.debug(\"Stop {}\", getClass().getSimpleName());\n+    syncStateProvider.unsubscribeFromSyncStateChanges(syncStateSubscription.get());\n+    badPeerCache.clear();\n+    return SafeFuture.COMPLETE;\n+  }\n+\n+  private SafeFuture<Void> initialize() {\n+    return chainData\n+        .getEarliestAvailableBlockSummary()\n+        .thenAccept(\n+            beaconBlockSummary -> {\n+              this.earliestBlock =\n+                  beaconBlockSummary.orElseThrow(\n+                      () -> new IllegalStateException(\"Unable to retrieve earliest block\"));\n+              if (earliestBlock.getSlot().isGreaterThan(UInt64.ZERO)) {\n+                LOG.info(\n+                    \"Begin historical sync of blocks prior to slot {}\", earliestBlock.getSlot());\n+                updateSyncMetrics();\n+              }\n+              syncStateSubscription.set(\n+                  syncStateProvider.subscribeToSyncStateChanges(\n+                      __ -> requestBlocksIfAppropriate()));\n+            });\n+  }\n+\n+  private void updateSyncMetrics() {\n+    if (earliestBlock.getBeaconBlock().isPresent()) {\n+      historicSyncGauge.set(earliestBlock.getSlot().bigIntegerValue().doubleValue());\n+    }\n+  }\n+\n+  private void requestBlocksIfAppropriate() {\n+    final Optional<MaxMissingBlockParams> blockParams = getMaxMissingBlockParams();\n+    if (blockParams.isEmpty()) {\n+      // Nothing to do - we're caught up to genesis\n+      LOG.info(\"Historical block sync is complete\");\n+      this.stop().reportExceptions();\n+    } else if (isRunning() && syncStateProvider.getCurrentSyncState().isInSync()) {\n+      // Pull the next batch of blocks\n+      findPeerAndRequestBlocks(blockParams.get());\n+    }\n+  }\n+\n+  private void findPeerAndRequestBlocks(final MaxMissingBlockParams params) {\n+    if (requestInProgress.compareAndSet(false, true)) {\n+      findPeer()\n+          .map(peer -> requestBlocks(peer, params))\n+          .orElseGet(this::waitToRetry)\n+          .alwaysRun(() -> requestInProgress.set(false))\n+          .always(this::requestBlocksIfAppropriate);\n+    }\n+  }\n+\n+  private SafeFuture<Void> requestBlocks(final Eth2Peer peer, final MaxMissingBlockParams params) {\n+    return createFetcher(peer, params)\n+        .run()\n+        .exceptionally(\n+            (err) -> {\n+              // We ran into trouble with this peer - ignore it for a while\n+              LOG.debug(\n+                  \"Encountered a problem requesting historical blocks from peer: \" + peer, err);\n+              if (peer.isConnected()) {\n+                // If we didn't disconnect the peer altogether, avoid making new requests for a\n+                // while\n+                badPeerCache.add(peer.getId());\n+                logBadPeerCacheSize(true);\n+              }\n+              return null;\n+            })\n+        .thenAccept(\n+            newValue -> {\n+              if (newValue != null && newValue.getSlot().isLessThanOrEqualTo(params.getMaxSlot())) {\n+                LOG.trace(\"Synced historical blocks to slot {}\", newValue.getSlot());\n+                earliestBlock = newValue;\n+                updateSyncMetrics();\n+              }\n+            });", "originalCommit": "9066f6941ed7f8f099dbb0d9334de4e6be895bd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA3OTI0Nw==", "url": "https://github.com/ConsenSys/teku/pull/3199#discussion_r523079247", "bodyText": "It would read more clearly, but if the thenAccept method throws for some reason, I wouldn't want to assume the error is coming from the fetch task.", "author": "mbaxter", "createdAt": "2020-11-13T16:55:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk5Nzc5NA=="}], "type": "inlineReview"}, {"oid": "59617fb6a6ab1368caa5df5228e6bc7598d0e343", "url": "https://github.com/ConsenSys/teku/commit/59617fb6a6ab1368caa5df5228e6bc7598d0e343", "message": "Merge branch 'master' into issue-3063/sync-historical-blocks", "committedDate": "2020-11-13T16:58:09Z", "type": "commit"}, {"oid": "8548182f840b1902d9637700fd911fe8f3966fee", "url": "https://github.com/ConsenSys/teku/commit/8548182f840b1902d9637700fd911fe8f3966fee", "message": "Cut new Subscribers helper method", "committedDate": "2020-11-13T17:01:27Z", "type": "commit"}, {"oid": "7da73e2ca7a3bff644ce846df0242c0ce44ff34b", "url": "https://github.com/ConsenSys/teku/commit/7da73e2ca7a3bff644ce846df0242c0ce44ff34b", "message": "Clarify RocksDbDatabase methods to retrieve latest finalized block data", "committedDate": "2020-11-13T17:06:56Z", "type": "commit"}, {"oid": "bee6641d3f9f74375412af6d172e5f7ce9cd8225", "url": "https://github.com/ConsenSys/teku/commit/bee6641d3f9f74375412af6d172e5f7ce9cd8225", "message": "Simplify code", "committedDate": "2020-11-13T17:09:12Z", "type": "commit"}, {"oid": "034a128c09fb9bf85be78c6186869344826668a4", "url": "https://github.com/ConsenSys/teku/commit/034a128c09fb9bf85be78c6186869344826668a4", "message": "Cleanup - no need to special-case disconnect errors, simplify test", "committedDate": "2020-11-13T19:07:38Z", "type": "commit"}]}