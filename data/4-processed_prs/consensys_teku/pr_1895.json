{"pr_number": 1895, "pr_title": "v0.12 bls", "pr_createdAt": "2020-05-22T10:51:59Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1895", "timeline": [{"oid": "2fc08eb87507b1b864a41fa6587ed459bdb08fab", "url": "https://github.com/ConsenSys/teku/commit/2fc08eb87507b1b864a41fa6587ed459bdb08fab", "message": "Add reference tests and tidy up", "committedDate": "2020-05-28T06:34:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI3Njc4Mg==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r433276782", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (publicKeys.isEmpty()) {\n          \n          \n            \n                if (publicKeys.isEmpty() || messages.isEmpty()) {", "author": "cemozerr", "createdAt": "2020-06-01T14:44:02Z", "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "diffHunk": "@@ -94,6 +100,9 @@ public static BLSSignature aggregate(final Stream<BLSSignature> signatures) {\n    */\n   public static boolean aggregateVerify(\n       List<BLSPublicKey> publicKeys, List<Bytes> messages, BLSSignature signature) {\n+    if (publicKeys.isEmpty()) {", "originalCommit": "cf0b26e59c613532f6638ce1a302e952fab0a12c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNzgwNA==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r434437804", "bodyText": "Yeah, this check is redundant here as publicKeys must be the same length as messages. But you've made me realise that for consistency with the standard we should also do the length check here (it's currently only checked elsewhere), and the uniqueness check for messages. So I'm going to rework some of this.", "author": "benjaminion", "createdAt": "2020-06-03T09:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI3Njc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzNDI3OQ==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r433334279", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final int zero0 = this.fp2.getA().iszilch() ? 1 : 0;\n          \n          \n            \n                final int zero0 = fp2.getA().iszilch() ? 1 : 0;", "author": "cemozerr", "createdAt": "2020-06-01T16:03:44Z", "path": "bls/src/main/java/tech/pegasys/teku/bls/hashToG2/FP2Immutable.java", "diffHunk": "@@ -170,18 +170,17 @@ boolean iszilch() {\n   }\n \n   /**\n-   * Calculate the sign of the field element.\n+   * Calculate the \"sign\" of the field element in constant time.\n    *\n-   * <p>This is described in the \"Notation\" paragraph at the start of Section 2 of this paper:\n-   * https://eprint.iacr.org/2019/403.pdf\n+   * <p>Defined here: https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-07#section-4.1\n    *\n-   * @return -1 if x is the lexically larger of x and -1 * x, else returns 1\n+   * @return zero or one\n    */\n   int sgn0() {\n-    if (fp2.getB().iszilch()) {\n-      return BIG.comp(fp2.getA(), THRESHOLD) > 0 ? -1 : 1;\n-    }\n-    return BIG.comp(fp2.getB(), THRESHOLD) > 0 ? -1 : 1;\n+    final int sign0 = fp2.getA().parity();\n+    final int zero0 = this.fp2.getA().iszilch() ? 1 : 0;", "originalCommit": "cf0b26e59c613532f6638ce1a302e952fab0a12c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyOTMzMQ==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r434429331", "bodyText": "Thanks. I've cleaned up a few of these.", "author": "benjaminion", "createdAt": "2020-06-03T09:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzNDI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzNjYzNw==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r433336637", "bodyText": "nit: to be more in line with similar checks in the codebase it might be good to switch these asserts to checkArgument calls", "author": "cemozerr", "createdAt": "2020-06-01T16:08:09Z", "path": "bls/src/main/java/tech/pegasys/teku/bls/hashToG2/HashToCurve.java", "diffHunk": "@@ -57,28 +65,27 @@ public static boolean isInGroupG2(ECP2 point) {\n    * Hashes to the G2 curve as described in the new BLS standard.\n    *\n    * @param message the message to be hashed. This is usually the 32 byte message digest\n-   * @param cipherSuite the salt value for HKDF_Extract\n+   * @param dst the domain separation tag (DST)\n    * @return a point from the G2 group representing the message hash\n    */\n-  public static ECP2 hashToG2(Bytes message, Bytes cipherSuite) {\n+  public static ECP2 hashToG2(Bytes message, Bytes dst) {\n \n-    FP2Immutable u0 = hashToBase(message, (byte) 0, cipherSuite);\n-    FP2Immutable u1 = hashToBase(message, (byte) 1, cipherSuite);\n+    FP2Immutable[] u = hashToField(message, 2, dst);\n \n-    JacobianPoint q0 = mapToCurve(u0);\n-    JacobianPoint q1 = mapToCurve(u1);\n+    JacobianPoint q0 = mapToCurve(u[0]);\n+    JacobianPoint q1 = mapToCurve(u[1]);\n \n-    JacobianPoint p = iso3(q0.add(q1));\n+    JacobianPoint r = iso3(q0.add(q1));\n \n     // This should never fail, and the check is non-trivial, so we use an assert\n-    assert isOnCurve(p);\n+    assert isOnCurve(r);", "originalCommit": "cf0b26e59c613532f6638ce1a302e952fab0a12c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyOTA1Nw==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r434429057", "bodyText": "As per the comments in the code, the checks are very expensive and we don't want to be doing them for every hash. They are really only there as canaries if we suspect problems with the BLS stuff one day and so compile with asserts enabled.\nThey are also useful documentation - this is in line with Oracle's advice on the use of assertions for invariants: https://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html#usage-invariants", "author": "benjaminion", "createdAt": "2020-06-03T09:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzNjYzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMzkzMw==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r435333933", "bodyText": "TIL the interesting nature of assert keyword in Java. Now this makes sense.", "author": "cemozerr", "createdAt": "2020-06-04T15:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzNjYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM0MDAxNA==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r433340014", "bodyText": "Is there a specification for this method anywhere? It would be really useful for reviewing if there was.", "author": "cemozerr", "createdAt": "2020-06-01T16:14:28Z", "path": "bls/src/main/java/tech/pegasys/teku/bls/hashToG2/HashToCurve.java", "diffHunk": "@@ -57,28 +65,27 @@ public static boolean isInGroupG2(ECP2 point) {\n    * Hashes to the G2 curve as described in the new BLS standard.\n    *\n    * @param message the message to be hashed. This is usually the 32 byte message digest\n-   * @param cipherSuite the salt value for HKDF_Extract\n+   * @param dst the domain separation tag (DST)\n    * @return a point from the G2 group representing the message hash\n    */\n-  public static ECP2 hashToG2(Bytes message, Bytes cipherSuite) {\n+  public static ECP2 hashToG2(Bytes message, Bytes dst) {", "originalCommit": "cf0b26e59c613532f6638ce1a302e952fab0a12c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MDMxNA==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r434440314", "bodyText": "Hmm - it's complicated as it pulls together bits from across the hash-to-curve standard. But you're right, it would be useful to be explicit what's happening here. I'll try to add the relevant refs.", "author": "benjaminion", "createdAt": "2020-06-03T09:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM0MDAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM1ODk5Mw==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r433358993", "bodyText": "The spec seems to suggest that you should store the intermediate b_i values, concatenate them together, and return the first len_in_bytes. But we seem to be only returning the first len_in_bytes of b_ell. Am I missing something?", "author": "cemozerr", "createdAt": "2020-06-01T16:49:01Z", "path": "bls/src/main/java/tech/pegasys/teku/bls/hashToG2/Helper.java", "diffHunk": "@@ -62,65 +66,94 @@ static boolean isOnCurve(JacobianPoint p) {\n    * @return true if the point is in G2, false otherwise\n    */\n   static boolean isInG2(JacobianPoint p) {\n-    return isOnCurve(p) && g2_map_to_infinity(p).isInfinity();\n+    return isOnCurve(p) && mapG2ToInfinity(p).isInfinity();\n   }\n \n   /**\n-   * Apply a transformation that maps G2 elements, and only G2 elements, to infinity\n+   * Apply a transformation that maps G2 elements, and only G2 elements, to infinity.\n    *\n    * <p>Uses the technique from https://eprint.iacr.org/2019/814.pdf section 3.1\n    *\n-   * @return\n+   * @param p the point on the curve to test\n+   * @return the point at infinity iff p is in G2, otherwise an arbitrary point\n    */\n-  static JacobianPoint g2_map_to_infinity(JacobianPoint p) {\n+  @VisibleForTesting\n+  static JacobianPoint mapG2ToInfinity(JacobianPoint p) {\n     JacobianPoint psi1 = psi(p);\n     JacobianPoint psi2 = psi(psi1);\n     JacobianPoint psi3 = psi(psi2);\n     return mxChain(psi3).add(psi2).neg().add(p);\n   }\n \n   /**\n-   * Hashes a string msg of any length into an element of the FP2 field.\n+   * Produces a uniformly random byte string of arbitrary length using SHA-256.\n+   *\n+   * <p>As defined at https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-07#section-5.3.1\n    *\n-   * <p>As defined at https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-04#section-5.3\n+   * @param message the message to hash\n+   * @param dst the domain separation tag for the cipher suite\n+   * @param lengthInBytes the number of bytes we want to obtain\n+   * @return a uniformly random sequence of Bytes\n+   */\n+  @VisibleForTesting\n+  static Bytes expandMessage(Bytes message, Bytes dst, int lengthInBytes) {\n+    checkArgument(dst.size() < 256, \"The DST must be 255 bytes or fewer.\");\n+    checkArgument(lengthInBytes > 0, \"Number of bytes requested must be greater than zero.\");\n+\n+    final int ell = 1 + (lengthInBytes - 1) / SHA256_HASH_SIZE;\n+    checkArgument(ell <= 255, \"Too many bytes of output were requested.\");\n+\n+    byte[] uniformBytes = new byte[ell * SHA256_HASH_SIZE];\n+\n+    Bytes dstPrime = Bytes.concatenate(dst, Bytes.of((byte) dst.size()));\n+    Bytes zPad = Bytes.wrap(new byte[SHA256_BLOCK_SIZE]);\n+    Bytes libStr = Bytes.ofUnsignedShort(lengthInBytes);\n+    Bytes b0 =\n+        Hash.sha2_256(Bytes.concatenate(zPad, message, libStr, Bytes.of((byte) 0), dstPrime));\n+    Bytes bb = Hash.sha2_256(Bytes.concatenate(b0, Bytes.of((byte) 1), dstPrime));\n+    System.arraycopy(bb.toArrayUnsafe(), 0, uniformBytes, 0, SHA256_HASH_SIZE);\n+    for (int i = 1; i < ell; i++) {\n+      bb = Hash.sha2_256(Bytes.concatenate(b0.xor(bb), Bytes.of((byte) (i + 1)), dstPrime));", "originalCommit": "cf0b26e59c613532f6638ce1a302e952fab0a12c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzMzU3Ng==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r434433576", "bodyText": "The next line concatenates bb onto the uniformBytes array, so it's equivalent.\nThis is an optimisation - the way the Bytes library does concatenation we'd end up re-copying the whole of uniformBytes every time we added the next chunk, giving us O(n^2/2) copies to do rather than O(n) as we have here, where n is the number of chunks. It's not very important in the grand scheme of things as n is not large. But I find it more pleasing \ud83d\ude04", "author": "benjaminion", "createdAt": "2020-06-03T09:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM1ODk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM2MTU2Mg==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r433361562", "bodyText": "In the link we provided, m is set to 1. Also, at this function, it seems like we can't use the simplified method if m = 2. https://github.com/PegaSysEng/teku/pull/1895/files#diff-67f0ab02949d5471961bcee03eb59b9bR179", "author": "cemozerr", "createdAt": "2020-06-01T16:53:59Z", "path": "bls/src/main/java/tech/pegasys/teku/bls/hashToG2/Helper.java", "diffHunk": "@@ -62,65 +66,94 @@ static boolean isOnCurve(JacobianPoint p) {\n    * @return true if the point is in G2, false otherwise\n    */\n   static boolean isInG2(JacobianPoint p) {\n-    return isOnCurve(p) && g2_map_to_infinity(p).isInfinity();\n+    return isOnCurve(p) && mapG2ToInfinity(p).isInfinity();\n   }\n \n   /**\n-   * Apply a transformation that maps G2 elements, and only G2 elements, to infinity\n+   * Apply a transformation that maps G2 elements, and only G2 elements, to infinity.\n    *\n    * <p>Uses the technique from https://eprint.iacr.org/2019/814.pdf section 3.1\n    *\n-   * @return\n+   * @param p the point on the curve to test\n+   * @return the point at infinity iff p is in G2, otherwise an arbitrary point\n    */\n-  static JacobianPoint g2_map_to_infinity(JacobianPoint p) {\n+  @VisibleForTesting\n+  static JacobianPoint mapG2ToInfinity(JacobianPoint p) {\n     JacobianPoint psi1 = psi(p);\n     JacobianPoint psi2 = psi(psi1);\n     JacobianPoint psi3 = psi(psi2);\n     return mxChain(psi3).add(psi2).neg().add(p);\n   }\n \n   /**\n-   * Hashes a string msg of any length into an element of the FP2 field.\n+   * Produces a uniformly random byte string of arbitrary length using SHA-256.\n+   *\n+   * <p>As defined at https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-07#section-5.3.1\n    *\n-   * <p>As defined at https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-04#section-5.3\n+   * @param message the message to hash\n+   * @param dst the domain separation tag for the cipher suite\n+   * @param lengthInBytes the number of bytes we want to obtain\n+   * @return a uniformly random sequence of Bytes\n+   */\n+  @VisibleForTesting\n+  static Bytes expandMessage(Bytes message, Bytes dst, int lengthInBytes) {\n+    checkArgument(dst.size() < 256, \"The DST must be 255 bytes or fewer.\");\n+    checkArgument(lengthInBytes > 0, \"Number of bytes requested must be greater than zero.\");\n+\n+    final int ell = 1 + (lengthInBytes - 1) / SHA256_HASH_SIZE;\n+    checkArgument(ell <= 255, \"Too many bytes of output were requested.\");\n+\n+    byte[] uniformBytes = new byte[ell * SHA256_HASH_SIZE];\n+\n+    Bytes dstPrime = Bytes.concatenate(dst, Bytes.of((byte) dst.size()));\n+    Bytes zPad = Bytes.wrap(new byte[SHA256_BLOCK_SIZE]);\n+    Bytes libStr = Bytes.ofUnsignedShort(lengthInBytes);\n+    Bytes b0 =\n+        Hash.sha2_256(Bytes.concatenate(zPad, message, libStr, Bytes.of((byte) 0), dstPrime));\n+    Bytes bb = Hash.sha2_256(Bytes.concatenate(b0, Bytes.of((byte) 1), dstPrime));\n+    System.arraycopy(bb.toArrayUnsafe(), 0, uniformBytes, 0, SHA256_HASH_SIZE);\n+    for (int i = 1; i < ell; i++) {\n+      bb = Hash.sha2_256(Bytes.concatenate(b0.xor(bb), Bytes.of((byte) (i + 1)), dstPrime));\n+      System.arraycopy(bb.toArrayUnsafe(), 0, uniformBytes, i * SHA256_HASH_SIZE, SHA256_HASH_SIZE);\n+    }\n+    return Bytes.wrap(uniformBytes, 0, lengthInBytes);\n+  }\n+\n+  /**\n+   * Hashes a string msg of any length into one or more elements of the FP2 field.\n    *\n-   * <p>This is hash_to_base() in the reference code.\n+   * <p>As defined at https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-07#section-5.2\n    *\n    * @param message the message to hash\n-   * @param ctr 0, 1, or 2 - used to efficiently create independent instances of hash_to_base\n-   * @param salt key for the HMAC base hash\n+   * @param count the number of field elements to return\n+   * @param dst the domain separation tag for the cipher suite\n    * @return an element in FP2\n    */\n-  static FP2Immutable hashToBase(Bytes message, byte ctr, Bytes salt) {\n-\n-    final Bytes h2cBytes = Bytes.wrap(\"H2C\".getBytes(StandardCharsets.US_ASCII));\n-    final Bytes ctrBytes = Bytes.of(ctr);\n+  static FP2Immutable[] hashToField(Bytes message, int count, Bytes dst) {\n \n-    Bytes info, t;\n+    // See https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-07#section-8.8.1\n+    final int l = 64;\n+    // The extension degree of our field, FP2\n+    final int m = 2;", "originalCommit": "cf0b26e59c613532f6638ce1a302e952fab0a12c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNjAzNA==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r434436034", "bodyText": "The simplified version for m=2 is shown at the end of section 4.1 - that's what I'm using here. It's not possible to link to it more directly, unfortunately.", "author": "benjaminion", "createdAt": "2020-06-03T09:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM2MTU2Mg=="}], "type": "inlineReview"}, {"oid": "ffac7ee09f5b518286374ea1fe4641ff417225d0", "url": "https://github.com/ConsenSys/teku/commit/ffac7ee09f5b518286374ea1fe4641ff417225d0", "message": "Basically working", "committedDate": "2020-06-03T19:09:35Z", "type": "commit"}, {"oid": "3a6ee9d3d3473b4503029bbb82796f968904195f", "url": "https://github.com/ConsenSys/teku/commit/3a6ee9d3d3473b4503029bbb82796f968904195f", "message": "Mostly passing v12 BLS reference tests", "committedDate": "2020-06-03T19:09:35Z", "type": "commit"}, {"oid": "1d728f17a17a647e18036e663beea8b50a5a6a33", "url": "https://github.com/ConsenSys/teku/commit/1d728f17a17a647e18036e663beea8b50a5a6a33", "message": "Add reference tests and tidy up", "committedDate": "2020-06-03T19:11:58Z", "type": "commit"}, {"oid": "37b47aab48dba105984937d4b4eff4155ac0025c", "url": "https://github.com/ConsenSys/teku/commit/37b47aab48dba105984937d4b4eff4155ac0025c", "message": "Correct some comments", "committedDate": "2020-06-03T19:11:58Z", "type": "commit"}, {"oid": "a209f1079403d9c2a4a272e3b91d6f035d5cb147", "url": "https://github.com/ConsenSys/teku/commit/a209f1079403d9c2a4a272e3b91d6f035d5cb147", "message": "Tidy up use of 'this'", "committedDate": "2020-06-03T19:11:58Z", "type": "commit"}, {"oid": "46a13e1b6fd244d8a5df8e0c633580986c4b685d", "url": "https://github.com/ConsenSys/teku/commit/46a13e1b6fd244d8a5df8e0c633580986c4b685d", "message": "Add documentation", "committedDate": "2020-06-03T19:11:58Z", "type": "commit"}, {"oid": "84d0212fe7e47ae8b7918f07e02403a39574b9da", "url": "https://github.com/ConsenSys/teku/commit/84d0212fe7e47ae8b7918f07e02403a39574b9da", "message": "Add psi2 and psi3 functions as an optimisation", "committedDate": "2020-06-03T19:11:58Z", "type": "commit"}, {"oid": "93cf0a03a9e05df8adc5d824e8a6c873c97fc4b7", "url": "https://github.com/ConsenSys/teku/commit/93cf0a03a9e05df8adc5d824e8a6c873c97fc4b7", "message": "Follow the BLS standard a little more explicitly", "committedDate": "2020-06-03T19:11:58Z", "type": "commit"}, {"oid": "0b9d76f7eed245dc21c63df6b9f8329201f16a7e", "url": "https://github.com/ConsenSys/teku/commit/0b9d76f7eed245dc21c63df6b9f8329201f16a7e", "message": "Roll back psi3 - it is not needed", "committedDate": "2020-06-03T19:11:58Z", "type": "commit"}, {"oid": "0b9d76f7eed245dc21c63df6b9f8329201f16a7e", "url": "https://github.com/ConsenSys/teku/commit/0b9d76f7eed245dc21c63df6b9f8329201f16a7e", "message": "Roll back psi3 - it is not needed", "committedDate": "2020-06-03T19:11:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMjMzOQ==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r435132339", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Set<Bytes> set = new HashSet<>();\n          \n          \n            \n                for (Bytes message : messages) {\n          \n          \n            \n                  if (!set.add(message)) return false;\n          \n          \n            \n                }\n          \n          \n            \n                if (new HashSet<>(messages).size() != messages.size) return false;\n          \n      \n    \n    \n  \n\nMinor code size improvement", "author": "Nashatyrev", "createdAt": "2020-06-04T09:52:59Z", "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "diffHunk": "@@ -94,15 +105,29 @@ public static BLSSignature aggregate(final Stream<BLSSignature> signatures) {\n    */\n   public static boolean aggregateVerify(\n       List<BLSPublicKey> publicKeys, List<Bytes> messages, BLSSignature signature) {\n+    checkArgument(\n+        publicKeys.size() == messages.size(),\n+        \"Number of public keys and number of messages differs.\");\n+    if (publicKeys.isEmpty()) {\n+      return false;\n+    }\n+    // Check that there are no duplicate messages\n+    Set<Bytes> set = new HashSet<>();\n+    for (Bytes message : messages) {\n+      if (!set.add(message)) return false;\n+    }", "originalCommit": "0b9d76f7eed245dc21c63df6b9f8329201f16a7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE1NDA5NQ==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r435154095", "bodyText": "This is similar to how I first wrote it, but my ever-optimising brain thought that it might be better to stop building the HashSet early if we found a duplicate. But our sets will be small, and your suggestion is elegant, so I will adopt it \ud83d\ude03", "author": "benjaminion", "createdAt": "2020-06-04T10:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMjMzOQ=="}], "type": "inlineReview"}, {"oid": "504fb05b3fc8a74d4d70592a480357e8b1851894", "url": "https://github.com/ConsenSys/teku/commit/504fb05b3fc8a74d4d70592a480357e8b1851894", "message": "Simplify duplicate message detection", "committedDate": "2020-06-04T10:39:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM1MTY0Mw==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r435351643", "bodyText": "Is there a consensus that this is the expected behavior? Worried that this might lead to consensus failures.", "author": "cemozerr", "createdAt": "2020-06-04T15:33:56Z", "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "diffHunk": "@@ -93,19 +96,29 @@ public static BLSSignature aggregate(List<BLSSignature> signatures) {\n    * <p>The standard says to return INVALID, that is, false, if the list of public keys is empty.\n    * See also discussion at https://github.com/ethereum/eth2.0-specs/issues/1713\n    *\n+   * <p>We also return false if any of the messages are duplicates.", "originalCommit": "93cf0a03a9e05df8adc5d824e8a6c873c97fc4b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3MTcxMQ==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r435371711", "bodyText": "Yes. The standard-defined behaviour is to return \"INVALID\". The question for us is whether that means return false or throw an exception (because it should only occur when there's a logical error somewhere in the code). I've chosen to return false here, but am open to either. In any case, it should not lead to consensus failure.", "author": "benjaminion", "createdAt": "2020-06-04T15:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM1MTY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MzkyNA==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r435383924", "bodyText": "\ud83d\udc4d We're moving towards returning booleans from verifications instead of throwing exceptions (which is an anti-pattern as Adrian says), so the decision to return false here makes sense.", "author": "cemozerr", "createdAt": "2020-06-04T16:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM1MTY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM1MzAzNw==", "url": "https://github.com/ConsenSys/teku/pull/1895#discussion_r435353037", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              void succeedsWhenAggregateVerifyWithRepeatedMessagesReturnsFalse() {\n          \n          \n            \n              void aggregateVerifyWithRepeatedMessagesReturnsFalse() {", "author": "cemozerr", "createdAt": "2020-06-04T15:35:16Z", "path": "bls/src/test/java/tech/pegasys/teku/bls/BLSTest.java", "diffHunk": "@@ -80,6 +80,27 @@ void succeedsWhenCorrectlySigningAndVerifyingAggregateSignaturesReturnsTrue() {\n     assertTrue(BLS.fastAggregateVerify(publicKeys, message, aggregatedSignature));\n   }\n \n+  @Test\n+  void succeedsWhenAggregateVerifyWithRepeatedMessagesReturnsFalse() {", "originalCommit": "93cf0a03a9e05df8adc5d824e8a6c873c97fc4b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e9c2a9e7128c560666139aa8420edec3bfe46807", "url": "https://github.com/ConsenSys/teku/commit/e9c2a9e7128c560666139aa8420edec3bfe46807", "message": "Update tests to handle new signatures.", "committedDate": "2020-06-04T21:26:40Z", "type": "commit"}]}