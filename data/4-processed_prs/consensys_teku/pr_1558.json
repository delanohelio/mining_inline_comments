{"pr_number": 1558, "pr_title": "[BC-336] Cleanup rocksdb database", "pr_createdAt": "2020-04-08T17:17:16Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1558", "timeline": [{"oid": "35bd4bfeb0f3e00f0cd90d8722349beb5740c90c", "url": "https://github.com/ConsenSys/teku/commit/35bd4bfeb0f3e00f0cd90d8722349beb5740c90c", "message": "Cleanup RocksDbDatabase implementation", "committedDate": "2020-04-08T16:40:58Z", "type": "commit"}, {"oid": "9263cb78dc55d8da63f77b8f1d8186f7f25e1d67", "url": "https://github.com/ConsenSys/teku/commit/9263cb78dc55d8da63f77b8f1d8186f7f25e1d67", "message": "Add serialization tests, fix long serialization", "committedDate": "2020-04-08T17:03:21Z", "type": "commit"}, {"oid": "34fef370893e941360fa46e203f78050cbbf2b0e", "url": "https://github.com/ConsenSys/teku/commit/34fef370893e941360fa46e203f78050cbbf2b0e", "message": "Merge branch 'master' into bc-336/cleanup-rocksdb-database", "committedDate": "2020-04-08T17:11:43Z", "type": "commit"}, {"oid": "76e683a51f8d4499d6fea879082d3a7b3745da84", "url": "https://github.com/ConsenSys/teku/commit/76e683a51f8d4499d6fea879082d3a7b3745da84", "message": "Fix RocksDbDatabase handling of batch updates", "committedDate": "2020-04-08T21:06:07Z", "type": "commit"}, {"oid": "963695653f85dea65457985c6b969f030c3998d6", "url": "https://github.com/ConsenSys/teku/commit/963695653f85dea65457985c6b969f030c3998d6", "message": "Merge branch 'master' into bc-336/cleanup-rocksdb-database", "committedDate": "2020-04-08T21:10:18Z", "type": "commit"}, {"oid": "1cceeee5d0dbedc62b5885d4ab0ead23f373f417", "url": "https://github.com/ConsenSys/teku/commit/1cceeee5d0dbedc62b5885d4ab0ead23f373f417", "message": "Cut closed checks - they're probably unnecessary", "committedDate": "2020-04-08T21:24:01Z", "type": "commit"}, {"oid": "b6efae1af3d7bff990d6b638eb989a72081873b5", "url": "https://github.com/ConsenSys/teku/commit/b6efae1af3d7bff990d6b638eb989a72081873b5", "message": "Revert \"Cut closed checks - they're probably unnecessary\"\n\nThis reverts commit 1cceeee5d0dbedc62b5885d4ab0ead23f373f417.", "committedDate": "2020-04-08T22:10:59Z", "type": "commit"}, {"oid": "d4bd3d46ca4ad3eb2b92a6d62868e03522784108", "url": "https://github.com/ConsenSys/teku/commit/d4bd3d46ca4ad3eb2b92a6d62868e03522784108", "message": "Turns out guarding rocksdb is important :) - add tests", "committedDate": "2020-04-08T22:28:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgxNDUxNQ==", "url": "https://github.com/ConsenSys/teku/pull/1558#discussion_r405814515", "bodyText": "ooo, streams that really need to be closed. Very niche. :)", "author": "ajsutton", "createdAt": "2020-04-08T21:05:30Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -223,323 +106,197 @@ public StorageUpdateResult update(final StorageUpdate event) {\n \n   @Override\n   public Optional<Store> createMemoryStore() {\n-    try {\n-      byte[] genesisTimeBytes = db.get(columnHandles.get(DEFAULT), GENESIS_TIME_KEY.getId());\n-      if (genesisTimeBytes == null) {\n-        // If genesis time hasn't been set, genesis hasn't happened and we have no data\n-        return Optional.empty();\n-      }\n-      final UnsignedLong genesisTime = UnsignedLong.valueOf(Longs.fromByteArray(genesisTimeBytes));\n-      final Checkpoint justifiedCheckpoint =\n-          getSingletonValue(JUSTIFIED_CHECKPOINT_KEY, Checkpoint.class);\n-      final Checkpoint finalizedCheckpoint =\n-          getSingletonValue(FINALIZED_CHECKPOINT_KEY, Checkpoint.class);\n-      final Checkpoint bestJustifiedCheckpoint =\n-          getSingletonValue(BEST_JUSTIFIED_CHECKPOINT_KEY, Checkpoint.class);\n-      final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot =\n-          allValues(HOT_BLOCKS_BY_ROOT, Bytes32.class, SignedBeaconBlock.class);\n-      final Map<Bytes32, BeaconState> hotStatesByRoot =\n-          allValues(HOT_STATES_BY_ROOT, Bytes32.class, BeaconStateImpl.class);\n-      final Map<Checkpoint, BeaconState> checkpointStates =\n-          allValues(CHECKPOINT_STATES, Checkpoint.class, BeaconStateImpl.class);\n-      final Map<UnsignedLong, Checkpoint> latestMessages =\n-          allUnsignedLongValues(LATEST_MESSAGES, Checkpoint.class);\n-      return Optional.of(\n-          new Store(\n-              UnsignedLong.valueOf(Instant.now().getEpochSecond()),\n-              genesisTime,\n-              justifiedCheckpoint,\n-              finalizedCheckpoint,\n-              bestJustifiedCheckpoint,\n-              hotBlocksByRoot,\n-              hotStatesByRoot,\n-              checkpointStates,\n-              latestMessages));\n-    } catch (RocksDBException e) {\n-      throw new DatabaseStorageException(\"Unable to create memory store\", e);\n+    Optional<UnsignedLong> maybeGenesisTime = db.get(V2Schema.GENESIS_TIME);\n+    if (maybeGenesisTime.isEmpty()) {\n+      // If genesis time hasn't been set, genesis hasn't happened and we have no data\n+      return Optional.empty();\n     }\n+    final UnsignedLong genesisTime = maybeGenesisTime.get();\n+    final Checkpoint justifiedCheckpoint = db.getOrThrow(V2Schema.JUSTIFIED_CHECKPOINT);\n+    final Checkpoint finalizedCheckpoint = db.getOrThrow(V2Schema.FINALIZED_CHECKPOINT);\n+    final Checkpoint bestJustifiedCheckpoint = db.getOrThrow(V2Schema.BEST_JUSTIFIED_CHECKPOINT);\n+\n+    final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot = db.getAll(V2Schema.HOT_BLOCKS_BY_ROOT);\n+    final Map<Bytes32, BeaconState> hotStatesByRoot = db.getAll(V2Schema.HOT_STATES_BY_ROOT);\n+    final Map<Checkpoint, BeaconState> checkpointStates = db.getAll(V2Schema.CHECKPOINT_STATES);\n+    final Map<UnsignedLong, Checkpoint> latestMessages = db.getAll(V2Schema.LATEST_MESSAGES);\n+\n+    return Optional.of(\n+        new Store(\n+            UnsignedLong.valueOf(Instant.now().getEpochSecond()),\n+            genesisTime,\n+            justifiedCheckpoint,\n+            finalizedCheckpoint,\n+            bestJustifiedCheckpoint,\n+            hotBlocksByRoot,\n+            hotStatesByRoot,\n+            checkpointStates,\n+            latestMessages));\n   }\n \n   @Override\n   public Optional<Bytes32> getFinalizedRootAtSlot(final UnsignedLong slot) {\n-    try {\n-      byte[] bytes =\n-          db.get(columnHandles.get(FINALIZED_ROOTS_BY_SLOT), Longs.toByteArray(slot.longValue()));\n-      return bytes == null ? Optional.empty() : Optional.of(Bytes32.wrap(bytes));\n-    } catch (RocksDBException e) {\n-      throw new DatabaseStorageException(\"Unable to getFinalizedRootAtSlot \" + slot, e);\n-    }\n+    return db.get(V2Schema.FINALIZED_ROOTS_BY_SLOT, slot);\n   }\n \n   @Override\n   public Optional<Bytes32> getLatestFinalizedRootAtSlot(final UnsignedLong slot) {\n-    try (RocksIterator rocksIterator = db.newIterator(columnHandles.get(FINALIZED_ROOTS_BY_SLOT))) {\n-      rocksIterator.seekForPrev(Longs.toByteArray(slot.longValue()));\n-      return rocksIterator.isValid()\n-          ? Optional.of(Bytes32.wrap(rocksIterator.value()))\n-          : Optional.empty();\n-    }\n+    return db.getFloorEntry(V2Schema.FINALIZED_ROOTS_BY_SLOT, slot).map(ColumnEntry::getValue);\n   }\n \n   @Override\n   public Optional<SignedBeaconBlock> getSignedBlock(final Bytes32 root) {\n-    byte[] bytes;\n-    try {\n-      bytes = db.get(columnHandles.get(HOT_BLOCKS_BY_ROOT), root.toArrayUnsafe());\n-\n-      if (bytes == null) {\n-        bytes = db.get(columnHandles.get(FINALIZED_BLOCKS_BY_ROOT), root.toArrayUnsafe());\n-      }\n-    } catch (RocksDBException e) {\n-      throw new DatabaseStorageException(\"Unable to load block \" + root, e);\n-    }\n-    return bytes != null\n-        ? Optional.of(deserialize(bytes, SignedBeaconBlock.class))\n-        : Optional.empty();\n+    return db.get(V2Schema.HOT_BLOCKS_BY_ROOT, root)\n+        .or(() -> db.get(V2Schema.FINALIZED_BLOCKS_BY_ROOT, root));\n   }\n \n   @Override\n   public Optional<BeaconState> getState(final Bytes32 root) {\n-    try {\n-      byte[] key = root.toArrayUnsafe();\n-      byte[] bytes = db.get(columnHandles.get(HOT_STATES_BY_ROOT), key);\n-      if (bytes == null) {\n-        bytes = db.get(columnHandles.get(FINALIZED_STATES_BY_ROOT), key);\n-      }\n-      return bytes == null\n-          ? Optional.empty()\n-          : Optional.of(deserialize(bytes, BeaconStateImpl.class));\n-    } catch (RocksDBException e) {\n-      throw new DatabaseStorageException(\"Unable to getState for root \" + root, e);\n-    }\n+    return db.get(V2Schema.HOT_STATES_BY_ROOT, root)\n+        .or(() -> db.get(V2Schema.FINALIZED_STATES_BY_ROOT, root));\n   }\n \n   @Override\n-  public void close() {\n-    if (closed.compareAndSet(false, true)) {\n-      txOptions.close();\n-      options.close();\n-      db.close();\n-    }\n+  public void close() throws Exception {\n+    db.close();\n   }\n \n-  private void rollback(final Transaction transaction) {\n-    try {\n-      if (transaction.getState() != TransactionState.ROLLEDBACK) {\n-        transaction.rollback();\n-      }\n-    } catch (RocksDBException ex) {\n-      throw new DatabaseStorageException(\"Unable to rollback transaction\", ex);\n-    }\n+  private Checkpoint getFinalizedCheckpoint() {\n+    return db.getOrThrow(V2Schema.FINALIZED_CHECKPOINT);\n   }\n \n   private StorageUpdateResult doUpdate(final StorageUpdate event) {\n-    try (Transaction transaction = db.beginTransaction(new WriteOptions())) {\n-      try {\n-        ColumnFamilyHandle defaultColumn = columnHandles.get(DEFAULT);\n-        final Checkpoint previousFinalizedCheckpoint =\n-            deserialize(db.get(defaultColumn, FINALIZED_CHECKPOINT_KEY.getId()), Checkpoint.class);\n-\n-        final Checkpoint newFinalizedCheckpoint =\n-            event.getFinalizedCheckpoint().orElse(previousFinalizedCheckpoint);\n-        event\n-            .getGenesisTime()\n-            .ifPresent(\n-                time ->\n-                    storeDefaultValue(\n-                        transaction, GENESIS_TIME_KEY, Longs.toByteArray(time.longValue())));\n-        event\n-            .getFinalizedCheckpoint()\n-            .ifPresent(\n-                (finalizedCheckpoint) ->\n-                    storeDefaultValue(\n-                        transaction, FINALIZED_CHECKPOINT_KEY, serialize(finalizedCheckpoint)));\n-        event\n-            .getJustifiedCheckpoint()\n-            .ifPresent(\n-                (justifiedCheckpoint) ->\n-                    storeDefaultValue(\n-                        transaction, JUSTIFIED_CHECKPOINT_KEY, serialize(justifiedCheckpoint)));\n-        event\n-            .getBestJustifiedCheckpoint()\n-            .ifPresent(\n-                (bestJustifiedCheckpoint) ->\n-                    storeDefaultValue(\n-                        transaction,\n-                        BEST_JUSTIFIED_CHECKPOINT_KEY,\n-                        serialize(bestJustifiedCheckpoint)));\n-        event\n-            .getCheckpointStates()\n-            .forEach(\n-                (checkpoint, beaconState) ->\n-                    store(\n-                        transaction,\n-                        CHECKPOINT_STATES,\n-                        serialize(checkpoint),\n-                        serialize(beaconState)));\n-        event\n-            .getLatestMessages()\n-            .forEach(\n-                (validatorIndex, checkpoint) ->\n-                    store(\n-                        transaction,\n-                        LATEST_MESSAGES,\n-                        Longs.toByteArray(validatorIndex.longValue()),\n-                        serialize(checkpoint)));\n-\n-        event.getBlocks().forEach((root, block) -> addHotBlock(transaction, root, block));\n-        event\n-            .getBlockStates()\n-            .forEach(\n-                (root, beaconState) ->\n-                    store(\n-                        transaction,\n-                        HOT_STATES_BY_ROOT,\n-                        root.toArrayUnsafe(),\n-                        serialize(beaconState)));\n-\n-        final StorageUpdateResult result;\n-        if (previousFinalizedCheckpoint == null\n-            || !previousFinalizedCheckpoint.equals(newFinalizedCheckpoint)) {\n-          recordFinalizedBlocks(newFinalizedCheckpoint, transaction);\n-          final Set<Checkpoint> prunedCheckpoints =\n-              pruneCheckpointStates(newFinalizedCheckpoint, transaction);\n-          final Set<Bytes32> prunedBlockRoots = pruneHotBlocks(newFinalizedCheckpoint, transaction);\n-          result = StorageUpdateResult.successful(prunedBlockRoots, prunedCheckpoints);\n-        } else {\n-          result = StorageUpdateResult.successfulWithNothingPruned();\n-        }\n-        transaction.commit();\n-        return result;\n-      } catch (final DatabaseStorageException | RocksDBException e) {\n-        rollback(transaction);\n-        return StorageUpdateResult.failed(new RuntimeException(e));\n+    try (final RocksDbInstance.Transaction transaction = db.startTransaction()) {\n+      final Checkpoint previousFinalizedCheckpoint = getFinalizedCheckpoint();\n+      final Checkpoint newFinalizedCheckpoint =\n+          event.getFinalizedCheckpoint().orElse(previousFinalizedCheckpoint);\n+\n+      event.getGenesisTime().ifPresent(val -> transaction.put(V2Schema.GENESIS_TIME, val));\n+      event\n+          .getFinalizedCheckpoint()\n+          .ifPresent(val -> transaction.put(V2Schema.FINALIZED_CHECKPOINT, val));\n+      event\n+          .getJustifiedCheckpoint()\n+          .ifPresent(val -> transaction.put(V2Schema.JUSTIFIED_CHECKPOINT, val));\n+      event\n+          .getBestJustifiedCheckpoint()\n+          .ifPresent(val -> transaction.put(V2Schema.BEST_JUSTIFIED_CHECKPOINT, val));\n+\n+      transaction.put(V2Schema.CHECKPOINT_STATES, event.getCheckpointStates());\n+      transaction.put(V2Schema.LATEST_MESSAGES, event.getLatestMessages());\n+\n+      event.getBlocks().forEach((root, block) -> addHotBlock(transaction, root, block));\n+      transaction.put(V2Schema.HOT_STATES_BY_ROOT, event.getBlockStates());\n+\n+      final StorageUpdateResult result;\n+      if (previousFinalizedCheckpoint == null\n+          || !previousFinalizedCheckpoint.equals(newFinalizedCheckpoint)) {\n+        recordFinalizedBlocks(transaction, newFinalizedCheckpoint);\n+        final Set<Checkpoint> prunedCheckpoints =\n+            pruneCheckpointStates(transaction, newFinalizedCheckpoint);\n+        final Set<Bytes32> prunedBlockRoots = pruneHotBlocks(transaction, newFinalizedCheckpoint);\n+        result = StorageUpdateResult.successful(prunedBlockRoots, prunedCheckpoints);\n+      } else {\n+        result = StorageUpdateResult.successfulWithNothingPruned();\n       }\n+      transaction.commit();\n+      return result;\n     }\n   }\n \n   private void putFinalizedState(\n-      Transaction transaction, final Bytes32 blockRoot, final BeaconState state)\n-      throws RocksDBException {\n+      RocksDbInstance.Transaction transaction, final Bytes32 blockRoot, final BeaconState state) {\n     switch (stateStorageMode) {\n       case ARCHIVE:\n-        transaction.put(\n-            columnHandles.get(FINALIZED_STATES_BY_ROOT),\n-            blockRoot.toArrayUnsafe(),\n-            serialize(state));\n+        transaction.put(V2Schema.FINALIZED_STATES_BY_ROOT, blockRoot, state);\n         break;\n       case PRUNE:\n         // Don't persist finalized state\n         break;\n+      default:\n+        throw new UnsupportedOperationException(\"Unhandled storage mode: \" + stateStorageMode);\n     }\n   }\n \n   private void addHotBlock(\n-      Transaction transaction, final Bytes32 root, final SignedBeaconBlock block) {\n-    try {\n-      transaction.put(\n-          columnHandles.get(HOT_BLOCKS_BY_ROOT), root.toArrayUnsafe(), serialize(block));\n-      addToHotRootsBySlotCache(root, block);\n-    } catch (RocksDBException e) {\n-      throw new DatabaseStorageException(\"Error storing a hotBlock \" + root, e);\n-    }\n-  }\n-\n-  private void addToHotRootsBySlotCache(final Bytes32 root, final SignedBeaconBlock block) {\n+      RocksDbInstance.Transaction transaction, final Bytes32 root, final SignedBeaconBlock block) {\n+    transaction.put(V2Schema.HOT_BLOCKS_BY_ROOT, root, block);\n     hotRootsBySlotCache\n         .computeIfAbsent(\n             block.getSlot(), key -> Collections.newSetFromMap(new ConcurrentHashMap<>()))\n         .add(root);\n   }\n \n   private Set<Checkpoint> pruneCheckpointStates(\n-      final Checkpoint newFinalizedCheckpoint, final Transaction transaction)\n-      throws RocksDBException {\n-    ColumnFamilyHandle checkpointStates = columnHandles.get(CHECKPOINT_STATES);\n-    Set<Checkpoint> prunedCheckpoints = new HashSet<>();\n-    try (final RocksIterator rocksIterator = db.newIterator(checkpointStates)) {\n-      rocksIterator.seekToFirst();\n-      while (rocksIterator.isValid()) {\n-        final byte[] key = rocksIterator.key();\n-        Checkpoint checkpoint = deserialize(key, Checkpoint.class);\n-        if (checkpoint.getEpoch().compareTo(newFinalizedCheckpoint.getEpoch()) < 0) {\n-          transaction.delete(checkpointStates, key);\n-          prunedCheckpoints.add(checkpoint);\n-        }\n-        rocksIterator.next();\n-      }\n+      final RocksDbInstance.Transaction transaction, final Checkpoint newFinalizedCheckpoint) {\n+    final Set<Checkpoint> prunedCheckpoints = new HashSet<>();\n+    try (final Stream<ColumnEntry<Checkpoint, BeaconState>> stream =", "originalCommit": "34fef370893e941360fa46e203f78050cbbf2b0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyNTc5Nw==", "url": "https://github.com/ConsenSys/teku/pull/1558#discussion_r405825797", "bodyText": "nit: IntelliJ is warning me this is redundant and you could just use defaultHandle directly below.", "author": "ajsutton", "createdAt": "2020-04-08T21:28:14Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/core/RocksDbInstance.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.core;\n+\n+import com.google.common.collect.ImmutableMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.rocksdb.AbstractRocksIterator;\n+import org.rocksdb.ColumnFamilyHandle;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import org.rocksdb.TransactionDB;\n+import org.rocksdb.WriteOptions;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.RocksDbColumn;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.RocksDbVariable;\n+\n+public class RocksDbInstance implements AutoCloseable {\n+\n+  private final TransactionDB db;\n+  private final ColumnFamilyHandle defaultHandle;\n+  private final ImmutableMap<RocksDbColumn<?, ?>, ColumnFamilyHandle> columnHandles;\n+  private final List<AutoCloseable> resources;\n+\n+  private final AtomicBoolean closed = new AtomicBoolean(false);\n+\n+  RocksDbInstance(\n+      final TransactionDB db,\n+      final ColumnFamilyHandle defaultHandle,\n+      final ImmutableMap<RocksDbColumn<?, ?>, ColumnFamilyHandle> columnHandles,\n+      final List<AutoCloseable> resources) {\n+    this.db = db;\n+    this.defaultHandle = defaultHandle;\n+    this.columnHandles = columnHandles;\n+    this.resources = resources;\n+  }\n+\n+  public <T> Optional<T> get(RocksDbVariable<T> variableType) {\n+    final ColumnFamilyHandle handle = defaultHandle;", "originalCommit": "963695653f85dea65457985c6b969f030c3998d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0MzMzMg==", "url": "https://github.com/ConsenSys/teku/pull/1558#discussion_r405843332", "bodyText": "nit: if we're going to have javadocj we should probably have a description rather than blank.", "author": "ajsutton", "createdAt": "2020-04-08T22:08:12Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/core/RocksDbInstance.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.core;\n+\n+import com.google.common.collect.ImmutableMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.rocksdb.AbstractRocksIterator;\n+import org.rocksdb.ColumnFamilyHandle;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import org.rocksdb.TransactionDB;\n+import org.rocksdb.WriteOptions;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.RocksDbColumn;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.RocksDbVariable;\n+\n+public class RocksDbInstance implements AutoCloseable {\n+\n+  private final TransactionDB db;\n+  private final ColumnFamilyHandle defaultHandle;\n+  private final ImmutableMap<RocksDbColumn<?, ?>, ColumnFamilyHandle> columnHandles;\n+  private final List<AutoCloseable> resources;\n+\n+  private final AtomicBoolean closed = new AtomicBoolean(false);\n+\n+  RocksDbInstance(\n+      final TransactionDB db,\n+      final ColumnFamilyHandle defaultHandle,\n+      final ImmutableMap<RocksDbColumn<?, ?>, ColumnFamilyHandle> columnHandles,\n+      final List<AutoCloseable> resources) {\n+    this.db = db;\n+    this.defaultHandle = defaultHandle;\n+    this.columnHandles = columnHandles;\n+    this.resources = resources;\n+  }\n+\n+  public <T> Optional<T> get(RocksDbVariable<T> variableType) {\n+    final ColumnFamilyHandle handle = defaultHandle;\n+    try {\n+      return Optional.ofNullable(db.get(handle, variableType.getId().toArrayUnsafe()))\n+          .map(data -> variableType.getSerializer().deserialize(data));\n+    } catch (RocksDBException e) {\n+      throw new DatabaseStorageException(\"Failed to get value\", e);\n+    }\n+  }\n+\n+  public <T> T getOrThrow(RocksDbVariable<T> variableType) {\n+    return get(variableType).orElseThrow();\n+  }\n+\n+  public <K, V> Optional<V> get(RocksDbColumn<K, V> column, K key) {\n+    final ColumnFamilyHandle handle = columnHandles.get(column);\n+    final byte[] keyBytes = column.getKeySerializer().serialize(key);\n+    try {\n+      return Optional.ofNullable(db.get(handle, keyBytes))\n+          .map(data -> column.getValueSerializer().deserialize(data));\n+    } catch (RocksDBException e) {\n+      throw new DatabaseStorageException(\"Failed to get value\", e);\n+    }\n+  }\n+\n+  public <K, V> Map<K, V> getAll(RocksDbColumn<K, V> column) {\n+    return stream(column).collect(Collectors.toMap(ColumnEntry::getKey, ColumnEntry::getValue));\n+  }\n+\n+  /**\n+   * @param column The column we want to query\n+   * @param key The requested key\n+   * @param <K> The key type of the column\n+   * @param <V> The value type of the column\n+   * @return The last entry with a key less than or equal to the given {@code key}\n+   */", "originalCommit": "1cceeee5d0dbedc62b5885d4ab0ead23f373f417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0NjcyNA==", "url": "https://github.com/ConsenSys/teku/pull/1558#discussion_r405846724", "bodyText": "nit: Probably better to avoid the abbreviation and name this rocksDbIterator", "author": "ajsutton", "createdAt": "2020-04-08T22:16:46Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/core/RocksDbIterator.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.core;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.RocksDbColumn;\n+\n+class RocksDbIterator<TKey, TValue> implements Iterator<ColumnEntry<TKey, TValue>>, AutoCloseable {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RocksDbColumn<TKey, TValue> column;\n+  private final RocksIterator rocksIt;", "originalCommit": "1cceeee5d0dbedc62b5885d4ab0ead23f373f417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0Nzc3Mg==", "url": "https://github.com/ConsenSys/teku/pull/1558#discussion_r405847772", "bodyText": "Probably should have a checkArgument to confirm the int fits within byte range to avoid silently creating conflicts if it's passed big numbers.", "author": "ajsutton", "createdAt": "2020-04-08T22:19:31Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/schema/RocksDbColumn.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.schema;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.storage.server.rocksdb.serialization.RocksDbSerializer;\n+\n+public class RocksDbColumn<TKey, TValue> {\n+  private final Bytes id;\n+  private final RocksDbSerializer<TKey> keySerializer;\n+  private final RocksDbSerializer<TValue> valueSerializer;\n+\n+  private RocksDbColumn(\n+      final byte[] id,\n+      final RocksDbSerializer<TKey> keySerializer,\n+      final RocksDbSerializer<TValue> valueSerializer) {\n+    this.id = Bytes.wrap(id);\n+    this.keySerializer = keySerializer;\n+    this.valueSerializer = valueSerializer;\n+  }\n+\n+  public static <K, V> RocksDbColumn<K, V> create(\n+      final byte[] id,\n+      final RocksDbSerializer<K> keySerializer,\n+      final RocksDbSerializer<V> valueSerializer) {\n+    return new RocksDbColumn<>(id, keySerializer, valueSerializer);\n+  }\n+\n+  public static <K, V> RocksDbColumn<K, V> create(\n+      final int id,\n+      final RocksDbSerializer<K> keySerializer,\n+      final RocksDbSerializer<V> valueSerializer) {\n+    return new RocksDbColumn<>(new byte[] {(byte) id}, keySerializer, valueSerializer);", "originalCommit": "1cceeee5d0dbedc62b5885d4ab0ead23f373f417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0NzkyNg==", "url": "https://github.com/ConsenSys/teku/pull/1558#discussion_r405847926", "bodyText": "Should check the int fits in a byte here too.", "author": "ajsutton", "createdAt": "2020-04-08T22:19:55Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/schema/RocksDbVariable.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.schema;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.storage.server.rocksdb.serialization.RocksDbSerializer;\n+\n+public class RocksDbVariable<TValue> {\n+  private final Bytes id;\n+  private final RocksDbSerializer<TValue> serializer;\n+\n+  private RocksDbVariable(final byte[] id, final RocksDbSerializer<TValue> serializer) {\n+    this.id = Bytes.wrap(id);\n+    this.serializer = serializer;\n+  }\n+\n+  public static <T> RocksDbVariable<T> create(\n+      final byte[] id, final RocksDbSerializer<T> serializer) {\n+    return new RocksDbVariable<T>(id, serializer);\n+  }\n+\n+  public static <T> RocksDbVariable<T> create(final int id, final RocksDbSerializer<T> serializer) {\n+    return new RocksDbVariable<T>(new byte[] {(byte) id}, serializer);", "originalCommit": "1cceeee5d0dbedc62b5885d4ab0ead23f373f417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg1OTk2Mg==", "url": "https://github.com/ConsenSys/teku/pull/1558#discussion_r405859962", "bodyText": "I so desperately want to make the columns an enum to avoid this but I think it winds up introducing just as many downsides - at least this way the \"mess\" is just hidden here and everything else looks nice. Sigh.", "author": "ajsutton", "createdAt": "2020-04-08T22:52:42Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/schema/Schema.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.schema;\n+\n+import java.lang.reflect.Modifier;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+\n+public interface Schema {\n+  Bytes DEFAULT_COLUMN_ID = Bytes.wrap(\"default\".getBytes(StandardCharsets.UTF_8));\n+\n+  static Stream<RocksDbColumn<?, ?>> streamColumns(Class<? extends Schema> schema) {\n+    return Arrays.stream(schema.getDeclaredFields())\n+        .filter(f -> (f.getModifiers() & Modifier.STATIC) > 0)\n+        .filter(f -> f.getType() == RocksDbColumn.class)\n+        .map(\n+            f -> {\n+              try {\n+                return (RocksDbColumn<?, ?>) f.get(null);\n+              } catch (IllegalAccessException e) {\n+                throw new RuntimeException(e);\n+              }\n+            });", "originalCommit": "1cceeee5d0dbedc62b5885d4ab0ead23f373f417", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMyMTYxOA==", "url": "https://github.com/ConsenSys/teku/pull/1558#discussion_r406321618", "bodyText": "yeah, this part is a bit messy - it might evolve ...", "author": "mbaxter", "createdAt": "2020-04-09T16:19:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg1OTk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NDI5NA==", "url": "https://github.com/ConsenSys/teku/pull/1558#discussion_r405864294", "bodyText": "It feels weird to have a static create but then do all the work in the constructor and ultimately throw away the constructed object.  It looks like we could just make all the methods static and move the constructor into create fairly easily.", "author": "ajsutton", "createdAt": "2020-04-08T23:04:42Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/core/RocksDbInstanceFactory.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.core;\n+\n+import com.google.common.collect.ImmutableMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.rocksdb.BlockBasedTableConfig;\n+import org.rocksdb.ColumnFamilyDescriptor;\n+import org.rocksdb.ColumnFamilyHandle;\n+import org.rocksdb.ColumnFamilyOptions;\n+import org.rocksdb.DBOptions;\n+import org.rocksdb.Env;\n+import org.rocksdb.LRUCache;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.TransactionDB;\n+import org.rocksdb.TransactionDBOptions;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.rocksdb.RocksDbConfiguration;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.RocksDbColumn;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.Schema;\n+\n+public class RocksDbInstanceFactory {\n+  static {\n+    RocksDbUtil.loadNativeLibrary();\n+  }\n+\n+  private final ColumnFamilyHandle defaultHandle;\n+  private final ImmutableMap<RocksDbColumn<?, ?>, ColumnFamilyHandle> columnHandles;\n+  private final TransactionDB db;\n+  private final List<AutoCloseable> resources = new ArrayList<>();\n+\n+  public static RocksDbInstance create(\n+      final RocksDbConfiguration configuration, final Class<? extends Schema> schema)\n+      throws DatabaseStorageException {\n+    final RocksDbInstanceFactory factory = new RocksDbInstanceFactory(configuration, schema);\n+    return new RocksDbInstance(\n+        factory.db, factory.defaultHandle, factory.columnHandles, factory.resources);\n+  }", "originalCommit": "1cceeee5d0dbedc62b5885d4ab0ead23f373f417", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMyMjM0OQ==", "url": "https://github.com/ConsenSys/teku/pull/1558#discussion_r406322349", "bodyText": "I originally had this as an instance inside of RocksDbInstance and I just didn't fully convert it to use static methods - will clean it up \ud83d\udc4d", "author": "mbaxter", "createdAt": "2020-04-09T16:21:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NDI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NDc3Nw==", "url": "https://github.com/ConsenSys/teku/pull/1558#discussion_r405864777", "bodyText": "nit: could just use Preconditions.checkState(closed.get(), \"Attempt to update a closed transaction\")", "author": "ajsutton", "createdAt": "2020-04-08T23:06:16Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/core/RocksDbInstance.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.core;\n+\n+import com.google.common.collect.ImmutableMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.rocksdb.AbstractRocksIterator;\n+import org.rocksdb.ColumnFamilyHandle;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import org.rocksdb.TransactionDB;\n+import org.rocksdb.WriteOptions;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.RocksDbColumn;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.RocksDbVariable;\n+\n+public class RocksDbInstance implements AutoCloseable {\n+\n+  private final TransactionDB db;\n+  private final ColumnFamilyHandle defaultHandle;\n+  private final ImmutableMap<RocksDbColumn<?, ?>, ColumnFamilyHandle> columnHandles;\n+  private final List<AutoCloseable> resources;\n+\n+  private final AtomicBoolean closed = new AtomicBoolean(false);\n+\n+  RocksDbInstance(\n+      final TransactionDB db,\n+      final ColumnFamilyHandle defaultHandle,\n+      final ImmutableMap<RocksDbColumn<?, ?>, ColumnFamilyHandle> columnHandles,\n+      final List<AutoCloseable> resources) {\n+    this.db = db;\n+    this.defaultHandle = defaultHandle;\n+    this.columnHandles = columnHandles;\n+    this.resources = resources;\n+  }\n+\n+  public <T> Optional<T> get(RocksDbVariable<T> variableType) {\n+    assertOpen();\n+    final ColumnFamilyHandle handle = defaultHandle;\n+    try {\n+      return Optional.ofNullable(db.get(handle, variableType.getId().toArrayUnsafe()))\n+          .map(data -> variableType.getSerializer().deserialize(data));\n+    } catch (RocksDBException e) {\n+      throw new DatabaseStorageException(\"Failed to get value\", e);\n+    }\n+  }\n+\n+  public <T> T getOrThrow(RocksDbVariable<T> variableType) {\n+    assertOpen();\n+    return get(variableType).orElseThrow();\n+  }\n+\n+  public <K, V> Optional<V> get(RocksDbColumn<K, V> column, K key) {\n+    assertOpen();\n+    final ColumnFamilyHandle handle = columnHandles.get(column);\n+    final byte[] keyBytes = column.getKeySerializer().serialize(key);\n+    try {\n+      return Optional.ofNullable(db.get(handle, keyBytes))\n+          .map(data -> column.getValueSerializer().deserialize(data));\n+    } catch (RocksDBException e) {\n+      throw new DatabaseStorageException(\"Failed to get value\", e);\n+    }\n+  }\n+\n+  public <K, V> Map<K, V> getAll(RocksDbColumn<K, V> column) {\n+    assertOpen();\n+    return stream(column).collect(Collectors.toMap(ColumnEntry::getKey, ColumnEntry::getValue));\n+  }\n+\n+  /**\n+   * @param column The column we want to query\n+   * @param key The requested key\n+   * @param <K> The key type of the column\n+   * @param <V> The value type of the column\n+   * @return The last entry with a key less than or equal to the given {@code key}\n+   */\n+  public <K, V> Optional<ColumnEntry<K, V>> getFloorEntry(RocksDbColumn<K, V> column, final K key) {\n+    assertOpen();\n+    final byte[] keyBytes = column.getKeySerializer().serialize(key);\n+    final Consumer<RocksIterator> setupIterator = it -> it.seekForPrev(keyBytes);\n+    try (final Stream<ColumnEntry<K, V>> stream = stream(column, setupIterator)) {\n+      return stream.findFirst();\n+    }\n+  }\n+\n+  /**\n+   * @param column The column we want to query\n+   * @param <K> The key type of the column\n+   * @param <V> The value type of the column\n+   * @return The last entry in this column - the entry with the greatest key value\n+   */\n+  public <K, V> Optional<ColumnEntry<K, V>> getLastEntry(RocksDbColumn<K, V> column) {\n+    assertOpen();\n+    try (final Stream<ColumnEntry<K, V>> stream =\n+        stream(column, AbstractRocksIterator::seekToLast)) {\n+      return stream.findFirst();\n+    }\n+  }\n+\n+  public <K, V> Stream<ColumnEntry<K, V>> stream(RocksDbColumn<K, V> column) {\n+    assertOpen();\n+    return stream(column, RocksIterator::seekToFirst);\n+  }\n+\n+  public Transaction startTransaction() {\n+    assertOpen();\n+    return new Transaction(db, defaultHandle, columnHandles);\n+  }\n+\n+  private <K, V> Stream<ColumnEntry<K, V>> stream(\n+      RocksDbColumn<K, V> column, Consumer<RocksIterator> setupIterator) {\n+    final ColumnFamilyHandle handle = columnHandles.get(column);\n+    final RocksIterator rocksDbIterator = db.newIterator(handle);\n+    setupIterator.accept(rocksDbIterator);\n+    return RocksDbIterator.create(column, rocksDbIterator).toStream();\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    if (closed.compareAndSet(false, true)) {\n+      for (final AutoCloseable resource : resources) {\n+        resource.close();\n+      }\n+    }\n+  }\n+\n+  private void assertOpen() {\n+    if (closed.get()) {\n+      throw new IllegalStateException(\"Attempt to update a closed transaction\");\n+    }\n+  }\n+\n+  public static class Transaction implements AutoCloseable {\n+    private final ColumnFamilyHandle defaultHandle;\n+    private final ImmutableMap<RocksDbColumn<?, ?>, ColumnFamilyHandle> columnHandles;\n+    private final org.rocksdb.Transaction rocksDbTx;\n+    private final WriteOptions writeOptions;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+\n+    private Transaction(\n+        final TransactionDB db,\n+        final ColumnFamilyHandle defaultHandle,\n+        final ImmutableMap<RocksDbColumn<?, ?>, ColumnFamilyHandle> columnHandles) {\n+      this.defaultHandle = defaultHandle;\n+      this.columnHandles = columnHandles;\n+      this.writeOptions = new WriteOptions();\n+      this.rocksDbTx = db.beginTransaction(writeOptions);\n+    }\n+\n+    public <T> void put(RocksDbVariable<T> variableType, T value) {\n+      assertOpen();\n+      final byte[] serialized = variableType.getSerializer().serialize(value);\n+      try {\n+        rocksDbTx.put(defaultHandle, variableType.getId().toArrayUnsafe(), serialized);\n+      } catch (RocksDBException e) {\n+        throw new DatabaseStorageException(\"Failed to put variable\", e);\n+      }\n+    }\n+\n+    public <K, V> void put(RocksDbColumn<K, V> column, K key, V value) {\n+      assertOpen();\n+      final byte[] keyBytes = column.getKeySerializer().serialize(key);\n+      final byte[] valueBytes = column.getValueSerializer().serialize(value);\n+      final ColumnFamilyHandle handle = columnHandles.get(column);\n+      try {\n+        rocksDbTx.put(handle, keyBytes, valueBytes);\n+      } catch (RocksDBException e) {\n+        throw new DatabaseStorageException(\"Failed to put column data\", e);\n+      }\n+    }\n+\n+    public <K, V> void put(RocksDbColumn<K, V> column, Map<K, V> data) {\n+      assertOpen();\n+      final ColumnFamilyHandle handle = columnHandles.get(column);\n+      for (Entry<K, V> kvEntry : data.entrySet()) {\n+        final byte[] key = column.getKeySerializer().serialize(kvEntry.getKey());\n+        final byte[] value = column.getValueSerializer().serialize(kvEntry.getValue());\n+        try {\n+          rocksDbTx.put(handle, key, value);\n+        } catch (RocksDBException e) {\n+          throw new DatabaseStorageException(\"Failed to put column data\", e);\n+        }\n+      }\n+    }\n+\n+    public <K, V> void delete(RocksDbColumn<K, V> column, K key) {\n+      assertOpen();\n+      final ColumnFamilyHandle handle = columnHandles.get(column);\n+      try {\n+        rocksDbTx.delete(handle, column.getKeySerializer().serialize(key));\n+      } catch (RocksDBException e) {\n+        throw new DatabaseStorageException(\"Failed to delete key\", e);\n+      }\n+    }\n+\n+    public void commit() {\n+      assertOpen();\n+      try {\n+        this.rocksDbTx.commit();\n+        close();\n+      } catch (RocksDBException e) {\n+        rollback();\n+        throw new DatabaseStorageException(\"Failed to commit transaction\", e);\n+      }\n+    }\n+\n+    public void rollback() {\n+      assertOpen();\n+      try {\n+        this.rocksDbTx.rollback();\n+        close();\n+      } catch (RocksDBException e) {\n+        throw new DatabaseStorageException(\"Failed to rollback transaction\", e);\n+      }\n+    }\n+\n+    private void assertOpen() {\n+      if (closed.get()) {\n+        throw new IllegalStateException(\"Attempt to update a closed transaction\");\n+      }", "originalCommit": "d4bd3d46ca4ad3eb2b92a6d62868e03522784108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2e35bd147bf621b36bf9dac9d7f953e855326930", "url": "https://github.com/ConsenSys/teku/commit/2e35bd147bf621b36bf9dac9d7f953e855326930", "message": "Address code review feedback + some minor cleanup", "committedDate": "2020-04-09T16:30:18Z", "type": "commit"}, {"oid": "83c4f19af7c2633e85bf6a149d1b670ef19db3d2", "url": "https://github.com/ConsenSys/teku/commit/83c4f19af7c2633e85bf6a149d1b670ef19db3d2", "message": "Merge branch 'master' into bc-336/cleanup-rocksdb-database", "committedDate": "2020-04-09T16:31:48Z", "type": "commit"}]}