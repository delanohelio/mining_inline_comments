{"pr_number": 1081, "pr_title": "[BC-175] Isolate libp2p dependencies", "pr_createdAt": "2020-01-06T16:00:27Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1081", "timeline": [{"oid": "504ee244212497d72c8cd94dd999ae92a4995f8d", "url": "https://github.com/ConsenSys/teku/commit/504ee244212497d72c8cd94dd999ae92a4995f8d", "message": "Reduce eth2 dependencies on netty / libp2p", "committedDate": "2020-01-06T15:31:24Z", "type": "commit"}, {"oid": "cc65b988c06d325625b55a7cb16c9469bed6f8fe", "url": "https://github.com/ConsenSys/teku/commit/cc65b988c06d325625b55a7cb16c9469bed6f8fe", "message": "Remove RpcMethods interface", "committedDate": "2020-01-06T15:42:12Z", "type": "commit"}, {"oid": "13b30f84b345493ec2b540b9d270fcef30af2874", "url": "https://github.com/ConsenSys/teku/commit/13b30f84b345493ec2b540b9d270fcef30af2874", "message": "Cleanup", "committedDate": "2020-01-06T15:59:37Z", "type": "commit"}, {"oid": "a611f69918fd335005063890d78e20e25c061116", "url": "https://github.com/ConsenSys/teku/commit/a611f69918fd335005063890d78e20e25c061116", "message": "Add handlerRemoved logic back in, rework RpcRequestHandler API", "committedDate": "2020-01-06T17:49:25Z", "type": "commit"}, {"oid": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42", "url": "https://github.com/ConsenSys/teku/commit/0025d7b941e51b3032ba2167ba71fe6a4ed24e42", "message": "Fix disconnect logic", "committedDate": "2020-01-06T18:17:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4MTk4MQ==", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363481981", "bodyText": "Strictly these should probably be get prefixed, but it is one of those cases where it feels right to break the rule (and I'm usually a big fan of get prefixes...).", "author": "ajsutton", "createdAt": "2020-01-06T21:04:00Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/beaconchain/BeaconChainMethods.java", "diffHunk": "@@ -25,57 +28,126 @@\n import tech.pegasys.artemis.networking.eth2.rpc.beaconchain.methods.GoodbyeMessageHandler;\n import tech.pegasys.artemis.networking.eth2.rpc.beaconchain.methods.StatusMessageFactory;\n import tech.pegasys.artemis.networking.eth2.rpc.beaconchain.methods.StatusMessageHandler;\n-import tech.pegasys.artemis.networking.eth2.rpc.core.RpcMessageHandler;\n-import tech.pegasys.artemis.networking.eth2.rpc.core.RpcMethod;\n-import tech.pegasys.artemis.networking.eth2.rpc.core.RpcMethods;\n+import tech.pegasys.artemis.networking.eth2.rpc.core.Eth2RpcMethod;\n import tech.pegasys.artemis.networking.eth2.rpc.core.encodings.RpcEncoding;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcMethod;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.CombinedChainDataClient;\n \n public class BeaconChainMethods {\n-  public static final RpcMethod<StatusMessage, StatusMessage> STATUS =\n-      new RpcMethod<>(\n-          \"/eth2/beacon_chain/req/status/1\",\n-          RpcEncoding.SSZ,\n-          StatusMessage.class,\n-          StatusMessage.class);\n-  public static final RpcMethod<GoodbyeMessage, GoodbyeMessage> GOODBYE =\n-      new RpcMethod<>(\n-          \"/eth2/beacon_chain/req/goodbye/1\",\n-          RpcEncoding.SSZ,\n-          GoodbyeMessage.class,\n-          GoodbyeMessage.class);\n-  public static final RpcMethod<BeaconBlocksByRootRequestMessage, BeaconBlock>\n-      BEACON_BLOCKS_BY_ROOT =\n-          new RpcMethod<>(\n-              \"/eth2/beacon_chain/req/beacon_blocks_by_root/1\",\n-              RpcEncoding.SSZ,\n-              BeaconBlocksByRootRequestMessage.class,\n-              BeaconBlock.class);\n-  public static final RpcMethod<BeaconBlocksByRangeRequestMessage, BeaconBlock>\n-      BEACON_BLOCKS_BY_RANGE =\n-          new RpcMethod<>(\n-              \"/eth2/beacon_chain/req/beacon_blocks_by_range/1\",\n-              RpcEncoding.SSZ,\n-              BeaconBlocksByRangeRequestMessage.class,\n-              BeaconBlock.class);\n-\n-  public static RpcMethods createRpcMethods(\n-      PeerLookup peerLookup,\n+  private static final String STATUS = \"/eth2/beacon_chain/req/status/1\";\n+  private static final String GOODBYE = \"/eth2/beacon_chain/req/goodbye/1\";\n+  private static final String BEACON_BLOCKS_BY_ROOT =\n+      \"/eth2/beacon_chain/req/beacon_blocks_by_root/1\";\n+  private static final String BEACON_BLOCKS_BY_RANGE =\n+      \"/eth2/beacon_chain/req/beacon_blocks_by_range/1\";\n+\n+  private final Eth2RpcMethod<StatusMessage, StatusMessage> status;\n+  private final Eth2RpcMethod<GoodbyeMessage, GoodbyeMessage> goodBye;\n+  private final Eth2RpcMethod<BeaconBlocksByRootRequestMessage, BeaconBlock> beaconBlocksByRoot;\n+  private final Eth2RpcMethod<BeaconBlocksByRangeRequestMessage, BeaconBlock> beaconBlocksByRange;\n+\n+  private final Collection<Eth2RpcMethod<?, ?>> allMethods;\n+\n+  private BeaconChainMethods(\n+      final Eth2RpcMethod<StatusMessage, StatusMessage> status,\n+      final Eth2RpcMethod<GoodbyeMessage, GoodbyeMessage> goodBye,\n+      final Eth2RpcMethod<BeaconBlocksByRootRequestMessage, BeaconBlock> beaconBlocksByRoot,\n+      final Eth2RpcMethod<BeaconBlocksByRangeRequestMessage, BeaconBlock> beaconBlocksByRange) {\n+    this.status = status;\n+    this.goodBye = goodBye;\n+    this.beaconBlocksByRoot = beaconBlocksByRoot;\n+    this.beaconBlocksByRange = beaconBlocksByRange;\n+    allMethods = List.of(status, goodBye, beaconBlocksByRoot, beaconBlocksByRange);\n+  }\n+\n+  public static BeaconChainMethods create(\n+      final PeerLookup peerLookup,\n       final CombinedChainDataClient combinedChainDataClient,\n       final ChainStorageClient chainStorageClient,\n       final MetricsSystem metricsSystem,\n       final StatusMessageFactory statusMessageFactory) {\n+    return new BeaconChainMethods(\n+        createStatus(statusMessageFactory, peerLookup),\n+        createGoodBye(metricsSystem, peerLookup),\n+        createBeaconBlocksByRoot(chainStorageClient, peerLookup),\n+        createBeaconBlocksByRange(combinedChainDataClient, peerLookup));\n+  }\n+\n+  private static Eth2RpcMethod<StatusMessage, StatusMessage> createStatus(\n+      final StatusMessageFactory statusMessageFactory, final PeerLookup peerLookup) {\n     final StatusMessageHandler statusHandler = new StatusMessageHandler(statusMessageFactory);\n+    return new Eth2RpcMethod<>(\n+        STATUS,\n+        RpcEncoding.SSZ,\n+        StatusMessage.class,\n+        StatusMessage.class,\n+        false,\n+        statusHandler,\n+        peerLookup);\n+  }\n+\n+  private static Eth2RpcMethod<GoodbyeMessage, GoodbyeMessage> createGoodBye(\n+      final MetricsSystem metricsSystem, final PeerLookup peerLookup) {\n     final GoodbyeMessageHandler goodbyeHandler = new GoodbyeMessageHandler(metricsSystem);\n+    return new Eth2RpcMethod<>(\n+        GOODBYE,\n+        RpcEncoding.SSZ,\n+        GoodbyeMessage.class,\n+        GoodbyeMessage.class,\n+        true,\n+        goodbyeHandler,\n+        peerLookup);\n+  }\n+\n+  private static Eth2RpcMethod<BeaconBlocksByRootRequestMessage, BeaconBlock>\n+      createBeaconBlocksByRoot(\n+          final ChainStorageClient chainStorageClient, final PeerLookup peerLookup) {\n     final BeaconBlocksByRootMessageHandler beaconBlocksByRootHandler =\n         new BeaconBlocksByRootMessageHandler(chainStorageClient);\n+    return new Eth2RpcMethod<>(\n+        BEACON_BLOCKS_BY_ROOT,\n+        RpcEncoding.SSZ,\n+        BeaconBlocksByRootRequestMessage.class,\n+        BeaconBlock.class,\n+        false,\n+        beaconBlocksByRootHandler,\n+        peerLookup);\n+  }\n+\n+  private static Eth2RpcMethod<BeaconBlocksByRangeRequestMessage, BeaconBlock>\n+      createBeaconBlocksByRange(\n+          final CombinedChainDataClient combinedChainDataClient, final PeerLookup peerLookup) {\n+\n     final BeaconBlocksByRangeMessageHandler beaconBlocksByRangeHandler =\n         new BeaconBlocksByRangeMessageHandler(combinedChainDataClient);\n-    return new RpcMethods(\n-        new RpcMessageHandler<>(STATUS, peerLookup, statusHandler),\n-        new RpcMessageHandler<>(GOODBYE, peerLookup, goodbyeHandler).setCloseNotification(),\n-        new RpcMessageHandler<>(BEACON_BLOCKS_BY_ROOT, peerLookup, beaconBlocksByRootHandler),\n-        new RpcMessageHandler<>(BEACON_BLOCKS_BY_RANGE, peerLookup, beaconBlocksByRangeHandler));\n+    return new Eth2RpcMethod<>(\n+        BEACON_BLOCKS_BY_RANGE,\n+        RpcEncoding.SSZ,\n+        BeaconBlocksByRangeRequestMessage.class,\n+        BeaconBlock.class,\n+        false,\n+        beaconBlocksByRangeHandler,\n+        peerLookup);\n+  }\n+\n+  public Collection<RpcMethod> all() {\n+    return Collections.unmodifiableCollection(allMethods);\n+  }\n+\n+  public Eth2RpcMethod<StatusMessage, StatusMessage> status() {", "originalCommit": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4MzA1NA==", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363483054", "bodyText": "Does this need reportExceptions()?", "author": "ajsutton", "createdAt": "2020-01-06T21:06:42Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/core/RpcResponseCallback.java", "diffHunk": "@@ -13,57 +13,36 @@\n \n package tech.pegasys.artemis.networking.eth2.rpc.core;\n \n-import io.libp2p.core.Connection;\n-import io.netty.buffer.ByteBuf;\n-import io.netty.channel.ChannelHandlerContext;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcStream;\n \n class RpcResponseCallback<TResponse> implements ResponseCallback<TResponse> {\n   private static final Logger LOG = LogManager.getLogger();\n-  private final ChannelHandlerContext ctx;\n   private final RpcEncoder rpcEncoder;\n-  private final boolean closeNotification;\n-  private final Connection connection;\n+  private final RpcStream rpcStream;\n \n-  public RpcResponseCallback(\n-      final ChannelHandlerContext ctx,\n-      final RpcEncoder rpcEncoder,\n-      final boolean closeNotification,\n-      final Connection connection) {\n-    this.ctx = ctx;\n+  public RpcResponseCallback(final RpcStream rpcStream, final RpcEncoder rpcEncoder) {\n+    this.rpcStream = rpcStream;\n     this.rpcEncoder = rpcEncoder;\n-    this.closeNotification = closeNotification;\n-    this.connection = connection;\n   }\n \n   @Override\n   public void respond(final TResponse data) {\n-    writeResponse(ctx, rpcEncoder.encodeSuccessfulResponse(data));\n+    rpcStream.writeBytes(rpcEncoder.encodeSuccessfulResponse(data)).reportExceptions();\n   }\n \n   @Override\n   @SuppressWarnings(\"FutureReturnValueIgnored\")\n   public void completeSuccessfully() {\n-    ctx.channel().disconnect();\n-    if (closeNotification) {\n-      connection.getNettyChannel().close();\n-    }\n+    rpcStream.disconnect().reportExceptions();\n   }\n \n   @Override\n   @SuppressWarnings(\"FutureReturnValueIgnored\")\n   public void completeWithError(final RpcException error) {\n     LOG.debug(\"Responding to RPC request with error: {}\", error.getErrorMessage());\n-    writeResponse(ctx, rpcEncoder.encodeErrorResponse(error));\n-    ctx.channel().disconnect();\n-  }\n-\n-  @SuppressWarnings(\"FutureReturnValueIgnored\")\n-  private void writeResponse(final ChannelHandlerContext ctx, final Bytes encoded) {\n-    ByteBuf respBuf = ctx.alloc().buffer();\n-    respBuf.writeBytes(encoded.toArrayUnsafe());\n-    ctx.writeAndFlush(respBuf);\n+    rpcStream.writeBytes(rpcEncoder.encodeErrorResponse(error));", "originalCommit": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ5ODk5OA==", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363498998", "bodyText": "yes - good call!", "author": "mbaxter", "createdAt": "2020-01-06T21:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4MzA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4Mzg3OQ==", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363483879", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new IllegalArgumentException(\"Unknown rpc method method invoked: \" + rpcMethod.getId());\n          \n          \n            \n                  throw new IllegalArgumentException(\"Unknown rpc method invoked: \" + rpcMethod.getId());", "author": "ajsutton", "createdAt": "2020-01-06T21:08:51Z", "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/LibP2PPeer.java", "diffHunk": "@@ -39,8 +50,19 @@ public boolean isConnected() {\n   }\n \n   @Override\n-  public Connection getConnection() {\n-    return connection;\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  public void disconnect() {\n+    connection.getNettyChannel().close();\n+  }\n+\n+  @Override\n+  public SafeFuture<RpcStream> sendRequest(\n+      RpcMethod rpcMethod, final Bytes initialPayload, final RpcRequestHandler handler) {\n+    RpcHandler rpcHandler = rpcHandlers.get(rpcMethod);\n+    if (rpcHandler == null) {\n+      throw new IllegalArgumentException(\"Unknown rpc method method invoked: \" + rpcMethod.getId());", "originalCommit": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4NDU0NA==", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363484544", "bodyText": "Really like this abstraction to hide the Netty APIs.", "author": "ajsutton", "createdAt": "2020-01-06T21:10:43Z", "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/LibP2PRpcStream.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.p2p.libp2p.rpc;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class LibP2PRpcStream implements RpcStream {", "originalCommit": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7a64f4874fdd501a33002ed097b7588823e458ba", "url": "https://github.com/ConsenSys/teku/commit/7a64f4874fdd501a33002ed097b7588823e458ba", "message": "Fix exception message\n\nCo-Authored-By: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-01-06T21:28:19Z", "type": "commit"}, {"oid": "2f595fe18d74b172d596dfa4cdbd24d1e75364ac", "url": "https://github.com/ConsenSys/teku/commit/2f595fe18d74b172d596dfa4cdbd24d1e75364ac", "message": "Report exception if writeBytes fails", "committedDate": "2020-01-06T21:49:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUzNTUwMg==", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363535502", "bodyText": "is the 0 here on the method name on purpose?", "author": "cemozerr", "createdAt": "2020-01-06T23:46:03Z", "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.p2p.libp2p.rpc;\n+\n+import io.libp2p.core.Connection;\n+import io.libp2p.core.P2PAbstractChannel;\n+import io.libp2p.core.multistream.Mode;\n+import io.libp2p.core.multistream.Multistream;\n+import io.libp2p.core.multistream.ProtocolBinding;\n+import io.libp2p.core.multistream.ProtocolMatcher;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.networking.p2p.libp2p.LibP2PNodeId;\n+import tech.pegasys.artemis.networking.p2p.libp2p.rpc.RpcHandler.Controller;\n+import tech.pegasys.artemis.networking.p2p.peer.NodeId;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcMethod;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcRequestHandler;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class RpcHandler implements ProtocolBinding<Controller> {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RpcMethod rpcMethod;\n+\n+  public RpcHandler(RpcMethod rpcMethod) {\n+    this.rpcMethod = rpcMethod;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public SafeFuture<RpcStream> sendRequest(\n+      Connection connection, Bytes initialPayload, RpcRequestHandler handler) {\n+    return SafeFuture.of(\n+            connection\n+                .getMuxerSession()\n+                .createStream(\n+                    Multistream.create(this.toInitiator(rpcMethod.getId())).toStreamHandler())\n+                .getControler())\n+        .thenCompose(\n+            ctr -> {\n+              ctr.setRequestHandler(handler);\n+              return ctr.getRpcStream()\n+                  .writeBytes(initialPayload)\n+                  .thenApply(f -> ctr.getRpcStream());\n+            });\n+  }\n+\n+  @NotNull\n+  @Override\n+  public String getAnnounce() {\n+    return rpcMethod.getId();\n+  }\n+\n+  @NotNull\n+  @Override\n+  public ProtocolMatcher getMatcher() {\n+    return new ProtocolMatcher(Mode.STRICT, getAnnounce(), null);\n+  }\n+\n+  @NotNull\n+  @Override\n+  public SafeFuture<Controller> initChannel(P2PAbstractChannel channel, String s) {\n+    // TODO timeout handlers\n+    final Connection connection = ((io.libp2p.core.Stream) channel).getConn();\n+    final NodeId nodeId = new LibP2PNodeId(connection.getSecureSession().getRemoteId());\n+    Controller controller = new Controller(nodeId);\n+    if (!channel.isInitiator()) {\n+      controller.setRequestHandler(rpcMethod.createIncomingRequestHandler());\n+    }\n+    channel.getNettyChannel().pipeline().addLast(controller);\n+    return controller.activeFuture;\n+  }\n+\n+  static class Controller extends SimpleChannelInboundHandler<ByteBuf> {\n+    private final NodeId nodeId;\n+    private RpcRequestHandler rpcRequestHandler;\n+    private RpcStream rpcStream;\n+    private List<ByteBuf> bufferedData = new ArrayList<>();\n+\n+    protected final SafeFuture<Controller> activeFuture = new SafeFuture<>();\n+\n+    private Controller(final NodeId nodeId) {\n+      this.nodeId = nodeId;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+      rpcStream = new LibP2PRpcStream(ctx);\n+      activeFuture.complete(this);\n+    }\n+\n+    public RpcStream getRpcStream() {\n+      return rpcStream;\n+    }\n+\n+    @Override\n+    protected void channelRead0(final ChannelHandlerContext ctx, final ByteBuf msg) {", "originalCommit": "2f595fe18d74b172d596dfa4cdbd24d1e75364ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc3ODIxNw==", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363778217", "bodyText": "yeah - its a quirk of the API (https://netty.io/4.0/api/io/netty/channel/SimpleChannelInboundHandler.html):\n\nPlease keep in mind that #channelRead0(ChannelHandlerContext, I) will be renamed to messageReceived(ChannelHandlerContext, I) in 5.0.", "author": "mbaxter", "createdAt": "2020-01-07T14:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUzNTUwMg=="}], "type": "inlineReview"}]}