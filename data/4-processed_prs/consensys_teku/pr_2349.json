{"pr_number": 2349, "pr_title": "Maintain a minimum number of randomly selected peers", "pr_createdAt": "2020-07-14T07:35:27Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2349", "timeline": [{"oid": "e6e485c190901418051439a1cc7edfa66a0db575", "url": "https://github.com/ConsenSys/teku/commit/e6e485c190901418051439a1cc7edfa66a0db575", "message": "Maintain a minimum number of randomly selected peers instead of selecting all peers based on score.", "committedDate": "2020-07-14T07:32:18Z", "type": "commit"}, {"oid": "d81ece30cca7a22ae420295c2e481fd1a5ca744c", "url": "https://github.com/ConsenSys/teku/commit/d81ece30cca7a22ae420295c2e481fd1a5ca744c", "message": "Fix errorprone.", "committedDate": "2020-07-14T07:53:17Z", "type": "commit"}, {"oid": "c479fac235ce01cbbfbcf25742aee2e3ecc3e239", "url": "https://github.com/ConsenSys/teku/commit/c479fac235ce01cbbfbcf25742aee2e3ecc3e239", "message": "Fix test.", "committedDate": "2020-07-14T09:01:38Z", "type": "commit"}, {"oid": "08949cbbeeb137986b721b336ec2a7040a6e62ec", "url": "https://github.com/ConsenSys/teku/commit/08949cbbeeb137986b721b336ec2a7040a6e62ec", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into connect-random-peers", "committedDate": "2020-07-14T09:03:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODI0MA==", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454238240", "bodyText": "if candidates.get() is not heavy, may be makes sense to remove this if", "author": "Nashatyrev", "createdAt": "2020-07-14T09:49:50Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/peers/Eth2PeerSelectionStrategy.java", "diffHunk": "@@ -38,54 +47,149 @@\n   private final TargetPeerRange targetPeerCountRange;\n   private final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory;\n   private final ReputationManager reputationManager;\n+  private final Shuffler shuffler;\n \n   public Eth2PeerSelectionStrategy(\n       final TargetPeerRange targetPeerCountRange,\n       final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory,\n-      final ReputationManager reputationManager) {\n+      final ReputationManager reputationManager,\n+      final Shuffler shuffler) {\n     this.targetPeerCountRange = targetPeerCountRange;\n     this.peerSubnetSubscriptionsFactory = peerSubnetSubscriptionsFactory;\n     this.reputationManager = reputationManager;\n+    this.shuffler = shuffler;\n   }\n \n   @Override\n   public List<PeerAddress> selectPeersToConnect(\n-      final P2PNetwork<?> network, final Supplier<List<DiscoveryPeer>> candidates) {\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final Supplier<List<DiscoveryPeer>> candidates) {\n     final PeerSubnetSubscriptions peerSubnetSubscriptions =\n         peerSubnetSubscriptionsFactory.create(network);\n     final int peersRequiredForPeerCount =\n         targetPeerCountRange.getPeersToAdd(network.getPeerCount());\n+    final int randomlySelectedPeerCount = getCurrentRandomlySelectedPeerCount(network, peerSources);\n+    final int randomlySelectedPeersToAdd =\n+        targetPeerCountRange.getRandomlySelectedPeersToAdd(randomlySelectedPeerCount);\n+\n     final int peersRequiredForSubnets = peerSubnetSubscriptions.getSubscribersRequired();\n-    final int maxAttempts = Math.max(peersRequiredForPeerCount, peersRequiredForSubnets);\n-    LOG.trace(\"Connecting to up to {} known peers\", maxAttempts);\n-    if (maxAttempts == 0) {\n+    final int scoreBasedPeersToAdd =\n+        Math.max(peersRequiredForPeerCount - randomlySelectedPeerCount, peersRequiredForSubnets);\n+    LOG.trace(\n+        \"Connecting to up to {} known peers\", scoreBasedPeersToAdd + randomlySelectedPeersToAdd);\n+    if (scoreBasedPeersToAdd == 0 && randomlySelectedPeersToAdd == 0) {\n       return emptyList();\n     }", "originalCommit": "08949cbbeeb137986b721b336ec2a7040a6e62ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4OTg0OA==", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454689848", "bodyText": "I'm in two minds - it requires pulling in every discovered peer which isn't the end of the world but definitely isn't free. Given we also get to avoid the cost of calculating peer scores etc I'm inclined to keep bailing out early.", "author": "ajsutton", "createdAt": "2020-07-14T22:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI0MjM0OA==", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454242348", "bodyText": "I'd better do something like\nList<RandomPeers> randomPeers = \n     selectRandomPeers(network, peerSources, randomlySelectedPeersToAdd, allCandidatePeers));\nallCandidatePeers.removeAll(randomPeers);\n... to keep the functions cleaner and avoid implicit allCandidatePeers modification inside selectAndRemoveRandomPeers()", "author": "Nashatyrev", "createdAt": "2020-07-14T09:57:12Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/peers/Eth2PeerSelectionStrategy.java", "diffHunk": "@@ -38,54 +47,149 @@\n   private final TargetPeerRange targetPeerCountRange;\n   private final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory;\n   private final ReputationManager reputationManager;\n+  private final Shuffler shuffler;\n \n   public Eth2PeerSelectionStrategy(\n       final TargetPeerRange targetPeerCountRange,\n       final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory,\n-      final ReputationManager reputationManager) {\n+      final ReputationManager reputationManager,\n+      final Shuffler shuffler) {\n     this.targetPeerCountRange = targetPeerCountRange;\n     this.peerSubnetSubscriptionsFactory = peerSubnetSubscriptionsFactory;\n     this.reputationManager = reputationManager;\n+    this.shuffler = shuffler;\n   }\n \n   @Override\n   public List<PeerAddress> selectPeersToConnect(\n-      final P2PNetwork<?> network, final Supplier<List<DiscoveryPeer>> candidates) {\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final Supplier<List<DiscoveryPeer>> candidates) {\n     final PeerSubnetSubscriptions peerSubnetSubscriptions =\n         peerSubnetSubscriptionsFactory.create(network);\n     final int peersRequiredForPeerCount =\n         targetPeerCountRange.getPeersToAdd(network.getPeerCount());\n+    final int randomlySelectedPeerCount = getCurrentRandomlySelectedPeerCount(network, peerSources);\n+    final int randomlySelectedPeersToAdd =\n+        targetPeerCountRange.getRandomlySelectedPeersToAdd(randomlySelectedPeerCount);\n+\n     final int peersRequiredForSubnets = peerSubnetSubscriptions.getSubscribersRequired();\n-    final int maxAttempts = Math.max(peersRequiredForPeerCount, peersRequiredForSubnets);\n-    LOG.trace(\"Connecting to up to {} known peers\", maxAttempts);\n-    if (maxAttempts == 0) {\n+    final int scoreBasedPeersToAdd =\n+        Math.max(peersRequiredForPeerCount - randomlySelectedPeerCount, peersRequiredForSubnets);\n+    LOG.trace(\n+        \"Connecting to up to {} known peers\", scoreBasedPeersToAdd + randomlySelectedPeersToAdd);\n+    if (scoreBasedPeersToAdd == 0 && randomlySelectedPeersToAdd == 0) {\n       return emptyList();\n     }\n+\n+    final List<DiscoveryPeer> allCandidatePeers = new ArrayList<>(candidates.get());\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+\n+    if (randomlySelectedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectAndRemoveRandomPeers(\n+              network, peerSources, randomlySelectedPeersToAdd, allCandidatePeers));", "originalCommit": "08949cbbeeb137986b721b336ec2a7040a6e62ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4ODE3Mg==", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454688172", "bodyText": "Yeah I was in two minds because it removes the invalid peers it finds as well as the ones it selects, but it's probably better to keep it simple and just wind up re-evaluating the rejected peers again when we consider them based on score.", "author": "ajsutton", "createdAt": "2020-07-14T22:46:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI0MjM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY5NzczOQ==", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454697739", "bodyText": "Ah, just remembered why I wound up doing this - there's a conversion from DiscoveryPeer to PeerAddress required to check if the candidate peer is already connected so having the chosen PeerAddress instances isn't enough to let us remove the DiscoveryPeer instances.  I don't like it but haven't come up with a way around it yet.", "author": "ajsutton", "createdAt": "2020-07-14T23:13:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI0MjM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI0NDk0OA==", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454244948", "bodyText": "Why not collect() here?", "author": "Nashatyrev", "createdAt": "2020-07-14T10:01:50Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/peers/Eth2PeerSelectionStrategy.java", "diffHunk": "@@ -38,54 +47,149 @@\n   private final TargetPeerRange targetPeerCountRange;\n   private final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory;\n   private final ReputationManager reputationManager;\n+  private final Shuffler shuffler;\n \n   public Eth2PeerSelectionStrategy(\n       final TargetPeerRange targetPeerCountRange,\n       final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory,\n-      final ReputationManager reputationManager) {\n+      final ReputationManager reputationManager,\n+      final Shuffler shuffler) {\n     this.targetPeerCountRange = targetPeerCountRange;\n     this.peerSubnetSubscriptionsFactory = peerSubnetSubscriptionsFactory;\n     this.reputationManager = reputationManager;\n+    this.shuffler = shuffler;\n   }\n \n   @Override\n   public List<PeerAddress> selectPeersToConnect(\n-      final P2PNetwork<?> network, final Supplier<List<DiscoveryPeer>> candidates) {\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final Supplier<List<DiscoveryPeer>> candidates) {\n     final PeerSubnetSubscriptions peerSubnetSubscriptions =\n         peerSubnetSubscriptionsFactory.create(network);\n     final int peersRequiredForPeerCount =\n         targetPeerCountRange.getPeersToAdd(network.getPeerCount());\n+    final int randomlySelectedPeerCount = getCurrentRandomlySelectedPeerCount(network, peerSources);\n+    final int randomlySelectedPeersToAdd =\n+        targetPeerCountRange.getRandomlySelectedPeersToAdd(randomlySelectedPeerCount);\n+\n     final int peersRequiredForSubnets = peerSubnetSubscriptions.getSubscribersRequired();\n-    final int maxAttempts = Math.max(peersRequiredForPeerCount, peersRequiredForSubnets);\n-    LOG.trace(\"Connecting to up to {} known peers\", maxAttempts);\n-    if (maxAttempts == 0) {\n+    final int scoreBasedPeersToAdd =\n+        Math.max(peersRequiredForPeerCount - randomlySelectedPeerCount, peersRequiredForSubnets);\n+    LOG.trace(\n+        \"Connecting to up to {} known peers\", scoreBasedPeersToAdd + randomlySelectedPeersToAdd);\n+    if (scoreBasedPeersToAdd == 0 && randomlySelectedPeersToAdd == 0) {\n       return emptyList();\n     }\n+\n+    final List<DiscoveryPeer> allCandidatePeers = new ArrayList<>(candidates.get());\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+\n+    if (randomlySelectedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectAndRemoveRandomPeers(\n+              network, peerSources, randomlySelectedPeersToAdd, allCandidatePeers));\n+    }\n+\n+    if (scoreBasedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectPeersByScore(\n+              network, peerSubnetSubscriptions, scoreBasedPeersToAdd, allCandidatePeers));\n+    }\n+    return unmodifiableList(selectedPeers); // Unmodifiable to make errorprone happy\n+  }\n+\n+  private List<PeerAddress> selectAndRemoveRandomPeers(\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final int randomlySelectedPeersToAdd,\n+      final List<DiscoveryPeer> allCandidatePeers) {\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+    shuffler.shuffle(allCandidatePeers);\n+    while (!allCandidatePeers.isEmpty() && selectedPeers.size() < randomlySelectedPeersToAdd) {\n+      final DiscoveryPeer candidate = allCandidatePeers.remove(0);\n+      checkCandidate(candidate, network)\n+          .ifPresent(\n+              peerAddress -> {\n+                peerSources.recordPeerSource(peerAddress.getId(), RANDOMLY_SELECTED);\n+                selectedPeers.add(peerAddress);\n+              });\n+    }\n+    return selectedPeers;\n+  }\n+\n+  private List<PeerAddress> selectPeersByScore(\n+      final P2PNetwork<?> network,\n+      final PeerSubnetSubscriptions peerSubnetSubscriptions,\n+      final int scoreBasedPeersToAdd,\n+      final List<DiscoveryPeer> allCandidatePeers) {\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n     final PeerScorer peerScorer = peerSubnetSubscriptions.createScorer();\n-    return candidates.get().stream()\n+    allCandidatePeers.stream()\n         .sorted(\n             Comparator.comparing((Function<DiscoveryPeer, Integer>) peerScorer::scoreCandidatePeer)\n                 .reversed())\n-        .map(network::createPeerAddress)\n+        .flatMap(candidate -> checkCandidate(candidate, network).stream())\n+        .limit(scoreBasedPeersToAdd)\n+        .forEach(selectedPeers::add);", "originalCommit": "08949cbbeeb137986b721b336ec2a7040a6e62ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4Njc4NA==", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454686784", "bodyText": "It was original adding to an existing list and I missed spotting the chance to refactor when it moved to a separate method.  Fixed.", "author": "ajsutton", "createdAt": "2020-07-14T22:42:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI0NDk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI0NzA4Nw==", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454247087", "bodyText": "Am I missing the place where we record peer as SELECTED_BY_SCORE?\npeerSources.recordPeerSource(peer, SELECTED_BY_SCORE);", "author": "Nashatyrev", "createdAt": "2020-07-14T10:05:53Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/peers/Eth2PeerSelectionStrategy.java", "diffHunk": "@@ -38,54 +47,149 @@\n   private final TargetPeerRange targetPeerCountRange;\n   private final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory;\n   private final ReputationManager reputationManager;\n+  private final Shuffler shuffler;\n \n   public Eth2PeerSelectionStrategy(\n       final TargetPeerRange targetPeerCountRange,\n       final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory,\n-      final ReputationManager reputationManager) {\n+      final ReputationManager reputationManager,\n+      final Shuffler shuffler) {\n     this.targetPeerCountRange = targetPeerCountRange;\n     this.peerSubnetSubscriptionsFactory = peerSubnetSubscriptionsFactory;\n     this.reputationManager = reputationManager;\n+    this.shuffler = shuffler;\n   }\n \n   @Override\n   public List<PeerAddress> selectPeersToConnect(\n-      final P2PNetwork<?> network, final Supplier<List<DiscoveryPeer>> candidates) {\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final Supplier<List<DiscoveryPeer>> candidates) {\n     final PeerSubnetSubscriptions peerSubnetSubscriptions =\n         peerSubnetSubscriptionsFactory.create(network);\n     final int peersRequiredForPeerCount =\n         targetPeerCountRange.getPeersToAdd(network.getPeerCount());\n+    final int randomlySelectedPeerCount = getCurrentRandomlySelectedPeerCount(network, peerSources);\n+    final int randomlySelectedPeersToAdd =\n+        targetPeerCountRange.getRandomlySelectedPeersToAdd(randomlySelectedPeerCount);\n+\n     final int peersRequiredForSubnets = peerSubnetSubscriptions.getSubscribersRequired();\n-    final int maxAttempts = Math.max(peersRequiredForPeerCount, peersRequiredForSubnets);\n-    LOG.trace(\"Connecting to up to {} known peers\", maxAttempts);\n-    if (maxAttempts == 0) {\n+    final int scoreBasedPeersToAdd =\n+        Math.max(peersRequiredForPeerCount - randomlySelectedPeerCount, peersRequiredForSubnets);\n+    LOG.trace(\n+        \"Connecting to up to {} known peers\", scoreBasedPeersToAdd + randomlySelectedPeersToAdd);\n+    if (scoreBasedPeersToAdd == 0 && randomlySelectedPeersToAdd == 0) {\n       return emptyList();\n     }\n+\n+    final List<DiscoveryPeer> allCandidatePeers = new ArrayList<>(candidates.get());\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+\n+    if (randomlySelectedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectAndRemoveRandomPeers(\n+              network, peerSources, randomlySelectedPeersToAdd, allCandidatePeers));\n+    }\n+\n+    if (scoreBasedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectPeersByScore(\n+              network, peerSubnetSubscriptions, scoreBasedPeersToAdd, allCandidatePeers));\n+    }\n+    return unmodifiableList(selectedPeers); // Unmodifiable to make errorprone happy\n+  }\n+\n+  private List<PeerAddress> selectAndRemoveRandomPeers(\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final int randomlySelectedPeersToAdd,\n+      final List<DiscoveryPeer> allCandidatePeers) {\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+    shuffler.shuffle(allCandidatePeers);\n+    while (!allCandidatePeers.isEmpty() && selectedPeers.size() < randomlySelectedPeersToAdd) {\n+      final DiscoveryPeer candidate = allCandidatePeers.remove(0);\n+      checkCandidate(candidate, network)\n+          .ifPresent(\n+              peerAddress -> {\n+                peerSources.recordPeerSource(peerAddress.getId(), RANDOMLY_SELECTED);\n+                selectedPeers.add(peerAddress);\n+              });\n+    }\n+    return selectedPeers;\n+  }\n+\n+  private List<PeerAddress> selectPeersByScore(\n+      final P2PNetwork<?> network,\n+      final PeerSubnetSubscriptions peerSubnetSubscriptions,\n+      final int scoreBasedPeersToAdd,\n+      final List<DiscoveryPeer> allCandidatePeers) {\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n     final PeerScorer peerScorer = peerSubnetSubscriptions.createScorer();\n-    return candidates.get().stream()\n+    allCandidatePeers.stream()\n         .sorted(\n             Comparator.comparing((Function<DiscoveryPeer, Integer>) peerScorer::scoreCandidatePeer)\n                 .reversed())\n-        .map(network::createPeerAddress)\n+        .flatMap(candidate -> checkCandidate(candidate, network).stream())\n+        .limit(scoreBasedPeersToAdd)\n+        .forEach(selectedPeers::add);\n+    return selectedPeers;", "originalCommit": "08949cbbeeb137986b721b336ec2a7040a6e62ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4MzI4Nw==", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454683287", "bodyText": "SELECTED_BY_SCORE is the default category used if there's no entry so we only ever record peers as being static or randomly selected.  I've renamed PeerSource to PeerPools to make this clearer.", "author": "ajsutton", "createdAt": "2020-07-14T22:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI0NzA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI1Mjg0NA==", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454252844", "bodyText": "Shouldn't we call peerSources.forgetPeer(peer.getId())) after .limit(peersToDrop) instead of line 182?\nMay be some of randomlySelectedPeersBeingDropped will not fall into the final list", "author": "Nashatyrev", "createdAt": "2020-07-14T10:16:54Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/peers/Eth2PeerSelectionStrategy.java", "diffHunk": "@@ -38,54 +47,149 @@\n   private final TargetPeerRange targetPeerCountRange;\n   private final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory;\n   private final ReputationManager reputationManager;\n+  private final Shuffler shuffler;\n \n   public Eth2PeerSelectionStrategy(\n       final TargetPeerRange targetPeerCountRange,\n       final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory,\n-      final ReputationManager reputationManager) {\n+      final ReputationManager reputationManager,\n+      final Shuffler shuffler) {\n     this.targetPeerCountRange = targetPeerCountRange;\n     this.peerSubnetSubscriptionsFactory = peerSubnetSubscriptionsFactory;\n     this.reputationManager = reputationManager;\n+    this.shuffler = shuffler;\n   }\n \n   @Override\n   public List<PeerAddress> selectPeersToConnect(\n-      final P2PNetwork<?> network, final Supplier<List<DiscoveryPeer>> candidates) {\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final Supplier<List<DiscoveryPeer>> candidates) {\n     final PeerSubnetSubscriptions peerSubnetSubscriptions =\n         peerSubnetSubscriptionsFactory.create(network);\n     final int peersRequiredForPeerCount =\n         targetPeerCountRange.getPeersToAdd(network.getPeerCount());\n+    final int randomlySelectedPeerCount = getCurrentRandomlySelectedPeerCount(network, peerSources);\n+    final int randomlySelectedPeersToAdd =\n+        targetPeerCountRange.getRandomlySelectedPeersToAdd(randomlySelectedPeerCount);\n+\n     final int peersRequiredForSubnets = peerSubnetSubscriptions.getSubscribersRequired();\n-    final int maxAttempts = Math.max(peersRequiredForPeerCount, peersRequiredForSubnets);\n-    LOG.trace(\"Connecting to up to {} known peers\", maxAttempts);\n-    if (maxAttempts == 0) {\n+    final int scoreBasedPeersToAdd =\n+        Math.max(peersRequiredForPeerCount - randomlySelectedPeerCount, peersRequiredForSubnets);\n+    LOG.trace(\n+        \"Connecting to up to {} known peers\", scoreBasedPeersToAdd + randomlySelectedPeersToAdd);\n+    if (scoreBasedPeersToAdd == 0 && randomlySelectedPeersToAdd == 0) {\n       return emptyList();\n     }\n+\n+    final List<DiscoveryPeer> allCandidatePeers = new ArrayList<>(candidates.get());\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+\n+    if (randomlySelectedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectAndRemoveRandomPeers(\n+              network, peerSources, randomlySelectedPeersToAdd, allCandidatePeers));\n+    }\n+\n+    if (scoreBasedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectPeersByScore(\n+              network, peerSubnetSubscriptions, scoreBasedPeersToAdd, allCandidatePeers));\n+    }\n+    return unmodifiableList(selectedPeers); // Unmodifiable to make errorprone happy\n+  }\n+\n+  private List<PeerAddress> selectAndRemoveRandomPeers(\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final int randomlySelectedPeersToAdd,\n+      final List<DiscoveryPeer> allCandidatePeers) {\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+    shuffler.shuffle(allCandidatePeers);\n+    while (!allCandidatePeers.isEmpty() && selectedPeers.size() < randomlySelectedPeersToAdd) {\n+      final DiscoveryPeer candidate = allCandidatePeers.remove(0);\n+      checkCandidate(candidate, network)\n+          .ifPresent(\n+              peerAddress -> {\n+                peerSources.recordPeerSource(peerAddress.getId(), RANDOMLY_SELECTED);\n+                selectedPeers.add(peerAddress);\n+              });\n+    }\n+    return selectedPeers;\n+  }\n+\n+  private List<PeerAddress> selectPeersByScore(\n+      final P2PNetwork<?> network,\n+      final PeerSubnetSubscriptions peerSubnetSubscriptions,\n+      final int scoreBasedPeersToAdd,\n+      final List<DiscoveryPeer> allCandidatePeers) {\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n     final PeerScorer peerScorer = peerSubnetSubscriptions.createScorer();\n-    return candidates.get().stream()\n+    allCandidatePeers.stream()\n         .sorted(\n             Comparator.comparing((Function<DiscoveryPeer, Integer>) peerScorer::scoreCandidatePeer)\n                 .reversed())\n-        .map(network::createPeerAddress)\n+        .flatMap(candidate -> checkCandidate(candidate, network).stream())\n+        .limit(scoreBasedPeersToAdd)\n+        .forEach(selectedPeers::add);\n+    return selectedPeers;\n+  }\n+\n+  private int getCurrentRandomlySelectedPeerCount(\n+      final P2PNetwork<?> network, final PeerSources peerSources) {\n+    return (int)\n+        network\n+            .streamPeers()\n+            .filter(peer -> peerSources.getSource(peer.getId()) == RANDOMLY_SELECTED)\n+            .count();\n+  }\n+\n+  private Optional<PeerAddress> checkCandidate(\n+      final DiscoveryPeer candidate, final P2PNetwork<?> network) {\n+    return Optional.of(network.createPeerAddress(candidate))\n         .filter(reputationManager::isConnectionInitiationAllowed)\n-        .filter(peerAddress -> !network.isConnected(peerAddress))\n-        .limit(maxAttempts)\n-        .collect(toList());\n+        .filter(peerAddress -> !network.isConnected(peerAddress));\n   }\n \n   @Override\n   public List<Peer> selectPeersToDisconnect(\n-      final P2PNetwork<?> network, final Predicate<Peer> canBeDisconnected) {\n-    final int peersToDrop = targetPeerCountRange.getPeersToDrop(network.getPeerCount());\n+      final P2PNetwork<?> network, final PeerSources peerSources) {\n+\n+    final Map<PeerSource, List<Peer>> peersBySource =\n+        network\n+            .streamPeers()\n+            .collect(Collectors.groupingBy(peer -> peerSources.getSource(peer.getId())));\n+\n+    final List<Peer> randomlySelectedPeers =\n+        peersBySource.getOrDefault(RANDOMLY_SELECTED, new ArrayList<>());\n+    final int randomlySelectedPeerCount = randomlySelectedPeers.size();\n+\n+    final int currentPeerCount = network.getPeerCount();\n+    final int peersToDrop = targetPeerCountRange.getPeersToDrop(currentPeerCount);\n     if (peersToDrop == 0) {\n       return emptyList();\n     }\n     final PeerScorer peerScorer = peerSubnetSubscriptionsFactory.create(network).createScorer();\n-    return network\n-        .streamPeers()\n-        .filter(canBeDisconnected)\n+    final int randomlySelectedPeersToDrop =\n+        targetPeerCountRange.getRandomlySelectedPeersToDrop(\n+            randomlySelectedPeerCount, currentPeerCount);\n+    shuffler.shuffle(randomlySelectedPeers);\n+    final List<Peer> randomlySelectedPeersBeingDropped =\n+        randomlySelectedPeers.subList(\n+            0, Math.min(randomlySelectedPeersToDrop, randomlySelectedPeers.size()));\n+    // Peers from the randomly selected pool that have been chosen are now left to justify\n+    // themselves based on their score alone.\n+    randomlySelectedPeersBeingDropped.forEach(peer -> peerSources.forgetPeer(peer.getId()));\n+    return Stream.concat(\n+            randomlySelectedPeersBeingDropped.stream(),\n+            peersBySource.getOrDefault(SELECTED_BY_SCORE, emptyList()).stream())\n         .sorted(Comparator.comparing(peerScorer::scoreExistingPeer))\n         .limit(peersToDrop)\n         .collect(toList());", "originalCommit": "08949cbbeeb137986b721b336ec2a7040a6e62ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4Njc2NQ==", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454686765", "bodyText": "We want to move them out of the randomly selected pool which puts them into the default score based pool.  Whether they get disconnected or not then just depends on their score, but they aren't \"protected\" as randomly selected peers anymore.", "author": "ajsutton", "createdAt": "2020-07-14T22:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI1Mjg0NA=="}], "type": "inlineReview"}, {"oid": "eba59236695c631b073260c1a147699e2668a4f0", "url": "https://github.com/ConsenSys/teku/commit/eba59236695c631b073260c1a147699e2668a4f0", "message": "Review feedback.", "committedDate": "2020-07-14T22:53:35Z", "type": "commit"}, {"oid": "12160b6966f609bbf05859b7b59aa0a1c860db26", "url": "https://github.com/ConsenSys/teku/commit/12160b6966f609bbf05859b7b59aa0a1c860db26", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into connect-random-peers", "committedDate": "2020-07-14T22:53:45Z", "type": "commit"}, {"oid": "ca4f60c69c0d6c5140bbd7f38c5ed08af02b83ee", "url": "https://github.com/ConsenSys/teku/commit/ca4f60c69c0d6c5140bbd7f38c5ed08af02b83ee", "message": "Fix test.", "committedDate": "2020-07-14T23:14:14Z", "type": "commit"}]}