{"pr_number": 2589, "pr_title": "Add state regeneration queue to limit concurrent regenerations", "pr_createdAt": "2020-08-17T06:10:46Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2589", "timeline": [{"oid": "0950833c5d48089060d7b5e3db3752d131e3d5ee", "url": "https://github.com/ConsenSys/teku/commit/0950833c5d48089060d7b5e3db3752d131e3d5ee", "message": "Add state regeneration queue to limit how many regenerations are in progress at a time.", "committedDate": "2020-08-17T06:06:08Z", "type": "commit"}, {"oid": "b999f14299f6017eccb92d1db33a3ec94e76ce5c", "url": "https://github.com/ConsenSys/teku/commit/b999f14299f6017eccb92d1db33a3ec94e76ce5c", "message": "Spotless.", "committedDate": "2020-08-17T06:12:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUwMTAwMg==", "url": "https://github.com/ConsenSys/teku/pull/2589#discussion_r471501002", "bodyText": "Something to potentially experiment with in a follow-up PR:  we could use AsyncChainStateGenerator.generateStates(targetRoot, stateHandler) to expose an API that gives us access to all intermediate states as well:  StateGenerator.regenerateStatesForBlock(targetRoot, stateHandler).  We could then dedupe requests across the entire chain being processed.", "author": "mbaxter", "createdAt": "2020-08-17T14:03:38Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/StateGenerationQueue.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.IntSupplier;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.hyperledger.besu.plugin.services.MetricsSystem;\n+import tech.pegasys.teku.core.lookup.BlockProvider;\n+import tech.pegasys.teku.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.teku.datastructures.hashtree.HashTree;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.metrics.TekuMetricCategory;\n+\n+public class StateGenerationQueue {\n+  private final ConcurrentHashMap<Bytes32, SafeFuture<SignedBlockAndState>> inProgressGeneration =\n+      new ConcurrentHashMap<>();\n+  private final AtomicInteger activeRegenerations = new AtomicInteger(0);\n+  private final Queue<RegenerationTask> queuedRegenerations = new ConcurrentLinkedQueue<>();\n+  private final MetricsSystem metricsSystem;\n+  private final IntSupplier activeRegenerationLimit;\n+\n+  StateGenerationQueue(\n+      final MetricsSystem metricsSystem, final IntSupplier activeRegenerationLimit) {\n+    this.metricsSystem = metricsSystem;\n+    this.activeRegenerationLimit = activeRegenerationLimit;\n+  }\n+\n+  public static StateGenerationQueue create(final MetricsSystem metricsSystem) {\n+    return new StateGenerationQueue(\n+        metricsSystem, () -> Math.max(2, Runtime.getRuntime().availableProcessors()));\n+  }\n+\n+  public void startMetrics() {\n+    metricsSystem.createIntegerGauge(\n+        TekuMetricCategory.BEACON,\n+        \"regenerations_requested\",\n+        \"Number of state regeneration tasks requested but not yet completed\",\n+        inProgressGeneration::size);\n+    metricsSystem.createIntegerGauge(\n+        TekuMetricCategory.BEACON,\n+        \"regenerations_active\",\n+        \"Number of state regeneration tasks actively being processed\",\n+        activeRegenerations::get);\n+    metricsSystem.createIntegerGauge(\n+        TekuMetricCategory.BEACON,\n+        \"regenerations_queued\",\n+        \"Number of state regeneration tasks queued for later processing\",\n+        queuedRegenerations::size);\n+  }\n+\n+  public SafeFuture<SignedBlockAndState> regenerateStateForBlock(\n+      final Bytes32 blockRoot,\n+      final HashTree tree,\n+      final SignedBlockAndState baseBlockAndState,\n+      final BlockProvider blockProvider,\n+      final Consumer<SignedBlockAndState> cacheHandler) {\n+    return regenerateStateForBlock(\n+        new RegenerationTask(blockRoot, tree, baseBlockAndState, blockProvider, cacheHandler));\n+  }\n+\n+  public SafeFuture<SignedBlockAndState> regenerateStateForBlock(final RegenerationTask task) {\n+    final SafeFuture<SignedBlockAndState> future = new SafeFuture<>();\n+    final SafeFuture<SignedBlockAndState> inProgress =\n+        inProgressGeneration.putIfAbsent(task.getBlockRoot(), future);\n+    if (inProgress != null) {\n+      return inProgress;\n+    }\n+    Optional<Bytes32> maybeAncestorRoot = task.getTree().getParent(task.getBlockRoot());\n+    while (maybeAncestorRoot.isPresent()) {\n+      final Bytes32 ancestorRoot = maybeAncestorRoot.get();\n+      final SafeFuture<SignedBlockAndState> parentFuture = inProgressGeneration.get(ancestorRoot);\n+      if (parentFuture != null) {\n+        parentFuture\n+            .thenAccept(ancestorState -> queueRegeneration(task.rebase(ancestorState)))\n+            .finish(\n+                error -> {\n+                  // Remove if regeneration fails.\n+                  inProgressGeneration.remove(task.getBlockRoot(), future);\n+                  future.completeExceptionally(error);\n+                });\n+        return future;\n+      }\n+      maybeAncestorRoot =\n+          maybeAncestorRoot\n+              // Don't find ancestor of the root hash\n+              .filter(root -> !root.equals(task.getTree().getRootHash()))\n+              .flatMap(task.getTree()::getParent);\n+    }\n+    queueRegeneration(task);\n+    return future;\n+  }\n+\n+  private void queueRegeneration(final RegenerationTask task) {\n+    queuedRegenerations.add(task);\n+    tryProcessNext();\n+  }\n+\n+  private void tryProcessNext() {\n+    int currentActiveCount = activeRegenerations.get();\n+    while (currentActiveCount < activeRegenerationLimit.getAsInt()\n+        && !queuedRegenerations.isEmpty()) {\n+      if (activeRegenerations.compareAndSet(currentActiveCount, currentActiveCount + 1)) {\n+        processNext();\n+      }\n+      currentActiveCount = activeRegenerations.get();\n+    }\n+  }\n+\n+  private void processNext() {\n+    final RegenerationTask task = queuedRegenerations.poll();\n+    if (task == null) {\n+      activeRegenerations.decrementAndGet();\n+      return;\n+    }\n+    task.regenerate()\n+        .whenComplete(\n+            (result, error) -> {\n+              final SafeFuture<SignedBlockAndState> future =\n+                  inProgressGeneration.remove(task.getBlockRoot());\n+              if (error != null) {\n+                future.completeExceptionally(error);\n+              } else {\n+                future.complete(result);\n+              }\n+            })\n+        .alwaysRun(\n+            () -> {\n+              activeRegenerations.decrementAndGet();\n+              tryProcessNext();\n+            })\n+        .reportExceptions();\n+  }\n+\n+  public static class RegenerationTask {\n+    private static final Logger LOG = LogManager.getLogger();\n+    private final HashTree tree;\n+    private final SignedBlockAndState baseBlockAndState;\n+    private final BlockProvider blockProvider;\n+    private final Bytes32 blockRoot;\n+    private final Consumer<SignedBlockAndState> cacheHandler;\n+\n+    public RegenerationTask(\n+        final Bytes32 blockRoot,\n+        final HashTree tree,\n+        final SignedBlockAndState baseBlockAndState,\n+        final BlockProvider blockProvider,\n+        final Consumer<SignedBlockAndState> cacheHandler) {\n+      this.tree = tree;\n+      this.baseBlockAndState = baseBlockAndState;\n+      this.blockProvider = blockProvider;\n+      this.blockRoot = blockRoot;\n+      this.cacheHandler = cacheHandler;\n+    }\n+\n+    public Bytes32 getBlockRoot() {\n+      return blockRoot;\n+    }\n+\n+    public HashTree getTree() {\n+      return tree;\n+    }\n+\n+    public RegenerationTask rebase(final SignedBlockAndState newBaseBlockAndState) {\n+      final Bytes32 newBaseRoot = newBaseBlockAndState.getRoot();\n+      if (!tree.contains(newBaseRoot)) {\n+        LOG.warn(\n+            \"Attempting to rebase a task for {} onto a starting state that is not a required ancestor ({} at slot {})\",\n+            blockRoot,\n+            newBaseRoot,\n+            newBaseBlockAndState.getSlot());\n+        return this;\n+      }\n+      final HashTree treeFromAncestor =\n+          tree.withRoot(newBaseRoot).block(newBaseBlockAndState.getBlock()).build();\n+      return new RegenerationTask(\n+          blockRoot, treeFromAncestor, newBaseBlockAndState, blockProvider, cacheHandler);\n+    }\n+\n+    public SafeFuture<SignedBlockAndState> regenerate() {\n+      final StateGenerator stateGenerator =\n+          StateGenerator.create(tree, baseBlockAndState, blockProvider);\n+      return stateGenerator.regenerateStateForBlock(blockRoot).thenPeek(cacheHandler);", "originalCommit": "b999f14299f6017eccb92d1db33a3ec94e76ce5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc2NjgzMQ==", "url": "https://github.com/ConsenSys/teku/pull/2589#discussion_r471766831", "bodyText": "Interesting idea, the one concern I'd have is making sure we didn't consume too much memory in the process.", "author": "ajsutton", "createdAt": "2020-08-17T20:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUwMTAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUxMTI3OA==", "url": "https://github.com/ConsenSys/teku/pull/2589#discussion_r471511278", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void assertRegneratedAfterRebase(final SignedBlockAndState newBaseState) {\n          \n          \n            \n                public void assertRegeneratedAfterRebase(final SignedBlockAndState newBaseState) {", "author": "mbaxter", "createdAt": "2020-08-17T14:19:11Z", "path": "ethereum/core/src/test/java/tech/pegasys/teku/core/stategenerator/StateGenerationQueueTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.core.stategenerator.StateGenerationQueue.RegenerationTask;\n+import tech.pegasys.teku.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.teku.datastructures.hashtree.HashTree;\n+import tech.pegasys.teku.datastructures.util.DataStructureUtil;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.metrics.StubMetricsSystem;\n+import tech.pegasys.teku.metrics.TekuMetricCategory;\n+\n+class StateGenerationQueueTest {\n+\n+  private static final int ACTIVE_REGENERATION_LIMIT = 2;\n+  private final DataStructureUtil dataStructureUtil = new DataStructureUtil();\n+  private final StubMetricsSystem metricsSystem = new StubMetricsSystem();\n+  private final StateGenerationQueue stateGenerationQueue =\n+      new StateGenerationQueue(metricsSystem, () -> ACTIVE_REGENERATION_LIMIT);\n+\n+  @BeforeEach\n+  void setUp() {\n+    stateGenerationQueue.startMetrics();\n+  }\n+\n+  @Test\n+  void shouldGenerateBlockWhenItIsTheOnlyTask() {\n+    final StubRegenerationTask task = createRandomTask();\n+    final SafeFuture<SignedBlockAndState> result =\n+        stateGenerationQueue.regenerateStateForBlock(task);\n+    assertThat(result).isNotDone();\n+    task.assertRegeneratedWithoutRebase();\n+\n+    final SignedBlockAndState expectedResult =\n+        dataStructureUtil.randomSignedBlockAndState(UInt64.ONE);\n+    task.regenerationResult.complete(expectedResult);\n+    assertThat(result).isCompletedWithValue(expectedResult);\n+    assertAllRegenerationsComplete();\n+  }\n+\n+  @Test\n+  void shouldRegenerateInParallelWhenLimitNotReached() {\n+    final StubRegenerationTask task1 = createRandomTask();\n+    final StubRegenerationTask task2 = createRandomTask();\n+    final StubRegenerationTask task3 = createRandomTask();\n+    final SafeFuture<SignedBlockAndState> result1 =\n+        stateGenerationQueue.regenerateStateForBlock(task1);\n+    final SafeFuture<SignedBlockAndState> result2 =\n+        stateGenerationQueue.regenerateStateForBlock(task2);\n+    final SafeFuture<SignedBlockAndState> result3 =\n+        stateGenerationQueue.regenerateStateForBlock(task3);\n+    assertThat(result1).isNotDone();\n+    assertThat(result2).isNotDone();\n+    assertThat(result3).isNotDone();\n+    task1.assertRegeneratedWithoutRebase();\n+    task2.assertRegeneratedWithoutRebase();\n+    task3.assertNotRegenerated();\n+\n+    // Task 3 is queued until one of the previous tasks finishes\n+    task1.regenerationResult.complete(dataStructureUtil.randomSignedBlockAndState(UInt64.ONE));\n+    task3.assertRegeneratedWithoutRebase();\n+  }\n+\n+  @Test\n+  void shouldUseQueuedRegenerationAsStartingPointIfPossible() {\n+    final SignedBlockAndState baseState = dataStructureUtil.randomSignedBlockAndState(UInt64.ONE);\n+    final List<SignedBlockAndState> blocks =\n+        dataStructureUtil.randomSignedBlockAndStateSequence(baseState.getBlock(), 10, false);\n+    final SignedBlockAndState task1State = blocks.get(6);\n+    final List<SignedBlockAndState> task1Blocks = blocks.subList(0, 6);\n+    final HashTree task1Tree = createHashTreeForChain(task1Blocks);\n+    final StubRegenerationTask task1 = new StubRegenerationTask(task1State.getRoot(), task1Tree);\n+    final SafeFuture<SignedBlockAndState> result1 =\n+        stateGenerationQueue.regenerateStateForBlock(task1);\n+    assertThat(result1).isNotDone();\n+    task1.assertRegeneratedWithoutRebase();\n+\n+    final Bytes32 task2Target = blocks.get(9).getRoot();\n+    final HashTree task2Tree = createHashTreeForChain(blocks);\n+    final StubRegenerationTask task2 = new StubRegenerationTask(task2Target, task2Tree);\n+    final SafeFuture<SignedBlockAndState> result2 =\n+        stateGenerationQueue.regenerateStateForBlock(task2);\n+    assertThat(result2).isNotDone();\n+    // Shouldn't start task 2 because it can use the result of task 1 as a better starting point\n+    task2.assertNotRegenerated();\n+\n+    task1.regenerationResult.complete(task1State);\n+    assertThat(result1).isCompletedWithValue(task1State);\n+\n+    task2.assertRegneratedAfterRebase(task1State);\n+    final SignedBlockAndState task2State =\n+        dataStructureUtil.randomSignedBlockAndState(UInt64.valueOf(2));\n+    task2.regenerationResult.complete(task2State);\n+\n+    assertThat(result2).isCompletedWithValue(task2State);\n+    assertAllRegenerationsComplete();\n+  }\n+\n+  @Test\n+  void shouldNotUseQueuedStartingPointBeforeTheCurrentRoot() {\n+    final SignedBlockAndState baseState = dataStructureUtil.randomSignedBlockAndState(UInt64.ONE);\n+    final List<SignedBlockAndState> blocks =\n+        dataStructureUtil.randomSignedBlockAndStateSequence(baseState.getBlock(), 10, false);\n+    final SignedBlockAndState task1State = blocks.get(6);\n+    final List<SignedBlockAndState> task1Blocks = blocks.subList(0, 6);\n+    final HashTree task1Tree = createHashTreeForChain(task1Blocks);\n+    final StubRegenerationTask task1 = new StubRegenerationTask(task1State.getRoot(), task1Tree);\n+    final SafeFuture<SignedBlockAndState> result1 =\n+        stateGenerationQueue.regenerateStateForBlock(task1);\n+    assertThat(result1).isNotDone();\n+    task1.assertRegeneratedWithoutRebase();\n+\n+    final Bytes32 task2Target = blocks.get(9).getRoot();\n+    final HashTree task2Tree = createHashTreeForChain(blocks.subList(7, 10));\n+    final StubRegenerationTask task2 = new StubRegenerationTask(task2Target, task2Tree);\n+    final SafeFuture<SignedBlockAndState> result2 =\n+        stateGenerationQueue.regenerateStateForBlock(task2);\n+    assertThat(result2).isNotDone();\n+    // Task 2 starts immediately because its base root is already better than task 1\n+    // even though task 1's target root is in the hash tree as the parent of its root\n+    task2.assertRegeneratedWithoutRebase();\n+  }\n+\n+  private HashTree createHashTreeForChain(final List<SignedBlockAndState> blocks) {\n+    final HashTree.Builder builder = HashTree.builder();\n+    blocks.forEach(block -> builder.childAndParentRoots(block.getRoot(), block.getParentRoot()));\n+    builder.rootHash(blocks.get(0).getRoot());\n+    return builder.build();\n+  }\n+\n+  private StubRegenerationTask createRandomTask() {\n+    final Bytes32 targetBlockRoot = dataStructureUtil.randomBytes32();\n+    final HashTree tree = createHashTree(targetBlockRoot);\n+    return new StubRegenerationTask(targetBlockRoot, tree);\n+  }\n+\n+  private void assertAllRegenerationsComplete() {\n+    assertThat(\n+            metricsSystem.getGauge(TekuMetricCategory.BEACON, \"regenerations_requested\").getValue())\n+        .isZero();\n+    assertThat(metricsSystem.getGauge(TekuMetricCategory.BEACON, \"regenerations_active\").getValue())\n+        .isZero();\n+    assertThat(metricsSystem.getGauge(TekuMetricCategory.BEACON, \"regenerations_queued\").getValue())\n+        .isZero();\n+  }\n+\n+  private HashTree createHashTree(final Bytes32 targetBlockRoot) {\n+    final HashTree.Builder hashTreeBuilder = HashTree.builder();\n+    Bytes32 childRoot = targetBlockRoot;\n+    Bytes32 parentRoot = dataStructureUtil.randomBytes32();\n+    for (int i = 0; i < 3; i++) {\n+      hashTreeBuilder.childAndParentRoots(childRoot, parentRoot);\n+      childRoot = parentRoot;\n+      parentRoot = dataStructureUtil.randomBytes32();\n+    }\n+    hashTreeBuilder.childAndParentRoots(childRoot, parentRoot);\n+    hashTreeBuilder.rootHash(childRoot);\n+    return hashTreeBuilder.build();\n+  }\n+\n+  private static class StubRegenerationTask extends RegenerationTask {\n+\n+    private final SafeFuture<SignedBlockAndState> regenerationResult = new SafeFuture<>();\n+    private boolean regenerated = false;\n+    private Optional<SignedBlockAndState> rebasedTo = Optional.empty();\n+\n+    public StubRegenerationTask(final Bytes32 blockRoot, final HashTree tree) {\n+      super(blockRoot, tree, null, null, null);\n+    }\n+\n+    @Override\n+    public RegenerationTask rebase(final SignedBlockAndState newBaseBlockAndState) {\n+      rebasedTo = Optional.of(newBaseBlockAndState);\n+      return this;\n+    }\n+\n+    @Override\n+    public SafeFuture<SignedBlockAndState> regenerate() {\n+      regenerated = true;\n+      return regenerationResult;\n+    }\n+\n+    public void assertRegeneratedWithoutRebase() {\n+      assertThat(rebasedTo).isEmpty();\n+      assertThat(regenerated).isTrue();\n+    }\n+\n+    public void assertNotRegenerated() {\n+      assertThat(regenerated).isFalse();\n+    }\n+\n+    public void assertRegneratedAfterRebase(final SignedBlockAndState newBaseState) {", "originalCommit": "b999f14299f6017eccb92d1db33a3ec94e76ce5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9668e1897d22249ca87ad9c61eed40865bce2eeb", "url": "https://github.com/ConsenSys/teku/commit/9668e1897d22249ca87ad9c61eed40865bce2eeb", "message": "Fix typo.", "committedDate": "2020-08-17T20:47:34Z", "type": "commit"}, {"oid": "814f3008450789da406acb31f06435f0006f7f74", "url": "https://github.com/ConsenSys/teku/commit/814f3008450789da406acb31f06435f0006f7f74", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into regenerate-queue", "committedDate": "2020-08-17T20:47:45Z", "type": "commit"}]}