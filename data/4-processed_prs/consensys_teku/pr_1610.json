{"pr_number": 1610, "pr_title": "refactored metrics to remove from BeaconChainController, and added tests for metric getters.", "pr_createdAt": "2020-04-17T03:39:30Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1610", "timeline": [{"oid": "59f487b53bb0cf4bb8c4b628914f3abb2fee3813", "url": "https://github.com/ConsenSys/teku/commit/59f487b53bb0cf4bb8c4b628914f3abb2fee3813", "message": "refactored metrics to remove from BeaconChainController, and added tests for metric getters.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-04-17T03:38:51Z", "type": "commit"}, {"oid": "658a7e3abce53d3f242953c7e8698dee85e803a3", "url": "https://github.com/ConsenSys/teku/commit/658a7e3abce53d3f242953c7e8698dee85e803a3", "message": "Merge remote-tracking branch 'upstream/master' into metrics-refactor\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-04-19T20:26:52Z", "type": "commit"}, {"oid": "cc15a2e5802a9c6b4bad1ed044c7be2bb2d8c172", "url": "https://github.com/ConsenSys/teku/commit/cc15a2e5802a9c6b4bad1ed044c7be2bb2d8c172", "message": "remove unused suppression\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-04-19T21:30:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyNTY3MA==", "url": "https://github.com/ConsenSys/teku/pull/1610#discussion_r411025670", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                beaconChainMetrics.initialise(metricsSystem);\n          \n          \n            \n                beaconChainMetrics.initialize(metricsSystem);", "author": "macfarla", "createdAt": "2020-04-20T00:20:47Z", "path": "services/beaconchain/src/main/java/tech/pegasys/artemis/services/beaconchain/BeaconChainController.java", "diffHunk": "@@ -220,124 +220,10 @@ private void initForkChoice() {\n     eventChannels.subscribe(FinalizedCheckpointChannel.class, forkChoice);\n   }\n \n-  private long getCurrentSlotValue() {\n-    return nodeSlot.longValue();\n-  }\n-\n-  private long getHeadSlotValue() {\n-    return recentChainData.getBestSlot().longValue();\n-  }\n-\n-  private static long getLongFromRoot(Bytes32 root) {\n-    return root.getLong(24, ByteOrder.LITTLE_ENDIAN);\n-  }\n-\n-  private long getFinalizedRootValue() {\n-    Optional<BeaconBlockAndState> maybeBlockAndState = recentChainData.getBestBlockAndState();\n-    if (maybeBlockAndState.isPresent()) {\n-      Bytes32 root =\n-          maybeBlockAndState.get().getState().getCurrent_justified_checkpoint().getRoot();\n-      return getLongFromRoot(root);\n-    }\n-    return 0L;\n-  }\n-\n-  private long getPreviousJustifiedRootValue() {\n-    Optional<BeaconBlockAndState> maybeBlockAndState = recentChainData.getBestBlockAndState();\n-    if (maybeBlockAndState.isPresent()) {\n-      Bytes32 root =\n-          maybeBlockAndState.get().getState().getPrevious_justified_checkpoint().getRoot();\n-      return getLongFromRoot(root);\n-    }\n-    return 0L;\n-  }\n-\n-  private long getJustifiedRootValue() {\n-    Optional<BeaconBlockAndState> maybeBlockAndState = recentChainData.getBestBlockAndState();\n-    if (maybeBlockAndState.isPresent()) {\n-      Bytes32 root =\n-          maybeBlockAndState.get().getState().getCurrent_justified_checkpoint().getRoot();\n-      return getLongFromRoot(root);\n-    }\n-    return 0L;\n-  }\n-\n-  private long getHeadRootValue() {\n-    Optional<Bytes32> maybeBlockRoot = recentChainData.getBestBlockRoot();\n-    return maybeBlockRoot.isPresent() ? getLongFromRoot(maybeBlockRoot.get()) : 0L;\n-  }\n-\n-  private long getFinalizedEpochValue() {\n-    return recentChainData.getFinalizedEpoch().longValue();\n-  }\n-\n-  private long getJustifiedEpochValue() {\n-    return recentChainData.getStore().getBestJustifiedCheckpoint().getEpoch().longValue();\n-  }\n-\n-  private long getPreviousJustifiedEpochValue() {\n-    Optional<BeaconBlockAndState> maybeBlockAndState = recentChainData.getBestBlockAndState();\n-    if (maybeBlockAndState.isPresent()) {\n-      return maybeBlockAndState\n-          .get()\n-          .getState()\n-          .getPrevious_justified_checkpoint()\n-          .getEpoch()\n-          .longValue();\n-    }\n-    return 0L;\n-  }\n-\n   public void initMetrics() {\n     LOG.debug(\"BeaconChainController.initMetrics()\");\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"slot\",\n-        \"Latest slot recorded by the beacon chain\",\n-        this::getCurrentSlotValue);\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"head_slot\",\n-        \"Slot of the head block of the beacon chain\",\n-        this::getHeadSlotValue);\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"head_root\",\n-        \"Root of the head block of the beacon chain\",\n-        this::getHeadRootValue);\n-\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"finalized_epoch\",\n-        \"Current finalized epoch\",\n-        this::getFinalizedEpochValue);\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"finalized_root\",\n-        \"Current finalized root\",\n-        this::getFinalizedRootValue);\n-\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"current_justified_epoch\",\n-        \"Current justified epoch\",\n-        this::getJustifiedEpochValue);\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"current_justified_root\",\n-        \"Current justified root\",\n-        this::getJustifiedRootValue);\n-\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"previous_justified_epoch\",\n-        \"Current previously justified epoch\",\n-        this::getPreviousJustifiedEpochValue);\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"previous_justified_root\",\n-        \"Current previously justified root\",\n-        this::getPreviousJustifiedRootValue);\n+    beaconChainMetrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    beaconChainMetrics.initialise(metricsSystem);", "originalCommit": "cc15a2e5802a9c6b4bad1ed044c7be2bb2d8c172", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyNTg3Nw==", "url": "https://github.com/ConsenSys/teku/pull/1610#discussion_r411025877", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void initialise(final MetricsSystem metricsSystem) {\n          \n          \n            \n              public void initialize(final MetricsSystem metricsSystem) {", "author": "macfarla", "createdAt": "2020-04-20T00:22:05Z", "path": "services/beaconchain/src/main/java/tech/pegasys/artemis/services/beaconchain/BeaconChainMetrics.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.services.beaconchain;\n+\n+import java.nio.ByteOrder;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.hyperledger.besu.plugin.services.MetricsSystem;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlockAndState;\n+import tech.pegasys.artemis.datastructures.blocks.NodeSlot;\n+import tech.pegasys.artemis.metrics.ArtemisMetricCategory;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+public class BeaconChainMetrics {\n+  private static final long NOT_SET = 0L;\n+  private final RecentChainData recentChainData;\n+  private volatile NodeSlot nodeSlot;\n+\n+  public BeaconChainMetrics(final RecentChainData recentChainData, NodeSlot nodeSlot) {\n+    this.recentChainData = recentChainData;\n+    this.nodeSlot = nodeSlot;\n+  }\n+\n+  public void initialise(final MetricsSystem metricsSystem) {", "originalCommit": "cc15a2e5802a9c6b4bad1ed044c7be2bb2d8c172", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyNjQyOA==", "url": "https://github.com/ConsenSys/teku/pull/1610#discussion_r411026428", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              void getJustifiedEpochValue_shouldSupplyValueWhenStoreIsPresent() {\n          \n          \n            \n              void getJustifiedEpochValue_shouldReturnValueWhenStoreIsPresent() {", "author": "macfarla", "createdAt": "2020-04-20T00:24:57Z", "path": "services/beaconchain/src/test/java/tech/pegasys/artemis/services/beaconchain/BeaconChainMetricsTest.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.services.beaconchain;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlockAndState;\n+import tech.pegasys.artemis.datastructures.blocks.NodeSlot;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+class BeaconChainMetricsTest {\n+  private static final UnsignedLong NODE_SLOT_VALUE = UnsignedLong.valueOf(100L);\n+  private final Bytes32 root =\n+      Bytes32.fromHexString(\"0x760aa80a2c5cc1452a5301ecb176b366372d5f2218e0c24eFFFFFFFFFFFFFFFF\");\n+  private final Bytes32 root2 =\n+      Bytes32.fromHexString(\"0x760aa80a2c5cc1452a5301ecb176b366372d5f2218e0c24eFFFFFFFFFFFFFF7F\");\n+  private final Bytes32 root3 =\n+      Bytes32.fromHexString(\"0x760aa80a2c5cc1452a5301ecb176b366372d5f2218e0c24e0000000000000080\");\n+  private final Checkpoint checkpoint = new Checkpoint(NODE_SLOT_VALUE, root);\n+\n+  private static BeaconBlockAndState blockAndState = mock(BeaconBlockAndState.class);\n+  private BeaconState state = mock(BeaconState.class);\n+\n+  private final NodeSlot nodeSlot = new NodeSlot(NODE_SLOT_VALUE);\n+\n+  private final RecentChainData recentChainData = mock(RecentChainData.class);\n+\n+  @Test\n+  void getLongFromRoot_shouldParseNegativeOne() {\n+    assertThat(-1L).isEqualTo(BeaconChainMetrics.getLongFromRoot(root));\n+  }\n+\n+  @Test\n+  void getLongFromRoot_shouldParseMaxLong() {\n+    assertThat(Long.MAX_VALUE).isEqualTo(BeaconChainMetrics.getLongFromRoot(root2));\n+  }\n+\n+  @Test\n+  void getLongFromRoot_shouldParseMinLong() {\n+    assertThat(Long.MIN_VALUE).isEqualTo(BeaconChainMetrics.getLongFromRoot(root3));\n+  }\n+\n+  @Test\n+  void getCurrentSlotValue_shouldReturnCurrentSlot() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    assertThat(NODE_SLOT_VALUE.longValue()).isEqualTo(metrics.getCurrentSlotValue());\n+  }\n+\n+  @Test\n+  void getHeadSlotValue_shouldSupplyValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(false);\n+    when(recentChainData.getBestSlot()).thenReturn(ONE);\n+\n+    assertThat(1L).isEqualTo(metrics.getHeadSlotValue());\n+    verify(recentChainData).isPreGenesis();\n+    verify(recentChainData).getBestSlot();\n+  }\n+\n+  @Test\n+  void getHeadSlotValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+\n+    assertThat(0L).isEqualTo(metrics.getHeadSlotValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getFinalizedEpochValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+\n+    assertThat(0L).isEqualTo(metrics.getFinalizedEpochValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getFinalizedEpochValue_shouldSupplyValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(false);\n+    when(recentChainData.getFinalizedEpoch()).thenReturn(ONE);\n+\n+    assertThat(1L).isEqualTo(metrics.getFinalizedEpochValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getHeadRootValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+\n+    assertThat(0L).isEqualTo(metrics.getHeadRootValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getHeadRootValue_shouldReturnValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(false);\n+    when(recentChainData.getBestBlockRoot()).thenReturn(Optional.of(root));\n+\n+    assertThat(-1L).isEqualTo(metrics.getHeadRootValue());\n+    verify(recentChainData).getBestBlockRoot();\n+  }\n+\n+  @Test\n+  void getFinalizedRootValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+    when(recentChainData.getBestBlockAndState()).thenCallRealMethod();\n+\n+    assertThat(0L).isEqualTo(metrics.getFinalizedRootValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getFinalizedRootValue_shouldReturnValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.getBestBlockAndState()).thenReturn(Optional.of(blockAndState));\n+    when(blockAndState.getState()).thenReturn(state);\n+    when(state.getFinalized_checkpoint()).thenReturn(checkpoint);\n+\n+    assertThat(-1L).isEqualTo(metrics.getFinalizedRootValue());\n+    verify(state).getFinalized_checkpoint();\n+  }\n+\n+  @Test\n+  void getPreviousJustifiedEpochValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+    when(recentChainData.getBestBlockAndState()).thenCallRealMethod();\n+\n+    assertThat(0L).isEqualTo(metrics.getPreviousJustifiedEpochValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getPreviousJustifiedEpochValue_shouldSupplyValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(false);\n+    when(recentChainData.getBestBlockAndState()).thenReturn(Optional.of(blockAndState));\n+    when(blockAndState.getState()).thenReturn(state);\n+    when(state.getPrevious_justified_checkpoint()).thenReturn(checkpoint);\n+\n+    assertThat(NODE_SLOT_VALUE.longValue()).isEqualTo(metrics.getPreviousJustifiedEpochValue());\n+    verify(state).getPrevious_justified_checkpoint();\n+  }\n+\n+  @Test\n+  void getPreviousJustifiedRootValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+    when(recentChainData.getBestBlockAndState()).thenCallRealMethod();\n+\n+    assertThat(0L).isEqualTo(metrics.getPreviousJustifiedRootValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getPreviousJustifiedRootValue_shouldReturnValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.getBestBlockAndState()).thenReturn(Optional.of(blockAndState));\n+    when(blockAndState.getState()).thenReturn(state);\n+    when(state.getPrevious_justified_checkpoint()).thenReturn(checkpoint);\n+\n+    assertThat(-1L).isEqualTo(metrics.getPreviousJustifiedRootValue());\n+    verify(state).getPrevious_justified_checkpoint();\n+  }\n+\n+  @Test\n+  void getJustifiedRootValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+    when(recentChainData.getBestBlockAndState()).thenCallRealMethod();\n+\n+    assertThat(0L).isEqualTo(metrics.getJustifiedRootValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getJustifiedRootValue_shouldReturnValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.getBestBlockAndState()).thenReturn(Optional.of(blockAndState));\n+    when(blockAndState.getState()).thenReturn(state);\n+    when(state.getCurrent_justified_checkpoint()).thenReturn(new Checkpoint(NODE_SLOT_VALUE, root));\n+\n+    assertThat(-1L).isEqualTo(metrics.getJustifiedRootValue());\n+    verify(state).getCurrent_justified_checkpoint();\n+  }\n+\n+  @Test\n+  void getJustifiedEpochValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+\n+    assertThat(0L).isEqualTo(metrics.getJustifiedEpochValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getJustifiedEpochValue_shouldSupplyValueWhenStoreIsPresent() {", "originalCommit": "cc15a2e5802a9c6b4bad1ed044c7be2bb2d8c172", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "58fb474994aad060b3cb840b070981479b26a459", "url": "https://github.com/ConsenSys/teku/commit/58fb474994aad060b3cb840b070981479b26a459", "message": "review feedback\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-04-20T01:11:11Z", "type": "commit"}]}