{"pr_number": 1132, "pr_title": "Implement DepositRequestManager", "pr_createdAt": "2020-02-04T01:56:38Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1132", "timeline": [{"oid": "023bd66f31714ec2bd21febcaa687841b28dc044", "url": "https://github.com/ConsenSys/teku/commit/023bd66f31714ec2bd21febcaa687841b28dc044", "message": "Implement DepositRequestManager", "committedDate": "2020-02-04T01:56:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MjUxNg==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r374442516", "bodyText": "This is going to result in a lot of outstanding requests when what we really want to do is coalesce the results (so if we receive 3 new block notifications while we're still retrieving the last batch, we should request all three blocks at once rather than handling them individually.", "author": "ajsutton", "createdAt": "2020-02-04T02:13:16Z", "path": "pow/src/main/java/tech/pegasys/artemis/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package tech.pegasys.artemis;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+import java.math.BigInteger;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+public class DepositRequestManager {\n+\n+  private final Web3j web3j;\n+  private final Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer;\n+  private final Map<String, SafeFuture<EthBlock.Block>> cachedBlocks = new ConcurrentHashMap<>();\n+\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+  private Disposable newBlockSubscription;\n+  private BiFunction<\n+          DefaultBlockParameter,\n+          DefaultBlockParameter,\n+          List<DepositContract.DepositEventEventResponse>> depositEventsInRangeFunction;\n+\n+  public DepositRequestManager(Web3j web3j,\n+                               Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer,\n+                               BiFunction<\n+                                       DefaultBlockParameter,\n+                                       DefaultBlockParameter,\n+                                       List<DepositContract.DepositEventEventResponse>> depositEventsInRangeFunction) {\n+    this.web3j = web3j;\n+    this.depositsFromBlockEventConsumer = depositsFromBlockEventConsumer;\n+    this.depositEventsInRangeFunction = depositEventsInRangeFunction;\n+  }\n+\n+  public void start() {\n+    newBlockSubscription = web3j\n+            .blockFlowable(false)\n+            .map(EthBlock::getBlock)\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::getLatestDeposits);", "originalCommit": "023bd66f31714ec2bd21febcaa687841b28dc044", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5MTIzNw==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r374991237", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-04T23:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MjUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MjgwNQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r374442805", "bodyText": "Requesting from block 0 would be fine, we don't need to translate this to EARLIEST. EARLIEST == genesis block == block 0.", "author": "ajsutton", "createdAt": "2020-02-04T02:14:39Z", "path": "pow/src/main/java/tech/pegasys/artemis/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package tech.pegasys.artemis;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+import java.math.BigInteger;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+public class DepositRequestManager {\n+\n+  private final Web3j web3j;\n+  private final Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer;\n+  private final Map<String, SafeFuture<EthBlock.Block>> cachedBlocks = new ConcurrentHashMap<>();\n+\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+  private Disposable newBlockSubscription;\n+  private BiFunction<\n+          DefaultBlockParameter,\n+          DefaultBlockParameter,\n+          List<DepositContract.DepositEventEventResponse>> depositEventsInRangeFunction;\n+\n+  public DepositRequestManager(Web3j web3j,\n+                               Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer,\n+                               BiFunction<\n+                                       DefaultBlockParameter,\n+                                       DefaultBlockParameter,\n+                                       List<DepositContract.DepositEventEventResponse>> depositEventsInRangeFunction) {\n+    this.web3j = web3j;\n+    this.depositsFromBlockEventConsumer = depositsFromBlockEventConsumer;\n+    this.depositEventsInRangeFunction = depositEventsInRangeFunction;\n+  }\n+\n+  public void start() {\n+    newBlockSubscription = web3j\n+            .blockFlowable(false)\n+            .map(EthBlock::getBlock)\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::getLatestDeposits);\n+  }\n+\n+  public void stop() {\n+    newBlockSubscription.dispose();\n+  }\n+\n+  private void getLatestDeposits(BigInteger latestCanonicalBlockNumber) {\n+    DefaultBlockParameter toBlock = DefaultBlockParameter.valueOf(latestCanonicalBlockNumber);\n+    DefaultBlockParameter fromBlock;\n+    if (latestSuccessfullyQueriedBlockNumber.equals(BigInteger.ZERO)) {\n+      fromBlock = DefaultBlockParameterName.EARLIEST;", "originalCommit": "023bd66f31714ec2bd21febcaa687841b28dc044", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAyNTU3Ng==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375025576", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-02-05T02:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MjgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0Mjk5MQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r374442991", "bodyText": "I'd suggest passing in the actual DepositContract here rather than a BiFunction.  You can still mock it but it makes the dependencies a lot clearer.", "author": "ajsutton", "createdAt": "2020-02-04T02:15:34Z", "path": "pow/src/main/java/tech/pegasys/artemis/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package tech.pegasys.artemis;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+import java.math.BigInteger;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+public class DepositRequestManager {\n+\n+  private final Web3j web3j;\n+  private final Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer;\n+  private final Map<String, SafeFuture<EthBlock.Block>> cachedBlocks = new ConcurrentHashMap<>();\n+\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+  private Disposable newBlockSubscription;\n+  private BiFunction<\n+          DefaultBlockParameter,\n+          DefaultBlockParameter,\n+          List<DepositContract.DepositEventEventResponse>> depositEventsInRangeFunction;\n+\n+  public DepositRequestManager(Web3j web3j,\n+                               Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer,\n+                               BiFunction<\n+                                       DefaultBlockParameter,\n+                                       DefaultBlockParameter,\n+                                       List<DepositContract.DepositEventEventResponse>> depositEventsInRangeFunction) {", "originalCommit": "023bd66f31714ec2bd21febcaa687841b28dc044", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5MzM2Mw==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r374993363", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-05T00:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0Mjk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MzI3Mg==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r374443272", "bodyText": "As you noted in chat, this will actually return a SafeFuture.  Should just result in the rest of the method being in a .thenApply call.", "author": "ajsutton", "createdAt": "2020-02-04T02:16:47Z", "path": "pow/src/main/java/tech/pegasys/artemis/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package tech.pegasys.artemis;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+import java.math.BigInteger;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+public class DepositRequestManager {\n+\n+  private final Web3j web3j;\n+  private final Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer;\n+  private final Map<String, SafeFuture<EthBlock.Block>> cachedBlocks = new ConcurrentHashMap<>();\n+\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+  private Disposable newBlockSubscription;\n+  private BiFunction<\n+          DefaultBlockParameter,\n+          DefaultBlockParameter,\n+          List<DepositContract.DepositEventEventResponse>> depositEventsInRangeFunction;\n+\n+  public DepositRequestManager(Web3j web3j,\n+                               Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer,\n+                               BiFunction<\n+                                       DefaultBlockParameter,\n+                                       DefaultBlockParameter,\n+                                       List<DepositContract.DepositEventEventResponse>> depositEventsInRangeFunction) {\n+    this.web3j = web3j;\n+    this.depositsFromBlockEventConsumer = depositsFromBlockEventConsumer;\n+    this.depositEventsInRangeFunction = depositEventsInRangeFunction;\n+  }\n+\n+  public void start() {\n+    newBlockSubscription = web3j\n+            .blockFlowable(false)\n+            .map(EthBlock::getBlock)\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::getLatestDeposits);\n+  }\n+\n+  public void stop() {\n+    newBlockSubscription.dispose();\n+  }\n+\n+  private void getLatestDeposits(BigInteger latestCanonicalBlockNumber) {\n+    DefaultBlockParameter toBlock = DefaultBlockParameter.valueOf(latestCanonicalBlockNumber);\n+    DefaultBlockParameter fromBlock;\n+    if (latestSuccessfullyQueriedBlockNumber.equals(BigInteger.ZERO)) {\n+      fromBlock = DefaultBlockParameterName.EARLIEST;\n+    } else {\n+      fromBlock = DefaultBlockParameter.valueOf(latestSuccessfullyQueriedBlockNumber);\n+    }\n+\n+    List<DepositContract.DepositEventEventResponse> events = depositEventsInRangeFunction.apply(fromBlock, toBlock);", "originalCommit": "023bd66f31714ec2bd21febcaa687841b28dc044", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5MzQwNA==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r374993404", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-05T00:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MzI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MzQ5Mg==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r374443492", "bodyText": "This probably should be finish as thenRun returns another SafeFuture.  And we probably should handle errors here explicitly - they likely just get logged and we retry but that's better than falling back to the default exception handler.", "author": "ajsutton", "createdAt": "2020-02-04T02:17:45Z", "path": "pow/src/main/java/tech/pegasys/artemis/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package tech.pegasys.artemis;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+import java.math.BigInteger;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+public class DepositRequestManager {\n+\n+  private final Web3j web3j;\n+  private final Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer;\n+  private final Map<String, SafeFuture<EthBlock.Block>> cachedBlocks = new ConcurrentHashMap<>();\n+\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+  private Disposable newBlockSubscription;\n+  private BiFunction<\n+          DefaultBlockParameter,\n+          DefaultBlockParameter,\n+          List<DepositContract.DepositEventEventResponse>> depositEventsInRangeFunction;\n+\n+  public DepositRequestManager(Web3j web3j,\n+                               Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer,\n+                               BiFunction<\n+                                       DefaultBlockParameter,\n+                                       DefaultBlockParameter,\n+                                       List<DepositContract.DepositEventEventResponse>> depositEventsInRangeFunction) {\n+    this.web3j = web3j;\n+    this.depositsFromBlockEventConsumer = depositsFromBlockEventConsumer;\n+    this.depositEventsInRangeFunction = depositEventsInRangeFunction;\n+  }\n+\n+  public void start() {\n+    newBlockSubscription = web3j\n+            .blockFlowable(false)\n+            .map(EthBlock::getBlock)\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::getLatestDeposits);\n+  }\n+\n+  public void stop() {\n+    newBlockSubscription.dispose();\n+  }\n+\n+  private void getLatestDeposits(BigInteger latestCanonicalBlockNumber) {\n+    DefaultBlockParameter toBlock = DefaultBlockParameter.valueOf(latestCanonicalBlockNumber);\n+    DefaultBlockParameter fromBlock;\n+    if (latestSuccessfullyQueriedBlockNumber.equals(BigInteger.ZERO)) {\n+      fromBlock = DefaultBlockParameterName.EARLIEST;\n+    } else {\n+      fromBlock = DefaultBlockParameter.valueOf(latestSuccessfullyQueriedBlockNumber);\n+    }\n+\n+    List<DepositContract.DepositEventEventResponse> events = depositEventsInRangeFunction.apply(fromBlock, toBlock);\n+\n+    List<SafeFuture<DepositsFromBlockEvent>> depositsFromEventFutures = events.stream()\n+            .collect(Collectors.groupingBy(event -> event.log.getBlockNumber(), TreeMap::new, Collectors.toList()))\n+            .values()\n+            .stream()\n+            .map(depositsEventResponseList -> {\n+              List<Deposit> depositsList = depositsEventResponseList.stream().map(Deposit::new).collect(Collectors.toList());\n+              return SafeFuture.of(web3j.ethGetBlockByHash(\n+                      depositsEventResponseList.get(0).log.getBlockHash(),\n+                      false\n+              )\n+                      .sendAsync()\n+                      .thenApply(EthBlock::getBlock)\n+                      .thenApply(block -> new DepositsFromBlockEvent(\n+                              UnsignedLong.valueOf(block.getNumber()),\n+                              Bytes32.fromHexString(block.getHash()),\n+                              UnsignedLong.valueOf(block.getTimestamp()),\n+                              depositsList)));\n+            }).collect(Collectors.toList());\n+\n+    SafeFuture.allOf(depositsFromEventFutures.toArray(SafeFuture[]::new))\n+            .thenRun(() -> depositsFromEventFutures\n+                    .stream()\n+                    .map(future -> checkNotNull(future.getNow(null)))\n+                    .sorted(Comparator.comparing(DepositsFromBlockEvent::getBlockNumber))\n+                    .forEachOrdered(this::publishDeposits))\n+            .thenRun(() -> latestSuccessfullyQueriedBlockNumber = latestCanonicalBlockNumber);", "originalCommit": "023bd66f31714ec2bd21febcaa687841b28dc044", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5NDI5Mw==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r374994293", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-05T00:06:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MzQ5Mg=="}], "type": "inlineReview"}, {"oid": "e7ff7ee10893fd69449961e0d8cde45f0e22d9c0", "url": "https://github.com/ConsenSys/teku/commit/e7ff7ee10893fd69449961e0d8cde45f0e22d9c0", "message": "Refactor and resolve comments", "committedDate": "2020-02-05T02:06:35Z", "type": "commit"}, {"oid": "21ac04cab84f6774cca5b80f3ecbb51f96cad148", "url": "https://github.com/ConsenSys/teku/commit/21ac04cab84f6774cca5b80f3ecbb51f96cad148", "message": "Merge branch 'master' into implementDepositRequestManager", "committedDate": "2020-02-05T02:07:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzOTY2OA==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375039668", "bodyText": "Probably should add a newBlockSubscription.dispose() prior to this line just for good measure.", "author": "ajsutton", "createdAt": "2020-02-05T03:12:31Z", "path": "pow/src/main/java/tech/pegasys/artemis/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class DepositRequestManager {\n+\n+  private final Web3j web3j;\n+  private final Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer;\n+  private final DepositContract depositContract;\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private boolean active = false;\n+  private boolean requestQueued = false;\n+  private BigInteger latestCanonicalBlockNumber;\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+  private Disposable newBlockSubscription;\n+\n+  public DepositRequestManager(\n+      Web3j web3j,\n+      Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer,\n+      DepositContract depositContract) {\n+    this.web3j = web3j;\n+    this.depositsFromBlockEventConsumer = depositsFromBlockEventConsumer;\n+    this.depositContract = depositContract;\n+  }\n+\n+  public void start() {\n+    newBlockSubscription =\n+        web3j\n+            .blockFlowable(false)\n+            .map(EthBlock::getBlock)\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(\n+                this::updateLatestCanonicalBlockNumber,\n+                err -> {\n+                  LOG.warn(\"New block subscription failed, retrying.\", err);\n+                  start();", "originalCommit": "21ac04cab84f6774cca5b80f3ecbb51f96cad148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2MzQwNA==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375363404", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-05T16:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzOTY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzOTgxOQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375039819", "bodyText": "This will need to be volatile as it's original assignment in start will be on a different thread to the error callback if we need to restart it (and possibly different to the thread used to call stop too).", "author": "ajsutton", "createdAt": "2020-02-05T03:13:20Z", "path": "pow/src/main/java/tech/pegasys/artemis/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class DepositRequestManager {\n+\n+  private final Web3j web3j;\n+  private final Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer;\n+  private final DepositContract depositContract;\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private boolean active = false;\n+  private boolean requestQueued = false;\n+  private BigInteger latestCanonicalBlockNumber;\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+  private Disposable newBlockSubscription;", "originalCommit": "21ac04cab84f6774cca5b80f3ecbb51f96cad148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2NzU4MQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375367581", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-05T16:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTAzOTgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA0MDA2Mw==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375040063", "bodyText": "I'd be tempted to extract this as an onDepositRequestSuccessful method.", "author": "ajsutton", "createdAt": "2020-02-05T03:14:30Z", "path": "pow/src/main/java/tech/pegasys/artemis/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class DepositRequestManager {\n+\n+  private final Web3j web3j;\n+  private final Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer;\n+  private final DepositContract depositContract;\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private boolean active = false;\n+  private boolean requestQueued = false;\n+  private BigInteger latestCanonicalBlockNumber;\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+  private Disposable newBlockSubscription;\n+\n+  public DepositRequestManager(\n+      Web3j web3j,\n+      Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer,\n+      DepositContract depositContract) {\n+    this.web3j = web3j;\n+    this.depositsFromBlockEventConsumer = depositsFromBlockEventConsumer;\n+    this.depositContract = depositContract;\n+  }\n+\n+  public void start() {\n+    newBlockSubscription =\n+        web3j\n+            .blockFlowable(false)\n+            .map(EthBlock::getBlock)\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(\n+                this::updateLatestCanonicalBlockNumber,\n+                err -> {\n+                  LOG.warn(\"New block subscription failed, retrying.\", err);\n+                  start();\n+                });\n+  }\n+\n+  public void stop() {\n+    newBlockSubscription.dispose();\n+  }\n+\n+  private synchronized void updateLatestCanonicalBlockNumber(\n+      BigInteger latestCanonicalBlockNumber) {\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    if (active) {\n+      requestQueued = true;\n+    } else {\n+      active = true;\n+      getLatestDeposits();\n+    }\n+  }\n+\n+  private void getLatestDeposits() {\n+    requestQueued = false;\n+\n+    DefaultBlockParameter fromBlock =\n+        DefaultBlockParameter.valueOf(latestSuccessfullyQueriedBlockNumber);\n+    final BigInteger latestCanonicalBlockNumberAtRequestStart = this.latestCanonicalBlockNumber;\n+    DefaultBlockParameter toBlock =\n+        DefaultBlockParameter.valueOf(latestCanonicalBlockNumberAtRequestStart);\n+\n+    LOG.trace(\n+        \"Attempting to fetch deposit events for block numbers in the range ({}, {})\",\n+        latestSuccessfullyQueriedBlockNumber,\n+        latestCanonicalBlockNumberAtRequestStart);\n+\n+    fetchAndPublishDepositEventsInBlockRange(fromBlock, toBlock)\n+        .finish(\n+            () -> {\n+              this.latestSuccessfullyQueriedBlockNumber = latestCanonicalBlockNumberAtRequestStart;\n+              synchronized (DepositRequestManager.this) {\n+                active = false;\n+                if (requestQueued) {\n+                  getLatestDeposits();\n+                }\n+              }", "originalCommit": "21ac04cab84f6774cca5b80f3ecbb51f96cad148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2OTA0NQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375369045", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-05T16:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA0MDA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA0MDExNw==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375040117", "bodyText": "And extract this as onDepositRequestFailed.", "author": "ajsutton", "createdAt": "2020-02-05T03:14:45Z", "path": "pow/src/main/java/tech/pegasys/artemis/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class DepositRequestManager {\n+\n+  private final Web3j web3j;\n+  private final Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer;\n+  private final DepositContract depositContract;\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private boolean active = false;\n+  private boolean requestQueued = false;\n+  private BigInteger latestCanonicalBlockNumber;\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+  private Disposable newBlockSubscription;\n+\n+  public DepositRequestManager(\n+      Web3j web3j,\n+      Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer,\n+      DepositContract depositContract) {\n+    this.web3j = web3j;\n+    this.depositsFromBlockEventConsumer = depositsFromBlockEventConsumer;\n+    this.depositContract = depositContract;\n+  }\n+\n+  public void start() {\n+    newBlockSubscription =\n+        web3j\n+            .blockFlowable(false)\n+            .map(EthBlock::getBlock)\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(\n+                this::updateLatestCanonicalBlockNumber,\n+                err -> {\n+                  LOG.warn(\"New block subscription failed, retrying.\", err);\n+                  start();\n+                });\n+  }\n+\n+  public void stop() {\n+    newBlockSubscription.dispose();\n+  }\n+\n+  private synchronized void updateLatestCanonicalBlockNumber(\n+      BigInteger latestCanonicalBlockNumber) {\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    if (active) {\n+      requestQueued = true;\n+    } else {\n+      active = true;\n+      getLatestDeposits();\n+    }\n+  }\n+\n+  private void getLatestDeposits() {\n+    requestQueued = false;\n+\n+    DefaultBlockParameter fromBlock =\n+        DefaultBlockParameter.valueOf(latestSuccessfullyQueriedBlockNumber);\n+    final BigInteger latestCanonicalBlockNumberAtRequestStart = this.latestCanonicalBlockNumber;\n+    DefaultBlockParameter toBlock =\n+        DefaultBlockParameter.valueOf(latestCanonicalBlockNumberAtRequestStart);\n+\n+    LOG.trace(\n+        \"Attempting to fetch deposit events for block numbers in the range ({}, {})\",\n+        latestSuccessfullyQueriedBlockNumber,\n+        latestCanonicalBlockNumberAtRequestStart);\n+\n+    fetchAndPublishDepositEventsInBlockRange(fromBlock, toBlock)\n+        .finish(\n+            () -> {\n+              this.latestSuccessfullyQueriedBlockNumber = latestCanonicalBlockNumberAtRequestStart;\n+              synchronized (DepositRequestManager.this) {\n+                active = false;\n+                if (requestQueued) {\n+                  getLatestDeposits();\n+                }\n+              }\n+            },\n+            (err) -> {\n+              LOG.warn(\n+                  \"Failed to fetch deposit events for block numbers in the range ({},{}): {}\",\n+                  latestSuccessfullyQueriedBlockNumber,\n+                  latestCanonicalBlockNumberAtRequestStart,\n+                  err);\n+              // TODO: add delayed processing\n+              getLatestDeposits();", "originalCommit": "21ac04cab84f6774cca5b80f3ecbb51f96cad148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2OTkzMw==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375369933", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-05T16:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA0MDExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA0MTYzOA==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375041638", "bodyText": "It would actually be easier to work with the data if this return a map of block hash to list of deposit responses (ie Map<String, List<DepositContract.DepositEventEventResponse>>.  Currently it's grouping by number - in the absence of forks that gives the same result as grouping by block hash (it's arguably more correct anyway, but we definitely don't have forks in the responses to a call to eth_getLogs).\nThen in getMapOfEthBlockFutures you can just iterate the keySet() to get the block details for each hash and in constructDepositsFromBlockEvents use the entrySet() so you have both the block hash and list of deposits.  That way you can avoid the need to call groupOfSameBlockDeposits.get(0).log.getBlockHash() to get the relevant block hash.", "author": "ajsutton", "createdAt": "2020-02-05T03:22:13Z", "path": "pow/src/main/java/tech/pegasys/artemis/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class DepositRequestManager {\n+\n+  private final Web3j web3j;\n+  private final Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer;\n+  private final DepositContract depositContract;\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private boolean active = false;\n+  private boolean requestQueued = false;\n+  private BigInteger latestCanonicalBlockNumber;\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+  private Disposable newBlockSubscription;\n+\n+  public DepositRequestManager(\n+      Web3j web3j,\n+      Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer,\n+      DepositContract depositContract) {\n+    this.web3j = web3j;\n+    this.depositsFromBlockEventConsumer = depositsFromBlockEventConsumer;\n+    this.depositContract = depositContract;\n+  }\n+\n+  public void start() {\n+    newBlockSubscription =\n+        web3j\n+            .blockFlowable(false)\n+            .map(EthBlock::getBlock)\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(\n+                this::updateLatestCanonicalBlockNumber,\n+                err -> {\n+                  LOG.warn(\"New block subscription failed, retrying.\", err);\n+                  start();\n+                });\n+  }\n+\n+  public void stop() {\n+    newBlockSubscription.dispose();\n+  }\n+\n+  private synchronized void updateLatestCanonicalBlockNumber(\n+      BigInteger latestCanonicalBlockNumber) {\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    if (active) {\n+      requestQueued = true;\n+    } else {\n+      active = true;\n+      getLatestDeposits();\n+    }\n+  }\n+\n+  private void getLatestDeposits() {\n+    requestQueued = false;\n+\n+    DefaultBlockParameter fromBlock =\n+        DefaultBlockParameter.valueOf(latestSuccessfullyQueriedBlockNumber);\n+    final BigInteger latestCanonicalBlockNumberAtRequestStart = this.latestCanonicalBlockNumber;\n+    DefaultBlockParameter toBlock =\n+        DefaultBlockParameter.valueOf(latestCanonicalBlockNumberAtRequestStart);\n+\n+    LOG.trace(\n+        \"Attempting to fetch deposit events for block numbers in the range ({}, {})\",\n+        latestSuccessfullyQueriedBlockNumber,\n+        latestCanonicalBlockNumberAtRequestStart);\n+\n+    fetchAndPublishDepositEventsInBlockRange(fromBlock, toBlock)\n+        .finish(\n+            () -> {\n+              this.latestSuccessfullyQueriedBlockNumber = latestCanonicalBlockNumberAtRequestStart;\n+              synchronized (DepositRequestManager.this) {\n+                active = false;\n+                if (requestQueued) {\n+                  getLatestDeposits();\n+                }\n+              }\n+            },\n+            (err) -> {\n+              LOG.warn(\n+                  \"Failed to fetch deposit events for block numbers in the range ({},{}): {}\",\n+                  latestSuccessfullyQueriedBlockNumber,\n+                  latestCanonicalBlockNumberAtRequestStart,\n+                  err);\n+              // TODO: add delayed processing\n+              getLatestDeposits();\n+            });\n+  }\n+\n+  private SafeFuture<Void> fetchAndPublishDepositEventsInBlockRange(\n+      DefaultBlockParameter fromBlock, DefaultBlockParameter toBlock) {\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> eventsFuture =\n+        depositContract.depositEventEventsInRange(fromBlock, toBlock);\n+\n+    return eventsFuture\n+        .thenApply(this::groupDepositEventResponsesByBlockNumber)\n+        .thenCompose(\n+            groupedDepositEventResponses -> {\n+              Map<String, SafeFuture<EthBlock.Block>> neededBlocksByHash =\n+                  getMapOfEthBlockFutures(groupedDepositEventResponses);\n+              return SafeFuture.allOf(neededBlocksByHash.values().toArray(SafeFuture[]::new))\n+                  .thenApply(\n+                      done ->\n+                          constructDepositsFromBlockEvents(\n+                              neededBlocksByHash, groupedDepositEventResponses));\n+            })\n+        .thenAccept(\n+            (depositsFromBlockEventList) ->\n+                depositsFromBlockEventList.stream()\n+                    .sorted(Comparator.comparing(DepositsFromBlockEvent::getBlockNumber))\n+                    .forEachOrdered(this::publishDeposits));\n+  }\n+\n+  private List<DepositsFromBlockEvent> constructDepositsFromBlockEvents(\n+      Map<String, SafeFuture<EthBlock.Block>> blockFutureByBlockHash,\n+      List<List<DepositContract.DepositEventEventResponse>> groupedDepositEventResponses) {\n+    return groupedDepositEventResponses.stream()\n+        .map(\n+            groupedDepositEventResponse -> {\n+              String blockHash = groupedDepositEventResponse.get(0).log.getBlockHash();\n+              EthBlock.Block block =\n+                  checkNotNull(blockFutureByBlockHash.get(blockHash).getNow(null));\n+              return new DepositsFromBlockEvent(\n+                  UnsignedLong.valueOf(block.getNumber()),\n+                  Bytes32.fromHexString(block.getHash()),\n+                  UnsignedLong.valueOf(block.getTimestamp()),\n+                  groupedDepositEventResponse.stream()\n+                      .map(Deposit::new)\n+                      .collect(Collectors.toList()));\n+            })\n+        .collect(Collectors.toList());\n+  }\n+\n+  private Map<String, SafeFuture<EthBlock.Block>> getMapOfEthBlockFutures(\n+      List<List<DepositContract.DepositEventEventResponse>> groupedDepositEventResponses) {\n+    return groupedDepositEventResponses.stream()\n+        .map(groupOfSameBlockDeposits -> groupOfSameBlockDeposits.get(0).log.getBlockHash())\n+        .collect(Collectors.toUnmodifiableMap(k -> k, this::getEthBlockFuture));\n+  }\n+\n+  // TODO: pass in web3j as an argument and share this code with Eth1DataManager to avoid\n+  // duplication\n+  private SafeFuture<EthBlock.Block> getEthBlockFuture(String blockHash) {\n+    return SafeFuture.of(web3j.ethGetBlockByHash(blockHash, false).sendAsync())\n+        .thenApply(EthBlock::getBlock);\n+  }\n+\n+  private List<List<DepositContract.DepositEventEventResponse>>\n+      groupDepositEventResponsesByBlockNumber(\n+          List<DepositContract.DepositEventEventResponse> events) {\n+    return new ArrayList<>(\n+        events.stream()\n+            .collect(\n+                Collectors.groupingBy(\n+                    event -> event.log.getBlockNumber(), TreeMap::new, Collectors.toList()))\n+            .values());\n+  }", "originalCommit": "21ac04cab84f6774cca5b80f3ecbb51f96cad148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM4MzI1NQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375383255", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-05T16:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA0MTYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA0MjMxMw==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375042313", "bodyText": "I think when this gets integrated this can just be DepositEventChannel.  It's still a nice simple interface to mock but also gives a clearer method call.\nBatchByBlockDepositHandler wound up using a Consumer because it was originally written when events were published through the EventBus. In hindsight, I was probably still overthinking it and could have just mocked EventBus easily enough.", "author": "ajsutton", "createdAt": "2020-02-05T03:25:52Z", "path": "pow/src/main/java/tech/pegasys/artemis/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class DepositRequestManager {\n+\n+  private final Web3j web3j;\n+  private final Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer;\n+  private final DepositContract depositContract;\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private boolean active = false;\n+  private boolean requestQueued = false;\n+  private BigInteger latestCanonicalBlockNumber;\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+  private Disposable newBlockSubscription;\n+\n+  public DepositRequestManager(\n+      Web3j web3j,\n+      Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer,", "originalCommit": "21ac04cab84f6774cca5b80f3ecbb51f96cad148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5OTM5MA==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375399390", "bodyText": "Done. Thank you for the explanation.", "author": "cemozerr", "createdAt": "2020-02-05T17:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA0MjMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA0MjQyNQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375042425", "bodyText": "This needs to be in a synchronized (this) block.", "author": "ajsutton", "createdAt": "2020-02-05T03:26:27Z", "path": "pow/src/main/java/tech/pegasys/artemis/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class DepositRequestManager {\n+\n+  private final Web3j web3j;\n+  private final Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer;\n+  private final DepositContract depositContract;\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private boolean active = false;\n+  private boolean requestQueued = false;\n+  private BigInteger latestCanonicalBlockNumber;\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+  private Disposable newBlockSubscription;\n+\n+  public DepositRequestManager(\n+      Web3j web3j,\n+      Consumer<DepositsFromBlockEvent> depositsFromBlockEventConsumer,\n+      DepositContract depositContract) {\n+    this.web3j = web3j;\n+    this.depositsFromBlockEventConsumer = depositsFromBlockEventConsumer;\n+    this.depositContract = depositContract;\n+  }\n+\n+  public void start() {\n+    newBlockSubscription =\n+        web3j\n+            .blockFlowable(false)\n+            .map(EthBlock::getBlock)\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(\n+                this::updateLatestCanonicalBlockNumber,\n+                err -> {\n+                  LOG.warn(\"New block subscription failed, retrying.\", err);\n+                  start();\n+                });\n+  }\n+\n+  public void stop() {\n+    newBlockSubscription.dispose();\n+  }\n+\n+  private synchronized void updateLatestCanonicalBlockNumber(\n+      BigInteger latestCanonicalBlockNumber) {\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    if (active) {\n+      requestQueued = true;\n+    } else {\n+      active = true;\n+      getLatestDeposits();\n+    }\n+  }\n+\n+  private void getLatestDeposits() {\n+    requestQueued = false;", "originalCommit": "21ac04cab84f6774cca5b80f3ecbb51f96cad148", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5NjMwMQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375396301", "bodyText": "getLatestDeposits is only called inside two synchronized blocks, doesn't that make sure we this whole method is executed by only one thread at a time anyway?", "author": "cemozerr", "createdAt": "2020-02-05T17:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA0MjQyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5NzMyNQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375397325", "bodyText": "actually nevermind, its also called from onDepositRequestFailed, which is not synchronized, is that the reason we need the synchronized(this) block here? and also why not use the volatile keyword instead?", "author": "cemozerr", "createdAt": "2020-02-05T17:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA0MjQyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5NzUzOQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375397539", "bodyText": "Done, but would appreciate your explanation", "author": "cemozerr", "createdAt": "2020-02-05T17:23:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA0MjQyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2NzM1OQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375467359", "bodyText": "We can't use volatile because active and requestQueued need to be changed in-sync - particularly the if (active) requestQueued = true on lines 84-85 need to be an atomic block but can't be if a different thread changes requestQueued without acquiring the same lock via synchronised.\nIf getLatestDeposits was only called from within synchronised blocks then this wouldn't be required.", "author": "ajsutton", "createdAt": "2020-02-05T19:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA0MjQyNQ=="}], "type": "inlineReview"}, {"oid": "41a11b2d191013b2af9fbee8cf51b5d839dcb2db", "url": "https://github.com/ConsenSys/teku/commit/41a11b2d191013b2af9fbee8cf51b5d839dcb2db", "message": "Merge branch 'master' into implementDepositRequestManager", "committedDate": "2020-02-05T17:28:14Z", "type": "commit"}, {"oid": "a8c5a72036e0010214a750e8b23353cdabfc480a", "url": "https://github.com/ConsenSys/teku/commit/a8c5a72036e0010214a750e8b23353cdabfc480a", "message": "Resolve comments and run retry with delay", "committedDate": "2020-02-05T21:10:53Z", "type": "commit"}, {"oid": "b62aecc8a6165817bc4ed621a674afe86b71555b", "url": "https://github.com/ConsenSys/teku/commit/b62aecc8a6165817bc4ed621a674afe86b71555b", "message": "Fix possible concurrency issues and refactor Eth1Provider out", "committedDate": "2020-02-05T22:36:53Z", "type": "commit"}, {"oid": "19d0233f92f6acd1b2fd713d9c5f04c3251499f8", "url": "https://github.com/ConsenSys/teku/commit/19d0233f92f6acd1b2fd713d9c5f04c3251499f8", "message": "Integrate DepositRequestManager and remove redundant code", "committedDate": "2020-02-06T00:39:03Z", "type": "commit"}, {"oid": "7bd76a7fb692c8f7364f649431c75f2f516ddcc4", "url": "https://github.com/ConsenSys/teku/commit/7bd76a7fb692c8f7364f649431c75f2f516ddcc4", "message": "Fix test warning for now", "committedDate": "2020-02-06T00:43:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwODA4MQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375608081", "bodyText": "nit: Because we return in the true case this doesn't need to be inside an else block.", "author": "ajsutton", "createdAt": "2020-02-06T02:07:28Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.DepositEventChannel;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositRequestManager {\n+\n+  private final Eth1Provider eth1Provider;\n+  private final DepositEventChannel depositEventChannel;\n+  private final DepositContract depositContract;\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable newBlockSubscription;\n+  private boolean active = false;\n+  private boolean requestQueued = false;\n+  private BigInteger latestCanonicalBlockNumber;\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+\n+  public DepositRequestManager(\n+      Eth1Provider eth1Provider,\n+      AsyncRunner asyncRunner,\n+      DepositEventChannel depositEventChannel,\n+      DepositContract depositContract) {\n+    this.eth1Provider = eth1Provider;\n+    this.asyncRunner = asyncRunner;\n+    this.depositEventChannel = depositEventChannel;\n+    this.depositContract = depositContract;\n+  }\n+\n+  public void start() {\n+    newBlockSubscription =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::updateLatestCanonicalBlockNumber, this::onSubscriptionFailed);\n+  }\n+\n+  private void onSubscriptionFailed(Throwable err) {\n+    Disposable subscription = newBlockSubscription;\n+    if (subscription != null) {\n+      subscription.dispose();\n+    }\n+    LOG.warn(\"New block subscription failed, retrying.\", err);\n+    start();\n+  }\n+\n+  public void stop() {\n+    newBlockSubscription.dispose();\n+  }\n+\n+  private synchronized void updateLatestCanonicalBlockNumber(\n+      BigInteger latestCanonicalBlockNumber) {\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    getLatestDeposits();\n+  }\n+\n+  private void getLatestDeposits() {\n+    final BigInteger latestCanonicalBlockNumberAtRequestStart;\n+    final BigInteger latestSuccessfullyQueriedBlockNumberAtRequestStart;\n+    synchronized (DepositRequestManager.this) {\n+      if (active) {\n+        requestQueued = true;\n+        return;\n+      } else {\n+        active = true;\n+        requestQueued = false;\n+      }", "originalCommit": "7bd76a7fb692c8f7364f649431c75f2f516ddcc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyMjA4Mw==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375622083", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-06T03:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwODA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwODc3MA==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375608770", "bodyText": "It occurs to me that we can remove the requestQueued variable and just use if (latestCanonicalBlockNumber.compareTo(latestSuccessfullyQueriedBlockNumber) > 0) here. The places where we set requestQueued can just be removed.\nBasically, if we haven't reached the latest canonical block, we need another request.", "author": "ajsutton", "createdAt": "2020-02-06T02:10:33Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.DepositEventChannel;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositRequestManager {\n+\n+  private final Eth1Provider eth1Provider;\n+  private final DepositEventChannel depositEventChannel;\n+  private final DepositContract depositContract;\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable newBlockSubscription;\n+  private boolean active = false;\n+  private boolean requestQueued = false;\n+  private BigInteger latestCanonicalBlockNumber;\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+\n+  public DepositRequestManager(\n+      Eth1Provider eth1Provider,\n+      AsyncRunner asyncRunner,\n+      DepositEventChannel depositEventChannel,\n+      DepositContract depositContract) {\n+    this.eth1Provider = eth1Provider;\n+    this.asyncRunner = asyncRunner;\n+    this.depositEventChannel = depositEventChannel;\n+    this.depositContract = depositContract;\n+  }\n+\n+  public void start() {\n+    newBlockSubscription =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::updateLatestCanonicalBlockNumber, this::onSubscriptionFailed);\n+  }\n+\n+  private void onSubscriptionFailed(Throwable err) {\n+    Disposable subscription = newBlockSubscription;\n+    if (subscription != null) {\n+      subscription.dispose();\n+    }\n+    LOG.warn(\"New block subscription failed, retrying.\", err);\n+    start();\n+  }\n+\n+  public void stop() {\n+    newBlockSubscription.dispose();\n+  }\n+\n+  private synchronized void updateLatestCanonicalBlockNumber(\n+      BigInteger latestCanonicalBlockNumber) {\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    getLatestDeposits();\n+  }\n+\n+  private void getLatestDeposits() {\n+    final BigInteger latestCanonicalBlockNumberAtRequestStart;\n+    final BigInteger latestSuccessfullyQueriedBlockNumberAtRequestStart;\n+    synchronized (DepositRequestManager.this) {\n+      if (active) {\n+        requestQueued = true;\n+        return;\n+      } else {\n+        active = true;\n+        requestQueued = false;\n+      }\n+\n+      latestCanonicalBlockNumberAtRequestStart = this.latestCanonicalBlockNumber;\n+      latestSuccessfullyQueriedBlockNumberAtRequestStart =\n+          this.latestSuccessfullyQueriedBlockNumber;\n+    }\n+\n+    LOG.trace(\n+        \"Attempting to fetch deposit events for block numbers in the range ({}, {})\",\n+        latestSuccessfullyQueriedBlockNumberAtRequestStart,\n+        latestCanonicalBlockNumberAtRequestStart);\n+\n+    DefaultBlockParameter fromBlock =\n+        DefaultBlockParameter.valueOf(latestSuccessfullyQueriedBlockNumberAtRequestStart);\n+    DefaultBlockParameter toBlock =\n+        DefaultBlockParameter.valueOf(latestCanonicalBlockNumberAtRequestStart);\n+\n+    fetchAndPublishDepositEventsInBlockRange(fromBlock, toBlock)\n+        .finish(\n+            () -> onDepositRequestSuccessful(latestCanonicalBlockNumberAtRequestStart),\n+            (err) -> onDepositRequestFailed(err, latestCanonicalBlockNumberAtRequestStart));\n+  }\n+\n+  private synchronized void onDepositRequestSuccessful(\n+      BigInteger latestCanonicalBlockNumberAtRequestStart) {\n+    this.latestSuccessfullyQueriedBlockNumber = latestCanonicalBlockNumberAtRequestStart;\n+    active = false;\n+    if (requestQueued) {\n+      getLatestDeposits();\n+    }", "originalCommit": "7bd76a7fb692c8f7364f649431c75f2f516ddcc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyMTQzNA==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375621434", "bodyText": "That seems like a no brainer now in hindsight. Thanks for the detailed review.", "author": "cemozerr", "createdAt": "2020-02-06T03:10:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwODc3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyMjA1OA==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375622058", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-06T03:14:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwODc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwOTM4Nw==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375609387", "bodyText": "really small nit: I'd probably use static imports for all the methods in Collectors just for brevity.", "author": "ajsutton", "createdAt": "2020-02-06T02:13:39Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositRequestManager.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.DepositEventChannel;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.Deposit;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositRequestManager {\n+\n+  private final Eth1Provider eth1Provider;\n+  private final DepositEventChannel depositEventChannel;\n+  private final DepositContract depositContract;\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable newBlockSubscription;\n+  private boolean active = false;\n+  private boolean requestQueued = false;\n+  private BigInteger latestCanonicalBlockNumber;\n+  private BigInteger latestSuccessfullyQueriedBlockNumber = BigInteger.ZERO;\n+\n+  public DepositRequestManager(\n+      Eth1Provider eth1Provider,\n+      AsyncRunner asyncRunner,\n+      DepositEventChannel depositEventChannel,\n+      DepositContract depositContract) {\n+    this.eth1Provider = eth1Provider;\n+    this.asyncRunner = asyncRunner;\n+    this.depositEventChannel = depositEventChannel;\n+    this.depositContract = depositContract;\n+  }\n+\n+  public void start() {\n+    newBlockSubscription =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .subscribe(this::updateLatestCanonicalBlockNumber, this::onSubscriptionFailed);\n+  }\n+\n+  private void onSubscriptionFailed(Throwable err) {\n+    Disposable subscription = newBlockSubscription;\n+    if (subscription != null) {\n+      subscription.dispose();\n+    }\n+    LOG.warn(\"New block subscription failed, retrying.\", err);\n+    start();\n+  }\n+\n+  public void stop() {\n+    newBlockSubscription.dispose();\n+  }\n+\n+  private synchronized void updateLatestCanonicalBlockNumber(\n+      BigInteger latestCanonicalBlockNumber) {\n+    this.latestCanonicalBlockNumber = latestCanonicalBlockNumber;\n+    getLatestDeposits();\n+  }\n+\n+  private void getLatestDeposits() {\n+    final BigInteger latestCanonicalBlockNumberAtRequestStart;\n+    final BigInteger latestSuccessfullyQueriedBlockNumberAtRequestStart;\n+    synchronized (DepositRequestManager.this) {\n+      if (active) {\n+        requestQueued = true;\n+        return;\n+      } else {\n+        active = true;\n+        requestQueued = false;\n+      }\n+\n+      latestCanonicalBlockNumberAtRequestStart = this.latestCanonicalBlockNumber;\n+      latestSuccessfullyQueriedBlockNumberAtRequestStart =\n+          this.latestSuccessfullyQueriedBlockNumber;\n+    }\n+\n+    LOG.trace(\n+        \"Attempting to fetch deposit events for block numbers in the range ({}, {})\",\n+        latestSuccessfullyQueriedBlockNumberAtRequestStart,\n+        latestCanonicalBlockNumberAtRequestStart);\n+\n+    DefaultBlockParameter fromBlock =\n+        DefaultBlockParameter.valueOf(latestSuccessfullyQueriedBlockNumberAtRequestStart);\n+    DefaultBlockParameter toBlock =\n+        DefaultBlockParameter.valueOf(latestCanonicalBlockNumberAtRequestStart);\n+\n+    fetchAndPublishDepositEventsInBlockRange(fromBlock, toBlock)\n+        .finish(\n+            () -> onDepositRequestSuccessful(latestCanonicalBlockNumberAtRequestStart),\n+            (err) -> onDepositRequestFailed(err, latestCanonicalBlockNumberAtRequestStart));\n+  }\n+\n+  private synchronized void onDepositRequestSuccessful(\n+      BigInteger latestCanonicalBlockNumberAtRequestStart) {\n+    this.latestSuccessfullyQueriedBlockNumber = latestCanonicalBlockNumberAtRequestStart;\n+    active = false;\n+    if (requestQueued) {\n+      getLatestDeposits();\n+    }\n+  }\n+\n+  private void onDepositRequestFailed(\n+      Throwable err, BigInteger latestCanonicalBlockNumberAtRequestStart) {\n+    LOG.warn(\n+        \"Failed to fetch deposit events for block numbers in the range ({},{}): {}\",\n+        latestSuccessfullyQueriedBlockNumber,\n+        latestCanonicalBlockNumberAtRequestStart,\n+        err);\n+\n+    asyncRunner\n+        .getDelayedFuture(Constants.ETH1_DEPOSIT_REQUEST_RETRY_TIMEOUT, TimeUnit.SECONDS)\n+        .finish(\n+            this::getLatestDeposits,\n+            (error) -> LOG.warn(\"Unable to execute delayed request. Dropping request\", error));\n+  }\n+\n+  private SafeFuture<Void> fetchAndPublishDepositEventsInBlockRange(\n+      DefaultBlockParameter fromBlock, DefaultBlockParameter toBlock) {\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> eventsFuture =\n+        depositContract.depositEventEventsInRange(fromBlock, toBlock);\n+\n+    return eventsFuture\n+        .thenApply(this::groupDepositEventResponsesByBlockHash)\n+        .thenCompose(\n+            groupedDepositEventResponsesByBlockHash -> {\n+              Map<String, SafeFuture<EthBlock.Block>> neededBlocksByHash =\n+                  getMapOfEthBlockFutures(groupedDepositEventResponsesByBlockHash.keySet());\n+              return SafeFuture.allOf(neededBlocksByHash.values().toArray(SafeFuture[]::new))\n+                  .thenApply(\n+                      done ->\n+                          constructDepositsFromBlockEvents(\n+                              neededBlocksByHash, groupedDepositEventResponsesByBlockHash));\n+            })\n+        .thenAccept(\n+            (depositsFromBlockEventList) ->\n+                depositsFromBlockEventList.stream()\n+                    .sorted(Comparator.comparing(DepositsFromBlockEvent::getBlockNumber))\n+                    .forEachOrdered(this::publishDeposits));\n+  }\n+\n+  private List<DepositsFromBlockEvent> constructDepositsFromBlockEvents(\n+      Map<String, SafeFuture<EthBlock.Block>> blockFutureByBlockHash,\n+      Map<String, List<DepositContract.DepositEventEventResponse>> groupedDepositEventResponses) {\n+    return groupedDepositEventResponses.entrySet().stream()\n+        .map(\n+            (entry) -> {\n+              String blockHash = entry.getKey();\n+              List<DepositContract.DepositEventEventResponse> groupedDepositEventResponse =\n+                  entry.getValue();\n+              EthBlock.Block block =\n+                  checkNotNull(blockFutureByBlockHash.get(blockHash).getNow(null));\n+\n+              return new DepositsFromBlockEvent(\n+                  UnsignedLong.valueOf(block.getNumber()),\n+                  Bytes32.fromHexString(block.getHash()),\n+                  UnsignedLong.valueOf(block.getTimestamp()),\n+                  groupedDepositEventResponse.stream()\n+                      .map(Deposit::new)\n+                      .sorted(Comparator.comparing(Deposit::getMerkle_tree_index))\n+                      .collect(Collectors.toList()));\n+            })\n+        .collect(Collectors.toList());\n+  }\n+\n+  private Map<String, SafeFuture<EthBlock.Block>> getMapOfEthBlockFutures(\n+      Set<String> neededBlockHashes) {\n+    return neededBlockHashes.stream()\n+        .collect(\n+            Collectors.toUnmodifiableMap(blockHash -> blockHash, eth1Provider::getEth1BlockFuture));", "originalCommit": "7bd76a7fb692c8f7364f649431c75f2f516ddcc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYyMDc4OQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r375620789", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-02-06T03:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwOTM4Nw=="}], "type": "inlineReview"}, {"oid": "eb4354aaca85f1da3dd431d556fcc8993b42f1f7", "url": "https://github.com/ConsenSys/teku/commit/eb4354aaca85f1da3dd431d556fcc8993b42f1f7", "message": "Use static imports for brevity", "committedDate": "2020-02-06T03:07:50Z", "type": "commit"}, {"oid": "de7c7eda1884dccbe3262c3c58cd39623dcb04ee", "url": "https://github.com/ConsenSys/teku/commit/de7c7eda1884dccbe3262c3c58cd39623dcb04ee", "message": "Remove unnecessary variable", "committedDate": "2020-02-06T03:14:07Z", "type": "commit"}, {"oid": "489bdaf03265714eed680adb767d0bc639a83acd", "url": "https://github.com/ConsenSys/teku/commit/489bdaf03265714eed680adb767d0bc639a83acd", "message": "Implement the tests", "committedDate": "2020-02-06T21:01:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA4OTI1Mg==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r376089252", "bodyText": "We really shouldn't need to spy the class under test - that suggests the test is dependent on the implementation details of the class instead of it's external behaviour.", "author": "ajsutton", "createdAt": "2020-02-06T21:22:59Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/DepositRequestManagerTest.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.atLeast;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.Longs;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.Flowable;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import org.web3j.protocol.core.methods.response.Log;\n+import org.web3j.utils.Numeric;\n+import tech.pegasys.artemis.pow.api.DepositEventChannel;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.async.StubAsyncRunner;\n+\n+public class DepositRequestManagerTest {\n+\n+  private Eth1Provider eth1Provider;\n+  private DepositEventChannel depositEventChannel;\n+  private DepositContract depositContract;\n+  private AsyncRunner asyncRunner;\n+\n+  private DepositRequestManager depositRequestManager;\n+\n+  @BeforeEach\n+  void setUp() {\n+    eth1Provider = mock(Eth1Provider.class);\n+    depositEventChannel = mock(DepositEventChannel.class);\n+    depositContract = mock(DepositContract.class);\n+    asyncRunner = new StubAsyncRunner();\n+\n+    depositRequestManager =\n+        spy(", "originalCommit": "489bdaf03265714eed680adb767d0bc639a83acd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3ODM2OA==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r376178368", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-02-07T01:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA4OTI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5OTQ2MA==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r376099460", "bodyText": "We want to look for the side effects here, not the call within depositRequestManager.  And it would be better if there was an explicit reason for failure rather than just depending on hitting a random NullPointerException later in the chain because a mock isn't fully set up.  So:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Test\n          \n          \n            \n              void restartOnSubscriptionFailure() {\n          \n          \n            \n                mockLatestCanonicalBlockNumber(1);\n          \n          \n            \n                depositRequestManager.start();\n          \n          \n            \n                verify(depositRequestManager, atLeast(2)).start();\n          \n          \n            \n              }\n          \n          \n            \n            @Test\n          \n          \n            \n              void restartOnSubscriptionFailure() {\n          \n          \n            \n                when(eth1Provider.getLatestBlockFlowable())\n          \n          \n            \n                    .thenReturn(Flowable.error(new IOException(\"Node is down\")));\n          \n          \n            \n                depositRequestManager.start();\n          \n          \n            \n                verify(eth1Provider, atLeast(2)).getLatestBlockFlowable();\n          \n          \n            \n              }\n          \n      \n    \n    \n  \n\nWhich exposes an interesting bug because it winds up hitting a StackOverflowException.  We probably need a delay before retrying. :)", "author": "ajsutton", "createdAt": "2020-02-06T21:45:27Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/DepositRequestManagerTest.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.atLeast;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.Longs;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.Flowable;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import org.web3j.protocol.core.methods.response.Log;\n+import org.web3j.utils.Numeric;\n+import tech.pegasys.artemis.pow.api.DepositEventChannel;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.async.StubAsyncRunner;\n+\n+public class DepositRequestManagerTest {\n+\n+  private Eth1Provider eth1Provider;\n+  private DepositEventChannel depositEventChannel;\n+  private DepositContract depositContract;\n+  private AsyncRunner asyncRunner;\n+\n+  private DepositRequestManager depositRequestManager;\n+\n+  @BeforeEach\n+  void setUp() {\n+    eth1Provider = mock(Eth1Provider.class);\n+    depositEventChannel = mock(DepositEventChannel.class);\n+    depositContract = mock(DepositContract.class);\n+    asyncRunner = new StubAsyncRunner();\n+\n+    depositRequestManager =\n+        spy(\n+            new DepositRequestManager(\n+                eth1Provider, asyncRunner, depositEventChannel, depositContract));\n+  }\n+\n+  @Test\n+  void restartOnSubscriptionFailure() {\n+    mockLatestCanonicalBlockNumber(1);\n+    depositRequestManager.start();\n+    verify(depositRequestManager, atLeast(2)).start();\n+  }", "originalCommit": "489bdaf03265714eed680adb767d0bc639a83acd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MTg3Mw==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r376151873", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-07T00:08:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5OTQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0NDU1Nw==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r376144557", "bodyText": "It's better to use an argument matcher to do this kind of verification of method calls rather than an ArgumentCaptor.  Captors are more intended for things like listeners where you need to call methods on them to progress the test.  So:\n    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEventWithBlockNumber(1)));\n    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEventWithBlockNumber(2)));\n    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEventWithBlockNumber(4)));\n    verifyNoMoreInteractions(depositEventChannel);\n\nwhere isEventWithBlockNumber is:\n  private ArgumentMatcher<DepositsFromBlockEvent> isEventWithBlockNumber(\n      final long expectedBlockNumber) {\n    return argument -> argument.getBlockNumber().longValue() == expectedBlockNumber;\n  }\n\nYou may want to extend the matcher to also assert at least the expected number of deposits in each event.", "author": "ajsutton", "createdAt": "2020-02-06T23:43:08Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/DepositRequestManagerTest.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.atLeast;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.Longs;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.Flowable;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import org.web3j.protocol.core.methods.response.Log;\n+import org.web3j.utils.Numeric;\n+import tech.pegasys.artemis.pow.api.DepositEventChannel;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.async.StubAsyncRunner;\n+\n+public class DepositRequestManagerTest {\n+\n+  private Eth1Provider eth1Provider;\n+  private DepositEventChannel depositEventChannel;\n+  private DepositContract depositContract;\n+  private AsyncRunner asyncRunner;\n+\n+  private DepositRequestManager depositRequestManager;\n+\n+  @BeforeEach\n+  void setUp() {\n+    eth1Provider = mock(Eth1Provider.class);\n+    depositEventChannel = mock(DepositEventChannel.class);\n+    depositContract = mock(DepositContract.class);\n+    asyncRunner = new StubAsyncRunner();\n+\n+    depositRequestManager =\n+        spy(\n+            new DepositRequestManager(\n+                eth1Provider, asyncRunner, depositEventChannel, depositContract));\n+  }\n+\n+  @Test\n+  void restartOnSubscriptionFailure() {\n+    mockLatestCanonicalBlockNumber(1);\n+    depositRequestManager.start();\n+    verify(depositRequestManager, atLeast(2)).start();\n+  }\n+\n+  @Test\n+  void checkTheRangeAskedForIsCorrect() {\n+    mockLatestCanonicalBlockNumber(10);\n+    depositRequestManager.start();\n+    ArgumentCaptor<DefaultBlockParameter> fromBlockArgumentCaptor =\n+        ArgumentCaptor.forClass(DefaultBlockParameter.class);\n+    ArgumentCaptor<DefaultBlockParameter> toBlockArgumentCaptor =\n+        ArgumentCaptor.forClass(DefaultBlockParameter.class);\n+    verify(depositContract)\n+        .depositEventEventsInRange(\n+            fromBlockArgumentCaptor.capture(), toBlockArgumentCaptor.capture());\n+\n+    assertThat(Numeric.decodeQuantity(fromBlockArgumentCaptor.getValue().getValue())).isEqualTo(0);\n+    assertThat(Numeric.decodeQuantity(toBlockArgumentCaptor.getValue().getValue())).isEqualTo(10);\n+  }\n+\n+  @Test\n+  void depositsInConsecutiveBlocks() {\n+    mockLatestCanonicalBlockNumber(10);\n+\n+    mockContractEventsInRange(\n+        0,\n+        10,\n+        List.of(\n+            mockDepositEventEventResponse(1, \"0x1234\", 1),\n+            mockDepositEventEventResponse(2, \"0x1234\", 1),\n+            mockDepositEventEventResponse(3, \"0x2345\", 2)));\n+\n+    mockBlockForEth1Provider(\"0x1234\", 1, 1000);\n+    mockBlockForEth1Provider(\"0x2345\", 2, 1014);\n+\n+    depositRequestManager.start();\n+\n+    ArgumentCaptor<DepositsFromBlockEvent> eventArgumentCaptor =\n+        ArgumentCaptor.forClass(DepositsFromBlockEvent.class);\n+    verify(depositEventChannel, times(2)).notifyDepositsFromBlock(eventArgumentCaptor.capture());\n+    assertThat(eventArgumentCaptor.getAllValues()).hasSize(2);\n+    assertThat(\n+            eventArgumentCaptor.getAllValues().stream()\n+                .map(DepositsFromBlockEvent::getBlockNumber)\n+                .map(UnsignedLong::longValue)\n+                .collect(Collectors.toList()))\n+        .containsExactly(1L, 2L);\n+  }\n+\n+  @Test\n+  void noDepositsInSomeBlocksInRange() {\n+    mockLatestCanonicalBlockNumber(10);\n+\n+    mockContractEventsInRange(\n+        0,\n+        10,\n+        List.of(\n+            mockDepositEventEventResponse(1, \"0x1234\", 1),\n+            mockDepositEventEventResponse(2, \"0x1234\", 1),\n+            mockDepositEventEventResponse(3, \"0x2345\", 2),\n+            mockDepositEventEventResponse(4, \"0x4567\", 4)));\n+\n+    mockBlockForEth1Provider(\"0x1234\", 1, 1000);\n+    mockBlockForEth1Provider(\"0x2345\", 2, 1014);\n+    mockBlockForEth1Provider(\"0x4567\", 4, 1042);\n+\n+    depositRequestManager.start();\n+\n+    ArgumentCaptor<DepositsFromBlockEvent> eventArgumentCaptor =\n+        ArgumentCaptor.forClass(DepositsFromBlockEvent.class);\n+    verify(depositEventChannel, times(3)).notifyDepositsFromBlock(eventArgumentCaptor.capture());\n+    assertThat(eventArgumentCaptor.getAllValues()).hasSize(3);\n+    assertThat(\n+            eventArgumentCaptor.getAllValues().stream()\n+                .map(DepositsFromBlockEvent::getBlockNumber)\n+                .map(UnsignedLong::longValue)\n+                .collect(Collectors.toList()))\n+        .containsExactly(1L, 2L, 4L);", "originalCommit": "489bdaf03265714eed680adb767d0bc639a83acd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MzA1Nw==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r376153057", "bodyText": "Neat.", "author": "cemozerr", "createdAt": "2020-02-07T00:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0NDU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3ODM5Nw==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r376178397", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-02-07T01:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0NDU1Nw=="}], "type": "inlineReview"}, {"oid": "c0cf843cb39ba08d89404a94922bc0ea67e27fed", "url": "https://github.com/ConsenSys/teku/commit/c0cf843cb39ba08d89404a94922bc0ea67e27fed", "message": "Refactor tests", "committedDate": "2020-02-07T01:49:45Z", "type": "commit"}, {"oid": "8d57ededf593bbfcd4ddd27e6069b3a6641ba597", "url": "https://github.com/ConsenSys/teku/commit/8d57ededf593bbfcd4ddd27e6069b3a6641ba597", "message": "Merge branch 'master' into implementDepositRequestManager", "committedDate": "2020-02-07T01:52:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4NzAzOA==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r376187038", "bodyText": "nit: Remove this println.", "author": "ajsutton", "createdAt": "2020-02-07T02:30:27Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/DepositRequestManagerTest.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.Longs;\n+import io.reactivex.BackpressureStrategy;\n+import io.reactivex.Flowable;\n+import io.reactivex.subjects.PublishSubject;\n+import java.math.BigInteger;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentMatcher;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import org.web3j.protocol.core.methods.response.Log;\n+import org.web3j.utils.Numeric;\n+import tech.pegasys.artemis.pow.api.DepositEventChannel;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.async.StubAsyncRunner;\n+\n+public class DepositRequestManagerTest {\n+\n+  private Eth1Provider eth1Provider;\n+  private DepositEventChannel depositEventChannel;\n+  private DepositContract depositContract;\n+  private StubAsyncRunner asyncRunner;\n+\n+  private DepositRequestManager depositRequestManager;\n+  private PublishSubject<EthBlock.Block> blockPublisher;\n+\n+  @BeforeEach\n+  void setUp() {\n+    eth1Provider = mock(Eth1Provider.class);\n+    depositEventChannel = mock(DepositEventChannel.class);\n+    depositContract = mock(DepositContract.class);\n+    asyncRunner = new StubAsyncRunner();\n+\n+    depositRequestManager =\n+        new DepositRequestManager(eth1Provider, asyncRunner, depositEventChannel, depositContract);\n+\n+    blockPublisher = mockFlowablePublisher();\n+  }\n+\n+  @Test\n+  void restartOnSubscriptionFailure() {\n+    blockPublisher.onError(new RuntimeException(\"Nope\"));\n+    depositRequestManager.start();\n+    verify(eth1Provider).getLatestBlockFlowable();\n+\n+    asyncRunner.executeQueuedActions();\n+\n+    verify(eth1Provider, times(2)).getLatestBlockFlowable();\n+  }\n+\n+  @Test\n+  void depositsInConsecutiveBlocks() {\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> depositEventsFuture =\n+        mockContractEventsInRange(0, 10);\n+\n+    mockBlockForEth1Provider(\"0x1234\", 1, 1000);\n+    mockBlockForEth1Provider(\"0x2345\", 2, 1014);\n+\n+    depositRequestManager.start();\n+\n+    pushLatestCanonicalBlockWithNumber(10);\n+\n+    depositEventsFuture.complete(\n+        List.of(\n+            mockDepositEventEventResponse(1, \"0x1234\", 1),\n+            mockDepositEventEventResponse(2, \"0x1234\", 1),\n+            mockDepositEventEventResponse(3, \"0x2345\", 2)));\n+\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(1, 2)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(2, 1)));\n+    verifyNoMoreInteractions(depositEventChannel);\n+  }\n+\n+  @Test\n+  void noDepositsInSomeBlocksInRange() {\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> depositEventsFuture =\n+        mockContractEventsInRange(0, 10);\n+\n+    mockBlockForEth1Provider(\"0x1234\", 1, 1000);\n+    mockBlockForEth1Provider(\"0x2345\", 2, 1014);\n+    mockBlockForEth1Provider(\"0x4567\", 4, 1042);\n+\n+    depositRequestManager.start();\n+\n+    pushLatestCanonicalBlockWithNumber(10);\n+\n+    depositEventsFuture.complete(\n+        List.of(\n+            mockDepositEventEventResponse(1, \"0x1234\", 1),\n+            mockDepositEventEventResponse(2, \"0x2345\", 2),\n+            mockDepositEventEventResponse(3, \"0x4567\", 4)));\n+\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(1, 1)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(2, 1)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(4, 1)));\n+    verifyNoMoreInteractions(depositEventChannel);\n+  }\n+\n+  @Test\n+  void doesAnotherRequestWhenTheLatestCanonicalBlockGetsUpdatedDuringCurrentRequest() {\n+\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> firstRequestFuture =\n+        mockContractEventsInRange(0, 10);\n+\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> secondRequestFuture =\n+        mockContractEventsInRange(11, 22);\n+\n+    mockBlockForEth1Provider(\"0x0001\", 1, 1000);\n+    mockBlockForEth1Provider(\"0x0002\", 2, 1014);\n+    mockBlockForEth1Provider(\"0x0004\", 4, 1042);\n+    mockBlockForEth1Provider(\"0x0010\", 10, 1140);\n+    mockBlockForEth1Provider(\"0x0011\", 11, 1154);\n+    mockBlockForEth1Provider(\"0x0014\", 14, 1196);\n+\n+    depositRequestManager.start();\n+\n+    pushLatestCanonicalBlockWithNumber(10);\n+\n+    firstRequestFuture.complete(\n+        List.of(\n+            mockDepositEventEventResponse(1, \"0x0001\", 1),\n+            mockDepositEventEventResponse(2, \"0x0001\", 1),\n+            mockDepositEventEventResponse(3, \"0x0002\", 2),\n+            mockDepositEventEventResponse(4, \"0x0004\", 4),\n+            mockDepositEventEventResponse(5, \"0x0010\", 10)));\n+\n+    pushLatestCanonicalBlockWithNumber(22);\n+\n+    secondRequestFuture.complete(\n+        List.of(\n+            mockDepositEventEventResponse(6, \"0x0011\", 11),\n+            mockDepositEventEventResponse(7, \"0x0014\", 14)));\n+\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(1, 2)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(2, 1)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(4, 1)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(10, 1)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(11, 1)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(14, 1)));\n+    verifyNoMoreInteractions(depositEventChannel);\n+  }\n+\n+  @Test\n+  void runSecondAttemptWhenFirstAttemptFails() {\n+\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> firstRequestFuture =\n+        mockContractEventsInRange(0, 10);\n+\n+    mockBlockForEth1Provider(\"0x0001\", 1, 1000);\n+    mockBlockForEth1Provider(\"0x0002\", 2, 1014);\n+\n+    depositRequestManager.start();\n+\n+    pushLatestCanonicalBlockWithNumber(10);\n+\n+    firstRequestFuture.completeExceptionally(new RuntimeException(\"Nope\"));\n+\n+    System.out.println(asyncRunner.hasDelayedActions());", "originalCommit": "8d57ededf593bbfcd4ddd27e6069b3a6641ba597", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUzNjY2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r376536661", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-07T18:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4NzAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4NzI5MQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r376187291", "bodyText": "nit: I think this can be written with the more usual when(depositContract.depositEventEventsInRange(...)).thenReturn(...) style which will preserve type safety.", "author": "ajsutton", "createdAt": "2020-02-07T02:31:37Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/DepositRequestManagerTest.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.Longs;\n+import io.reactivex.BackpressureStrategy;\n+import io.reactivex.Flowable;\n+import io.reactivex.subjects.PublishSubject;\n+import java.math.BigInteger;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentMatcher;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import org.web3j.protocol.core.methods.response.Log;\n+import org.web3j.utils.Numeric;\n+import tech.pegasys.artemis.pow.api.DepositEventChannel;\n+import tech.pegasys.artemis.pow.contract.DepositContract;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.async.StubAsyncRunner;\n+\n+public class DepositRequestManagerTest {\n+\n+  private Eth1Provider eth1Provider;\n+  private DepositEventChannel depositEventChannel;\n+  private DepositContract depositContract;\n+  private StubAsyncRunner asyncRunner;\n+\n+  private DepositRequestManager depositRequestManager;\n+  private PublishSubject<EthBlock.Block> blockPublisher;\n+\n+  @BeforeEach\n+  void setUp() {\n+    eth1Provider = mock(Eth1Provider.class);\n+    depositEventChannel = mock(DepositEventChannel.class);\n+    depositContract = mock(DepositContract.class);\n+    asyncRunner = new StubAsyncRunner();\n+\n+    depositRequestManager =\n+        new DepositRequestManager(eth1Provider, asyncRunner, depositEventChannel, depositContract);\n+\n+    blockPublisher = mockFlowablePublisher();\n+  }\n+\n+  @Test\n+  void restartOnSubscriptionFailure() {\n+    blockPublisher.onError(new RuntimeException(\"Nope\"));\n+    depositRequestManager.start();\n+    verify(eth1Provider).getLatestBlockFlowable();\n+\n+    asyncRunner.executeQueuedActions();\n+\n+    verify(eth1Provider, times(2)).getLatestBlockFlowable();\n+  }\n+\n+  @Test\n+  void depositsInConsecutiveBlocks() {\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> depositEventsFuture =\n+        mockContractEventsInRange(0, 10);\n+\n+    mockBlockForEth1Provider(\"0x1234\", 1, 1000);\n+    mockBlockForEth1Provider(\"0x2345\", 2, 1014);\n+\n+    depositRequestManager.start();\n+\n+    pushLatestCanonicalBlockWithNumber(10);\n+\n+    depositEventsFuture.complete(\n+        List.of(\n+            mockDepositEventEventResponse(1, \"0x1234\", 1),\n+            mockDepositEventEventResponse(2, \"0x1234\", 1),\n+            mockDepositEventEventResponse(3, \"0x2345\", 2)));\n+\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(1, 2)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(2, 1)));\n+    verifyNoMoreInteractions(depositEventChannel);\n+  }\n+\n+  @Test\n+  void noDepositsInSomeBlocksInRange() {\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> depositEventsFuture =\n+        mockContractEventsInRange(0, 10);\n+\n+    mockBlockForEth1Provider(\"0x1234\", 1, 1000);\n+    mockBlockForEth1Provider(\"0x2345\", 2, 1014);\n+    mockBlockForEth1Provider(\"0x4567\", 4, 1042);\n+\n+    depositRequestManager.start();\n+\n+    pushLatestCanonicalBlockWithNumber(10);\n+\n+    depositEventsFuture.complete(\n+        List.of(\n+            mockDepositEventEventResponse(1, \"0x1234\", 1),\n+            mockDepositEventEventResponse(2, \"0x2345\", 2),\n+            mockDepositEventEventResponse(3, \"0x4567\", 4)));\n+\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(1, 1)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(2, 1)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(4, 1)));\n+    verifyNoMoreInteractions(depositEventChannel);\n+  }\n+\n+  @Test\n+  void doesAnotherRequestWhenTheLatestCanonicalBlockGetsUpdatedDuringCurrentRequest() {\n+\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> firstRequestFuture =\n+        mockContractEventsInRange(0, 10);\n+\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> secondRequestFuture =\n+        mockContractEventsInRange(11, 22);\n+\n+    mockBlockForEth1Provider(\"0x0001\", 1, 1000);\n+    mockBlockForEth1Provider(\"0x0002\", 2, 1014);\n+    mockBlockForEth1Provider(\"0x0004\", 4, 1042);\n+    mockBlockForEth1Provider(\"0x0010\", 10, 1140);\n+    mockBlockForEth1Provider(\"0x0011\", 11, 1154);\n+    mockBlockForEth1Provider(\"0x0014\", 14, 1196);\n+\n+    depositRequestManager.start();\n+\n+    pushLatestCanonicalBlockWithNumber(10);\n+\n+    firstRequestFuture.complete(\n+        List.of(\n+            mockDepositEventEventResponse(1, \"0x0001\", 1),\n+            mockDepositEventEventResponse(2, \"0x0001\", 1),\n+            mockDepositEventEventResponse(3, \"0x0002\", 2),\n+            mockDepositEventEventResponse(4, \"0x0004\", 4),\n+            mockDepositEventEventResponse(5, \"0x0010\", 10)));\n+\n+    pushLatestCanonicalBlockWithNumber(22);\n+\n+    secondRequestFuture.complete(\n+        List.of(\n+            mockDepositEventEventResponse(6, \"0x0011\", 11),\n+            mockDepositEventEventResponse(7, \"0x0014\", 14)));\n+\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(1, 2)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(2, 1)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(4, 1)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(10, 1)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(11, 1)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(14, 1)));\n+    verifyNoMoreInteractions(depositEventChannel);\n+  }\n+\n+  @Test\n+  void runSecondAttemptWhenFirstAttemptFails() {\n+\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> firstRequestFuture =\n+        mockContractEventsInRange(0, 10);\n+\n+    mockBlockForEth1Provider(\"0x0001\", 1, 1000);\n+    mockBlockForEth1Provider(\"0x0002\", 2, 1014);\n+\n+    depositRequestManager.start();\n+\n+    pushLatestCanonicalBlockWithNumber(10);\n+\n+    firstRequestFuture.completeExceptionally(new RuntimeException(\"Nope\"));\n+\n+    System.out.println(asyncRunner.hasDelayedActions());\n+\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> secondRequestFuture =\n+        mockContractEventsInRange(0, 10);\n+\n+    secondRequestFuture.complete(\n+        List.of(\n+            mockDepositEventEventResponse(1, \"0x0001\", 1),\n+            mockDepositEventEventResponse(2, \"0x0002\", 2)));\n+\n+    asyncRunner.executeQueuedActions();\n+\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(1, 1)));\n+    verify(depositEventChannel).notifyDepositsFromBlock(argThat(isEvent(2, 1)));\n+    verifyNoMoreInteractions(depositEventChannel);\n+  }\n+\n+  private void mockBlockForEth1Provider(String blockHash, long blockNumber, long timestamp) {\n+    EthBlock.Block block = mock(EthBlock.Block.class);\n+    when(block.getTimestamp()).thenReturn(BigInteger.valueOf(timestamp));\n+    when(block.getNumber()).thenReturn(BigInteger.valueOf(blockNumber));\n+    when(block.getHash()).thenReturn(blockHash);\n+    when(eth1Provider.getEth1BlockFuture(blockHash)).thenReturn(SafeFuture.completedFuture(block));\n+  }\n+\n+  private void pushLatestCanonicalBlockWithNumber(long latestBlockNumber) {\n+    EthBlock.Block block = mock(EthBlock.Block.class);\n+    when(block.getNumber())\n+        .thenReturn(\n+            BigInteger.valueOf(latestBlockNumber).add(ETH1_FOLLOW_DISTANCE.bigIntegerValue()));\n+    blockPublisher.onNext(block);\n+  }\n+\n+  private SafeFuture<List<DepositContract.DepositEventEventResponse>> mockContractEventsInRange(\n+      long fromBlockNumber, long toBlockNumber) {\n+    SafeFuture<List<DepositContract.DepositEventEventResponse>> safeFuture = new SafeFuture<>();\n+    doReturn(safeFuture)\n+        .when(depositContract)\n+        .depositEventEventsInRange(\n+            argThat(\n+                argument ->\n+                    Numeric.decodeQuantity(argument.getValue())\n+                        .equals(BigInteger.valueOf(fromBlockNumber))),\n+            argThat(\n+                argument ->\n+                    Numeric.decodeQuantity(argument.getValue())\n+                        .equals(BigInteger.valueOf(toBlockNumber))));", "originalCommit": "8d57ededf593bbfcd4ddd27e6069b3a6641ba597", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUzNzkwNA==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r376537904", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-07T18:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4NzI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUzODMyMQ==", "url": "https://github.com/ConsenSys/teku/pull/1132#discussion_r376538321", "bodyText": "Actually, I think Mockito has a problem. When I write it that way, it gives a null pointer exception.", "author": "cemozerr", "createdAt": "2020-02-07T18:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4NzI5MQ=="}], "type": "inlineReview"}, {"oid": "22aefea87d915a77e493aa4c2932127b3c875e44", "url": "https://github.com/ConsenSys/teku/commit/22aefea87d915a77e493aa4c2932127b3c875e44", "message": "Merge branch 'master' into implementDepositRequestManager", "committedDate": "2020-02-07T18:28:01Z", "type": "commit"}, {"oid": "3d6fd6712a3196692cd5f4beb6bf69300adc46be", "url": "https://github.com/ConsenSys/teku/commit/3d6fd6712a3196692cd5f4beb6bf69300adc46be", "message": "Remove stray println", "committedDate": "2020-02-07T18:28:43Z", "type": "commit"}]}