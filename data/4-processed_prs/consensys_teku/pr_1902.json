{"pr_number": 1902, "pr_title": "Calculate ETH1 deposit count and root based on event logs", "pr_createdAt": "2020-05-25T04:39:52Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1902", "timeline": [{"oid": "3052b1cb39bb4de5dec21028a9dd3688d229317a", "url": "https://github.com/ConsenSys/teku/commit/3052b1cb39bb4de5dec21028a9dd3688d229317a", "message": "Rework Eth1Data handling to avoid needing ETH1 world state.", "committedDate": "2020-05-25T04:24:53Z", "type": "commit"}, {"oid": "19908bbcffef807efd7d018488f7ad81c9b68cde", "url": "https://github.com/ConsenSys/teku/commit/19908bbcffef807efd7d018488f7ad81c9b68cde", "message": "Rename method.", "committedDate": "2020-05-25T04:39:36Z", "type": "commit"}, {"oid": "8a6da1a5709ad234c85448da025268c96a05af12", "url": "https://github.com/ConsenSys/teku/commit/8a6da1a5709ad234c85448da025268c96a05af12", "message": "Remove unused variable.", "committedDate": "2020-05-25T04:42:57Z", "type": "commit"}, {"oid": "65b333f34dc2610200a569b874aa3d2e66bd369f", "url": "https://github.com/ConsenSys/teku/commit/65b333f34dc2610200a569b874aa3d2e66bd369f", "message": "Request empty blocks in parallel with processing deposits.", "committedDate": "2020-05-25T04:48:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUwNzIyMQ==", "url": "https://github.com/ConsenSys/teku/pull/1902#discussion_r430507221", "bodyText": "This line seems redundant. Every time requestNextBlockIfRequired  calls requestBlock, it sets requestInProgress to true. However, requestNextBlockIfRequired does not set requestInProgress to false. So requestNextBlockIfRequiredreturns early every time its called inside requestBlock.", "author": "cemozerr", "createdAt": "2020-05-26T15:35:45Z", "path": "pow/src/main/java/tech/pegasys/teku/pow/Eth1BlockFetcher.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.pow;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.NavigableSet;\n+import java.util.TreeSet;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock.Block;\n+import tech.pegasys.teku.pow.api.Eth1EventsChannel;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+import tech.pegasys.teku.util.time.TimeProvider;\n+\n+public class Eth1BlockFetcher {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final TimeProvider timeProvider;\n+  private final UnsignedLong cacheDuration;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final NavigableSet<UnsignedLong> blocksToRequest = new TreeSet<>();\n+  private boolean requestInProgress = false;\n+  private boolean active = false;\n+\n+  public Eth1BlockFetcher(\n+      final Eth1EventsChannel eth1EventsChannel,\n+      final Eth1Provider eth1Provider,\n+      final TimeProvider timeProvider,\n+      final UnsignedLong cacheDuration) {\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.eth1Provider = eth1Provider;\n+    this.timeProvider = timeProvider;\n+    this.cacheDuration = cacheDuration;\n+  }\n+\n+  public synchronized void onInSync(final UnsignedLong latestCanonicalBlockNumber) {\n+    if (active) {\n+      return;\n+    }\n+    active = true;\n+    LOG.debug(\"Beginning back-fill of Eth1 blocks\");\n+    backfillEth1Blocks(latestCanonicalBlockNumber);\n+  }\n+\n+  public void fetch(final BigInteger fromBlock, final BigInteger toBlock) {\n+    synchronized (this) {\n+      if (!active) {\n+        // No point starting to request data if we haven't yet reached the start of the chain\n+        // We'll just wind up downloading a heap of blocks we then throw away\n+        return;\n+      }\n+      for (BigInteger block = fromBlock;\n+          block.compareTo(toBlock) <= 0;\n+          block = block.add(BigInteger.ONE)) {\n+        blocksToRequest.add(UnsignedLong.valueOf(block));\n+      }\n+    }\n+    requestNextBlockIfRequired();\n+  }\n+\n+  private void requestNextBlockIfRequired() {\n+    UnsignedLong blockToRequest;\n+    synchronized (this) {\n+      if (requestInProgress || blocksToRequest.isEmpty()) {\n+        return;\n+      }\n+      blockToRequest = blocksToRequest.last();\n+      blocksToRequest.remove(blockToRequest);\n+      requestInProgress = true;\n+    }\n+    requestBlock(blockToRequest)\n+        .always(\n+            () -> {\n+              synchronized (Eth1BlockFetcher.this) {\n+                requestInProgress = false;\n+              }\n+              requestNextBlockIfRequired();\n+            });\n+  }\n+\n+  private SafeFuture<Void> requestBlock(final UnsignedLong blockNumberToRequest) {\n+    // Note: Not using guaranteed requests here - if the Eth1 chain is temporarily unavailable\n+    // we may miss some blocks but that's better than potentially getting stuck retrying a block\n+    LOG.debug(\"Requesting block {}\", blockNumberToRequest);\n+    return eth1Provider\n+        .getEth1BlockFuture(blockNumberToRequest)\n+        .thenAccept(\n+            block -> {\n+              if (isAboveLowerBound(UnsignedLong.valueOf(block.getTimestamp()))) {\n+                postBlock(block);\n+              } else {\n+                // Every block before the one we just fetched must be outside of the range\n+                synchronized (Eth1BlockFetcher.this) {\n+                  // All blocks at or before this number must be before the cache period\n+                  blocksToRequest.headSet(blockNumberToRequest, true).clear();\n+                }\n+              }\n+              requestNextBlockIfRequired();", "originalCommit": "65b333f34dc2610200a569b874aa3d2e66bd369f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczNDI1Nw==", "url": "https://github.com/ConsenSys/teku/pull/1902#discussion_r430734257", "bodyText": "Yes it is, that logic got moved to the .always but I missed this call.", "author": "ajsutton", "createdAt": "2020-05-26T22:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUwNzIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUyMDY3OQ==", "url": "https://github.com/ConsenSys/teku/pull/1902#discussion_r430520679", "bodyText": "Is there a reason why you used guaranteed requests here? Missing some blocks does seem better than potentially getting stuck retrying a block, similar to the case above.", "author": "cemozerr", "createdAt": "2020-05-26T15:51:50Z", "path": "pow/src/main/java/tech/pegasys/teku/pow/Eth1BlockFetcher.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.pow;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.NavigableSet;\n+import java.util.TreeSet;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock.Block;\n+import tech.pegasys.teku.pow.api.Eth1EventsChannel;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+import tech.pegasys.teku.util.time.TimeProvider;\n+\n+public class Eth1BlockFetcher {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final TimeProvider timeProvider;\n+  private final UnsignedLong cacheDuration;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final NavigableSet<UnsignedLong> blocksToRequest = new TreeSet<>();\n+  private boolean requestInProgress = false;\n+  private boolean active = false;\n+\n+  public Eth1BlockFetcher(\n+      final Eth1EventsChannel eth1EventsChannel,\n+      final Eth1Provider eth1Provider,\n+      final TimeProvider timeProvider,\n+      final UnsignedLong cacheDuration) {\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.eth1Provider = eth1Provider;\n+    this.timeProvider = timeProvider;\n+    this.cacheDuration = cacheDuration;\n+  }\n+\n+  public synchronized void onInSync(final UnsignedLong latestCanonicalBlockNumber) {\n+    if (active) {\n+      return;\n+    }\n+    active = true;\n+    LOG.debug(\"Beginning back-fill of Eth1 blocks\");\n+    backfillEth1Blocks(latestCanonicalBlockNumber);\n+  }\n+\n+  public void fetch(final BigInteger fromBlock, final BigInteger toBlock) {\n+    synchronized (this) {\n+      if (!active) {\n+        // No point starting to request data if we haven't yet reached the start of the chain\n+        // We'll just wind up downloading a heap of blocks we then throw away\n+        return;\n+      }\n+      for (BigInteger block = fromBlock;\n+          block.compareTo(toBlock) <= 0;\n+          block = block.add(BigInteger.ONE)) {\n+        blocksToRequest.add(UnsignedLong.valueOf(block));\n+      }\n+    }\n+    requestNextBlockIfRequired();\n+  }\n+\n+  private void requestNextBlockIfRequired() {\n+    UnsignedLong blockToRequest;\n+    synchronized (this) {\n+      if (requestInProgress || blocksToRequest.isEmpty()) {\n+        return;\n+      }\n+      blockToRequest = blocksToRequest.last();\n+      blocksToRequest.remove(blockToRequest);\n+      requestInProgress = true;\n+    }\n+    requestBlock(blockToRequest)\n+        .always(\n+            () -> {\n+              synchronized (Eth1BlockFetcher.this) {\n+                requestInProgress = false;\n+              }\n+              requestNextBlockIfRequired();\n+            });\n+  }\n+\n+  private SafeFuture<Void> requestBlock(final UnsignedLong blockNumberToRequest) {\n+    // Note: Not using guaranteed requests here - if the Eth1 chain is temporarily unavailable\n+    // we may miss some blocks but that's better than potentially getting stuck retrying a block\n+    LOG.debug(\"Requesting block {}\", blockNumberToRequest);\n+    return eth1Provider\n+        .getEth1BlockFuture(blockNumberToRequest)\n+        .thenAccept(\n+            block -> {\n+              if (isAboveLowerBound(UnsignedLong.valueOf(block.getTimestamp()))) {\n+                postBlock(block);\n+              } else {\n+                // Every block before the one we just fetched must be outside of the range\n+                synchronized (Eth1BlockFetcher.this) {\n+                  // All blocks at or before this number must be before the cache period\n+                  blocksToRequest.headSet(blockNumberToRequest, true).clear();\n+                }\n+              }\n+              requestNextBlockIfRequired();\n+            })\n+        .exceptionallyCompose(\n+            error -> {\n+              LOG.warn(\"Failed to retrieve block {}\", blockNumberToRequest);\n+              return SafeFuture.COMPLETE;\n+            });\n+  }\n+\n+  private void postBlock(final Block block) {\n+    eth1EventsChannel.onEth1Block(\n+        Bytes32.fromHexString(block.getHash()), UnsignedLong.valueOf(block.getTimestamp()));\n+  }\n+\n+  private void backfillEth1Blocks(final UnsignedLong nextBlockToRequest) {\n+    // Walk backwards from blockNumber until we reach the start of the voting period\n+    eth1Provider\n+        .getGuaranteedEth1BlockFuture(nextBlockToRequest)", "originalCommit": "65b333f34dc2610200a569b874aa3d2e66bd369f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczNjg5Nw==", "url": "https://github.com/ConsenSys/teku/pull/1902#discussion_r430736897", "bodyText": "I'm in two minds about it.  Ultimately I went with guaranteed here in backfill and not the normal case because if the node is down or overloaded briefly during backfill we'll potentially miss fairly large numbers of blocks and not backfill the cache properly.  If it's down briefly in the normal case, we likely only miss a couple of blocks (because normally we're querying one new block about every 15 seconds).", "author": "ajsutton", "createdAt": "2020-05-26T22:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUyMDY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc2MDIyNw==", "url": "https://github.com/ConsenSys/teku/pull/1902#discussion_r430760227", "bodyText": "That makes sense to me.", "author": "cemozerr", "createdAt": "2020-05-26T23:22:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUyMDY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0ODk0NQ==", "url": "https://github.com/ConsenSys/teku/pull/1902#discussion_r430548945", "bodyText": "Adding a LOG.debug here might be useful, in case we're getting too many redundant blocks from Eth1BlockFetcher", "author": "cemozerr", "createdAt": "2020-05-26T16:32:21Z", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/Eth1DataCache.java", "diffHunk": "@@ -13,50 +13,48 @@\n \n package tech.pegasys.teku.validator.coordinator;\n \n-import static tech.pegasys.teku.util.config.Constants.EPOCHS_PER_ETH1_VOTING_PERIOD;\n-import static tech.pegasys.teku.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n-import static tech.pegasys.teku.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n-import static tech.pegasys.teku.util.config.Constants.SECONDS_PER_SLOT;\n-import static tech.pegasys.teku.util.config.Constants.SLOTS_PER_EPOCH;\n-\n-import com.google.common.eventbus.EventBus;\n-import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.NavigableMap;\n import java.util.Optional;\n import java.util.concurrent.ConcurrentSkipListMap;\n+import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.datastructures.blocks.Eth1Data;\n import tech.pegasys.teku.datastructures.state.BeaconState;\n-import tech.pegasys.teku.pow.event.CacheEth1BlockEvent;\n-import tech.pegasys.teku.util.config.Constants;\n \n public class Eth1DataCache {\n-\n   private final UnsignedLong cacheDuration;\n-  private volatile Optional<UnsignedLong> genesisTime = Optional.empty();\n+  private final Eth1VotingPeriod eth1VotingPeriod;\n \n   private final NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n \n-  public Eth1DataCache(EventBus eventBus) {\n-    eventBus.register(this);\n-    cacheDuration = calculateCacheDuration();\n+  public Eth1DataCache(final Eth1VotingPeriod eth1VotingPeriod) {\n+    this.eth1VotingPeriod = eth1VotingPeriod;\n+    cacheDuration = eth1VotingPeriod.getCacheDurationInSeconds();\n   }\n \n-  public void startBeaconChainMode(BeaconState headState) {\n-    this.genesisTime = Optional.of(headState.getGenesis_time());\n+  public void onBlockWithDeposit(final UnsignedLong blockTimestamp, final Eth1Data eth1Data) {\n+    eth1ChainCache.put(blockTimestamp, eth1Data);\n+    prune(blockTimestamp);\n   }\n \n-  @Subscribe\n-  public void onCacheEth1BlockEvent(CacheEth1BlockEvent cacheEth1BlockEvent) {\n-    final UnsignedLong latestBlockTimestamp = cacheEth1BlockEvent.getBlockTimestamp();\n-    eth1ChainCache.put(latestBlockTimestamp, createEth1Data(cacheEth1BlockEvent));\n-    prune(latestBlockTimestamp);\n+  public void onEth1Block(final Bytes32 blockHash, final UnsignedLong blockTimestamp) {\n+    final Entry<UnsignedLong, Eth1Data> previousBlock = eth1ChainCache.floorEntry(blockTimestamp);\n+    if (previousBlock == null) {\n+      // This block is either before any deposits so will never be voted for", "originalCommit": "65b333f34dc2610200a569b874aa3d2e66bd369f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczNzE4NQ==", "url": "https://github.com/ConsenSys/teku/pull/1902#discussion_r430737185", "bodyText": "Done.", "author": "ajsutton", "createdAt": "2020-05-26T22:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0ODk0NQ=="}], "type": "inlineReview"}, {"oid": "9ef674a8af2aa83d048b19636288bd259e18fa19", "url": "https://github.com/ConsenSys/teku/commit/9ef674a8af2aa83d048b19636288bd259e18fa19", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into no-eth1-world-state", "committedDate": "2020-05-26T22:04:47Z", "type": "commit"}, {"oid": "9bbc9821b71b3cc4a49547107c2ade0db8343e88", "url": "https://github.com/ConsenSys/teku/commit/9bbc9821b71b3cc4a49547107c2ade0db8343e88", "message": "Review feedback.", "committedDate": "2020-05-26T22:12:14Z", "type": "commit"}]}