{"pr_number": 1615, "pr_title": "Implement BlockValidator", "pr_createdAt": "2020-04-17T19:03:03Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1615", "timeline": [{"oid": "4e0fea79e98213e89eba344d803674ad53377051", "url": "https://github.com/ConsenSys/teku/commit/4e0fea79e98213e89eba344d803674ad53377051", "message": "Implement BlockValidator", "committedDate": "2020-04-17T19:02:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NjE3OA==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410446178", "bodyText": "We should use a ConcurrentLimitedSet here, so this collection doesn't grow forever:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n          \n          \n            \n              private final Set<UnsignedLong> receivedValidSignatureBlockSlots = ConcurrentLimitedSet.create(maxSize, DROP_LEAST_RECENTLY_ACCESSED);", "author": "mbaxter", "createdAt": "2020-04-17T20:11:05Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();", "originalCommit": "4e0fea79e98213e89eba344d803674ad53377051", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3OTMzOA==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410479338", "bodyText": "Makes sense.", "author": "cemozerr", "createdAt": "2020-04-17T21:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NjE3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4MDMyNg==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410480326", "bodyText": "I do think drop oldest element strategy would make more sense here.", "author": "cemozerr", "createdAt": "2020-04-17T21:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NjE3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4MTE0MA==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410481140", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-17T21:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NjE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTkyMg==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410449922", "bodyText": "(nit) You could just use an Optional here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n          \n          \n            \n                final Optional<BeaconState> preState = recentChainData.getBlockState(block.getMessage().getParent_root());\n          \n          \n            \n                if (preState.isEmpty() || !blockIsNotFromFutureSlot(block)) {", "author": "mbaxter", "createdAt": "2020-04-17T20:19:25Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());", "originalCommit": "4e0fea79e98213e89eba344d803674ad53377051", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4MTg1Mw==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410481853", "bodyText": "Good idea. done.", "author": "cemozerr", "createdAt": "2020-04-17T21:37:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MDU1NA==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410450554", "bodyText": "The double-negative is a bit confusing:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n          \n          \n            \n                if (!blockPreStateDoesExist(preState) || blockIsFromFutureSlot(block)) {", "author": "mbaxter", "createdAt": "2020-04-17T20:20:38Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {", "originalCommit": "4e0fea79e98213e89eba344d803674ad53377051", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4MjY2NA==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410482664", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-04-17T21:39:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MDU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1ODEwMw==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410458103", "bodyText": "In general, I'd probably cut back on the logging in this validator.  I think we probably just want to log a trace message if we encounter something that clearly violates the spec (invalid signature, unprocessable block, etc).", "author": "mbaxter", "createdAt": "2020-04-17T20:38:35Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n+      LOG.trace(\"BlockValidator: Either block pre state does not exist or block is from the future. \" +\n+              \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState) &&\n+              blockSignatureIsValidWithRespectToProposerIndex(block, preState, postState)) {\n+        LOG.trace(\"BlockValidator: Block has passed all gossip layer validation\");", "originalCommit": "4e0fea79e98213e89eba344d803674ad53377051", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4MjY4Mw==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410482683", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-04-17T21:39:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1ODEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NDIyMg==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410464222", "bodyText": "I don't think this calculation actually does anything (when MAXIMUM_GOSSIP_CLOCK_DISPARITY < 1000) ...  Should we do something like?:\nfinal long disparityInSeconds = Math.round((float) MAXIMUM_GOSSIP_CLOCK_DISPARITY / 1000.0);\nfinal UnsignedLong maxOffset = UnsignedLong.valueOf(disparityInSeconds);\nfinal UnsignedLong maxTime = store.getTime.plus(maxOffset);", "author": "mbaxter", "createdAt": "2020-04-17T20:53:13Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n+      LOG.trace(\"BlockValidator: Either block pre state does not exist or block is from the future. \" +\n+              \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState) &&\n+              blockSignatureIsValidWithRespectToProposerIndex(block, preState, postState)) {\n+        LOG.trace(\"BlockValidator: Block has passed all gossip layer validation\");\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsNotFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    // .times() and .dividedBy() is to account for the fact that store.time is in seconds\n+    // and MAXIMUM_GOSSIP_CLOCK_DISPARITY is in ms.\n+    UnsignedLong maxTime = store.getTime()\n+            .times(valueOf(1000))\n+            .plus(MAXIMUM_GOSSIP_CLOCK_DISPARITY)\n+            .dividedBy(valueOf(1000));", "originalCommit": "4e0fea79e98213e89eba344d803674ad53377051", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4NDgxMg==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410484812", "bodyText": "Good catch. I don't think that's the perfect solution either, (we should potentially think of switching store.time to be in milliseconds at some point) however, I think we can live with your suggestion.", "author": "cemozerr", "createdAt": "2020-04-17T21:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NDIyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4NTA5OQ==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410485099", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-17T21:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NDIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NjY5Ng==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410466696", "bodyText": "The add method will return true if we successfully add a new element.  Suggest only continuing with processing if we successfully add to the collection.", "author": "mbaxter", "createdAt": "2020-04-17T20:58:53Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n+      LOG.trace(\"BlockValidator: Either block pre state does not exist or block is from the future. \" +\n+              \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState) &&\n+              blockSignatureIsValidWithRespectToProposerIndex(block, preState, postState)) {\n+        LOG.trace(\"BlockValidator: Block has passed all gossip layer validation\");\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsNotFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    // .times() and .dividedBy() is to account for the fact that store.time is in seconds\n+    // and MAXIMUM_GOSSIP_CLOCK_DISPARITY is in ms.\n+    UnsignedLong maxTime = store.getTime()\n+            .times(valueOf(1000))\n+            .plus(MAXIMUM_GOSSIP_CLOCK_DISPARITY)\n+            .dividedBy(valueOf(1000));\n+    UnsignedLong maxCurrSlot = getCurrentSlot(maxTime, store.getGenesisTime());\n+    return block.getSlot().compareTo(maxCurrSlot) <= 0;\n+  }\n+\n+  private boolean blockSlotIsGreaterThanLatestFinalizedSlot(SignedBeaconBlock block) {\n+    UnsignedLong finalizedSlot = recentChainData.getStore().getFinalizedCheckpoint().getEpochStartSlot();\n+    return block.getSlot().compareTo(finalizedSlot) > 0;\n+  }\n+\n+  private boolean blockPreStateDoesExist(BeaconState preState) {\n+    return preState != null;\n+  }\n+\n+  private boolean blockIsFirstBlockWithValidSignatureForSlot(SignedBeaconBlock block) {\n+    return !receivedValidSignatureBlockSlots.contains(block.getSlot());\n+  }\n+\n+  private boolean blockSignatureIsValidWithRespectToProposerIndex(SignedBeaconBlock block,\n+                                                                  BeaconState preState,\n+                                                                  BeaconState postState) {\n+      Validator proposer = postState.getValidators().get(\n+              toIntExact(block.getMessage().getProposer_index().longValue())\n+      );\n+\n+      final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n+      final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n+      final BLSSignature signature = block.getSignature();\n+      boolean signatureValid = BLS.verify(proposer.getPubkey(), signing_root, signature);\n+\n+      if (signatureValid) {\n+        receivedValidSignatureBlockSlots.add(block.getSlot());", "originalCommit": "4e0fea79e98213e89eba344d803674ad53377051", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4NjA3OQ==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410486079", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-17T21:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NjY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NzkyMw==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410467923", "bodyText": "I think we need to put slot/proposerIndex pairs in this collection ... What if there are multiple forks where we have different valid proposers for the same slot on different forks?", "author": "mbaxter", "createdAt": "2020-04-17T21:01:37Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();", "originalCommit": "4e0fea79e98213e89eba344d803674ad53377051", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NDQzNA==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410494434", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-04-17T22:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NzkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MTY4MA==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410471680", "bodyText": "nice :D", "author": "mbaxter", "createdAt": "2020-04-17T21:10:27Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/BlockTopicHandler.java", "diffHunk": "@@ -66,49 +56,18 @@ protected SignedBeaconBlock deserialize(final Bytes bytes) throws SSZException {\n \n   @Override\n   protected boolean validateData(final SignedBeaconBlock block) {\n-    if (recentChainData.isPreGenesis()) {\n-      // We can't process blocks pre-genesis\n-      return false;\n-    }\n-\n-    final BeaconState preState =\n-        recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n-    if (preState == null) {\n-      // Post event even if we don't have the prestate\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    if (!isBlockSignatureValid(block, preState)) {\n-      LOG.trace(\"Dropping gossiped block with invalid signature: {}\", block);\n-      return false;\n-    }\n-\n-    final UnsignedLong currentSlot = get_current_slot(recentChainData.getStore());\n-    if (block.getSlot().compareTo(currentSlot) > 0) {\n-      // Don't gossip future blocks\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    return true;\n-  }\n-\n-  private boolean isBlockSignatureValid(final SignedBeaconBlock block, final BeaconState preState) {\n-    final StateTransition stateTransition = new StateTransition();\n-\n-    try {\n-      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n-      final int proposerIndex = get_beacon_proposer_index(postState);\n-      final Validator proposer = postState.getValidators().get(proposerIndex);\n-      final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n-      final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n-      final BLSSignature signature = block.getSignature();\n-      return BLS.verify(proposer.getPubkey(), signing_root, signature);\n-\n-    } catch (EpochProcessingException | SlotProcessingException e) {\n-      LOG.error(\"Unable to process block state.\", e);\n-      return false;\n+    BlockValidationResult blockValidationResult = blockValidator.validate(block);\n+    switch (blockValidationResult) {", "originalCommit": "4e0fea79e98213e89eba344d803674ad53377051", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MzA1OA==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410473058", "bodyText": "Looks like a few test cases are missing for invalid signatures, missing prestate, duplicate block", "author": "mbaxter", "createdAt": "2020-04-17T21:13:58Z", "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/gossip/BlockValidatorTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package tech.pegasys.artemis.networking.eth2.gossip;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.bls.BLSKeyGenerator;\n+import tech.pegasys.artemis.bls.BLSKeyPair;\n+import tech.pegasys.artemis.core.ChainBuilder;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.StateTransitionException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidationResult;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidator;\n+import tech.pegasys.artemis.statetransition.BeaconChainUtil;\n+import tech.pegasys.artemis.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.List;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+\n+public class BlockValidatorTest {", "originalCommit": "4e0fea79e98213e89eba344d803674ad53377051", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4NjU1NQ==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410486555", "bodyText": "Yeah, I put it up as a draft PR to get feedback. Gotta figure out how to make PR's actually draft.", "author": "cemozerr", "createdAt": "2020-04-17T21:49:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MzA1OA=="}], "type": "inlineReview"}, {"oid": "94a50bb49933bdf3208a6158f84492602c83dfbc", "url": "https://github.com/ConsenSys/teku/commit/94a50bb49933bdf3208a6158f84492602c83dfbc", "message": "Resolve comments & finish tests", "committedDate": "2020-04-17T22:46:07Z", "type": "commit"}, {"oid": "a6a6e0e607bf224018860f84d87e2d97bda71aaf", "url": "https://github.com/ConsenSys/teku/commit/a6a6e0e607bf224018860f84d87e2d97bda71aaf", "message": "Fix tests", "committedDate": "2020-04-17T23:44:55Z", "type": "commit"}, {"oid": "97c0cc75708674ab7d01fbdb746abe03703d0203", "url": "https://github.com/ConsenSys/teku/commit/97c0cc75708674ab7d01fbdb746abe03703d0203", "message": "Run spotless", "committedDate": "2020-04-17T23:49:35Z", "type": "commit"}, {"oid": "03175188f7c5e6a6c9c826b9e32daa5f1f760e5b", "url": "https://github.com/ConsenSys/teku/commit/03175188f7c5e6a6c9c826b9e32daa5f1f760e5b", "message": "Merge remote-tracking branch 'remotes/origin/master' into validateBlocks\n\n# Conflicts:\n#\tnetworking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/BlockTopicHandler.java", "committedDate": "2020-04-17T23:51:22Z", "type": "commit"}, {"oid": "984a2c8fdc88801ff0fcdf0695d4158f491f483a", "url": "https://github.com/ConsenSys/teku/commit/984a2c8fdc88801ff0fcdf0695d4158f491f483a", "message": "Fix merge issue", "committedDate": "2020-04-18T00:00:08Z", "type": "commit"}, {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c", "url": "https://github.com/ConsenSys/teku/commit/a38713fa1922a8b1f6b348fd578ff01dd0ad066c", "message": "Only post on to eventBus once if valid", "committedDate": "2020-04-18T00:13:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA4OTYyOA==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411089628", "bodyText": "nit: We should provide a message here to indicate what the unexpected value was.", "author": "ajsutton", "createdAt": "2020-04-20T04:45:38Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/BlockTopicHandler.java", "diffHunk": "@@ -66,49 +50,17 @@ protected SignedBeaconBlock deserialize(final Bytes bytes) throws SSZException {\n \n   @Override\n   protected boolean validateData(final SignedBeaconBlock block) {\n-    if (recentChainData.isPreGenesis()) {\n-      // We can't process blocks pre-genesis\n-      return false;\n-    }\n-\n-    final BeaconState preState =\n-        recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n-    if (preState == null) {\n-      // Post event even if we don't have the prestate\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    if (!isBlockSignatureValid(block, preState)) {\n-      LOG.trace(\"Dropping gossiped block with invalid signature: {}\", block);\n-      return false;\n-    }\n-\n-    final UnsignedLong currentSlot = get_current_slot(recentChainData.getStore());\n-    if (block.getSlot().compareTo(currentSlot) > 0) {\n-      // Don't gossip future blocks\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    return true;\n-  }\n-\n-  private boolean isBlockSignatureValid(final SignedBeaconBlock block, final BeaconState preState) {\n-    final StateTransition stateTransition = new StateTransition();\n-\n-    try {\n-      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n-      final int proposerIndex = get_beacon_proposer_index(postState);\n-      final Validator proposer = postState.getValidators().get(proposerIndex);\n-      final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n-      final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n-      final BLSSignature signature = block.getSignature();\n-      return BLS.verify(proposer.getPubkey(), signing_root, signature);\n-\n-    } catch (EpochProcessingException | SlotProcessingException e) {\n-      LOG.error(\"Unable to process block state.\", e);\n-      return false;\n+    BlockValidationResult blockValidationResult = blockValidator.validate(block);\n+    switch (blockValidationResult) {\n+      case INVALID:\n+        return false;\n+      case SAVED_FOR_FUTURE:\n+        eventBus.post(createEvent(block));\n+        return false;\n+      case VALID:\n+        return true;\n+      default:\n+        throw new UnsupportedOperationException();", "originalCommit": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1MDE2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411550161", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-04-20T17:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA4OTYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5MjIxMA==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411092210", "bodyText": "We should be using the caches for this via AttestationUtil.getValidatorPubKey (which probably should be moved to a public method in ValidatorsUtil.", "author": "ajsutton", "createdAt": "2020-04-20T04:54:18Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.core.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_BLOCK_SET_SIZE;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<SlotAndProposer> receivedValidBlockInfoSet =\n+      ConcurrentLimitedSet.create(VALID_BLOCK_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+\n+  public BlockValidator(RecentChainData recentChainData, StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block)\n+        || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Block is either too old or is not the first block with valid signature for \"\n+              + \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final Optional<BeaconState> preState =\n+        Optional.ofNullable(\n+            recentChainData.getStore().getBlockState(block.getMessage().getParent_root()));\n+    if (preState.isEmpty() || blockIsFromFutureSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Either block pre state does not exist or block is from the future. \"\n+              + \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState =\n+          stateTransition.process_slots(preState.get(), block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState)\n+          && blockSignatureIsValidWithRespectToProposerIndex(block, preState.get(), postState)) {\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    final long disparityInSeconds = Math.round((float) MAXIMUM_GOSSIP_CLOCK_DISPARITY / 1000.0);\n+    final UnsignedLong maxOffset = UnsignedLong.valueOf(disparityInSeconds);\n+    final UnsignedLong maxTime = store.getTime().plus(maxOffset);\n+    UnsignedLong maxCurrSlot = getCurrentSlot(maxTime, store.getGenesisTime());\n+    return block.getSlot().compareTo(maxCurrSlot) > 0;\n+  }\n+\n+  private boolean blockSlotIsGreaterThanLatestFinalizedSlot(SignedBeaconBlock block) {\n+    UnsignedLong finalizedSlot =\n+        recentChainData.getStore().getFinalizedCheckpoint().getEpochStartSlot();\n+    return block.getSlot().compareTo(finalizedSlot) > 0;\n+  }\n+\n+  private boolean blockIsFirstBlockWithValidSignatureForSlot(SignedBeaconBlock block) {\n+    return !receivedValidBlockInfoSet.contains(new SlotAndProposer(block));\n+  }\n+\n+  private boolean blockSignatureIsValidWithRespectToProposerIndex(\n+      SignedBeaconBlock block, BeaconState preState, BeaconState postState) {\n+    Validator proposer =\n+        postState\n+            .getValidators()\n+            .get(toIntExact(block.getMessage().getProposer_index().longValue()));", "originalCommit": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1MzY0OQ==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411553649", "bodyText": "Both done.", "author": "cemozerr", "createdAt": "2020-04-20T17:19:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5MjIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5MjYxNw==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411092617", "bodyText": "Remove the toIntExact here and use long comparison (the int proposerIndex will be automatically up-cast to a long).  That way it will evaluate to false if proposer index is greater than Integer.MAX_VALUE rather than throwing an exception.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return proposerIndex == toIntExact(block.getMessage().getProposer_index().longValue());\n          \n          \n            \n                return proposerIndex == block.getMessage().getProposer_index().longValue();", "author": "ajsutton", "createdAt": "2020-04-20T04:55:42Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.core.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_BLOCK_SET_SIZE;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<SlotAndProposer> receivedValidBlockInfoSet =\n+      ConcurrentLimitedSet.create(VALID_BLOCK_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+\n+  public BlockValidator(RecentChainData recentChainData, StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block)\n+        || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Block is either too old or is not the first block with valid signature for \"\n+              + \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final Optional<BeaconState> preState =\n+        Optional.ofNullable(\n+            recentChainData.getStore().getBlockState(block.getMessage().getParent_root()));\n+    if (preState.isEmpty() || blockIsFromFutureSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Either block pre state does not exist or block is from the future. \"\n+              + \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState =\n+          stateTransition.process_slots(preState.get(), block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState)\n+          && blockSignatureIsValidWithRespectToProposerIndex(block, preState.get(), postState)) {\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    final long disparityInSeconds = Math.round((float) MAXIMUM_GOSSIP_CLOCK_DISPARITY / 1000.0);\n+    final UnsignedLong maxOffset = UnsignedLong.valueOf(disparityInSeconds);\n+    final UnsignedLong maxTime = store.getTime().plus(maxOffset);\n+    UnsignedLong maxCurrSlot = getCurrentSlot(maxTime, store.getGenesisTime());\n+    return block.getSlot().compareTo(maxCurrSlot) > 0;\n+  }\n+\n+  private boolean blockSlotIsGreaterThanLatestFinalizedSlot(SignedBeaconBlock block) {\n+    UnsignedLong finalizedSlot =\n+        recentChainData.getStore().getFinalizedCheckpoint().getEpochStartSlot();\n+    return block.getSlot().compareTo(finalizedSlot) > 0;\n+  }\n+\n+  private boolean blockIsFirstBlockWithValidSignatureForSlot(SignedBeaconBlock block) {\n+    return !receivedValidBlockInfoSet.contains(new SlotAndProposer(block));\n+  }\n+\n+  private boolean blockSignatureIsValidWithRespectToProposerIndex(\n+      SignedBeaconBlock block, BeaconState preState, BeaconState postState) {\n+    Validator proposer =\n+        postState\n+            .getValidators()\n+            .get(toIntExact(block.getMessage().getProposer_index().longValue()));\n+\n+    final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n+    final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n+    final BLSSignature signature = block.getSignature();\n+    boolean signatureValid = BLS.verify(proposer.getPubkey(), signing_root, signature);\n+\n+    return signatureValid && receivedValidBlockInfoSet.add(new SlotAndProposer(block));\n+  }\n+\n+  private boolean blockIsProposedByTheExpectedProposer(\n+      SignedBeaconBlock block, BeaconState postState) {\n+    final int proposerIndex = get_beacon_proposer_index(postState);\n+    return proposerIndex == toIntExact(block.getMessage().getProposer_index().longValue());", "originalCommit": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1NDIwNQ==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411554205", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-04-20T17:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5MjYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5Mzg4Nw==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411093887", "bodyText": "Still need a test for a block that's not from the future, but that we don't have the parent for.", "author": "ajsutton", "createdAt": "2020-04-20T05:00:15Z", "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/gossip/BlockValidatorTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.signatures.Signer;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidationResult;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidator;\n+import tech.pegasys.artemis.statetransition.BeaconChainUtil;\n+import tech.pegasys.artemis.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+public class BlockValidatorTest {", "originalCommit": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1NzczMw==", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411557733", "bodyText": "added.", "author": "cemozerr", "createdAt": "2020-04-20T17:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5Mzg4Nw=="}], "type": "inlineReview"}, {"oid": "f707197c5e1fa43257c08e3c2fcd10ac36b5754f", "url": "https://github.com/ConsenSys/teku/commit/f707197c5e1fa43257c08e3c2fcd10ac36b5754f", "message": "Resolve comments", "committedDate": "2020-04-20T17:27:10Z", "type": "commit"}, {"oid": "96cdd4164520357d3a13fe0049d25dc63fdf58e5", "url": "https://github.com/ConsenSys/teku/commit/96cdd4164520357d3a13fe0049d25dc63fdf58e5", "message": "Merge remote-tracking branch 'remotes/origin/master' into validateBlocks\n\n# Conflicts:\n#\tnetworking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/ActiveEth2Network.java\n#\tutil/src/main/java/tech/pegasys/artemis/util/config/Constants.java", "committedDate": "2020-04-20T17:30:19Z", "type": "commit"}, {"oid": "810641e08e15ffb87ebfce104e77bcbf0c47db2b", "url": "https://github.com/ConsenSys/teku/commit/810641e08e15ffb87ebfce104e77bcbf0c47db2b", "message": "Merge branch 'master' into validateBlocks", "committedDate": "2020-04-20T17:34:14Z", "type": "commit"}]}