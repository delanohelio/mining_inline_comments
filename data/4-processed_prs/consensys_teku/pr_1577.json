{"pr_number": 1577, "pr_title": "[BC-336] Rework hot state management", "pr_createdAt": "2020-04-13T20:08:22Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1577", "timeline": [{"oid": "056bb4a10117a95bc50efd1f4353f124c8c30d9a", "url": "https://github.com/ConsenSys/teku/commit/056bb4a10117a95bc50efd1f4353f124c8c30d9a", "message": "Prep for new rocksdb version - abstract away db schema from core logic", "committedDate": "2020-04-13T15:14:03Z", "type": "commit"}, {"oid": "c292d4055126bda01dbd7c2ea1eb6f0dd9a6004e", "url": "https://github.com/ConsenSys/teku/commit/c292d4055126bda01dbd7c2ea1eb6f0dd9a6004e", "message": "Add V3 database that keeps hot states in memory only", "committedDate": "2020-04-13T15:14:03Z", "type": "commit"}, {"oid": "a4ecadec62d51a5cf6aa0a586b389dcaffd67835", "url": "https://github.com/ConsenSys/teku/commit/a4ecadec62d51a5cf6aa0a586b389dcaffd67835", "message": "Rework storage tests to use valid chains of blocks", "committedDate": "2020-04-13T15:14:03Z", "type": "commit"}, {"oid": "a610daab0029c64be8c0c4b89fd91e38fbd65bc6", "url": "https://github.com/ConsenSys/teku/commit/a610daab0029c64be8c0c4b89fd91e38fbd65bc6", "message": "Clean up Database tests a bit more", "committedDate": "2020-04-13T15:14:03Z", "type": "commit"}, {"oid": "7fd08cbf3368e1e871c8521d007981fe70f639fb", "url": "https://github.com/ConsenSys/teku/commit/7fd08cbf3368e1e871c8521d007981fe70f639fb", "message": "Add method for getting root from SignedBeaconBlock", "committedDate": "2020-04-13T15:49:49Z", "type": "commit"}, {"oid": "dc027f8317839aed236dc08c3f8ade9e58aab42c", "url": "https://github.com/ConsenSys/teku/commit/dc027f8317839aed236dc08c3f8ade9e58aab42c", "message": "Make ChainBuilder API's more explicit", "committedDate": "2020-04-13T15:50:01Z", "type": "commit"}, {"oid": "86c2a80d4aa443bf928208e6ba07dfa1bb1b9aee", "url": "https://github.com/ConsenSys/teku/commit/86c2a80d4aa443bf928208e6ba07dfa1bb1b9aee", "message": "Fix test, consolidate common logic, add v3 test for unrecoverable forks", "committedDate": "2020-04-13T19:50:47Z", "type": "commit"}, {"oid": "ae63340aa787b47d13c7b7ebb25c1106f41f46dd", "url": "https://github.com/ConsenSys/teku/commit/ae63340aa787b47d13c7b7ebb25c1106f41f46dd", "message": "Make v3 columns contiguous", "committedDate": "2020-04-13T19:54:50Z", "type": "commit"}, {"oid": "84f04a7ad1a68c78019cc9e29c691d7f1f38a83b", "url": "https://github.com/ConsenSys/teku/commit/84f04a7ad1a68c78019cc9e29c691d7f1f38a83b", "message": "Move attestation generator into core package", "committedDate": "2020-04-14T17:15:26Z", "type": "commit"}, {"oid": "4fa5d8c0895f834b6dd4bd4b91962afa25fea44d", "url": "https://github.com/ConsenSys/teku/commit/4fa5d8c0895f834b6dd4bd4b91962afa25fea44d", "message": "Merge BlockAndState with BeaconBlockAndState", "committedDate": "2020-04-14T18:24:20Z", "type": "commit"}, {"oid": "a0584eebd54da2ed0ea6225e6e6454ce7ab07414", "url": "https://github.com/ConsenSys/teku/commit/a0584eebd54da2ed0ea6225e6e6454ce7ab07414", "message": "Fix update of hotRootsBySlotCache, add tests\n\nAdd test utility for generating attestions to include in blocks. Fix\nhotBySlot updates to update properly across multiple commits.", "committedDate": "2020-04-14T18:35:27Z", "type": "commit"}, {"oid": "fbe3b860f142757f638fb6ebeaf439e2dd1bfedb", "url": "https://github.com/ConsenSys/teku/commit/fbe3b860f142757f638fb6ebeaf439e2dd1bfedb", "message": "Merge branch 'master' into bc-336/rework-hot-state-management", "committedDate": "2020-04-14T18:38:31Z", "type": "commit"}, {"oid": "25aa9d5de28362946166600ae891a18afb979171", "url": "https://github.com/ConsenSys/teku/commit/25aa9d5de28362946166600ae891a18afb979171", "message": "Reconcile upstream changes from master - remove latestMessage handling", "committedDate": "2020-04-14T18:43:44Z", "type": "commit"}, {"oid": "d9b5f428b753770822f2fdfb461653367bf024d9", "url": "https://github.com/ConsenSys/teku/commit/d9b5f428b753770822f2fdfb461653367bf024d9", "message": "Fix ChainDataProvider tests", "committedDate": "2020-04-14T19:12:05Z", "type": "commit"}, {"oid": "5501f8edb9ce3a78c5ac68397d1c0973f35dc54f", "url": "https://github.com/ConsenSys/teku/commit/5501f8edb9ce3a78c5ac68397d1c0973f35dc54f", "message": "Fix BlockImporter tests", "committedDate": "2020-04-14T19:20:36Z", "type": "commit"}, {"oid": "791b0b393ede933fef2b164852986fb884f02ca1", "url": "https://github.com/ConsenSys/teku/commit/791b0b393ede933fef2b164852986fb884f02ca1", "message": "Fix gossip tests", "committedDate": "2020-04-14T19:46:34Z", "type": "commit"}, {"oid": "fec390bbc6fabe590d84f11abade72f9d0bcc12c", "url": "https://github.com/ConsenSys/teku/commit/fec390bbc6fabe590d84f11abade72f9d0bcc12c", "message": "Fix validator index iteration", "committedDate": "2020-04-14T20:14:08Z", "type": "commit"}, {"oid": "4ed633fd246d9b79e5993e7540902b56b5c886c8", "url": "https://github.com/ConsenSys/teku/commit/4ed633fd246d9b79e5993e7540902b56b5c886c8", "message": "Fix AttestationAggregatorTest\n\nTests assume produced attestation is for a committee of size > 1", "committedDate": "2020-04-14T20:48:34Z", "type": "commit"}, {"oid": "3bc4c4b5557c8499137d9bd71915aec5a9343e52", "url": "https://github.com/ConsenSys/teku/commit/3bc4c4b5557c8499137d9bd71915aec5a9343e52", "message": "Fix ValidatorApiHandlerTest", "committedDate": "2020-04-14T21:17:01Z", "type": "commit"}, {"oid": "f09565612ab7928e7ee7836b64998a50bf0c8d2e", "url": "https://github.com/ConsenSys/teku/commit/f09565612ab7928e7ee7836b64998a50bf0c8d2e", "message": "Clean up", "committedDate": "2020-04-14T21:17:30Z", "type": "commit"}, {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c", "url": "https://github.com/ConsenSys/teku/commit/e40f58a1d95340bb76fc249260f11c1de9c5ee9c", "message": "Merge branch 'master' into bc-336/rework-hot-state-management", "committedDate": "2020-04-14T21:29:24Z", "type": "commit"}, {"oid": "aa1c56795bf04344d0b79860ac4f92dd9d7df820", "url": "https://github.com/ConsenSys/teku/commit/aa1c56795bf04344d0b79860ac4f92dd9d7df820", "message": "Make v3 default database version", "committedDate": "2020-04-14T22:04:34Z", "type": "commit"}, {"oid": "0a65efb823b211e82b1c79063b25910c753f5918", "url": "https://github.com/ConsenSys/teku/commit/0a65efb823b211e82b1c79063b25910c753f5918", "message": "Fix genesis persistence", "committedDate": "2020-04-14T22:24:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NjU2MA==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408466560", "bodyText": "nit: checkArgument can actually do the format for you:\ncheckArgument(\n    preState.getSlot().compareTo(slot) <= 0,\n    \"process_slots: State slot %s higher than given slot %s\", preState.getSlot(), slot);", "author": "ajsutton", "createdAt": "2020-04-14T22:11:52Z", "path": "ethereum/core/src/main/java/tech/pegasys/artemis/core/StateTransition.java", "diffHunk": "@@ -208,7 +208,8 @@ public BeaconState process_slots(BeaconState preState, UnsignedLong slot)\n     try {\n       checkArgument(\n           preState.getSlot().compareTo(slot) <= 0,\n-          \"process_slots: State slot higher than given slot\");\n+          String.format(\n+              \"process_slots: State slot %s higher than given slot %s\", preState.getSlot(), slot));", "originalCommit": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDc5NQ==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408470795", "bodyText": "Nice to see these block and state data structures getting sorted out.", "author": "ajsutton", "createdAt": "2020-04-14T22:22:27Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/blocks/BeaconBlockAndState.java", "diffHunk": "@@ -13,24 +13,27 @@\n \n package tech.pegasys.artemis.datastructures.blocks;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n+\n import com.google.common.base.MoreObjects;\n+import com.google.common.primitives.UnsignedLong;\n import java.util.Objects;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.artemis.datastructures.state.BeaconState;\n \n+/** Helper datastructure that holds an unsigned block with its corresponding state */\n public class BeaconBlockAndState {", "originalCommit": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MTc2Mg==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408471762", "bodyText": "Not quite sure how we wound up with MessageSignerService in datastructures as it's actually a service.  Makes sense to have the LoalMessageSignerService with it, but we may need to think about moving them both somewhere more sensible (core? maybe even a dedicated module?).  Outside of the scope of this PR though I think.", "author": "ajsutton", "createdAt": "2020-04-14T22:24:54Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/validator/LocalMessageSignerService.java", "diffHunk": "@@ -11,13 +11,12 @@\n  * specific language governing permissions and limitations under the License.\n  */\n \n-package tech.pegasys.artemis.validator.client.signer;\n+package tech.pegasys.artemis.datastructures.validator;", "originalCommit": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg3OTQ1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408879456", "bodyText": "Went ahead and move them into core.signatures", "author": "mbaxter", "createdAt": "2020-04-15T14:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MTc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NjQ2OQ==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408476469", "bodyText": "Greater than seems wrong here.  We should be removing hot blocks that are less than the finalised slot. I think we are doing that given that we're getting the headMap in the updater so just the name that's wrong.", "author": "ajsutton", "createdAt": "2020-04-14T22:37:32Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -259,52 +241,33 @@ private void addHotBlock(\n       return Collections.emptySet();\n     }\n     final UnsignedLong finalizedSlot = newlyFinalizedBlock.get().getSlot();\n-    final ConcurrentNavigableMap<UnsignedLong, Set<Bytes32>> toRemove =\n-        hotRootsBySlotCache.headMap(finalizedSlot);\n-    LOG.trace(\"Pruning slots {} from non-finalized pool\", toRemove::keySet);\n-    final Set<Bytes32> prunedRoots =\n-        toRemove.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n-    for (Set<Bytes32> hotRoots : toRemove.values()) {\n-      for (Bytes32 root : hotRoots) {\n-        transaction.delete(V2Schema.HOT_STATES_BY_ROOT, root);\n-        transaction.delete(V2Schema.HOT_BLOCKS_BY_ROOT, root);\n-      }\n-    }\n-    hotRootsBySlotCache.keySet().removeAll(toRemove.keySet());\n-    return prunedRoots;\n+    return updater.pruneHotBlocksAtSlotsGreaterThan(finalizedSlot);", "originalCommit": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4MTYwMw==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408881603", "bodyText": "whoops - fixed", "author": "mbaxter", "createdAt": "2020-04-15T14:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NjQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3ODAyMg==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408478022", "bodyText": "It shouldn't ever matter, but should we set this to false up at line 269 when we actually find a finalised state.  That way if for some reason we miss one we're record the latest finalised state we do have rather than not updating it at all.", "author": "ajsutton", "createdAt": "2020-04-14T22:41:41Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -313,6 +276,7 @@ private void recordFinalizedBlocks(\n       }\n \n       // Update for next round of iteration\n+      isLatestFinalizedBlock = false;", "originalCommit": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4MjY4Mw==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408882683", "bodyText": "good call", "author": "mbaxter", "createdAt": "2020-04-15T14:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3ODAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3OTY2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408479661", "bodyText": "Non-canonical forks or forks that have a different finalised state (ie invalid/incompatible)?", "author": "ajsutton", "createdAt": "2020-04-14T22:46:20Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.dataaccess;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.StateTransitionException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.ColumnEntry;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance.Transaction;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.V3Schema;\n+\n+public class V3RocksDbDao implements RocksDbDAO {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  // Persistent data\n+  private final RocksDbInstance db;\n+  // In-memory data\n+  private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache =\n+      new ConcurrentSkipListMap<>();\n+  private final Map<Bytes32, BeaconState> hotStates = new ConcurrentHashMap<>();\n+\n+  public V3RocksDbDao(final RocksDbInstance db) {\n+    this.db = db;\n+    initialize();\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getGenesisTime() {\n+    return db.get(V3Schema.GENESIS_TIME);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getJustifiedCheckpoint() {\n+    return db.get(V3Schema.JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getBestJustifiedCheckpoint() {\n+    return db.get(V3Schema.BEST_JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getFinalizedCheckpoint() {\n+    return db.get(V3Schema.FINALIZED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getHighestFinalizedSlot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getKey);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.get(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getLatestFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.getFloorEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getHotBlock(final Bytes32 root) {\n+    return db.get(V3Schema.HOT_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getFinalizedBlock(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getHotState(final Bytes32 root) {\n+    return Optional.ofNullable(hotStates.get(root));\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getFinalizedState(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_STATES_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, SignedBeaconBlock> getHotBlocks() {\n+    return db.getAll(V3Schema.HOT_BLOCKS_BY_ROOT);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, BeaconState> getHotStates() {\n+    return new HashMap<>(hotStates);\n+  }\n+\n+  @Override\n+  public Map<Checkpoint, BeaconState> getCheckpointStates() {\n+    return db.getAll(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  @Override\n+  public Stream<ColumnEntry<Checkpoint, BeaconState>> streamCheckpointStates() {\n+    return db.stream(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  private Optional<BeaconState> getLatestFinalizedState() {\n+    return db.get(V3Schema.LATEST_FINALIZED_STATE);\n+  }\n+\n+  public Optional<Bytes32> getLatestFinalizedRoot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Updater updater() {\n+    return new V3Updater(db, hotRootsBySlotCache, hotStates);\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    hotRootsBySlotCache.clear();\n+    db.close();\n+  }\n+\n+  private void initialize() {\n+    final Optional<BeaconState> finalizedState = getLatestFinalizedState();\n+    final Optional<Bytes32> finalizedRoot = getLatestFinalizedRoot();\n+    final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot = getHotBlocks();\n+\n+    if (finalizedRoot.isEmpty() && finalizedState.isEmpty() && hotBlocksByRoot.isEmpty()) {\n+      // Database is empty, nothing to initialize\n+      LOG.trace(\"Database appears to be empty.  Skip initialization of hot states.\");\n+      return;\n+    } else if (finalizedRoot.isEmpty() || finalizedState.isEmpty()) {\n+      throw new DatabaseStorageException(\"Missing latest finalized block information\");\n+    }\n+\n+    initializeHotStates(finalizedRoot.get(), finalizedState.get(), hotBlocksByRoot);\n+  }\n+\n+  private void initializeHotStates(\n+      final Bytes32 finalizedRoot,\n+      final BeaconState finalizedState,\n+      final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot) {\n+    // Initialize hot states with latest finalized state\n+    hotStates.put(finalizedRoot, finalizedState);\n+\n+    // Index blocks by parent root\n+    final Map<Bytes32, List<SignedBeaconBlock>> blocksByParent = new HashMap<>();\n+    for (Entry<Bytes32, SignedBeaconBlock> hotBlockEntry : hotBlocksByRoot.entrySet()) {\n+      final SignedBeaconBlock currentBlock = hotBlockEntry.getValue();\n+      final List<SignedBeaconBlock> blockList =\n+          blocksByParent.computeIfAbsent(currentBlock.getParent_root(), (key) -> new ArrayList<>());\n+      blockList.add(currentBlock);\n+    }\n+\n+    // Generate remaining hot states\n+    final Deque<Bytes32> parentRoots = new ArrayDeque<>();\n+    parentRoots.push(finalizedRoot);\n+    while (!parentRoots.isEmpty()) {\n+      final Bytes32 parentRoot = parentRoots.pop();\n+      final BeaconState parentState = hotStates.get(parentRoot);\n+      final List<SignedBeaconBlock> blocks =\n+          blocksByParent.computeIfAbsent(parentRoot, (key) -> Collections.emptyList());\n+      for (SignedBeaconBlock block : blocks) {\n+        final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n+        processBlock(parentState, block)\n+            .ifPresent(\n+                state -> {\n+                  hotStates.put(blockRoot, state);\n+                  parentRoots.push(blockRoot);\n+                });\n+      }\n+    }\n+\n+    if (hotStates.size() != hotBlocksByRoot.size()) {\n+      LOG.trace(\n+          \"Only {} hot states produced for {} hot blocks.  Some hot blocks must belong to non-canonical forks.\",", "originalCommit": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4ODUwNw==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408888507", "bodyText": "Hmm - I guess I've been using canonical to mean descending from the latest finalized block.    Will try to clarify.", "author": "mbaxter", "createdAt": "2020-04-15T14:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3OTY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MDEzOQ==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408480139", "bodyText": "We should probably print a message via StatusLogger to indicate that we're reloading the hot states and then when we complete.  The process will take a little bit of time so we should let the user know what's going on.", "author": "ajsutton", "createdAt": "2020-04-14T22:47:39Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.dataaccess;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.StateTransitionException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.ColumnEntry;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance.Transaction;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.V3Schema;\n+\n+public class V3RocksDbDao implements RocksDbDAO {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  // Persistent data\n+  private final RocksDbInstance db;\n+  // In-memory data\n+  private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache =\n+      new ConcurrentSkipListMap<>();\n+  private final Map<Bytes32, BeaconState> hotStates = new ConcurrentHashMap<>();\n+\n+  public V3RocksDbDao(final RocksDbInstance db) {\n+    this.db = db;\n+    initialize();\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getGenesisTime() {\n+    return db.get(V3Schema.GENESIS_TIME);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getJustifiedCheckpoint() {\n+    return db.get(V3Schema.JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getBestJustifiedCheckpoint() {\n+    return db.get(V3Schema.BEST_JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getFinalizedCheckpoint() {\n+    return db.get(V3Schema.FINALIZED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getHighestFinalizedSlot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getKey);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.get(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getLatestFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.getFloorEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getHotBlock(final Bytes32 root) {\n+    return db.get(V3Schema.HOT_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getFinalizedBlock(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getHotState(final Bytes32 root) {\n+    return Optional.ofNullable(hotStates.get(root));\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getFinalizedState(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_STATES_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, SignedBeaconBlock> getHotBlocks() {\n+    return db.getAll(V3Schema.HOT_BLOCKS_BY_ROOT);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, BeaconState> getHotStates() {\n+    return new HashMap<>(hotStates);\n+  }\n+\n+  @Override\n+  public Map<Checkpoint, BeaconState> getCheckpointStates() {\n+    return db.getAll(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  @Override\n+  public Stream<ColumnEntry<Checkpoint, BeaconState>> streamCheckpointStates() {\n+    return db.stream(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  private Optional<BeaconState> getLatestFinalizedState() {\n+    return db.get(V3Schema.LATEST_FINALIZED_STATE);\n+  }\n+\n+  public Optional<Bytes32> getLatestFinalizedRoot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Updater updater() {\n+    return new V3Updater(db, hotRootsBySlotCache, hotStates);\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    hotRootsBySlotCache.clear();\n+    db.close();\n+  }\n+\n+  private void initialize() {", "originalCommit": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyNzIwOQ==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408927209", "bodyText": "This seemed kind of low-level / implementation-specific compared to the other StatusLogger messages.  So, I just added some Logger.info messages here, and then added some StatusLogger messages around chain data initialization as a whole (including hydrating the initial Store).", "author": "mbaxter", "createdAt": "2020-04-15T15:21:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MDEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MTE4OQ==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408481189", "bodyText": "headMap returns a live view so we may not want to putAll into it or we've effectively committed part of this transaction early. It should be safe to do it the other way around though (putAll into hotRootsBySlotAdditions.headMap).", "author": "ajsutton", "createdAt": "2020-04-14T22:50:34Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.dataaccess;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.StateTransitionException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.ColumnEntry;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance.Transaction;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.V3Schema;\n+\n+public class V3RocksDbDao implements RocksDbDAO {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  // Persistent data\n+  private final RocksDbInstance db;\n+  // In-memory data\n+  private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache =\n+      new ConcurrentSkipListMap<>();\n+  private final Map<Bytes32, BeaconState> hotStates = new ConcurrentHashMap<>();\n+\n+  public V3RocksDbDao(final RocksDbInstance db) {\n+    this.db = db;\n+    initialize();\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getGenesisTime() {\n+    return db.get(V3Schema.GENESIS_TIME);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getJustifiedCheckpoint() {\n+    return db.get(V3Schema.JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getBestJustifiedCheckpoint() {\n+    return db.get(V3Schema.BEST_JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getFinalizedCheckpoint() {\n+    return db.get(V3Schema.FINALIZED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getHighestFinalizedSlot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getKey);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.get(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getLatestFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.getFloorEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getHotBlock(final Bytes32 root) {\n+    return db.get(V3Schema.HOT_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getFinalizedBlock(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getHotState(final Bytes32 root) {\n+    return Optional.ofNullable(hotStates.get(root));\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getFinalizedState(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_STATES_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, SignedBeaconBlock> getHotBlocks() {\n+    return db.getAll(V3Schema.HOT_BLOCKS_BY_ROOT);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, BeaconState> getHotStates() {\n+    return new HashMap<>(hotStates);\n+  }\n+\n+  @Override\n+  public Map<Checkpoint, BeaconState> getCheckpointStates() {\n+    return db.getAll(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  @Override\n+  public Stream<ColumnEntry<Checkpoint, BeaconState>> streamCheckpointStates() {\n+    return db.stream(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  private Optional<BeaconState> getLatestFinalizedState() {\n+    return db.get(V3Schema.LATEST_FINALIZED_STATE);\n+  }\n+\n+  public Optional<Bytes32> getLatestFinalizedRoot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Updater updater() {\n+    return new V3Updater(db, hotRootsBySlotCache, hotStates);\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    hotRootsBySlotCache.clear();\n+    db.close();\n+  }\n+\n+  private void initialize() {\n+    final Optional<BeaconState> finalizedState = getLatestFinalizedState();\n+    final Optional<Bytes32> finalizedRoot = getLatestFinalizedRoot();\n+    final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot = getHotBlocks();\n+\n+    if (finalizedRoot.isEmpty() && finalizedState.isEmpty() && hotBlocksByRoot.isEmpty()) {\n+      // Database is empty, nothing to initialize\n+      LOG.trace(\"Database appears to be empty.  Skip initialization of hot states.\");\n+      return;\n+    } else if (finalizedRoot.isEmpty() || finalizedState.isEmpty()) {\n+      throw new DatabaseStorageException(\"Missing latest finalized block information\");\n+    }\n+\n+    initializeHotStates(finalizedRoot.get(), finalizedState.get(), hotBlocksByRoot);\n+  }\n+\n+  private void initializeHotStates(\n+      final Bytes32 finalizedRoot,\n+      final BeaconState finalizedState,\n+      final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot) {\n+    // Initialize hot states with latest finalized state\n+    hotStates.put(finalizedRoot, finalizedState);\n+\n+    // Index blocks by parent root\n+    final Map<Bytes32, List<SignedBeaconBlock>> blocksByParent = new HashMap<>();\n+    for (Entry<Bytes32, SignedBeaconBlock> hotBlockEntry : hotBlocksByRoot.entrySet()) {\n+      final SignedBeaconBlock currentBlock = hotBlockEntry.getValue();\n+      final List<SignedBeaconBlock> blockList =\n+          blocksByParent.computeIfAbsent(currentBlock.getParent_root(), (key) -> new ArrayList<>());\n+      blockList.add(currentBlock);\n+    }\n+\n+    // Generate remaining hot states\n+    final Deque<Bytes32> parentRoots = new ArrayDeque<>();\n+    parentRoots.push(finalizedRoot);\n+    while (!parentRoots.isEmpty()) {\n+      final Bytes32 parentRoot = parentRoots.pop();\n+      final BeaconState parentState = hotStates.get(parentRoot);\n+      final List<SignedBeaconBlock> blocks =\n+          blocksByParent.computeIfAbsent(parentRoot, (key) -> Collections.emptyList());\n+      for (SignedBeaconBlock block : blocks) {\n+        final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n+        processBlock(parentState, block)\n+            .ifPresent(\n+                state -> {\n+                  hotStates.put(blockRoot, state);\n+                  parentRoots.push(blockRoot);\n+                });\n+      }\n+    }\n+\n+    if (hotStates.size() != hotBlocksByRoot.size()) {\n+      LOG.trace(\n+          \"Only {} hot states produced for {} hot blocks.  Some hot blocks must belong to non-canonical forks.\",\n+          hotStates.size(),\n+          hotBlocksByRoot.size());\n+    }\n+  }\n+\n+  private final Optional<BeaconState> processBlock(\n+      final BeaconState preState, final SignedBeaconBlock block) {\n+    StateTransition stateTransition = new StateTransition();\n+    try {\n+      final BeaconState postState = stateTransition.initiate(preState, block);\n+      return Optional.of(postState);\n+    } catch (StateTransitionException e) {\n+      LOG.error(\n+          \"Unable to produce state for block at slot {} ({})\",\n+          block.getSlot(),\n+          block.getMessage().hash_tree_root());\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static class V3Updater implements Updater {\n+\n+    private final Transaction transaction;\n+    private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache;\n+    private final Map<Bytes32, BeaconState> hotStates;\n+\n+    // Hot root by slot updates\n+    private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotAdditions =\n+        new ConcurrentSkipListMap<>();\n+    private final Set<UnsignedLong> prunedSlots = new HashSet<>();\n+\n+    // Hot state updates\n+    private final Map<Bytes32, BeaconState> newHotStates = new HashMap<>();\n+    private final Set<Bytes32> deletedStates = new HashSet<>();\n+\n+    V3Updater(\n+        final RocksDbInstance db,\n+        final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache,\n+        final Map<Bytes32, BeaconState> hotStates) {\n+      this.transaction = db.startTransaction();\n+      this.hotRootsBySlotCache = hotRootsBySlotCache;\n+      this.hotStates = hotStates;\n+    }\n+\n+    @Override\n+    public void setGenesisTime(final UnsignedLong genesisTime) {\n+      transaction.put(V3Schema.GENESIS_TIME, genesisTime);\n+    }\n+\n+    @Override\n+    public void setJustifiedCheckpoint(final Checkpoint checkpoint) {\n+      transaction.put(V3Schema.JUSTIFIED_CHECKPOINT, checkpoint);\n+    }\n+\n+    @Override\n+    public void setBestJustifiedCheckpoint(final Checkpoint checkpoint) {\n+      transaction.put(V3Schema.BEST_JUSTIFIED_CHECKPOINT, checkpoint);\n+    }\n+\n+    @Override\n+    public void setLatestFinalizedState(final BeaconState state) {\n+      transaction.put(V3Schema.LATEST_FINALIZED_STATE, state);\n+    }\n+\n+    @Override\n+    public void setFinalizedCheckpoint(final Checkpoint checkpoint) {\n+      transaction.put(V3Schema.FINALIZED_CHECKPOINT, checkpoint);\n+    }\n+\n+    @Override\n+    public void addCheckpointState(final Checkpoint checkpoint, final BeaconState state) {\n+      transaction.put(V3Schema.CHECKPOINT_STATES, checkpoint, state);\n+    }\n+\n+    @Override\n+    public void addCheckpointStates(final Map<Checkpoint, BeaconState> checkpointStates) {\n+      checkpointStates.forEach(this::addCheckpointState);\n+    }\n+\n+    @Override\n+    public void addHotBlock(final SignedBeaconBlock block) {\n+      final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n+      transaction.put(V3Schema.HOT_BLOCKS_BY_ROOT, blockRoot, block);\n+      hotRootsBySlotAdditions\n+          .computeIfAbsent(block.getSlot(), key -> new HashSet<>())\n+          .add(blockRoot);\n+    }\n+\n+    @Override\n+    public void addFinalizedBlock(final SignedBeaconBlock block) {\n+      final Bytes32 root = block.getMessage().hash_tree_root();\n+      transaction.put(V3Schema.FINALIZED_ROOTS_BY_SLOT, block.getSlot(), root);\n+      transaction.put(V3Schema.FINALIZED_BLOCKS_BY_ROOT, root, block);\n+    }\n+\n+    @Override\n+    public void addHotState(final Bytes32 blockRoot, final BeaconState state) {\n+      newHotStates.put(blockRoot, state);\n+    }\n+\n+    @Override\n+    public void addFinalizedState(final Bytes32 blockRoot, final BeaconState state) {\n+      transaction.put(V3Schema.FINALIZED_STATES_BY_ROOT, blockRoot, state);\n+    }\n+\n+    @Override\n+    public void addHotBlocks(final Map<Bytes32, SignedBeaconBlock> blocks) {\n+      blocks.values().forEach(this::addHotBlock);\n+    }\n+\n+    @Override\n+    public void addHotStates(final Map<Bytes32, BeaconState> states) {\n+      states.forEach(this::addHotState);\n+    }\n+\n+    @Override\n+    public void deleteCheckpointState(final Checkpoint checkpoint) {\n+      transaction.delete(V3Schema.CHECKPOINT_STATES, checkpoint);\n+    }\n+\n+    @Override\n+    public Set<Bytes32> pruneHotBlocksAtSlotsGreaterThan(final UnsignedLong slot) {\n+      final Map<UnsignedLong, Set<Bytes32>> toRemove = hotRootsBySlotCache.headMap(slot);\n+      toRemove.putAll(hotRootsBySlotAdditions.headMap(slot));", "originalCommit": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NzA4Mw==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408897083", "bodyText": "good catch!", "author": "mbaxter", "createdAt": "2020-04-15T14:42:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MTE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4Mzc2NA==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408483764", "bodyText": "nit: Should be RocksDbDao.", "author": "ajsutton", "createdAt": "2020-04-14T22:57:51Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/RocksDbDAO.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.dataaccess;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.ColumnEntry;\n+\n+/**\n+ * A RocksDB \"data access object\" interface to abstract interactions with underlying database.\n+ *\n+ * @see <a href=\"https://en.wikipedia.org/wiki/Data_access_object\">DAO</a>\n+ */\n+public interface RocksDbDAO extends AutoCloseable {", "originalCommit": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5MTI2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408491261", "bodyText": "Should this be PRUNE not ARCHIVE?", "author": "ajsutton", "createdAt": "2020-04-14T23:20:20Z", "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/rocksdb/V3RocksDbDatabaseTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import com.google.common.collect.Streams;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import tech.pegasys.artemis.core.ChainBuilder;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.storage.server.Database;\n+import tech.pegasys.artemis.storage.server.StateStorageMode;\n+\n+public class V3RocksDbDatabaseTest extends AbstractRocksDbDatabaseTest {\n+\n+  @Override\n+  protected Database createDatabase(final File tempDir, final StateStorageMode storageMode) {\n+    final RocksDbConfiguration config = RocksDbConfiguration.withDataDirectory(tempDir.toPath());\n+    return RocksDbDatabase.createV3(config, storageMode);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_archive(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_prune(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);", "originalCommit": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5Nzk1OQ==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408897959", "bodyText": "yep - good catch", "author": "mbaxter", "createdAt": "2020-04-15T14:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5MTI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5NDQwOQ==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408494409", "bodyText": "Doesn't need to be addressed in this PR but we should actually be removing those blocks from the hot state and rejecting any new blocks that build on them.   Not sure if we're just wasting memory at the moment or if we're considering them as part of fork choice and might try to switch to a fork that conflicts with our finalised blocks.", "author": "ajsutton", "createdAt": "2020-04-14T23:30:11Z", "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/rocksdb/V3RocksDbDatabaseTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import com.google.common.collect.Streams;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import tech.pegasys.artemis.core.ChainBuilder;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.storage.server.Database;\n+import tech.pegasys.artemis.storage.server.StateStorageMode;\n+\n+public class V3RocksDbDatabaseTest extends AbstractRocksDbDatabaseTest {\n+\n+  @Override\n+  protected Database createDatabase(final File tempDir, final StateStorageMode storageMode) {\n+    final RocksDbConfiguration config = RocksDbConfiguration.withDataDirectory(tempDir.toPath());\n+    return RocksDbDatabase.createV3(config, storageMode);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_archive(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_prune(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);\n+  }\n+\n+  private void testShouldHandleRestartWithUnrecoverableForkBlocks(", "originalCommit": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTgyNQ==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408901825", "bodyText": "I'm pretty sure we're just wasting memory right now.  We shouldn't be importing blocks or choosing head blocks that don't descend from the latest finalized block.\nI'll log a ticket to follow-up though.", "author": "mbaxter", "createdAt": "2020-04-15T14:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5NDQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzMzc5NA==", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408933794", "bodyText": "Ticket: https://pegasys1.atlassian.net/browse/BC-353", "author": "mbaxter", "createdAt": "2020-04-15T15:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5NDQwOQ=="}], "type": "inlineReview"}, {"oid": "505056f1363a08e598846808548ef201e636e865", "url": "https://github.com/ConsenSys/teku/commit/505056f1363a08e598846808548ef201e636e865", "message": "Simplify IllegalArgument message formatting", "committedDate": "2020-04-15T14:14:28Z", "type": "commit"}, {"oid": "da7a8be691ba920ac2844b5bc7d9ed477797624e", "url": "https://github.com/ConsenSys/teku/commit/da7a8be691ba920ac2844b5bc7d9ed477797624e", "message": "Move signature utilities to core", "committedDate": "2020-04-15T14:19:17Z", "type": "commit"}, {"oid": "bf17bee52dada77fe6ae91c97949bc44245d0bfd", "url": "https://github.com/ConsenSys/teku/commit/bf17bee52dada77fe6ae91c97949bc44245d0bfd", "message": "Address the bulk of review feedback", "committedDate": "2020-04-15T14:50:35Z", "type": "commit"}, {"oid": "ef629ab7ed9b8356b4574b4db1948f673ee43792", "url": "https://github.com/ConsenSys/teku/commit/ef629ab7ed9b8356b4574b4db1948f673ee43792", "message": "Add logging around initializing hot states", "committedDate": "2020-04-15T14:53:51Z", "type": "commit"}, {"oid": "8b65c22fdcb0a19868a13b3907476ee9d40da7ea", "url": "https://github.com/ConsenSys/teku/commit/8b65c22fdcb0a19868a13b3907476ee9d40da7ea", "message": "Merge branch 'master' into bc-336/rework-hot-state-management", "committedDate": "2020-04-15T15:08:05Z", "type": "commit"}, {"oid": "cde2d2bdb66cfa2ab8fdb348fc4760f5e296bb0c", "url": "https://github.com/ConsenSys/teku/commit/cde2d2bdb66cfa2ab8fdb348fc4760f5e296bb0c", "message": "Add status logging around chain data initialization", "committedDate": "2020-04-15T15:19:07Z", "type": "commit"}, {"oid": "a37b75728ddf24ad9da06c6b3a9541fedb9bf672", "url": "https://github.com/ConsenSys/teku/commit/a37b75728ddf24ad9da06c6b3a9541fedb9bf672", "message": "Remove unused logger", "committedDate": "2020-04-15T15:27:03Z", "type": "commit"}]}