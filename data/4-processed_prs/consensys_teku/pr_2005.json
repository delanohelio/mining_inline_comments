{"pr_number": 2005, "pr_title": "Fix snappy blocking", "pr_createdAt": "2020-05-29T14:19:53Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2005", "timeline": [{"oid": "ced53b2f5c8a89e2861e69b1f0fdc99dfc60c8a9", "url": "https://github.com/ConsenSys/teku/commit/ced53b2f5c8a89e2861e69b1f0fdc99dfc60c8a9", "message": "Experimental snappy decoder", "committedDate": "2020-05-29T13:34:40Z", "type": "commit"}, {"oid": "c7177049a53d76a82f97fc335e8169ca8ba6e306", "url": "https://github.com/ConsenSys/teku/commit/c7177049a53d76a82f97fc335e8169ca8ba6e306", "message": "Add initial draft of Netty decoder for Snappy compressed RPC response chunks", "committedDate": "2020-05-29T14:15:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzMjE4MA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r432532180", "bodyText": "Don't we want to decode regardless of the responseCode?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (respCode == 0 && compressed) {\n          \n          \n            \n                  if (compressed) {", "author": "mbaxter", "createdAt": "2020-05-29T14:39:33Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/RpcResponseChunkDecoder.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import static java.lang.Integer.min;\n+\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.compression.SnappyFrameDecoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Netty decoder which decodes ssz_snappy or raw ssz Eth2 RPC response chunks from inbound response\n+ * stream\n+ */\n+public class RpcResponseChunkDecoder extends SnappyFrameDecoder {\n+\n+  private final boolean compressed;\n+  private int respCode;\n+  private long remainingRawLength = 0;\n+  private boolean decodePayload = false;\n+  private final List<ByteBuf> rawDataFrames = new ArrayList<>();\n+\n+  /**\n+   * Create a new decoder\n+   *\n+   * @param compressed {@code true} if the stream is Snappy compressed, {@code false} if the stream\n+   *     is plain ssz\n+   */\n+  public RpcResponseChunkDecoder(boolean compressed) {\n+    super(true);\n+    this.compressed = compressed;\n+  }\n+\n+  @Override\n+  protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n+    if (!decodePayload) {\n+      if (in.readableBytes() < 2) {\n+        // wait for more byte to read resp code and length fields\n+        return;\n+      }\n+      int rollbackIndex = in.readerIndex();\n+\n+      byte respCode = in.readByte();\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        in.readerIndex(rollbackIndex);\n+        return;\n+      }\n+      this.respCode = respCode;\n+      this.remainingRawLength = length;\n+      decodePayload = true;\n+    } else {\n+      ArrayList<Object> rawOut = new ArrayList<>();\n+      if (respCode == 0 && compressed) {", "originalCommit": "c7177049a53d76a82f97fc335e8169ca8ba6e306", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzOTMzNA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r432839334", "bodyText": "As I understand from the spec the error payload is not compressed. Is it wrong assumption?", "author": "Nashatyrev", "createdAt": "2020-05-30T12:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzMjE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4ODQzMw==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r433288433", "bodyText": "Yeah, the error payload is treated like any other payload, so if we're using compression the errors should be compressed as well.", "author": "mbaxter", "createdAt": "2020-06-01T15:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzMjE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MjU1OQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r433382559", "bodyText": "Yep, sounds totally reasonable. I'm now not sure what insisted me think differently", "author": "Nashatyrev", "createdAt": "2020-06-01T17:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzMjE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzNzM2Mw==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r432537363", "bodyText": "Should this be a while?:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!rawOut.isEmpty()) {\n          \n          \n            \n                  while (!rawOut.isEmpty()) {", "author": "mbaxter", "createdAt": "2020-05-29T14:47:24Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/RpcResponseChunkDecoder.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import static java.lang.Integer.min;\n+\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.compression.SnappyFrameDecoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Netty decoder which decodes ssz_snappy or raw ssz Eth2 RPC response chunks from inbound response\n+ * stream\n+ */\n+public class RpcResponseChunkDecoder extends SnappyFrameDecoder {\n+\n+  private final boolean compressed;\n+  private int respCode;\n+  private long remainingRawLength = 0;\n+  private boolean decodePayload = false;\n+  private final List<ByteBuf> rawDataFrames = new ArrayList<>();\n+\n+  /**\n+   * Create a new decoder\n+   *\n+   * @param compressed {@code true} if the stream is Snappy compressed, {@code false} if the stream\n+   *     is plain ssz\n+   */\n+  public RpcResponseChunkDecoder(boolean compressed) {\n+    super(true);\n+    this.compressed = compressed;\n+  }\n+\n+  @Override\n+  protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n+    if (!decodePayload) {\n+      if (in.readableBytes() < 2) {\n+        // wait for more byte to read resp code and length fields\n+        return;\n+      }\n+      int rollbackIndex = in.readerIndex();\n+\n+      byte respCode = in.readByte();\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        in.readerIndex(rollbackIndex);\n+        return;\n+      }\n+      this.respCode = respCode;\n+      this.remainingRawLength = length;\n+      decodePayload = true;\n+    } else {\n+      ArrayList<Object> rawOut = new ArrayList<>();\n+      if (respCode == 0 && compressed) {\n+        super.decode(ctx, in, rawOut);\n+      } else {\n+        rawOut.add(in.readSlice(min(in.readableBytes(), (int) remainingRawLength)).retain());\n+      }\n+\n+      if (remainingRawLength == 0) {\n+        // special case for chunk with 0 length\n+        rawOut.add(Unpooled.EMPTY_BUFFER);\n+      }\n+\n+      if (!rawOut.isEmpty()) {", "originalCommit": "c7177049a53d76a82f97fc335e8169ca8ba6e306", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MzAyNg==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r432843026", "bodyText": "It decodes only 1 frame per round. If it's not the case then we have big problems :)", "author": "Nashatyrev", "createdAt": "2020-05-30T13:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzNzM2Mw=="}], "type": "inlineReview"}, {"oid": "6749db2affcf96cd453791207d144f711ddc8964", "url": "https://github.com/ConsenSys/teku/commit/6749db2affcf96cd453791207d144f711ddc8964", "message": "Error response should also be compressed", "committedDate": "2020-06-03T09:43:58Z", "type": "commit"}, {"oid": "8c6356aaf99a7dc8fda09e6e3b2d20f7a628889a", "url": "https://github.com/ConsenSys/teku/commit/8c6356aaf99a7dc8fda09e6e3b2d20f7a628889a", "message": "Merge remote-tracking branch 'pegasys/master' into fix-snappy-blocking", "committedDate": "2020-06-05T15:16:05Z", "type": "commit"}, {"oid": "1cb4e4ae6dbceda5bb1db740b7c876280d826ef9", "url": "https://github.com/ConsenSys/teku/commit/1cb4e4ae6dbceda5bb1db740b7c876280d826ef9", "message": "Initial copy of netty SnappyFrameDecoder", "committedDate": "2020-06-05T16:12:52Z", "type": "commit"}, {"oid": "71fdaae0a1b4985c2089a5c420920bdb644e2107", "url": "https://github.com/ConsenSys/teku/commit/71fdaae0a1b4985c2089a5c420920bdb644e2107", "message": "Draft commit", "committedDate": "2020-06-05T16:20:44Z", "type": "commit"}, {"oid": "8cb73986fd148e96ad0f7242ee7ac391f4465079", "url": "https://github.com/ConsenSys/teku/commit/8cb73986fd148e96ad0f7242ee7ac391f4465079", "message": "Draft RPC response decoders commit", "committedDate": "2020-06-08T17:36:49Z", "type": "commit"}, {"oid": "1eadef3b0fb255b553ff16ae66faa4aa5f33ede9", "url": "https://github.com/ConsenSys/teku/commit/1eadef3b0fb255b553ff16ae66faa4aa5f33ede9", "message": "Something what compiles and can potentially work", "committedDate": "2020-06-10T10:47:27Z", "type": "commit"}, {"oid": "502df73e3a2a75dae6fa66fbd7170160e5346dea", "url": "https://github.com/ConsenSys/teku/commit/502df73e3a2a75dae6fa66fbd7170160e5346dea", "message": "Fix a bug", "committedDate": "2020-06-10T12:16:01Z", "type": "commit"}, {"oid": "be7da417e14c5b70aef1672461465191fede68af", "url": "https://github.com/ConsenSys/teku/commit/be7da417e14c5b70aef1672461465191fede68af", "message": "Fix another bug", "committedDate": "2020-06-10T15:09:10Z", "type": "commit"}, {"oid": "30983e6d9cc4c80fe66ba6faf5ec2c332fed8d68", "url": "https://github.com/ConsenSys/teku/commit/30983e6d9cc4c80fe66ba6faf5ec2c332fed8d68", "message": "Delegate refcounting to CompositeByteBuf as it may be retained with output ByteBuf.", "committedDate": "2020-06-10T15:11:41Z", "type": "commit"}, {"oid": "7327c30c738fa339b1415d372ba4b8e48d03439b", "url": "https://github.com/ConsenSys/teku/commit/7327c30c738fa339b1415d372ba4b8e48d03439b", "message": "Replace static exception instance with factory", "committedDate": "2020-06-10T15:12:41Z", "type": "commit"}, {"oid": "1b1150248e854753af1505862b7511be9710f583", "url": "https://github.com/ConsenSys/teku/commit/1b1150248e854753af1505862b7511be9710f583", "message": "Release ByteBuf after message decoding. Copy bytes to decoder as it may retain Bytes.slice()", "committedDate": "2020-06-10T15:13:46Z", "type": "commit"}, {"oid": "e1bb12da961369dc8d7d5ba15537a4f98c468a00", "url": "https://github.com/ConsenSys/teku/commit/e1bb12da961369dc8d7d5ba15537a4f98c468a00", "message": "Temp comment tests. Adjust and pass RpcRequestDecoderTest", "committedDate": "2020-06-10T15:14:45Z", "type": "commit"}, {"oid": "4c5493c9a50fadd69e80b90f5d2b642624d7332d", "url": "https://github.com/ConsenSys/teku/commit/4c5493c9a50fadd69e80b90f5d2b642624d7332d", "message": "RpcResponseDecoder: decode all available messages", "committedDate": "2020-06-10T17:43:18Z", "type": "commit"}, {"oid": "52457aa84b3c3a8f44e7eaf57409d831f92af7b7", "url": "https://github.com/ConsenSys/teku/commit/52457aa84b3c3a8f44e7eaf57409d831f92af7b7", "message": "Temp", "committedDate": "2020-06-11T10:00:30Z", "type": "commit"}, {"oid": "97ed48f7933680ceca49eb9f185300bf5673fbfa", "url": "https://github.com/ConsenSys/teku/commit/97ed48f7933680ceca49eb9f185300bf5673fbfa", "message": "Create compressor on each chunk to avoid side effects", "committedDate": "2020-06-11T14:40:40Z", "type": "commit"}, {"oid": "c020c9fb691301ae3d900b4b020a3a4e2ffed810", "url": "https://github.com/ConsenSys/teku/commit/c020c9fb691301ae3d900b4b020a3a4e2ffed810", "message": "Throw EXTRA_DATA_APPENDED only when extra data is present in buffer", "committedDate": "2020-06-11T14:41:21Z", "type": "commit"}, {"oid": "eede4cd030efdf240623c3377571992d00897031", "url": "https://github.com/ConsenSys/teku/commit/eede4cd030efdf240623c3377571992d00897031", "message": "Release unprocessed retained buffers on complete()", "committedDate": "2020-06-11T16:16:32Z", "type": "commit"}, {"oid": "c71c3736df1cb7e5c23b443c18a5f90a40235d12", "url": "https://github.com/ConsenSys/teku/commit/c71c3736df1cb7e5c23b443c18a5f90a40235d12", "message": "Add Compressor.uncompressComplete() to release retained unprocessed buffers and throw error in this case", "committedDate": "2020-06-11T16:17:07Z", "type": "commit"}, {"oid": "a0db1dcaa52db0b7152cf09c7bc34addf7433950", "url": "https://github.com/ConsenSys/teku/commit/a0db1dcaa52db0b7152cf09c7bc34addf7433950", "message": "Release any buffered ByteBufs on uncompression failures", "committedDate": "2020-06-11T17:10:56Z", "type": "commit"}, {"oid": "63bd8acd54668cc967826f1c10c9f2923e5446d7", "url": "https://github.com/ConsenSys/teku/commit/63bd8acd54668cc967826f1c10c9f2923e5446d7", "message": "Adjust SnappyCompressionTest. Make more ByteBuf test slices", "committedDate": "2020-06-11T17:13:22Z", "type": "commit"}, {"oid": "fa9f822c2552c28856ff6ea6d4b5b4d3008de27a", "url": "https://github.com/ConsenSys/teku/commit/fa9f822c2552c28856ff6ea6d4b5b4d3008de27a", "message": "Create a disposable decompressor instance via Compressor.createDecompressor", "committedDate": "2020-06-16T12:32:16Z", "type": "commit"}, {"oid": "dd0b9f303b896324ecc091f466ff04303ef032aa", "url": "https://github.com/ConsenSys/teku/commit/dd0b9f303b896324ecc091f466ff04303ef032aa", "message": "Restrict reusing disposable decoder. Throw MESSAGE_TRUNCATED on complete() when no message was decoded", "committedDate": "2020-06-16T14:50:48Z", "type": "commit"}, {"oid": "c13e6f410605c5dc35f8d641fa76bebc69e9102b", "url": "https://github.com/ConsenSys/teku/commit/c13e6f410605c5dc35f8d641fa76bebc69e9102b", "message": "Adjust LengthPrefixedEncodingTest", "committedDate": "2020-06-16T14:51:20Z", "type": "commit"}, {"oid": "660dfd8681494acb928a25a9e624c16b6b1b989b", "url": "https://github.com/ConsenSys/teku/commit/660dfd8681494acb928a25a9e624c16b6b1b989b", "message": "Add RpcRequestHandler.active() method", "committedDate": "2020-06-16T16:38:25Z", "type": "commit"}, {"oid": "6160267044189935f5c202f6968916f4283e26b4", "url": "https://github.com/ConsenSys/teku/commit/6160267044189935f5c202f6968916f4283e26b4", "message": "Some fixes for Eth2OutgoingRequestHandler. Adjusted tests Eth2Incoming/OutgoingRequestHandlerTest", "committedDate": "2020-06-16T18:25:16Z", "type": "commit"}, {"oid": "9d626ad79afdbe62ee966ebe41e1b97acd1e76ac", "url": "https://github.com/ConsenSys/teku/commit/9d626ad79afdbe62ee966ebe41e1b97acd1e76ac", "message": "Apply spotless", "committedDate": "2020-06-16T18:30:49Z", "type": "commit"}, {"oid": "4e780cbed485ee844df4f18c2d205a15d7b07025", "url": "https://github.com/ConsenSys/teku/commit/4e780cbed485ee844df4f18c2d205a15d7b07025", "message": "Remove unused field", "committedDate": "2020-06-16T18:34:29Z", "type": "commit"}, {"oid": "28983686b94e0a43f64f8db0b7eeee12aeea66bf", "url": "https://github.com/ConsenSys/teku/commit/28983686b94e0a43f64f8db0b7eeee12aeea66bf", "message": "Resolve warnings", "committedDate": "2020-06-16T18:39:51Z", "type": "commit"}, {"oid": "ebfa00302b748c164f9ca2e93c1a7708e1d0440c", "url": "https://github.com/ConsenSys/teku/commit/ebfa00302b748c164f9ca2e93c1a7708e1d0440c", "message": "Apply spotless", "committedDate": "2020-06-16T19:49:08Z", "type": "commit"}, {"oid": "bd641f16d929624e22d48a13f43d0c8f2bc1ca5a", "url": "https://github.com/ConsenSys/teku/commit/bd641f16d929624e22d48a13f43d0c8f2bc1ca5a", "message": "Fix test on Win", "committedDate": "2020-06-17T09:55:57Z", "type": "commit"}, {"oid": "a1d35645c24ac2e943c61b904f06f84299d569b8", "url": "https://github.com/ConsenSys/teku/commit/a1d35645c24ac2e943c61b904f06f84299d569b8", "message": "Fix errorprone warning", "committedDate": "2020-06-17T09:57:55Z", "type": "commit"}, {"oid": "9921456ddf52016d45dc91a4d3734c650f369154", "url": "https://github.com/ConsenSys/teku/commit/9921456ddf52016d45dc91a4d3734c650f369154", "message": "Fix more errorprone warnings", "committedDate": "2020-06-17T10:12:37Z", "type": "commit"}, {"oid": "b08e4b128ce19a19b3e3db83fbaace34f8df8e2e", "url": "https://github.com/ConsenSys/teku/commit/b08e4b128ce19a19b3e3db83fbaace34f8df8e2e", "message": "Should invoke RpcHandler.complete() when remote write is closed on the stream", "committedDate": "2020-06-17T11:13:20Z", "type": "commit"}, {"oid": "0c3bf2f76a9991337a79a84c4dd499dd77a3b015", "url": "https://github.com/ConsenSys/teku/commit/0c3bf2f76a9991337a79a84c4dd499dd77a3b015", "message": "Add a bit more info to error log msg", "committedDate": "2020-06-17T11:44:21Z", "type": "commit"}, {"oid": "08374b5a6d12aab3a852ee787331097f105a8043", "url": "https://github.com/ConsenSys/teku/commit/08374b5a6d12aab3a852ee787331097f105a8043", "message": "Add Netty based snappy encoder. Get rid of xerial dependency. Fix and enable CRC validation", "committedDate": "2020-06-17T13:55:33Z", "type": "commit"}, {"oid": "4c80e3b54d67f217cb32e6c4a1b5d82c47002c31", "url": "https://github.com/ConsenSys/teku/commit/4c80e3b54d67f217cb32e6c4a1b5d82c47002c31", "message": "Apply spotless", "committedDate": "2020-06-17T13:59:55Z", "type": "commit"}, {"oid": "81f7a0da670cdd99083f3097e98ccbb0c4cdb6e0", "url": "https://github.com/ConsenSys/teku/commit/81f7a0da670cdd99083f3097e98ccbb0c4cdb6e0", "message": "Add ByteBuf slicing test cases", "committedDate": "2020-06-17T14:46:29Z", "type": "commit"}, {"oid": "80b655482040c4ff41277bb95a0385be2e3adac9", "url": "https://github.com/ConsenSys/teku/commit/80b655482040c4ff41277bb95a0385be2e3adac9", "message": "Minor fix", "committedDate": "2020-06-17T14:56:44Z", "type": "commit"}, {"oid": "35de5c43672c9ffd779a0a7fda1a1e82b5f1f3bd", "url": "https://github.com/ConsenSys/teku/commit/35de5c43672c9ffd779a0a7fda1a1e82b5f1f3bd", "message": "Change buggy Bytes.wrapByteBuf() to safe copy variant (see https://github.com/apache/incubator-tuweni/issues/88)", "committedDate": "2020-06-17T15:11:46Z", "type": "commit"}, {"oid": "33da4d0276e22c73afd980c684631007ab49ec19", "url": "https://github.com/ConsenSys/teku/commit/33da4d0276e22c73afd980c684631007ab49ec19", "message": "Some interfaces refactoring. Add javadoc", "committedDate": "2020-06-17T16:52:01Z", "type": "commit"}, {"oid": "1b78a62c379292fb74a3c7ae3865ddad47079d57", "url": "https://github.com/ConsenSys/teku/commit/1b78a62c379292fb74a3c7ae3865ddad47079d57", "message": "It's better not to consume the ByteBuf came with Gossip message event", "committedDate": "2020-06-17T17:13:45Z", "type": "commit"}, {"oid": "76621982eb6e90e692b64bf6219b3ccb7ea5d322", "url": "https://github.com/ConsenSys/teku/commit/76621982eb6e90e692b64bf6219b3ccb7ea5d322", "message": "Temporarily return back static exception instance. Would fix in a separate PR", "committedDate": "2020-06-17T17:32:30Z", "type": "commit"}, {"oid": "cc9b5d8b314e1443107d7ac146e15e2eea4c3baf", "url": "https://github.com/ConsenSys/teku/commit/cc9b5d8b314e1443107d7ac146e15e2eea4c3baf", "message": "Compressor has now disposable Decompressor factory, so no need to pass Compressor factory", "committedDate": "2020-06-17T17:37:55Z", "type": "commit"}, {"oid": "35424d4f273709c8eb4dd6f54ff0d643e50f8b74", "url": "https://github.com/ConsenSys/teku/commit/35424d4f273709c8eb4dd6f54ff0d643e50f8b74", "message": "Minor javadoc fix", "committedDate": "2020-06-17T17:38:54Z", "type": "commit"}, {"oid": "b01a3b478482951823e4e3a6cba02d5a6282c9d3", "url": "https://github.com/ConsenSys/teku/commit/b01a3b478482951823e4e3a6cba02d5a6282c9d3", "message": "Remove commented code", "committedDate": "2020-06-17T18:04:10Z", "type": "commit"}, {"oid": "22afeff54f30ded0d52db684af46591e0f1e32af", "url": "https://github.com/ConsenSys/teku/commit/22afeff54f30ded0d52db684af46591e0f1e32af", "message": "Use new SnappyFrameEncoder", "committedDate": "2020-06-17T18:04:58Z", "type": "commit"}, {"oid": "7905a5e34471c880f4a48df722a02115af8bf506", "url": "https://github.com/ConsenSys/teku/commit/7905a5e34471c880f4a48df722a02115af8bf506", "message": "Remove commented code", "committedDate": "2020-06-17T18:06:05Z", "type": "commit"}, {"oid": "de1e0e35901be6d33b72a1ee9f36612549b1bd9f", "url": "https://github.com/ConsenSys/teku/commit/de1e0e35901be6d33b72a1ee9f36612549b1bd9f", "message": "Merge remote-tracking branch 'pegasys/master' into fix-snappy-blocking", "committedDate": "2020-06-17T18:09:03Z", "type": "commit"}, {"oid": "c77a1d085701a15f5d2cdc1feca30cde2d33f929", "url": "https://github.com/ConsenSys/teku/commit/c77a1d085701a15f5d2cdc1feca30cde2d33f929", "message": "Adjust xerial snappy dependency", "committedDate": "2020-06-17T18:20:46Z", "type": "commit"}, {"oid": "9d789946533d88950e8a8c76db5202d65149ef39", "url": "https://github.com/ConsenSys/teku/commit/9d789946533d88950e8a8c76db5202d65149ef39", "message": "Minor fix", "committedDate": "2020-06-17T18:23:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM5Njk0Nw==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442396947", "bodyText": "(nit) We usually put internal classes at the bottom of the file.", "author": "mbaxter", "createdAt": "2020-06-18T17:43:25Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedPayloadDecoder.java", "diffHunk": "@@ -14,102 +14,130 @@\n package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n \n import static tech.pegasys.teku.util.config.Constants.MAX_CHUNK_SIZE;\n-import static tech.pegasys.teku.util.iostreams.IOStreamConstants.END_OF_STREAM;\n \n-import com.google.protobuf.CodedInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes;\n import tech.pegasys.teku.networking.eth2.rpc.core.RpcException;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor.Decompressor;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.CompressionException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadLargerThanExpectedException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n \n-class LengthPrefixedPayloadDecoder<T> {\n-  private static final Logger LOG = LogManager.getLogger();\n+class LengthPrefixedPayloadDecoder<T> implements RpcByteBufDecoder<T> {\n \n-  static final Bytes MAX_CHUNK_SIZE_PREFIX = ProtobufEncoder.encodeVarInt(MAX_CHUNK_SIZE);\n+  private static class VarIntDecoder extends AbstractByteBufDecoder<Long> {", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwMjQ3Ng==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442402476", "bodyText": "Seems like RpcException.EXTRA_DATA_APPENDED would be a better error here?", "author": "mbaxter", "createdAt": "2020-06-18T17:53:14Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/AbstractByteBufDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.Unpooled;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n+\n+/**\n+ * Abstract {@link ByteBufDecoder} implementation which handles unprocessed {@link ByteBuf}s\n+ *\n+ * <p>This class is a standalone analog of Netty {@link io.netty.handler.codec.ByteToMessageDecoder}\n+ */\n+public abstract class AbstractByteBufDecoder<TMessage>\n+    implements ByteBufDecoder<TMessage, RuntimeException> {\n+\n+  private CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();\n+\n+  @Override\n+  public synchronized Optional<TMessage> decodeOneMessage(ByteBuf in) {\n+    if (!in.isReadable()) {\n+      return Optional.empty();\n+    }\n+    compositeByteBuf.addComponent(true, in.retainedSlice());\n+    try {\n+      Optional<TMessage> outBuf;\n+      while (true) {\n+        int readerIndex = compositeByteBuf.readerIndex();\n+        outBuf = decodeOneImpl(compositeByteBuf);\n+        if (outBuf.isPresent()\n+            || readerIndex == compositeByteBuf.readerIndex()\n+            || compositeByteBuf.readableBytes() == 0) {\n+          break;\n+        }\n+      }\n+      if (outBuf.isPresent()) {\n+        in.skipBytes(in.readableBytes() - compositeByteBuf.readableBytes());\n+        compositeByteBuf.release();\n+        compositeByteBuf = Unpooled.compositeBuffer();\n+      } else {\n+        in.skipBytes(in.readableBytes());\n+      }\n+      return outBuf;\n+    } catch (Throwable t) {\n+      compositeByteBuf.release();\n+      compositeByteBuf = Unpooled.compositeBuffer();\n+      throw t;\n+    }\n+  }\n+\n+  @Override\n+  public void complete() {\n+    if (compositeByteBuf.isReadable()) {\n+      compositeByteBuf.release();\n+      throw new PayloadSmallerThanExpectedException(\n+          \"Rpc stream complete, but unprocessed data left: \" + compositeByteBuf.readableBytes());", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2NzYyNw==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443667627", "bodyText": "Honestly I slightly messed up exceptions handling.\nDid a small refactor here. Can you please review?", "author": "Nashatyrev", "createdAt": "2020-06-22T16:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwMjQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNDY4MQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442414681", "bodyText": "What about:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      // making a copy here since the Bytes.wrapByteBuf(buf).slice(...)\n          \n          \n            \n                      // would be broken after [in] buffer is released\n          \n          \n            \n                      byte[] arr = new byte[ret.get().readableBytes()];\n          \n          \n            \n                      ret.get().readBytes(arr);\n          \n          \n            \n                      Bytes bytes = Bytes.wrap(arr);\n          \n          \n            \n                      Bytes bytes = Bytes.wrapByteBuf(ret.get()).copy();", "author": "mbaxter", "createdAt": "2020-06-18T18:15:47Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedPayloadDecoder.java", "diffHunk": "@@ -14,102 +14,130 @@\n package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n \n import static tech.pegasys.teku.util.config.Constants.MAX_CHUNK_SIZE;\n-import static tech.pegasys.teku.util.iostreams.IOStreamConstants.END_OF_STREAM;\n \n-import com.google.protobuf.CodedInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes;\n import tech.pegasys.teku.networking.eth2.rpc.core.RpcException;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor.Decompressor;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.CompressionException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadLargerThanExpectedException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n \n-class LengthPrefixedPayloadDecoder<T> {\n-  private static final Logger LOG = LogManager.getLogger();\n+class LengthPrefixedPayloadDecoder<T> implements RpcByteBufDecoder<T> {\n \n-  static final Bytes MAX_CHUNK_SIZE_PREFIX = ProtobufEncoder.encodeVarInt(MAX_CHUNK_SIZE);\n+  private static class VarIntDecoder extends AbstractByteBufDecoder<Long> {\n+    @Override\n+    protected Optional<Long> decodeOneImpl(ByteBuf in) {\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        return Optional.empty();\n+      }\n+      return Optional.of(length);\n+    }\n+  }\n \n   private final RpcPayloadEncoder<T> payloadEncoder;\n   private final Compressor compressor;\n+  private Optional<Decompressor> decompressor = Optional.empty();\n+  private Optional<VarIntDecoder> varIntDecoder = Optional.empty();\n+  private boolean decoded = false;\n+  private boolean disposed = false;\n \n   public LengthPrefixedPayloadDecoder(\n       final RpcPayloadEncoder<T> payloadEncoder, final Compressor compressor) {\n     this.payloadEncoder = payloadEncoder;\n     this.compressor = compressor;\n   }\n \n-  public T decodePayload(final InputStream inputStream) throws RpcException {\n-    try {\n-      final int uncompressedPayloadSize = processLengthPrefixHeader(inputStream);\n-      return processPayload(inputStream, uncompressedPayloadSize);\n-    } catch (PayloadSmallerThanExpectedException e) {\n-      throw RpcException.PAYLOAD_TRUNCATED;\n-    } catch (PayloadLargerThanExpectedException e) {\n-      throw RpcException.EXTRA_DATA_APPENDED;\n-    } catch (CompressionException e) {\n-      LOG.debug(\"Failed to uncompress rpc payload\", e);\n-      throw RpcException.FAILED_TO_UNCOMPRESS_MESSAGE;\n-    } catch (IOException e) {\n-      LOG.error(\"Unable to decode rpc payload\", e);\n-      throw RpcException.SERVER_ERROR;\n+  @Override\n+  public Optional<T> decodeOneMessage(final ByteBuf in) throws RpcException {\n+    if (decoded || disposed) {\n+      throw new IllegalStateException(\"Trying to reuse disposable LengthPrefixedPayloadDecoder\");\n+    }\n+    if (decompressor.isEmpty()) {\n+      readLengthPrefixHeader(in)\n+          .ifPresent(len -> decompressor = Optional.of(compressor.createDecompressor(len)));\n+    }\n+    if (decompressor.isPresent()) {\n+      Optional<ByteBuf> ret = decompressor.get().decodeOneMessage(in);\n+      if (ret.isPresent()) {\n+        decompressor = Optional.empty();\n+        try {\n+          // making a copy here since the Bytes.wrapByteBuf(buf).slice(...)\n+          // would be broken after [in] buffer is released\n+          byte[] arr = new byte[ret.get().readableBytes()];\n+          ret.get().readBytes(arr);\n+          Bytes bytes = Bytes.wrap(arr);", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4MjM1MQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443482351", "bodyText": "I've found a bug in Bytes.wrapByteBuf() so changed all its usages to a safer variant", "author": "Nashatyrev", "createdAt": "2020-06-22T11:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNDY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNjQxOQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442426419", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java\n          \n          \n            \n             * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFrameDecoder.java", "author": "mbaxter", "createdAt": "2020-06-18T18:37:30Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.validateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.CompressionException;\n+import io.netty.handler.codec.compression.Snappy;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.AbstractByteBufDecoder;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNzM4Nw==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442427387", "bodyText": "Looks like we're enabling these checks by default", "author": "mbaxter", "createdAt": "2020-06-18T18:39:26Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.validateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.CompressionException;\n+import io.netty.handler.codec.compression.Snappy;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.AbstractByteBufDecoder;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java\n+ *\n+ * <p>Uncompresses a {@link ByteBuf} encoded with the Snappy framing format.\n+ *\n+ * <p>See <a href=\"https://github.com/google/snappy/blob/master/framing_format.txt\">Snappy framing\n+ * format</a>.\n+ *\n+ * <p>Note that by default, validation of the checksum header in each chunk is DISABLED for\n+ * performance improvements. If performance is less of an issue, or if you would prefer the safety\n+ * that checksum validation brings, please use the {@link #SnappyFrameDecoder(boolean)} constructor\n+ * with the argument set to {@code true}.", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4Mzk2MQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443483961", "bodyText": "Right! This comment just left from the original implementation. Removed it.", "author": "Nashatyrev", "createdAt": "2020-06-22T11:09:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNzM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODAxNg==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442428016", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Creates a new snappy-framed decoder with validation of checksums turned OFF. To turn checksum\n          \n          \n            \n               * validation on, please use the alternate {@link #SnappyFrameDecoder(boolean)} constructor.\n          \n          \n            \n               */\n          \n          \n            \n               * Creates a new snappy-framed decoder with validation of checksums turned on. To turn checksum\n          \n          \n            \n               * validation off, please use the alternate {@link #SnappyFrameDecoder(boolean)} constructor.\n          \n          \n            \n               */", "author": "mbaxter", "createdAt": "2020-06-18T18:40:34Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.validateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.CompressionException;\n+import io.netty.handler.codec.compression.Snappy;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.AbstractByteBufDecoder;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java\n+ *\n+ * <p>Uncompresses a {@link ByteBuf} encoded with the Snappy framing format.\n+ *\n+ * <p>See <a href=\"https://github.com/google/snappy/blob/master/framing_format.txt\">Snappy framing\n+ * format</a>.\n+ *\n+ * <p>Note that by default, validation of the checksum header in each chunk is DISABLED for\n+ * performance improvements. If performance is less of an issue, or if you would prefer the safety\n+ * that checksum validation brings, please use the {@link #SnappyFrameDecoder(boolean)} constructor\n+ * with the argument set to {@code true}.\n+ */\n+public class SnappyFrameDecoder extends AbstractByteBufDecoder<ByteBuf> {\n+\n+  private enum ChunkType {\n+    STREAM_IDENTIFIER,\n+    COMPRESSED_DATA,\n+    UNCOMPRESSED_DATA,\n+    RESERVED_UNSKIPPABLE,\n+    RESERVED_SKIPPABLE\n+  }\n+\n+  private static final int SNAPPY_IDENTIFIER_LEN = 6;\n+  private static final int MAX_UNCOMPRESSED_DATA_SIZE = 65536 + 4;\n+\n+  private final Snappy snappy = new Snappy();\n+  private final boolean validateChecksums;\n+\n+  private boolean started;\n+  private boolean corrupted;\n+\n+  /**\n+   * Creates a new snappy-framed decoder with validation of checksums turned OFF. To turn checksum\n+   * validation on, please use the alternate {@link #SnappyFrameDecoder(boolean)} constructor.\n+   */", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MjIzNw==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442442237", "bodyText": "Shouldn't we make sure that started == false?  I put together a quick test and it looks like we'll accept extra snappy headers prepended to the message.", "author": "mbaxter", "createdAt": "2020-06-18T19:06:48Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.validateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.CompressionException;\n+import io.netty.handler.codec.compression.Snappy;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.AbstractByteBufDecoder;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java\n+ *\n+ * <p>Uncompresses a {@link ByteBuf} encoded with the Snappy framing format.\n+ *\n+ * <p>See <a href=\"https://github.com/google/snappy/blob/master/framing_format.txt\">Snappy framing\n+ * format</a>.\n+ *\n+ * <p>Note that by default, validation of the checksum header in each chunk is DISABLED for\n+ * performance improvements. If performance is less of an issue, or if you would prefer the safety\n+ * that checksum validation brings, please use the {@link #SnappyFrameDecoder(boolean)} constructor\n+ * with the argument set to {@code true}.\n+ */\n+public class SnappyFrameDecoder extends AbstractByteBufDecoder<ByteBuf> {\n+\n+  private enum ChunkType {\n+    STREAM_IDENTIFIER,\n+    COMPRESSED_DATA,\n+    UNCOMPRESSED_DATA,\n+    RESERVED_UNSKIPPABLE,\n+    RESERVED_SKIPPABLE\n+  }\n+\n+  private static final int SNAPPY_IDENTIFIER_LEN = 6;\n+  private static final int MAX_UNCOMPRESSED_DATA_SIZE = 65536 + 4;\n+\n+  private final Snappy snappy = new Snappy();\n+  private final boolean validateChecksums;\n+\n+  private boolean started;\n+  private boolean corrupted;\n+\n+  /**\n+   * Creates a new snappy-framed decoder with validation of checksums turned OFF. To turn checksum\n+   * validation on, please use the alternate {@link #SnappyFrameDecoder(boolean)} constructor.\n+   */\n+  public SnappyFrameDecoder() {\n+    this(true);\n+  }\n+\n+  /**\n+   * Creates a new snappy-framed decoder with validation of checksums as specified.\n+   *\n+   * @param validateChecksums If true, the checksum field will be validated against the actual\n+   *     uncompressed data, and if the checksums do not match, a suitable {@link\n+   *     CompressionException} will be thrown\n+   */\n+  public SnappyFrameDecoder(boolean validateChecksums) {\n+    this.validateChecksums = validateChecksums;\n+  }\n+\n+  @Override\n+  protected Optional<ByteBuf> decodeOneImpl(ByteBuf in) {\n+    if (corrupted) {\n+      in.skipBytes(in.readableBytes());\n+      return Optional.empty();\n+    }\n+\n+    ByteBuf ret = null;\n+\n+    try {\n+      int idx = in.readerIndex();\n+      final int inSize = in.readableBytes();\n+      if (inSize < 4) {\n+        // We need to be at least able to read the chunk type identifier (one byte),\n+        // and the length of the chunk (3 bytes) in order to proceed\n+        return Optional.empty();\n+      }\n+\n+      final int chunkTypeVal = in.getUnsignedByte(idx);\n+      final ChunkType chunkType = mapChunkType((byte) chunkTypeVal);\n+      final int chunkLength = in.getUnsignedMediumLE(idx + 1);\n+\n+      switch (chunkType) {\n+        case STREAM_IDENTIFIER:", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4OTIyOA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443489228", "bodyText": "Good catch \ud83d\udc4d  This is from original Netty class. Fixed", "author": "Nashatyrev", "createdAt": "2020-06-22T11:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MjIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2MjExNQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442462115", "bodyText": "Why not just use the netty Snappy implementations of this utils?", "author": "mbaxter", "createdAt": "2020-06-18T19:43:43Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyUtil.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.handler.codec.compression.DecompressionException;\n+import java.util.zip.CRC32C;\n+\n+class SnappyUtil {\n+\n+  static int calculateChecksum(ByteBuf data) {\n+    return calculateChecksum(data, data.readerIndex(), data.readableBytes());\n+  }\n+\n+  static int calculateChecksum(ByteBuf data, int offset, int length) {\n+    CRC32C crc32 = new CRC32C();\n+    try {\n+      for (int i = offset; i < offset + length; i++) {\n+        crc32.update(data.getByte(i));\n+      }\n+      return maskChecksum((int) crc32.getValue());\n+    } finally {\n+      crc32.reset();\n+    }\n+  }\n+\n+  static int maskChecksum(int checksum) {\n+    return (checksum >>> 15 | checksum << 17) + 0xa282ead8;\n+  }\n+\n+  static void validateChecksum(int expectedChecksum, ByteBuf data, int offset, int length) {", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4OTc5OA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443489798", "bodyText": "This method is package private there \ud83d\ude1e", "author": "Nashatyrev", "createdAt": "2020-06-22T11:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2MjExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3MjYxNg==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442472616", "bodyText": "I think we can simplify this by handling the \"first byte\" logic here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<TResponse> maybeResponses =\n          \n          \n            \n                        responseDecoder.decodeNextResponses(data, this::onFirstByteReceived);\n          \n          \n            \n                    if (data.isReadable()) {\n          \n          \n            \n                        onFirstByteReceived();\n          \n          \n            \n                    }\n          \n          \n            \n                    List<TResponse> maybeResponses = responseDecoder.decodeNextResponses(data);", "author": "mbaxter", "createdAt": "2020-06-18T20:04:02Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/Eth2OutgoingRequestHandler.java", "diffHunk": "@@ -76,37 +76,29 @@ public void handleInitialPayloadSent(final RpcStream stream) {\n   }\n \n   @Override\n-  public void processInput(\n-      final NodeId nodeId, final RpcStream rpcStream, final InputStream input) {\n+  public void active(NodeId nodeId, RpcStream rpcStream) {}\n+\n+  @Override\n+  public void processData(final NodeId nodeId, final RpcStream rpcStream, final ByteBuf data) {\n     try {\n       this.rpcStream = rpcStream;\n \n-      Optional<TResponse> maybeResponse =\n-          responseDecoder.decodeNextResponse(input, this::onFirstByteReceived);\n-      while (!isClosed.get() && maybeResponse.isPresent()) {\n-        final TResponse response = maybeResponse.get();\n-        responseProcessor.processResponse(response);\n-\n-        final int chunksReceived = currentChunkCount.incrementAndGet();\n-        if (chunksReceived >= maximumResponseChunks) {\n-          // Make sure there aren't any trailing unconsumed bytes\n-          if (input.available() > 0) {\n-            LOG.debug(\n-                \"Encountered unconsumed data after last expected response chunk was processed.\");\n-            cancelRequest(rpcStream, RpcException.EXTRA_DATA_APPENDED);\n-          } else {\n-            completeRequest(rpcStream);\n-          }\n-          break;\n+      if (!isClosed.get()) {\n+        List<TResponse> maybeResponses =\n+            responseDecoder.decodeNextResponses(data, this::onFirstByteReceived);", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU0MDM4MA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443540380", "bodyText": "Yep, good suggestion \ud83d\udc4d", "author": "Nashatyrev", "createdAt": "2020-06-22T13:00:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3MjYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3NTYzNg==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442475636", "bodyText": "We should catch the specific exception we're expecting here", "author": "mbaxter", "createdAt": "2020-06-18T20:10:14Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedPayloadDecoder.java", "diffHunk": "@@ -14,102 +14,130 @@\n package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n \n import static tech.pegasys.teku.util.config.Constants.MAX_CHUNK_SIZE;\n-import static tech.pegasys.teku.util.iostreams.IOStreamConstants.END_OF_STREAM;\n \n-import com.google.protobuf.CodedInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes;\n import tech.pegasys.teku.networking.eth2.rpc.core.RpcException;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor.Decompressor;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.CompressionException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadLargerThanExpectedException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n \n-class LengthPrefixedPayloadDecoder<T> {\n-  private static final Logger LOG = LogManager.getLogger();\n+class LengthPrefixedPayloadDecoder<T> implements RpcByteBufDecoder<T> {\n \n-  static final Bytes MAX_CHUNK_SIZE_PREFIX = ProtobufEncoder.encodeVarInt(MAX_CHUNK_SIZE);\n+  private static class VarIntDecoder extends AbstractByteBufDecoder<Long> {\n+    @Override\n+    protected Optional<Long> decodeOneImpl(ByteBuf in) {\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        return Optional.empty();\n+      }\n+      return Optional.of(length);\n+    }\n+  }\n \n   private final RpcPayloadEncoder<T> payloadEncoder;\n   private final Compressor compressor;\n+  private Optional<Decompressor> decompressor = Optional.empty();\n+  private Optional<VarIntDecoder> varIntDecoder = Optional.empty();\n+  private boolean decoded = false;\n+  private boolean disposed = false;\n \n   public LengthPrefixedPayloadDecoder(\n       final RpcPayloadEncoder<T> payloadEncoder, final Compressor compressor) {\n     this.payloadEncoder = payloadEncoder;\n     this.compressor = compressor;\n   }\n \n-  public T decodePayload(final InputStream inputStream) throws RpcException {\n-    try {\n-      final int uncompressedPayloadSize = processLengthPrefixHeader(inputStream);\n-      return processPayload(inputStream, uncompressedPayloadSize);\n-    } catch (PayloadSmallerThanExpectedException e) {\n-      throw RpcException.PAYLOAD_TRUNCATED;\n-    } catch (PayloadLargerThanExpectedException e) {\n-      throw RpcException.EXTRA_DATA_APPENDED;\n-    } catch (CompressionException e) {\n-      LOG.debug(\"Failed to uncompress rpc payload\", e);\n-      throw RpcException.FAILED_TO_UNCOMPRESS_MESSAGE;\n-    } catch (IOException e) {\n-      LOG.error(\"Unable to decode rpc payload\", e);\n-      throw RpcException.SERVER_ERROR;\n+  @Override\n+  public Optional<T> decodeOneMessage(final ByteBuf in) throws RpcException {\n+    if (decoded || disposed) {\n+      throw new IllegalStateException(\"Trying to reuse disposable LengthPrefixedPayloadDecoder\");\n+    }\n+    if (decompressor.isEmpty()) {\n+      readLengthPrefixHeader(in)\n+          .ifPresent(len -> decompressor = Optional.of(compressor.createDecompressor(len)));\n+    }\n+    if (decompressor.isPresent()) {\n+      Optional<ByteBuf> ret = decompressor.get().decodeOneMessage(in);\n+      if (ret.isPresent()) {\n+        decompressor = Optional.empty();\n+        try {\n+          // making a copy here since the Bytes.wrapByteBuf(buf).slice(...)\n+          // would be broken after [in] buffer is released\n+          byte[] arr = new byte[ret.get().readableBytes()];\n+          ret.get().readBytes(arr);\n+          Bytes bytes = Bytes.wrap(arr);\n+          decoded = true;\n+          return Optional.of(payloadEncoder.decode(bytes));\n+        } finally {\n+          ret.get().release();\n+        }\n+      } else {\n+        return Optional.empty();\n+      }\n+    } else {\n+      return Optional.empty();\n     }\n   }\n \n-  /** Decode the length-prefix header, which contains the length of the uncompressed payload */\n-  private int processLengthPrefixHeader(final InputStream inputStream)\n-      throws RpcException, IOException {\n-    // Collect length prefix raw bytes\n-    final ByteArrayOutputStream headerBytes = new ByteArrayOutputStream();\n-\n-    boolean foundTerminatingCharacter = false;\n-    int nextByte;\n-    while ((nextByte = inputStream.read()) != END_OF_STREAM) {\n-      if (headerBytes.size() >= MAX_CHUNK_SIZE_PREFIX.size()) {\n-        // Any protobuf length requiring more bytes than this will also be bigger.\n-        throw RpcException.CHUNK_TOO_LONG;\n+  @Override\n+  public void complete() throws RpcException {\n+    if (disposed) {\n+      throw new IllegalStateException(\"Trying to reuse disposable LengthPrefixedPayloadDecoder\");\n+    }\n+    disposed = true;\n+    RpcException err = null;\n+    if (varIntDecoder.isPresent()) {\n+      try {\n+        varIntDecoder.ifPresent(AbstractByteBufDecoder::complete);\n+      } catch (Exception e) {", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2ODQ3MQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443668471", "bodyText": "Added comments here. There is no much sense catching specific exceptions here, sine the complete() is called just to release resources. We already know that the message was truncated", "author": "Nashatyrev", "createdAt": "2020-06-22T16:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3NTYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMTkzNQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442501935", "bodyText": "We're not guaranteed to receive this event right?  Don't we need to make sure complete is always called so that resources are definitely released in all cases?", "author": "mbaxter", "createdAt": "2020-06-18T21:05:03Z", "path": "networking/p2p/src/main/java/tech/pegasys/teku/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -232,36 +188,23 @@ public void handlerRemoved(ChannelHandlerContext ctx) throws IllegalArgumentExce\n       close();\n     }\n \n-    private void close() {\n-      SafeFuture.of(p2pChannel.closeFuture())\n-          .whenComplete(\n-              (res, err) -> {\n-                if (err != null) {\n-                  LOG.warn(\"Failed to close p2pChannel.\", err);\n-                }\n-                closeOutputStream();\n-              })\n-          .reportExceptions();\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+      if (evt instanceof RemoteWriteClosed) {\n+        rpcRequestHandler.complete(nodeId, rpcStream);", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxNTUzOQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443615539", "bodyText": "Yes, very good point \ud83d\udc4d\nIndeed this user event is not guaranteed and we should make sure the complete() is called on stream EOF.\nI fixed this here: b25386b", "author": "Nashatyrev", "createdAt": "2020-06-22T14:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMTkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMjY0NQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442502645", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOG.debug(\"RPC Request stream ends prematurely\", e);\n          \n          \n            \n                  LOG.debug(\"RPC Request stream closed prematurely\", e);", "author": "mbaxter", "createdAt": "2020-06-18T21:06:33Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/Eth2IncomingRequestHandler.java", "diffHunk": "@@ -59,19 +59,32 @@ public Eth2IncomingRequestHandler(\n   }\n \n   @Override\n-  public void processInput(\n-      final NodeId nodeId, final RpcStream rpcStream, final InputStream input) {\n-\n+  public void active(NodeId nodeId, RpcStream rpcStream) {\n     ensureRequestReceivedWithinTimeLimit(rpcStream);\n+  }\n \n-    final ResponseCallback<TResponse> callback = new RpcResponseCallback<>(rpcStream, rpcEncoder);\n+  @Override\n+  public void processData(final NodeId nodeId, final RpcStream rpcStream, final ByteBuf data) {\n     try {\n       Optional<Eth2Peer> peer = peerLookup.getConnectedPeer(nodeId);\n-      final TRequest request = requestDecoder.decodeRequest(input);\n-      handleRequest(peer, request, callback);\n+      requestDecoder\n+          .decodeRequest(data)\n+          .ifPresent(\n+              request ->\n+                  handleRequest(peer, request, new RpcResponseCallback<>(rpcStream, rpcEncoder)));\n     } catch (final RpcException e) {\n       requestHandled.set(true);\n-      callback.completeWithErrorResponse(e);\n+      new RpcResponseCallback<>(rpcStream, rpcEncoder).completeWithErrorResponse(e);\n+    }\n+  }\n+\n+  @Override\n+  public void complete(NodeId nodeId, RpcStream rpcStream) {\n+    try {\n+      requestDecoder.complete();\n+    } catch (RpcException e) {\n+      new RpcResponseCallback<>(rpcStream, rpcEncoder).completeWithErrorResponse(e);\n+      LOG.debug(\"RPC Request stream ends prematurely\", e);", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMzE5OA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442503198", "bodyText": "nice \ud83d\udcaf", "author": "mbaxter", "createdAt": "2020-06-18T21:07:42Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/Eth2IncomingRequestHandler.java", "diffHunk": "@@ -97,8 +110,9 @@ private void ensureRequestReceivedWithinTimeLimit(final RpcStream stream) {\n             (__) -> {\n               if (!requestHandled.get()) {\n                 LOG.debug(\n-                    \"Failed to receive incoming request data within {} sec. Close stream.\",\n-                    timeout.getSeconds());\n+                    \"Failed to receive incoming request data within {} sec for method {}. Close stream.\",\n+                    timeout.getSeconds(),\n+                    method);", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwODE1NA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442508154", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                firstByteListener.ifPresent(FirstByteReceivedListener::onFirstByteReceived);\n          \n          \n            \n            \n          \n          \n            \n                if (!data.isReadable()) {\n          \n          \n            \n                  return Optional.empty();\n          \n          \n            \n                }\n          \n          \n            \n                if (!data.isReadable()) {\n          \n          \n            \n                  return Optional.empty();\n          \n          \n            \n                }\n          \n          \n            \n                firstByteListener.ifPresent(FirstByteReceivedListener::onFirstByteReceived);", "author": "mbaxter", "createdAt": "2020-06-18T21:18:21Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/RpcResponseDecoder.java", "diffHunk": "@@ -31,62 +29,96 @@\n  * @param <T>\n  */\n public class RpcResponseDecoder<T> {\n-  private static final Logger LOG = LogManager.getLogger();\n-\n+  private Optional<Integer> respCodeMaybe = Optional.empty();\n+  private Optional<RpcByteBufDecoder<T>> payloadDecoder = Optional.empty();\n+  private Optional<RpcByteBufDecoder<String>> errorDecoder = Optional.empty();\n   private final Class<T> responseType;\n   private final RpcEncoding encoding;\n \n-  protected RpcResponseDecoder(final Class<T> responseType, final RpcEncoding encoding) {\n+  public RpcResponseDecoder(Class<T> responseType, RpcEncoding encoding) {\n     this.responseType = responseType;\n     this.encoding = encoding;\n   }\n \n-  public Optional<T> decodeNextResponse(final InputStream input) throws RpcException {\n-    return decodeNextResponse(input, Optional.empty());\n+  public List<T> decodeNextResponses(final ByteBuf data) throws RpcException {\n+    return decodeNextResponses(data, Optional.empty());\n   }\n \n-  public Optional<T> decodeNextResponse(\n-      final InputStream input, final FirstByteReceivedListener firstByteReceivedListener)\n+  public List<T> decodeNextResponses(\n+      final ByteBuf data, final FirstByteReceivedListener firstByteReceivedListener)\n       throws RpcException {\n-    return decodeNextResponse(input, Optional.of(firstByteReceivedListener));\n+    return decodeNextResponses(data, Optional.of(firstByteReceivedListener));\n   }\n \n-  private Optional<T> decodeNextResponse(\n-      final InputStream input, Optional<FirstByteReceivedListener> firstByteListener)\n+  private List<T> decodeNextResponses(\n+      final ByteBuf data, Optional<FirstByteReceivedListener> firstByteListener)\n       throws RpcException {\n-    try {\n-      final OptionalInt maybeStatus = getNextStatusCode(input);\n-      if (maybeStatus.isEmpty()) {\n-        // Empty status indicates we're finished reading responses\n-        return Optional.empty();\n-      }\n-      firstByteListener.ifPresent(FirstByteReceivedListener::onFirstByteReceived);\n-      final int status = maybeStatus.getAsInt();\n-      if (status == SUCCESS_RESPONSE_CODE) {\n-        final T response = encoding.decodePayload(input, responseType);\n-        return Optional.of(response);\n+    List<T> ret = new ArrayList<>();\n+    while (true) {\n+      Optional<T> responseMaybe = decodeNextResponse(data, firstByteListener);\n+      if (responseMaybe.isPresent()) {\n+        ret.add(responseMaybe.get());\n       } else {\n-        throw decodeError(input, status);\n+        break;\n       }\n-    } catch (IOException e) {\n-      LOG.error(\"Unexpected error while reading rpc responses\", e);\n-      throw RpcException.SERVER_ERROR;\n     }\n+\n+    return ret;\n   }\n \n-  private RpcException decodeError(final InputStream input, final int statusCode)\n+  private Optional<T> decodeNextResponse(\n+      final ByteBuf data, Optional<FirstByteReceivedListener> firstByteListener)\n       throws RpcException {\n-    final String errorMessage = encoding.decodePayload(input, String.class);\n-    return new RpcException(toByteExactUnsigned(statusCode), errorMessage);\n-  }\n+    firstByteListener.ifPresent(FirstByteReceivedListener::onFirstByteReceived);\n+\n+    if (!data.isReadable()) {\n+      return Optional.empty();\n+    }", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU0MTA1MQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443541051", "bodyText": "Not relevant any more", "author": "Nashatyrev", "createdAt": "2020-06-22T13:01:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwODE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMDMzNQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442510335", "bodyText": "If all of the ByteBuf's are coming in on the netty thread, do we need this to be synchronized?", "author": "mbaxter", "createdAt": "2020-06-18T21:23:07Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/AbstractByteBufDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.Unpooled;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n+\n+/**\n+ * Abstract {@link ByteBufDecoder} implementation which handles unprocessed {@link ByteBuf}s\n+ *\n+ * <p>This class is a standalone analog of Netty {@link io.netty.handler.codec.ByteToMessageDecoder}\n+ */\n+public abstract class AbstractByteBufDecoder<TMessage>\n+    implements ByteBufDecoder<TMessage, RuntimeException> {\n+\n+  private CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();\n+\n+  @Override\n+  public synchronized Optional<TMessage> decodeOneMessage(ByteBuf in) {", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NDQ4NA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443494484", "bodyText": "Right. In our context there is no need in synchronization. Adjusted", "author": "Nashatyrev", "createdAt": "2020-06-22T11:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMDMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMTcxNg==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442531716", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class NoopFrameDecoder extends AbstractByteBufDecoder<ByteBuf> {\n          \n          \n            \n            public class NoopDecoder extends AbstractByteBufDecoder<ByteBuf> {", "author": "mbaxter", "createdAt": "2020-06-18T22:16:29Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/noop/NoopFrameDecoder.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.noop;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.AbstractByteBufDecoder;\n+\n+public class NoopFrameDecoder extends AbstractByteBufDecoder<ByteBuf> {", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NTQ0Mw==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443495443", "bodyText": "Yep, nothing with 'frames' here \ud83d\udc4d", "author": "Nashatyrev", "createdAt": "2020-06-22T11:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMTcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMjExNQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442532115", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java\n          \n          \n            \n             * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFrameEncoder.java", "author": "mbaxter", "createdAt": "2020-06-18T22:17:41Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameEncoder.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.calculateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.Snappy;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.CompressionException;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMzU3NA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442533574", "bodyText": "Never seen this \ud83e\udd14 What about just:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (; ; ) {\n          \n          \n            \n                  while(true) {", "author": "mbaxter", "createdAt": "2020-06-18T22:22:15Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameEncoder.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.calculateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.Snappy;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.CompressionException;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java\n+ *\n+ * <p>Compresses a {@link ByteBuf} using the Snappy framing format.\n+ *\n+ * <p>See <a href=\"https://github.com/google/snappy/blob/master/framing_format.txt\">Snappy framing\n+ * format</a>.\n+ */\n+public class SnappyFrameEncoder {\n+  /**\n+   * The minimum amount that we'll consider actually attempting to compress. This value is preamble\n+   * + the minimum length our Snappy service will compress (instead of just emitting a literal).\n+   */\n+  private static final int MIN_COMPRESSIBLE_LENGTH = 18;\n+\n+  /**\n+   * All streams should start with the \"Stream identifier\", containing chunk type 0xff, a length\n+   * field of 0x6, and 'sNaPpY' in ASCII.\n+   */\n+  private static final byte[] STREAM_START = {\n+    (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59\n+  };\n+\n+  private final Snappy snappy = new Snappy();\n+  private boolean started;\n+\n+  public Bytes encode(Bytes in) {\n+    ByteBuf inBuf = Unpooled.wrappedBuffer(in.toArrayUnsafe());\n+    ByteBuf outBuf = Unpooled.buffer(in.size() / 2);\n+    try {\n+      encode(inBuf, outBuf);\n+      byte[] bytes = new byte[outBuf.readableBytes()];\n+      outBuf.readBytes(bytes);\n+      return Bytes.wrap(bytes);\n+    } finally {\n+      inBuf.release();\n+      outBuf.release();\n+    }\n+  }\n+\n+  public void encode(ByteBuf in, ByteBuf out) {\n+    if (!in.isReadable()) {\n+      return;\n+    }\n+\n+    if (!started) {\n+      started = true;\n+      out.writeBytes(STREAM_START);\n+    }\n+\n+    int dataLength = in.readableBytes();\n+    if (dataLength > MIN_COMPRESSIBLE_LENGTH) {\n+      for (; ; ) {", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NjMwNA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443496304", "bodyText": "Fixed.\nThis is from original code and I suppose it's a C style", "author": "Nashatyrev", "createdAt": "2020-06-22T11:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMzU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzNzQ2OA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442537468", "bodyText": "Nice test util - some more comments on what's happening here would be helpful :D", "author": "mbaxter", "createdAt": "2020-06-18T22:34:23Z", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/Utils.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc;\n+\n+import static java.lang.Integer.max;\n+import static java.lang.Integer.min;\n+\n+import com.google.common.collect.Streams;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.tuweni.bytes.Bytes;\n+\n+public class Utils {\n+\n+  public static List<List<ByteBuf>> generateTestSlices(Bytes... chunks) {", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwNTI1Mg==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443505252", "bodyText": "Done: 01d9e5e", "author": "Nashatyrev", "createdAt": "2020-06-22T11:54:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzNzQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzNzY4Ng==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442537686", "bodyText": "Stray comments", "author": "mbaxter", "createdAt": "2020-06-18T22:35:11Z", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/AbstractRequestHandlerTest.java", "diffHunk": "@@ -63,8 +55,8 @@\n   protected final Eth2Peer peer = mock(Eth2Peer.class);\n   protected T reqHandler;\n \n-  private Thread inputHandlerThread;\n-  private final AtomicBoolean inputHandlerDone = new AtomicBoolean(false);\n+  //  private Thread inputHandlerThread;\n+  //  private final AtomicBoolean inputHandlerDone = new AtomicBoolean(false);", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzODE5OQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442538199", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected void deliverBytes(final Bytes bytes, final int waitUntilBytesConsumed) {\n          \n          \n            \n              protected void deliverBytes(final Bytes bytes) {", "author": "mbaxter", "createdAt": "2020-06-18T22:36:43Z", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/AbstractRequestHandlerTest.java", "diffHunk": "@@ -123,14 +90,7 @@ protected void deliverBytes(final Bytes bytes) throws IOException {\n     deliverBytes(bytes, bytes.size());\n   }\n \n-  protected void deliverBytes(final Bytes bytes, final int waitUntilBytesConsumed)\n-      throws IOException {\n-    checkArgument(\n-        waitUntilBytesConsumed <= bytes.size(), \"Cannot wait for more bytes than those supplied.\");\n-    inputStream.deliverBytes(bytes);\n-    final int maxRemainingBytes = bytes.size() - waitUntilBytesConsumed;\n-    Waiter.waitFor(\n-        () ->\n-            assertThat(inputStream.countUnconsumedBytes()).isLessThanOrEqualTo(maxRemainingBytes));\n+  protected void deliverBytes(final Bytes bytes, final int waitUntilBytesConsumed) {", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzOTM1OA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442539358", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void shouldParseSingleResponseReceivedInSinglePacket() throws Exception {\n          \n          \n            \n              public void shouldParseSingleResponse() throws Exception {", "author": "mbaxter", "createdAt": "2020-06-18T22:40:25Z", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/RpcRequestDecoderTest.java", "diffHunk": "@@ -16,29 +16,54 @@\n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatThrownBy;\n \n+import io.netty.buffer.ByteBuf;\n+import java.util.ArrayList;\n+import java.util.List;\n import org.apache.tuweni.bytes.Bytes;\n import org.junit.jupiter.api.Test;\n import tech.pegasys.teku.datastructures.networking.libp2p.rpc.BeaconBlocksByRootRequestMessage;\n \n class RpcRequestDecoderTest extends RpcDecoderTestBase {\n \n-  private final RpcRequestDecoder<BeaconBlocksByRootRequestMessage> decoder =\n-      METHOD.createRequestDecoder();\n-\n   @Test\n   public void shouldParseSingleResponseReceivedInSinglePacket() throws Exception {", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MDE3Nw==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442540177", "bodyText": "(nit) This class should probably go in the testFixtures directory", "author": "mbaxter", "createdAt": "2020-06-18T22:42:57Z", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/Utils.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc;\n+\n+import static java.lang.Integer.max;\n+import static java.lang.Integer.min;\n+\n+import com.google.common.collect.Streams;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.tuweni.bytes.Bytes;\n+\n+public class Utils {", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MjQ0Mg==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442542442", "bodyText": "(nit) Could probably improve readability by just having an instance variable for the status decoder that we use throughout:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThatThrownBy(() -> encoding.createDecoder(StatusMessage.class).decodeOneMessage(input))\n          \n          \n            \n                assertThatThrownBy(() -> statusDecoder.decodeOneMessage(input))", "author": "mbaxter", "createdAt": "2020-06-18T22:50:11Z", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedEncodingTest.java", "diffHunk": "@@ -41,65 +42,109 @@\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenLengthPrefixIsTooLong() {\n-    assertThatThrownBy(\n-            () ->\n-                encoding.decodePayload(\n-                    inputStream(\"0xAAAAAAAAAAAAAAAAAAAA80\"), StatusMessage.class))\n+    ByteBuf input = inputByteBuffer(\"0xAAAAAAAAAAAAAAAAAAAA80\");\n+    assertThatThrownBy(() -> encoding.createDecoder(StatusMessage.class).decodeOneMessage(input))", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MzAxNQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442543015", "bodyText": "Why not:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    .isInstanceOf(RpcException.class)\n          \n          \n            \n                    .hasMessageContaining(\"payload smaller\");\n          \n          \n            \n                    .isEqualTo(RpcException.PAYLOAD_TRUNCATED);\n          \n      \n    \n    \n  \n\n?", "author": "mbaxter", "createdAt": "2020-06-18T22:52:05Z", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedEncodingTest.java", "diffHunk": "@@ -41,65 +42,109 @@\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenLengthPrefixIsTooLong() {\n-    assertThatThrownBy(\n-            () ->\n-                encoding.decodePayload(\n-                    inputStream(\"0xAAAAAAAAAAAAAAAAAAAA80\"), StatusMessage.class))\n+    ByteBuf input = inputByteBuffer(\"0xAAAAAAAAAAAAAAAAAAAA80\");\n+    assertThatThrownBy(() -> encoding.createDecoder(StatusMessage.class).decodeOneMessage(input))\n         .isEqualTo(RpcException.CHUNK_TOO_LONG);\n+    input.release();\n+    assertThat(input.refCnt()).isEqualTo(0);\n   }\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenNoPayloadIsPresent() {\n-    final InputStream invalidMessage = inputStream(ONE_BYTE_LENGTH_PREFIX);\n-    assertThatThrownBy(() -> encoding.decodePayload(invalidMessage, StatusMessage.class))\n-        .isEqualTo(RpcException.PAYLOAD_TRUNCATED);\n+    ByteBuf input = inputByteBuffer(ONE_BYTE_LENGTH_PREFIX);\n+    assertThatThrownBy(\n+            () -> {\n+              RpcByteBufDecoder<StatusMessage> decoder =\n+                  encoding.createDecoder(StatusMessage.class);\n+\n+              assertThat(decoder.decodeOneMessage(input)).isEmpty();\n+              decoder.complete();\n+            })\n+        .isInstanceOf(RpcException.class)\n+        .hasMessageContaining(\"payload smaller\");", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxMjY5Mw==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443512693", "bodyText": "Changed back for now.\nI just started replacing static exceptions instances but decided to make a separate PR for this later.\nJust filed an issue on that: #2190", "author": "Nashatyrev", "createdAt": "2020-06-22T12:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MzAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MzIwNg==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442543206", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    .isInstanceOf(RpcException.class)\n          \n          \n            \n                    .hasMessageContaining(\"payload smaller\");\n          \n          \n            \n                    .isEqualTo(RpcException.PAYLOAD_TRUNCATED);", "author": "mbaxter", "createdAt": "2020-06-18T22:52:41Z", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedEncodingTest.java", "diffHunk": "@@ -41,65 +42,109 @@\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenLengthPrefixIsTooLong() {\n-    assertThatThrownBy(\n-            () ->\n-                encoding.decodePayload(\n-                    inputStream(\"0xAAAAAAAAAAAAAAAAAAAA80\"), StatusMessage.class))\n+    ByteBuf input = inputByteBuffer(\"0xAAAAAAAAAAAAAAAAAAAA80\");\n+    assertThatThrownBy(() -> encoding.createDecoder(StatusMessage.class).decodeOneMessage(input))\n         .isEqualTo(RpcException.CHUNK_TOO_LONG);\n+    input.release();\n+    assertThat(input.refCnt()).isEqualTo(0);\n   }\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenNoPayloadIsPresent() {\n-    final InputStream invalidMessage = inputStream(ONE_BYTE_LENGTH_PREFIX);\n-    assertThatThrownBy(() -> encoding.decodePayload(invalidMessage, StatusMessage.class))\n-        .isEqualTo(RpcException.PAYLOAD_TRUNCATED);\n+    ByteBuf input = inputByteBuffer(ONE_BYTE_LENGTH_PREFIX);\n+    assertThatThrownBy(\n+            () -> {\n+              RpcByteBufDecoder<StatusMessage> decoder =\n+                  encoding.createDecoder(StatusMessage.class);\n+\n+              assertThat(decoder.decodeOneMessage(input)).isEmpty();\n+              decoder.complete();\n+            })\n+        .isInstanceOf(RpcException.class)\n+        .hasMessageContaining(\"payload smaller\");\n+    input.release();\n+    assertThat(input.refCnt()).isEqualTo(0);\n   }\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenPayloadTooShort() {\n     final Bytes correctMessage = createValidStatusMessage();\n     final int truncatedSize = correctMessage.size() - 5;\n-    final InputStream partialMessage = inputStream(correctMessage.slice(0, truncatedSize));\n-    assertThatThrownBy(() -> encoding.decodePayload(partialMessage, StatusMessage.class))\n-        .isEqualTo(RpcException.PAYLOAD_TRUNCATED);\n+    ByteBuf input = inputByteBuffer(correctMessage.slice(0, truncatedSize));\n+    assertThatThrownBy(\n+            () -> {\n+              RpcByteBufDecoder<StatusMessage> decoder =\n+                  encoding.createDecoder(StatusMessage.class);\n+              assertThat(decoder.decodeOneMessage(input)).isEmpty();\n+              decoder.complete();\n+            })\n+        .isInstanceOf(RpcException.class)\n+        .hasMessageContaining(\"payload smaller\");", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Njk0OA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442546948", "bodyText": "What's wrong with the existing line?", "author": "mbaxter", "createdAt": "2020-06-18T23:05:35Z", "path": "networking/p2p/src/main/java/tech/pegasys/teku/networking/p2p/libp2p/gossip/GossipHandler.java", "diffHunk": "@@ -64,7 +64,9 @@ public GossipHandler(\n           GOSSIP_MAX_SIZE);\n       return VALIDATION_FAILED;\n     }\n-    Bytes bytes = Bytes.wrapByteBuf(message.getData()).copy();", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxMzI1OQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443513259", "bodyText": "Mentioned the Bytes.wrapByteBuf bug above", "author": "Nashatyrev", "createdAt": "2020-06-22T12:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Njk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Nzg3Nw==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442547877", "bodyText": "What's this for?", "author": "mbaxter", "createdAt": "2020-06-18T23:08:49Z", "path": "teku/src/test/java/tech/pegasys/teku/cli/BeaconNodeCommandTest.java", "diffHunk": "@@ -203,7 +203,9 @@ private Path createConfigFile() throws IOException {\n     final URL configFile = this.getClass().getResource(\"/complete_config.yaml\");\n     final String updatedConfig =\n         Resources.toString(configFile, UTF_8)\n-            .replace(\"data-path: \\\".\\\"\", \"data-path: \\\"\" + dataPath.toString() + \"\\\"\");\n+            .replace(\n+                \"data-path: \\\".\\\"\",\n+                \"data-path: \\\"\" + dataPath.toString().replace(\"\\\\\", \"\\\\\\\\\") + \"\\\"\");", "originalCommit": "9d789946533d88950e8a8c76db5202d65149ef39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxMzQxNA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443513414", "bodyText": "This the test fix for Windows", "author": "Nashatyrev", "createdAt": "2020-06-22T12:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Nzg3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxMzc5Ng==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443513796", "bodyText": "The \\ in win paths should be escaped in the YAML", "author": "Nashatyrev", "createdAt": "2020-06-22T12:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Nzg3Nw=="}], "type": "inlineReview"}, {"oid": "644007a528c7d21a74522fa4c96641d468f03a8c", "url": "https://github.com/ConsenSys/teku/commit/644007a528c7d21a74522fa4c96641d468f03a8c", "message": "Move internal class to the bottom", "committedDate": "2020-06-22T11:01:36Z", "type": "commit"}, {"oid": "ab9ec744e8fffc014f595ec02be7c4b26602930c", "url": "https://github.com/ConsenSys/teku/commit/ab9ec744e8fffc014f595ec02be7c4b26602930c", "message": "Fix links to Netty classes", "committedDate": "2020-06-22T11:07:39Z", "type": "commit"}, {"oid": "bb6cb6a657b65ac944ed9ad8f85216276cdb37f4", "url": "https://github.com/ConsenSys/teku/commit/bb6cb6a657b65ac944ed9ad8f85216276cdb37f4", "message": "Remove irrelevant doc", "committedDate": "2020-06-22T11:08:52Z", "type": "commit"}, {"oid": "0424bb2d087bacc4ee6ef8bffc20b1b0b2df7ecf", "url": "https://github.com/ConsenSys/teku/commit/0424bb2d087bacc4ee6ef8bffc20b1b0b2df7ecf", "message": "Fix javadoc", "committedDate": "2020-06-22T11:10:21Z", "type": "commit"}, {"oid": "2db462a4fdbb085d5e3c2a7f2ee3eeca510ed813", "url": "https://github.com/ConsenSys/teku/commit/2db462a4fdbb085d5e3c2a7f2ee3eeca510ed813", "message": "SnappyFrameDecoder: fail on extra snappy header", "committedDate": "2020-06-22T11:19:20Z", "type": "commit"}, {"oid": "4af7640aaf03384fae3d70e225bb567c07eaed55", "url": "https://github.com/ConsenSys/teku/commit/4af7640aaf03384fae3d70e225bb567c07eaed55", "message": "Wording fix", "committedDate": "2020-06-22T11:23:50Z", "type": "commit"}, {"oid": "7a4060baaa9149ac701f3eba45561f91027acb35", "url": "https://github.com/ConsenSys/teku/commit/7a4060baaa9149ac701f3eba45561f91027acb35", "message": "Remove unnecessary synchronized", "committedDate": "2020-06-22T11:28:56Z", "type": "commit"}, {"oid": "0501a6a0a4616703b207a9d5908cacc6c18707ad", "url": "https://github.com/ConsenSys/teku/commit/0501a6a0a4616703b207a9d5908cacc6c18707ad", "message": "Apply spotless", "committedDate": "2020-06-22T11:33:41Z", "type": "commit"}, {"oid": "0aceea760bbc9e8779653d2b57e4eb540f7739a7", "url": "https://github.com/ConsenSys/teku/commit/0aceea760bbc9e8779653d2b57e4eb540f7739a7", "message": "Rename class", "committedDate": "2020-06-22T11:33:55Z", "type": "commit"}, {"oid": "8c45ba63f32efccdbd0dbee621f729e3310f0e78", "url": "https://github.com/ConsenSys/teku/commit/8c45ba63f32efccdbd0dbee621f729e3310f0e78", "message": "Minor style fix", "committedDate": "2020-06-22T11:35:33Z", "type": "commit"}, {"oid": "01d9e5ec0689b4b07a6abc7440a07da9d0ef7d46", "url": "https://github.com/ConsenSys/teku/commit/01d9e5ec0689b4b07a6abc7440a07da9d0ef7d46", "message": "Move Utils to testFixtures, add javadoc for the method", "committedDate": "2020-06-22T11:54:11Z", "type": "commit"}, {"oid": "186626b31e0acf74ee784152e2f418ffd19ee6e1", "url": "https://github.com/ConsenSys/teku/commit/186626b31e0acf74ee784152e2f418ffd19ee6e1", "message": "Tests cleanup", "committedDate": "2020-06-22T11:58:05Z", "type": "commit"}, {"oid": "caf219d6903217ed1478da23b6a3727f36fd607d", "url": "https://github.com/ConsenSys/teku/commit/caf219d6903217ed1478da23b6a3727f36fd607d", "message": "Minor test fixes", "committedDate": "2020-06-22T12:54:21Z", "type": "commit"}, {"oid": "30bf5426a12d43336ca784c3c804dd5da2abf780", "url": "https://github.com/ConsenSys/teku/commit/30bf5426a12d43336ca784c3c804dd5da2abf780", "message": "Simplify RPC response first byte handling", "committedDate": "2020-06-22T13:01:14Z", "type": "commit"}, {"oid": "b25386bdb73fe0143c2a3efd79eb425f1e9dfc96", "url": "https://github.com/ConsenSys/teku/commit/b25386bdb73fe0143c2a3efd79eb425f1e9dfc96", "message": "RpcRequestHandler.complete() should be called in any case of stream close", "committedDate": "2020-06-22T14:31:07Z", "type": "commit"}, {"oid": "a7877404f7e0e63f2cfadfdf67751a4e07e05007", "url": "https://github.com/ConsenSys/teku/commit/a7877404f7e0e63f2cfadfdf67751a4e07e05007", "message": "Make CompressionException back checked. Refactor Compressor/Rpc exceptions handling", "committedDate": "2020-06-22T15:58:54Z", "type": "commit"}, {"oid": "e32f47d8c72dbda75549ea8bd232d528e98b0f3b", "url": "https://github.com/ConsenSys/teku/commit/e32f47d8c72dbda75549ea8bd232d528e98b0f3b", "message": "Merge remote-tracking branch 'pegasys/master' into fix-snappy-blocking\n\n# Conflicts:\n#\tnetworking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/RpcResponseDecoder.java", "committedDate": "2020-06-22T16:01:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc4NTkyMA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443785920", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected abstract void throwDataTruncatedException(int dataLeft) throws TException;\n          \n          \n            \n              protected abstract void throwUnprocessedDataException(int dataLeft) throws TException;", "author": "mbaxter", "createdAt": "2020-06-22T19:45:06Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/AbstractByteBufDecoder.java", "diffHunk": "@@ -65,14 +64,15 @@\n   }\n \n   @Override\n-  public void complete() {\n+  public void complete() throws TException {\n     if (compositeByteBuf.isReadable()) {\n       compositeByteBuf.release();\n-      throw new PayloadSmallerThanExpectedException(\n-          \"Rpc stream complete, but unprocessed data left: \" + compositeByteBuf.readableBytes());\n+      throwDataTruncatedException(compositeByteBuf.readableBytes());\n     }\n   }\n \n+  protected abstract void throwDataTruncatedException(int dataLeft) throws TException;", "originalCommit": "e32f47d8c72dbda75549ea8bd232d528e98b0f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5NzE0MA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443797140", "bodyText": "I think this should throw the opposite error - we think we're done processing the response but there's extra data in the pipeline, so the payload was larger than we expected:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                throw new PayloadSmallerThanExpectedException(\n          \n          \n            \n                throw new PayloadLargerThanExpectedException(", "author": "mbaxter", "createdAt": "2020-06-22T20:09:10Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -194,14 +195,20 @@ public SnappyFrameDecoder(boolean validateChecksums) {\n           snappy.reset();\n           break;\n       }\n-    } catch (Exception e) {\n+    } catch (CompressionException e) {\n       corrupted = true;\n       throw e;\n     }\n     return Optional.ofNullable(ret);\n   }\n \n-  private static void checkByte(byte actual, byte expect) {\n+  @Override\n+  protected void throwDataTruncatedException(int dataLeft) throws CompressionException {\n+    throw new PayloadSmallerThanExpectedException(", "originalCommit": "e32f47d8c72dbda75549ea8bd232d528e98b0f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEzMTA1MQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r444131051", "bodyText": "No, here it means that we were requesting the next message to be decoded, there was just a part of this message which was stored and then the stream was prematurely completed. So the last message appeared truncated", "author": "Nashatyrev", "createdAt": "2020-06-23T10:43:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5NzE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5OTU5NQ==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443799595", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      \"Unexpected stream identifier contents. Mismatched snappy \" + \"protocol version?\");\n          \n          \n            \n                      \"Unexpected stream identifier contents. Mismatched snappy protocol version?\");", "author": "mbaxter", "createdAt": "2020-06-22T20:14:18Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -194,14 +195,20 @@ public SnappyFrameDecoder(boolean validateChecksums) {\n           snappy.reset();\n           break;\n       }\n-    } catch (Exception e) {\n+    } catch (CompressionException e) {\n       corrupted = true;\n       throw e;\n     }\n     return Optional.ofNullable(ret);\n   }\n \n-  private static void checkByte(byte actual, byte expect) {\n+  @Override\n+  protected void throwDataTruncatedException(int dataLeft) throws CompressionException {\n+    throw new PayloadSmallerThanExpectedException(\n+        \"Snappy stream complete, but unprocessed data left: \" + dataLeft);\n+  }\n+\n+  private static void checkByte(byte actual, byte expect) throws CompressionException {\n     if (actual != expect) {\n       throw new CompressionException(\n           \"Unexpected stream identifier contents. Mismatched snappy \" + \"protocol version?\");", "originalCommit": "e32f47d8c72dbda75549ea8bd232d528e98b0f3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgwMTg1Mw==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443801853", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                throw new PayloadSmallerThanExpectedException(\n          \n          \n            \n                throw new PayloadLargerThanExpectedException(", "author": "mbaxter", "createdAt": "2020-06-22T20:18:33Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/noop/NoopDecoder.java", "diffHunk": "@@ -31,4 +33,10 @@ public NoopDecoder(int expectedBytes) {\n     }\n     return Optional.of(in.readRetainedSlice(expectedBytes));\n   }\n+\n+  @Override\n+  protected void throwDataTruncatedException(int dataLeft) throws CompressionException {\n+    throw new PayloadSmallerThanExpectedException(", "originalCommit": "e32f47d8c72dbda75549ea8bd232d528e98b0f3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEzMTE2NA==", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r444131164", "bodyText": "Commented above", "author": "Nashatyrev", "createdAt": "2020-06-23T10:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgwMTg1Mw=="}], "type": "inlineReview"}, {"oid": "7f66d13e12b3f6027caba3d371ab439ebc159a59", "url": "https://github.com/ConsenSys/teku/commit/7f66d13e12b3f6027caba3d371ab439ebc159a59", "message": "Rename method and minor fix", "committedDate": "2020-06-23T10:44:38Z", "type": "commit"}, {"oid": "94fcb54402d0670a801c9ee4585112aac10e623d", "url": "https://github.com/ConsenSys/teku/commit/94fcb54402d0670a801c9ee4585112aac10e623d", "message": "Merge remote-tracking branch 'pegasys/master' into fix-snappy-blocking", "committedDate": "2020-06-23T10:44:44Z", "type": "commit"}]}