{"pr_number": 1147, "pr_title": "Implement and test Proto's getProofWithViewBoundary", "pr_createdAt": "2020-02-11T23:28:36Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1147", "timeline": [{"oid": "b6edef333807fea7fc29be0ff3f7ab5a1420bde4", "url": "https://github.com/ConsenSys/teku/commit/b6edef333807fea7fc29be0ff3f7ab5a1420bde4", "message": "Implement and test Proto's getProofWithViewBoundary", "committedDate": "2020-02-11T23:22:00Z", "type": "commit"}, {"oid": "97bf4e5bd82e8fb6eb0084baeb255eb7295701f4", "url": "https://github.com/ConsenSys/teku/commit/97bf4e5bd82e8fb6eb0084baeb255eb7295701f4", "message": "Remove unused variable", "committedDate": "2020-02-11T23:47:38Z", "type": "commit"}, {"oid": "aabbc5bb32387fe90f57e17663e7c5f3c00f030a", "url": "https://github.com/ConsenSys/teku/commit/aabbc5bb32387fe90f57e17663e7c5f3c00f030a", "message": "Refactor method names", "committedDate": "2020-02-11T23:56:13Z", "type": "commit"}, {"oid": "c4b9ba404f6d492d3e4cd2d9880216f853286b6b", "url": "https://github.com/ConsenSys/teku/commit/c4b9ba404f6d492d3e4cd2d9880216f853286b6b", "message": "Remove unnecessary line from test", "committedDate": "2020-02-11T23:59:18Z", "type": "commit"}, {"oid": "e5477e5ddfd5412db946b1d632c963a03d9f87f4", "url": "https://github.com/ConsenSys/teku/commit/e5477e5ddfd5412db946b1d632c963a03d9f87f4", "message": "Remove now-irrelevant test", "committedDate": "2020-02-12T00:01:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQwMDc0MQ==", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378400741", "bodyText": "We should probably throw an exception of the value isn't found.", "author": "mbaxter", "createdAt": "2020-02-12T17:26:46Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "diffHunk": "@@ -38,45 +38,110 @@ protected MerkleTree(int treeDepth) {\n     zeroHashes = generateZeroHashes(treeDepth);\n   }\n \n-  abstract void add(Bytes32 leaf);\n+  public abstract void add(Bytes32 leaf);\n \n-  protected abstract int getNumberOfLeaves();\n+  public abstract int getNumberOfLeaves();\n \n   protected static List<Bytes32> generateZeroHashes(int height) {\n     List<Bytes32> zeroHashes = new ArrayList<>();\n-    for (int i = 0; i < height; i++) {\n-      zeroHashes.add(Bytes32.ZERO);\n-    }\n-    for (int i = 0; i < height - 1; i++) {\n-      zeroHashes.set(i + 1, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i), zeroHashes.get(i))));\n+    zeroHashes.add(Bytes32.ZERO);\n+    for (int i = 1; i < height; i++) {\n+      zeroHashes.add(\n+          i, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i - 1), zeroHashes.get(i - 1))));\n     }\n     return zeroHashes;\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByValue(Bytes32 value) {\n+  public SSZVector<Bytes32> getProof(Bytes32 value) {\n     int index = tree.get(0).indexOf(value);", "originalCommit": "e5477e5ddfd5412db946b1d632c963a03d9f87f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ0NzE0NQ==", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378447145", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-12T18:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQwMDc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQwNTgwNg==", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378405806", "bodyText": "I stared at this way too long - can we add a comment here? :D", "author": "mbaxter", "createdAt": "2020-02-12T17:35:59Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "diffHunk": "@@ -38,45 +38,110 @@ protected MerkleTree(int treeDepth) {\n     zeroHashes = generateZeroHashes(treeDepth);\n   }\n \n-  abstract void add(Bytes32 leaf);\n+  public abstract void add(Bytes32 leaf);\n \n-  protected abstract int getNumberOfLeaves();\n+  public abstract int getNumberOfLeaves();\n \n   protected static List<Bytes32> generateZeroHashes(int height) {\n     List<Bytes32> zeroHashes = new ArrayList<>();\n-    for (int i = 0; i < height; i++) {\n-      zeroHashes.add(Bytes32.ZERO);\n-    }\n-    for (int i = 0; i < height - 1; i++) {\n-      zeroHashes.set(i + 1, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i), zeroHashes.get(i))));\n+    zeroHashes.add(Bytes32.ZERO);\n+    for (int i = 1; i < height; i++) {\n+      zeroHashes.add(\n+          i, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i - 1), zeroHashes.get(i - 1))));\n     }\n     return zeroHashes;\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByValue(Bytes32 value) {\n+  public SSZVector<Bytes32> getProof(Bytes32 value) {\n     int index = tree.get(0).indexOf(value);\n-    return getProofTreeByIndex(index);\n+    return getProof(index);\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByIndex(int index) {\n+  public SSZVector<Bytes32> getProof(int index) {\n     List<Bytes32> proof = new ArrayList<>();\n     for (int i = 0; i < treeDepth; i++) {\n       index = index % 2 == 1 ? index - 1 : index + 1;", "originalCommit": "e5477e5ddfd5412db946b1d632c963a03d9f87f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ0OTAwMQ==", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378449001", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-02-12T18:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQwNTgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQyMTIwNA==", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378421204", "bodyText": "Is this equivalent to checking that viewLimit is <= # of leaf nodes?  Could we just have a single check at the top for this?", "author": "mbaxter", "createdAt": "2020-02-12T18:05:15Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "diffHunk": "@@ -38,45 +38,110 @@ protected MerkleTree(int treeDepth) {\n     zeroHashes = generateZeroHashes(treeDepth);\n   }\n \n-  abstract void add(Bytes32 leaf);\n+  public abstract void add(Bytes32 leaf);\n \n-  protected abstract int getNumberOfLeaves();\n+  public abstract int getNumberOfLeaves();\n \n   protected static List<Bytes32> generateZeroHashes(int height) {\n     List<Bytes32> zeroHashes = new ArrayList<>();\n-    for (int i = 0; i < height; i++) {\n-      zeroHashes.add(Bytes32.ZERO);\n-    }\n-    for (int i = 0; i < height - 1; i++) {\n-      zeroHashes.set(i + 1, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i), zeroHashes.get(i))));\n+    zeroHashes.add(Bytes32.ZERO);\n+    for (int i = 1; i < height; i++) {\n+      zeroHashes.add(\n+          i, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i - 1), zeroHashes.get(i - 1))));\n     }\n     return zeroHashes;\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByValue(Bytes32 value) {\n+  public SSZVector<Bytes32> getProof(Bytes32 value) {\n     int index = tree.get(0).indexOf(value);\n-    return getProofTreeByIndex(index);\n+    return getProof(index);\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByIndex(int index) {\n+  public SSZVector<Bytes32> getProof(int index) {\n     List<Bytes32> proof = new ArrayList<>();\n     for (int i = 0; i < treeDepth; i++) {\n       index = index % 2 == 1 ? index - 1 : index + 1;\n-      if (index < tree.get(i).size()) proof.add(tree.get(i).get(index));\n-      else proof.add(zeroHashes.get(i));\n+      if (index < tree.get(i).size()) {\n+        proof.add(tree.get(i).get(index));\n+      } else {\n+        proof.add(zeroHashes.get(i));\n+      }\n       index /= 2;\n     }\n     proof.add(calcMixInValue());\n     return new SSZVector<>(proof, Bytes32.class);\n   }\n \n-  private Bytes32 calcMixInValue() {\n+  private Bytes32 calcViewBoundaryRoot(int depth, int viewLimit) {\n+    if (depth == 0) {\n+      return zeroHashes.get(0);\n+    }\n+    depth -= 1;\n+    Bytes32 deeperRoot = calcViewBoundaryRoot(depth, viewLimit);\n+    if ((viewLimit & (1 << depth)) != 0) {\n+      return Hash.sha2_256(Bytes.concatenate(tree.get(depth).get(viewLimit >> depth), deeperRoot));\n+    } else {\n+      return Hash.sha2_256(Bytes.concatenate(deeperRoot, zeroHashes.get(depth)));\n+    }\n+  }\n+\n+  public SSZVector<Bytes32> getProofWithViewBoundary(Bytes32 value, int viewLimit) {\n+    return getProofWithViewBoundary(tree.get(0).indexOf(value), viewLimit);\n+  }\n+\n+  public SSZVector<Bytes32> getProofWithViewBoundary(int index, int viewLimit) {\n+    checkArgument(index < viewLimit, \"MerkleTree: Index must be within view limit\");\n+\n+    List<Bytes32> proof = new ArrayList<>();\n+    for (int i = 0; i < treeDepth; i++) {\n+      // Get index of sibling node\n+      index = index % 2 == 1 ? index - 1 : index + 1;\n+\n+      // Check how much of the tree at this level is strictly within the view limit.\n+      int limit = viewLimit >> i;\n+\n+      checkArgument(\n+          limit <= tree.get(i).size(), \"MerkleTree: Tree is too small for given limit at height\");", "originalCommit": "e5477e5ddfd5412db946b1d632c963a03d9f87f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ1MDMzOA==", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378450338", "bodyText": "I am not sure if the two are equivalent", "author": "cemozerr", "createdAt": "2020-02-12T19:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQyMTIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQyMzE1Mw==", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378423153", "bodyText": "Looks like viewLimit is exclusive - can we add some javadoc explaining the parameters?", "author": "mbaxter", "createdAt": "2020-02-12T18:09:06Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "diffHunk": "@@ -38,45 +38,110 @@ protected MerkleTree(int treeDepth) {\n     zeroHashes = generateZeroHashes(treeDepth);\n   }\n \n-  abstract void add(Bytes32 leaf);\n+  public abstract void add(Bytes32 leaf);\n \n-  protected abstract int getNumberOfLeaves();\n+  public abstract int getNumberOfLeaves();\n \n   protected static List<Bytes32> generateZeroHashes(int height) {\n     List<Bytes32> zeroHashes = new ArrayList<>();\n-    for (int i = 0; i < height; i++) {\n-      zeroHashes.add(Bytes32.ZERO);\n-    }\n-    for (int i = 0; i < height - 1; i++) {\n-      zeroHashes.set(i + 1, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i), zeroHashes.get(i))));\n+    zeroHashes.add(Bytes32.ZERO);\n+    for (int i = 1; i < height; i++) {\n+      zeroHashes.add(\n+          i, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i - 1), zeroHashes.get(i - 1))));\n     }\n     return zeroHashes;\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByValue(Bytes32 value) {\n+  public SSZVector<Bytes32> getProof(Bytes32 value) {\n     int index = tree.get(0).indexOf(value);\n-    return getProofTreeByIndex(index);\n+    return getProof(index);\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByIndex(int index) {\n+  public SSZVector<Bytes32> getProof(int index) {\n     List<Bytes32> proof = new ArrayList<>();\n     for (int i = 0; i < treeDepth; i++) {\n       index = index % 2 == 1 ? index - 1 : index + 1;\n-      if (index < tree.get(i).size()) proof.add(tree.get(i).get(index));\n-      else proof.add(zeroHashes.get(i));\n+      if (index < tree.get(i).size()) {\n+        proof.add(tree.get(i).get(index));\n+      } else {\n+        proof.add(zeroHashes.get(i));\n+      }\n       index /= 2;\n     }\n     proof.add(calcMixInValue());\n     return new SSZVector<>(proof, Bytes32.class);\n   }\n \n-  private Bytes32 calcMixInValue() {\n+  private Bytes32 calcViewBoundaryRoot(int depth, int viewLimit) {\n+    if (depth == 0) {\n+      return zeroHashes.get(0);\n+    }\n+    depth -= 1;\n+    Bytes32 deeperRoot = calcViewBoundaryRoot(depth, viewLimit);\n+    if ((viewLimit & (1 << depth)) != 0) {\n+      return Hash.sha2_256(Bytes.concatenate(tree.get(depth).get(viewLimit >> depth), deeperRoot));\n+    } else {\n+      return Hash.sha2_256(Bytes.concatenate(deeperRoot, zeroHashes.get(depth)));\n+    }\n+  }\n+\n+  public SSZVector<Bytes32> getProofWithViewBoundary(Bytes32 value, int viewLimit) {\n+    return getProofWithViewBoundary(tree.get(0).indexOf(value), viewLimit);\n+  }\n+\n+  public SSZVector<Bytes32> getProofWithViewBoundary(int index, int viewLimit) {", "originalCommit": "e5477e5ddfd5412db946b1d632c963a03d9f87f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ1MzA5OA==", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378453098", "bodyText": "Switched to inclusive (it made more sense) and added javadocs.", "author": "cemozerr", "createdAt": "2020-02-12T19:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQyMzE1Mw=="}], "type": "inlineReview"}, {"oid": "8e8369b70b40cc49e8a4e798a0c7a2e40e1dc346", "url": "https://github.com/ConsenSys/teku/commit/8e8369b70b40cc49e8a4e798a0c7a2e40e1dc346", "message": "Resolve comments", "committedDate": "2020-02-12T19:42:36Z", "type": "commit"}]}