{"pr_number": 2271, "pr_title": "[Issue 2037] Limit hot blocks in memory (with race condition fix)", "pr_createdAt": "2020-06-30T16:38:59Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2271", "timeline": [{"oid": "96a632968741d30d6d150e97fd0c76d1978be3cf", "url": "https://github.com/ConsenSys/teku/commit/96a632968741d30d6d150e97fd0c76d1978be3cf", "message": "Revert \"Revert \"[Issue 2037] Limit hot blocks kept in memory (#2211)\" (#2240)\"\n\nThis reverts commit 50fa4ed6a34761f2c2c9d9d97621e41b7c05266f.", "committedDate": "2020-06-29T19:50:36Z", "type": "commit"}, {"oid": "299f87dd29690c7bfb35efd0c5bc065af61e77d9", "url": "https://github.com/ConsenSys/teku/commit/299f87dd29690c7bfb35efd0c5bc065af61e77d9", "message": "Fix race condition - only update blockTree when necessary\n\nThis prevents transactions irrelevant to the blockTree structure from\noverwriting blockTree updates.", "committedDate": "2020-06-30T16:13:29Z", "type": "commit"}, {"oid": "169311e77f22446ae8f8ad2c72a4c5bbd6511bfd", "url": "https://github.com/ConsenSys/teku/commit/169311e77f22446ae8f8ad2c72a4c5bbd6511bfd", "message": "Merge branch 'master' into issue-2037/limit-hot-blocks-in-memory-w-race-condition-fix", "committedDate": "2020-06-30T16:17:16Z", "type": "commit"}, {"oid": "017d12c8686c4d44c72289d4c9ae88dc666dbd8c", "url": "https://github.com/ConsenSys/teku/commit/017d12c8686c4d44c72289d4c9ae88dc666dbd8c", "message": "Merge branch 'master' into issue-2037/limit-hot-blocks-in-memory-w-race-condition-fix", "committedDate": "2020-06-30T17:52:54Z", "type": "commit"}, {"oid": "a2a8ccd57029cbbda3541602263bac3cc7c9a178", "url": "https://github.com/ConsenSys/teku/commit/a2a8ccd57029cbbda3541602263bac3cc7c9a178", "message": "Merge branch 'master' into issue-2037/limit-hot-blocks-in-memory-w-race-condition-fix", "committedDate": "2020-06-30T23:52:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1ODU0OQ==", "url": "https://github.com/ConsenSys/teku/pull/2271#discussion_r448058549", "bodyText": "Would be good to include as much information in this exception message as possible - it proved quite hard to understand when it was popping up a lot last time.  Ideally it would be good to start and end slots we were trying to load blocks for and the block root of the state we were trying to regenerate.", "author": "ajsutton", "createdAt": "2020-07-01T00:58:02Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/AsyncChainStateGenerator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.common.collect.Lists;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.core.lookup.BlockProvider;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.hashtree.HashTree;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+\n+class AsyncChainStateGenerator {\n+  public static final int DEFAULT_BLOCK_BATCH_SIZE = 250;\n+\n+  private final HashTree blockTree;\n+  private final BlockProvider blockProvider;\n+  private final StateProvider stateProvider;\n+  private final int blockBatchSize;\n+\n+  private AsyncChainStateGenerator(\n+      final HashTree blockTree,\n+      final BlockProvider blockProvider,\n+      final StateProvider stateProvider,\n+      final int blockBatchSize) {\n+    this.blockTree = blockTree;\n+    this.blockProvider = blockProvider;\n+    this.stateProvider = stateProvider;\n+    this.blockBatchSize = blockBatchSize;\n+  }\n+\n+  public static AsyncChainStateGenerator create(\n+      final HashTree blockTree,\n+      final BlockProvider blockProvider,\n+      final StateProvider stateProvider) {\n+    return new AsyncChainStateGenerator(\n+        blockTree, blockProvider, stateProvider, DEFAULT_BLOCK_BATCH_SIZE);\n+  }\n+\n+  public SafeFuture<BeaconState> generateTargetState(final Bytes32 targetRoot) {\n+    if (!blockTree.contains(targetRoot)) {\n+      return SafeFuture.failedFuture(\n+          new IllegalArgumentException(\"Target root is unknown: \" + targetRoot));\n+    }\n+\n+    final SafeFuture<BeaconState> lastState = new SafeFuture<>();\n+    generateStates(\n+            targetRoot,\n+            (block, state) -> {\n+              if (block.getRoot().equals(targetRoot)) {\n+                lastState.complete(state);\n+              }\n+            })\n+        .finish(\n+            // Make sure future is completed\n+            () ->\n+                lastState.completeExceptionally(\n+                    new IllegalStateException(\"Failed to generate state for \" + targetRoot)),\n+            lastState::completeExceptionally);\n+\n+    return lastState;\n+  }\n+\n+  public SafeFuture<?> generateStates(final Bytes32 targetRoot, final StateHandler handler) {\n+    return SafeFuture.of(\n+        () -> {\n+          // Build chain from target root to the first ancestor with a known state\n+          final AtomicReference<BeaconState> baseState = new AtomicReference<>(null);\n+          final List<Bytes32> chain =\n+              blockTree.collectChainRoots(\n+                  targetRoot,\n+                  (currentRoot) -> {\n+                    stateProvider.getState(currentRoot).ifPresent(baseState::set);\n+                    return baseState.get() == null;\n+                  });\n+\n+          if (baseState.get() == null) {\n+            throw new IllegalArgumentException(\"Unable to find base state to build on\");\n+          }\n+\n+          if (chain.size() == 0) {\n+            throw new IllegalStateException(\"Failed to retrieve chain\");\n+          }\n+\n+          // Process chain in batches\n+          final List<List<Bytes32>> blockBatches = Lists.partition(chain, blockBatchSize);\n+          // Request and process each batch of blocks in order\n+          SafeFuture<BeaconState> future =\n+              processBlockBatch(blockBatches.get(0), baseState.get(), handler);\n+          for (int i = 1; i < blockBatches.size(); i++) {\n+            final List<Bytes32> blockBatch = blockBatches.get(i);\n+            future = future.thenCompose(state -> processBlockBatch(blockBatch, state, handler));\n+          }\n+          return future;\n+        });\n+  }\n+\n+  private SafeFuture<BeaconState> processBlockBatch(\n+      final List<Bytes32> blockRoots, final BeaconState startState, final StateHandler handler) {\n+    checkArgument(startState != null, \"Must provide start state\");\n+    return blockProvider\n+        .getBlocks(blockRoots)\n+        .thenApply(\n+            blocks -> {\n+              final List<SignedBeaconBlock> chainBlocks =\n+                  blockRoots.stream()\n+                      .map(blocks::get)\n+                      .filter(Objects::nonNull)\n+                      .collect(Collectors.toList());\n+              if (chainBlocks.size() < blockRoots.size()) {\n+                final String missingBlocks =\n+                    blockRoots.stream()\n+                        .filter(root -> !blocks.containsKey(root))\n+                        .map(Object::toString)\n+                        .collect(Collectors.joining(\", \"));\n+                throw new IllegalStateException(\"Failed to retrieve blocks: \" + missingBlocks);", "originalCommit": "a2a8ccd57029cbbda3541602263bac3cc7c9a178", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1OTcxMQ==", "url": "https://github.com/ConsenSys/teku/pull/2271#discussion_r448559711", "bodyText": "Added more info to these exceptions and added some logging", "author": "mbaxter", "createdAt": "2020-07-01T19:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1ODU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA2MTQ5NA==", "url": "https://github.com/ConsenSys/teku/pull/2271#discussion_r448061494", "bodyText": "We probably shouldn't modify the list that's passed in by sorting it.  That said, we never seem to actually run this code so maybe just remove it?", "author": "ajsutton", "createdAt": "2020-07-01T01:09:31Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/ChainStateGenerator.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+\n+class ChainStateGenerator {\n+  private final BlockProcessor blockProcessor = new BlockProcessor();\n+  private final List<SignedBeaconBlock> chain;\n+  private final BeaconState baseState;\n+\n+  private ChainStateGenerator(\n+      final List<SignedBeaconBlock> chain,\n+      final BeaconState baseState,\n+      final boolean skipValidation) {\n+    if (!skipValidation) {\n+      chain.sort(Comparator.comparing(SignedBeaconBlock::getSlot));", "originalCommit": "a2a8ccd57029cbbda3541602263bac3cc7c9a178", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5ODQ5Nw==", "url": "https://github.com/ConsenSys/teku/pull/2271#discussion_r448098497", "bodyText": "nit: It may be worth logging an issue to tidy up the future handling then make all these TODO comments reference that issue number so they're easier to find (e.g. `// TODO(#xxxx) - handle future properly)", "author": "ajsutton", "createdAt": "2020-07-01T03:44:19Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -299,14 +334,17 @@ public SignedBeaconBlock getSignedBlock(Bytes32 blockRoot) {\n     if (block == null) {\n       return Optional.empty();\n     }\n-    return getOrGenerateBlockState(blockRoot).map((state) -> new SignedBlockAndState(block, state));\n+    // TODO - handle future properly", "originalCommit": "a2a8ccd57029cbbda3541602263bac3cc7c9a178", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMDc5MQ==", "url": "https://github.com/ConsenSys/teku/pull/2271#discussion_r448100791", "bodyText": "Should we have a version of this that commits an update to time (or anything else that doesn't affect the block tree) before the transaction applies?  Basically covering the race condition case we had previously.  Sorry if I missed it somewhere.", "author": "ajsutton", "createdAt": "2020-07-01T03:55:28Z", "path": "storage/src/test/java/tech/pegasys/teku/storage/store/StoreTest.java", "diffHunk": "@@ -44,58 +48,50 @@\n   private final ChainBuilder chainBuilder = ChainBuilder.create(VALIDATOR_KEYS);\n \n   @Test\n-  public void getBlockState_withLimitedStateCache() throws StateTransitionException {\n-    final SignedBlockAndState genesis = chainBuilder.generateGenesis();\n-    final Checkpoint genesisCheckpoint = chainBuilder.getCurrentCheckpointForEpoch(0);\n-    // Create a new store with a small state cache\n-    final int stateCacheSize = 10;\n-    final Store store =\n-        new Store(\n-            new StubMetricsSystem(),\n-            genesis.getState().getGenesis_time(),\n-            genesis.getState().getGenesis_time(),\n-            genesisCheckpoint,\n-            genesisCheckpoint,\n-            genesisCheckpoint,\n-            Map.of(genesis.getRoot(), genesis.getBlock()),\n-            StateProvider.NOOP,\n-            Map.of(genesisCheckpoint, genesis.getState()),\n-            genesis.getState(),\n-            Collections.emptyMap(),\n-            stateCacheSize);\n-\n-    // Generate enough blocks to exceed our cache limit\n-    final List<SignedBlockAndState> blocks =\n-        chainBuilder.generateBlocksUpToSlot(3 * stateCacheSize);\n-    addBlocks(store, blocks);\n-\n-    // Request states in order\n-    for (SignedBlockAndState block : blocks) {\n-      final BeaconState result = store.getBlockState(block.getRoot());\n-      assertThat(result).isNotNull();\n-      assertThat(result.hash_tree_root()).isEqualTo(block.getBlock().getMessage().getState_root());\n-    }\n+  public void getSignedBlock_withLimitedCache() throws StateTransitionException {\n+    processChainWithLimitedCache(\n+        (store, blockAndState) -> {\n+          final SignedBeaconBlock expectedBlock = blockAndState.getBlock();\n+          final SignedBeaconBlock blockResult = store.getSignedBlock(expectedBlock.getRoot());\n+          assertThat(blockResult)\n+              .withFailMessage(\"Expected block %s to be available\", expectedBlock.getSlot())\n+              .isEqualTo(expectedBlock);\n+        });\n+  }\n \n-    // Request states in reverse order\n-    Collections.reverse(blocks);\n-    for (SignedBlockAndState block : blocks) {\n-      final BeaconState result = store.getBlockState(block.getRoot());\n-      assertThat(result).isNotNull();\n-      assertThat(result.hash_tree_root()).isEqualTo(block.getBlock().getMessage().getState_root());\n-    }\n+  @Test\n+  public void getBlockState_withLimitedCache() throws StateTransitionException {\n+    processChainWithLimitedCache(\n+        (store, blockAndState) -> {\n+          final BeaconState result = store.getBlockState(blockAndState.getRoot());\n+          assertThat(result)\n+              .withFailMessage(\n+                  \"Expected state for block %s to be available\", blockAndState.getSlot())\n+              .isNotNull();\n+          assertThat(result.hash_tree_root())\n+              .isEqualTo(blockAndState.getBlock().getMessage().getState_root());\n+        });\n   }\n \n   @Test\n   public void shouldApplyChangesWhenTransactionCommits() throws StateTransitionException {", "originalCommit": "a2a8ccd57029cbbda3541602263bac3cc7c9a178", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2MDMxOQ==", "url": "https://github.com/ConsenSys/teku/pull/2271#discussion_r448560319", "bodyText": "I thought this test would be messy and involve spinning up various threads, but found a simple way to test using StubAsyncRunner \ud83c\udf89", "author": "mbaxter", "createdAt": "2020-07-01T19:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMDc5MQ=="}], "type": "inlineReview"}, {"oid": "7b43de620c11f9c6f057e60fbd2bb7bd210c57fa", "url": "https://github.com/ConsenSys/teku/commit/7b43de620c11f9c6f057e60fbd2bb7bd210c57fa", "message": "Merge branch 'master' into issue-2037/limit-hot-blocks-in-memory-w-race-condition-fix", "committedDate": "2020-07-01T14:58:15Z", "type": "commit"}, {"oid": "afa858a6fd1dc2a5aad8af285bb0861c5f8e0137", "url": "https://github.com/ConsenSys/teku/commit/afa858a6fd1dc2a5aad8af285bb0861c5f8e0137", "message": "Add more descriptive errors, and logs", "committedDate": "2020-07-01T17:30:00Z", "type": "commit"}, {"oid": "3fea7d4b328f28acda581ca6af792675d483d6aa", "url": "https://github.com/ConsenSys/teku/commit/3fea7d4b328f28acda581ca6af792675d483d6aa", "message": "Cut List sorting", "committedDate": "2020-07-01T17:32:01Z", "type": "commit"}, {"oid": "fea03e0abf931dc9735f9e430319ddac4b010202", "url": "https://github.com/ConsenSys/teku/commit/fea03e0abf931dc9735f9e430319ddac4b010202", "message": "Cleanup TODO's, reference follow-up ticket", "committedDate": "2020-07-01T17:39:56Z", "type": "commit"}, {"oid": "24681e3402b35a513b0ab598c804a6e45bb723f5", "url": "https://github.com/ConsenSys/teku/commit/24681e3402b35a513b0ab598c804a6e45bb723f5", "message": "Clean up StoreTest", "committedDate": "2020-07-01T18:14:37Z", "type": "commit"}, {"oid": "d41a195c4e5d9daa2d2afa819728cb7d64d5baca", "url": "https://github.com/ConsenSys/teku/commit/d41a195c4e5d9daa2d2afa819728cb7d64d5baca", "message": "Add test for interleaved Store transactions", "committedDate": "2020-07-01T18:58:53Z", "type": "commit"}, {"oid": "72b40e2aeac08fe49d71dc535b7c1dcfd9771ce8", "url": "https://github.com/ConsenSys/teku/commit/72b40e2aeac08fe49d71dc535b7c1dcfd9771ce8", "message": "Merge branch 'master' into issue-2037/limit-hot-blocks-in-memory-w-race-condition-fix", "committedDate": "2020-07-01T18:59:15Z", "type": "commit"}]}