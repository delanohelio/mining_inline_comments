{"pr_number": 2700, "pr_title": "Requeue operations from blocks when re-org occurs", "pr_createdAt": "2020-08-31T16:51:44Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2700", "timeline": [{"oid": "8898417952e3b51213bfa2e27959384cefae52fd", "url": "https://github.com/ConsenSys/teku/commit/8898417952e3b51213bfa2e27959384cefae52fd", "message": "Add blockImportResult isBlockOnCanonical chain variable", "committedDate": "2020-08-31T10:26:00Z", "type": "commit"}, {"oid": "8d294cfccf62901938db180dad721331a870e186", "url": "https://github.com/ConsenSys/teku/commit/8d294cfccf62901938db180dad721331a870e186", "message": "Only remove operations from pools if block is on canonical chain", "committedDate": "2020-08-31T10:31:53Z", "type": "commit"}, {"oid": "dbf8d88f79e5a892ad7f29236a884e9a9681bb07", "url": "https://github.com/ConsenSys/teku/commit/dbf8d88f79e5a892ad7f29236a884e9a9681bb07", "message": "Implement OperationsReOrgManager", "committedDate": "2020-08-31T16:50:25Z", "type": "commit"}, {"oid": "87f4df1d40e627e1fa2d7731b1fc8f69d49a5a1f", "url": "https://github.com/ConsenSys/teku/commit/87f4df1d40e627e1fa2d7731b1fc8f69d49a5a1f", "message": "Add comment", "committedDate": "2020-09-01T10:40:20Z", "type": "commit"}, {"oid": "8a4c3aeaf1d0804ffce3ea30410b9f89ce11e7c9", "url": "https://github.com/ConsenSys/teku/commit/8a4c3aeaf1d0804ffce3ea30410b9f89ce11e7c9", "message": "Refactor OperationsReOrgManager and run spotless", "committedDate": "2020-09-01T10:56:07Z", "type": "commit"}, {"oid": "5c64740761812d65ed3e8f0203c8917dd19c4292", "url": "https://github.com/ConsenSys/teku/commit/5c64740761812d65ed3e8f0203c8917dd19c4292", "message": "Add better future handling in case attestation processing goes awry", "committedDate": "2020-09-01T11:20:52Z", "type": "commit"}, {"oid": "2c0816fdc1a2a585964be22141ce086d9502a1c7", "url": "https://github.com/ConsenSys/teku/commit/2c0816fdc1a2a585964be22141ce086d9502a1c7", "message": "Run spotless", "committedDate": "2020-09-01T11:26:24Z", "type": "commit"}, {"oid": "c1ad6fe32563d2fefbc58af72610896e6d2bb9cb", "url": "https://github.com/ConsenSys/teku/commit/c1ad6fe32563d2fefbc58af72610896e6d2bb9cb", "message": "Start the integration test for OperationsReOrgManager", "committedDate": "2020-09-01T15:41:44Z", "type": "commit"}, {"oid": "855ee3ffcea1f5581321cc4e7522a1eddc64d36c", "url": "https://github.com/ConsenSys/teku/commit/855ee3ffcea1f5581321cc4e7522a1eddc64d36c", "message": "Run spotless", "committedDate": "2020-09-01T15:44:11Z", "type": "commit"}, {"oid": "6235383e2238fad15c5f3d2185ef4899616cfb16", "url": "https://github.com/ConsenSys/teku/commit/6235383e2238fad15c5f3d2185ef4899616cfb16", "message": "Improve test", "committedDate": "2020-09-01T16:36:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkwNjA1Ng==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r481906056", "bodyText": "I don't think this is worth a warn level - if the block was finalized during the processing it isn't a big deal if we don't recover the operations from it.", "author": "ajsutton", "createdAt": "2020-09-02T08:53:30Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/OperationsReOrgManager.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.statetransition;\n+\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.attestation.ValidateableAttestation;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlockBody;\n+import tech.pegasys.teku.datastructures.operations.AttesterSlashing;\n+import tech.pegasys.teku.datastructures.operations.ProposerSlashing;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.statetransition.attestation.AggregatingAttestationPool;\n+import tech.pegasys.teku.statetransition.attestation.AttestationManager;\n+import tech.pegasys.teku.storage.api.ReorgEventChannel;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class OperationsReOrgManager implements ReorgEventChannel {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  final OperationPool<SignedVoluntaryExit> exitPool;\n+  final OperationPool<ProposerSlashing> proposerSlashingPool;\n+  final OperationPool<AttesterSlashing> attesterSlashingPool;\n+  final AttestationManager attestationManager;\n+  final AggregatingAttestationPool attestationPool;\n+  final RecentChainData recentChainData;\n+\n+  public OperationsReOrgManager(\n+      OperationPool<ProposerSlashing> proposerSlashingPool,\n+      OperationPool<AttesterSlashing> attesterSlashingPool,\n+      OperationPool<SignedVoluntaryExit> exitPool,\n+      AggregatingAttestationPool attestationPool,\n+      AttestationManager attestationManager,\n+      RecentChainData recentChainData) {\n+    this.exitPool = exitPool;\n+    this.proposerSlashingPool = proposerSlashingPool;\n+    this.attesterSlashingPool = attesterSlashingPool;\n+    this.attestationManager = attestationManager;\n+    this.attestationPool = attestationPool;\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  @Override\n+  public void reorgOccurred(\n+      Bytes32 bestBlockRoot, UInt64 bestSlot, Bytes32 oldBestBlockRoot, UInt64 commonAncestorSlot) {\n+    NavigableMap<UInt64, Bytes32> notCanonicalBlockRoots =\n+        recentChainData.getAncestorRootsForRoot(commonAncestorSlot, oldBestBlockRoot);\n+    notCanonicalBlockRoots.forEach(\n+        (__, root) -> {\n+          SafeFuture<Optional<BeaconBlock>> maybeBlockFuture =\n+              recentChainData.retrieveBlockByRoot(root);\n+          maybeBlockFuture\n+              .thenAccept(\n+                  maybeBlock ->\n+                      maybeBlock.ifPresentOrElse(\n+                          block -> {\n+                            BeaconBlockBody blockBody = block.getBody();\n+                            proposerSlashingPool.addAll(blockBody.getProposer_slashings());\n+                            attesterSlashingPool.addAll(blockBody.getAttester_slashings());\n+                            exitPool.addAll(blockBody.getVoluntary_exits());\n+\n+                            // Attestations need to get re-processed through AttestationManager\n+                            // because we don't have access to the state with which they were\n+                            // verified anymore and we need to make sure later on\n+                            // that they're being included on the correct fork.\n+                            blockBody\n+                                .getAttestations()\n+                                .forEach(\n+                                    attestation -> {\n+                                      attestationManager\n+                                          .onAttestation(\n+                                              ValidateableAttestation.fromAttestation(attestation))\n+                                          .finish(\n+                                              result ->\n+                                                  result.ifInvalid(\n+                                                      reason ->\n+                                                          LOG.debug(\n+                                                              \"Rejected re-queued attestation from block: {} due to: {}\",\n+                                                              root,\n+                                                              reason)),\n+                                              err ->\n+                                                  LOG.error(\n+                                                      \"Failed to process re-queued attestation from block: {} due to: {}\",\n+                                                      root,\n+                                                      err));\n+                                    });\n+                          },\n+                          () ->\n+                              LOG.warn(\n+                                  \"Failed to re-queue operations for now non-canonical block: {}\",\n+                                  root)))", "originalCommit": "6235383e2238fad15c5f3d2185ef4899616cfb16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkyNzMwNg==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r481927306", "bodyText": "Makes sense.", "author": "cemozerr", "createdAt": "2020-09-02T09:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkwNjA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkwOTk5NQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r481909995", "bodyText": "We shouldn't be casting to SuccesfulBlockImportResult - it's always just a BlockImportResult and for failures isBlockOnCanonicalChain would always return false (block isn't on the canonical chain if it failed to import).", "author": "ajsutton", "createdAt": "2020-09-02T08:57:39Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/blockimport/BlockImporter.java", "diffHunk": "@@ -82,7 +83,13 @@ public BlockImporter(\n \n               final Optional<BlockProcessingRecord> record = result.getBlockProcessingRecord();\n               eventBus.post(new ImportedBlockEvent(block));\n-              notifyBlockOperationSubscribers(block);\n+\n+              // Notify operation pools to remove operations only\n+              // if the block is on our canonical chain\n+              if (((SuccessfulBlockImportResult) result).isBlockOnCanonicalChain()) {", "originalCommit": "6235383e2238fad15c5f3d2185ef4899616cfb16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkyOTk5MQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r481929991", "bodyText": "Makes sense.", "author": "cemozerr", "createdAt": "2020-09-02T09:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkwOTk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkxMzIwNg==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r481913206", "bodyText": "Hard coded 10000 doesn't look right here.", "author": "ajsutton", "createdAt": "2020-09-02T09:01:11Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/RecentChainData.java", "diffHunk": "@@ -186,6 +187,12 @@ public UpdatableStore getStore() {\n         .orElseGet(TreeMap::new);\n   }\n \n+  public NavigableMap<UInt64, Bytes32> getAncestorRootsForRoot(\n+      final UInt64 startSlot, Bytes32 root) {\n+    return ForkChoiceUtil.getAncestors(\n+        forkChoiceStrategy.orElseThrow(), root, startSlot, UInt64.ONE, UInt64.valueOf(10000));", "originalCommit": "6235383e2238fad15c5f3d2185ef4899616cfb16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkxNDAwMQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r481914001", "bodyText": "Also I'm suspicious that we might be including the common ancestor block itself when processing a reorg.  We should process both chains only from the block after the common ancestor (ie only process the blocks that actually changed).", "author": "ajsutton", "createdAt": "2020-09-02T09:02:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkxMzIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkzMDk2MA==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r481930960", "bodyText": "Yeah, I wasn't sure about 10000 as well. I need a number high enough to never be a problem, but less than the limits of UInt64 so that it never throws an ArithmeticException as well.", "author": "cemozerr", "createdAt": "2020-09-02T09:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkxMzIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk0MjE0MQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r481942141", "bodyText": "Added a new method to get every ancestor that does not calculate count instead of passing a magic variable.", "author": "cemozerr", "createdAt": "2020-09-02T09:44:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkxMzIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk0NTI3Ng==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r481945276", "bodyText": "Also made sure this method does not return the block root for the common ancestor.", "author": "cemozerr", "createdAt": "2020-09-02T09:50:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkxMzIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkxNjQyMw==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r481916423", "bodyText": "This looks awfully complex and I think it still has to setup quite a lot of operations yet.  I suspect getting it all set up with valid data will be a lot of code and pretty slow.  I think I'd just do a unit test focused on OperationsReOrgManager - with a mock RecentChainData it should be fairly easy to inject the blocks we want and all we really need to see is that the operations from those blocks and added or removed from all the right places.  We know they do their job fine from there.", "author": "ajsutton", "createdAt": "2020-09-02T09:04:57Z", "path": "ethereum/statetransition/src/test/java/tech/pegasys/teku/statetransition/OperationsReOrgManagerTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.statetransition;\n+\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.core.ChainBuilder;\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlockBody;\n+import tech.pegasys.teku.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.operations.AttesterSlashing;\n+import tech.pegasys.teku.datastructures.operations.ProposerSlashing;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.statetransition.attestation.AggregatingAttestationPool;\n+import tech.pegasys.teku.statetransition.attestation.AttestationManager;\n+import tech.pegasys.teku.statetransition.forkchoice.ForkChoice;\n+import tech.pegasys.teku.statetransition.forkchoice.SingleThreadedForkChoiceExecutor;\n+import tech.pegasys.teku.storage.api.TrackingReorgEventChannel;\n+import tech.pegasys.teku.storage.client.ChainUpdater;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.storage.storageSystem.InMemoryStorageSystemBuilder;\n+import tech.pegasys.teku.storage.storageSystem.StorageSystem;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+public class OperationsReOrgManagerTest {", "originalCommit": "6235383e2238fad15c5f3d2185ef4899616cfb16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwNjU0OA==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482006548", "bodyText": "Makes sense. Will switch to unit tests.", "author": "cemozerr", "createdAt": "2020-09-02T11:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTkxNjQyMw=="}], "type": "inlineReview"}, {"oid": "d924bf755d26b4e036b82d7cdb05bd5e7e44ed4e", "url": "https://github.com/ConsenSys/teku/commit/d924bf755d26b4e036b82d7cdb05bd5e7e44ed4e", "message": "Change debug level and add method to BlockImportResult", "committedDate": "2020-09-02T09:27:15Z", "type": "commit"}, {"oid": "464ca51c670827997cea583fc87a208b2769d22f", "url": "https://github.com/ConsenSys/teku/commit/464ca51c670827997cea583fc87a208b2769d22f", "message": "Added a method to return block roots for any chain defined by root and start slot", "committedDate": "2020-09-02T09:51:19Z", "type": "commit"}, {"oid": "01c4b610658faa8c9a9a407d61646af242ae1e64", "url": "https://github.com/ConsenSys/teku/commit/01c4b610658faa8c9a9a407d61646af242ae1e64", "message": "Switched to unit test for OperationsReOrgManager and added tests for RecentChainData", "committedDate": "2020-09-02T11:47:05Z", "type": "commit"}, {"oid": "25ce7a1ed7c77c4c5351d5d4380c4434aa54f3ce", "url": "https://github.com/ConsenSys/teku/commit/25ce7a1ed7c77c4c5351d5d4380c4434aa54f3ce", "message": "Integrate OperationsReOrgManager", "committedDate": "2020-09-02T11:51:45Z", "type": "commit"}, {"oid": "f51549f088299900680406927ae8a92f79113b4e", "url": "https://github.com/ConsenSys/teku/commit/f51549f088299900680406927ae8a92f79113b4e", "message": "Run spotless", "committedDate": "2020-09-02T11:52:18Z", "type": "commit"}, {"oid": "fc57b11f1182f0b5f549ab960c8421a05fe0ead2", "url": "https://github.com/ConsenSys/teku/commit/fc57b11f1182f0b5f549ab960c8421a05fe0ead2", "message": "Fix compile errors", "committedDate": "2020-09-02T12:15:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5OTQyMQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482599421", "bodyText": "If we're going to add a java doc comment we should fill it all out. :)\nI also feel like this should be some variant of getAncestors so that it has a similar name to the existing getAncestors method.  Maybe getAncestorsOnFork?", "author": "ajsutton", "createdAt": "2020-09-02T23:33:06Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -119,6 +119,26 @@ public static UInt64 compute_slots_since_epoch_start(UInt64 slot) {\n     return roots;\n   }\n \n+  /**\n+   * @param forkChoiceStrategy\n+   * @param root\n+   * @param startSlot\n+   * @return every block root from root (inclusive) to start slot (exclusive) traversing the chain\n+   *     backwards\n+   */", "originalCommit": "fc57b11f1182f0b5f549ab960c8421a05fe0ead2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkwMjU4Ng==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482902586", "bodyText": "Makes sense. Done.", "author": "cemozerr", "createdAt": "2020-09-03T11:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5OTQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMTk3Ng==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482601976", "bodyText": "The nesting levels here seem to have gotten a bit out of control.  Probably need to extract a method or two to reduce them.", "author": "ajsutton", "createdAt": "2020-09-02T23:41:34Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/OperationsReOrgManager.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.statetransition;\n+\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlockBody;\n+import tech.pegasys.teku.datastructures.operations.AttesterSlashing;\n+import tech.pegasys.teku.datastructures.operations.ProposerSlashing;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.statetransition.attestation.AggregatingAttestationPool;\n+import tech.pegasys.teku.statetransition.attestation.AttestationManager;\n+import tech.pegasys.teku.storage.api.ReorgEventChannel;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class OperationsReOrgManager implements ReorgEventChannel {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  final OperationPool<SignedVoluntaryExit> exitPool;\n+  final OperationPool<ProposerSlashing> proposerSlashingPool;\n+  final OperationPool<AttesterSlashing> attesterSlashingPool;\n+  final AttestationManager attestationManager;\n+  final AggregatingAttestationPool attestationPool;\n+  final RecentChainData recentChainData;\n+\n+  public OperationsReOrgManager(\n+      OperationPool<ProposerSlashing> proposerSlashingPool,\n+      OperationPool<AttesterSlashing> attesterSlashingPool,\n+      OperationPool<SignedVoluntaryExit> exitPool,\n+      AggregatingAttestationPool attestationPool,\n+      AttestationManager attestationManager,\n+      RecentChainData recentChainData) {\n+    this.exitPool = exitPool;\n+    this.proposerSlashingPool = proposerSlashingPool;\n+    this.attesterSlashingPool = attesterSlashingPool;\n+    this.attestationManager = attestationManager;\n+    this.attestationPool = attestationPool;\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  @Override\n+  public void reorgOccurred(\n+      Bytes32 bestBlockRoot, UInt64 bestSlot, Bytes32 oldBestBlockRoot, UInt64 commonAncestorSlot) {\n+    NavigableMap<UInt64, Bytes32> notCanonicalBlockRoots =\n+        recentChainData.getEveryRootOnChainTillSlot(commonAncestorSlot, oldBestBlockRoot);\n+    notCanonicalBlockRoots.forEach(\n+        (__, root) -> {\n+          SafeFuture<Optional<BeaconBlock>> maybeBlockFuture =\n+              recentChainData.retrieveBlockByRoot(root);\n+          maybeBlockFuture\n+              .thenAccept(\n+                  maybeBlock ->\n+                      maybeBlock.ifPresentOrElse(\n+                          block -> {\n+                            BeaconBlockBody blockBody = block.getBody();\n+                            proposerSlashingPool.addAll(blockBody.getProposer_slashings());\n+                            attesterSlashingPool.addAll(blockBody.getAttester_slashings());\n+                            exitPool.addAll(blockBody.getVoluntary_exits());\n+\n+                            // Attestations need to get re-processed through AttestationManager\n+                            // because we don't have access to the state with which they were\n+                            // verified anymore and we need to make sure later on\n+                            // that they're being included on the correct fork.\n+                            blockBody\n+                                .getAttestations()\n+                                .forEach(\n+                                    attestation -> {\n+                                      attestationManager\n+                                          .onAttestation(attestation)\n+                                          .finish(\n+                                              result ->\n+                                                  result.ifInvalid(\n+                                                      reason ->\n+                                                          LOG.debug(\n+                                                              \"Rejected re-queued attestation from block: {} due to: {}\",\n+                                                              root,\n+                                                              reason)),\n+                                              err ->\n+                                                  LOG.error(\n+                                                      \"Failed to process re-queued attestation from block: {} due to: {}\",\n+                                                      root,\n+                                                      err));\n+                                    });\n+                          },\n+                          () ->\n+                              LOG.debug(\n+                                  \"Failed to re-queue operations for now non-canonical block: {}\",\n+                                  root)))\n+              .finish(\n+                  err ->\n+                      LOG.warn(\n+                          \"Failed to re-queue operations for now non-canonical block: {} due to future error: {}\",\n+                          root,\n+                          err.getMessage()));\n+        });", "originalCommit": "fc57b11f1182f0b5f549ab960c8421a05fe0ead2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkxNDA2Mg==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482914062", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-03T11:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMjE4Nw==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482602187", "bodyText": "We should preserve the stack trace instead of only logging the error message.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                  LOG.warn(\n          \n          \n            \n                                      \"Failed to re-queue operations for now non-canonical block: {} due to future error: {}\",\n          \n          \n            \n                                      root,\n          \n          \n            \n                                      err.getMessage()));\n          \n          \n            \n                                  LOG.warn(\n          \n          \n            \n                                      \"Failed to re-queue operations for now non-canonical block: {}\",\n          \n          \n            \n                                      root,\n          \n          \n            \n                                      err));", "author": "ajsutton", "createdAt": "2020-09-02T23:42:17Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/OperationsReOrgManager.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.statetransition;\n+\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlockBody;\n+import tech.pegasys.teku.datastructures.operations.AttesterSlashing;\n+import tech.pegasys.teku.datastructures.operations.ProposerSlashing;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.statetransition.attestation.AggregatingAttestationPool;\n+import tech.pegasys.teku.statetransition.attestation.AttestationManager;\n+import tech.pegasys.teku.storage.api.ReorgEventChannel;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class OperationsReOrgManager implements ReorgEventChannel {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  final OperationPool<SignedVoluntaryExit> exitPool;\n+  final OperationPool<ProposerSlashing> proposerSlashingPool;\n+  final OperationPool<AttesterSlashing> attesterSlashingPool;\n+  final AttestationManager attestationManager;\n+  final AggregatingAttestationPool attestationPool;\n+  final RecentChainData recentChainData;\n+\n+  public OperationsReOrgManager(\n+      OperationPool<ProposerSlashing> proposerSlashingPool,\n+      OperationPool<AttesterSlashing> attesterSlashingPool,\n+      OperationPool<SignedVoluntaryExit> exitPool,\n+      AggregatingAttestationPool attestationPool,\n+      AttestationManager attestationManager,\n+      RecentChainData recentChainData) {\n+    this.exitPool = exitPool;\n+    this.proposerSlashingPool = proposerSlashingPool;\n+    this.attesterSlashingPool = attesterSlashingPool;\n+    this.attestationManager = attestationManager;\n+    this.attestationPool = attestationPool;\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  @Override\n+  public void reorgOccurred(\n+      Bytes32 bestBlockRoot, UInt64 bestSlot, Bytes32 oldBestBlockRoot, UInt64 commonAncestorSlot) {\n+    NavigableMap<UInt64, Bytes32> notCanonicalBlockRoots =\n+        recentChainData.getEveryRootOnChainTillSlot(commonAncestorSlot, oldBestBlockRoot);\n+    notCanonicalBlockRoots.forEach(\n+        (__, root) -> {\n+          SafeFuture<Optional<BeaconBlock>> maybeBlockFuture =\n+              recentChainData.retrieveBlockByRoot(root);\n+          maybeBlockFuture\n+              .thenAccept(\n+                  maybeBlock ->\n+                      maybeBlock.ifPresentOrElse(\n+                          block -> {\n+                            BeaconBlockBody blockBody = block.getBody();\n+                            proposerSlashingPool.addAll(blockBody.getProposer_slashings());\n+                            attesterSlashingPool.addAll(blockBody.getAttester_slashings());\n+                            exitPool.addAll(blockBody.getVoluntary_exits());\n+\n+                            // Attestations need to get re-processed through AttestationManager\n+                            // because we don't have access to the state with which they were\n+                            // verified anymore and we need to make sure later on\n+                            // that they're being included on the correct fork.\n+                            blockBody\n+                                .getAttestations()\n+                                .forEach(\n+                                    attestation -> {\n+                                      attestationManager\n+                                          .onAttestation(attestation)\n+                                          .finish(\n+                                              result ->\n+                                                  result.ifInvalid(\n+                                                      reason ->\n+                                                          LOG.debug(\n+                                                              \"Rejected re-queued attestation from block: {} due to: {}\",\n+                                                              root,\n+                                                              reason)),\n+                                              err ->\n+                                                  LOG.error(\n+                                                      \"Failed to process re-queued attestation from block: {} due to: {}\",\n+                                                      root,\n+                                                      err));\n+                                    });\n+                          },\n+                          () ->\n+                              LOG.debug(\n+                                  \"Failed to re-queue operations for now non-canonical block: {}\",\n+                                  root)))\n+              .finish(\n+                  err ->\n+                      LOG.warn(\n+                          \"Failed to re-queue operations for now non-canonical block: {} due to future error: {}\",\n+                          root,\n+                          err.getMessage()));", "originalCommit": "fc57b11f1182f0b5f549ab960c8421a05fe0ead2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkxMDI5Nw==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482910297", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-03T11:35:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMjE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMjQwMA==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482602400", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                              LOG.error(\n          \n          \n            \n                                                                  \"Failed to process re-queued attestation from block: {} due to: {}\",\n          \n          \n            \n                                                                  root,\n          \n          \n            \n                                                                  err));\n          \n          \n            \n                                                              LOG.error(\n          \n          \n            \n                                                                  \"Failed to process re-queued attestation from block: {}\",\n          \n          \n            \n                                                                  root,\n          \n          \n            \n                                                                  err));\n          \n      \n    \n    \n  \n\nAvoid losing the error message.", "author": "ajsutton", "createdAt": "2020-09-02T23:42:56Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/OperationsReOrgManager.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.statetransition;\n+\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlockBody;\n+import tech.pegasys.teku.datastructures.operations.AttesterSlashing;\n+import tech.pegasys.teku.datastructures.operations.ProposerSlashing;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.statetransition.attestation.AggregatingAttestationPool;\n+import tech.pegasys.teku.statetransition.attestation.AttestationManager;\n+import tech.pegasys.teku.storage.api.ReorgEventChannel;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class OperationsReOrgManager implements ReorgEventChannel {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  final OperationPool<SignedVoluntaryExit> exitPool;\n+  final OperationPool<ProposerSlashing> proposerSlashingPool;\n+  final OperationPool<AttesterSlashing> attesterSlashingPool;\n+  final AttestationManager attestationManager;\n+  final AggregatingAttestationPool attestationPool;\n+  final RecentChainData recentChainData;\n+\n+  public OperationsReOrgManager(\n+      OperationPool<ProposerSlashing> proposerSlashingPool,\n+      OperationPool<AttesterSlashing> attesterSlashingPool,\n+      OperationPool<SignedVoluntaryExit> exitPool,\n+      AggregatingAttestationPool attestationPool,\n+      AttestationManager attestationManager,\n+      RecentChainData recentChainData) {\n+    this.exitPool = exitPool;\n+    this.proposerSlashingPool = proposerSlashingPool;\n+    this.attesterSlashingPool = attesterSlashingPool;\n+    this.attestationManager = attestationManager;\n+    this.attestationPool = attestationPool;\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  @Override\n+  public void reorgOccurred(\n+      Bytes32 bestBlockRoot, UInt64 bestSlot, Bytes32 oldBestBlockRoot, UInt64 commonAncestorSlot) {\n+    NavigableMap<UInt64, Bytes32> notCanonicalBlockRoots =\n+        recentChainData.getEveryRootOnChainTillSlot(commonAncestorSlot, oldBestBlockRoot);\n+    notCanonicalBlockRoots.forEach(\n+        (__, root) -> {\n+          SafeFuture<Optional<BeaconBlock>> maybeBlockFuture =\n+              recentChainData.retrieveBlockByRoot(root);\n+          maybeBlockFuture\n+              .thenAccept(\n+                  maybeBlock ->\n+                      maybeBlock.ifPresentOrElse(\n+                          block -> {\n+                            BeaconBlockBody blockBody = block.getBody();\n+                            proposerSlashingPool.addAll(blockBody.getProposer_slashings());\n+                            attesterSlashingPool.addAll(blockBody.getAttester_slashings());\n+                            exitPool.addAll(blockBody.getVoluntary_exits());\n+\n+                            // Attestations need to get re-processed through AttestationManager\n+                            // because we don't have access to the state with which they were\n+                            // verified anymore and we need to make sure later on\n+                            // that they're being included on the correct fork.\n+                            blockBody\n+                                .getAttestations()\n+                                .forEach(\n+                                    attestation -> {\n+                                      attestationManager\n+                                          .onAttestation(attestation)\n+                                          .finish(\n+                                              result ->\n+                                                  result.ifInvalid(\n+                                                      reason ->\n+                                                          LOG.debug(\n+                                                              \"Rejected re-queued attestation from block: {} due to: {}\",\n+                                                              root,\n+                                                              reason)),\n+                                              err ->\n+                                                  LOG.error(\n+                                                      \"Failed to process re-queued attestation from block: {} due to: {}\",\n+                                                      root,\n+                                                      err));", "originalCommit": "fc57b11f1182f0b5f549ab960c8421a05fe0ead2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkwOTk1NQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482909955", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-03T11:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMjQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMzA3OQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482603079", "bodyText": "This method is too big overall. Probably worth splitting in two - process nonCanonical and then process canonical blocks.  And then probably a few other helper methods to make the optional/future chainings not wind up so deeply nested and hard to follow.", "author": "ajsutton", "createdAt": "2020-09-02T23:45:08Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/OperationsReOrgManager.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.statetransition;\n+\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlockBody;\n+import tech.pegasys.teku.datastructures.operations.AttesterSlashing;\n+import tech.pegasys.teku.datastructures.operations.ProposerSlashing;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.statetransition.attestation.AggregatingAttestationPool;\n+import tech.pegasys.teku.statetransition.attestation.AttestationManager;\n+import tech.pegasys.teku.storage.api.ReorgEventChannel;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class OperationsReOrgManager implements ReorgEventChannel {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  final OperationPool<SignedVoluntaryExit> exitPool;\n+  final OperationPool<ProposerSlashing> proposerSlashingPool;\n+  final OperationPool<AttesterSlashing> attesterSlashingPool;\n+  final AttestationManager attestationManager;\n+  final AggregatingAttestationPool attestationPool;\n+  final RecentChainData recentChainData;\n+\n+  public OperationsReOrgManager(\n+      OperationPool<ProposerSlashing> proposerSlashingPool,\n+      OperationPool<AttesterSlashing> attesterSlashingPool,\n+      OperationPool<SignedVoluntaryExit> exitPool,\n+      AggregatingAttestationPool attestationPool,\n+      AttestationManager attestationManager,\n+      RecentChainData recentChainData) {\n+    this.exitPool = exitPool;\n+    this.proposerSlashingPool = proposerSlashingPool;\n+    this.attesterSlashingPool = attesterSlashingPool;\n+    this.attestationManager = attestationManager;\n+    this.attestationPool = attestationPool;\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  @Override\n+  public void reorgOccurred(", "originalCommit": "fc57b11f1182f0b5f549ab960c8421a05fe0ead2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkwOTI2NA==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482909264", "bodyText": "I tried to make it better, and its a bit better, but there is still some serious nesting. Could use suggestions.", "author": "cemozerr", "createdAt": "2020-09-03T11:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMzA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMzU0OQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482603549", "bodyText": "I probably wouldn't add this method.  We want to create the ValidatableAttestation only at the key entry points but this makes it much simpler to get that wrong and create a new ValidatableAttestation without thinking about it and then we'll lose the context it tracks.", "author": "ajsutton", "createdAt": "2020-09-02T23:46:41Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AttestationManager.java", "diffHunk": "@@ -112,7 +113,10 @@ private void onBlockImported(final ImportedBlockEvent blockImportedEvent) {\n                               \"Failed to process pending attestation dependent on \" + blockRoot,\n                               err));\n             });\n-    block.getMessage().getBody().getAttestations().forEach(aggregatingAttestationPool::remove);\n+  }\n+\n+  public SafeFuture<AttestationProcessingResult> onAttestation(Attestation attestation) {\n+    return onAttestation(ValidateableAttestation.fromAttestation(attestation));\n   }", "originalCommit": "fc57b11f1182f0b5f549ab960c8421a05fe0ead2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkxNTU5Mg==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482915592", "bodyText": "Makes sense.", "author": "cemozerr", "createdAt": "2020-09-03T11:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMzU0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkxNTYxNg==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482915616", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-03T11:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMzU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMzcxMA==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482603710", "bodyText": "Should avoid the cast to SuccessfulBlockImportResult.  Might need to make setBlockOnCanonicalChain a markAsCanonical method which throws UnsupportedOperationException for failed results.", "author": "ajsutton", "createdAt": "2020-09-02T23:47:10Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -146,15 +147,18 @@ private void processHead(Optional<UInt64> nodeSlot) {\n                       forkChoiceStrategy.onAttestation(transaction, indexedAttestation));\n           return transaction\n               .commit()\n-              .thenRun(() -> updateForkChoiceForImportedBlock(block, forkChoiceStrategy, result))\n+              .thenRun(\n+                  () ->\n+                      updateForkChoiceForImportedBlock(\n+                          block, forkChoiceStrategy, (SuccessfulBlockImportResult) result))", "originalCommit": "fc57b11f1182f0b5f549ab960c8421a05fe0ead2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjkxNzM0OQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482917349", "bodyText": "Makes sense. Done.", "author": "cemozerr", "createdAt": "2020-09-03T11:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMzcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwNDMxNQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482604315", "bodyText": "Probably worth having a test for when blocks are removed but not added or vice-versa (ie a reorg that only changes from an empty slot to a full one and the other way).  Should work fine but that's the most common type of reorg so important to handle it right.", "author": "ajsutton", "createdAt": "2020-09-02T23:49:19Z", "path": "ethereum/statetransition/src/test/java/tech/pegasys/teku/statetransition/OperationsReOrgManagerTest.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.statetransition;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.operations.AttesterSlashing;\n+import tech.pegasys.teku.datastructures.operations.ProposerSlashing;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.datastructures.util.AttestationProcessingResult;\n+import tech.pegasys.teku.datastructures.util.DataStructureUtil;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.statetransition.attestation.AggregatingAttestationPool;\n+import tech.pegasys.teku.statetransition.attestation.AttestationManager;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class OperationsReOrgManagerTest {\n+\n+  private DataStructureUtil dataStructureUtil = new DataStructureUtil();\n+\n+  private OperationPool<ProposerSlashing> proposerSlashingOperationPool = mock(OperationPool.class);\n+  private OperationPool<AttesterSlashing> attesterSlashingOperationPool = mock(OperationPool.class);\n+  private OperationPool<SignedVoluntaryExit> exitOperationPool = mock(OperationPool.class);\n+  private AggregatingAttestationPool attestationPool = mock(AggregatingAttestationPool.class);\n+  private AttestationManager attestationManager = mock(AttestationManager.class);\n+\n+  private RecentChainData recentChainData = mock(RecentChainData.class);\n+\n+  private OperationsReOrgManager operationsReOrgManager =\n+      new OperationsReOrgManager(\n+          proposerSlashingOperationPool,\n+          attesterSlashingOperationPool,\n+          exitOperationPool,\n+          attestationPool,\n+          attestationManager,\n+          recentChainData);\n+\n+  @Test\n+  void shouldRequeueAndRemoveOperations() throws Exception {", "originalCommit": "fc57b11f1182f0b5f549ab960c8421a05fe0ead2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0NzU4MA==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482947580", "bodyText": "I did the reOrg from an empty slot to a full one, but I'm having a hard time understanding the reOrg from full one to empty slot since attestations vote on blocks.", "author": "cemozerr", "createdAt": "2020-09-03T12:42:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwNDMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwNTA1OQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482605059", "bodyText": "Should rename this to match the recentChainData method it delegates to.", "author": "ajsutton", "createdAt": "2020-09-02T23:51:43Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/CombinedChainDataClient.java", "diffHunk": "@@ -357,7 +357,7 @@ public UpdatableStore getStore() {\n \n   public NavigableMap<UInt64, Bytes32> getAncestorRoots(\n       final UInt64 startSlot, final UInt64 step, final UInt64 count) {\n-    return recentChainData.getAncestorRoots(startSlot, step, count);\n+    return recentChainData.getAncestorRootsForChainHead(startSlot, step, count);", "originalCommit": "fc57b11f1182f0b5f549ab960c8421a05fe0ead2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0ODQ2Mg==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482948462", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-03T12:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwNTA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwNTcyMw==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482605723", "bodyText": "Probably should have a test case for when the block root is unknown.", "author": "ajsutton", "createdAt": "2020-09-02T23:54:02Z", "path": "storage/src/test/java/tech/pegasys/teku/storage/client/RecentChainDataTest.java", "diffHunk": "@@ -564,6 +578,47 @@ public void commit_pruneParallelExistingBlocks() throws Exception {\n     testCommitPruningOfParallelBlocks(false);\n   }\n \n+  @Test\n+  public void getEveryRootOnChainTillSlot() {", "originalCommit": "fc57b11f1182f0b5f549ab960c8421a05fe0ead2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NjExNg==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r482956116", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-03T12:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwNTcyMw=="}], "type": "inlineReview"}, {"oid": "0a43f2ae099abc2d3ce1f9acfb536bad22f1a5a8", "url": "https://github.com/ConsenSys/teku/commit/0a43f2ae099abc2d3ce1f9acfb536bad22f1a5a8", "message": "Add proper javadoc and change method name", "committedDate": "2020-09-03T11:20:48Z", "type": "commit"}, {"oid": "a80539886c87eeb02c8045db1faccc42803781ea", "url": "https://github.com/ConsenSys/teku/commit/a80539886c87eeb02c8045db1faccc42803781ea", "message": "Break up long method", "committedDate": "2020-09-03T11:34:08Z", "type": "commit"}, {"oid": "0e094319d0669237212704f30f1b195988c0d981", "url": "https://github.com/ConsenSys/teku/commit/0e094319d0669237212704f30f1b195988c0d981", "message": "Resolve comments", "committedDate": "2020-09-03T12:44:29Z", "type": "commit"}, {"oid": "3752bb8a69ddb03930804fb6d5a075733aeda4a2", "url": "https://github.com/ConsenSys/teku/commit/3752bb8a69ddb03930804fb6d5a075733aeda4a2", "message": "Run spotless", "committedDate": "2020-09-03T12:49:37Z", "type": "commit"}, {"oid": "bb7edec9edf66187356229e164b0ffed27648099", "url": "https://github.com/ConsenSys/teku/commit/bb7edec9edf66187356229e164b0ffed27648099", "message": "Add test case", "committedDate": "2020-09-03T12:56:30Z", "type": "commit"}, {"oid": "bdb1f7c97025eb05840ff9c8fc67ec131731cef6", "url": "https://github.com/ConsenSys/teku/commit/bdb1f7c97025eb05840ff9c8fc67ec131731cef6", "message": "Run spotless", "committedDate": "2020-09-03T12:56:44Z", "type": "commit"}, {"oid": "2c98e489f30d073ff9db8cdac319146ac41abe2f", "url": "https://github.com/ConsenSys/teku/commit/2c98e489f30d073ff9db8cdac319146ac41abe2f", "message": "Remove redundant changes and fix tests", "committedDate": "2020-09-03T13:24:28Z", "type": "commit"}, {"oid": "49ab6a9b4ea7dc7961c35c079e55ab87d4d4eb9b", "url": "https://github.com/ConsenSys/teku/commit/49ab6a9b4ea7dc7961c35c079e55ab87d4d4eb9b", "message": "Merge remote-tracking branch 'remotes/origin/master' into requeueOperationsFromBlocksWhenReOrgOccurs\n\n# Conflicts:\n#\tservices/beaconchain/src/main/java/tech/pegasys/teku/services/beaconchain/BeaconChainController.java", "committedDate": "2020-09-03T13:28:36Z", "type": "commit"}, {"oid": "72e121a0c3a00554d19c33bb3d31b0533fc9eb75", "url": "https://github.com/ConsenSys/teku/commit/72e121a0c3a00554d19c33bb3d31b0533fc9eb75", "message": "Fix test", "committedDate": "2020-09-03T13:53:23Z", "type": "commit"}, {"oid": "628f85860f7bf77e54d59d44b832194283dd20e2", "url": "https://github.com/ConsenSys/teku/commit/628f85860f7bf77e54d59d44b832194283dd20e2", "message": "Fix tests", "committedDate": "2020-09-04T09:18:21Z", "type": "commit"}, {"oid": "50594a5676cd342b387be2995fd4fcc03b75dd6e", "url": "https://github.com/ConsenSys/teku/commit/50594a5676cd342b387be2995fd4fcc03b75dd6e", "message": "Run spotless", "committedDate": "2020-09-04T09:19:04Z", "type": "commit"}, {"oid": "9108f86f4933acbc0db89651c01db05452a8394c", "url": "https://github.com/ConsenSys/teku/commit/9108f86f4933acbc0db89651c01db05452a8394c", "message": "Add json deserialization annotations for IndexedAttestation and AttesterSlashing", "committedDate": "2020-09-04T10:01:21Z", "type": "commit"}, {"oid": "cc223eea2a266978e7af0694413bf1c7d1654ab4", "url": "https://github.com/ConsenSys/teku/commit/cc223eea2a266978e7af0694413bf1c7d1654ab4", "message": "Run spotless", "committedDate": "2020-09-04T10:02:04Z", "type": "commit"}, {"oid": "8d81ba2af7818d78282ddcb97ec16381f9ee7afc", "url": "https://github.com/ConsenSys/teku/commit/8d81ba2af7818d78282ddcb97ec16381f9ee7afc", "message": "Update outdated test", "committedDate": "2020-09-04T10:13:22Z", "type": "commit"}, {"oid": "a97880bb54db19a4f59235c827d7386b3a43190d", "url": "https://github.com/ConsenSys/teku/commit/a97880bb54db19a4f59235c827d7386b3a43190d", "message": "Run spotless", "committedDate": "2020-09-04T11:08:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3ODEzMg==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r483578132", "bodyText": "I'm not sure why this change was required as part of this PR.", "author": "ajsutton", "createdAt": "2020-09-04T12:15:34Z", "path": "data/serializer/src/main/java/tech/pegasys/teku/api/schema/AttesterSlashing.java", "diffHunk": "@@ -23,6 +26,14 @@ public AttesterSlashing(\n     this.attestation_2 = new IndexedAttestation(attesterSlashing.getAttestation_2());\n   }\n \n+  @JsonCreator\n+  public AttesterSlashing(\n+      @JsonProperty(\"attestation_1\") final IndexedAttestation attestation_1,\n+      @JsonProperty(\"attestation_2\") final IndexedAttestation attestation_2) {\n+    this.attestation_1 = attestation_1;\n+    this.attestation_2 = attestation_2;\n+  }\n+", "originalCommit": "a97880bb54db19a4f59235c827d7386b3a43190d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU4NjkwMw==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r483586903", "bodyText": "Ok I think I can see this one being useful for the submit block API which previously was a bug.  Still not sure what's deserializing an IndexedAttestation since they should only be in states and we shouldn't parse any of those from JSON (I think).", "author": "ajsutton", "createdAt": "2020-09-04T12:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3ODEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU4OTU2Ng==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r483589566", "bodyText": "We need to parse IndexedAttestation when we're deserializing JSON of AttesterSlashing, since it contains two IndexedAttestations.\nI needed to do deal with all this JSON stuff as I made sure now our DataStructureUtil.randomBeaconBlock(int n) method always returns a block with 1 AttesterSlashing, instead of returning an empty AttesterSlashing SSZList as it used to do. This made all our tests more robust IMO.\nThen it turned out that we could not deserialize BeaconBlock JSON objects which included AttesterSlashings. I saw this as the PostBlockTest.shouldReturnAcceptedIfBlockFailsValidation failed after creating and trying to deserialize a randomBeaconBlock, which now included an AttesterSlashing.", "author": "cemozerr", "createdAt": "2020-09-04T12:39:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3ODEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg1OTYzOQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r483859639", "bodyText": "oh right of course. Yep that makes sense.", "author": "ajsutton", "createdAt": "2020-09-04T21:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3ODEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3ODMyMg==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r483578322", "bodyText": "Not sure what caused this to be needed either.", "author": "ajsutton", "createdAt": "2020-09-04T12:15:57Z", "path": "data/serializer/src/main/java/tech/pegasys/teku/api/schema/IndexedAttestation.java", "diffHunk": "@@ -40,6 +42,16 @@ public IndexedAttestation(\n     this.signature = new BLSSignature(indexedAttestation.getSignature());\n   }\n \n+  @JsonCreator\n+  public IndexedAttestation(\n+      @JsonProperty(\"attesting_indices\") final List<UInt64> attesting_indices,\n+      @JsonProperty(\"data\") final AttestationData data,\n+      @JsonProperty(\"signature\") final BLSSignature signature) {\n+    this.attesting_indices = attesting_indices;\n+    this.data = data;\n+    this.signature = signature;\n+  }", "originalCommit": "a97880bb54db19a4f59235c827d7386b3a43190d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3ODU4OQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r483578589", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                while (parentSlot.isPresent() && parentSlot.get().compareTo(startSlot) > 0) {\n          \n          \n            \n                while (parentSlot.isPresent() && parentSlot.get().isGreaterThan(startSlot)) {", "author": "ajsutton", "createdAt": "2020-09-04T12:16:35Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -119,6 +119,26 @@ public static UInt64 compute_slots_since_epoch_start(UInt64 slot) {\n     return roots;\n   }\n \n+  /**\n+   * @param forkChoiceStrategy the object that stores information on forks and block roots\n+   * @param root the root that dictates the block/fork that we walk backwards from\n+   * @param startSlot the slot (exclusive) until which we walk the chain backwards\n+   * @return every block root from root (inclusive) to start slot (exclusive) traversing the chain\n+   *     backwards\n+   */\n+  public static NavigableMap<UInt64, Bytes32> getAncestorsOnFork(\n+      ForkChoiceStrategy forkChoiceStrategy, Bytes32 root, UInt64 startSlot) {\n+    final NavigableMap<UInt64, Bytes32> roots = new TreeMap<>();\n+    Bytes32 parentRoot = root;\n+    Optional<UInt64> parentSlot = forkChoiceStrategy.blockSlot(parentRoot);\n+    while (parentSlot.isPresent() && parentSlot.get().compareTo(startSlot) > 0) {", "originalCommit": "a97880bb54db19a4f59235c827d7386b3a43190d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5MjQxNg==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r483592416", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-04T12:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3ODU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3ODk5OQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r483578999", "bodyText": "We definitely shouldn't have JSON serialisation annotations in our core classes.", "author": "ajsutton", "createdAt": "2020-09-04T12:17:25Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/operations/AttesterSlashing.java", "diffHunk": "@@ -41,6 +42,7 @@\n   private final IndexedAttestation attestation_2;\n \n   @Label(\"sos-ignore\")\n+  @JsonIgnore", "originalCommit": "a97880bb54db19a4f59235c827d7386b3a43190d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5MzIxOA==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r483593218", "bodyText": "Artifact of intense debugging. Removed.", "author": "cemozerr", "createdAt": "2020-09-04T12:47:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3ODk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU4MTA0Ng==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r483581046", "bodyText": "Why is this a new method just to reorder the params?", "author": "ajsutton", "createdAt": "2020-09-04T12:21:51Z", "path": "ethereum/datastructures/src/testFixtures/java/tech/pegasys/teku/datastructures/util/DataStructureUtil.java", "diffHunk": "@@ -126,6 +126,11 @@ public BLSSignature randomSignature() {\n     return randomSSZList(classInfo, maxSize / 10, maxSize, valueGenerator);\n   }\n \n+  public <T> SSZList<T> randomSSZList(\n+      Class<? extends T> classInfo, long maxSize, Supplier<T> valueGenerator, long numItems) {\n+    return randomSSZList(classInfo, numItems, maxSize, valueGenerator);\n+  }", "originalCommit": "a97880bb54db19a4f59235c827d7386b3a43190d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5NDQzMg==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r483594432", "bodyText": "Its to have a configurable number of items in the SSZList. In the past, we either had the randomFullSSZList option which filled the list to its maxSize, or the default randomSSZList, which would fill each list maxSize/10 number of items.\nIn attester slashing, that would mean 0 items.", "author": "cemozerr", "createdAt": "2020-09-04T12:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU4MTA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU4MTc0Ng==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r483581746", "bodyText": "I'd probably have at least 3 attestations in the blocks by default.  Good to have a slashing added in there that I'm guessing wound up with none before though.", "author": "ajsutton", "createdAt": "2020-09-04T12:23:18Z", "path": "ethereum/datastructures/src/testFixtures/java/tech/pegasys/teku/datastructures/util/DataStructureUtil.java", "diffHunk": "@@ -381,8 +386,11 @@ public BeaconBlockBody randomBeaconBlockBody() {\n         randomSSZList(\n             ProposerSlashing.class, Constants.MAX_PROPOSER_SLASHINGS, this::randomProposerSlashing),\n         randomSSZList(\n-            AttesterSlashing.class, Constants.MAX_ATTESTER_SLASHINGS, this::randomAttesterSlashing),\n-        randomSSZList(Attestation.class, Constants.MAX_ATTESTATIONS, this::randomAttestation),\n+            AttesterSlashing.class,\n+            Constants.MAX_ATTESTER_SLASHINGS,\n+            this::randomAttesterSlashing,\n+            1),\n+        randomSSZList(Attestation.class, Constants.MAX_ATTESTATIONS, this::randomAttestation, 1),", "originalCommit": "a97880bb54db19a4f59235c827d7386b3a43190d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5NDg5NQ==", "url": "https://github.com/ConsenSys/teku/pull/2700#discussion_r483594895", "bodyText": "Yep exactly the case.", "author": "cemozerr", "createdAt": "2020-09-04T12:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU4MTc0Ng=="}], "type": "inlineReview"}, {"oid": "5f3ac3903cc4f1ef130e86694ee356e9064dce31", "url": "https://github.com/ConsenSys/teku/commit/5f3ac3903cc4f1ef130e86694ee356e9064dce31", "message": "Switch to isGreaterThan", "committedDate": "2020-09-04T12:46:05Z", "type": "commit"}, {"oid": "071c3b45f53b8fc09d53d70b597f36dfee236bcd", "url": "https://github.com/ConsenSys/teku/commit/071c3b45f53b8fc09d53d70b597f36dfee236bcd", "message": "Remove json annotation in core class", "committedDate": "2020-09-04T12:47:48Z", "type": "commit"}, {"oid": "8df57a72c498c71e0e2a253f07e684eae4c9f0b7", "url": "https://github.com/ConsenSys/teku/commit/8df57a72c498c71e0e2a253f07e684eae4c9f0b7", "message": "Set random beacon block body default numbers", "committedDate": "2020-09-04T12:52:54Z", "type": "commit"}, {"oid": "1a42f50d88509843cdff4aa4e99c60946b138613", "url": "https://github.com/ConsenSys/teku/commit/1a42f50d88509843cdff4aa4e99c60946b138613", "message": "Run spotlessApply", "committedDate": "2020-09-04T12:59:06Z", "type": "commit"}, {"oid": "c57c224e127c427c6ce7d026557df6e145643306", "url": "https://github.com/ConsenSys/teku/commit/c57c224e127c427c6ce7d026557df6e145643306", "message": "Run spotless", "committedDate": "2020-09-04T13:01:08Z", "type": "commit"}, {"oid": "15ab918474016aeba13bc0c781dbfa57f0f86dac", "url": "https://github.com/ConsenSys/teku/commit/15ab918474016aeba13bc0c781dbfa57f0f86dac", "message": "Fix test", "committedDate": "2020-09-04T13:16:02Z", "type": "commit"}, {"oid": "a26759b0b2afd89bcb645b0b15cc697f2226b245", "url": "https://github.com/ConsenSys/teku/commit/a26759b0b2afd89bcb645b0b15cc697f2226b245", "message": "Run spotless", "committedDate": "2020-09-04T22:35:38Z", "type": "commit"}, {"oid": "13cd47a13eb1aeaf04a12d250d5285d81c6b81f0", "url": "https://github.com/ConsenSys/teku/commit/13cd47a13eb1aeaf04a12d250d5285d81c6b81f0", "message": "Merge branch 'master' into requeueOperationsFromBlocksWhenReOrgOccurs", "committedDate": "2020-09-04T22:36:05Z", "type": "commit"}]}