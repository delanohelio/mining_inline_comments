{"pr_number": 2486, "pr_title": "Wait for the previous write to complete before loading the next block", "pr_createdAt": "2020-07-31T01:42:30Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2486", "timeline": [{"oid": "62823659277c0ff835fc1527a78953c1c470f26c", "url": "https://github.com/ConsenSys/teku/commit/62823659277c0ff835fc1527a78953c1c470f26c", "message": "Wait for the previous write to complete before loading the next block.", "committedDate": "2020-07-31T01:39:24Z", "type": "commit"}, {"oid": "35af19b6c41a1cb54e64e00c56d761cecda744c3", "url": "https://github.com/ConsenSys/teku/commit/35af19b6c41a1cb54e64e00c56d761cecda744c3", "message": "Update unit test.", "committedDate": "2020-07-31T02:03:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4MjMwNQ==", "url": "https://github.com/ConsenSys/teku/pull/2486#discussion_r464482305", "bodyText": "Looks like RequestState.currentSlot and RequestState.remainingBlocks should be volatile.", "author": "mbaxter", "createdAt": "2020-08-03T15:19:25Z", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "diffHunk": "@@ -120,35 +120,43 @@ public void onIncomingMessage(\n   }\n \n   private SafeFuture<RequestState> sendNextBlock(final RequestState requestState) {\n-    SafeFuture<Optional<SignedBeaconBlock>> blockFuture = requestState.loadNextBlock();\n+    SafeFuture<Boolean> blockFuture = processNextBlock(requestState);\n     // Avoid risk of StackOverflowException by iterating when the block future is already complete\n     // Using thenCompose on the completed future would execute immediately and recurse back into\n     // this method to send the next block.  When not already complete, thenCompose is executed\n     // on a separate thread so doesn't recurse on the same stack.\n     while (blockFuture.isDone() && !blockFuture.isCompletedExceptionally()) {\n-      final boolean complete = handleLoadedBlock(requestState, blockFuture.join());\n-      if (complete) {\n+      if (blockFuture.join()) {\n         return completedFuture(requestState);\n       }\n-      blockFuture = requestState.loadNextBlock();\n+      blockFuture = processNextBlock(requestState);\n     }\n     return blockFuture.thenCompose(\n-        maybeBlock ->\n-            handleLoadedBlock(requestState, maybeBlock)\n-                ? completedFuture(requestState)\n-                : sendNextBlock(requestState));\n+        complete -> complete ? completedFuture(requestState) : sendNextBlock(requestState));\n+  }\n+\n+  private SafeFuture<Boolean> processNextBlock(final RequestState requestState) {\n+    // Ensure blocks are loaded off of the event thread\n+    return requestState\n+        .loadNextBlock()\n+        .thenCompose(block -> handleLoadedBlock(requestState, block));\n   }\n \n   /** Sends the block and returns true if the request is now complete. */\n-  private boolean handleLoadedBlock(\n+  private SafeFuture<Boolean> handleLoadedBlock(\n       final RequestState requestState, final Optional<SignedBeaconBlock> block) {\n-    block.ifPresent(requestState::sendBlock);\n-    if (requestState.isComplete()) {\n-      return true;\n-    } else {\n-      requestState.incrementCurrentSlot();\n-      return false;\n-    }\n+    return block\n+        .map(requestState::sendBlock)\n+        .orElse(SafeFuture.COMPLETE)\n+        .thenApply(\n+            __ -> {\n+              if (requestState.isComplete()) {\n+                return true;\n+              } else {\n+                requestState.incrementCurrentSlot();\n+                return false;\n+              }\n+            });\n   }\n \n   private class RequestState {", "originalCommit": "35af19b6c41a1cb54e64e00c56d761cecda744c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1OTY0OQ==", "url": "https://github.com/ConsenSys/teku/pull/2486#discussion_r464659649", "bodyText": "They don't need to be volatile because there's only one thread at a time accessing them (ie we load one block at a time).  Even though those actions might wind up happening on different threads, CompletableFuture guarantees that anything that happens in a thread before completing a future happens-before the completion stage runs (which applies even if it's run with one of the Async methods).  So even as we jump threads, we're guaranteed to see the most up to date values of those variables.", "author": "ajsutton", "createdAt": "2020-08-03T21:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4MjMwNQ=="}], "type": "inlineReview"}, {"oid": "bdbffe32331cc488ee6f05165ea8fe29a294b5a1", "url": "https://github.com/ConsenSys/teku/commit/bdbffe32331cc488ee6f05165ea8fe29a294b5a1", "message": "Merge branch 'master' into wait-for-write", "committedDate": "2020-08-03T20:49:48Z", "type": "commit"}]}