{"pr_number": 2006, "pr_title": "[#1976] Move hot state management into store", "pr_createdAt": "2020-05-29T18:43:08Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2006", "timeline": [{"oid": "a1a9ba1032c229a44b92d31076f1b08da00d720e", "url": "https://github.com/ConsenSys/teku/commit/a1a9ba1032c229a44b92d31076f1b08da00d720e", "message": "Rework Database state api - only return finalized states", "committedDate": "2020-05-29T15:58:05Z", "type": "commit"}, {"oid": "7fca0328dc4098d70e4e6f0f2d3ae9bcc5cf0612", "url": "https://github.com/ConsenSys/teku/commit/7fca0328dc4098d70e4e6f0f2d3ae9bcc5cf0612", "message": "Move hotState managment and pruning logic into RecentChainData\n\nMake pruning more robust - prune all knowably non-canonical blocks", "committedDate": "2020-05-29T18:31:22Z", "type": "commit"}, {"oid": "fc1c7676c2ec212922d1369ac6788e4bf3708192", "url": "https://github.com/ConsenSys/teku/commit/fc1c7676c2ec212922d1369ac6788e4bf3708192", "message": "Clean up", "committedDate": "2020-05-29T19:08:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5NjMwMg==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r432996302", "bodyText": "This doesn't feel like the right place for this.  I'd be very tempted to split it into it's own class.  My natural inclination is to make it not static as well but given where it gets used from maybe not in this case...", "author": "ajsutton", "createdAt": "2020-05-31T23:40:44Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/StateTransition.java", "diffHunk": "@@ -62,6 +70,60 @@ public StateTransition(BlockValidator blockValidator) {\n     this(Optional.empty(), blockValidator);\n   }\n \n+  public static Map<Bytes32, BeaconState> produceStatesForBlocks(", "originalCommit": "fc1c7676c2ec212922d1369ac6788e4bf3708192", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM1MDQ2Ng==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r433350466", "bodyText": "Moved this into a new class called StateGenerator", "author": "mbaxter", "createdAt": "2020-06-01T16:33:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5NjMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5NzI5Mw==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r432997293", "bodyText": "nit: Can use a method reference here.", "author": "ajsutton", "createdAt": "2020-05-31T23:52:40Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/Store.java", "diffHunk": "@@ -354,15 +450,68 @@ public VoteTracker getVote(UnsignedLong validatorIndex) {\n \n     @CheckReturnValue\n     public SafeFuture<Void> commit() {\n+      final Map<Bytes32, SignedBeaconBlock> hotBlocks = new HashMap<>();\n+      // To start all blocks are assumed to be hot blocks\n+      hotBlocks.putAll(blocks);\n+\n+      // If a new checkpoint has been finalized, calculated what to finalize and what to prune\n+      final UnsignedLong previouslyFinalizedEpoch = Store.this.finalized_checkpoint.getEpoch();\n+      final Optional<UnsignedLong> newlyFinalizedEpoch =\n+          finalized_checkpoint\n+              .map(Checkpoint::getEpoch)\n+              .filter(epoch -> epoch.compareTo(previouslyFinalizedEpoch) > 0);\n+      // Calculate finalized chain data\n+      final Map<Bytes32, SignedBlockAndState> finalizedChainData;\n+      final Map<UnsignedLong, Set<Bytes32>> prunedHotBlockRoots;\n+      final Set<Checkpoint> staleCheckpointStates;\n+      final Optional<SignedBeaconBlock> newlyFinalizedBlock;\n+      if (newlyFinalizedEpoch.isPresent()) {\n+        final SignedBlockAndState previouslyFinalizedBlock =\n+            getBlockAndState(Store.this.finalized_checkpoint.getRoot())\n+                .orElseThrow(() -> new IllegalStateException(\"Finalized block is missing\"));\n+        final SignedBlockAndState newlyFinalizedBlockAndState =\n+            getBlockAndState(finalized_checkpoint.get().getRoot())\n+                .orElseThrow(() -> new IllegalStateException(\"Newly finalized block is missing\"));\n+        newlyFinalizedBlock = Optional.of(newlyFinalizedBlockAndState.getBlock());\n+\n+        finalizedChainData =\n+            getFinalizedChainData(previouslyFinalizedBlock, newlyFinalizedBlockAndState);\n+        prunedHotBlockRoots =\n+            getPrunedHotBlockRoots(\n+                finalized_checkpoint.get(), newlyFinalizedBlock.get(), hotBlocks);\n+        // Collect stale checkpoint states to be deleted\n+        staleCheckpointStates =\n+            Store.this.checkpoint_states.keySet().stream()\n+                .filter(c -> c.getEpoch().compareTo(newlyFinalizedEpoch.get()) < 0)\n+                .collect(Collectors.toSet());\n+\n+        // Make sure we save the checkpoint state for the new finalized checkpoint\n+        checkpoint_states.put(finalized_checkpoint.get(), newlyFinalizedBlockAndState.getState());\n+\n+        // Remove pruned blocks from hot blocks\n+        prunedHotBlockRoots.forEach((slot, roots) -> roots.forEach(hotBlocks::remove));\n+      } else {\n+        newlyFinalizedBlock = Optional.empty();\n+        finalizedChainData = Collections.emptyMap();\n+        prunedHotBlockRoots = Collections.emptyMap();\n+        staleCheckpointStates = Collections.emptySet();\n+      }\n+\n+      final Set<Bytes32> prunedRootsSet =\n+          prunedHotBlockRoots.values().stream()\n+              .flatMap(roots -> roots.stream())", "originalCommit": "fc1c7676c2ec212922d1369ac6788e4bf3708192", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5NzUwNg==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r432997506", "bodyText": "nit: Can just be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final Map<Bytes32, SignedBeaconBlock> hotBlocks = new HashMap<>();\n          \n          \n            \n                  // To start all blocks are assumed to be hot blocks\n          \n          \n            \n                  hotBlocks.putAll(blocks);\n          \n          \n            \n                  // To start all blocks are assumed to be hot blocks\n          \n          \n            \n                  final Map<Bytes32, SignedBeaconBlock> hotBlocks = new HashMap<>(blocks);", "author": "ajsutton", "createdAt": "2020-05-31T23:55:24Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/Store.java", "diffHunk": "@@ -354,15 +450,68 @@ public VoteTracker getVote(UnsignedLong validatorIndex) {\n \n     @CheckReturnValue\n     public SafeFuture<Void> commit() {\n+      final Map<Bytes32, SignedBeaconBlock> hotBlocks = new HashMap<>();\n+      // To start all blocks are assumed to be hot blocks\n+      hotBlocks.putAll(blocks);", "originalCommit": "fc1c7676c2ec212922d1369ac6788e4bf3708192", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5NzgzNA==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r432997834", "bodyText": "This method has gotten pretty big.  It's not easy to split up but I wonder if the calculation of finalised chain data could be separated out and return an object with newlyFinalizedBlock, finalizedChainData, prunedHotBlockRoots, staleCheckpointStates.  It's probably more code overall but I think helps to improve readability overall though.\nHappy to leave it for now if it's likely to get changed again in later PRs though.", "author": "ajsutton", "createdAt": "2020-05-31T23:59:25Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/Store.java", "diffHunk": "@@ -354,15 +450,68 @@ public VoteTracker getVote(UnsignedLong validatorIndex) {\n \n     @CheckReturnValue\n     public SafeFuture<Void> commit() {", "originalCommit": "fc1c7676c2ec212922d1369ac6788e4bf3708192", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM1MTcwNw==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r433351707", "bodyText": "Yeah - there's a lot of logic here.  Tried to reorganize a little here, but not sure how much better this is: 6199f6d\nIt's messy because there are all of the cross-references to the current transaction and underlying Store.", "author": "mbaxter", "createdAt": "2020-06-01T16:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5NzgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5ODI5OQ==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r432998299", "bodyText": "Don't these need to be the other way around?  First put all the existing data into the map, then add the new values? Otherwise if the new blocks are from the same slot as any existing block the putAll will overwrite the set (whereas it should merge them).", "author": "ajsutton", "createdAt": "2020-06-01T00:05:00Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/Store.java", "diffHunk": "@@ -403,6 +561,74 @@ public VoteTracker getVote(UnsignedLong validatorIndex) {\n               });\n     }\n \n+    private Map<Bytes32, SignedBlockAndState> getFinalizedChainData(\n+        final SignedBlockAndState previouslyFinalizedBlock,\n+        final SignedBlockAndState newlyFinalizedBlock) {\n+      final Map<Bytes32, SignedBlockAndState> finalizedChainData = new HashMap<>();\n+\n+      SignedBlockAndState oldestFinalizedBlock = newlyFinalizedBlock;\n+      SignedBlockAndState currentBlock = newlyFinalizedBlock;\n+      while (currentBlock != null\n+          && currentBlock.getSlot().compareTo(previouslyFinalizedBlock.getSlot()) > 0) {\n+        finalizedChainData.put(currentBlock.getRoot(), currentBlock);\n+        oldestFinalizedBlock = currentBlock;\n+        currentBlock = getBlockAndState(currentBlock.getParentRoot()).orElse(null);\n+      }\n+\n+      // Make sure we capture all finalized blocks\n+      if (!oldestFinalizedBlock.getParentRoot().equals(previouslyFinalizedBlock.getRoot())) {\n+        throw new IllegalStateException(\"Unable to retrieve all finalized blocks\");\n+      }\n+\n+      return finalizedChainData;\n+    }\n+\n+    private Map<UnsignedLong, Set<Bytes32>> getPrunedHotBlockRoots(\n+        final Checkpoint newFinalizedCheckpoint,\n+        final SignedBeaconBlock finalizedBlock,\n+        final Map<Bytes32, SignedBeaconBlock> newBlocks) {\n+      final UnsignedLong finalizedSlot = newFinalizedCheckpoint.getEpochStartSlot();\n+      Map<UnsignedLong, Set<Bytes32>> prunedBlockRoots = new HashMap<>();\n+\n+      // Build combined index from slot to block root for new and existing blocks\n+      final NavigableMap<UnsignedLong, Set<Bytes32>> slotToHotBlockRootIndex = new TreeMap<>();\n+      indexBlockRootsBySlot(slotToHotBlockRootIndex, newBlocks.values());\n+      slotToHotBlockRootIndex.putAll(rootsBySlotLookup);", "originalCommit": "fc1c7676c2ec212922d1369ac6788e4bf3708192", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MjU2Ng==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r433292566", "bodyText": "yes - good catch!  will make sure we have some tests around this.", "author": "mbaxter", "createdAt": "2020-06-01T15:10:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk5ODI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjgxNg==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r433002816", "bodyText": "Just confirming - this doesn't break backwards compatibility because it's not a column itself - there will just be a value stored in the DB which we no longer use?", "author": "ajsutton", "createdAt": "2020-06-01T00:46:38Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/schema/V3Schema.java", "diffHunk": "@@ -57,7 +57,6 @@\n       RocksDbVariable.create(3, CHECKPOINT_SERIALIZER);\n   RocksDbVariable<Checkpoint> FINALIZED_CHECKPOINT =\n       RocksDbVariable.create(4, CHECKPOINT_SERIALIZER);\n-  RocksDbVariable<BeaconState> LATEST_FINALIZED_STATE = RocksDbVariable.create(5, STATE_SERIALIZER);", "originalCommit": "fc1c7676c2ec212922d1369ac6788e4bf3708192", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM0OTUxNA==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r433349514", "bodyText": "Right - manually tested as well to confirm.", "author": "mbaxter", "createdAt": "2020-06-01T16:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjgxNg=="}], "type": "inlineReview"}, {"oid": "1f950bfe93028a84aea6173a5eac0a1361bf503a", "url": "https://github.com/ConsenSys/teku/commit/1f950bfe93028a84aea6173a5eac0a1361bf503a", "message": "Move state generation logic into an independent utility class", "committedDate": "2020-06-01T15:07:15Z", "type": "commit"}, {"oid": "f344080161946590369c8484cf51cca6e5b37054", "url": "https://github.com/ConsenSys/teku/commit/f344080161946590369c8484cf51cca6e5b37054", "message": "Fix bug in pruning logic, add tests", "committedDate": "2020-06-01T15:55:21Z", "type": "commit"}, {"oid": "13681bff4c054993e2da310aeb4880fcf047f636", "url": "https://github.com/ConsenSys/teku/commit/13681bff4c054993e2da310aeb4880fcf047f636", "message": "Code review - small cleanup", "committedDate": "2020-06-01T15:55:44Z", "type": "commit"}, {"oid": "6199f6dff80b7815eb2b6f1354e4e010ca89bb03", "url": "https://github.com/ConsenSys/teku/commit/6199f6dff80b7815eb2b6f1354e4e010ca89bb03", "message": "Reorganize pruning logic", "committedDate": "2020-06-01T16:30:45Z", "type": "commit"}, {"oid": "ff21d709c2eceaa3cb384b8fda90f914eea2dd38", "url": "https://github.com/ConsenSys/teku/commit/ff21d709c2eceaa3cb384b8fda90f914eea2dd38", "message": "Merge branch 'master' into issue-1976/move-hot-state-mgmt-into-store", "committedDate": "2020-06-01T16:36:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzNDEwMg==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r433434102", "bodyText": "Hmm - I think the current structure is problematic.  We do these calculations upfront to figure out our updates, send those updates to storage, and only then get a writeLock to actually update our in-memory Store.  But with that setup, we could interleave multiple transactions and commit the calculated changes out of order, and run into problems while trying to calculate the updates because the Store can change out from under us ...", "author": "mbaxter", "createdAt": "2020-06-01T19:12:29Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/Store.java", "diffHunk": "@@ -354,23 +451,16 @@ public VoteTracker getVote(UnsignedLong validatorIndex) {\n \n     @CheckReturnValue\n     public SafeFuture<Void> commit() {\n-      final StorageUpdate updateEvent =\n-          new StorageUpdate(\n-              genesis_time,\n-              justified_checkpoint,\n-              finalized_checkpoint,\n-              best_justified_checkpoint,\n-              blocks,\n-              block_states,\n-              checkpoint_states,\n-              votes);\n+      final TransactionCommitUpdates updates = TransactionCommitUpdates.calculate(Store.this, this);", "originalCommit": "ff21d709c2eceaa3cb384b8fda90f914eea2dd38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5NTkxNw==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r434895917", "bodyText": "Fixed this by adding a write lock around the update calculations.  This means that our update calculations are running off of a fixed Store, so we don't have to worry about any data changing while we're processing.  It's possible that we could fail to prune some new blocks that end up getting committed after we run our calculations, but those data will eventually be pruned the next time we finalize a new checkpoint.", "author": "mbaxter", "createdAt": "2020-06-03T22:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzNDEwMg=="}], "type": "inlineReview"}, {"oid": "894f7ca6b261961e67c9b31689af4c8e305b7bb4", "url": "https://github.com/ConsenSys/teku/commit/894f7ca6b261961e67c9b31689af4c8e305b7bb4", "message": "Add CheckpointAndBlock datastructure", "committedDate": "2020-06-03T15:54:01Z", "type": "commit"}, {"oid": "64a2c365fc085cfd94e1acb1b61eeef43f1e3222", "url": "https://github.com/ConsenSys/teku/commit/64a2c365fc085cfd94e1acb1b61eeef43f1e3222", "message": "Fix checkpoint ordering in StoreTest", "committedDate": "2020-06-03T15:57:40Z", "type": "commit"}, {"oid": "29bf47f4a5f1f307670e104f3a2f8ad8cdab2ece", "url": "https://github.com/ConsenSys/teku/commit/29bf47f4a5f1f307670e104f3a2f8ad8cdab2ece", "message": "Throw an exception if StateGenerator fails to regenerate any state", "committedDate": "2020-06-03T15:59:27Z", "type": "commit"}, {"oid": "f55e0664016d10a5d0a3a7de3692dcb1bb738b1f", "url": "https://github.com/ConsenSys/teku/commit/f55e0664016d10a5d0a3a7de3692dcb1bb738b1f", "message": "Add latest finalized state tracking back in\n\nWe can't substitute latest finalized state for the checkpoint state: the\ncheckpoint state does not necessarily correspond to the latest finalized\nblock's state.  If the finalized block is prior to the epoch boundary\nslot, its corresponding checkpoint state will be advanced to the epoch\nboundary slot.", "committedDate": "2020-06-03T16:07:05Z", "type": "commit"}, {"oid": "a5fb123fc19cc2d4bfcca25baa46957eea7899c0", "url": "https://github.com/ConsenSys/teku/commit/a5fb123fc19cc2d4bfcca25baa46957eea7899c0", "message": "Simplify storage update API's", "committedDate": "2020-06-03T18:35:37Z", "type": "commit"}, {"oid": "1f66175d54fce066c9ace485671ed4c77fdfd974", "url": "https://github.com/ConsenSys/teku/commit/1f66175d54fce066c9ace485671ed4c77fdfd974", "message": "Move Store to client package", "committedDate": "2020-06-03T18:38:49Z", "type": "commit"}, {"oid": "c3db937beb403873c6f4f9fd56eb1f2d4747aaef", "url": "https://github.com/ConsenSys/teku/commit/c3db937beb403873c6f4f9fd56eb1f2d4747aaef", "message": "Lock while transaction updates are being calculated", "committedDate": "2020-06-03T19:58:39Z", "type": "commit"}, {"oid": "3f51b2e1eaeca36307c9d47b579f2b97aee02cfb", "url": "https://github.com/ConsenSys/teku/commit/3f51b2e1eaeca36307c9d47b579f2b97aee02cfb", "message": "Move transaction update helper class into separate file", "committedDate": "2020-06-03T19:58:39Z", "type": "commit"}, {"oid": "2f649dcff28e650a3bf7a1b81da56902442dd28c", "url": "https://github.com/ConsenSys/teku/commit/2f649dcff28e650a3bf7a1b81da56902442dd28c", "message": "Move logic to update Store into StoreTransactionUpdates\n\nFix a few issues / cleanup StoreTransactionUpdates", "committedDate": "2020-06-03T19:58:39Z", "type": "commit"}, {"oid": "d3f07b619e5805175ed7aa1060f799821349d651", "url": "https://github.com/ConsenSys/teku/commit/d3f07b619e5805175ed7aa1060f799821349d651", "message": "Merge branch 'master' into issue-1976/move-hot-state-mgmt-into-store", "committedDate": "2020-06-03T21:23:15Z", "type": "commit"}, {"oid": "ad382275dc955e61ef01f5b029ebcf2289ee287e", "url": "https://github.com/ConsenSys/teku/commit/ad382275dc955e61ef01f5b029ebcf2289ee287e", "message": "Remove dead code", "committedDate": "2020-06-03T22:18:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxMjg1Nw==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r434912857", "bodyText": "nit: private?", "author": "ajsutton", "createdAt": "2020-06-03T23:34:03Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/state/CheckpointAndBlock.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.datastructures.state;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+\n+public class CheckpointAndBlock {\n+  final Checkpoint checkpoint;\n+  final SignedBeaconBlock block;", "originalCommit": "ad382275dc955e61ef01f5b029ebcf2289ee287e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxNTI3Nw==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r434915277", "bodyText": "It's kind of terrifying for these to not be private - there's quite a bit of stuff that could be changing them. I do like having things split into separate classes though.\nMaybe we should create a dedicated store package so that we have a very clear scope of what can access this stuff?  Maybe could even introduce a MutableStore interface that most things use (which extends ReadOnlyStore and adds the startTransaction methods).  Then the actual Store is only ever passed to the store helper classes.", "author": "ajsutton", "createdAt": "2020-06-03T23:42:45Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/Store.java", "diffHunk": "@@ -42,27 +47,28 @@\n import tech.pegasys.teku.datastructures.forkchoice.VoteTracker;\n import tech.pegasys.teku.datastructures.state.BeaconState;\n import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.datastructures.state.CheckpointAndBlock;\n import tech.pegasys.teku.datastructures.util.BeaconStateUtil;\n import tech.pegasys.teku.storage.api.StorageUpdateChannel;\n-import tech.pegasys.teku.storage.client.FailedPrecommitException;\n-import tech.pegasys.teku.storage.events.StorageUpdate;\n import tech.pegasys.teku.util.async.SafeFuture;\n \n public class Store implements ReadOnlyStore {\n   private static final Logger LOG = LogManager.getLogger();\n   private final ReadWriteLock lock = new ReentrantReadWriteLock();\n   private final Lock readLock = lock.readLock();\n-  private UnsignedLong time;\n-  private UnsignedLong genesis_time;\n-  private Checkpoint justified_checkpoint;\n-  private Checkpoint finalized_checkpoint;\n-  private Checkpoint best_justified_checkpoint;\n-  private Map<Bytes32, SignedBeaconBlock> blocks;\n-  private Map<Bytes32, BeaconState> block_states;\n-  private Map<Checkpoint, BeaconState> checkpoint_states;\n-  private Map<UnsignedLong, VoteTracker> votes;\n-\n-  public Store(\n+  UnsignedLong time;\n+  UnsignedLong genesis_time;\n+  Checkpoint justified_checkpoint;\n+  Checkpoint finalized_checkpoint;\n+  Checkpoint best_justified_checkpoint;\n+  Map<Bytes32, SignedBeaconBlock> blocks;\n+  Map<Bytes32, BeaconState> block_states;\n+  Map<Checkpoint, BeaconState> checkpoint_states;\n+  Map<UnsignedLong, VoteTracker> votes;", "originalCommit": "ad382275dc955e61ef01f5b029ebcf2289ee287e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMjQ3NQ==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r435332475", "bodyText": "Yeah - I was a bit uncomfortable with this as well.  Isolating the Store and helper classes into a separate package sounds like a good solution \ud83d\udc4d Will fix.", "author": "mbaxter", "createdAt": "2020-06-04T15:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxNTI3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM2OTIwMA==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r435369200", "bodyText": "Added some interfaces and made Store package-private: 82036c6", "author": "mbaxter", "createdAt": "2020-06-04T15:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxNTI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxNzc5Nw==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r434917797", "bodyText": "Do these blocks wind up staying on disk? And is that an issue?", "author": "ajsutton", "createdAt": "2020-06-03T23:51:49Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/Store.java", "diffHunk": "@@ -111,6 +120,91 @@ public static Store getForkChoiceStore(final BeaconState anchorState) {\n         votes);\n   }\n \n+  public static Store createByRegeneratingHotStates(\n+      final UnsignedLong time,\n+      final UnsignedLong genesis_time,\n+      final Checkpoint justified_checkpoint,\n+      final Checkpoint finalized_checkpoint,\n+      final Checkpoint best_justified_checkpoint,\n+      final Map<Bytes32, SignedBeaconBlock> blocks,\n+      final Map<Checkpoint, BeaconState> checkpoint_states,\n+      final BeaconState finalizedState,\n+      final Map<UnsignedLong, VoteTracker> votes) {\n+\n+    final StateGenerator stateGenerator = new StateGenerator();\n+    final Map<Bytes32, BeaconState> blockStates =\n+        stateGenerator.produceStatesForBlocks(\n+            finalized_checkpoint.getRoot(), finalizedState, blocks.values());\n+\n+    // If we couldn't regenerate states, log a warning\n+    if (blockStates.size() < blocks.size()) {\n+      LOG.warn(\"Unable to regenerate some hot states from hot blocks\");\n+\n+      // Drop any blocks for which a state couldn't be generated\n+      new HashSet<>(Sets.difference(blocks.keySet(), blockStates.keySet())).forEach(blocks::remove);", "originalCommit": "ad382275dc955e61ef01f5b029ebcf2289ee287e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzNDcwOA==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r435334708", "bodyText": "I'm not throwing an error here for backwards-compatibility reasons, but we should add an error here at some point.  For existing databases, fork blocks are pruned on restart, so they could have some invalid blocks in the database that would need to be pruned here.  I'll add a comment.", "author": "mbaxter", "createdAt": "2020-06-04T15:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxNzc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkxOTE2MA==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r434919160", "bodyText": "So to think through a conversation we've had offline about whether or not the call to storageUpdateChannel.onStorageUpdate needs to happen inside the write lock...\n\nWe can only have one thread importing blocks at a time, otherwise we'd mess up the in-memory state and various block validations wouldn't be accurate\nThere might be concurrent fork choice evaluations being done which would result in other store transactions interleaving, but those would only touch votes and blocks don't touch votes.\n\nThus, this is safe to do outside the write lock because no other block import can start until at least after this commit method returns, by which time the storage update has been sent and has the ordering fixed from there.\nBy releasing the write lock, even if storage is backed up read queries are able to be performed against the store which is good.\nCurrently block import waits for the returned future to complete before moving on to the next block and that will make this work, but if it didn't I believe we'd have an issue here because we aren't applying the changes to the in-memory store until the write to disk has completed.\nThe issue is that tx 1 makes the changes for block 10, then sends them off to storage, but at that point they haven't been applied to the underlying Store so are only visible to tx 1.  If the block importer didn't wait for commit to complete and moved on to block 11 - block 10 wouldn't yet be visible to it and it would fail.\nBut if we apply the additions before we know the storage works, we're a bit hosed if the storage fails because we then can't roll back.\nSo we probably need to stick with doing it this way and address it if we ever want to import blocks without waiting for storage (at which point we need to handle the error case anyway). We may want to just make commit() synchronous since everywhere that uses it does a .join() anyway.", "author": "ajsutton", "createdAt": "2020-06-03T23:56:32Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/Store.java", "diffHunk": "@@ -354,46 +460,25 @@ public VoteTracker getVote(UnsignedLong validatorIndex) {\n \n     @CheckReturnValue\n     public SafeFuture<Void> commit() {\n-      final StorageUpdate updateEvent =\n-          new StorageUpdate(\n-              genesis_time,\n-              justified_checkpoint,\n-              finalized_checkpoint,\n-              best_justified_checkpoint,\n-              blocks,\n-              block_states,\n-              checkpoint_states,\n-              votes);\n+      final StoreTransactionUpdates updates;\n+      // Lock so that we have a consistent view while calculating our updates\n+      final Lock writeLock = Store.this.lock.writeLock();\n+      writeLock.lock();\n+      try {\n+        updates = StoreTransactionUpdates.calculate(Store.this, this);\n+      } finally {\n+        writeLock.unlock();\n+      }\n+\n       return storageUpdateChannel\n-          .onStorageUpdate(updateEvent)\n+          .onStorageUpdate(updates.createStorageUpdate())", "originalCommit": "ad382275dc955e61ef01f5b029ebcf2289ee287e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkyMDQ2Nw==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r434920467", "bodyText": "It is really nice that this is in a separate class.", "author": "ajsutton", "createdAt": "2020-06-04T00:01:20Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/StoreTransactionUpdates.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.storage.client;\n+\n+import static tech.pegasys.teku.storage.client.Store.indexBlockRootsBySlot;\n+import static tech.pegasys.teku.storage.client.Store.removeBlockRootFromSlotIndex;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.datastructures.state.CheckpointAndBlock;\n+import tech.pegasys.teku.storage.client.Store.Transaction;\n+import tech.pegasys.teku.storage.events.StorageUpdate;\n+\n+class StoreTransactionUpdates {", "originalCommit": "ad382275dc955e61ef01f5b029ebcf2289ee287e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkyNzgxMg==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r434927812", "bodyText": "Looks like it would be easier to not use an Optional here.  Just something like:\nfinal CheckpointAndBlock newFinalizedCheckpoint = tx.getFinalizedCheckpointAndBlock();\n...\nif (newFinalizedCheckpoint.getEpoch().compareTo(prevFinalizedCheckpoint.getEpoch()) > 0) {\n    ... calculate stuff to prune ...\n} else {\n  .. the empty map stuff ...\n}\n\nAlthough I guess you need the optional to pass into the StoreTransactionUpdates so happy to go either way.", "author": "ajsutton", "createdAt": "2020-06-04T00:30:19Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/StoreTransactionUpdates.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.storage.client;\n+\n+import static tech.pegasys.teku.storage.client.Store.indexBlockRootsBySlot;\n+import static tech.pegasys.teku.storage.client.Store.removeBlockRootFromSlotIndex;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.datastructures.state.CheckpointAndBlock;\n+import tech.pegasys.teku.storage.client.Store.Transaction;\n+import tech.pegasys.teku.storage.events.StorageUpdate;\n+\n+class StoreTransactionUpdates {\n+  private final Store.Transaction tx;\n+\n+  private final Map<Bytes32, SignedBeaconBlock> hotBlocks;\n+  private final Map<Bytes32, SignedBlockAndState> finalizedChainData;\n+  private final Map<UnsignedLong, Set<Bytes32>> prunedHotBlockRoots;\n+  private final Map<Checkpoint, BeaconState> checkpointStates;\n+  private final Set<Checkpoint> staleCheckpointStates;\n+  private final Optional<CheckpointAndBlock> newFinalizedCheckpoint;\n+  private final Map<Bytes32, BeaconState> hotStates;\n+\n+  private StoreTransactionUpdates(\n+      final Transaction tx,\n+      final Map<Bytes32, SignedBeaconBlock> hotBlocks,\n+      final Map<Bytes32, BeaconState> hotStates,\n+      final Map<Bytes32, SignedBlockAndState> finalizedChainData,\n+      final Map<UnsignedLong, Set<Bytes32>> prunedHotBlockRoots,\n+      final Map<Checkpoint, BeaconState> checkpointStates,\n+      final Set<Checkpoint> staleCheckpointStates,\n+      final Optional<CheckpointAndBlock> newFinalizedCheckpoint) {\n+    this.tx = tx;\n+    this.hotBlocks = hotBlocks;\n+    this.hotStates = hotStates;\n+    this.finalizedChainData = finalizedChainData;\n+    this.prunedHotBlockRoots = prunedHotBlockRoots;\n+    this.checkpointStates = checkpointStates;\n+    this.staleCheckpointStates = staleCheckpointStates;\n+    this.newFinalizedCheckpoint = newFinalizedCheckpoint;\n+  }\n+\n+  public static StoreTransactionUpdates calculate(final Store baseStore, final Transaction tx) {\n+    // Save copy of tx data that may be pruned\n+    final Map<Bytes32, SignedBeaconBlock> hotBlocks = new HashMap<>(tx.blocks);\n+    final Map<Bytes32, BeaconState> hotStates = new HashMap<>(tx.block_states);\n+    final Map<Checkpoint, BeaconState> checkpointStates = new HashMap<>(tx.checkpoint_states);\n+\n+    // If a new checkpoint has been finalized, calculated what to finalize and what to prune\n+    final CheckpointAndBlock prevFinalizedCheckpoint = baseStore.getFinalizedCheckpointAndBlock();\n+    final Optional<CheckpointAndBlock> newFinalizedCheckpoint =\n+        Optional.of(tx.getFinalizedCheckpointAndBlock())\n+            .filter(c -> c.getEpoch().compareTo(prevFinalizedCheckpoint.getEpoch()) > 0);", "originalCommit": "ad382275dc955e61ef01f5b029ebcf2289ee287e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3NzAwMw==", "url": "https://github.com/ConsenSys/teku/pull/2006#discussion_r435377003", "bodyText": "\ud83d\udc4d Simplified", "author": "mbaxter", "createdAt": "2020-06-04T16:07:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkyNzgxMg=="}], "type": "inlineReview"}, {"oid": "8ce59b1f30c45d0cef8ee4fcd5499aeade5911eb", "url": "https://github.com/ConsenSys/teku/commit/8ce59b1f30c45d0cef8ee4fcd5499aeade5911eb", "message": "Move Store to a dedicated package for better isolation", "committedDate": "2020-06-04T15:13:52Z", "type": "commit"}, {"oid": "82036c69613d283ab5fef1f3ba1b4d0cad25fe6e", "url": "https://github.com/ConsenSys/teku/commit/82036c69613d283ab5fef1f3ba1b4d0cad25fe6e", "message": "Put Store behind an interface, make Store package-private", "committedDate": "2020-06-04T15:47:06Z", "type": "commit"}, {"oid": "178c4bc48ca6607f7a3b90d54e6314932e7290f1", "url": "https://github.com/ConsenSys/teku/commit/178c4bc48ca6607f7a3b90d54e6314932e7290f1", "message": "Add explanatory comment around warning", "committedDate": "2020-06-04T15:49:44Z", "type": "commit"}, {"oid": "f65dc0fe33b907aaf350007024a3bf9da5fc7e1c", "url": "https://github.com/ConsenSys/teku/commit/f65dc0fe33b907aaf350007024a3bf9da5fc7e1c", "message": "Merge branch 'master' into issue-1976/move-hot-state-mgmt-into-store", "committedDate": "2020-06-04T15:52:40Z", "type": "commit"}, {"oid": "478590d098a7ded563ef64d41cb1d51659a3fe04", "url": "https://github.com/ConsenSys/teku/commit/478590d098a7ded563ef64d41cb1d51659a3fe04", "message": "Simplify finalized checkpoint handling", "committedDate": "2020-06-04T16:05:31Z", "type": "commit"}, {"oid": "8996e262e1d9d56e8f0ea304e1176eec5a89d6e0", "url": "https://github.com/ConsenSys/teku/commit/8996e262e1d9d56e8f0ea304e1176eec5a89d6e0", "message": "Merge branch 'master' into issue-1976/move-hot-state-mgmt-into-store", "committedDate": "2020-06-04T18:02:27Z", "type": "commit"}]}