{"pr_number": 1111, "pr_title": "Optimize: add dedicated BeaconSate cache container, add active validators cache", "pr_createdAt": "2020-01-23T10:47:55Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1111", "timeline": [{"oid": "bcc60315ad654d49d500f7c8d8301cba935d6426", "url": "https://github.com/ConsenSys/teku/commit/bcc60315ad654d49d500f7c8d8301cba935d6426", "message": "Add activeValidatorsCache (naive static implementation)", "committedDate": "2020-01-23T09:19:23Z", "type": "commit"}, {"oid": "d724d3aab1f020d1c4b7aa71e87e39f9b1e9d69c", "url": "https://github.com/ConsenSys/teku/commit/d724d3aab1f020d1c4b7aa71e87e39f9b1e9d69c", "message": "Add TransitionCaches to the BeaconChainWithCache", "committedDate": "2020-01-23T09:27:26Z", "type": "commit"}, {"oid": "89d375ca06891b1d214094ac0a7beff94afc99cf", "url": "https://github.com/ConsenSys/teku/commit/89d375ca06891b1d214094ac0a7beff94afc99cf", "message": "Move activeValidators cache from ValidatorUtils statics to the TransitionsCache instance", "committedDate": "2020-01-23T09:27:43Z", "type": "commit"}, {"oid": "8588b1d60b72857ff10ec1a7e0130f2ea1990d0f", "url": "https://github.com/ConsenSys/teku/commit/8588b1d60b72857ff10ec1a7e0130f2ea1990d0f", "message": "Make LRUCache to evict last inserted entry instead of last accessed, since it is more appropriate for transition logic", "committedDate": "2020-01-23T09:50:49Z", "type": "commit"}, {"oid": "84ecfd1a24c5d394b183b526febce60a8c3e6776", "url": "https://github.com/ConsenSys/teku/commit/84ecfd1a24c5d394b183b526febce60a8c3e6776", "message": "Add javadocs", "committedDate": "2020-01-23T09:51:02Z", "type": "commit"}, {"oid": "c88eecc073a94bde9a3312e28730fbf69d59c7a7", "url": "https://github.com/ConsenSys/teku/commit/c88eecc073a94bde9a3312e28730fbf69d59c7a7", "message": "Apply spotless", "committedDate": "2020-01-23T10:55:07Z", "type": "commit"}, {"oid": "9a0a51f476df20d56fc11468af7d31b499365b30", "url": "https://github.com/ConsenSys/teku/commit/9a0a51f476df20d56fc11468af7d31b499365b30", "message": "Fix compiler warnings", "committedDate": "2020-01-23T11:36:38Z", "type": "commit"}, {"oid": "04f9319220e4e56f1c3b85dac1ab8f77595c25e5", "url": "https://github.com/ConsenSys/teku/commit/04f9319220e4e56f1c3b85dac1ab8f77595c25e5", "message": "Make LRUCache.copy() method thread-safe", "committedDate": "2020-01-23T12:54:11Z", "type": "commit"}, {"oid": "cfa0829bcbc02347f177b19f665d1bf927ddfbff", "url": "https://github.com/ConsenSys/teku/commit/cfa0829bcbc02347f177b19f665d1bf927ddfbff", "message": "Blocks generator: use the right keys source", "committedDate": "2020-01-23T13:14:05Z", "type": "commit"}, {"oid": "07206583d6e2e5b0df720ebcda3076328228c1b0", "url": "https://github.com/ConsenSys/teku/commit/07206583d6e2e5b0df720ebcda3076328228c1b0", "message": "Re-generate benchmark blocks for 0.9.4", "committedDate": "2020-01-23T13:48:36Z", "type": "commit"}, {"oid": "dad2554ecba9653bae9a6669c33652cda3ff3198", "url": "https://github.com/ConsenSys/teku/commit/dad2554ecba9653bae9a6669c33652cda3ff3198", "message": "Remove debug blocks printing", "committedDate": "2020-01-23T13:49:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyODA1Nw==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370328057", "bodyText": "Could this just use LimitedHashMap?  The static block to add initialCachedContent would just have to be done after construction but that should be safe since we're still in the constructor so no other operations can be happening.", "author": "ajsutton", "createdAt": "2020-01-23T20:04:56Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.datastructures.util.cache;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Cache made around LRU-map with fixed size, removing eldest entries (by added) when the space is\n+ * over\n+ *\n+ * @param <K> Keys type\n+ * @param <V> Values type\n+ */\n+public class LRUCache<K, V> implements Cache<K, V> {\n+\n+  private final Map<K, V> cacheData;\n+  private final int maxCapacity;\n+\n+  /**\n+   * Creates cache\n+   *\n+   * @param capacity Size of the cache\n+   */\n+  public LRUCache(int capacity) {\n+    this(capacity, Collections.emptyMap());\n+  }\n+\n+  private LRUCache(int capacity, Map<K, V> initialCachedContent) {\n+    this.maxCapacity = capacity;\n+    this.cacheData =\n+        Collections.synchronizedMap(\n+            new LinkedHashMap<>(maxCapacity + 1) {", "originalCommit": "dad2554ecba9653bae9a6669c33652cda3ff3198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUwMDUzOQ==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370500539", "bodyText": "Yep \ud83d\udc4d\nDone: 19d72bc", "author": "Nashatyrev", "createdAt": "2020-01-24T07:24:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyODA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTM0OA==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370329348", "bodyText": "I was going to suggest we consider using the Guava cache libraries rather than writing our own, but their version of Cache.get throws a checked exception to allow the fallback function to throw checked exceptions which makes using the cache kind of awful.", "author": "ajsutton", "createdAt": "2020-01-23T20:08:04Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.datastructures.util.cache;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Cache made around LRU-map with fixed size, removing eldest entries (by added) when the space is\n+ * over\n+ *\n+ * @param <K> Keys type\n+ * @param <V> Values type\n+ */\n+public class LRUCache<K, V> implements Cache<K, V> {", "originalCommit": "dad2554ecba9653bae9a6669c33652cda3ff3198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5OTU3OA==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370499578", "bodyText": "Heh, looks like we are on the same camp regarding checked exceptions :)\nNever used Guava caches, but we may consider them for more advanced use cases. This one is pretty simple and straightforward.", "author": "Nashatyrev", "createdAt": "2020-01-24T07:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDczMDM4MQ==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370730381", "bodyText": "Just wondering, why do you guys not like checked exceptions? To be able to handle a wider array of exceptions at a higher level?", "author": "cemozerr", "createdAt": "2020-01-24T16:41:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3OTIyMw==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370879223", "bodyText": "Checked exceptions can wind up requiring a lot of boilerplate try/catch code that makes it hard to follow control flow well.  If there's an error condition that really does need to be handled (e.g. block failing to import) then my first preference would be return a success or error result but if that's not feasible for some reason then I would use a checked exception. I wouldn't want to use an unchecked exception for something that really needs to be handled (the fact that most of the spec code throws unchecked exceptions when it fails is slightly terrifying).\nThings change a bit when working with CompletableFuture because unchecked exceptions get picked up as failed results so well and checked exceptions are even more annoying since methods like thenApply take a function and don't allow throwing checked exceptions.\nSo it's one of those highly context dependent rules...\nThe most annoying thing about checked exceptions though is when a method declares a checked exception that it really shouldn't ever throw.  Which is what happens with guava's cache get method.  It declares a checked exception so that it can allow the fallback function to throw a checked exception, but our actual fallback function shouldn't ever throw any exception so we wind up being forced to handle a checked exception that shouldn't ever be thrown so there's really nothing useful we can do once we catch it. Lots of boiler plate code and no actual value.", "author": "ajsutton", "createdAt": "2020-01-24T23:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4ODEzMQ==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r371988131", "bodyText": "That's interesting and great to know. Thank you very much for the detailed explanation @ajsutton", "author": "cemozerr", "createdAt": "2020-01-28T18:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIyMzM2MA==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r372223360", "bodyText": "@cemozerr\nFrom my personal experience the major part of checked exception handlings looks like\ncatch (SomeCheckedException e) {\n  throw new SomeUncheckedException(e);\n}\nIn the best case it's\ncatch (SomeCheckedException e) {\n  throw new SomeUncheckedException(\"Error while doing that: \" + that, e);\n}\nThis is because the major part of exceptions are actually unrecoverable at a lower level from one side and from another side it doesn't make too much sense when a higher level method declares throws a bunch of irrelevant checked exceptions.\nAgree with @ajsutton that in major cases dealing with unchecked exceptions is just a lot of boilerplate code unfortunately.\nBut there were always two opposite camps of developers regarding checked exception and of course they are both right at some point", "author": "Nashatyrev", "createdAt": "2020-01-29T07:23:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NzIwNg==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370347206", "bodyText": "This works and I like how it winds up with very minimal changes, but I wonder if as we introduce more caches we'll wind up with a lot of boilerplate in getting the caches etc obscuring the actual business logic.\nI think we should land this as-is, but I am wondering if we could be a bit radical here and take advantage of polymorphism.  1144a56 is what I have in mind.  If BeaconState provided a getActiveValidatorIndices method with the actual spec logic, then BeaconStateWithCache could just override that method to check the cache first.  Feels really nice and clean in many ways.\nBut there's a couple of downsides:\n\nNot sure this scales well - we could wind up with half the transition code in BeaconState.\nI don't see this playing well with hard forks after launch (neither does our current approach)\n\nWhich I think is enough to talk me out of it, and that it's better for classes like ValidatorUtils to use actual instances rather than all static methods - then this polymorphism approach could be used there, and different implementations could be provided for different hard forks, but that's a bigger scope of work.\nYou can safely ignore this for now if you like, I just keep pondering how we need to evolve the design to be more flexible in the future...  Happy to hear any thoughts anyone has though.", "author": "ajsutton", "createdAt": "2020-01-23T20:50:18Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java", "diffHunk": "@@ -100,11 +101,17 @@ public static boolean is_eligible_for_activation(BeaconState state, Validator va\n    *     <a>https://github.com/ethereum/eth2.0-specs/blob/v0.8.0/specs/core/0_beacon-chain.md#get_active_validator_indices</a>\n    */\n   public static List<Integer> get_active_validator_indices(BeaconState state, UnsignedLong epoch) {\n-    List<Validator> validators = state.getValidators();\n-    return IntStream.range(0, validators.size())\n-        .filter(index -> is_active_validator(validators.get(index), epoch))\n-        .boxed()\n-        .collect(Collectors.toList());\n+    return BeaconStateWithCache.getTransitionCaches(state)\n+        .getActiveValidators()\n+        .get(\n+            epoch,\n+            e -> {\n+              List<Validator> validators = state.getValidators();\n+              return IntStream.range(0, validators.size())\n+                  .filter(index -> is_active_validator(validators.get(index), epoch))\n+                  .boxed()\n+                  .collect(Collectors.toList());\n+            });", "originalCommit": "dad2554ecba9653bae9a6669c33652cda3ff3198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUwMzQxNQ==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370503415", "bodyText": "Yep, I see what you mean and totally support this approach. The spec procedural style contradicts Java OOP. But we are still sticking to it to be closer to the original spec to easy follow spec changes.\nI think at some point this is absolutely must have, but suppose this should be a separate large refactoring and we could start it from your suggested change", "author": "Nashatyrev", "createdAt": "2020-01-24T07:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NzIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3NzE0MA==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370877140", "bodyText": "Yeah agreed, out of scope for this PR.", "author": "ajsutton", "createdAt": "2020-01-24T22:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NzIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0ODIzNw==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370348237", "bodyText": "Would it be better to add getTransitionCaches to BeaconState and then use polymorphism so BeaconState returns TransitionCaches.getNoOp() and BeaconStateWithCache overrides it to return a real cache?\nThat would avoid the instanceof checks here and in deepCopy.", "author": "ajsutton", "createdAt": "2020-01-23T20:52:52Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/BeaconStateWithCache.java", "diffHunk": "@@ -172,6 +225,16 @@ public static BeaconStateWithCache fromBeaconState(BeaconState state) {\n         state.getFinalized_checkpoint());\n   }\n \n+  public static TransitionCaches getTransitionCaches(BeaconState state) {\n+    return state instanceof BeaconStateWithCache\n+        ? ((BeaconStateWithCache) state).getTransitionCaches()\n+        : TransitionCaches.getNoOp();\n+  }\n+\n+  public TransitionCaches getTransitionCaches() {\n+    return transitionCaches;\n+  }", "originalCommit": "dad2554ecba9653bae9a6669c33652cda3ff3198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUwODExMg==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370508112", "bodyText": "Not sure about this. I would keep the core BeaconState as clear as possible of any implementation specific stuff. I believe this central class would finally become pretty complex even without those 'tool' methods.\nTo reduce boilerplate in the spec functions we could do like this Nashatyrev#6 (though after formatting I'm not sure it looks much nicer)\nHowever I have no strong opinion whether it should done this or that way.", "author": "Nashatyrev", "createdAt": "2020-01-24T07:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0ODIzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3Nzc5Mg==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370877792", "bodyText": "I'd stick with the current approach in this PR for now then.  Nashatyrev#6 doesn't seem too worth it.\nLet's see how it goes as we add more caches - we may come up with other ideas, especially if we do wind up moving to a more OO style as discussed above.", "author": "ajsutton", "createdAt": "2020-01-24T22:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0ODIzNw=="}], "type": "inlineReview"}, {"oid": "19d72bc794a3046bed74b5f9380a3bff80835604", "url": "https://github.com/ConsenSys/teku/commit/19d72bc794a3046bed74b5f9380a3bff80835604", "message": "Use existing LimitedHashMap instead of duplicating code", "committedDate": "2020-01-24T07:08:26Z", "type": "commit"}, {"oid": "43403794e6e081b9a084b9d3a54e28b706f136cc", "url": "https://github.com/ConsenSys/teku/commit/43403794e6e081b9a084b9d3a54e28b706f136cc", "message": "Merge remote-tracking branch 'pegasys/master' into optimize-add-cache-active-validators", "committedDate": "2020-01-24T07:22:53Z", "type": "commit"}, {"oid": "8ae65418ee21f58897ec62e63116b7fd4e03e438", "url": "https://github.com/ConsenSys/teku/commit/8ae65418ee21f58897ec62e63116b7fd4e03e438", "message": "Benchmark resource updated with a block list of 300 entries", "committedDate": "2020-01-24T07:59:46Z", "type": "commit"}, {"oid": "aa4a266eca9b4da95137bca8c8645c8137f6b643", "url": "https://github.com/ConsenSys/teku/commit/aa4a266eca9b4da95137bca8c8645c8137f6b643", "message": "Rephrase the code to fix the DoubleBraceInitialization warning", "committedDate": "2020-01-24T08:40:28Z", "type": "commit"}, {"oid": "059167f5c001f7ad23cd76019083e924b04273a4", "url": "https://github.com/ConsenSys/teku/commit/059167f5c001f7ad23cd76019083e924b04273a4", "message": "Merge branch 'master' into optimize-add-cache-active-validators", "committedDate": "2020-01-27T16:19:47Z", "type": "commit"}]}