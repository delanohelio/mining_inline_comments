{"pr_number": 1506, "pr_title": "Add ValidatorClientService", "pr_createdAt": "2020-03-31T04:47:05Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1506", "timeline": [{"oid": "bd9556a6175b62d71df8a97e6a3eba1765434d86", "url": "https://github.com/ConsenSys/teku/commit/bd9556a6175b62d71df8a97e6a3eba1765434d86", "message": "Maintain services in a list in ServiceController so optional services are easier.", "committedDate": "2020-03-31T04:12:05Z", "type": "commit"}, {"oid": "fc3af7109660743abc55ca5ba4608aa044d91fd8", "url": "https://github.com/ConsenSys/teku/commit/fc3af7109660743abc55ca5ba4608aa044d91fd8", "message": "Add new ValidatorClientService that tracks the current fork and validator duties.\nToggled off as the duties are currently still performed by ValidatorCoordinator and unimplemented in ValidatorClientService.", "committedDate": "2020-03-31T04:42:22Z", "type": "commit"}, {"oid": "ec94232275f899ae9daba422cc642bb6be50b0c8", "url": "https://github.com/ConsenSys/teku/commit/ec94232275f899ae9daba422cc642bb6be50b0c8", "message": "Add final.", "committedDate": "2020-03-31T04:44:00Z", "type": "commit"}, {"oid": "93bbb990e5464f53623a7a71eb2bc0ecd2ca0caf", "url": "https://github.com/ConsenSys/teku/commit/93bbb990e5464f53623a7a71eb2bc0ecd2ca0caf", "message": "Uncomment.", "committedDate": "2020-03-31T04:48:47Z", "type": "commit"}, {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6", "url": "https://github.com/ConsenSys/teku/commit/7df0b1aab972ff493231169be15aac31af80c9f6", "message": "Spotless.", "committedDate": "2020-03-31T04:50:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA5MzM4Nw==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401093387", "bodyText": "nit: would be nice to have a generic function that takes attestationProposalDuties and blockProposalDuties as arguments since the rest of the logic is same.", "author": "cemozerr", "createdAt": "2020-03-31T17:36:28Z", "path": "validator/client/src/main/java/tech/pegasys/artemis/validator/client/DutyScheduler.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.client;\n+\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.bls.BLSPublicKey;\n+import tech.pegasys.artemis.util.config.Constants;\n+import tech.pegasys.artemis.validator.api.ValidatorApiChannel;\n+import tech.pegasys.artemis.validator.api.ValidatorDuties;\n+import tech.pegasys.artemis.validator.api.ValidatorTimingChannel;\n+import tech.pegasys.artemis.validator.client.duties.AttestationProductionDuty;\n+import tech.pegasys.artemis.validator.client.duties.BlockProductionDuty;\n+import tech.pegasys.artemis.validator.client.duties.ValidatorDutyFactory;\n+\n+public class DutyScheduler implements ValidatorTimingChannel {\n+  private static final Logger LOG = LogManager.getLogger();\n+  final AtomicReference<UnsignedLong> latestScheduledEpoch = new AtomicReference<>();\n+  private final ConcurrentMap<UnsignedLong, BlockProductionDuty> blockProposalDuties =\n+      new ConcurrentHashMap<>();\n+  private final ConcurrentMap<UnsignedLong, AttestationProductionDuty> attestationProposalDuties =\n+      new ConcurrentHashMap<>();\n+  private final AsyncRunner asyncRunner;\n+  private final ValidatorApiChannel validatorApiChannel;\n+  private final ValidatorDutyFactory dutyFactory;\n+  private final Map<BLSPublicKey, Validator> validators;\n+\n+  public DutyScheduler(\n+      final AsyncRunner asyncRunner,\n+      final ValidatorApiChannel validatorApiChannel,\n+      final ValidatorDutyFactory dutyFactory,\n+      final Map<BLSPublicKey, Validator> validators) {\n+    this.asyncRunner = asyncRunner;\n+    this.validatorApiChannel = validatorApiChannel;\n+    this.dutyFactory = dutyFactory;\n+    this.validators = validators;\n+  }\n+\n+  @Override\n+  public void onSlot(final UnsignedLong slotNumber) {\n+    final UnsignedLong epochNumber = compute_epoch_at_slot(slotNumber);\n+    latestScheduledEpoch.getAndUpdate(\n+        lastRequestedEpoch -> {\n+          final UnsignedLong startEpoch =\n+              lastRequestedEpoch == null ? epochNumber : lastRequestedEpoch.plus(UnsignedLong.ONE);\n+          final UnsignedLong endEpoch = epochNumber.plus(UnsignedLong.ONE);\n+          for (UnsignedLong currentEpoch = startEpoch;\n+              currentEpoch.compareTo(endEpoch) <= 0;\n+              currentEpoch = currentEpoch.plus(UnsignedLong.ONE)) {\n+            scheduleDutiesForEpoch(currentEpoch).reportExceptions();\n+          }\n+          return startEpoch.compareTo(endEpoch) > 0 ? startEpoch : endEpoch;\n+        });\n+  }\n+\n+  private SafeFuture<Void> scheduleDutiesForEpoch(final UnsignedLong epoch) {\n+    LOG.trace(\"Requesting duties for epoch {}\", epoch);\n+    return validatorApiChannel\n+        .getDuties(epoch, validators.keySet())\n+        .orTimeout(Constants.VALIDATOR_DUTIES_TIMEOUT, TimeUnit.SECONDS)\n+        .thenApply(\n+            maybeDuties ->\n+                maybeDuties.orElseThrow(\n+                    () ->\n+                        new IllegalStateException(\n+                            \"Duties could not be calculated because chain data was not yet available\")))\n+        .thenAccept(duties -> duties.forEach(this::scheduleDuties))\n+        .exceptionallyCompose(\n+            error -> {\n+              LOG.error(\n+                  \"Failed to request validator duties for epoch \"\n+                      + epoch\n+                      + \". Retrying after delay.\",\n+                  error);\n+              return asyncRunner.runAfterDelay(\n+                  () -> scheduleDutiesForEpoch(epoch), 5, TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void scheduleDuties(final ValidatorDuties validatorDuties) {\n+    LOG.trace(\"Got validator duties: {}\", validatorDuties);\n+    final Validator validator = validators.get(validatorDuties.getPublicKey());\n+    validatorDuties\n+        .getDuties()\n+        .ifPresent(\n+            duties -> {\n+              duties\n+                  .getBlockProposalSlots()\n+                  .forEach(slot -> scheduleBlockProduction(validator, slot));\n+              scheduleAttestationProduction(\n+                  duties.getAttestationCommitteeIndex(),\n+                  validator,\n+                  duties.getValidatorIndex(),\n+                  duties.getAttestationSlot());\n+            });\n+  }\n+\n+  private void scheduleBlockProduction(final Validator validator, final UnsignedLong slot) {\n+    blockProposalDuties.put(slot, dutyFactory.createBlockProductionDuty(validator, slot));\n+  }\n+\n+  private void scheduleAttestationProduction(\n+      final int attestationCommitteeIndex,\n+      final Validator validator,\n+      final int validatorIndex,\n+      final UnsignedLong slot) {\n+    attestationProposalDuties\n+        .computeIfAbsent(slot, dutyFactory::createAttestationProductionDuty)\n+        .addValidator(attestationCommitteeIndex, validator, validatorIndex);\n+  }\n+\n+  @Override\n+  public void onBlockProductionDue(final UnsignedLong slot) {\n+    final BlockProductionDuty duty = blockProposalDuties.remove(slot);\n+    if (duty == null) {\n+      return;\n+    }\n+    duty.performDuty();\n+  }\n+\n+  @Override\n+  public void onAttestationCreationDue(final UnsignedLong slot) {\n+    final AttestationProductionDuty duty = attestationProposalDuties.remove(slot);", "originalCommit": "7df0b1aab972ff493231169be15aac31af80c9f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA5OTA5NA==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401099094", "bodyText": "The block production duty is probably more time-dependent than the duty scheduling that gets performed in onSlot so I would reverse their order (unless there is a scenario in which we schedule the block production of the current slot in the exact slot itself, although since we're scheduling an epoch ahead, that probably should not happen)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                validatorTimingChannel.onSlot(slot);\n          \n          \n            \n                validatorTimingChannel.onBlockProductionDue(slot);", "author": "cemozerr", "createdAt": "2020-03-31T17:45:44Z", "path": "validator/anticorruption/src/main/java/tech/pegasys/artemis/validator/anticorruption/BeaconChainEventAdapter.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.anticorruption;\n+\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import tech.pegasys.artemis.statetransition.events.attestation.BroadcastAttestationEvent;\n+import tech.pegasys.artemis.util.time.channels.SlotEventsChannel;\n+import tech.pegasys.artemis.validator.api.ValidatorTimingChannel;\n+\n+/**\n+ * Converts events from the {@link com.google.common.eventbus.EventBus} to the new validator client\n+ * {@link tech.pegasys.artemis.events.EventChannels}.\n+ */\n+class BeaconChainEventAdapter implements SlotEventsChannel {\n+\n+  private final ValidatorTimingChannel validatorTimingChannel;\n+\n+  public BeaconChainEventAdapter(final ValidatorTimingChannel validatorTimingChannel) {\n+    this.validatorTimingChannel = validatorTimingChannel;\n+  }\n+\n+  @Subscribe\n+  public void onBroadcastAttestationEvent(final BroadcastAttestationEvent event) {\n+    validatorTimingChannel.onAttestationCreationDue(event.getNodeSlot());\n+  }\n+\n+  @Override\n+  public void onSlot(final UnsignedLong slot) {\n+    validatorTimingChannel.onSlot(slot);", "originalCommit": "7df0b1aab972ff493231169be15aac31af80c9f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA5OTUzNA==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401099534", "bodyText": "Or, can we run them in parallel?", "author": "cemozerr", "createdAt": "2020-03-31T17:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA5OTA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2MjA1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401262056", "bodyText": "The requests for both very quickly become asynchronous anyway because of the calls into ValidatorApiChannel.  Which is somewhat unfortunate because you need to have found the duties to perform before you know you need to produce a block which means we'll miss creating a block on the first slot we see because the duties won't yet be scheduled.  I think I can live with that though - if we'd started slightly later we'd have missed the slot anyway.", "author": "ajsutton", "createdAt": "2020-03-31T22:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA5OTA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA5OTIyMw==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401099223", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                validatorTimingChannel.onBlockProductionDue(slot);\n          \n          \n            \n                validatorTimingChannel.onSlot(slot);", "author": "cemozerr", "createdAt": "2020-03-31T17:45:58Z", "path": "validator/anticorruption/src/main/java/tech/pegasys/artemis/validator/anticorruption/BeaconChainEventAdapter.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.anticorruption;\n+\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import tech.pegasys.artemis.statetransition.events.attestation.BroadcastAttestationEvent;\n+import tech.pegasys.artemis.util.time.channels.SlotEventsChannel;\n+import tech.pegasys.artemis.validator.api.ValidatorTimingChannel;\n+\n+/**\n+ * Converts events from the {@link com.google.common.eventbus.EventBus} to the new validator client\n+ * {@link tech.pegasys.artemis.events.EventChannels}.\n+ */\n+class BeaconChainEventAdapter implements SlotEventsChannel {\n+\n+  private final ValidatorTimingChannel validatorTimingChannel;\n+\n+  public BeaconChainEventAdapter(final ValidatorTimingChannel validatorTimingChannel) {\n+    this.validatorTimingChannel = validatorTimingChannel;\n+  }\n+\n+  @Subscribe\n+  public void onBroadcastAttestationEvent(final BroadcastAttestationEvent event) {\n+    validatorTimingChannel.onAttestationCreationDue(event.getNodeSlot());\n+  }\n+\n+  @Override\n+  public void onSlot(final UnsignedLong slot) {\n+    validatorTimingChannel.onSlot(slot);\n+    validatorTimingChannel.onBlockProductionDue(slot);", "originalCommit": "7df0b1aab972ff493231169be15aac31af80c9f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwMDkwNA==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401100904", "bodyText": "Is this fork number for hard forks? Otherwise, 5 minutes of refresh time seems a bit risky.", "author": "cemozerr", "createdAt": "2020-03-31T17:48:43Z", "path": "validator/client/src/main/java/tech/pegasys/artemis/validator/client/ForkProvider.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.client;\n+\n+import static tech.pegasys.artemis.util.config.Constants.FORK_REFRESH_TIME_SECONDS;\n+import static tech.pegasys.artemis.util.config.Constants.FORK_RETRY_DELAY_SECONDS;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.datastructures.state.Fork;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.validator.api.ValidatorApiChannel;\n+\n+public class ForkProvider {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private AsyncRunner asyncRunner;\n+  private final ValidatorApiChannel validatorApiChannel;\n+\n+  private volatile Optional<Fork> currentFork = Optional.empty();\n+\n+  public ForkProvider(\n+      final AsyncRunner asyncRunner, final ValidatorApiChannel validatorApiChannel) {\n+    this.asyncRunner = asyncRunner;\n+    this.validatorApiChannel = validatorApiChannel;\n+  }\n+\n+  public SafeFuture<Fork> getFork() {\n+    return currentFork.map(SafeFuture::completedFuture).orElseGet(this::loadFork);\n+  }\n+\n+  public SafeFuture<Fork> loadFork() {\n+    return requestFork()\n+        .exceptionallyCompose(\n+            error -> {\n+              LOG.error(\"Failed to retrieve current fork. Retrying after delay\", error);\n+              return asyncRunner.runAfterDelay(\n+                  this::getFork, FORK_RETRY_DELAY_SECONDS, TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  public SafeFuture<Fork> requestFork() {\n+    return validatorApiChannel\n+        .getFork()\n+        .thenCompose(\n+            maybeFork -> {\n+              if (maybeFork.isEmpty()) {\n+                LOG.trace(\"Fork not available, retrying\");\n+                return asyncRunner.runAfterDelay(\n+                    this::requestFork, FORK_RETRY_DELAY_SECONDS, TimeUnit.SECONDS);\n+              }\n+              final Fork fork = maybeFork.orElseThrow();\n+              currentFork = Optional.of(fork);\n+              // Periodically refresh the current fork.\n+              asyncRunner\n+                  .runAfterDelay(this::loadFork, FORK_REFRESH_TIME_SECONDS, TimeUnit.SECONDS)", "originalCommit": "7df0b1aab972ff493231169be15aac31af80c9f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2MjM4MA==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401262380", "bodyText": "This is for hard forks - it's the Fork object from the spec.", "author": "ajsutton", "createdAt": "2020-03-31T22:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwMDkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNjUyOA==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401106528", "bodyText": "I might have missed this previously, but why does ValidatorDuties keep a list of blockProposerSlots? A validator proposes a block about every 3 weeks.", "author": "cemozerr", "createdAt": "2020-03-31T17:57:43Z", "path": "validator/client/src/test/java/tech/pegasys/artemis/validator/client/DutySchedulerTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.client;\n+\n+import static java.util.Collections.emptyList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.async.StubAsyncRunner;\n+import tech.pegasys.artemis.util.bls.BLSPublicKey;\n+import tech.pegasys.artemis.validator.api.ValidatorApiChannel;\n+import tech.pegasys.artemis.validator.api.ValidatorDuties;\n+import tech.pegasys.artemis.validator.client.duties.AttestationProductionDuty;\n+import tech.pegasys.artemis.validator.client.duties.BlockProductionDuty;\n+import tech.pegasys.artemis.validator.client.duties.ValidatorDutyFactory;\n+import tech.pegasys.artemis.validator.client.signer.Signer;\n+\n+class DutySchedulerTest {\n+  private static final BLSPublicKey VALIDATOR1_KEY = BLSPublicKey.random(100);\n+  private static final BLSPublicKey VALIDATOR2_KEY = BLSPublicKey.random(200);\n+  private static final Collection<BLSPublicKey> VALIDATOR_KEYS =\n+      Set.of(VALIDATOR1_KEY, VALIDATOR2_KEY);\n+  private final Signer validator1Signer = mock(Signer.class);\n+  private final Signer validator2Signer = mock(Signer.class);\n+  private final Validator validator1 = new Validator(VALIDATOR1_KEY, validator1Signer);\n+  private final Validator validator2 = new Validator(VALIDATOR2_KEY, validator2Signer);\n+\n+  private final ValidatorApiChannel validatorApiChannel = mock(ValidatorApiChannel.class);\n+  private final ValidatorDutyFactory dutyFactory = mock(ValidatorDutyFactory.class);\n+  private final StubAsyncRunner asyncRunner = new StubAsyncRunner();\n+\n+  private final DutyScheduler validatorClient =\n+      new DutyScheduler(\n+          asyncRunner,\n+          validatorApiChannel,\n+          dutyFactory,\n+          Map.of(VALIDATOR1_KEY, validator1, VALIDATOR2_KEY, validator2));\n+\n+  @BeforeEach\n+  public void setUp() {\n+    when(validatorApiChannel.getDuties(any(), any()))\n+        .thenReturn(SafeFuture.completedFuture(Optional.of(emptyList())));\n+    when(dutyFactory.createAttestationProductionDuty(any()))\n+        .thenReturn(mock(AttestationProductionDuty.class));\n+  }\n+\n+  @Test\n+  public void shouldFetchDutiesForCurrentAndNextEpoch() {\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+\n+    verify(validatorApiChannel).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+    verify(validatorApiChannel).getDuties(UnsignedLong.valueOf(2), VALIDATOR_KEYS);\n+  }\n+\n+  @Test\n+  public void shouldNotRefetchDutiesWhichHaveAlreadyBeenRetrieved() {\n+    when(validatorApiChannel.getDuties(any(), any())).thenReturn(new SafeFuture<>());\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+\n+    verify(validatorApiChannel).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+    verify(validatorApiChannel).getDuties(UnsignedLong.valueOf(2), VALIDATOR_KEYS);\n+\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.valueOf(2)));\n+\n+    // Requests the next epoch, but not the current one because we already have that\n+    verify(validatorApiChannel).getDuties(UnsignedLong.valueOf(3), VALIDATOR_KEYS);\n+    verifyNoMoreInteractions(validatorApiChannel);\n+  }\n+\n+  @Test\n+  public void shouldRetryWhenRequestingDutiesFails() {\n+    final SafeFuture<Optional<List<ValidatorDuties>>> request1 = new SafeFuture<>();\n+    final SafeFuture<Optional<List<ValidatorDuties>>> request2 = new SafeFuture<>();\n+    when(validatorApiChannel.getDuties(UnsignedLong.ONE, VALIDATOR_KEYS))\n+        .thenReturn(request1)\n+        .thenReturn(request2);\n+\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+    verify(validatorApiChannel, times(1)).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+\n+    request1.completeExceptionally(new RuntimeException(\"Nope\"));\n+    assertThat(asyncRunner.hasDelayedActions()).isTrue();\n+    asyncRunner.executeQueuedActions();\n+\n+    // Should retry request\n+    verify(validatorApiChannel, times(2)).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+\n+    // And not have any more retries scheduled\n+    assertThat(asyncRunner.hasDelayedActions()).isFalse();\n+  }\n+\n+  @Test\n+  public void shouldScheduleBlockProposalDuty() {\n+    final UnsignedLong blockProposerSlot = UnsignedLong.valueOf(5);\n+    final ValidatorDuties validator1Duties =\n+        ValidatorDuties.withDuties(\n+            VALIDATOR1_KEY, 5, 3, List.of(blockProposerSlot), UnsignedLong.valueOf(7));", "originalCommit": "7df0b1aab972ff493231169be15aac31af80c9f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2Mjc3OQ==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401262779", "bodyText": "Validators are randomly assigned blocks to produce so there's no restriction on them being asked to produce twice in one epoch.  This matches the Lighthouse API and Prysm are moving to it as well (they've realised this is likely why they miss block sometimes).", "author": "ajsutton", "createdAt": "2020-03-31T22:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNjUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2NDkxMQ==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401264911", "bodyText": "Interesting!", "author": "cemozerr", "createdAt": "2020-03-31T23:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNjUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMjUzMg==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401112532", "bodyText": "This functionality is not yet implemented although you're still testing, right?", "author": "cemozerr", "createdAt": "2020-03-31T18:07:46Z", "path": "validator/client/src/test/java/tech/pegasys/artemis/validator/client/DutySchedulerTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.client;\n+\n+import static java.util.Collections.emptyList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.async.StubAsyncRunner;\n+import tech.pegasys.artemis.util.bls.BLSPublicKey;\n+import tech.pegasys.artemis.validator.api.ValidatorApiChannel;\n+import tech.pegasys.artemis.validator.api.ValidatorDuties;\n+import tech.pegasys.artemis.validator.client.duties.AttestationProductionDuty;\n+import tech.pegasys.artemis.validator.client.duties.BlockProductionDuty;\n+import tech.pegasys.artemis.validator.client.duties.ValidatorDutyFactory;\n+import tech.pegasys.artemis.validator.client.signer.Signer;\n+\n+class DutySchedulerTest {\n+  private static final BLSPublicKey VALIDATOR1_KEY = BLSPublicKey.random(100);\n+  private static final BLSPublicKey VALIDATOR2_KEY = BLSPublicKey.random(200);\n+  private static final Collection<BLSPublicKey> VALIDATOR_KEYS =\n+      Set.of(VALIDATOR1_KEY, VALIDATOR2_KEY);\n+  private final Signer validator1Signer = mock(Signer.class);\n+  private final Signer validator2Signer = mock(Signer.class);\n+  private final Validator validator1 = new Validator(VALIDATOR1_KEY, validator1Signer);\n+  private final Validator validator2 = new Validator(VALIDATOR2_KEY, validator2Signer);\n+\n+  private final ValidatorApiChannel validatorApiChannel = mock(ValidatorApiChannel.class);\n+  private final ValidatorDutyFactory dutyFactory = mock(ValidatorDutyFactory.class);\n+  private final StubAsyncRunner asyncRunner = new StubAsyncRunner();\n+\n+  private final DutyScheduler validatorClient =\n+      new DutyScheduler(\n+          asyncRunner,\n+          validatorApiChannel,\n+          dutyFactory,\n+          Map.of(VALIDATOR1_KEY, validator1, VALIDATOR2_KEY, validator2));\n+\n+  @BeforeEach\n+  public void setUp() {\n+    when(validatorApiChannel.getDuties(any(), any()))\n+        .thenReturn(SafeFuture.completedFuture(Optional.of(emptyList())));\n+    when(dutyFactory.createAttestationProductionDuty(any()))\n+        .thenReturn(mock(AttestationProductionDuty.class));\n+  }\n+\n+  @Test\n+  public void shouldFetchDutiesForCurrentAndNextEpoch() {\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+\n+    verify(validatorApiChannel).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+    verify(validatorApiChannel).getDuties(UnsignedLong.valueOf(2), VALIDATOR_KEYS);\n+  }\n+\n+  @Test\n+  public void shouldNotRefetchDutiesWhichHaveAlreadyBeenRetrieved() {\n+    when(validatorApiChannel.getDuties(any(), any())).thenReturn(new SafeFuture<>());\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+\n+    verify(validatorApiChannel).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+    verify(validatorApiChannel).getDuties(UnsignedLong.valueOf(2), VALIDATOR_KEYS);\n+\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.valueOf(2)));\n+\n+    // Requests the next epoch, but not the current one because we already have that\n+    verify(validatorApiChannel).getDuties(UnsignedLong.valueOf(3), VALIDATOR_KEYS);\n+    verifyNoMoreInteractions(validatorApiChannel);\n+  }\n+\n+  @Test\n+  public void shouldRetryWhenRequestingDutiesFails() {\n+    final SafeFuture<Optional<List<ValidatorDuties>>> request1 = new SafeFuture<>();\n+    final SafeFuture<Optional<List<ValidatorDuties>>> request2 = new SafeFuture<>();\n+    when(validatorApiChannel.getDuties(UnsignedLong.ONE, VALIDATOR_KEYS))\n+        .thenReturn(request1)\n+        .thenReturn(request2);\n+\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+    verify(validatorApiChannel, times(1)).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+\n+    request1.completeExceptionally(new RuntimeException(\"Nope\"));\n+    assertThat(asyncRunner.hasDelayedActions()).isTrue();\n+    asyncRunner.executeQueuedActions();\n+\n+    // Should retry request\n+    verify(validatorApiChannel, times(2)).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+\n+    // And not have any more retries scheduled\n+    assertThat(asyncRunner.hasDelayedActions()).isFalse();\n+  }\n+\n+  @Test\n+  public void shouldScheduleBlockProposalDuty() {\n+    final UnsignedLong blockProposerSlot = UnsignedLong.valueOf(5);\n+    final ValidatorDuties validator1Duties =\n+        ValidatorDuties.withDuties(\n+            VALIDATOR1_KEY, 5, 3, List.of(blockProposerSlot), UnsignedLong.valueOf(7));\n+    when(validatorApiChannel.getDuties(eq(UnsignedLong.ONE), any()))\n+        .thenReturn(SafeFuture.completedFuture(Optional.of(List.of(validator1Duties))));\n+\n+    final BlockProductionDuty blockCreationDuty = mock(BlockProductionDuty.class);\n+    when(dutyFactory.createBlockProductionDuty(validator1, blockProposerSlot))\n+        .thenReturn(blockCreationDuty);\n+\n+    // Load duties\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+\n+    // Execute\n+    validatorClient.onBlockProductionDue(blockProposerSlot);\n+    verify(blockCreationDuty).performDuty();\n+  }\n+\n+  @Test\n+  public void shouldNotPerformDutiesForSameSlotTwice() {\n+    final UnsignedLong blockProposerSlot = UnsignedLong.valueOf(5);\n+    final ValidatorDuties validator1Duties =\n+        ValidatorDuties.withDuties(\n+            VALIDATOR1_KEY, 5, 3, List.of(blockProposerSlot), UnsignedLong.valueOf(7));\n+    when(validatorApiChannel.getDuties(eq(UnsignedLong.ONE), any()))\n+        .thenReturn(SafeFuture.completedFuture(Optional.of(List.of(validator1Duties))));\n+\n+    final BlockProductionDuty blockCreationDuty = mock(BlockProductionDuty.class);\n+    when(dutyFactory.createBlockProductionDuty(validator1, blockProposerSlot))\n+        .thenReturn(blockCreationDuty);\n+\n+    // Load duties\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+\n+    // Execute\n+    validatorClient.onBlockProductionDue(blockProposerSlot);\n+    verify(blockCreationDuty).performDuty();\n+\n+    // Somehow we triggered the same slot again.\n+    validatorClient.onBlockProductionDue(blockProposerSlot);", "originalCommit": "7df0b1aab972ff493231169be15aac31af80c9f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2MjkxOA==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401262918", "bodyText": "Scheduling the duty is implemented, just the BlockProductionDuty doesn't actually do anything yet.", "author": "ajsutton", "createdAt": "2020-03-31T22:57:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMjUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2NDcxMQ==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401264711", "bodyText": "I mean the anticorruption layer.", "author": "cemozerr", "createdAt": "2020-03-31T23:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMjUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2NzQ3Mw==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401267473", "bodyText": "I'm not quite sure what you mean.  The anticorruption layer is converting beacon chain events to drive the validator timing channel.  It shouldn't wind up triggering the same slot twice but I don't want to depend on that.", "author": "ajsutton", "createdAt": "2020-03-31T23:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMjUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2NzcyMg==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401267722", "bodyText": "I'm being particularly defensive here because I know what drives the timing events is likely to change and I'm not sure what it will wind up being yet so making as few assumptions as possible.", "author": "ajsutton", "createdAt": "2020-03-31T23:12:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMjUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI3MTAzMg==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401271032", "bodyText": "Oh, I was just curious where the mechanism to make sure we don't propose two blocks in the same slot, but I see that we pass in the slot to performDuty so it makes sense now.", "author": "cemozerr", "createdAt": "2020-03-31T23:22:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMjUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI3MjEyOA==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401272128", "bodyText": "Yeah I broke that test when I introduced performDutyForSlot because I wrote it with get instead of remove.  So it's proved it's worth. :)", "author": "ajsutton", "createdAt": "2020-03-31T23:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMjUzMg=="}], "type": "inlineReview"}, {"oid": "cd4899fc05c315f57cdb366cb119aa41fc537e08", "url": "https://github.com/ConsenSys/teku/commit/cd4899fc05c315f57cdb366cb119aa41fc537e08", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into validator-client-service", "committedDate": "2020-03-31T22:49:44Z", "type": "commit"}, {"oid": "c656dab491839c800cd5b9ca6c17bcbebb5a47ac", "url": "https://github.com/ConsenSys/teku/commit/c656dab491839c800cd5b9ca6c17bcbebb5a47ac", "message": "Update test.", "committedDate": "2020-03-31T22:54:18Z", "type": "commit"}, {"oid": "8b775504e7fe3e4c94fe5920c280358bd95c8c20", "url": "https://github.com/ConsenSys/teku/commit/8b775504e7fe3e4c94fe5920c280358bd95c8c20", "message": "Extract Duty interface to remove duplication when performing duties.", "committedDate": "2020-03-31T23:01:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2NTEzNQ==", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401265135", "bodyText": "Nice!", "author": "cemozerr", "createdAt": "2020-03-31T23:03:56Z", "path": "validator/client/src/main/java/tech/pegasys/artemis/validator/client/DutyScheduler.java", "diffHunk": "@@ -132,16 +133,17 @@ private void scheduleAttestationProduction(\n \n   @Override\n   public void onBlockProductionDue(final UnsignedLong slot) {\n-    final BlockProductionDuty duty = blockProposalDuties.remove(slot);\n-    if (duty == null) {\n-      return;\n-    }\n-    duty.performDuty();\n+    performDutyForSlot(blockProposalDuties, slot);\n   }\n \n   @Override\n   public void onAttestationCreationDue(final UnsignedLong slot) {\n-    final AttestationProductionDuty duty = attestationProposalDuties.remove(slot);\n+    performDutyForSlot(attestationProposalDuties, slot);\n+  }\n+\n+  public void performDutyForSlot(", "originalCommit": "8b775504e7fe3e4c94fe5920c280358bd95c8c20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}