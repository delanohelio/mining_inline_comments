{"pr_number": 619, "pr_title": "Lifecycle Events V1 [1.15]", "pr_createdAt": "2020-05-12T05:15:00Z", "pr_url": "https://github.com/FabricMC/fabric/pull/619", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNzg4OA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423507888", "bodyText": "Should we still have this in its own separate EVENT class, since it looks like we're going in the direction of having classes that define lots of different events?", "author": "LemmaEOF", "createdAt": "2020-05-12T07:07:11Z", "path": "fabric-generic-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/generic/v1/item/ItemTooltipCallback.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.event.generic.v1.item;\n+\n+import java.util.List;\n+\n+import net.minecraft.client.item.TooltipContext;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.text.Text;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+@Environment(EnvType.CLIENT)\n+public interface ItemTooltipCallback {\n+\t/**\n+\t * Fired after the game has appended all base tooltip lines to the list.\n+\t */\n+\tEvent<ItemTooltipCallback> EVENT = EventFactory.createArrayBacked(ItemTooltipCallback.class, callbacks -> (stack, context, lines) -> {", "originalCommit": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxMTE5MQ==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423511191", "bodyText": "Then again, a majority of the events in the API still follow that EVENT rule. Due to the fact there are references to client types, I couldn't easily do a EntityUnloadCallback.CLIENT/SERVER without classloader issues. The other route was double the amount of interfaces in the api", "author": "i509VCB", "createdAt": "2020-05-12T07:13:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNzg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2MTM0Ng==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423561346", "bodyText": "Imo for that you can do EntityUnloadCallback and ClientEvents.ENTITY_UNLOAD where\nEntityUnloadCallback ENTITY_UNLOAD = EventFactory.createArrayBacked(xxx); in ClientEvents class", "author": "liach", "createdAt": "2020-05-12T08:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNzg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2MTc2Mg==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423561762", "bodyText": "Also how is this a \"generic event\"?", "author": "liach", "createdAt": "2020-05-12T08:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNzg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwMjgzOA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423902838", "bodyText": "Yes, it is not really a generic event. But the item tooltip stuff is surely not lifecycle by any metric.\nI'd say it makes more sense in an item module but this is temporary", "author": "i509VCB", "createdAt": "2020-05-12T17:18:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNzg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2MjYzMg==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423562632", "bodyText": "any point of getting the profiler before the profiler enabled check?", "author": "liach", "createdAt": "2020-05-12T08:40:07Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/lifecycle/v1/ClientLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.event.lifecycle.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameTickCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ClientLifecycleEvents {\n+\tprivate ClientLifecycleEvents() {\n+\t}\n+\n+\tpublic static final Event<GameTickCallback<MinecraftClient>> CLIENT_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> client -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftClient> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(client);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftClient> event : callbacks) {\n+\t\t\t\tevent.onTick(client);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<WorldTickCallback<ClientWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientWorldTick\");\n+\n+\t\t\tfor (WorldTickCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (WorldTickCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<ChunkLoadCallback<ClientWorld>> CHUNK_LOAD = EventFactory.createArrayBacked(ChunkLoadCallback.class, callbacks -> (clientWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tProfiler profiler = clientWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientChunkLoad\");\n+\n+\t\t\tfor (ChunkLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkLoad(clientWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkLoad(clientWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<ChunkUnloadCallback<ClientWorld>> CHUNK_UNLOAD = EventFactory.createArrayBacked(ChunkUnloadCallback.class, callbacks -> (clientWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tProfiler profiler = clientWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientChunkUnload\");\n+\n+\t\t\tfor (ChunkUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkUnload(clientWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkUnload(clientWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<BlockEntityLoadCallback<ClientWorld>> BLOCK_ENTITY_LOAD = EventFactory.createArrayBacked(BlockEntityLoadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tfinal Profiler profiler = world.getProfiler();\n+\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tprofiler.push(\"fabricClientBlockEntityLoad\");\n+\n+\t\t\tfor (BlockEntityLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<BlockEntityUnloadCallback<ClientWorld>> BLOCK_ENTITY_UNLOAD = EventFactory.createArrayBacked(BlockEntityUnloadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tfinal Profiler profiler = world.getProfiler();", "originalCommit": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwMzYwNA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423903604", "bodyText": "Really nothing. Just wanted to throw the profiler into the variable stack and forget about it. I'll probably move it into the if block", "author": "i509VCB", "createdAt": "2020-05-12T17:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2MjYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA0NDEzMA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r424044130", "bodyText": "All the profiler calls should be within the isProfilingEnabled block now", "author": "i509VCB", "createdAt": "2020-05-12T21:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2MjYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2MzAyMQ==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423563021", "bodyText": "yes, you do it like this, only get profiler after the isProfilingEnabled check", "author": "liach", "createdAt": "2020-05-12T08:40:41Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+import net.minecraft.server.MinecraftServer;\n+import net.minecraft.server.world.ServerWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+\n+public final class ServerLifecycleEvents {\n+\tprivate ServerLifecycleEvents() {\n+\t}\n+\n+\tpublic static final Event<GameTickCallback<MinecraftServer>> SERVER_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> server -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = server.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(server);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tevent.onTick(server);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<WorldTickCallback<ServerWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();", "originalCommit": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NzgzNA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423567834", "bodyText": "Maybe lifecycle?", "author": "liach", "createdAt": "2020-05-12T08:47:50Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleCallback.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+import net.minecraft.server.MinecraftServer;\n+\n+/**\n+ * A callback which is invoked when the server advances in it's lifecycle.\n+ */\n+public interface ServerLifecycleCallback {\n+\tvoid onChangeLifecycle(MinecraftServer server);", "originalCommit": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwNDc3OA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423904778", "bodyText": "Well this means the server's lifecycle stage has changed. onLifecycle is a bit vague it would somewhat correspond to a lifecycle method", "author": "i509VCB", "createdAt": "2020-05-12T17:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NzgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5MTM0OA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423991348", "bodyText": "lifecycle is a verb. It has cycle meaning it is cycling to a next stage.", "author": "liach", "createdAt": "2020-05-12T19:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NzgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU2MDg4NA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r424560884", "bodyText": "Sorry what ? https://www.merriam-webster.com/dictionary/life%20cycle", "author": "Pyrofab", "createdAt": "2020-05-13T16:11:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NzgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMzNzMwOA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r425337308", "bodyText": "Gradle has a lifecycle that is like a info for logging. This current name is acceptable.", "author": "liach", "createdAt": "2020-05-14T18:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NzgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxNTQ1Ng==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423915456", "bodyText": "do we already tick twice per tick for worlds? once for server and once for client?", "author": "shedaniel", "createdAt": "2020-05-12T17:39:19Z", "path": "fabric-events-lifecycle-v0/src/main/java/net/fabricmc/fabric/impl/event/lifecycle/client/LegacyClientEventInvokers.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.event.lifecycle.client;\n+\n+import net.fabricmc.api.ClientModInitializer;\n+import net.fabricmc.fabric.api.event.client.ClientTickCallback;\n+import net.fabricmc.fabric.api.event.client.ItemTooltipCallback;\n+import net.fabricmc.fabric.api.event.world.WorldTickCallback;\n+import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientLifecycleEvents;\n+\n+public class LegacyClientEventInvokers implements ClientModInitializer {\n+\t@Override\n+\tpublic void onInitializeClient() {\n+\t\t// Allows deprecated events to still be invoked by the newer implementations\n+\t\tClientLifecycleEvents.CLIENT_TICK.register(ClientTickCallback.EVENT.invoker()::tick);\n+\t\tClientLifecycleEvents.WORLD_TICK.register(WorldTickCallback.EVENT.invoker()::tick);", "originalCommit": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkyNzUxOQ==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423927519", "bodyText": "Yes.", "author": "i509VCB", "createdAt": "2020-05-12T17:58:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxNTQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwODYwNw==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423908607", "bodyText": "The invokers of all of the above legacy events are being captured here, which is invalid. That is, for each event here, the value of EVENT.invoker() is only evaluated in this method, where the callback is being registered for the replacement event, and not each time the new event is invoked. The Event class allows the value of invoker() to change when new listeners are registered.\nFor the array-based events which all of fabric API uses, the invoker is updated each time a new listener is registered, which means this will fail to notify any listeners that are registered after this initializer is called.\nThis will have to be changed to evaluate the value of invoker() each time the event is called, probably with an explicit lambda instead of a method reference.", "author": "JamiesWhiteShirt", "createdAt": "2020-05-12T17:28:23Z", "path": "fabric-events-lifecycle-v0/src/main/java/net/fabricmc/fabric/impl/event/lifecycle/client/LegacyClientEventInvokers.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.event.lifecycle.client;\n+\n+import net.fabricmc.api.ClientModInitializer;\n+import net.fabricmc.fabric.api.event.client.ClientTickCallback;\n+import net.fabricmc.fabric.api.event.client.ItemTooltipCallback;\n+import net.fabricmc.fabric.api.event.world.WorldTickCallback;\n+import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientLifecycleEvents;\n+\n+public class LegacyClientEventInvokers implements ClientModInitializer {\n+\t@Override\n+\tpublic void onInitializeClient() {\n+\t\t// Allows deprecated events to still be invoked by the newer implementations\n+\t\tClientLifecycleEvents.CLIENT_TICK.register(ClientTickCallback.EVENT.invoker()::tick);\n+\t\tClientLifecycleEvents.WORLD_TICK.register(WorldTickCallback.EVENT.invoker()::tick);\n+\t\t// This is part of generic events now.\n+\t\tnet.fabricmc.fabric.api.client.event.generic.v1.item.ItemTooltipCallback.EVENT.register(ItemTooltipCallback.EVENT.invoker()::getTooltip);", "originalCommit": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk2MTU3NQ==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423961575", "bodyText": "Changed it to a lambda.", "author": "i509VCB", "createdAt": "2020-05-12T18:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwODYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxNzEyNg==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423917126", "bodyText": "We might want to impose a stricter order for when the SERVER_STOP and ENTITY_UNLOAD/BLOCK_ENTITY_UNLOAD events are called. Let's say a mod registers a listener for both SERVER_STOP and ENTITY_UNLOAD/BLOCK_ENTITY_UNLOAD. Depending on whether the mod gets to register its SERVER_STOP event listener before or after this listener (which may be nondeterministic), it will have its SERVER_STOP event listener called either before or after all the ENTITY_UNLOAD/BLOCK_ENTITY_UNLOAD events are invoked.\nI imagine a mod might use these events to free resources, and might want to use some server-bound resource which is freed when the SERVER_STOP event is called when entities and block entities are unloaded. Having all the entities and block entities unload before the server is unloaded would make the most sense.", "author": "JamiesWhiteShirt", "createdAt": "2020-05-12T17:42:06Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/impl/event/lifecycle/LifecycleInternalListeners.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.event.lifecycle;\n+\n+import java.util.List;\n+\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.server.world.ServerWorld;\n+\n+import net.fabricmc.api.ModInitializer;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.ServerLifecycleEvents;\n+\n+public class LifecycleInternalListeners implements ModInitializer {\n+\t@Override\n+\tpublic void onInitialize() {\n+\t\tServerLifecycleEvents.SERVER_STOP.register(server -> {\n+\t\t\t// We use the server shutdown to unload all entities and block entities so their events are fired.\n+\t\t\tfor (ServerWorld world : server.getWorlds()) {\n+\t\t\t\tfinal List<Entity> entities = world.getEntities(null, entity -> true); // Get every single entity in the world\n+\n+\t\t\t\tfor (Entity entity : entities) {\n+\t\t\t\t\tServerLifecycleEvents.ENTITY_UNLOAD.invoker().onEntityUnload(entity, world);\n+\t\t\t\t}\n+\n+\t\t\t\tfor (BlockEntity blockEntity : world.blockEntities) {\n+\t\t\t\t\tServerLifecycleEvents.BLOCK_ENTITY_UNLOAD.invoker().onUnloadBlockEntity(blockEntity, world);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});", "originalCommit": "f4bfead302a597dc0caba69f9e8f2d62f3218e9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkzNDMzNw==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r423934337", "bodyText": "I could fire that internal listener a bit earlier so all entities would be ublosded before the server stops. However some event listeners may already use the fact not every entity is unloaded during server shutdown themselves, so we would be shooting them in the foot then. I could hook this into the server world being closed so it is garunteed the world no longer will exist, and some what covers custom worlds added by other mods", "author": "i509VCB", "createdAt": "2020-05-12T18:09:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxNzEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzNjUyMA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r424036520", "bodyText": "@JamiesWhiteShirt So I decided to make this case be bound to the closing of the server worlds so events can still work off the old contract where entities were still present on the server", "author": "i509VCB", "createdAt": "2020-05-12T21:12:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxNzEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDA0Mw==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435594043", "bodyText": "These all need more specific documentation, the various ticks all last quite a while. It may even be necessary to have separate events for start and end, e.g. end of world tick may be used to start async computations for the next tick.", "author": "sfPlayer1", "createdAt": "2020-06-04T22:48:33Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/lifecycle/v1/ClientLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.event.lifecycle.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameLifecycleCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameTickCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ClientLifecycleEvents {\n+\tprivate ClientLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a client ticks.", "originalCommit": "3180af925a4e314bf325498692eac40951bb84f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwOTI4OQ==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r436309289", "bodyText": "Added some slight documentation about where the tick events are called. (There are START and END callbacks now)", "author": "i509VCB", "createdAt": "2020-06-06T23:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5ODk1Nw==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435598957", "bodyText": "For load/unload the timing is crucial and should be explained. Ideally all load events occur after the subject has been added to the world/chunk with the world+chunk being normally usable and obtainable via MinecraftServer. This ensures that e.g. an area search can be done without fragile postponing workarounds. Unload should happen while still reachable for similar reasons.\nAdditionally, access to the de-/serialization phases would be useful such that custom data can be embedded in the vanilla nbt tree as it gets read or written. It is useful for persistent data attachments to chunk or world, e.g. to store worldgen metadata for retrogen implementations.", "author": "sfPlayer1", "createdAt": "2020-06-04T23:03:22Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/lifecycle/v1/ClientLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.event.lifecycle.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameLifecycleCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameTickCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ClientLifecycleEvents {\n+\tprivate ClientLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a client ticks.\n+\t */\n+\tpublic static final Event<GameTickCallback<MinecraftClient>> CLIENT_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> client -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftClient> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(client);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftClient> event : callbacks) {\n+\t\t\t\tevent.onTick(client);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a ClientWorld ticks.\n+\t */\n+\tpublic static final Event<WorldTickCallback<ClientWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientWorldTick\");\n+\n+\t\t\tfor (WorldTickCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (WorldTickCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a chunk is loaded into a ClientWorld.", "originalCommit": "3180af925a4e314bf325498692eac40951bb84f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwMDU2OQ==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r436200569", "bodyText": "I've had a discussion on discord related to a Save/LoadEntityDataCallback and the concenus was it isn't very useful unless we have a way to attach data to an entity (via something like CCA) or mixin to said entity to access the data you wish to store.", "author": "i509VCB", "createdAt": "2020-06-05T23:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5ODk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5OTI5NQ==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435599295", "bodyText": "These lack documentation, not sure what they are supposed to do?", "author": "sfPlayer1", "createdAt": "2020-06-04T23:04:24Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/lifecycle/v1/ClientLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.event.lifecycle.v1;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameLifecycleCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.GameTickCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+\n+@Environment(EnvType.CLIENT)\n+public final class ClientLifecycleEvents {\n+\tprivate ClientLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a client ticks.\n+\t */\n+\tpublic static final Event<GameTickCallback<MinecraftClient>> CLIENT_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> client -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = client.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftClient> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(client);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftClient> event : callbacks) {\n+\t\t\t\tevent.onTick(client);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a ClientWorld ticks.\n+\t */\n+\tpublic static final Event<WorldTickCallback<ClientWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientWorldTick\");\n+\n+\t\t\tfor (WorldTickCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (WorldTickCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a chunk is loaded into a ClientWorld.\n+\t */\n+\tpublic static final Event<ChunkLoadCallback<ClientWorld>> CHUNK_LOAD = EventFactory.createArrayBacked(ChunkLoadCallback.class, callbacks -> (clientWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tProfiler profiler = clientWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientChunkLoad\");\n+\n+\t\t\tfor (ChunkLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkLoad(clientWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkLoad(clientWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a chunk is unloaded from a ClientWorld.\n+\t */\n+\tpublic static final Event<ChunkUnloadCallback<ClientWorld>> CHUNK_UNLOAD = EventFactory.createArrayBacked(ChunkUnloadCallback.class, callbacks -> (clientWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = clientWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientChunkUnload\");\n+\n+\t\t\tfor (ChunkUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkUnload(clientWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkUnload(clientWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a BlockEntity is loaded into a ClientWorld.\n+\t */\n+\tpublic static final Event<BlockEntityLoadCallback<ClientWorld>> BLOCK_ENTITY_LOAD = EventFactory.createArrayBacked(BlockEntityLoadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientBlockEntityLoad\");\n+\n+\t\t\tfor (BlockEntityLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a BlockEntity is unloaded from a ClientWorld.\n+\t */\n+\tpublic static final Event<BlockEntityUnloadCallback<ClientWorld>> BLOCK_ENTITY_UNLOAD = EventFactory.createArrayBacked(BlockEntityUnloadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientBlockEntityUnload\");\n+\n+\t\t\tfor (BlockEntityUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an Entity is loaded into a ClientWorld.\n+\t */\n+\tpublic static final Event<EntityLoadCallback<ClientWorld>> ENTITY_LOAD = EventFactory.createArrayBacked(EntityLoadCallback.class, callbacks -> (entity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientEntityLoad\");\n+\n+\t\t\tfor (EntityLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (EntityLoadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an Entity is unloaded from a ClientWorld.\n+\t */\n+\tpublic static final Event<EntityUnloadCallback<ClientWorld>> ENTITY_UNLOAD = EventFactory.createArrayBacked(EntityUnloadCallback.class, callbacks -> (entity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricClientEntityLoad\");\n+\n+\t\t\tfor (EntityUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onEntityUnload(entity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (EntityUnloadCallback<ClientWorld> callback : callbacks) {\n+\t\t\t\tcallback.onEntityUnload(entity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\tpublic static final Event<GameLifecycleCallback<MinecraftClient>> CLIENT_STARTING = EventFactory.createArrayBacked(GameLifecycleCallback.class, callbacks -> client -> {", "originalCommit": "3180af925a4e314bf325498692eac40951bb84f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMDY0MA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435600640", "bodyText": "I'd use two instances without generics for ease of use. It may be worthwhile to organize the events+callbacks differently, maybe an outer class like ClientTickEvents that holds both the event fields and callbacks as nested classes? Similar for others, ClientLifecycleEvents is getting big and the many trivial top level callback interfaces are getting a bit too spread out.", "author": "sfPlayer1", "createdAt": "2020-06-04T23:08:53Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/GameLifecycleCallback.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+/**\n+ * A callback which is invoked when the game's engine advances in it's lifecycle.\n+ */\n+public interface GameLifecycleCallback<T> {", "originalCommit": "3180af925a4e314bf325498692eac40951bb84f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwMDI3MA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r436200270", "bodyText": "I've split up the Client/ServerLifecycleEvents into more specific classes.\nBecause of the split, at most these more specific classes (So there is a ClientTickEvents.World and ServerTickEvents.World) now only hold 2-3 inner classes for the interfaces for event listeners implement.", "author": "i509VCB", "createdAt": "2020-06-05T23:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMDY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMTAxNQ==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435601015", "bodyText": "Same with this generic parameter, also avoids implementing e.g. chunk+world tick handlers in the same class.", "author": "sfPlayer1", "createdAt": "2020-06-04T23:10:09Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/GameTickCallback.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+public interface GameTickCallback<T> {\n+\tvoid onTick(T game);", "originalCommit": "3180af925a4e314bf325498692eac40951bb84f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMTM1Mw==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435601353", "bodyText": "\".. and it is about to tick for the first time\" maybe? assuming that's correct?", "author": "sfPlayer1", "createdAt": "2020-06-04T23:11:11Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+import net.minecraft.server.MinecraftServer;\n+import net.minecraft.server.world.ServerWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+import net.fabricmc.fabric.impl.lifecycle.ServerLifecycleInternals;\n+\n+public final class ServerLifecycleEvents {\n+\tprivate ServerLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a server ticks.\n+\t */\n+\tpublic static final Event<GameTickCallback<MinecraftServer>> SERVER_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> server -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = server.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(server);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tevent.onTick(server);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a ServerWorld ticks.\n+\t */\n+\tpublic static final Event<WorldTickCallback<ServerWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerWorldTick_\" + world.dimension.getType().toString());\n+\n+\t\t\tfor (WorldTickCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (WorldTickCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an chunk is loaded into a ServerWorld.\n+\t */\n+\tpublic static final Event<ChunkLoadCallback<ServerWorld>> CHUNK_LOAD = EventFactory.createArrayBacked(ChunkLoadCallback.class, callbacks -> (serverWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = serverWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerChunkLoad\");\n+\n+\t\t\tfor (ChunkLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkLoad(serverWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkLoad(serverWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an chunk is unloaded from a ServerWorld.\n+\t */\n+\tpublic static final Event<ChunkUnloadCallback<ServerWorld>> CHUNK_UNLOAD = EventFactory.createArrayBacked(ChunkUnloadCallback.class, callbacks -> (serverWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = serverWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerChunkUnload\");\n+\n+\t\t\tfor (ChunkUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkUnload(serverWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkUnload(serverWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an BlockEntity is loaded into a ServerWorld.\n+\t */\n+\tpublic static final Event<BlockEntityLoadCallback<ServerWorld>> BLOCK_ENTITY_LOAD = EventFactory.createArrayBacked(BlockEntityLoadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerBlockEntityLoad\");\n+\n+\t\t\tfor (BlockEntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an BlockEntity is unloaded from a ServerWorld.\n+\t */\n+\tpublic static final Event<BlockEntityUnloadCallback<ServerWorld>> BLOCK_ENTITY_UNLOAD = EventFactory.createArrayBacked(BlockEntityUnloadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerBlockEntityUnload\");\n+\n+\t\t\tfor (BlockEntityUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an Entity is loaded into a ServerWorld.\n+\t *\n+\t * <p>Note there is no corresponding unload event because entity unloads cannot be reliably tracked.\n+\t */\n+\tpublic static final Event<EntityLoadCallback<ServerWorld>> ENTITY_LOAD = EventFactory.createArrayBacked(EntityLoadCallback.class, callbacks -> (entity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerEntityLoad\");\n+\n+\t\t\tfor (EntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (EntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when the server has started. At this stage, all worlds are live.", "originalCommit": "3180af925a4e314bf325498692eac40951bb84f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMTk4Mg==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435601982", "bodyText": "This could clarify what stopping means, especially with the client having a less permanent stop (in a way).", "author": "sfPlayer1", "createdAt": "2020-06-04T23:13:10Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+import net.minecraft.server.MinecraftServer;\n+import net.minecraft.server.world.ServerWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+import net.fabricmc.fabric.impl.lifecycle.ServerLifecycleInternals;\n+\n+public final class ServerLifecycleEvents {\n+\tprivate ServerLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a server ticks.\n+\t */\n+\tpublic static final Event<GameTickCallback<MinecraftServer>> SERVER_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> server -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = server.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(server);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tevent.onTick(server);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a ServerWorld ticks.\n+\t */\n+\tpublic static final Event<WorldTickCallback<ServerWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerWorldTick_\" + world.dimension.getType().toString());\n+\n+\t\t\tfor (WorldTickCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (WorldTickCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an chunk is loaded into a ServerWorld.\n+\t */\n+\tpublic static final Event<ChunkLoadCallback<ServerWorld>> CHUNK_LOAD = EventFactory.createArrayBacked(ChunkLoadCallback.class, callbacks -> (serverWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = serverWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerChunkLoad\");\n+\n+\t\t\tfor (ChunkLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkLoad(serverWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkLoad(serverWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an chunk is unloaded from a ServerWorld.\n+\t */\n+\tpublic static final Event<ChunkUnloadCallback<ServerWorld>> CHUNK_UNLOAD = EventFactory.createArrayBacked(ChunkUnloadCallback.class, callbacks -> (serverWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = serverWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerChunkUnload\");\n+\n+\t\t\tfor (ChunkUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkUnload(serverWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkUnload(serverWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an BlockEntity is loaded into a ServerWorld.\n+\t */\n+\tpublic static final Event<BlockEntityLoadCallback<ServerWorld>> BLOCK_ENTITY_LOAD = EventFactory.createArrayBacked(BlockEntityLoadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerBlockEntityLoad\");\n+\n+\t\t\tfor (BlockEntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an BlockEntity is unloaded from a ServerWorld.\n+\t */\n+\tpublic static final Event<BlockEntityUnloadCallback<ServerWorld>> BLOCK_ENTITY_UNLOAD = EventFactory.createArrayBacked(BlockEntityUnloadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerBlockEntityUnload\");\n+\n+\t\t\tfor (BlockEntityUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an Entity is loaded into a ServerWorld.\n+\t *\n+\t * <p>Note there is no corresponding unload event because entity unloads cannot be reliably tracked.\n+\t */\n+\tpublic static final Event<EntityLoadCallback<ServerWorld>> ENTITY_LOAD = EventFactory.createArrayBacked(EntityLoadCallback.class, callbacks -> (entity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerEntityLoad\");\n+\n+\t\t\tfor (EntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (EntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when the server has started. At this stage, all worlds are live.\n+\t */\n+\tpublic static final Event<GameLifecycleCallback<MinecraftServer>> SERVER_STARTED = EventFactory.createArrayBacked(GameLifecycleCallback.class, (callbacks) -> (server) -> {\n+\t\tfor (GameLifecycleCallback<MinecraftServer> callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when the server has started stopping. All worlds are still present.", "originalCommit": "3180af925a4e314bf325498692eac40951bb84f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjYzNA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r435602634", "bodyText": "While this is useful and sometimes not truly avoidable, I am not sure if we want to reinforce the notion that there's only one server. There should at least be a strong recommendation to always use world.getServer and other context specific approaches instead.", "author": "sfPlayer1", "createdAt": "2020-06-04T23:15:31Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+import net.minecraft.server.MinecraftServer;\n+import net.minecraft.server.world.ServerWorld;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.block.entity.BlockEntityUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.chunk.ChunkUnloadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.entity.EntityLoadCallback;\n+import net.fabricmc.fabric.api.event.lifecycle.v1.world.WorldTickCallback;\n+import net.fabricmc.fabric.impl.lifecycle.ServerLifecycleInternals;\n+\n+public final class ServerLifecycleEvents {\n+\tprivate ServerLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a server ticks.\n+\t */\n+\tpublic static final Event<GameTickCallback<MinecraftServer>> SERVER_TICK = EventFactory.createArrayBacked(GameTickCallback.class, callbacks -> server -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = server.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerTick\");\n+\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(event));\n+\t\t\t\tevent.onTick(server);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (GameTickCallback<MinecraftServer> event : callbacks) {\n+\t\t\t\tevent.onTick(server);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a ServerWorld ticks.\n+\t */\n+\tpublic static final Event<WorldTickCallback<ServerWorld>> WORLD_TICK = EventFactory.createArrayBacked(WorldTickCallback.class, callbacks -> world -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerWorldTick_\" + world.dimension.getType().toString());\n+\n+\t\t\tfor (WorldTickCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (WorldTickCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onTick(world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an chunk is loaded into a ServerWorld.\n+\t */\n+\tpublic static final Event<ChunkLoadCallback<ServerWorld>> CHUNK_LOAD = EventFactory.createArrayBacked(ChunkLoadCallback.class, callbacks -> (serverWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = serverWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerChunkLoad\");\n+\n+\t\t\tfor (ChunkLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkLoad(serverWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkLoad(serverWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an chunk is unloaded from a ServerWorld.\n+\t */\n+\tpublic static final Event<ChunkUnloadCallback<ServerWorld>> CHUNK_UNLOAD = EventFactory.createArrayBacked(ChunkUnloadCallback.class, callbacks -> (serverWorld, chunk) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = serverWorld.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerChunkUnload\");\n+\n+\t\t\tfor (ChunkUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onChunkUnload(serverWorld, chunk);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (ChunkUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onChunkUnload(serverWorld, chunk);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an BlockEntity is loaded into a ServerWorld.\n+\t */\n+\tpublic static final Event<BlockEntityLoadCallback<ServerWorld>> BLOCK_ENTITY_LOAD = EventFactory.createArrayBacked(BlockEntityLoadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerBlockEntityLoad\");\n+\n+\t\t\tfor (BlockEntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onLoadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an BlockEntity is unloaded from a ServerWorld.\n+\t */\n+\tpublic static final Event<BlockEntityUnloadCallback<ServerWorld>> BLOCK_ENTITY_UNLOAD = EventFactory.createArrayBacked(BlockEntityUnloadCallback.class, callbacks -> (blockEntity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerBlockEntityUnload\");\n+\n+\t\t\tfor (BlockEntityUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (BlockEntityUnloadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onUnloadBlockEntity(blockEntity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when an Entity is loaded into a ServerWorld.\n+\t *\n+\t * <p>Note there is no corresponding unload event because entity unloads cannot be reliably tracked.\n+\t */\n+\tpublic static final Event<EntityLoadCallback<ServerWorld>> ENTITY_LOAD = EventFactory.createArrayBacked(EntityLoadCallback.class, callbacks -> (entity, world) -> {\n+\t\tif (EventFactory.isProfilingEnabled()) {\n+\t\t\tfinal Profiler profiler = world.getProfiler();\n+\t\t\tprofiler.push(\"fabricServerEntityLoad\");\n+\n+\t\t\tfor (EntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tprofiler.push(EventFactory.getHandlerName(callback));\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t\tprofiler.pop();\n+\t\t\t}\n+\n+\t\t\tprofiler.pop();\n+\t\t} else {\n+\t\t\tfor (EntityLoadCallback<ServerWorld> callback : callbacks) {\n+\t\t\t\tcallback.onEntityLoad(entity, world);\n+\t\t\t}\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when the server has started. At this stage, all worlds are live.\n+\t */\n+\tpublic static final Event<GameLifecycleCallback<MinecraftServer>> SERVER_STARTED = EventFactory.createArrayBacked(GameLifecycleCallback.class, (callbacks) -> (server) -> {\n+\t\tfor (GameLifecycleCallback<MinecraftServer> callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when the server has started stopping. All worlds are still present.\n+\t */\n+\tpublic static final Event<GameLifecycleCallback<MinecraftServer>> SERVER_STOPPING = EventFactory.createArrayBacked(GameLifecycleCallback.class, (callbacks) -> (server) -> {\n+\t\tfor (GameLifecycleCallback<MinecraftServer> callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when the server has stopped. All worlds have been closed and all (block)entities and players have been unloaded.\n+\t */\n+\tpublic static final Event<GameLifecycleCallback<MinecraftServer>> SERVER_STOPPED = EventFactory.createArrayBacked(GameLifecycleCallback.class, callbacks -> server -> {\n+\t\tfor (GameLifecycleCallback<MinecraftServer> callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Gets the currently running server.\n+\t *\n+\t * <p>The server instance returned SHOULD NOT be cached! Call the method every time you need the server.\n+\t *\n+\t * @return the currently running server\n+\t * @throws IllegalStateException if the server is not available\n+\t */\n+\tpublic static MinecraftServer getCurrentServer() {", "originalCommit": "3180af925a4e314bf325498692eac40951bb84f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyNTA1NA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r436025054", "bodyText": "Yea that is precisely why I did stage this addition to one commit incase it was unpopular. The documentation would be nice to have about reccomending getting the server from the ServerWorld.\nInternally this will optionally get the depending on a client or server. Which you can look at in impl packages.", "author": "i509VCB", "createdAt": "2020-06-05T16:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjYzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwNzA0NQ==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r436307045", "bodyText": "Hmm, I think this might getPrimaryServer might be a better name since we don't assume one server exists. I've added some docs explaining how it's use is discouraged.", "author": "i509VCB", "createdAt": "2020-06-06T22:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwMjYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMwOTI4Nw==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r436309287", "bodyText": "just do @Deprecated", "author": "liach", "createdAt": "2020-06-06T23:43:40Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleEvents.java", "diffHunk": "@@ -61,17 +61,17 @@ private ServerLifecycleEvents() {\n \t});\n \n \t/**\n-\t * Gets the currently running server.\n+\t * Gets the currently running primary server.\n \t *\n-\t * <p><b>Use of this method is highly impractical and not recommended since there is no real restriction on whether the game engine could run multiple servers concurrently.</b>\n+\t * <p><b>Use of this method is highly discouraged and not recommended since there is no real restriction on whether the game engine could run multiple servers concurrently.</b>", "originalCommit": "d9dcda0789f23b4df8b2da290ead333af2a93217", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNjQ1Nw==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r440506457", "bodyText": "After thinking a bit, I am going to drop these methods.", "author": "i509VCB", "createdAt": "2020-06-15T23:46:01Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/event/lifecycle/v1/ServerLifecycleEvents.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.event.lifecycle.v1;\n+\n+import net.minecraft.server.MinecraftServer;\n+import net.minecraft.server.world.ServerWorld;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.impl.lifecycle.ServerLifecycleInternals;\n+\n+public final class ServerLifecycleEvents {\n+\tprivate ServerLifecycleEvents() {\n+\t}\n+\n+\t/**\n+\t * Called when a Minecraft server has started and is about to tick for the first time.\n+\t *\n+\t * <p>At this stage, all worlds are live.\n+\t */\n+\tpublic static final Event<ServerLifecycleEvents.LifecycleCallback> SERVER_STARTED = EventFactory.createArrayBacked(ServerLifecycleEvents.LifecycleCallback.class, (callbacks) -> (server) -> {\n+\t\tfor (ServerLifecycleEvents.LifecycleCallback callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a Minecraft server has started shutting down.\n+\t * This occurs before the server's network channel is closed and before any players are disconnected.\n+\t *\n+\t * <p>For example, an integrated server will begin stopping, but it's client may continue to run.\n+\t *\n+\t * <p>All worlds are still present and can be modified.\n+\t */\n+\tpublic static final Event<ServerLifecycleEvents.LifecycleCallback> SERVER_STOPPING = EventFactory.createArrayBacked(ServerLifecycleEvents.LifecycleCallback.class, (callbacks) -> (server) -> {\n+\t\tfor (ServerLifecycleEvents.LifecycleCallback callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called when a Minecraft server has stopped.\n+\t * All worlds have been closed and all (block)entities and players have been unloaded.\n+\t *\n+\t * <p>For example, an {@link net.fabricmc.api.EnvType#CLIENT integrated server} will begin stopping, but it's client may continue to run.\n+\t * Meanwhile for a {@link net.fabricmc.api.EnvType#SERVER dedicated server}, this will be the last event called.\n+\t */\n+\tpublic static final Event<ServerLifecycleEvents.LifecycleCallback> SERVER_STOPPED = EventFactory.createArrayBacked(ServerLifecycleEvents.LifecycleCallback.class, callbacks -> server -> {\n+\t\tfor (ServerLifecycleEvents.LifecycleCallback callback : callbacks) {\n+\t\t\tcallback.onChangeLifecycle(server);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Gets the currently running primary server.\n+\t *\n+\t * <p><b>Use of this method is highly discouraged and not recommended since there is no real restriction on whether the game engine could run multiple servers concurrently.</b>\n+\t * One should attempt to obtain the server instance from a {@link ServerWorld server world} or via other means.\n+\t *\n+\t * <p>The server instance returned SHOULD NOT be cached! Call the method every time you need the server.\n+\t *\n+\t * @return the currently running server\n+\t * @throws IllegalStateException if the server is not available\n+\t */\n+\t@Deprecated\n+\tpublic static MinecraftServer getPrimaryServer() {", "originalCommit": "046fa8ca53afe6a2d2e837cf9a44fe235d7f58f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzNDEwMg==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r440534102", "bodyText": "Please do.", "author": "liach", "createdAt": "2020-06-16T01:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNjQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU4NDA2MA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r440584060", "bodyText": "And it's out", "author": "i509VCB", "createdAt": "2020-06-16T04:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNjQ1Nw=="}], "type": "inlineReview"}, {"oid": "c4b25c4552e6ded3eedbabd02d999fd8731d92f6", "url": "https://github.com/FabricMC/fabric/commit/c4b25c4552e6ded3eedbabd02d999fd8731d92f6", "message": "Lifecycle Events V1\n\nNow includes Chunk and (Block)Entity (un)load events", "committedDate": "2020-06-16T02:39:44Z", "type": "commit"}, {"oid": "1367a39e53949a907a69e30adb860854e935fdf5", "url": "https://github.com/FabricMC/fabric/commit/1367a39e53949a907a69e30adb860854e935fdf5", "message": "Add some tests to verify worlds are ticking in the log", "committedDate": "2020-06-16T02:39:44Z", "type": "commit"}, {"oid": "8fa596bc50ff3958e5dfabc7be503d72e7fce366", "url": "https://github.com/FabricMC/fabric/commit/8fa596bc50ff3958e5dfabc7be503d72e7fce366", "message": "Lambda boogaloo", "committedDate": "2020-06-16T02:39:44Z", "type": "commit"}, {"oid": "b3ad317ace70e240775ab86c428119fb86135ada", "url": "https://github.com/FabricMC/fabric/commit/b3ad317ace70e240775ab86c428119fb86135ada", "message": "Add some docs. Distinguish between a server starting to stop and server which has stopped.", "committedDate": "2020-06-16T02:39:45Z", "type": "commit"}, {"oid": "500a72e8e83c914b39f3755bc2fac815737c4fba", "url": "https://github.com/FabricMC/fabric/commit/500a72e8e83c914b39f3755bc2fac815737c4fba", "message": "Split up test mods, some tweaks to (block)entity (un)load events.\n\nBind the ServerWorld being closed during shutdown to unload (block)entities.", "committedDate": "2020-06-16T02:39:45Z", "type": "commit"}, {"oid": "a9c22feecdc6fe638b9340609cb416aa173913c6", "url": "https://github.com/FabricMC/fabric/commit/a9c22feecdc6fe638b9340609cb416aa173913c6", "message": "Shift around a few profiler variables and finalize", "committedDate": "2020-06-16T02:39:45Z", "type": "commit"}, {"oid": "33a92e87c85da8e7730f5b7b0d55e8963f4dab6f", "url": "https://github.com/FabricMC/fabric/commit/33a92e87c85da8e7730f5b7b0d55e8963f4dab6f", "message": "Complete the tests, Block entities on server should be reliably tracked now.\n\nEntities on the server obviously still need to be wrangled.", "committedDate": "2020-06-16T02:39:45Z", "type": "commit"}, {"oid": "afa3483bad1b4bc3e5fe3c7985d9517878d8c6e5", "url": "https://github.com/FabricMC/fabric/commit/afa3483bad1b4bc3e5fe3c7985d9517878d8c6e5", "message": "Drop Server Entity Unload callback.\n\nBelieve me, this was a hard decision but it stands on the fact that about 20-40% of entities silently unload without going through the proper \"unloadEntity\" method in ServerWorld. No amount of debug hacks, double tracking unload events and even replacing the entity maps do not fix this issue. So I have decided to drop this from the feature set.", "committedDate": "2020-06-16T02:39:45Z", "type": "commit"}, {"oid": "e2f7c9f7fda2a4ceb7617d77462c2503bbd62c4a", "url": "https://github.com/FabricMC/fabric/commit/e2f7c9f7fda2a4ceb7617d77462c2503bbd62c4a", "message": "checkstyle", "committedDate": "2020-06-16T02:39:45Z", "type": "commit"}, {"oid": "c0c4f00ada859be89a4e3395609e15ff26c1d44a", "url": "https://github.com/FabricMC/fabric/commit/c0c4f00ada859be89a4e3395609e15ff26c1d44a", "message": "generic-events -> item-api", "committedDate": "2020-06-16T02:39:47Z", "type": "commit"}, {"oid": "c78c53c1c27dbe8439f4c91b5b08cdd09e577b71", "url": "https://github.com/FabricMC/fabric/commit/c78c53c1c27dbe8439f4c91b5b08cdd09e577b71", "message": "Server start -> Server started", "committedDate": "2020-06-16T02:39:47Z", "type": "commit"}, {"oid": "4c15b7d1e9f6dd82a5ec5b043c0d3b8247fc2a7c", "url": "https://github.com/FabricMC/fabric/commit/4c15b7d1e9f6dd82a5ec5b043c0d3b8247fc2a7c", "message": "Allow getting current server from Lifecycle\n\nPeople have asked for this, but it is not encouraged for obvious reasons. Should be staged well enough to revert if we decide to.", "committedDate": "2020-06-16T02:39:47Z", "type": "commit"}, {"oid": "203d95884f06030d5d25c807782ff5d6503199dc", "url": "https://github.com/FabricMC/fabric/commit/203d95884f06030d5d25c807782ff5d6503199dc", "message": "checkstyle lol", "committedDate": "2020-06-16T02:39:47Z", "type": "commit"}, {"oid": "fe4803963f26946682017f9d36898c05f8c42258", "url": "https://github.com/FabricMC/fabric/commit/fe4803963f26946682017f9d36898c05f8c42258", "message": "update injection name", "committedDate": "2020-06-16T02:39:47Z", "type": "commit"}, {"oid": "5acbe34ea600c0b6c37af73670984f342e9f7f95", "url": "https://github.com/FabricMC/fabric/commit/5acbe34ea600c0b6c37af73670984f342e9f7f95", "message": "Checkstyle lol: Redundant modifiers", "committedDate": "2020-06-16T02:39:47Z", "type": "commit"}, {"oid": "2c2780026c3b5cd0c0d744f88bd3c727135da2b4", "url": "https://github.com/FabricMC/fabric/commit/2c2780026c3b5cd0c0d744f88bd3c727135da2b4", "message": "Add client starting, stopping and stopped callbacks.", "committedDate": "2020-06-16T02:39:48Z", "type": "commit"}, {"oid": "53c4e71c3bec6de4a828652ec85f5c4df6718d50", "url": "https://github.com/FabricMC/fabric/commit/53c4e71c3bec6de4a828652ec85f5c4df6718d50", "message": "Loicenses", "committedDate": "2020-06-16T02:39:48Z", "type": "commit"}, {"oid": "ae655e5275f5492b75279943a05475c186055d2d", "url": "https://github.com/FabricMC/fabric/commit/ae655e5275f5492b75279943a05475c186055d2d", "message": "Reorganize so each event category has it's own class.\n\nAlso this collapses the pretty widely reaching interfaces into more specific inner classes to avoid issues with generics.", "committedDate": "2020-06-16T02:39:48Z", "type": "commit"}, {"oid": "e4579679f02d43dbf5210ac0dc17eb8b96a2f166", "url": "https://github.com/FabricMC/fabric/commit/e4579679f02d43dbf5210ac0dc17eb8b96a2f166", "message": "Some docs and slight name changes", "committedDate": "2020-06-16T02:39:48Z", "type": "commit"}, {"oid": "030a5095cf57f51ed424561bf8e6acca5b013251", "url": "https://github.com/FabricMC/fabric/commit/030a5095cf57f51ed424561bf8e6acca5b013251", "message": "Add start tick callbacks to worlds, server and client", "committedDate": "2020-06-16T02:39:48Z", "type": "commit"}, {"oid": "0a4d752cf8cbbf2b2e05a53900cd6d41087122a5", "url": "https://github.com/FabricMC/fabric/commit/0a4d752cf8cbbf2b2e05a53900cd6d41087122a5", "message": "Enhance some client related docs to life cycle", "committedDate": "2020-06-16T02:39:48Z", "type": "commit"}, {"oid": "628d4a41e95ec9a419e02883b59da8fda04f8c2b", "url": "https://github.com/FabricMC/fabric/commit/628d4a41e95ec9a419e02883b59da8fda04f8c2b", "message": "Deprecate for reasons of discouraging singletonish server getter methods in lifecycle", "committedDate": "2020-06-16T02:39:48Z", "type": "commit"}, {"oid": "34b3c3c85fb8c8ca2ebce51b1899c610a096704e", "url": "https://github.com/FabricMC/fabric/commit/34b3c3c85fb8c8ca2ebce51b1899c610a096704e", "message": "Add some description related to integrated server on server stopping.", "committedDate": "2020-06-16T02:39:48Z", "type": "commit"}, {"oid": "abf04bfafd3d900a4a04e7e9851c0df27a0ee79f", "url": "https://github.com/FabricMC/fabric/commit/abf04bfafd3d900a4a04e7e9851c0df27a0ee79f", "message": "Add small test to verify tick starts are right spot of load", "committedDate": "2020-06-16T02:39:48Z", "type": "commit"}, {"oid": "77ee4ab8e8ec24e6587664c7a727dedb18474955", "url": "https://github.com/FabricMC/fabric/commit/77ee4ab8e8ec24e6587664c7a727dedb18474955", "message": "Docs and a tiny bit more testing.", "committedDate": "2020-06-16T02:39:49Z", "type": "commit"}, {"oid": "90dbb2c4e235b2eb06eba840081ae4c9b1313df0", "url": "https://github.com/FabricMC/fabric/commit/90dbb2c4e235b2eb06eba840081ae4c9b1313df0", "message": "Try clarifying client docs", "committedDate": "2020-06-16T02:39:49Z", "type": "commit"}, {"oid": "d25c6b16b8d4e00888a9750b3b1b2af3ce9f1e53", "url": "https://github.com/FabricMC/fabric/commit/d25c6b16b8d4e00888a9750b3b1b2af3ce9f1e53", "message": "Drop a slightly unnessecary event", "committedDate": "2020-06-16T02:39:49Z", "type": "commit"}, {"oid": "0b884f022df534a3efe69f0a1e662635c290c085", "url": "https://github.com/FabricMC/fabric/commit/0b884f022df534a3efe69f0a1e662635c290c085", "message": "Actually call and implement START_SERVER_TICK event", "committedDate": "2020-06-16T02:39:49Z", "type": "commit"}, {"oid": "6599a110201a0a482003e3d652bc9e6d08046ba4", "url": "https://github.com/FabricMC/fabric/commit/6599a110201a0a482003e3d652bc9e6d08046ba4", "message": "Remove non-existent test", "committedDate": "2020-06-16T02:39:49Z", "type": "commit"}, {"oid": "15c3bccb6d790937ba470d2979356883275bd7c4", "url": "https://github.com/FabricMC/fabric/commit/15c3bccb6d790937ba470d2979356883275bd7c4", "message": "again", "committedDate": "2020-06-16T02:39:49Z", "type": "commit"}, {"oid": "8c187dd160015b7a4e689f6990c94228a959a7d2", "url": "https://github.com/FabricMC/fabric/commit/8c187dd160015b7a4e689f6990c94228a959a7d2", "message": "Refer to minecraft itself in client lifecycle docs", "committedDate": "2020-06-16T02:39:49Z", "type": "commit"}, {"oid": "ff486728a95e09cfec0bd43c33985cb1646650ba", "url": "https://github.com/FabricMC/fabric/commit/ff486728a95e09cfec0bd43c33985cb1646650ba", "message": "Refer to Minecraft itself within ServerLifecycleEvents", "committedDate": "2020-06-16T02:39:49Z", "type": "commit"}, {"oid": "ff486728a95e09cfec0bd43c33985cb1646650ba", "url": "https://github.com/FabricMC/fabric/commit/ff486728a95e09cfec0bd43c33985cb1646650ba", "message": "Refer to Minecraft itself within ServerLifecycleEvents", "committedDate": "2020-06-16T02:39:49Z", "type": "forcePushed"}, {"oid": "c84f36209d0072ab9c4083c0bf111917720d54e1", "url": "https://github.com/FabricMC/fabric/commit/c84f36209d0072ab9c4083c0bf111917720d54e1", "message": "Remove primary server getters", "committedDate": "2020-06-16T04:47:58Z", "type": "commit"}, {"oid": "b226b21df1ad95edf2e381cc180525a37e9d64af", "url": "https://github.com/FabricMC/fabric/commit/b226b21df1ad95edf2e381cc180525a37e9d64af", "message": "IJ DO YOU SPEAK RESOLVING IMPORTS\n\n(cherry picked from commit c9257e8a11d8361469349f4171263121bb111af7)", "committedDate": "2020-06-16T04:52:52Z", "type": "commit"}, {"oid": "a5112223ca4505fb7777b1ef53d3478d0155079d", "url": "https://github.com/FabricMC/fabric/commit/a5112223ca4505fb7777b1ef53d3478d0155079d", "message": "Prune the tests that shouldn't exist", "committedDate": "2020-06-16T06:00:04Z", "type": "commit"}, {"oid": "f708519af80db1cc8297cfc017ffcb47afbf8cca", "url": "https://github.com/FabricMC/fabric/commit/f708519af80db1cc8297cfc017ffcb47afbf8cca", "message": "Listen here checkstyle you bugger\n\n(cherry picked from commit 9701bba4002cec089c9d3738b1f226128078c130)", "committedDate": "2020-06-17T06:33:18Z", "type": "commit"}, {"oid": "3431c0d894309f137f39f288174a5d14c6423cee", "url": "https://github.com/FabricMC/fabric/commit/3431c0d894309f137f39f288174a5d14c6423cee", "message": "Split up events to individual interfaces. Make Chunk events use WorldChunk instead.", "committedDate": "2020-06-18T00:52:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk1MDI5OQ==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r441950299", "bodyText": "clientStopping.onClientStopping etc sounds weird \ud83e\udd14", "author": "liach", "createdAt": "2020-06-18T03:39:15Z", "path": "fabric-lifecycle-events-v1/src/main/java/net/fabricmc/fabric/api/client/event/lifecycle/v1/ClientLifecycleEvents.java", "diffHunk": "@@ -33,9 +33,9 @@ private ClientLifecycleEvents() {\n \t *\n \t * <p>This occurs while the splash screen is displayed.\n \t */\n-\tpublic static final Event<ClientLifecycleCallback> CLIENT_STARTED = EventFactory.createArrayBacked(ClientLifecycleCallback.class, callbacks -> client -> {\n-\t\tfor (ClientLifecycleCallback callback : callbacks) {\n-\t\t\tcallback.onChangeLifecycle(client);\n+\tpublic static final Event<ClientStarted> CLIENT_STARTED = EventFactory.createArrayBacked(ClientStarted.class, callbacks -> client -> {\n+\t\tfor (ClientStarted callback : callbacks) {\n+\t\t\tcallback.onClientStarted(client);", "originalCommit": "3431c0d894309f137f39f288174a5d14c6423cee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk1Nzg1NA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r441957854", "bodyText": "yea it definitely felt odd to type out. Any better ideas for name?", "author": "i509VCB", "createdAt": "2020-06-18T04:11:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk1MDI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNzE1NQ==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r442427155", "bodyText": "Not sure if we really need a whole module just for ItemTooltipCallback", "author": "modmuss50", "createdAt": "2020-06-18T18:38:55Z", "path": "fabric-item-api-v1/build.gradle", "diffHunk": "@@ -0,0 +1,6 @@\n+archivesBaseName = \"fabric-item-api-v1\"", "originalCommit": "3431c0d894309f137f39f288174a5d14c6423cee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzMjY3MQ==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r442432671", "bodyText": "To me, it makes sense. It gives a home for future item hooks. Better than a huge misc module that would become massively bloated as time goes on.", "author": "Prospector", "createdAt": "2020-06-18T18:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNzE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzNjc0NA==", "url": "https://github.com/FabricMC/fabric/pull/619#discussion_r442436744", "bodyText": "Like prospector said, this is a thought of, what would likely exist in the future where this one can live", "author": "i509VCB", "createdAt": "2020-06-18T18:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNzE1NQ=="}], "type": "inlineReview"}]}