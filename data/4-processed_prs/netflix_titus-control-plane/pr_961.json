{"pr_number": 961, "pr_title": "Align KubeScheduler pod -> task state mapping with KubeApiServerIntegrator", "pr_createdAt": "2020-12-02T18:38:45Z", "pr_url": "https://github.com/Netflix/titus-control-plane/pull/961", "timeline": [{"oid": "29f94d15cce95d6b3be0436a05d6659de5735c67", "url": "https://github.com/Netflix/titus-control-plane/commit/29f94d15cce95d6b3be0436a05d6659de5735c67", "message": "Align KubeScheduler pod -> task state mapping with KubeApiServerIntegrator", "committedDate": "2020-12-02T18:37:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxNzcxNA==", "url": "https://github.com/Netflix/titus-control-plane/pull/961#discussion_r534417714", "bodyText": "There is KubeUtil.getMetadataName.", "author": "corindwyer", "createdAt": "2020-12-02T19:14:14Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/direct/model/PodWrapper.java", "diffHunk": "@@ -41,6 +43,10 @@ public V1Pod getV1Pod() {\n         return v1Pod;\n     }\n \n+    public String getName() {\n+        return v1Pod.getMetadata() == null ? \"\" : StringExt.nonNull(v1Pod.getMetadata().getName());", "originalCommit": "29f94d15cce95d6b3be0436a05d6659de5735c67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNTUwMA==", "url": "https://github.com/Netflix/titus-control-plane/pull/961#discussion_r534425500", "bodyText": "I think we can use V1ContainerStateRunning.getStartedAt here in the future as these special reasons are going away.", "author": "corindwyer", "createdAt": "2020-12-02T19:27:24Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/PodToTaskMapper.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.util.Optional;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.titus.api.jobmanager.model.job.JobFunctions;\n+import com.netflix.titus.api.jobmanager.model.job.Task;\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.api.jobmanager.model.job.TaskStatus;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.tuple.Either;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodPhase;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodWrapper;\n+import io.kubernetes.client.openapi.models.V1Node;\n+\n+import static com.netflix.titus.api.jobmanager.model.job.TaskState.Finished;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskState.KillInitiated;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskState.Launched;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskState.StartInitiated;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskState.Started;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskState.isBefore;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_FAILED;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_NORMAL;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_POD_SCHEDULED;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_STUCK_IN_STATE;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_TASK_KILLED;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_TRANSIENT_SYSTEM_ERROR;\n+import static com.netflix.titus.api.jobmanager.model.job.TaskStatus.REASON_UNKNOWN;\n+import static com.netflix.titus.runtime.kubernetes.KubeConstants.NODE_LOST;\n+\n+/**\n+ * Evaluates pod phase, pod condition and container state to determine best fitting Titus task state.\n+ */\n+public class PodToTaskMapper {\n+\n+    @VisibleForTesting\n+    static final String TASK_STARTING = \"TASK_STARTING\";\n+\n+    private final PodWrapper podWrapper;\n+    private final Optional<V1Node> node;\n+    private final Task task;\n+    private final ContainerResultCodeResolver containerResultCodeResolver;\n+    private final TitusRuntime titusRuntime;\n+\n+    private final Either<TaskStatus, String> newTaskStatus;\n+\n+    public PodToTaskMapper(PodWrapper podWrapper,\n+                           Optional<V1Node> node,\n+                           Task task,\n+                           boolean podDeleted,\n+                           ContainerResultCodeResolver containerResultCodeResolver,\n+                           TitusRuntime titusRuntime) {\n+        this.podWrapper = podWrapper;\n+        this.node = node;\n+        this.task = task;\n+        this.containerResultCodeResolver = containerResultCodeResolver;\n+        this.titusRuntime = titusRuntime;\n+\n+        if (TaskState.isTerminalState(task.getStatus().getState())) {\n+            this.newTaskStatus = irrelevant(\"task already marked as finished\");\n+        } else if (podDeleted) {\n+            this.newTaskStatus = handlePodDeleted();\n+        } else {\n+            switch (podWrapper.getPodPhase()) {\n+                case PENDING:\n+                    this.newTaskStatus = handlePodPending();\n+                    break;\n+                case RUNNING:\n+                    this.newTaskStatus = handlePodRunning();\n+                    break;\n+                case SUCCEEDED:\n+                case FAILED:\n+                    this.newTaskStatus = handlePodFinished();\n+                    break;\n+                case UNKNOWN:\n+                default:\n+                    this.newTaskStatus = unexpected(\"unknown pod phase\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle pod object deleted event.\n+     */\n+    private Either<TaskStatus, String> handlePodDeleted() {\n+        TaskState taskState = task.getStatus().getState();\n+        boolean hasKillInitiatedState = JobFunctions.findTaskStatus(task, KillInitiated).isPresent();\n+        String reason = podWrapper.getReason();\n+        long now = titusRuntime.getClock().wallTime();\n+\n+        if (!hasKillInitiatedState) {\n+            if (NODE_LOST.equals(reason)) {\n+                return Either.ofValue(TaskStatus.newBuilder()\n+                        .withState(Finished)\n+                        .withReasonCode(effectiveFinalReasonCode(REASON_TASK_KILLED))\n+                        .withReasonMessage(\"The host running the container was unexpectedly terminated\")\n+                        .withTimestamp(now)\n+                        .build()\n+                );\n+            } else {\n+                return Either.ofValue(TaskStatus.newBuilder()\n+                        .withState(Finished)\n+                        .withReasonCode(effectiveFinalReasonCode(REASON_TASK_KILLED))\n+                        .withReasonMessage(\"Container was terminated without going through the Titus API\")\n+                        .withTimestamp(now)\n+                        .build()\n+                );\n+            }\n+        }\n+\n+        String reasonCode;\n+        if (podWrapper.getPodPhase() == PodPhase.PENDING || podWrapper.getPodPhase() == PodPhase.RUNNING) {\n+            // Pod in pending phase which is being deleted must have been terminated, as it was never run.\n+            // Pod in running state that did not complete must have been terminated as well.\n+            if (taskState == KillInitiated && task.getStatus().getReasonCode().equals(REASON_STUCK_IN_STATE)) {\n+                reasonCode = REASON_TRANSIENT_SYSTEM_ERROR;\n+            } else {\n+                reasonCode = REASON_TASK_KILLED;\n+            }\n+        } else if (podWrapper.getPodPhase() == PodPhase.SUCCEEDED) {\n+            if (taskState == KillInitiated && task.getStatus().getReasonCode().equals(REASON_STUCK_IN_STATE)) {\n+                reasonCode = REASON_TRANSIENT_SYSTEM_ERROR;\n+            } else {\n+                if (podWrapper.hasDeletionTimestamp() || taskState == KillInitiated) {\n+                    reasonCode = REASON_TASK_KILLED;\n+                } else {\n+                    reasonCode = REASON_NORMAL;\n+                }\n+            }\n+        } else if (podWrapper.getPodPhase() == PodPhase.FAILED) {\n+            reasonCode = REASON_FAILED;\n+        } else {\n+            titusRuntime.getCodeInvariants().inconsistent(\"Pod: %s has unknown phase mapping: %s\", podWrapper.getName(), podWrapper.getPodPhase());\n+            reasonCode = REASON_UNKNOWN;\n+        }\n+\n+        return Either.ofValue(TaskStatus.newBuilder()\n+                .withState(Finished)\n+                .withReasonCode(effectiveFinalReasonCode(reasonCode))\n+                .withReasonMessage(\"Container was terminated without going through the Titus API\")\n+                .withTimestamp(now)\n+                .build()\n+        );\n+    }\n+\n+    /**\n+     * Handle pod 'Pending' phase. In this phase we have to distinguish cases:\n+     * <ul>\n+     *     <li>pod is waiting in the queue</li>\n+     *     <li>pod is assigned to a node but not running yet</li>\n+     * </ul>\n+     */\n+    private Either<TaskStatus, String> handlePodPending() {\n+        if (!podWrapper.isScheduled()) {\n+            return handlePodPendingQueued();\n+        }\n+        return handlePodPendingInitializingInContainerWaitingState(podWrapper);\n+    }\n+\n+    /**\n+     * Handle pod is waiting in the queue (is not scheduled yet). This event does not cause any task state\n+     * transition. We only verify consistency.\n+     */\n+    private Either<TaskStatus, String> handlePodPendingQueued() {\n+        if (task.getStatus().getState() != TaskState.Accepted) {\n+            return unexpected(\"expected queued task in the Accepted state\");\n+        }\n+        return irrelevant(\"pod is waiting in the queue to be scheduled\");\n+    }\n+\n+    /**\n+     * Handle pod is assigned to a node but not running yet. The following pre-conditions must exist:\n+     * <ul>\n+     *     <li>pod condition 'PodScheduled' is set</li>\n+     *     <li>nodeName is not empty</li>\n+     * </ul>\n+     * Based on container state and reason message the state is classified as 'Launched' or 'StartInitiated':\n+     * <ul>\n+     *     <li>if reason != 'TASK_STARTING' set 'Launched'</li>", "originalCommit": "29f94d15cce95d6b3be0436a05d6659de5735c67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}