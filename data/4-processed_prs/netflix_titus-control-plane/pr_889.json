{"pr_number": 889, "pr_title": "Extract GC controller logic from KubeApiServerIntegrator", "pr_createdAt": "2020-07-29T19:00:45Z", "pr_url": "https://github.com/Netflix/titus-control-plane/pull/889", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyOTcxNQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r462529715", "bodyText": "Move this first in the function for better flow?", "author": "joshi-keyur", "createdAt": "2020-07-29T19:17:08Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/NodeGcController.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.model.InstanceLifecycleState;\n+import com.netflix.titus.api.agent.service.AgentManagementService;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1NodeCondition;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.READY;\n+\n+/**\n+ * Responsible for deleting Kubernetes node objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class NodeGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(NodeGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"nodeGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final AgentManagementService agentManagementService;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge nodesToGc;\n+\n+    @Inject\n+    public NodeGcController(KubeControllerConfiguration configuration,\n+                            TitusRuntime titusRuntime,\n+                            AgentManagementService agentManagementService,\n+                            KubeApiFacade kubeApiFacade,\n+                            LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.agentManagementService = agentManagementService;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+        this.nodesToGc = titusRuntime.getRegistry().gauge(METRIC_ROOT + \"nodesToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"nodeGcController\")\n+                .withDescription(\"GC nodes that no longer exist\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getNodeGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getNodeGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getNodeGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcNodes(), ExecutorsExt.namedSingleThreadExecutor(\"node-gc-controller\"));\n+    }\n+\n+    void gcNodes() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isNodeGcControllerEnabled()) {", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNjA4OQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r462536089", "bodyText": "I am wondering how likely is the scenario where nodeName is missing/empty and if that is indicative of a different issue.", "author": "joshi-keyur", "createdAt": "2020-07-29T19:28:58Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/NodeGcController.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.model.InstanceLifecycleState;\n+import com.netflix.titus.api.agent.service.AgentManagementService;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1NodeCondition;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.READY;\n+\n+/**\n+ * Responsible for deleting Kubernetes node objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class NodeGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(NodeGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"nodeGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final AgentManagementService agentManagementService;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge nodesToGc;\n+\n+    @Inject\n+    public NodeGcController(KubeControllerConfiguration configuration,\n+                            TitusRuntime titusRuntime,\n+                            AgentManagementService agentManagementService,\n+                            KubeApiFacade kubeApiFacade,\n+                            LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.agentManagementService = agentManagementService;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+        this.nodesToGc = titusRuntime.getRegistry().gauge(METRIC_ROOT + \"nodesToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"nodeGcController\")\n+                .withDescription(\"GC nodes that no longer exist\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getNodeGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getNodeGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getNodeGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcNodes(), ExecutorsExt.namedSingleThreadExecutor(\"node-gc-controller\"));\n+    }\n+\n+    void gcNodes() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isNodeGcControllerEnabled()) {\n+            logger.info(\"Node GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        Set<String> nodeNamesToGc = nodes.stream()\n+                .filter(this::isNodeEligibleForGc)\n+                .map(n -> KubeUtil.getMetadataName(n.getMetadata()))\n+                .filter(StringExt::isNotEmpty)\n+                .collect(Collectors.toSet());\n+\n+        logger.info(\"Attempting to GC {} nodes: {}\", nodeNamesToGc.size(), nodeNamesToGc);\n+        this.nodesToGc.set(nodeNamesToGc.size());\n+        for (String nodeName : nodeNamesToGc) {\n+            gcNode(nodeName);\n+        }\n+        logger.info(\"Finished node GC\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isNodeEligibleForGc(V1Node node) {\n+        String nodeName = KubeUtil.getMetadataName(node.getMetadata());\n+        Optional<V1NodeCondition> readyNodeConditionOpt = KubeUtil.findNodeCondition(node, READY);\n+        if (StringExt.isNotEmpty(nodeName) && readyNodeConditionOpt.isPresent()) {", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzODM3NA==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r462538374", "bodyText": "This should not happen but the models/API don't provide any guarantees so there is a lot of defensive checks.", "author": "corindwyer", "createdAt": "2020-07-29T19:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNjA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU1NjgxNg==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r462556816", "bodyText": "What is the heartbeat rate for the Ready condition? Should we document how the gracePeriodMs relates to the default heartbeat rate and provide a guardrail check so we don't accidentally set the gracePeriod lower?", "author": "joshi-keyur", "createdAt": "2020-07-29T20:06:34Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/NodeGcController.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.model.InstanceLifecycleState;\n+import com.netflix.titus.api.agent.service.AgentManagementService;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1NodeCondition;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.READY;\n+\n+/**\n+ * Responsible for deleting Kubernetes node objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class NodeGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(NodeGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"nodeGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final AgentManagementService agentManagementService;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge nodesToGc;\n+\n+    @Inject\n+    public NodeGcController(KubeControllerConfiguration configuration,\n+                            TitusRuntime titusRuntime,\n+                            AgentManagementService agentManagementService,\n+                            KubeApiFacade kubeApiFacade,\n+                            LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.agentManagementService = agentManagementService;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+        this.nodesToGc = titusRuntime.getRegistry().gauge(METRIC_ROOT + \"nodesToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"nodeGcController\")\n+                .withDescription(\"GC nodes that no longer exist\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getNodeGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getNodeGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getNodeGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcNodes(), ExecutorsExt.namedSingleThreadExecutor(\"node-gc-controller\"));\n+    }\n+\n+    void gcNodes() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isNodeGcControllerEnabled()) {\n+            logger.info(\"Node GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        Set<String> nodeNamesToGc = nodes.stream()\n+                .filter(this::isNodeEligibleForGc)\n+                .map(n -> KubeUtil.getMetadataName(n.getMetadata()))\n+                .filter(StringExt::isNotEmpty)\n+                .collect(Collectors.toSet());\n+\n+        logger.info(\"Attempting to GC {} nodes: {}\", nodeNamesToGc.size(), nodeNamesToGc);\n+        this.nodesToGc.set(nodeNamesToGc.size());\n+        for (String nodeName : nodeNamesToGc) {\n+            gcNode(nodeName);\n+        }\n+        logger.info(\"Finished node GC\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isNodeEligibleForGc(V1Node node) {\n+        String nodeName = KubeUtil.getMetadataName(node.getMetadata());\n+        Optional<V1NodeCondition> readyNodeConditionOpt = KubeUtil.findNodeCondition(node, READY);\n+        if (StringExt.isNotEmpty(nodeName) && readyNodeConditionOpt.isPresent()) {\n+            V1NodeCondition readyNodeCondition = readyNodeConditionOpt.get();\n+            boolean isReadyConditionTimestampPastGracePeriod = hasConditionGracePeriodElapsed(readyNodeCondition, configuration.getNodeGcGracePeriodMs());\n+            boolean isAgentInstanceNotAvailable = isAgentInstanceNotAvailable(nodeName);\n+            return isReadyConditionTimestampPastGracePeriod && isAgentInstanceNotAvailable;\n+        }\n+        return false;\n+    }\n+\n+    private boolean hasConditionGracePeriodElapsed(V1NodeCondition condition, long gracePeriodMs) {", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU2NDA4Ng==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r462564086", "bodyText": "The heartbeat rate is determined by the kubelet. This check is only used as an extra safety check, but the real source is the cloud provider information from agent management.", "author": "corindwyer", "createdAt": "2020-07-29T20:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU1NjgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE1Njk2NA==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r463156964", "bodyText": "Record schedule reference to close it in the shutdown method.", "author": "tbak", "createdAt": "2020-07-30T17:28:39Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/NodeGcController.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.model.InstanceLifecycleState;\n+import com.netflix.titus.api.agent.service.AgentManagementService;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1NodeCondition;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.READY;\n+\n+/**\n+ * Responsible for deleting Kubernetes node objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class NodeGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(NodeGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"nodeGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final AgentManagementService agentManagementService;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge nodesToGc;\n+\n+    @Inject\n+    public NodeGcController(KubeControllerConfiguration configuration,\n+                            TitusRuntime titusRuntime,\n+                            AgentManagementService agentManagementService,\n+                            KubeApiFacade kubeApiFacade,\n+                            LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.agentManagementService = agentManagementService;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+        this.nodesToGc = titusRuntime.getRegistry().gauge(METRIC_ROOT + \"nodesToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"nodeGcController\")\n+                .withDescription(\"GC nodes that no longer exist\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getNodeGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getNodeGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getNodeGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcNodes(), ExecutorsExt.namedSingleThreadExecutor(\"node-gc-controller\"));", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NjcyOA==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r465376728", "bodyText": "Same for the ExecutorService", "author": "fabiokung", "createdAt": "2020-08-04T23:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE1Njk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE1ODI3MQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r463158271", "bodyText": "Should we limit amount of nodes to GC per iteration? This will do a traffic shaping, and prevent K8S API overloading in case of large amount of nodes to GC (might me more relevant for pod GC).", "author": "tbak", "createdAt": "2020-07-30T17:30:53Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/NodeGcController.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.model.InstanceLifecycleState;\n+import com.netflix.titus.api.agent.service.AgentManagementService;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1NodeCondition;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.READY;\n+\n+/**\n+ * Responsible for deleting Kubernetes node objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class NodeGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(NodeGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"nodeGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final AgentManagementService agentManagementService;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge nodesToGc;\n+\n+    @Inject\n+    public NodeGcController(KubeControllerConfiguration configuration,\n+                            TitusRuntime titusRuntime,\n+                            AgentManagementService agentManagementService,\n+                            KubeApiFacade kubeApiFacade,\n+                            LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.agentManagementService = agentManagementService;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+        this.nodesToGc = titusRuntime.getRegistry().gauge(METRIC_ROOT + \"nodesToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"nodeGcController\")\n+                .withDescription(\"GC nodes that no longer exist\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getNodeGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getNodeGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getNodeGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcNodes(), ExecutorsExt.namedSingleThreadExecutor(\"node-gc-controller\"));\n+    }\n+\n+    void gcNodes() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isNodeGcControllerEnabled()) {\n+            logger.info(\"Node GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        Set<String> nodeNamesToGc = nodes.stream()\n+                .filter(this::isNodeEligibleForGc)\n+                .map(n -> KubeUtil.getMetadataName(n.getMetadata()))\n+                .filter(StringExt::isNotEmpty)\n+                .collect(Collectors.toSet());\n+\n+        logger.info(\"Attempting to GC {} nodes: {}\", nodeNamesToGc.size(), nodeNamesToGc);\n+        this.nodesToGc.set(nodeNamesToGc.size());\n+        for (String nodeName : nodeNamesToGc) {\n+            gcNode(nodeName);", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4NDU2OA==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r465384568", "bodyText": "the periodic scheduler has a timeout, but that doesn't guarantee any progress is made on each iteration. I agree a limit here is probably good", "author": "fabiokung", "createdAt": "2020-08-04T23:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE1ODI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2MDYwOQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r463160609", "bodyText": "This check is made a few times. Might be easier to check it in the very beginning (line 111), and do not repeat it later.", "author": "tbak", "createdAt": "2020-07-30T17:35:17Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/NodeGcController.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.model.InstanceLifecycleState;\n+import com.netflix.titus.api.agent.service.AgentManagementService;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1NodeCondition;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.READY;\n+\n+/**\n+ * Responsible for deleting Kubernetes node objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class NodeGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(NodeGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"nodeGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final AgentManagementService agentManagementService;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge nodesToGc;\n+\n+    @Inject\n+    public NodeGcController(KubeControllerConfiguration configuration,\n+                            TitusRuntime titusRuntime,\n+                            AgentManagementService agentManagementService,\n+                            KubeApiFacade kubeApiFacade,\n+                            LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.agentManagementService = agentManagementService;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+        this.nodesToGc = titusRuntime.getRegistry().gauge(METRIC_ROOT + \"nodesToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"nodeGcController\")\n+                .withDescription(\"GC nodes that no longer exist\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getNodeGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getNodeGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getNodeGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcNodes(), ExecutorsExt.namedSingleThreadExecutor(\"node-gc-controller\"));\n+    }\n+\n+    void gcNodes() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isNodeGcControllerEnabled()) {\n+            logger.info(\"Node GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        Set<String> nodeNamesToGc = nodes.stream()\n+                .filter(this::isNodeEligibleForGc)\n+                .map(n -> KubeUtil.getMetadataName(n.getMetadata()))\n+                .filter(StringExt::isNotEmpty)\n+                .collect(Collectors.toSet());\n+\n+        logger.info(\"Attempting to GC {} nodes: {}\", nodeNamesToGc.size(), nodeNamesToGc);\n+        this.nodesToGc.set(nodeNamesToGc.size());\n+        for (String nodeName : nodeNamesToGc) {\n+            gcNode(nodeName);\n+        }\n+        logger.info(\"Finished node GC\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isNodeEligibleForGc(V1Node node) {\n+        String nodeName = KubeUtil.getMetadataName(node.getMetadata());\n+        Optional<V1NodeCondition> readyNodeConditionOpt = KubeUtil.findNodeCondition(node, READY);\n+        if (StringExt.isNotEmpty(nodeName) && readyNodeConditionOpt.isPresent()) {\n+            V1NodeCondition readyNodeCondition = readyNodeConditionOpt.get();\n+            boolean isReadyConditionTimestampPastGracePeriod = hasConditionGracePeriodElapsed(readyNodeCondition, configuration.getNodeGcGracePeriodMs());\n+            boolean isAgentInstanceNotAvailable = isAgentInstanceNotAvailable(nodeName);\n+            return isReadyConditionTimestampPastGracePeriod && isAgentInstanceNotAvailable;\n+        }\n+        return false;\n+    }\n+\n+    private boolean hasConditionGracePeriodElapsed(V1NodeCondition condition, long gracePeriodMs) {\n+        DateTime lastHeartbeatTime = condition.getLastHeartbeatTime();\n+        return lastHeartbeatTime != null && clock.isPast(lastHeartbeatTime.getMillis() + gracePeriodMs);\n+    }\n+\n+    private boolean isAgentInstanceNotAvailable(String nodeName) {\n+        if (StringExt.isEmpty(nodeName)) {\n+            return false;\n+        }\n+\n+        Optional<AgentInstance> agentInstanceOpt = agentManagementService.findAgentInstance(nodeName);\n+        if (!agentInstanceOpt.isPresent()) {\n+            return true;\n+        }\n+\n+        AgentInstance agentInstance = agentInstanceOpt.get();\n+        return agentInstance.getLifecycleStatus().getState() == InstanceLifecycleState.Stopped;\n+    }\n+\n+    private void gcNode(String nodeName) {\n+        if (StringExt.isNotEmpty(nodeName)) {", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4MzQzNQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r465383435", "bodyText": "minor: consider inverting the boolean check and do an early return to reduce indentation for the rest of the method", "author": "fabiokung", "createdAt": "2020-08-04T23:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2MDYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4NjMxMQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r470086311", "bodyText": "it is already checked earlier so just going to remove it", "author": "corindwyer", "createdAt": "2020-08-13T16:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2MDYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2MjkzNg==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r463162936", "bodyText": "try/catch for each of gcXXX? So in case one fails due to an unexpected error, we proceed with other GCs", "author": "tbak", "createdAt": "2020-07-30T17:39:36Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/PodGcController.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.DEFAULT_NAMESPACE;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.PENDING;\n+\n+/**\n+ * Responsible for deleting Kubernetes pod objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class PodGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(PodGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"podGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge podsOnUnknownNodes;\n+    private final Gauge podsPastDeletionTimestampToGcGauge;\n+    private final Gauge pendingPodsWithDeletionTimestampToGcGauge;\n+\n+    @Inject\n+    public PodGcController(KubeControllerConfiguration configuration,\n+                           TitusRuntime titusRuntime,\n+                           KubeApiFacade kubeApiFacade,\n+                           LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+\n+        Registry registry = titusRuntime.getRegistry();\n+        podsOnUnknownNodes = registry.gauge(METRIC_ROOT + \"podsOnUnknownNodes\");\n+        podsPastDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"podsPastDeletionTimestampToGc\");\n+        pendingPodsWithDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"pendingPodsWithDeletionTimestampToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"podGcController\")\n+                .withDescription(\"Clean up pods that need to be garbage collected\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getPodGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getPodGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getPodGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcPods(), ExecutorsExt.namedSingleThreadExecutor(\"pod-gc-controller\"));\n+    }\n+\n+    void gcPods() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!kubeApiFacade.getPodInformer().hasSynced()) {\n+            logger.info(\"Pod informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isPodGcControllerEnabled()) {\n+            logger.info(\"Pod GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+\n+        gcPodsOnUnknownNode(nodes, pods);", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIyMjM1Ng==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r463222356", "bodyText": "The idea is that the code that can fail in each one does its own exception handling but I think it is fine to be safer here.", "author": "corindwyer", "createdAt": "2020-07-30T19:29:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2MjkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2MzYwOA==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r463163608", "bodyText": "Like for nodes, provide a limit for how many pods to GC per iteration.", "author": "tbak", "createdAt": "2020-07-30T17:40:50Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/PodGcController.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.DEFAULT_NAMESPACE;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.PENDING;\n+\n+/**\n+ * Responsible for deleting Kubernetes pod objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class PodGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(PodGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"podGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge podsOnUnknownNodes;\n+    private final Gauge podsPastDeletionTimestampToGcGauge;\n+    private final Gauge pendingPodsWithDeletionTimestampToGcGauge;\n+\n+    @Inject\n+    public PodGcController(KubeControllerConfiguration configuration,\n+                           TitusRuntime titusRuntime,\n+                           KubeApiFacade kubeApiFacade,\n+                           LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+\n+        Registry registry = titusRuntime.getRegistry();\n+        podsOnUnknownNodes = registry.gauge(METRIC_ROOT + \"podsOnUnknownNodes\");\n+        podsPastDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"podsPastDeletionTimestampToGc\");\n+        pendingPodsWithDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"pendingPodsWithDeletionTimestampToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"podGcController\")\n+                .withDescription(\"Clean up pods that need to be garbage collected\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getPodGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getPodGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getPodGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcPods(), ExecutorsExt.namedSingleThreadExecutor(\"pod-gc-controller\"));\n+    }\n+\n+    void gcPods() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!kubeApiFacade.getPodInformer().hasSynced()) {\n+            logger.info(\"Pod informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isPodGcControllerEnabled()) {\n+            logger.info(\"Pod GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+\n+        gcPodsOnUnknownNode(nodes, pods);\n+        gcPodsPastDeletionTimestamp(pods);\n+        gcPendingPodsWithDeletionTimestamp(pods);\n+    }\n+\n+    /**\n+     * GC pods on unknown nodes\n+     */\n+    private void gcPodsOnUnknownNode(List<V1Node> nodes, List<V1Pod> pods) {\n+        Set<String> knownNodeNames = nodes.stream().map(n -> KubeUtil.getMetadataName(n.getMetadata())).collect(Collectors.toSet());\n+        List<V1Pod> podsOnUnknownNodes = pods.stream()\n+                .filter(p -> isPodOnUnknownNode(p, knownNodeNames))\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pods: {} on unknown nodes\", podsOnUnknownNodes.size(),\n+                podsOnUnknownNodes);\n+        this.podsOnUnknownNodes.set(podsOnUnknownNodes.size());\n+        for (V1Pod pod : podsOnUnknownNodes) {", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2NDQxOA==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r463164418", "bodyText": "Return pods to remove, and do execution in one place for all of them (unknown, past deletion timestamp, etc)?", "author": "tbak", "createdAt": "2020-07-30T17:42:23Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/PodGcController.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.DEFAULT_NAMESPACE;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.PENDING;\n+\n+/**\n+ * Responsible for deleting Kubernetes pod objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class PodGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(PodGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"podGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge podsOnUnknownNodes;\n+    private final Gauge podsPastDeletionTimestampToGcGauge;\n+    private final Gauge pendingPodsWithDeletionTimestampToGcGauge;\n+\n+    @Inject\n+    public PodGcController(KubeControllerConfiguration configuration,\n+                           TitusRuntime titusRuntime,\n+                           KubeApiFacade kubeApiFacade,\n+                           LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+\n+        Registry registry = titusRuntime.getRegistry();\n+        podsOnUnknownNodes = registry.gauge(METRIC_ROOT + \"podsOnUnknownNodes\");\n+        podsPastDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"podsPastDeletionTimestampToGc\");\n+        pendingPodsWithDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"pendingPodsWithDeletionTimestampToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"podGcController\")\n+                .withDescription(\"Clean up pods that need to be garbage collected\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getPodGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getPodGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getPodGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcPods(), ExecutorsExt.namedSingleThreadExecutor(\"pod-gc-controller\"));\n+    }\n+\n+    void gcPods() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!kubeApiFacade.getPodInformer().hasSynced()) {\n+            logger.info(\"Pod informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isPodGcControllerEnabled()) {\n+            logger.info(\"Pod GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+\n+        gcPodsOnUnknownNode(nodes, pods);\n+        gcPodsPastDeletionTimestamp(pods);\n+        gcPendingPodsWithDeletionTimestamp(pods);\n+    }\n+\n+    /**\n+     * GC pods on unknown nodes\n+     */\n+    private void gcPodsOnUnknownNode(List<V1Node> nodes, List<V1Pod> pods) {", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2NTAyOA==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r463165028", "bodyText": "These checks should be done in the very beginning, after getting the data set from informer.", "author": "tbak", "createdAt": "2020-07-30T17:43:33Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/PodGcController.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.DEFAULT_NAMESPACE;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.PENDING;\n+\n+/**\n+ * Responsible for deleting Kubernetes pod objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class PodGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(PodGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"podGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge podsOnUnknownNodes;\n+    private final Gauge podsPastDeletionTimestampToGcGauge;\n+    private final Gauge pendingPodsWithDeletionTimestampToGcGauge;\n+\n+    @Inject\n+    public PodGcController(KubeControllerConfiguration configuration,\n+                           TitusRuntime titusRuntime,\n+                           KubeApiFacade kubeApiFacade,\n+                           LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+\n+        Registry registry = titusRuntime.getRegistry();\n+        podsOnUnknownNodes = registry.gauge(METRIC_ROOT + \"podsOnUnknownNodes\");\n+        podsPastDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"podsPastDeletionTimestampToGc\");\n+        pendingPodsWithDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"pendingPodsWithDeletionTimestampToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"podGcController\")\n+                .withDescription(\"Clean up pods that need to be garbage collected\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getPodGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getPodGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getPodGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcPods(), ExecutorsExt.namedSingleThreadExecutor(\"pod-gc-controller\"));\n+    }\n+\n+    void gcPods() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!kubeApiFacade.getPodInformer().hasSynced()) {\n+            logger.info(\"Pod informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isPodGcControllerEnabled()) {\n+            logger.info(\"Pod GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+\n+        gcPodsOnUnknownNode(nodes, pods);\n+        gcPodsPastDeletionTimestamp(pods);\n+        gcPendingPodsWithDeletionTimestamp(pods);\n+    }\n+\n+    /**\n+     * GC pods on unknown nodes\n+     */\n+    private void gcPodsOnUnknownNode(List<V1Node> nodes, List<V1Pod> pods) {\n+        Set<String> knownNodeNames = nodes.stream().map(n -> KubeUtil.getMetadataName(n.getMetadata())).collect(Collectors.toSet());\n+        List<V1Pod> podsOnUnknownNodes = pods.stream()\n+                .filter(p -> isPodOnUnknownNode(p, knownNodeNames))\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pods: {} on unknown nodes\", podsOnUnknownNodes.size(),\n+                podsOnUnknownNodes);\n+        this.podsOnUnknownNodes.set(podsOnUnknownNodes.size());\n+        for (V1Pod pod : podsOnUnknownNodes) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pod GC on unknown nodes\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodOnUnknownNode(V1Pod pod, Set<String> knownNodeNames) {\n+        if (pod == null || pod.getSpec() == null) {", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2NjQ3Ng==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r463166476", "bodyText": "Again an early check would be better. It seems we need another GC process to cleanup such bad records from K8S.", "author": "tbak", "createdAt": "2020-07-30T17:46:11Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/PodGcController.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.DEFAULT_NAMESPACE;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.PENDING;\n+\n+/**\n+ * Responsible for deleting Kubernetes pod objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class PodGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(PodGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"podGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge podsOnUnknownNodes;\n+    private final Gauge podsPastDeletionTimestampToGcGauge;\n+    private final Gauge pendingPodsWithDeletionTimestampToGcGauge;\n+\n+    @Inject\n+    public PodGcController(KubeControllerConfiguration configuration,\n+                           TitusRuntime titusRuntime,\n+                           KubeApiFacade kubeApiFacade,\n+                           LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+\n+        Registry registry = titusRuntime.getRegistry();\n+        podsOnUnknownNodes = registry.gauge(METRIC_ROOT + \"podsOnUnknownNodes\");\n+        podsPastDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"podsPastDeletionTimestampToGc\");\n+        pendingPodsWithDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"pendingPodsWithDeletionTimestampToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"podGcController\")\n+                .withDescription(\"Clean up pods that need to be garbage collected\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getPodGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getPodGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getPodGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcPods(), ExecutorsExt.namedSingleThreadExecutor(\"pod-gc-controller\"));\n+    }\n+\n+    void gcPods() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!kubeApiFacade.getPodInformer().hasSynced()) {\n+            logger.info(\"Pod informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isPodGcControllerEnabled()) {\n+            logger.info(\"Pod GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+\n+        gcPodsOnUnknownNode(nodes, pods);\n+        gcPodsPastDeletionTimestamp(pods);\n+        gcPendingPodsWithDeletionTimestamp(pods);\n+    }\n+\n+    /**\n+     * GC pods on unknown nodes\n+     */\n+    private void gcPodsOnUnknownNode(List<V1Node> nodes, List<V1Pod> pods) {\n+        Set<String> knownNodeNames = nodes.stream().map(n -> KubeUtil.getMetadataName(n.getMetadata())).collect(Collectors.toSet());\n+        List<V1Pod> podsOnUnknownNodes = pods.stream()\n+                .filter(p -> isPodOnUnknownNode(p, knownNodeNames))\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pods: {} on unknown nodes\", podsOnUnknownNodes.size(),\n+                podsOnUnknownNodes);\n+        this.podsOnUnknownNodes.set(podsOnUnknownNodes.size());\n+        for (V1Pod pod : podsOnUnknownNodes) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pod GC on unknown nodes\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodOnUnknownNode(V1Pod pod, Set<String> knownNodeNames) {\n+        if (pod == null || pod.getSpec() == null) {\n+            return false;\n+        }\n+\n+        String nodeName = pod.getSpec().getNodeName();\n+        return StringExt.isNotEmpty(nodeName) && !knownNodeNames.contains(nodeName);\n+    }\n+\n+    /**\n+     * GC pods past deletion timestamp timeout.\n+     */\n+    private void gcPodsPastDeletionTimestamp(List<V1Pod> pods) {\n+        List<V1Pod> podsPastDeletionTimestampToGc = pods.stream()\n+                .filter(this::isPodPastDeletionTimestamp)\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pods: {} past deletion timestamp\", podsPastDeletionTimestampToGc.size(),\n+                podsPastDeletionTimestampToGc);\n+        podsPastDeletionTimestampToGcGauge.set(podsPastDeletionTimestampToGc.size());\n+        for (V1Pod pod : podsPastDeletionTimestampToGc) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pods past deletion timestamp GC\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodPastDeletionTimestamp(V1Pod pod) {\n+        V1PodSpec spec = pod.getSpec();\n+        V1ObjectMeta metadata = pod.getMetadata();\n+        if (spec == null || metadata == null) {", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2NzgzOA==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r463167838", "bodyText": "Do we need this check? How would we know about this pod if it is null value", "author": "tbak", "createdAt": "2020-07-30T17:48:25Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/PodGcController.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.DEFAULT_NAMESPACE;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.PENDING;\n+\n+/**\n+ * Responsible for deleting Kubernetes pod objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class PodGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(PodGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"podGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge podsOnUnknownNodes;\n+    private final Gauge podsPastDeletionTimestampToGcGauge;\n+    private final Gauge pendingPodsWithDeletionTimestampToGcGauge;\n+\n+    @Inject\n+    public PodGcController(KubeControllerConfiguration configuration,\n+                           TitusRuntime titusRuntime,\n+                           KubeApiFacade kubeApiFacade,\n+                           LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+\n+        Registry registry = titusRuntime.getRegistry();\n+        podsOnUnknownNodes = registry.gauge(METRIC_ROOT + \"podsOnUnknownNodes\");\n+        podsPastDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"podsPastDeletionTimestampToGc\");\n+        pendingPodsWithDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"pendingPodsWithDeletionTimestampToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"podGcController\")\n+                .withDescription(\"Clean up pods that need to be garbage collected\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getPodGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getPodGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getPodGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcPods(), ExecutorsExt.namedSingleThreadExecutor(\"pod-gc-controller\"));\n+    }\n+\n+    void gcPods() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!kubeApiFacade.getPodInformer().hasSynced()) {\n+            logger.info(\"Pod informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isPodGcControllerEnabled()) {\n+            logger.info(\"Pod GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+\n+        gcPodsOnUnknownNode(nodes, pods);\n+        gcPodsPastDeletionTimestamp(pods);\n+        gcPendingPodsWithDeletionTimestamp(pods);\n+    }\n+\n+    /**\n+     * GC pods on unknown nodes\n+     */\n+    private void gcPodsOnUnknownNode(List<V1Node> nodes, List<V1Pod> pods) {\n+        Set<String> knownNodeNames = nodes.stream().map(n -> KubeUtil.getMetadataName(n.getMetadata())).collect(Collectors.toSet());\n+        List<V1Pod> podsOnUnknownNodes = pods.stream()\n+                .filter(p -> isPodOnUnknownNode(p, knownNodeNames))\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pods: {} on unknown nodes\", podsOnUnknownNodes.size(),\n+                podsOnUnknownNodes);\n+        this.podsOnUnknownNodes.set(podsOnUnknownNodes.size());\n+        for (V1Pod pod : podsOnUnknownNodes) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pod GC on unknown nodes\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodOnUnknownNode(V1Pod pod, Set<String> knownNodeNames) {\n+        if (pod == null || pod.getSpec() == null) {\n+            return false;\n+        }\n+\n+        String nodeName = pod.getSpec().getNodeName();\n+        return StringExt.isNotEmpty(nodeName) && !knownNodeNames.contains(nodeName);\n+    }\n+\n+    /**\n+     * GC pods past deletion timestamp timeout.\n+     */\n+    private void gcPodsPastDeletionTimestamp(List<V1Pod> pods) {\n+        List<V1Pod> podsPastDeletionTimestampToGc = pods.stream()\n+                .filter(this::isPodPastDeletionTimestamp)\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pods: {} past deletion timestamp\", podsPastDeletionTimestampToGc.size(),\n+                podsPastDeletionTimestampToGc);\n+        podsPastDeletionTimestampToGcGauge.set(podsPastDeletionTimestampToGc.size());\n+        for (V1Pod pod : podsPastDeletionTimestampToGc) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pods past deletion timestamp GC\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodPastDeletionTimestamp(V1Pod pod) {\n+        V1PodSpec spec = pod.getSpec();\n+        V1ObjectMeta metadata = pod.getMetadata();\n+        if (spec == null || metadata == null) {\n+            return false;\n+        }\n+\n+        Long terminationGracePeriodSeconds = spec.getTerminationGracePeriodSeconds();\n+        DateTime deletionTimestamp = metadata.getDeletionTimestamp();\n+        if (terminationGracePeriodSeconds == null || deletionTimestamp == null) {\n+            return false;\n+        }\n+\n+        long terminationGracePeriodMs = terminationGracePeriodSeconds * 1000L;\n+        return clock.isPast(deletionTimestamp.getMillis() + terminationGracePeriodMs\n+                + configuration.getPodsPastTerminationGracePeriodMs());\n+    }\n+\n+    /**\n+     * GC pods in Pending phase with a deletion timestamp.\n+     */\n+    private void gcPendingPodsWithDeletionTimestamp(List<V1Pod> pods) {\n+        List<V1Pod> pendingPodsWithDeletionTimestampToGc = pods.stream()\n+                .filter(this::isPodInPendingPhaseWithDeletionTimestamp)\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pending pods: {} with deletion timestamp\", pendingPodsWithDeletionTimestampToGc.size(),\n+                pendingPodsWithDeletionTimestampToGc);\n+        pendingPodsWithDeletionTimestampToGcGauge.set(pendingPodsWithDeletionTimestampToGc.size());\n+        for (V1Pod pod : pendingPodsWithDeletionTimestampToGc) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pending pods with deletion timestamp GC\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodInPendingPhaseWithDeletionTimestamp(V1Pod pod) {\n+        if (pod == null || pod.getMetadata() == null || pod.getStatus() == null) {\n+            return false;\n+        }\n+        DateTime deletionTimestamp = pod.getMetadata().getDeletionTimestamp();\n+        return deletionTimestamp != null && PENDING.equalsIgnoreCase(pod.getStatus().getPhase());\n+    }\n+\n+    private void gcPod(V1Pod pod) {\n+        if (pod != null) {", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2ODQ2Nw==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r463168467", "bodyText": "Should be an early check. If pod name is knot know, we should not call any of the GC evaluators.", "author": "tbak", "createdAt": "2020-07-30T17:49:26Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/PodGcController.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.DEFAULT_NAMESPACE;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.PENDING;\n+\n+/**\n+ * Responsible for deleting Kubernetes pod objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class PodGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(PodGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"podGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge podsOnUnknownNodes;\n+    private final Gauge podsPastDeletionTimestampToGcGauge;\n+    private final Gauge pendingPodsWithDeletionTimestampToGcGauge;\n+\n+    @Inject\n+    public PodGcController(KubeControllerConfiguration configuration,\n+                           TitusRuntime titusRuntime,\n+                           KubeApiFacade kubeApiFacade,\n+                           LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+\n+        Registry registry = titusRuntime.getRegistry();\n+        podsOnUnknownNodes = registry.gauge(METRIC_ROOT + \"podsOnUnknownNodes\");\n+        podsPastDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"podsPastDeletionTimestampToGc\");\n+        pendingPodsWithDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"pendingPodsWithDeletionTimestampToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"podGcController\")\n+                .withDescription(\"Clean up pods that need to be garbage collected\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getPodGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getPodGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getPodGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcPods(), ExecutorsExt.namedSingleThreadExecutor(\"pod-gc-controller\"));\n+    }\n+\n+    void gcPods() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!kubeApiFacade.getPodInformer().hasSynced()) {\n+            logger.info(\"Pod informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isPodGcControllerEnabled()) {\n+            logger.info(\"Pod GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+\n+        gcPodsOnUnknownNode(nodes, pods);\n+        gcPodsPastDeletionTimestamp(pods);\n+        gcPendingPodsWithDeletionTimestamp(pods);\n+    }\n+\n+    /**\n+     * GC pods on unknown nodes\n+     */\n+    private void gcPodsOnUnknownNode(List<V1Node> nodes, List<V1Pod> pods) {\n+        Set<String> knownNodeNames = nodes.stream().map(n -> KubeUtil.getMetadataName(n.getMetadata())).collect(Collectors.toSet());\n+        List<V1Pod> podsOnUnknownNodes = pods.stream()\n+                .filter(p -> isPodOnUnknownNode(p, knownNodeNames))\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pods: {} on unknown nodes\", podsOnUnknownNodes.size(),\n+                podsOnUnknownNodes);\n+        this.podsOnUnknownNodes.set(podsOnUnknownNodes.size());\n+        for (V1Pod pod : podsOnUnknownNodes) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pod GC on unknown nodes\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodOnUnknownNode(V1Pod pod, Set<String> knownNodeNames) {\n+        if (pod == null || pod.getSpec() == null) {\n+            return false;\n+        }\n+\n+        String nodeName = pod.getSpec().getNodeName();\n+        return StringExt.isNotEmpty(nodeName) && !knownNodeNames.contains(nodeName);\n+    }\n+\n+    /**\n+     * GC pods past deletion timestamp timeout.\n+     */\n+    private void gcPodsPastDeletionTimestamp(List<V1Pod> pods) {\n+        List<V1Pod> podsPastDeletionTimestampToGc = pods.stream()\n+                .filter(this::isPodPastDeletionTimestamp)\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pods: {} past deletion timestamp\", podsPastDeletionTimestampToGc.size(),\n+                podsPastDeletionTimestampToGc);\n+        podsPastDeletionTimestampToGcGauge.set(podsPastDeletionTimestampToGc.size());\n+        for (V1Pod pod : podsPastDeletionTimestampToGc) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pods past deletion timestamp GC\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodPastDeletionTimestamp(V1Pod pod) {\n+        V1PodSpec spec = pod.getSpec();\n+        V1ObjectMeta metadata = pod.getMetadata();\n+        if (spec == null || metadata == null) {\n+            return false;\n+        }\n+\n+        Long terminationGracePeriodSeconds = spec.getTerminationGracePeriodSeconds();\n+        DateTime deletionTimestamp = metadata.getDeletionTimestamp();\n+        if (terminationGracePeriodSeconds == null || deletionTimestamp == null) {\n+            return false;\n+        }\n+\n+        long terminationGracePeriodMs = terminationGracePeriodSeconds * 1000L;\n+        return clock.isPast(deletionTimestamp.getMillis() + terminationGracePeriodMs\n+                + configuration.getPodsPastTerminationGracePeriodMs());\n+    }\n+\n+    /**\n+     * GC pods in Pending phase with a deletion timestamp.\n+     */\n+    private void gcPendingPodsWithDeletionTimestamp(List<V1Pod> pods) {\n+        List<V1Pod> pendingPodsWithDeletionTimestampToGc = pods.stream()\n+                .filter(this::isPodInPendingPhaseWithDeletionTimestamp)\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pending pods: {} with deletion timestamp\", pendingPodsWithDeletionTimestampToGc.size(),\n+                pendingPodsWithDeletionTimestampToGc);\n+        pendingPodsWithDeletionTimestampToGcGauge.set(pendingPodsWithDeletionTimestampToGc.size());\n+        for (V1Pod pod : pendingPodsWithDeletionTimestampToGc) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pending pods with deletion timestamp GC\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodInPendingPhaseWithDeletionTimestamp(V1Pod pod) {\n+        if (pod == null || pod.getMetadata() == null || pod.getStatus() == null) {\n+            return false;\n+        }\n+        DateTime deletionTimestamp = pod.getMetadata().getDeletionTimestamp();\n+        return deletionTimestamp != null && PENDING.equalsIgnoreCase(pod.getStatus().getPhase());\n+    }\n+\n+    private void gcPod(V1Pod pod) {\n+        if (pod != null) {\n+            gcPod(KubeUtil.getMetadataName(pod.getMetadata()));\n+        }\n+    }\n+\n+    private void gcPod(String podName) {\n+        if (StringExt.isNotEmpty(podName)) {", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3MzA4Mg==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r463173082", "bodyText": "Terminating?", "author": "tbak", "createdAt": "2020-07-30T17:57:06Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/KubeApiServerIntegrator.java", "diffHunk": "@@ -322,7 +269,7 @@ public void rejectLease(VirtualMachineLease lease) {\n     public void killTask(String taskId) {\n         killTaskCounter.increment();\n         try {\n-            logger.info(\"deleting pod: {}\", taskId);\n+            logger.info(\"Killing pod: {} by setting deletionTimestamp\", taskId);", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4MTYwOA==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r465381608", "bodyText": "if a Pod is deleted (by anyone) and it didn't have a proper status field set yet, we wait for full reconciliation to catch it?\nShouldn't we consider emitting a ContainerEvent with REASON_TASK_LOST (or REASON_UNKNOWN) here, for that case?", "author": "fabiokung", "createdAt": "2020-08-04T23:15:50Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/KubeApiServerIntegrator.java", "diffHunk": "@@ -653,6 +620,49 @@ private void podUpdated(V1Pod pod) {\n         }\n     }\n \n+    private void podDeleted(V1Pod pod) {\n+        try {\n+            V1ObjectMeta metadata = pod.getMetadata();\n+            V1PodStatus status = pod.getStatus();\n+            String podName = KubeUtil.getMetadataName(metadata);\n+\n+            if (!isPodValid(pod, metadata, status, podName)) {", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4Mjk2Mg==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r465382962", "bodyText": "very minor optimization here: inline the second variable and prevent some wasted cycles when the first check already fails. The method call is already very descriptive and readability isn't much improved by the extra variable.", "author": "fabiokung", "createdAt": "2020-08-04T23:20:22Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/NodeGcController.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.model.InstanceLifecycleState;\n+import com.netflix.titus.api.agent.service.AgentManagementService;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1NodeCondition;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.READY;\n+\n+/**\n+ * Responsible for deleting Kubernetes node objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class NodeGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(NodeGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"nodeGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final AgentManagementService agentManagementService;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge nodesToGc;\n+\n+    @Inject\n+    public NodeGcController(KubeControllerConfiguration configuration,\n+                            TitusRuntime titusRuntime,\n+                            AgentManagementService agentManagementService,\n+                            KubeApiFacade kubeApiFacade,\n+                            LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.agentManagementService = agentManagementService;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+        this.nodesToGc = titusRuntime.getRegistry().gauge(METRIC_ROOT + \"nodesToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"nodeGcController\")\n+                .withDescription(\"GC nodes that no longer exist\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getNodeGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getNodeGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getNodeGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcNodes(), ExecutorsExt.namedSingleThreadExecutor(\"node-gc-controller\"));\n+    }\n+\n+    void gcNodes() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isNodeGcControllerEnabled()) {\n+            logger.info(\"Node GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        Set<String> nodeNamesToGc = nodes.stream()\n+                .filter(this::isNodeEligibleForGc)\n+                .map(n -> KubeUtil.getMetadataName(n.getMetadata()))\n+                .filter(StringExt::isNotEmpty)\n+                .collect(Collectors.toSet());\n+\n+        logger.info(\"Attempting to GC {} nodes: {}\", nodeNamesToGc.size(), nodeNamesToGc);\n+        this.nodesToGc.set(nodeNamesToGc.size());\n+        for (String nodeName : nodeNamesToGc) {\n+            gcNode(nodeName);\n+        }\n+        logger.info(\"Finished node GC\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isNodeEligibleForGc(V1Node node) {\n+        String nodeName = KubeUtil.getMetadataName(node.getMetadata());\n+        Optional<V1NodeCondition> readyNodeConditionOpt = KubeUtil.findNodeCondition(node, READY);\n+        if (StringExt.isNotEmpty(nodeName) && readyNodeConditionOpt.isPresent()) {\n+            V1NodeCondition readyNodeCondition = readyNodeConditionOpt.get();\n+            boolean isReadyConditionTimestampPastGracePeriod = hasConditionGracePeriodElapsed(readyNodeCondition, configuration.getNodeGcGracePeriodMs());\n+            boolean isAgentInstanceNotAvailable = isAgentInstanceNotAvailable(nodeName);\n+            return isReadyConditionTimestampPastGracePeriod && isAgentInstanceNotAvailable;", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4Mzg0OA==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r465383848", "bodyText": "CodeInvariants#unexpectedError()?", "author": "fabiokung", "createdAt": "2020-08-04T23:23:12Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/NodeGcController.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.model.InstanceLifecycleState;\n+import com.netflix.titus.api.agent.service.AgentManagementService;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1NodeCondition;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.READY;\n+\n+/**\n+ * Responsible for deleting Kubernetes node objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class NodeGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(NodeGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"nodeGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final AgentManagementService agentManagementService;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge nodesToGc;\n+\n+    @Inject\n+    public NodeGcController(KubeControllerConfiguration configuration,\n+                            TitusRuntime titusRuntime,\n+                            AgentManagementService agentManagementService,\n+                            KubeApiFacade kubeApiFacade,\n+                            LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.agentManagementService = agentManagementService;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+        this.nodesToGc = titusRuntime.getRegistry().gauge(METRIC_ROOT + \"nodesToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"nodeGcController\")\n+                .withDescription(\"GC nodes that no longer exist\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getNodeGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getNodeGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getNodeGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcNodes(), ExecutorsExt.namedSingleThreadExecutor(\"node-gc-controller\"));\n+    }\n+\n+    void gcNodes() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isNodeGcControllerEnabled()) {\n+            logger.info(\"Node GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        Set<String> nodeNamesToGc = nodes.stream()\n+                .filter(this::isNodeEligibleForGc)\n+                .map(n -> KubeUtil.getMetadataName(n.getMetadata()))\n+                .filter(StringExt::isNotEmpty)\n+                .collect(Collectors.toSet());\n+\n+        logger.info(\"Attempting to GC {} nodes: {}\", nodeNamesToGc.size(), nodeNamesToGc);\n+        this.nodesToGc.set(nodeNamesToGc.size());\n+        for (String nodeName : nodeNamesToGc) {\n+            gcNode(nodeName);\n+        }\n+        logger.info(\"Finished node GC\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isNodeEligibleForGc(V1Node node) {\n+        String nodeName = KubeUtil.getMetadataName(node.getMetadata());\n+        Optional<V1NodeCondition> readyNodeConditionOpt = KubeUtil.findNodeCondition(node, READY);\n+        if (StringExt.isNotEmpty(nodeName) && readyNodeConditionOpt.isPresent()) {\n+            V1NodeCondition readyNodeCondition = readyNodeConditionOpt.get();\n+            boolean isReadyConditionTimestampPastGracePeriod = hasConditionGracePeriodElapsed(readyNodeCondition, configuration.getNodeGcGracePeriodMs());\n+            boolean isAgentInstanceNotAvailable = isAgentInstanceNotAvailable(nodeName);\n+            return isReadyConditionTimestampPastGracePeriod && isAgentInstanceNotAvailable;\n+        }\n+        return false;\n+    }\n+\n+    private boolean hasConditionGracePeriodElapsed(V1NodeCondition condition, long gracePeriodMs) {\n+        DateTime lastHeartbeatTime = condition.getLastHeartbeatTime();\n+        return lastHeartbeatTime != null && clock.isPast(lastHeartbeatTime.getMillis() + gracePeriodMs);\n+    }\n+\n+    private boolean isAgentInstanceNotAvailable(String nodeName) {\n+        if (StringExt.isEmpty(nodeName)) {\n+            return false;\n+        }\n+\n+        Optional<AgentInstance> agentInstanceOpt = agentManagementService.findAgentInstance(nodeName);\n+        if (!agentInstanceOpt.isPresent()) {\n+            return true;\n+        }\n+\n+        AgentInstance agentInstance = agentInstanceOpt.get();\n+        return agentInstance.getLifecycleStatus().getState() == InstanceLifecycleState.Stopped;\n+    }\n+\n+    private void gcNode(String nodeName) {\n+        if (StringExt.isNotEmpty(nodeName)) {\n+            try {\n+                kubeApiFacade.getCoreV1Api().deleteNode(\n+                        nodeName,\n+                        null,\n+                        null,\n+                        0,\n+                        null,\n+                        BACKGROUND,\n+                        null\n+                );\n+            } catch (JsonSyntaxException e) {\n+                // this is probably successful. the generated client has the wrong response type\n+            } catch (ApiException e) {\n+                if (!e.getMessage().equalsIgnoreCase(NOT_FOUND)) {\n+                    logger.error(\"Failed to delete node: {} with error: \", nodeName, e);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Failed to delete node: {} with error: \", nodeName, e);", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDExMTUwMw==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r470111503", "bodyText": "I wouldn't say this is unexpected as there could be networking/client errors that happen.", "author": "corindwyer", "createdAt": "2020-08-13T17:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4Mzg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4NTY4MA==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r465385680", "bodyText": "should probably filter out entries with null (or empty strings) as their name since this is an index", "author": "fabiokung", "createdAt": "2020-08-04T23:28:51Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultKubeJobManagementReconciler.java", "diffHunk": "@@ -167,13 +205,15 @@ private void reconcile() {\n         List<Task> tasks = v3JobOperations.getTasks();\n \n         Map<String, V1Node> nodesById = nodes.stream().collect(Collectors.toMap(\n-                node -> node.getMetadata().getName(),\n+                node -> KubeUtil.getMetadataName(node.getMetadata()),", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4NTgxMg==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r465385812", "bodyText": "same here, filter out the empty string to void trying to call delete with an empty name later", "author": "fabiokung", "createdAt": "2020-08-04T23:29:17Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultKubeJobManagementReconciler.java", "diffHunk": "@@ -167,13 +205,15 @@ private void reconcile() {\n         List<Task> tasks = v3JobOperations.getTasks();\n \n         Map<String, V1Node> nodesById = nodes.stream().collect(Collectors.toMap(\n-                node -> node.getMetadata().getName(),\n+                node -> KubeUtil.getMetadataName(node.getMetadata()),\n                 Function.identity()\n         ));\n         Map<String, Task> currentTasks = tasks.stream().collect(Collectors.toMap(Task::getId, Function.identity()));\n-        Set<String> currentPodNames = pods.stream().map(p -> p.getMetadata().getName()).collect(Collectors.toSet());\n+        Set<String> currentPodNames = pods.stream().map(p -> KubeUtil.getMetadataName(p.getMetadata())).collect(Collectors.toSet());", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MzUwNA==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r465393504", "bodyText": "This gauge could be set to an inflated value depending on how many pods are actually GC'd successfully vs how many fail in the gcPod() function (where the exception is swallowed). Do you think it'd be better to wait until the gcPod loop to set the gauge to the correctly number or possibly introduce a separate gauge to track attempted vs actual pod GC?", "author": "joshi-keyur", "createdAt": "2020-08-04T23:54:43Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/PodGcController.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.DEFAULT_NAMESPACE;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.PENDING;\n+\n+/**\n+ * Responsible for deleting Kubernetes pod objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class PodGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(PodGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"podGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge podsOnUnknownNodes;\n+    private final Gauge podsPastDeletionTimestampToGcGauge;\n+    private final Gauge pendingPodsWithDeletionTimestampToGcGauge;\n+\n+    @Inject\n+    public PodGcController(KubeControllerConfiguration configuration,\n+                           TitusRuntime titusRuntime,\n+                           KubeApiFacade kubeApiFacade,\n+                           LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+\n+        Registry registry = titusRuntime.getRegistry();\n+        podsOnUnknownNodes = registry.gauge(METRIC_ROOT + \"podsOnUnknownNodes\");\n+        podsPastDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"podsPastDeletionTimestampToGc\");\n+        pendingPodsWithDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"pendingPodsWithDeletionTimestampToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"podGcController\")\n+                .withDescription(\"Clean up pods that need to be garbage collected\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getPodGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getPodGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getPodGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcPods(), ExecutorsExt.namedSingleThreadExecutor(\"pod-gc-controller\"));\n+    }\n+\n+    void gcPods() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!kubeApiFacade.getPodInformer().hasSynced()) {\n+            logger.info(\"Pod informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isPodGcControllerEnabled()) {\n+            logger.info(\"Pod GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+\n+        gcPodsOnUnknownNode(nodes, pods);\n+        gcPodsPastDeletionTimestamp(pods);\n+        gcPendingPodsWithDeletionTimestamp(pods);\n+    }\n+\n+    /**\n+     * GC pods on unknown nodes\n+     */\n+    private void gcPodsOnUnknownNode(List<V1Node> nodes, List<V1Pod> pods) {\n+        Set<String> knownNodeNames = nodes.stream().map(n -> KubeUtil.getMetadataName(n.getMetadata())).collect(Collectors.toSet());\n+        List<V1Pod> podsOnUnknownNodes = pods.stream()\n+                .filter(p -> isPodOnUnknownNode(p, knownNodeNames))\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pods: {} on unknown nodes\", podsOnUnknownNodes.size(),\n+                podsOnUnknownNodes);\n+        this.podsOnUnknownNodes.set(podsOnUnknownNodes.size());\n+        for (V1Pod pod : podsOnUnknownNodes) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pod GC on unknown nodes\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodOnUnknownNode(V1Pod pod, Set<String> knownNodeNames) {\n+        if (pod == null || pod.getSpec() == null) {\n+            return false;\n+        }\n+\n+        String nodeName = pod.getSpec().getNodeName();\n+        return StringExt.isNotEmpty(nodeName) && !knownNodeNames.contains(nodeName);\n+    }\n+\n+    /**\n+     * GC pods past deletion timestamp timeout.\n+     */\n+    private void gcPodsPastDeletionTimestamp(List<V1Pod> pods) {\n+        List<V1Pod> podsPastDeletionTimestampToGc = pods.stream()\n+                .filter(this::isPodPastDeletionTimestamp)\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pods: {} past deletion timestamp\", podsPastDeletionTimestampToGc.size(),\n+                podsPastDeletionTimestampToGc);\n+        podsPastDeletionTimestampToGcGauge.set(podsPastDeletionTimestampToGc.size());\n+        for (V1Pod pod : podsPastDeletionTimestampToGc) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pods past deletion timestamp GC\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodPastDeletionTimestamp(V1Pod pod) {\n+        V1PodSpec spec = pod.getSpec();\n+        V1ObjectMeta metadata = pod.getMetadata();\n+        if (spec == null || metadata == null) {\n+            return false;\n+        }\n+\n+        Long terminationGracePeriodSeconds = spec.getTerminationGracePeriodSeconds();\n+        DateTime deletionTimestamp = metadata.getDeletionTimestamp();\n+        if (terminationGracePeriodSeconds == null || deletionTimestamp == null) {\n+            return false;\n+        }\n+\n+        long terminationGracePeriodMs = terminationGracePeriodSeconds * 1000L;\n+        return clock.isPast(deletionTimestamp.getMillis() + terminationGracePeriodMs\n+                + configuration.getPodsPastTerminationGracePeriodMs());\n+    }\n+\n+    /**\n+     * GC pods in Pending phase with a deletion timestamp.\n+     */\n+    private void gcPendingPodsWithDeletionTimestamp(List<V1Pod> pods) {\n+        List<V1Pod> pendingPodsWithDeletionTimestampToGc = pods.stream()\n+                .filter(this::isPodInPendingPhaseWithDeletionTimestamp)\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pending pods: {} with deletion timestamp\", pendingPodsWithDeletionTimestampToGc.size(),\n+                pendingPodsWithDeletionTimestampToGc);\n+        pendingPodsWithDeletionTimestampToGcGauge.set(pendingPodsWithDeletionTimestampToGc.size());", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NDA3Mw==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r465394073", "bodyText": "Do we know how frequently and when this case could happen? Does it make sense to log at DEBUG level in case we need to troubleshoot a GC issue?", "author": "joshi-keyur", "createdAt": "2020-08-04T23:56:42Z", "path": "titus-server-master/src/main/java/com/netflix/titus/master/kubernetes/controller/PodGcController.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.kubernetes.controller;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.JsonSyntaxException;\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.common.framework.scheduler.LocalScheduler;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.kubeapiserver.KubeUtil;\n+import com.netflix.titus.master.mesos.kubeapiserver.client.KubeApiFacade;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import io.kubernetes.client.openapi.models.V1ObjectMeta;\n+import io.kubernetes.client.openapi.models.V1Pod;\n+import io.kubernetes.client.openapi.models.V1PodSpec;\n+import org.joda.time.DateTime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.BACKGROUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.DEFAULT_NAMESPACE;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.NOT_FOUND;\n+import static com.netflix.titus.master.mesos.kubeapiserver.KubeConstants.PENDING;\n+\n+/**\n+ * Responsible for deleting Kubernetes pod objects when they no longer exist in agent management. This will eventually be moved\n+ * to a new component.\n+ */\n+\n+@Singleton\n+public class PodGcController {\n+    private static final Logger logger = LoggerFactory.getLogger(PodGcController.class);\n+    private static final String METRIC_ROOT = MetricConstants.METRIC_KUBERNETES_CONTROLLER + \"podGcController.\";\n+\n+    private final KubeControllerConfiguration configuration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final LocalScheduler scheduler;\n+\n+    private final Clock clock;\n+    private final Gauge podsOnUnknownNodes;\n+    private final Gauge podsPastDeletionTimestampToGcGauge;\n+    private final Gauge pendingPodsWithDeletionTimestampToGcGauge;\n+\n+    @Inject\n+    public PodGcController(KubeControllerConfiguration configuration,\n+                           TitusRuntime titusRuntime,\n+                           KubeApiFacade kubeApiFacade,\n+                           LocalScheduler scheduler) {\n+        this.configuration = configuration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.scheduler = scheduler;\n+\n+        this.clock = titusRuntime.getClock();\n+\n+        Registry registry = titusRuntime.getRegistry();\n+        podsOnUnknownNodes = registry.gauge(METRIC_ROOT + \"podsOnUnknownNodes\");\n+        podsPastDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"podsPastDeletionTimestampToGc\");\n+        pendingPodsWithDeletionTimestampToGcGauge = registry.gauge(METRIC_ROOT + \"pendingPodsWithDeletionTimestampToGc\");\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor reconcileSchedulerDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"podGcController\")\n+                .withDescription(\"Clean up pods that need to be garbage collected\")\n+                .withInitialDelay(Duration.ofMillis(configuration.getPodGcControllerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(configuration.getPodGcControllerIntervalMs()))\n+                .withTimeout(Duration.ofMillis(configuration.getPodGcControllerTimeoutMs()))\n+                .build();\n+        scheduler.schedule(reconcileSchedulerDescriptor, e -> gcPods(), ExecutorsExt.namedSingleThreadExecutor(\"pod-gc-controller\"));\n+    }\n+\n+    void gcPods() {\n+        if (!kubeApiFacade.getNodeInformer().hasSynced()) {\n+            logger.info(\"Node informer has not synced\");\n+            return;\n+        }\n+\n+        if (!kubeApiFacade.getPodInformer().hasSynced()) {\n+            logger.info(\"Pod informer has not synced\");\n+            return;\n+        }\n+\n+        if (!configuration.isPodGcControllerEnabled()) {\n+            logger.info(\"Pod GC is disabled\");\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+\n+        gcPodsOnUnknownNode(nodes, pods);\n+        gcPodsPastDeletionTimestamp(pods);\n+        gcPendingPodsWithDeletionTimestamp(pods);\n+    }\n+\n+    /**\n+     * GC pods on unknown nodes\n+     */\n+    private void gcPodsOnUnknownNode(List<V1Node> nodes, List<V1Pod> pods) {\n+        Set<String> knownNodeNames = nodes.stream().map(n -> KubeUtil.getMetadataName(n.getMetadata())).collect(Collectors.toSet());\n+        List<V1Pod> podsOnUnknownNodes = pods.stream()\n+                .filter(p -> isPodOnUnknownNode(p, knownNodeNames))\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pods: {} on unknown nodes\", podsOnUnknownNodes.size(),\n+                podsOnUnknownNodes);\n+        this.podsOnUnknownNodes.set(podsOnUnknownNodes.size());\n+        for (V1Pod pod : podsOnUnknownNodes) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pod GC on unknown nodes\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodOnUnknownNode(V1Pod pod, Set<String> knownNodeNames) {\n+        if (pod == null || pod.getSpec() == null) {\n+            return false;\n+        }\n+\n+        String nodeName = pod.getSpec().getNodeName();\n+        return StringExt.isNotEmpty(nodeName) && !knownNodeNames.contains(nodeName);\n+    }\n+\n+    /**\n+     * GC pods past deletion timestamp timeout.\n+     */\n+    private void gcPodsPastDeletionTimestamp(List<V1Pod> pods) {\n+        List<V1Pod> podsPastDeletionTimestampToGc = pods.stream()\n+                .filter(this::isPodPastDeletionTimestamp)\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pods: {} past deletion timestamp\", podsPastDeletionTimestampToGc.size(),\n+                podsPastDeletionTimestampToGc);\n+        podsPastDeletionTimestampToGcGauge.set(podsPastDeletionTimestampToGc.size());\n+        for (V1Pod pod : podsPastDeletionTimestampToGc) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pods past deletion timestamp GC\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodPastDeletionTimestamp(V1Pod pod) {\n+        V1PodSpec spec = pod.getSpec();\n+        V1ObjectMeta metadata = pod.getMetadata();\n+        if (spec == null || metadata == null) {\n+            return false;\n+        }\n+\n+        Long terminationGracePeriodSeconds = spec.getTerminationGracePeriodSeconds();\n+        DateTime deletionTimestamp = metadata.getDeletionTimestamp();\n+        if (terminationGracePeriodSeconds == null || deletionTimestamp == null) {\n+            return false;\n+        }\n+\n+        long terminationGracePeriodMs = terminationGracePeriodSeconds * 1000L;\n+        return clock.isPast(deletionTimestamp.getMillis() + terminationGracePeriodMs\n+                + configuration.getPodsPastTerminationGracePeriodMs());\n+    }\n+\n+    /**\n+     * GC pods in Pending phase with a deletion timestamp.\n+     */\n+    private void gcPendingPodsWithDeletionTimestamp(List<V1Pod> pods) {\n+        List<V1Pod> pendingPodsWithDeletionTimestampToGc = pods.stream()\n+                .filter(this::isPodInPendingPhaseWithDeletionTimestamp)\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"Attempting to GC {} pending pods: {} with deletion timestamp\", pendingPodsWithDeletionTimestampToGc.size(),\n+                pendingPodsWithDeletionTimestampToGc);\n+        pendingPodsWithDeletionTimestampToGcGauge.set(pendingPodsWithDeletionTimestampToGc.size());\n+        for (V1Pod pod : pendingPodsWithDeletionTimestampToGc) {\n+            gcPod(pod);\n+        }\n+        logger.info(\"Finished pending pods with deletion timestamp GC\");\n+    }\n+\n+    @VisibleForTesting\n+    boolean isPodInPendingPhaseWithDeletionTimestamp(V1Pod pod) {\n+        if (pod == null || pod.getMetadata() == null || pod.getStatus() == null) {\n+            return false;\n+        }\n+        DateTime deletionTimestamp = pod.getMetadata().getDeletionTimestamp();\n+        return deletionTimestamp != null && PENDING.equalsIgnoreCase(pod.getStatus().getPhase());\n+    }\n+\n+    private void gcPod(V1Pod pod) {\n+        if (pod != null) {\n+            gcPod(KubeUtil.getMetadataName(pod.getMetadata()));\n+        }\n+    }\n+\n+    private void gcPod(String podName) {\n+        if (StringExt.isNotEmpty(podName)) {\n+            try {\n+                kubeApiFacade.getCoreV1Api().deleteNamespacedPod(\n+                        podName,\n+                        DEFAULT_NAMESPACE,\n+                        null,\n+                        null,\n+                        0,\n+                        null,\n+                        BACKGROUND,\n+                        null\n+                );\n+            } catch (JsonSyntaxException e) {\n+                // this is probably successful. the generated client has the wrong response type", "originalCommit": "c91bd7161db6e0e1826c9be341f53a4ab809e94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA4ODExOQ==", "url": "https://github.com/Netflix/titus-control-plane/pull/889#discussion_r470088119", "bodyText": "it happens 100% of the time so I don't think we need a log line", "author": "corindwyer", "createdAt": "2020-08-13T16:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NDA3Mw=="}], "type": "inlineReview"}, {"oid": "bddce49a1f7d89da4392487081c6c7890bf37caf", "url": "https://github.com/Netflix/titus-control-plane/commit/bddce49a1f7d89da4392487081c6c7890bf37caf", "message": "extract gc controller logic from KubeApiServerIntegrator into GC controllers", "committedDate": "2020-10-02T23:52:37Z", "type": "commit"}, {"oid": "bddce49a1f7d89da4392487081c6c7890bf37caf", "url": "https://github.com/Netflix/titus-control-plane/commit/bddce49a1f7d89da4392487081c6c7890bf37caf", "message": "extract gc controller logic from KubeApiServerIntegrator into GC controllers", "committedDate": "2020-10-02T23:52:37Z", "type": "forcePushed"}]}