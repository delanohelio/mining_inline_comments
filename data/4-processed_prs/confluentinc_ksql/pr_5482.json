{"pr_number": 5482, "pr_title": "feat: Adds SSL mutual auth support to intra-cluster requests", "pr_createdAt": "2020-05-26T23:18:33Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5482", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc2NzY5MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430767690", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ------------------------------------\n          \n          \n            \n            --------------------------------------------", "author": "JimGalasyn", "createdAt": "2020-05-26T23:47:51Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,6 +219,42 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n+Configure ksqlDB for Internal Authentication\n+------------------------------------", "originalCommit": "4a52c1104b9cc93ca59f1cba41f5ac570f05d2d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc2NzgyMQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430767821", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Since some system requests aren't done on behalf of a user (e.g. `/heartbeat`, `/lag`), \n          \n          \n            \n            Since some system requests aren't done on behalf of a user, like `/heartbeat` and `/lag`,", "author": "JimGalasyn", "createdAt": "2020-05-26T23:48:16Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,6 +219,42 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n+Configure ksqlDB for Internal Authentication\n+------------------------------------\n+\n+Since some system requests aren't done on behalf of a user (e.g. `/heartbeat`, `/lag`), ", "originalCommit": "4a52c1104b9cc93ca59f1cba41f5ac570f05d2d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc2ODkwOA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430768908", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can read generally about configuring `ksql.internal.listener` [here](index.md).\n          \n          \n            \n            For more information about configuring `ksql.internal.listener`, see [Configure ksqlDB for HTTPS](index.html#configure-ksqldb-for-https).", "author": "JimGalasyn", "createdAt": "2020-05-26T23:52:02Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,6 +219,42 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n+Configure ksqlDB for Internal Authentication\n+------------------------------------\n+\n+Since some system requests aren't done on behalf of a user (e.g. `/heartbeat`, `/lag`), \n+user-based authentication is not appropriate for them. Instead, ksqlDB supports SSL mutual authentication for system requests.\n+\n+In addition to some of the HTTPS configurations above, your key store must now\n+contain not only the certificate/key for the endpoints exposed with `listeners`, but also\n+the additional certificate/key for your internal listener set with\n+`ksql.internal.listener`.  Similarly, since your internal certificate is likely\n+self-signed, a trust store is required to contain certificates for nodes in your cluster.\n+\n+```properties\n+# Contains both internal and external certificates for this node.\n+# e.g. cert and key for external.example.com and node-1.internal.example.com\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# Contains internal certificates for all nodes in the cluster.\n+# e.g. cert for node-2.internal.example.com and node-3.internal.example.com\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=https://external.example.com:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+ksql.internal.ssl.client.authentication=REQUIRED\n+```\n+\n+Not only does this configure system authentication to be secure and authenticated at the\n+connection level, but ksqlDB then also considers these requests to be authenticated.\n+\n+\n+You can read generally about configuring `ksql.internal.listener` [here](index.md).", "originalCommit": "4a52c1104b9cc93ca59f1cba41f5ac570f05d2d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MTQ1Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430981452", "bodyText": "I'm not a fan of fine grained unit tests like these - they end up being very brittle and can provide a false sense of security. Would much rather see more coarse grained tests :)", "author": "purplefox", "createdAt": "2020-05-27T09:26:40Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/api/auth/SystemAuthenticationHandlerTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package io.confluent.ksql.api.auth;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Optional;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class SystemAuthenticationHandlerTest {", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNDQyNg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431524426", "bodyText": "Unit tests are often somewhat brittle for this reason, but the benefit is that you can test every code path.\nI think this is fairly in line with the codebase.  What would you change to make it coarser?", "author": "AlanConfluent", "createdAt": "2020-05-28T00:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MTQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcxMTU0Ng==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431711546", "bodyText": "It's a bit incongruous to add a fine grained mock test for this handler - the other handlers don't have this and that's been the approach we've taken with the new API. Instead we use much more coarse grained test which test the code as it would actually be used in a real setup. E.g. take a look at AuthTest.", "author": "purplefox", "createdAt": "2020-05-28T09:43:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MTQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcxNDY3MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431714670", "bodyText": "Unlike full blown integration tests these kinds of tests run really fast, so you should be able to write enough tests that exercise all the code paths, but unlike fine grained unit tests, they run exactly as they would in the real system, and we're not testing the implementation directly thus allowing it to evolve and be refactored much more easily.\nBTW... I'm well known for my opinion on fine grained unit tests (you should see my Twitter conversations), and I'm currently thinking of writing a blog post on them and why I think this approach - mainly championed by \"TDD\" has been super damaging in our industry ;)", "author": "purplefox", "createdAt": "2020-05-28T09:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MTQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc2MTUyNA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r432761524", "bodyText": "I was following the pattern in ksqldb-rest-app/src/test/java/io/confluent/ksql/api/auth/... where other auth handers do this kind of test.  It would seem a shame to delete my nice test.\nI'm happen to try to write a few test cases in AuthTest to specifically test this, though it's likely going to be a bit complex since it requires setting up https.  I'll give this a shot.", "author": "AlanConfluent", "createdAt": "2020-05-29T22:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MTQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk2NjUzOQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430966539", "bodyText": "Don't assume they'll be self-signed. This is probably not the norm.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `ksql.internal.listener`.  Similarly, since your internal certificate is likely\n          \n          \n            \n            self-signed, a trust store is required to contain certificates for nodes in your cluster.\n          \n          \n            \n            `ksql.internal.listener`.  If your internal certificate is self-signed, a trust store is required to contain certificates for nodes in your cluster.", "author": "big-andy-coates", "createdAt": "2020-05-27T09:02:53Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,6 +219,42 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n+Configure ksqlDB for Internal Authentication\n+------------------------------------\n+\n+Since some system requests aren't done on behalf of a user (e.g. `/heartbeat`, `/lag`), \n+user-based authentication is not appropriate for them. Instead, ksqlDB supports SSL mutual authentication for system requests.\n+\n+In addition to some of the HTTPS configurations above, your key store must now\n+contain not only the certificate/key for the endpoints exposed with `listeners`, but also\n+the additional certificate/key for your internal listener set with\n+`ksql.internal.listener`.  Similarly, since your internal certificate is likely\n+self-signed, a trust store is required to contain certificates for nodes in your cluster.", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk2NzMzOQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430967339", "bodyText": "Not sure what this is saying.", "author": "big-andy-coates", "createdAt": "2020-05-27T09:04:09Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,6 +219,42 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n+Configure ksqlDB for Internal Authentication\n+------------------------------------\n+\n+Since some system requests aren't done on behalf of a user (e.g. `/heartbeat`, `/lag`), \n+user-based authentication is not appropriate for them. Instead, ksqlDB supports SSL mutual authentication for system requests.\n+\n+In addition to some of the HTTPS configurations above, your key store must now\n+contain not only the certificate/key for the endpoints exposed with `listeners`, but also\n+the additional certificate/key for your internal listener set with\n+`ksql.internal.listener`.  Similarly, since your internal certificate is likely\n+self-signed, a trust store is required to contain certificates for nodes in your cluster.\n+\n+```properties\n+# Contains both internal and external certificates for this node.\n+# e.g. cert and key for external.example.com and node-1.internal.example.com\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# Contains internal certificates for all nodes in the cluster.\n+# e.g. cert for node-2.internal.example.com and node-3.internal.example.com\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=https://external.example.com:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+ksql.internal.ssl.client.authentication=REQUIRED\n+```\n+\n+Not only does this configure system authentication to be secure and authenticated at the\n+connection level, but ksqlDB then also considers these requests to be authenticated.", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwNjY3OQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431506679", "bodyText": "Hah, ok.  I was just meaning that the request attains a status as run by a SystemUser at the KSQL level.  It's not purely that the connection is https.\nThis is confusing.  I'll remove it.", "author": "AlanConfluent", "createdAt": "2020-05-27T23:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk2NzMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3MzIzMQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430973231", "bodyText": "Why do we have an Optional<Boolean> for isInternalListener.  Surely it either is an internal listerned or it isn't!  It's very confusing having it as an optional.\nWhat does Optional.of(false) mean for isInternalListerner?", "author": "big-andy-coates", "createdAt": "2020-05-27T09:13:36Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/AuthHandlers.java", "diffHunk": "@@ -37,12 +38,17 @@\n   private AuthHandlers() {\n   }\n \n-  static void setupAuthHandlers(final Server server, final Router router) {\n+  static void setupAuthHandlers(final Server server, final Router router,\n+      final Optional<Boolean> isInternalListener) {", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxMTU0Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431511543", "bodyText": "Optional.empty() means that no internal listener is set.  Optional.of(false) means that there is, but this is not it.  Optional.of(true) means there is and this is it.\nIt makes sense to have these three states in ServerVerticle given how the InternalEndpointHandler is installed, but i don't think it does here.  I'll simplify it to just a boolean.", "author": "AlanConfluent", "createdAt": "2020-05-28T00:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3MzIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3Mzk3NQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430973975", "bodyText": "We should have internal endpoints for internally proxied requests, e.g. show queries and pull queries.  These too should NOT require authetication.", "author": "big-andy-coates", "createdAt": "2020-05-27T09:14:49Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/InternalEndpointHandler.java", "diffHunk": "@@ -26,7 +26,7 @@\n public class InternalEndpointHandler implements Handler<RoutingContext> {\n   public static final String CONTEXT_DATA_IS_INTERNAL = \"isInternal\";\n \n-  private static final Set<String> INTERNAL_PATHS = ImmutableSet.of(\n+  public static final Set<String> INTERNAL_PATHS = ImmutableSet.of(", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxNzIxMg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431517212", "bodyText": "The current code does.  This set INTERNAL_PATHS says that if these are used on a public listener, it's an error.  This was the recommended strategy vs not installing the endpoints at all on the public listener.\nI no longer use this in SystemAuthenticationHandler which is only installed on the internal listener and accepts requests for all paths, but verifies they come on an SSL connection with a verified peer.", "author": "AlanConfluent", "createdAt": "2020-05-28T00:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3Mzk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3ODQwMQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430978401", "bodyText": "This feels very wrong.   This is the client that each node uses to talk to other nodes right?  It shouldn't have two KsqlClient instances.  All communication within the cluster should be trusted once the connections are authenticated.\nBoth pull requests and the show queries requests can be moved to a different internal specific endpoint, such that they can be differentiated from client requests.  This then means only a single sharedClient is needed here.  Not two, and then the code/engineer needs to know which to use for which internal requests.", "author": "big-andy-coates", "createdAt": "2020-05-27T09:21:42Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -45,26 +47,32 @@\n \n   private final Optional<String> authHeader;\n   private final KsqlClient sharedClient;\n+  private final KsqlClient internalClient;\n \n-  DefaultKsqlClient(final Optional<String> authHeader, final Map<String, Object> clientProps) {\n+  DefaultKsqlClient(final Optional<String> authHeader, final Map<String, Object> clientProps,\n+      final Optional<HostAliasResolver> hostAliasResolver) {\n     this(\n         authHeader,\n         new KsqlClient(\n             toClientProps(clientProps),\n             Optional.empty(),\n             new LocalProperties(ImmutableMap.of()),\n-            createClientOptions()\n-        )\n+            createClientOptions(),\n+            hostAliasResolver\n+        ),\n+        getInternalClient(toClientProps(clientProps), hostAliasResolver)\n     );\n   }\n \n   @VisibleForTesting\n   DefaultKsqlClient(\n       final Optional<String> authHeader,\n-      final KsqlClient sharedClient\n+      final KsqlClient sharedClient,\n+      final KsqlClient internalClient", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyMTg4NQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431521885", "bodyText": "Good call.  When this wasn't enabled for all internal endpoints, both had to be maintained, but with your previous suggestion to make use the SystemUser for all endpoints on the internal listener, there's just one KsqlClient now.\nI agree about splitting up internal vs external endpoints.  I had previously done that in my internal listener change.  I was asked to undo it and instead expose the same set of endpoints, but have a handler that makes the real internal ones unauthorized on the public listener.  Either way, only one client is now needed here since DefaultKsqlClient is only for inter-node communication.", "author": "AlanConfluent", "createdAt": "2020-05-28T00:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3ODQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3OTE5Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430979193", "bodyText": "nit: all the new tests being added by people tend to use the shouldXXX naming style.  If there some reason you've moved away from this?", "author": "big-andy-coates", "createdAt": "2020-05-27T09:23:00Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/api/auth/SystemAuthenticationHandlerTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package io.confluent.ksql.api.auth;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Optional;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class SystemAuthenticationHandlerTest {\n+\n+  @Mock Server server;\n+  @Mock RoutingContext routingContext;\n+\n+  @Test\n+  public void noListener() {", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNDc0MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431524740", "bodyText": "Nope, not really intentional.  'Should' it is.", "author": "AlanConfluent", "createdAt": "2020-05-28T00:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3OTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3OTI4Nw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430979287", "bodyText": "nit: private.", "author": "big-andy-coates", "createdAt": "2020-05-27T09:23:08Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/api/auth/SystemAuthenticationHandlerTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package io.confluent.ksql.api.auth;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Optional;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class SystemAuthenticationHandlerTest {\n+\n+  @Mock Server server;\n+  @Mock RoutingContext routingContext;", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNDU5OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431524598", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-05-28T00:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3OTI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3OTk0Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430979943", "bodyText": "success here meaning....? Running with mutual auth internally?", "author": "big-andy-coates", "createdAt": "2020-05-27T09:24:07Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/api/auth/SystemAuthenticationHandlerTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package io.confluent.ksql.api.auth;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Optional;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class SystemAuthenticationHandlerTest {\n+\n+  @Mock Server server;\n+  @Mock RoutingContext routingContext;\n+\n+  @Test\n+  public void noListener() {\n+    when(server.getConfig()).thenReturn(new KsqlRestConfig(ImmutableMap.of()));\n+    Optional<SystemAuthenticationHandler> handler =\n+        SystemAuthenticationHandler.getSystemAuthenticationHandler(server, Optional.empty());\n+    assertThat(handler.isPresent(), is(false));\n+  }\n+\n+  @Test\n+  public void notMutualAuth() {\n+    when(server.getConfig()).thenReturn(new KsqlRestConfig(ImmutableMap.of(\n+        KsqlRestConfig.INTERNAL_LISTENER_CONFIG, \"https://localhost:9188\",\n+        KsqlRestConfig.KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_CONFIG,\n+        KsqlRestConfig.SSL_CLIENT_AUTHENTICATION_NONE\n+    )));\n+    Optional<SystemAuthenticationHandler> handler =\n+        SystemAuthenticationHandler.getSystemAuthenticationHandler(server, Optional.of(true));\n+    assertThat(handler.isPresent(), is(false));\n+  }\n+\n+  @Test\n+  public void notInternal() {\n+    when(server.getConfig()).thenReturn(new KsqlRestConfig(ImmutableMap.of(\n+        KsqlRestConfig.INTERNAL_LISTENER_CONFIG, \"https://localhost:9188\",\n+        KsqlRestConfig.KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_CONFIG,\n+        KsqlRestConfig.SSL_CLIENT_AUTHENTICATION_REQUIRED\n+    )));\n+    Optional<SystemAuthenticationHandler> handler =\n+        SystemAuthenticationHandler.getSystemAuthenticationHandler(server, Optional.of(false));\n+    assertThat(handler.isPresent(), is(false));\n+  }\n+\n+  @Test\n+  public void success() {", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNTQ4NA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431525484", "bodyText": "Returned the handler.  Improved the name.", "author": "AlanConfluent", "createdAt": "2020-05-28T01:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3OTk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDQ3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430980472", "bodyText": "why does this need to change?", "author": "big-andy-coates", "createdAt": "2020-05-27T09:25:03Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/HighAvailabilityTestUtil.java", "diffHunk": "@@ -38,9 +40,29 @@\n \n   private static final Logger LOG = LoggerFactory.getLogger(HighAvailabilityTestUtil.class);\n \n-  static ClusterStatusResponse sendClusterStatusRequest(final TestKsqlRestApp restApp) {\n-    try (final KsqlRestClient restClient = restApp.buildInternalKsqlClient()) {\n-      final RestResponse<ClusterStatusResponse> res = restClient.makeClusterStatusRequest();\n+  static ClusterStatusResponse sendClusterStatusRequest(\n+      final TestKsqlRestApp restApp) {\n+    try (final KsqlRestClient restClient = restApp.buildKsqlClient()) {", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNTg4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431525883", "bodyText": "I had previously added the additional version below which allowed for https calls to the client API, so I could use different certs for the public listener and private.  But this wasn't really what I was testing, so I removed all of these and just added a simple auth credential version.", "author": "AlanConfluent", "createdAt": "2020-05-28T01:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MzA5MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430983091", "bodyText": "Can we move all of this out into a different class? This this class stays focussed on the simple case?", "author": "big-andy-coates", "createdAt": "2020-05-27T09:29:25Z", "path": "ksqldb-test-util/src/main/java/io/confluent/ksql/test/util/secure/ClientTrustStore.java", "diffHunk": "@@ -42,7 +43,48 @@\n       + \"7rKeqVDlpM5lUidfckmrF3TxmS6d1aN/1WSZtDZCnNK8+h6LrrbtSQMsS6tc1Cv5YjJ/7KB+rQmTmGJCdzI5E=\";\n \n   private static final String TRUSTSTORE_PASSWORD = \"password\";\n+\n+  // Trust store containing two certs, for internal.example.com and external.example.com\n+  private static final String BASE64_ENCODED_STORE_MULTIPLE =", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNzM3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431527372", "bodyText": "Done, moved to MultiNodeKeyStore.", "author": "AlanConfluent", "createdAt": "2020-05-28T01:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MzA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MzI3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430983272", "bodyText": "Likewise.", "author": "big-andy-coates", "createdAt": "2020-05-27T09:29:42Z", "path": "ksqldb-test-util/src/main/java/io/confluent/ksql/test/util/secure/ServerKeyStore.java", "diffHunk": "@@ -88,7 +89,103 @@\n   private static final String KEY_PASSWORD = \"password\";\n   private static final String KEYSTORE_PASSWORD = \"password\";\n   private static final String TRUSTSTORE_PASSWORD = \"password\";\n+\n+  // Keystore containing two certs, for external.example.com and internal.example.com\n+  private static final String BASE64_ENCODED_STORE_MULTIPLE =", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNzQ2MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431527461", "bodyText": "Done, moved to MultiNodeTrustStore.", "author": "AlanConfluent", "createdAt": "2020-05-28T01:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MzI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MDMxOA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430990318", "bodyText": "We should be capturing the name of the entity connecting to use, i.e. the hostname of the remote server, and storing this in the principle.  This can then be used later when logging out request information so that we/users can see which node a remove request came from.", "author": "big-andy-coates", "createdAt": "2020-05-27T09:41:34Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/auth/SystemAuthenticationHandler.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.auth;\n+\n+import io.confluent.ksql.api.server.InternalEndpointHandler;\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.ClientAuth;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.AuthProvider;\n+import io.vertx.ext.auth.User;\n+import io.vertx.ext.web.RoutingContext;\n+import java.net.URI;\n+import java.security.Principal;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+public class SystemAuthenticationHandler implements Handler<RoutingContext> {\n+\n+  public SystemAuthenticationHandler() {}\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    if (InternalEndpointHandler.INTERNAL_PATHS.contains(routingContext.normalisedPath())) {\n+      routingContext.setUser(new SystemUser(new SystemPrincipal()));\n+    }\n+    routingContext.next();\n+  }", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxMDE1NA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431510154", "bodyText": "Good idea.  Done.", "author": "AlanConfluent", "createdAt": "2020-05-28T00:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MDMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExNzgzMQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433117831", "bodyText": "As time goes on there will be more an more functionality that requires inter-node communication.  Having clustered services that talk inter-node is a common pattern, (e.g. Kafka!), so I don't think we need to call out the endpoints that are being used - these are an implementation detail and don't really help the user.   Hence, I think it's clearer/cleaner just to say:\n\nksqlDB supports securing inter-node communication using SSL mutual authentication.", "author": "big-andy-coates", "createdAt": "2020-06-01T08:54:34Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,6 +219,44 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n+Configure ksqlDB for Internal Authentication\n+--------------------------------------------\n+\n+Since some system requests aren't done on behalf of a user, like `/heartbeat` and `/lag`, \n+user-based authentication is not appropriate for them. Instead, ksqlDB supports SSL mutual authentication for system requests.", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyMzE0MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433123140", "bodyText": "This, and the example config below, seems to assume the users in securing the client facing endpoint via SSL as well. That may not be the case.\nAlso, the ksql.ssl.keystore.alias.xxx in the example config aren't explained anywhere.\nConfiguring this stuff is normally a pain point for users, so the more hand-holding and the better the examples we can provide the better. To that end, I would encourage adding different sections for :\n\nConfiguring ksqlDB to use SSL mutual auth for inter-node comms and SSL server auth for client comms.  This section should explain about the aliases configs and how these relate to the keystores - I'd be tempted to give a step-by-step guide of how to create the necessary keystores and truststores, so that its really clear where in the process the user defines the alias they later reference in the ksql.ssl.keystore.alias.xxx configs.\nConfiguring ksqlDB to use SSL mutual auth for inter-node comms only, (which assumes some other auth method on the client facing comms).\nConfiguring ksqlDB to use jaas for external - does this require them to have specific paths in the exclude list for specific features to work?  If it does, that's not really a workable solution going forward as that list will change.  Users generally customize their properties files and then upgrade by updating the jars only - can we have some single setting that turns off auth on internal calls?\nConfiguring ksqlDB to use jaas for internal and external - if this is even possible?\nConfiguring ksqlDB to use a custom auth handler installed by the user - if this is even possible?\n\nI know the later points above are outside the scope of this PR - but now that we've got this new internal listener config we need to make sure the documentation covers the different valid combinations of auth setup for the listeners and make sure they are easy to configure. Of course, you can update the config in a follow-on PR. But document it we should - otherwise we've done all the hard work, but users will likely struggle to use the feature!", "author": "big-andy-coates", "createdAt": "2020-06-01T09:06:27Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,6 +219,44 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n+Configure ksqlDB for Internal Authentication\n+--------------------------------------------\n+\n+Since some system requests aren't done on behalf of a user, like `/heartbeat` and `/lag`, \n+user-based authentication is not appropriate for them. Instead, ksqlDB supports SSL mutual authentication for system requests.\n+\n+In addition to some of the HTTPS configurations above, your key store must now\n+contain not only the certificate/key for the endpoints exposed with `listeners`, but also\n+the additional certificate/key for your internal listener set with\n+`ksql.internal.listener`.  If your internal certificate is self-signed, a trust store is required to contain certificates for nodes in your cluster.", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyODg5OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433128898", "bodyText": "It would be good to see if @JimGalasyn has the time to try and follow the steps to create a working secure two-node setup!", "author": "big-andy-coates", "createdAt": "2020-06-01T09:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyMzE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4NDY5OQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435584699", "bodyText": "Ok, I've improved the documentation here quite a lot.\n\nThis, and the example config below, seems to assume the users in securing the client facing endpoint via SSL as well. That may not be the case.\n\nI removed that assumption.  The first example is with internal only.  I also give a second example that shows setting things up with both.\n\nAlso, the ksql.ssl.keystore.alias.xxx in the example config aren't explained anywhere.\n\nI now give more elaborated explanations on it.\n\nConfiguring this stuff is normally a pain point for users, so the more hand-holding and the better the examples we can provide the better. To that end, I would encourage adding different sections for :\nConfiguring ksqlDB to use SSL mutual auth for inter-node comms and SSL server auth for client comms. This section should explain about the aliases configs and how these relate to the keystores - I'd be tempted to give a step-by-step guide of how to create the necessary keystores and truststores, so that its really clear where in the process the user defines the alias they later reference in the ksql.ssl.keystore.alias.xxx configs.\n\nI added a whole section on how to generate the keystore and trust store.  It seems like maybe this could live elsewhere, but it's right in the middle of things at the moment.\n\nConfiguring ksqlDB to use SSL mutual auth for inter-node comms only, (which assumes some other auth method on the client facing comms).\n\nAdded\n\nConfiguring ksqlDB to use jaas for external - does this require them to have specific paths in the exclude list for specific features to work? If it does, that's not really a workable solution going forward as that list will change.\n\nAdded.\nThis is what's used in one of my functional tests.  It requires no exclude lists.  That was one of the big changes I did was to have KSQL consider this request authenticated as a SystemUser.\n\nUsers generally customize their properties files and then upgrade by updating the jars only - can we have some single setting that turns off auth on internal calls?\n\nI'm confused by what you mean.  Do you want a flag that negates other auth settings and disables it?  At the moment, ksql.internal.ssl.client.authentication=NONE works more or less that way.  It may still use SSL on the internal connection, but it won't require verification on either side (server or client).\n\nConfiguring ksqlDB to use jaas for internal and external - if this is even possible?\n\nNot possible at the moment for internal.\n\nConfiguring ksqlDB to use a custom auth handler installed by the user - if this is even possible?\nI know the later points above are outside the scope of this PR - but now that we've got this new internal listener config we need to make sure the documentation covers the different valid combinations of auth setup for the listeners and make sure they are easy to configure. Of course, you can update the config in a follow-on PR. But document it we should - otherwise we've done all the hard work, but users will likely struggle to use the feature!\n\nI added documentation for the above cases.  I agree we should keep working on this and I'm open to doing followup work there.", "author": "AlanConfluent", "createdAt": "2020-06-04T22:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyMzE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNTQ5Ng==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433125496", "bodyText": "Can't this just be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (SystemAuthenticationHandler.hasAuthorization(routingContext)) {\n          \n          \n            \n                if (SystemAuthenticationHandler. isAuthenticatedAsSystemUser(routingContext)) {\n          \n      \n    \n    \n  \n\nNot sure the second hasAuthorization method adds anything here...", "author": "big-andy-coates", "createdAt": "2020-06-01T09:11:42Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/auth/KsqlAuthorizationProviderHandler.java", "diffHunk": "@@ -54,6 +54,11 @@ public void handle(final RoutingContext routingContext) {\n       return;\n     }\n \n+    if (SystemAuthenticationHandler.hasAuthorization(routingContext)) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4NTAwNQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435585005", "bodyText": "Ok.  Done.", "author": "AlanConfluent", "createdAt": "2020-06-04T22:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNTQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNTgwMg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433125802", "bodyText": "Nice! Thanks for grabbing this info.", "author": "big-andy-coates", "createdAt": "2020-06-01T09:12:25Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/auth/SystemAuthenticationHandler.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.auth;\n+\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.ClientAuth;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.AuthProvider;\n+import io.vertx.ext.auth.User;\n+import io.vertx.ext.web.RoutingContext;\n+import java.net.URI;\n+import java.security.Principal;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.net.ssl.SSLSession;\n+\n+public class SystemAuthenticationHandler implements Handler<RoutingContext> {\n+\n+  public SystemAuthenticationHandler() {}\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    final HttpConnection httpConnection = routingContext.request().connection();\n+    if (!httpConnection.isSsl()) {\n+      throw new IllegalStateException(\"Should only have ssl connections\");\n+    }\n+    final Principal peerPrincipal = getPeerPrincipal(httpConnection.sslSession());\n+    routingContext.setUser(new SystemUser(peerPrincipal));", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4NTIyOA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435585228", "bodyText": "\ud83d\udc4d", "author": "AlanConfluent", "createdAt": "2020-06-04T22:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNTgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNzAzMg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433127032", "bodyText": "Does this call fail is auth mode is set to NONE?\nIf that's the case, then we shouldn't be throwing an exception here is auth mode is controlled by the user, right? i.e. if they want internal communication encrypted, but don't care about mutual auth, then this shouldn't be failing.", "author": "big-andy-coates", "createdAt": "2020-06-01T09:15:13Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/auth/SystemAuthenticationHandler.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.auth;\n+\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.ClientAuth;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.AuthProvider;\n+import io.vertx.ext.auth.User;\n+import io.vertx.ext.web.RoutingContext;\n+import java.net.URI;\n+import java.security.Principal;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.net.ssl.SSLSession;\n+\n+public class SystemAuthenticationHandler implements Handler<RoutingContext> {\n+\n+  public SystemAuthenticationHandler() {}\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    final HttpConnection httpConnection = routingContext.request().connection();\n+    if (!httpConnection.isSsl()) {\n+      throw new IllegalStateException(\"Should only have ssl connections\");\n+    }\n+    final Principal peerPrincipal = getPeerPrincipal(httpConnection.sslSession());\n+    routingContext.setUser(new SystemUser(peerPrincipal));\n+    routingContext.next();\n+  }\n+\n+  private static Principal getPeerPrincipal(final SSLSession sslSession) {\n+    try {\n+      return sslSession.getPeerPrincipal();\n+    } catch (SSLPeerUnverifiedException e) {\n+      throw new IllegalStateException(\"Peer should always be verified\", e);\n+    }", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4NTU0OQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435585549", "bodyText": "If auth mode is set to None, this handler won't even be installed.  It's only installed when mutual auth is enabled.", "author": "AlanConfluent", "createdAt": "2020-06-04T22:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNzAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNzY1Ng==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433127656", "bodyText": "nit: This would be better as JavaDocs - either on the method, or on the class.   JavaDocs are available to developers within the IDE, e.g CTRL+J in my setup, these comments aren't.", "author": "big-andy-coates", "createdAt": "2020-06-01T09:16:37Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/auth/SystemAuthenticationHandler.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.auth;\n+\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.ClientAuth;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.AuthProvider;\n+import io.vertx.ext.auth.User;\n+import io.vertx.ext.web.RoutingContext;\n+import java.net.URI;\n+import java.security.Principal;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.net.ssl.SSLSession;\n+\n+public class SystemAuthenticationHandler implements Handler<RoutingContext> {\n+\n+  public SystemAuthenticationHandler() {}\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    final HttpConnection httpConnection = routingContext.request().connection();\n+    if (!httpConnection.isSsl()) {\n+      throw new IllegalStateException(\"Should only have ssl connections\");\n+    }\n+    final Principal peerPrincipal = getPeerPrincipal(httpConnection.sslSession());\n+    routingContext.setUser(new SystemUser(peerPrincipal));\n+    routingContext.next();\n+  }\n+\n+  private static Principal getPeerPrincipal(final SSLSession sslSession) {\n+    try {\n+      return sslSession.getPeerPrincipal();\n+    } catch (SSLPeerUnverifiedException e) {\n+      throw new IllegalStateException(\"Peer should always be verified\", e);\n+    }\n+  }\n+\n+  public static boolean isAuthenticatedAsSystemUser(final RoutingContext routingContext) {\n+    final User user = routingContext.user();\n+    return user instanceof SystemUser;\n+  }\n+\n+  public static boolean hasAuthorization(final RoutingContext routingContext) {\n+    return isAuthenticatedAsSystemUser(routingContext);\n+  }\n+\n+  public static Optional<SystemAuthenticationHandler> getSystemAuthenticationHandler(\n+      final Server server, final boolean isInternalListener) {\n+    // The requirements for being considered a system call on behalf of the SystemUser are that\n+    // SSL mutual auth is in effect for the connection (meaning that the request is verified to be\n+    // coming from a known set of servers in the cluster), and that it came on the internal\n+    // listener interface, meaning that it's being done with the authorization of the system\n+    // rather than directly on behalf of the user. Mutual auth is only enforced when SSL is used.", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4NTcxNw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435585717", "bodyText": "Good point.  Moved to java docs.", "author": "AlanConfluent", "createdAt": "2020-06-04T22:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNzY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzMzM0OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433133348", "bodyText": "Rather than passing isInternalListener to SystemAuthenticationHandler.getSystemAuthenticationHandler, why not just only call this method if isInternalListener is true?  This decouples SystemAuthenticationHandler from any concept of internal.\nPersonally, I'd be tempted to go further: I'd move the logic of when the system auth handler should be installed into this AuthHandlers class. i.e. move the getSystemAuthenticationHandler into this class.   Why?  It's generally a good pattern to separate the logic of when something should be used from the something itself.  This decoupling allows the same something to be used in the future in some other way without needing to be changed.\nThe systemAuthenticationHandler.ifPresent(handler -> router.route().handler(handler)); could then also be moved into the call.\nBut this is just a suggestion. Feel free to ignore me.", "author": "big-andy-coates", "createdAt": "2020-06-01T09:29:58Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/AuthHandlers.java", "diffHunk": "@@ -37,12 +38,17 @@\n   private AuthHandlers() {\n   }\n \n-  static void setupAuthHandlers(final Server server, final Router router) {\n+  static void setupAuthHandlers(final Server server, final Router router,\n+      final boolean isInternalListener) {\n     final Optional<AuthHandler> jaasAuthHandler = getJaasAuthHandler(server);\n     final KsqlSecurityExtension securityExtension = server.getSecurityExtension();\n     final Optional<AuthenticationPlugin> authenticationPlugin = server.getAuthenticationPlugin();\n     final Optional<Handler<RoutingContext>> pluginHandler =\n         authenticationPlugin.map(plugin -> new AuthenticationPluginHandler(server, plugin));\n+    final Optional<SystemAuthenticationHandler> systemAuthenticationHandler\n+        = SystemAuthenticationHandler.getSystemAuthenticationHandler(server, isInternalListener);", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4OTY3MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435589671", "bodyText": "I think it's generally good to have the isInternalListener in getSystemAuthenticationHandler so that all of the logic is in one place so it's easy to reason about.\nI'm fine to move getSystemAuthenticationHandler here.  I put it in SystemAuthenticationHandler to organize related logic together, but I get your point about decoupling installation from the logic itself.", "author": "AlanConfluent", "createdAt": "2020-06-04T22:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzMzM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDE2MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433134160", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            listener.getScheme().equalsIgnoreCase(\"https\"), isInternalListener),\n          \n          \n            \n                            listener.getScheme().equalsIgnoreCase(\"https\"), isInternalListener.orElse(false)),", "author": "big-andy-coates", "createdAt": "2020-06-01T09:31:54Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -115,7 +117,7 @@ public synchronized void start() {\n         final VertxCompletableFuture<String> vcf = new VertxCompletableFuture<>();\n         final ServerVerticle serverVerticle = new ServerVerticle(endpoints,\n             createHttpServerOptions(config, listener.getHost(), listener.getPort(),\n-                listener.getScheme().equalsIgnoreCase(\"https\")),\n+                listener.getScheme().equalsIgnoreCase(\"https\"), isInternalListener),", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDQyMg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435594422", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T22:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDI1OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433134258", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final Optional<Boolean> isInternalListener) {\n          \n          \n            \n                  final boolean isInternalListener) {", "author": "big-andy-coates", "createdAt": "2020-06-01T09:32:08Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -239,7 +241,8 @@ public int queryConnectionCount() {\n   }\n \n   private static HttpServerOptions createHttpServerOptions(final KsqlRestConfig ksqlRestConfig,\n-      final String host, final int port, final boolean tls) {\n+      final String host, final int port, final boolean tls,\n+      final Optional<Boolean> isInternalListener) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDQ1OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435594458", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T22:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDM1Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433134352", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (isInternalListener.isPresent() && isInternalListener.get()) {\n          \n          \n            \n                  if (isInternalListener) {", "author": "big-andy-coates", "createdAt": "2020-06-01T09:32:22Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -251,30 +254,54 @@ private static HttpServerOptions createHttpServerOptions(final KsqlRestConfig ks\n         .setPerFrameWebSocketCompressionSupported(true);\n \n     if (tls) {\n-      options.setUseAlpn(true).setSsl(true);\n-\n-      final String keyStorePath = ksqlRestConfig\n-          .getString(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n-      final Password keyStorePassword = ksqlRestConfig\n-          .getPassword(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG);\n-      if (keyStorePath != null && !keyStorePath.isEmpty()) {\n-        options.setKeyStoreOptions(\n-            new JksOptions().setPath(keyStorePath).setPassword(keyStorePassword.value()));\n+      final String externalAlias = ksqlRestConfig\n+          .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG);\n+      final String internalAlias = ksqlRestConfig\n+          .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+      if (isInternalListener.isPresent() && isInternalListener.get()) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDU1MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433134550", "bodyText": "nit: move these into the appropriate branch of the if/else?", "author": "big-andy-coates", "createdAt": "2020-06-01T09:32:51Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -251,30 +254,54 @@ private static HttpServerOptions createHttpServerOptions(final KsqlRestConfig ks\n         .setPerFrameWebSocketCompressionSupported(true);\n \n     if (tls) {\n-      options.setUseAlpn(true).setSsl(true);\n-\n-      final String keyStorePath = ksqlRestConfig\n-          .getString(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n-      final Password keyStorePassword = ksqlRestConfig\n-          .getPassword(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG);\n-      if (keyStorePath != null && !keyStorePath.isEmpty()) {\n-        options.setKeyStoreOptions(\n-            new JksOptions().setPath(keyStorePath).setPassword(keyStorePassword.value()));\n+      final String externalAlias = ksqlRestConfig\n+          .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG);\n+      final String internalAlias = ksqlRestConfig\n+          .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDUxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435594519", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T22:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0MzMzNg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433143336", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                AuthHandlers.setupAuthHandlers(server, router,\n          \n          \n            \n                    isInternalListener.isPresent() && isInternalListener.get());\n          \n          \n            \n                AuthHandlers.setupAuthHandlers(server, router,  isInternalListener.orElse(false));\n          \n      \n    \n    \n  \n\n??", "author": "big-andy-coates", "createdAt": "2020-06-01T09:53:56Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -118,7 +118,8 @@ private Router setupRouter() {\n     isInternalListener.ifPresent(isInternal ->\n         router.route().handler(new InternalEndpointHandler(isInternal)));\n \n-    AuthHandlers.setupAuthHandlers(server, router);\n+    AuthHandlers.setupAuthHandlers(server, router,\n+        isInternalListener.isPresent() && isInternalListener.get());", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5ODkxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435598919", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T23:03:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0MzMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NDQ2Ng==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433144466", "bodyText": "default value for the aliases in the config is an empty string. Adding a validator to the KsqlRestConfig  for the two alias configs can ensure the value is never null, making this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (keyStoreAlias != null && !keyStoreAlias.isEmpty()) {\n          \n          \n            \n                  if (!keyStoreAlias.isEmpty()) {", "author": "big-andy-coates", "createdAt": "2020-06-01T09:56:29Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -251,30 +254,54 @@ private static HttpServerOptions createHttpServerOptions(final KsqlRestConfig ks\n         .setPerFrameWebSocketCompressionSupported(true);\n \n     if (tls) {\n-      options.setUseAlpn(true).setSsl(true);\n-\n-      final String keyStorePath = ksqlRestConfig\n-          .getString(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n-      final Password keyStorePassword = ksqlRestConfig\n-          .getPassword(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG);\n-      if (keyStorePath != null && !keyStorePath.isEmpty()) {\n-        options.setKeyStoreOptions(\n-            new JksOptions().setPath(keyStorePath).setPassword(keyStorePassword.value()));\n+      final String externalAlias = ksqlRestConfig\n+          .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG);\n+      final String internalAlias = ksqlRestConfig\n+          .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+      if (isInternalListener.isPresent() && isInternalListener.get()) {\n+        setTlsOptions(ksqlRestConfig, options, internalAlias,\n+            ksqlRestConfig.getClientAuthInternal());\n+      } else {\n+        setTlsOptions(ksqlRestConfig, options, externalAlias, ksqlRestConfig.getClientAuth());\n       }\n+    }\n+    return options;\n+  }\n \n-      final String trustStorePath = ksqlRestConfig\n-          .getString(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n-      final Password trustStorePassword = ksqlRestConfig\n-          .getPassword(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG);\n-      if (trustStorePath != null && !trustStorePath.isEmpty()) {\n-        options.setTrustStoreOptions(\n-            new JksOptions().setPath(trustStorePath).setPassword(trustStorePassword.value()));\n+  private static void setTlsOptions(\n+      final KsqlRestConfig ksqlRestConfig,\n+      final HttpServerOptions options,\n+      final String keyStoreAlias,\n+      final ClientAuth clientAuth\n+  ) {\n+    options.setUseAlpn(true).setSsl(true);\n+\n+    final String keyStorePath = ksqlRestConfig\n+        .getString(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n+    final Password keyStorePassword = ksqlRestConfig\n+        .getPassword(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG);\n+    if (keyStorePath != null && !keyStorePath.isEmpty()) {\n+      final JksOptions keyStoreOptions = new JksOptions()\n+          .setPassword(keyStorePassword.value());\n+      if (keyStoreAlias != null && !keyStoreAlias.isEmpty()) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NTA0MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435595041", "bodyText": "Done.  If I have \"\" as the default, is there a way for it to ever be null?", "author": "AlanConfluent", "createdAt": "2020-06-04T22:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNTczMw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440115733", "bodyText": "Not sure. Maybe explicitly setting it via ksql.what.ever=null in the config file?  If that doesn't allow nulls then great!", "author": "big-andy-coates", "createdAt": "2020-06-15T11:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MzM3NA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440353374", "bodyText": "I tested that and it was the string \"null\" so I think we're good here.", "author": "AlanConfluent", "createdAt": "2020-06-15T18:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NDQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NTQ4MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433145481", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"\",\n          \n          \n            \n                        \"\",\n          \n          \n            \n                        new NonNullValidator(),", "author": "big-andy-coates", "createdAt": "2020-06-01T09:58:54Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java", "diffHunk": "@@ -364,6 +384,27 @@\n             Importance.MEDIUM,\n             \"\"\n         ).define(\n+            KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_CONFIG,\n+            Type.STRING,\n+            SSL_CLIENT_AUTHENTICATION_NONE,\n+            SSL_CLIENT_AUTHENTICATION_VALIDATOR,\n+            Importance.MEDIUM,\n+            KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_DOC\n+        ).define(\n+            KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG,\n+            Type.STRING,\n+            \"\",\n+            Importance.MEDIUM,\n+            KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_DOC\n+        )\n+        .define(\n+            KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG,\n+            Type.STRING,\n+            \"\",", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDcxMw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435604713", "bodyText": "Same here", "author": "AlanConfluent", "createdAt": "2020-06-04T23:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NTQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NTUwNw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433145507", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"\",\n          \n          \n            \n                        \"\",\n          \n          \n            \n                        new NonNullValidator(),", "author": "big-andy-coates", "createdAt": "2020-06-01T09:58:58Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java", "diffHunk": "@@ -364,6 +384,27 @@\n             Importance.MEDIUM,\n             \"\"\n         ).define(\n+            KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_CONFIG,\n+            Type.STRING,\n+            SSL_CLIENT_AUTHENTICATION_NONE,\n+            SSL_CLIENT_AUTHENTICATION_VALIDATOR,\n+            Importance.MEDIUM,\n+            KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_DOC\n+        ).define(\n+            KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG,\n+            Type.STRING,\n+            \"\",", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDYzOQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435604639", "bodyText": "I tested it out by passing \"null\" and empty string and I can't get it to be null when it has a default as \"\".  I'm pretty sure this validator isn't required.", "author": "AlanConfluent", "createdAt": "2020-06-04T23:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NTUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNTA3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440115072", "bodyText": "cool", "author": "big-andy-coates", "createdAt": "2020-06-15T11:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NTUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODA2MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433148060", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (trustStoreLocation != null) {\n          \n          \n            \n                  if (trustStoreLocation != null && !trustStoreLocation.isEmpty()) {\n          \n      \n    \n    \n  \n\n???", "author": "big-andy-coates", "createdAt": "2020-06-01T10:05:20Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -164,5 +167,50 @@ private static HttpClientOptions createClientOptions() {\n     return clientProps;\n   }\n \n+  private static Consumer<HttpClientOptions> prepareHttpOptionsForSSL(\n+      final Map<String, String> clientProps, final boolean verifyHost) {\n+    return (httpClientOptions) -> {\n+      httpClientOptions.setVerifyHost(verifyHost);\n+      httpClientOptions.setSsl(true);\n+      final String internalAlias = clientProps\n+          .get(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+      final String trustStoreLocation = clientProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+      if (trustStoreLocation != null) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNTE5OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435605198", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T23:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODQwMQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433148401", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (keyStoreLocation != null) {\n          \n          \n            \n                    if (keyStoreLocation != null && !keyStoreLocation.isEmpty()) {\n          \n      \n    \n    \n  \n\n???\nPITA these configs don't default to \"\" and have a validator to ensure they're not null!", "author": "big-andy-coates", "createdAt": "2020-06-01T10:06:05Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -164,5 +167,50 @@ private static HttpClientOptions createClientOptions() {\n     return clientProps;\n   }\n \n+  private static Consumer<HttpClientOptions> prepareHttpOptionsForSSL(\n+      final Map<String, String> clientProps, final boolean verifyHost) {\n+    return (httpClientOptions) -> {\n+      httpClientOptions.setVerifyHost(verifyHost);\n+      httpClientOptions.setSsl(true);\n+      final String internalAlias = clientProps\n+          .get(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+      final String trustStoreLocation = clientProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+      if (trustStoreLocation != null) {\n+        final String suppliedTruststorePassword = clientProps\n+            .get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG);\n+        httpClientOptions.setTrustStoreOptions(new JksOptions().setPath(trustStoreLocation)\n+            .setPassword(suppliedTruststorePassword == null ? \"\" : suppliedTruststorePassword));\n+\n+        final String keyStoreLocation = clientProps.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n+        if (keyStoreLocation != null) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNzQ0MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435607441", "bodyText": "I wasn't able to get this to have a null value, even when I don't set it...  It appears to have a default of \"\".", "author": "AlanConfluent", "createdAt": "2020-06-04T23:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODg0Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433148842", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      if (internalAlias != null && !internalAlias.isEmpty()) {\n          \n          \n            \n                      if (!internalAlias.isEmpty()) {\n          \n      \n    \n    \n  \n\nThis one we control, so can have suitable defaults and validators to ensure never null.", "author": "big-andy-coates", "createdAt": "2020-06-01T10:07:09Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -164,5 +167,50 @@ private static HttpClientOptions createClientOptions() {\n     return clientProps;\n   }\n \n+  private static Consumer<HttpClientOptions> prepareHttpOptionsForSSL(\n+      final Map<String, String> clientProps, final boolean verifyHost) {\n+    return (httpClientOptions) -> {\n+      httpClientOptions.setVerifyHost(verifyHost);\n+      httpClientOptions.setSsl(true);\n+      final String internalAlias = clientProps\n+          .get(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+      final String trustStoreLocation = clientProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+      if (trustStoreLocation != null) {\n+        final String suppliedTruststorePassword = clientProps\n+            .get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG);\n+        httpClientOptions.setTrustStoreOptions(new JksOptions().setPath(trustStoreLocation)\n+            .setPassword(suppliedTruststorePassword == null ? \"\" : suppliedTruststorePassword));\n+\n+        final String keyStoreLocation = clientProps.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n+        if (keyStoreLocation != null) {\n+          final String suppliedKeyStorePassord = Strings.nullToEmpty(clientProps\n+              .get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG));\n+          final JksOptions keyStoreOptions = new JksOptions()\n+              .setPassword(suppliedKeyStorePassord);\n+          if (internalAlias != null && !internalAlias.isEmpty()) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwODU2Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435608562", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T23:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0OTE5Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433149192", "bodyText": "Does this work if mode is REQUESTED?", "author": "big-andy-coates", "createdAt": "2020-06-01T10:08:01Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -164,5 +167,50 @@ private static HttpClientOptions createClientOptions() {\n     return clientProps;\n   }\n \n+  private static Consumer<HttpClientOptions> prepareHttpOptionsForSSL(\n+      final Map<String, String> clientProps, final boolean verifyHost) {\n+    return (httpClientOptions) -> {\n+      httpClientOptions.setVerifyHost(verifyHost);\n+      httpClientOptions.setSsl(true);\n+      final String internalAlias = clientProps\n+          .get(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+      final String trustStoreLocation = clientProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+      if (trustStoreLocation != null) {\n+        final String suppliedTruststorePassword = clientProps\n+            .get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG);\n+        httpClientOptions.setTrustStoreOptions(new JksOptions().setPath(trustStoreLocation)\n+            .setPassword(suppliedTruststorePassword == null ? \"\" : suppliedTruststorePassword));\n+\n+        final String keyStoreLocation = clientProps.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n+        if (keyStoreLocation != null) {\n+          final String suppliedKeyStorePassord = Strings.nullToEmpty(clientProps\n+              .get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG));\n+          final JksOptions keyStoreOptions = new JksOptions()\n+              .setPassword(suppliedKeyStorePassord);\n+          if (internalAlias != null && !internalAlias.isEmpty()) {\n+            keyStoreOptions.setValue(KeystoreUtil.getKeyStore(\n+                keyStoreLocation, suppliedKeyStorePassord, internalAlias));\n+          } else {\n+            keyStoreOptions.setPath(keyStoreLocation);\n+          }\n+          httpClientOptions.setKeyStoreOptions(keyStoreOptions);\n+        }\n+      }\n+    };\n+  }\n \n+  private static KsqlClient getInternalClient(final Map<String, String> clientProps,\n+      final Optional<HostAliasResolver> hostAliasResolver) {\n+    final boolean verifyHost =\n+        !KsqlRestConfig.SSL_CLIENT_AUTHENTICATION_NONE.equals(clientProps.get(\n+        KsqlRestConfig.KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_CONFIG));", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNzQ1MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435617450", "bodyText": "If the server requires anything other than NONE for requesting clients, then then it will also verify identities as a requesting client when doing internal communication.  If REQUESTED is done, while https is in use, it requires that their certs check out.\nThis is a little arbitrary.  I wanted a simple way to allow for having https, but not doing verification here (i.e. \"NONE\") without introducing another config.  What do you think?", "author": "AlanConfluent", "createdAt": "2020-06-04T23:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0OTE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0OTcyMw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433149723", "bodyText": "Better to encode the optionality of password into the signature of the method? i.e. Optional<String> password?", "author": "big-andy-coates", "createdAt": "2020-06-01T10:09:12Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/util/KeystoreUtil.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.util;\n+\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.buffer.Buffer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class KeystoreUtil {\n+  private static final Logger LOG = LoggerFactory.getLogger(KeystoreUtil.class);\n+  private static final String KEYSTORE_TYPE = \"JKS\";\n+\n+  private KeystoreUtil() {}\n+\n+  /**\n+   * Utility to fetch a Vert.x Buffer that is the serialized version of the key store from the\n+   * given path, but which contains only the entry for the given alias.  This circumvents Vert.x's\n+   * direct support of an alias option.\n+   * @param keyStorePath The original key store which may contain multiple certificates\n+   * @param password The key store password\n+   * @param alias The alias of the entry to extract\n+   * @return The Buffer containing the keystore\n+   */\n+  public static Buffer getKeyStore(\n+      final String keyStorePath,\n+      final String password,\n+      final String alias\n+  ) {\n+    final char[] pw = password != null ? password.toCharArray() : null;", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODI3MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435618271", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T23:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0OTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MDM5MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433150390", "bodyText": "Is this assuming the same password for the keystore and the key?  Isn't it possible these are different?", "author": "big-andy-coates", "createdAt": "2020-06-01T10:10:47Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/util/KeystoreUtil.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.util;\n+\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.buffer.Buffer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class KeystoreUtil {\n+  private static final Logger LOG = LoggerFactory.getLogger(KeystoreUtil.class);\n+  private static final String KEYSTORE_TYPE = \"JKS\";\n+\n+  private KeystoreUtil() {}\n+\n+  /**\n+   * Utility to fetch a Vert.x Buffer that is the serialized version of the key store from the\n+   * given path, but which contains only the entry for the given alias.  This circumvents Vert.x's\n+   * direct support of an alias option.\n+   * @param keyStorePath The original key store which may contain multiple certificates\n+   * @param password The key store password\n+   * @param alias The alias of the entry to extract\n+   * @return The Buffer containing the keystore\n+   */\n+  public static Buffer getKeyStore(\n+      final String keyStorePath,\n+      final String password,\n+      final String alias\n+  ) {\n+    final char[] pw = password != null ? password.toCharArray() : null;\n+    final KeyStore keyStore = loadExistingKeyStore(keyStorePath, pw);\n+\n+    final PrivateKey key;\n+    final Certificate[] chain;\n+    try {\n+      key = (PrivateKey) keyStore.getKey(alias, pw);\n+      chain = keyStore.getCertificateChain(alias);", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODI5OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435618298", "bodyText": "You're right.  Made it a separate parameter.  By default, I'm passing the same password for both, since we don't appear to use the key password in ksql at the moment.\nThe keytool will use the same password for keys as for the keystore if you don't provide a separate one, so this seems like the default behavior.", "author": "AlanConfluent", "createdAt": "2020-06-04T23:50:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MDM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MDY1Ng==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433150656", "bodyText": "Include the alias in the message to make it clear which is failing?", "author": "big-andy-coates", "createdAt": "2020-06-01T10:11:19Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/util/KeystoreUtil.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.util;\n+\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.buffer.Buffer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class KeystoreUtil {\n+  private static final Logger LOG = LoggerFactory.getLogger(KeystoreUtil.class);\n+  private static final String KEYSTORE_TYPE = \"JKS\";\n+\n+  private KeystoreUtil() {}\n+\n+  /**\n+   * Utility to fetch a Vert.x Buffer that is the serialized version of the key store from the\n+   * given path, but which contains only the entry for the given alias.  This circumvents Vert.x's\n+   * direct support of an alias option.\n+   * @param keyStorePath The original key store which may contain multiple certificates\n+   * @param password The key store password\n+   * @param alias The alias of the entry to extract\n+   * @return The Buffer containing the keystore\n+   */\n+  public static Buffer getKeyStore(\n+      final String keyStorePath,\n+      final String password,\n+      final String alias\n+  ) {\n+    final char[] pw = password != null ? password.toCharArray() : null;\n+    final KeyStore keyStore = loadExistingKeyStore(keyStorePath, pw);\n+\n+    final PrivateKey key;\n+    final Certificate[] chain;\n+    try {\n+      key = (PrivateKey) keyStore.getKey(alias, pw);\n+      chain = keyStore.getCertificateChain(alias);\n+    } catch (Exception e) {\n+      throw new KsqlException(\"Error fetching key/certificate\", e);", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyNTA0NQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435625045", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-05T00:16:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MDY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MTM1OQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433151359", "bodyText": "Why not use try-with-resource, removing the need for finally block\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                try {\n          \n          \n            \n                try (FileInputStream input = new InputStream(keyStoreParth) {", "author": "big-andy-coates", "createdAt": "2020-06-01T10:12:59Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/util/KeystoreUtil.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.util;\n+\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.buffer.Buffer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class KeystoreUtil {\n+  private static final Logger LOG = LoggerFactory.getLogger(KeystoreUtil.class);\n+  private static final String KEYSTORE_TYPE = \"JKS\";\n+\n+  private KeystoreUtil() {}\n+\n+  /**\n+   * Utility to fetch a Vert.x Buffer that is the serialized version of the key store from the\n+   * given path, but which contains only the entry for the given alias.  This circumvents Vert.x's\n+   * direct support of an alias option.\n+   * @param keyStorePath The original key store which may contain multiple certificates\n+   * @param password The key store password\n+   * @param alias The alias of the entry to extract\n+   * @return The Buffer containing the keystore\n+   */\n+  public static Buffer getKeyStore(\n+      final String keyStorePath,\n+      final String password,\n+      final String alias\n+  ) {\n+    final char[] pw = password != null ? password.toCharArray() : null;\n+    final KeyStore keyStore = loadExistingKeyStore(keyStorePath, pw);\n+\n+    final PrivateKey key;\n+    final Certificate[] chain;\n+    try {\n+      key = (PrivateKey) keyStore.getKey(alias, pw);\n+      chain = keyStore.getCertificateChain(alias);\n+    } catch (Exception e) {\n+      throw new KsqlException(\"Error fetching key/certificate\", e);\n+    }\n+\n+    if (key == null || chain == null) {\n+      throw new KsqlException(\"Alias doesn't exist in keystore: \" + alias);\n+    }\n+\n+    final byte[] singleValueKeyStore = createSingleValueKeyStore(key, chain, pw, alias);\n+    return Buffer.buffer(singleValueKeyStore);\n+  }\n+\n+  private static KeyStore loadExistingKeyStore(final String keyStorePath, final char[] pw) {\n+    FileInputStream input = null;\n+    try {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyNTgyNQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435625825", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-05T00:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MTM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MTc3MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433151770", "bodyText": "input stream leak...\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  keyStore.load(new FileInputStream(keyStorePath), pw);\n          \n          \n            \n                  keyStore.load(input, pw);", "author": "big-andy-coates", "createdAt": "2020-06-01T10:14:03Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/util/KeystoreUtil.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.util;\n+\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.buffer.Buffer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class KeystoreUtil {\n+  private static final Logger LOG = LoggerFactory.getLogger(KeystoreUtil.class);\n+  private static final String KEYSTORE_TYPE = \"JKS\";\n+\n+  private KeystoreUtil() {}\n+\n+  /**\n+   * Utility to fetch a Vert.x Buffer that is the serialized version of the key store from the\n+   * given path, but which contains only the entry for the given alias.  This circumvents Vert.x's\n+   * direct support of an alias option.\n+   * @param keyStorePath The original key store which may contain multiple certificates\n+   * @param password The key store password\n+   * @param alias The alias of the entry to extract\n+   * @return The Buffer containing the keystore\n+   */\n+  public static Buffer getKeyStore(\n+      final String keyStorePath,\n+      final String password,\n+      final String alias\n+  ) {\n+    final char[] pw = password != null ? password.toCharArray() : null;\n+    final KeyStore keyStore = loadExistingKeyStore(keyStorePath, pw);\n+\n+    final PrivateKey key;\n+    final Certificate[] chain;\n+    try {\n+      key = (PrivateKey) keyStore.getKey(alias, pw);\n+      chain = keyStore.getCertificateChain(alias);\n+    } catch (Exception e) {\n+      throw new KsqlException(\"Error fetching key/certificate\", e);\n+    }\n+\n+    if (key == null || chain == null) {\n+      throw new KsqlException(\"Alias doesn't exist in keystore: \" + alias);\n+    }\n+\n+    final byte[] singleValueKeyStore = createSingleValueKeyStore(key, chain, pw, alias);\n+    return Buffer.buffer(singleValueKeyStore);\n+  }\n+\n+  private static KeyStore loadExistingKeyStore(final String keyStorePath, final char[] pw) {\n+    FileInputStream input = null;\n+    try {\n+      input = new FileInputStream(keyStorePath);\n+      final KeyStore keyStore = KeyStore.getInstance(KEYSTORE_TYPE);\n+      keyStore.load(new FileInputStream(keyStorePath), pw);", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyNTg4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435625883", "bodyText": "oops.  Good catch", "author": "AlanConfluent", "createdAt": "2020-06-05T00:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MTc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NDE0Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433154142", "bodyText": "why are we passing in a consumer that is just called back with the httpClientOptions passed in?  This feels like an anti-pattern to me.", "author": "big-andy-coates", "createdAt": "2020-06-01T10:20:10Z", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -44,27 +45,50 @@\n   private final HttpClient httpTlsClient;\n   private final LocalProperties localProperties;\n   private final Optional<String> basicAuthHeader;\n+  private final Optional<HostAliasResolver> hostAliasResolver;\n \n   public KsqlClient(\n       final Map<String, String> clientProps,\n       final Optional<BasicCredentials> credentials,\n       final LocalProperties localProperties,\n-      final HttpClientOptions httpClientOptions\n+      final HttpClientOptions httpClientOptions,\n+      final Optional<HostAliasResolver> hostAliasResolver\n   ) {\n     this.vertx = Vertx.vertx();\n     this.basicAuthHeader = createBasicAuthHeader(\n         Objects.requireNonNull(credentials, \"credentials\"));\n     this.localProperties = Objects.requireNonNull(localProperties, \"localProperties\");\n+    this.hostAliasResolver = Objects.requireNonNull(hostAliasResolver, \"hostAliasResolver\");\n     this.httpNonTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, false);\n     this.httpTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, true);\n   }\n \n+  public KsqlClient(\n+      final Optional<BasicCredentials> credentials,\n+      final LocalProperties localProperties,\n+      final HttpClientOptions httpClientOptions,\n+      final Consumer<HttpClientOptions> sslHttpClientOptionsConsumer,", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzMzY0OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435633648", "bodyText": "Because it's only used when SSL is used...  I agree I don't like it.  I'll instead pass in a Function<Boolean, HttpClientOptions> factory that takes in if it's ssl in place of this as well as the HttpClientOptions before it.", "author": "AlanConfluent", "createdAt": "2020-06-05T00:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NDE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NDYwNg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433154606", "bodyText": "Rather than store a Optional<HostResolver>, why not default to a HostResolver impl that just returns the value passed? e.g. Function.identify().  This would simplify this code.", "author": "big-andy-coates", "createdAt": "2020-06-01T10:21:22Z", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -44,27 +45,50 @@\n   private final HttpClient httpTlsClient;\n   private final LocalProperties localProperties;\n   private final Optional<String> basicAuthHeader;\n+  private final Optional<HostAliasResolver> hostAliasResolver;\n \n   public KsqlClient(\n       final Map<String, String> clientProps,\n       final Optional<BasicCredentials> credentials,\n       final LocalProperties localProperties,\n-      final HttpClientOptions httpClientOptions\n+      final HttpClientOptions httpClientOptions,\n+      final Optional<HostAliasResolver> hostAliasResolver\n   ) {\n     this.vertx = Vertx.vertx();\n     this.basicAuthHeader = createBasicAuthHeader(\n         Objects.requireNonNull(credentials, \"credentials\"));\n     this.localProperties = Objects.requireNonNull(localProperties, \"localProperties\");\n+    this.hostAliasResolver = Objects.requireNonNull(hostAliasResolver, \"hostAliasResolver\");\n     this.httpNonTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, false);\n     this.httpTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, true);\n   }\n \n+  public KsqlClient(\n+      final Optional<BasicCredentials> credentials,\n+      final LocalProperties localProperties,\n+      final HttpClientOptions httpClientOptions,\n+      final Consumer<HttpClientOptions> sslHttpClientOptionsConsumer,\n+      final Optional<HostAliasResolver> hostAliasResolver\n+  ) {\n+    this.vertx = Vertx.vertx();\n+    this.basicAuthHeader = createBasicAuthHeader(\n+        Objects.requireNonNull(credentials, \"credentials\"));\n+    this.localProperties = Objects.requireNonNull(localProperties, \"localProperties\");\n+    this.hostAliasResolver = Objects.requireNonNull(hostAliasResolver, \"hostAliasResolver\");\n+    this.httpNonTlsClient = createHttpClient(vertx, httpClientOptions, sslHttpClientOptionsConsumer,\n+        false);\n+    this.httpTlsClient = createHttpClient(vertx, httpClientOptions, sslHttpClientOptionsConsumer,\n+        true);\n+  }\n+\n   public KsqlTarget target(final URI server) {\n     final boolean isUriTls = server.getScheme().equalsIgnoreCase(\"https\");\n     final HttpClient client = isUriTls ? httpTlsClient : httpNonTlsClient;\n+    final String aliasHost = hostAliasResolver.map(resolver -> resolver.resolve(server.getHost()))\n+        .orElse(server.getHost());", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY1ODY5MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435658690", "bodyText": "I effectively did this with your BiFunction<Integer, String, SocketAddress> socketAddressFactory suggestion.", "author": "AlanConfluent", "createdAt": "2020-06-05T02:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NDYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NTYxNw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433155617", "bodyText": "It seems a shame to require every use of this production class to supply a HostAliasResolver, given this should only be passed for test cases, right?  And most test cases won't need this either. Just one or two specific tests that are testing the new code you're adding. Yet HostAliasResolver is mentioned around 40 times in this PR.\nIs there another way?\nAt the very least you could remove this parameter from this constructor and add another constructor, annotated with @VisibleForTesting that takes the resolver.  However, ideally, the production code should know nothing of HostAliasResolver...\nI think this can be achieved by injecting an interface to handle the SocketAddress.inetSocketAddress call.   So rather than taking a HostAliasResolver the @VisiableForTesting constructor takes BiFunction<Integer, String, SocketAddress> socketAddressFactory.  Test code can then use this to perform the same aliasing that HostAliasResolver does now.   Please see if you can remove HostAliasResolver from the production code base, or at least from the non- @VisibleForTesting constructors.\nSocketAddress.inetSocketAddress(server.getPort(), aliasHost)", "author": "big-andy-coates", "createdAt": "2020-06-01T10:23:57Z", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -44,27 +45,50 @@\n   private final HttpClient httpTlsClient;\n   private final LocalProperties localProperties;\n   private final Optional<String> basicAuthHeader;\n+  private final Optional<HostAliasResolver> hostAliasResolver;\n \n   public KsqlClient(\n       final Map<String, String> clientProps,\n       final Optional<BasicCredentials> credentials,\n       final LocalProperties localProperties,\n-      final HttpClientOptions httpClientOptions\n+      final HttpClientOptions httpClientOptions,\n+      final Optional<HostAliasResolver> hostAliasResolver", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzMzEwNQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435633105", "bodyText": "Yeah, I agree I didn't really like having to add this, but you need some \"seam\" to inject the test version.\nNice suggestion. I did the factory as you mentioned.  A named interface is definitely a little misleading for test-only code.  Now I have a @VisibleForTesting constructor where I take it, and the other just uses the default SocketAddress::inetSocketAddress.", "author": "AlanConfluent", "createdAt": "2020-06-05T00:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NTYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MDE5OQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433160199", "bodyText": "why are we passing in host here? I'm assuming this is different to socketAddress.getHost.  This is really counter-intuitive and the kind of thing that will trip people up later when they make changes to this class.\nIs there any reason by you can't just change the calling code to pass in the right socketAdrress?", "author": "big-andy-coates", "createdAt": "2020-06-01T10:34:59Z", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlTarget.java", "diffHunk": "@@ -73,28 +73,31 @@\n   private final SocketAddress socketAddress;\n   private final LocalProperties localProperties;\n   private final Optional<String> authHeader;\n+  private final String host;\n \n   KsqlTarget(\n       final HttpClient httpClient,\n       final SocketAddress socketAddress,\n       final LocalProperties localProperties,\n-      final Optional<String> authHeader\n+      final Optional<String> authHeader,\n+      final String host", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY2MzkzNw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435663937", "bodyText": "This host value is what's passed to the server as the host header rather than what's used to actually connect.  This is what allows you to connect to localhost while claiming you're talking to example.com and to compare the returned cert to example.com.\nI agree it's a little confusing, though this is the exact API we use in Vert.x: https://vertx.io/docs/apidocs/io/vertx/core/http/HttpClient.html#request-io.vertx.core.http.HttpMethod-io.vertx.core.net.SocketAddress-int-java.lang.String-java.lang.String-io.vertx.core.Handler-\nThe difference there is that they have a lot of overloaded versions that don't require this additional host parameter, so you have to read about it if you want to us it.  I tried adding documentation.  Tell me if you have other ideas.  (One such thing might be taking in arbitrary headers and then I could set the host header explicitly, and use the socketAddress.host() as before, though I don't really consider this cleaner).", "author": "AlanConfluent", "createdAt": "2020-06-05T02:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MDE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyMDQ3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440120472", "bodyText": "Looks good.", "author": "big-andy-coates", "createdAt": "2020-06-15T11:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MDE5OQ=="}], "type": "inlineReview"}, {"oid": "8c465a732a69fe85cfdc91b1eee10944ae62f419", "url": "https://github.com/confluentinc/ksql/commit/8c465a732a69fe85cfdc91b1eee10944ae62f419", "message": "More feedback", "committedDate": "2020-06-05T03:08:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3NzA4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440077083", "bodyText": "Link to the markdown docs so that the links work in Github!\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.html#configuring-listeners-of-a-ksqldb-cluster).\n          \n          \n            \n            For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.md#configuring-listeners-of-a-ksqldb-cluster).", "author": "big-andy-coates", "createdAt": "2020-06-15T10:22:08Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,6 +219,134 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n+Configure ksqlDB for Internal Authentication\n+--------------------------------------------\n+\n+ksqlDB supports securing inter-node communication using SSL mutual authentication.\n+\n+For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.html#configuring-listeners-of-a-ksqldb-cluster).", "originalCommit": "dc801b4f9a8ab90b578d343bdc5e7003e7d2dec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NzM1Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440347353", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-15T17:54:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3NzA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA4NjI2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440086265", "bodyText": "Add recommendation about using SSL encryption for external listener if using plain-text BASIC http auth - or better still, just update the example to use SSL-client-auth.\nThe existing Configure ksqlDB for Basic HTTP Authentication section has such a recommendation. Equally this existing section could be updated to do-the-right-thing and have both BASIC and SSL client auth.", "author": "big-andy-coates", "createdAt": "2020-06-15T10:40:12Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,6 +219,134 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n+Configure ksqlDB for Internal Authentication\n+--------------------------------------------\n+\n+ksqlDB supports securing inter-node communication using SSL mutual authentication.\n+\n+For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.html#configuring-listeners-of-a-ksqldb-cluster).\n+\n+### Using Authentication on the Internal Listener\n+\n+Your key store must contain the key pair for your internal listener set with\n+`ksql.internal.listener`.  If your internal certificate is not signed by a recognized\n+public Certificate Authority, a trust store is required to contain certificates for\n+nodes in your cluster.  Below is an example configuration:\n+\n+```properties\n+# Contains the internal key pair for this node.\n+# (e.g. key pair for node-1.internal.example.com)\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# Contains the certificates for nodes in the cluster.\n+# (e.g. certs for node-1.internal.example.com, node-2.internal.example.com)\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+# This enables mutual auth checking for the internal listener\n+ksql.internal.ssl.client.authentication=REQUIRED\n+```\n+\n+### Using Authentication for Both the Internal and External Listener\n+\n+Client facing basic HTTP authentication can be used alongside authentication for the ", "originalCommit": "dc801b4f9a8ab90b578d343bdc5e7003e7d2dec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2NTkyNg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440465926", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-15T21:48:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA4NjI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA5MjM3NA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440092374", "bodyText": "I've just had a look at what's already in this document and I think, rather than adding a brand new section, the details you're covering need to be integrated with what is already there.\nCurrently, the sections above cover:\n\n\"Configuring ksqlDB for HTTPS\" i.e. External encrypted using SSL-client auth.\n\n'Configure the CLI for HTTPS', i.e. CLI side config needed to talk to server over ssl.\n\n\n\"Configure ksqlDB for Basic HTTP Authentication\", i.e. External secured using HTTP-BASIC auth.\n\n'Configure the CLI for Basic HTTP Authentication', i.e. CLI config needed for HTTP-BASIC.\n\n\n\nNOTE: the text right at the top of the doc, which is an index of sorts, link to the above sections.\nThen the sections you've added are:\n\nInternal secured using SSL-mutual auth\nInternal secured using SSL-mutual auth + External secured using HTTP-BASIC auth.\nInternal secured using SSL-mutual auth + External encrypted using SSL-client auth\n\nNOTE: the text right at the top of the doc needs updating to link to your new sections.\nOthers have also previously added new sections without updating the preamble / index at the top. So we could do with fixing that.\nRecommended structure:\nWhat I'd recommend is updating the blurb at the top to something that calls out 'single listener' vs 'dual listener' difference, and 'authentication' vs 'encryption' and links to appropriate sections, and includes links to any new sections added by others. Maybe something like the following.\nNote: Each index level would link to the appropriate section in the doc below. Each configuration section title clearly states, in a consistent manner, what's being configured.  This will allow people to jump to the big they need.\nIt also directs ccloud users away to the ccloud docs, allowing this page to focus on the on-prem setup.\n\nksqlDB supports several combinations of encryption and authentication on its client-facing and internal endpoints, and also supports many of the security features of the other services it communicates with, like {{ site.aktm }} and {{ site.sr }}.\n\nSecuring ksqlDB on Confluent Cloud\nSecuring ksqlDB on premise\n\nSecuring ksqlDB installation\n\nSecuring interactive deployments\n\nSecuring single listener setup\n\nConfiguring listener for SSL encryption\nConfiguring listener for HTTP-BASIC authentication\nConfiguring listener for JAAS authentication\n\n\nSecuring dual listener setup\n\nConfiguring internal for SSL-mutual authentication\nConfiguring internal for SSL-mutual authentication + external for SSL encryption\nConfiguring internal for SSL-mutual authentication + external for HTTP-BASIC authentication\nConfiguring internal for SSL-mutual authentication + external for JAAS authentication\n\n\nSecuring headless deployments\n\n\n\n\nSecuring communication with other services\n\nConfigure ksqlDB for Confluent Control Center\nConfigure ksqlDB for Secured Confluent Schema Registry\nConfigure ksqlDB for Secured Apache Kafka clusters\n\nConfiguring Kafka Encrypted Communication\nConfigure Kafka Authentication\nConfigure Authorization of ksqlDB with Kafka ACLs\n\nConfluent Platform v5.0 (Apache Kafka v2.0) and above\nConfluent Platform versions below v5.0 (Apache Kafka < v2.0)\n\n\n\n\n\n\n\n\n\n\nThen each section heading can explain the top level items that come within it. For example:\n\nSecuring ksqlDB on premise\nThis section covers how to secure installations of ksqlDB outside of Confluent Cloud, e.g. on-premise installations or manual installations on other cloud platforms.\nThe section is split into:\n\nSecuring ksqlDB installation: covering how to secure access to ksqlDB itself and its own internal communication.\nSecuring communication with other services: covering how to secure communication with other services and access to the resources they hold.\n\nSecuring ksqlDB installation\nksqlDB supports two main deployment modes:\n\nSecuring interactive deployments: interactive deployments are those where the ksqlDB servers accept client connections.\nSecuring headless deployments: headless deployments are those where the ksqlDB servers do not accept client connections. They read the SQL statements they should run from a file on-disk.\n\nSecuring interactive deployments\nSecuring the interactive ksqlDB installation involves securing the HTTP endpoints the ksqlDB server is listening on.\nAs well as accepting connections and requests from clients, a multi-node ksqlDB cluster also requires inter-node communications.  You can choose to configure the external client and internal inter-node communication  separately or over a single listener:\n\nSecuring single listener setup:  ideal for single-node installations, or where the inter-node communication is over the same network interfaces as client communication.\nSecuring dual listener setup: useful where inter-node communication is over a different network interfaces or requires different authentication or encryption configuration.\n\n\nI'm sure you get the idea!\nAlso, take a look at the existing preamble text at the top. I'm sure there's useful information in there.  I'd be restructuring it and moving it into the appropriate sections. e.g. the bit about how to pass the config file to the server should be in the Securing ksqlDB on premise section.", "author": "big-andy-coates", "createdAt": "2020-06-15T10:52:56Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,6 +219,134 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n+Configure ksqlDB for Internal Authentication", "originalCommit": "dc801b4f9a8ab90b578d343bdc5e7003e7d2dec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ5MTkyMw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440491923", "bodyText": "I've just had a look at what's already in this document and I think, rather than adding a brand new section, the details you're covering need to be integrated with what is already there.\n\nI followed your instructions fairly closely, so I think we're good there.\n@JimGalasyn Can you take a look at my docs changes again?  Also, How can I verify that the local anchor links work correctly?  None of my tools allow for checking this.", "author": "AlanConfluent", "createdAt": "2020-06-15T22:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA5MjM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExMTgwNw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440111807", "bodyText": "Maybe include ksql.ssl.client.authentication= whatever, just so users are aware?", "author": "big-andy-coates", "createdAt": "2020-06-15T11:33:07Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,6 +219,134 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n+Configure ksqlDB for Internal Authentication\n+--------------------------------------------\n+\n+ksqlDB supports securing inter-node communication using SSL mutual authentication.\n+\n+For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.html#configuring-listeners-of-a-ksqldb-cluster).\n+\n+### Using Authentication on the Internal Listener\n+\n+Your key store must contain the key pair for your internal listener set with\n+`ksql.internal.listener`.  If your internal certificate is not signed by a recognized\n+public Certificate Authority, a trust store is required to contain certificates for\n+nodes in your cluster.  Below is an example configuration:\n+\n+```properties\n+# Contains the internal key pair for this node.\n+# (e.g. key pair for node-1.internal.example.com)\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# Contains the certificates for nodes in the cluster.\n+# (e.g. certs for node-1.internal.example.com, node-2.internal.example.com)\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+# This enables mutual auth checking for the internal listener\n+ksql.internal.ssl.client.authentication=REQUIRED\n+```\n+\n+### Using Authentication for Both the Internal and External Listener\n+\n+Client facing basic HTTP authentication can be used alongside authentication for the \n+internal listener. This ensures that neither the client or internal\n+APIs can be accessed by unauthorized users.\n+Below is an example configuration:\n+\n+```properties\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+ksql.internal.ssl.client.authentication=REQUIRED\n+\n+authentication.method=BASIC\n+authentication.roles=admin,developer,user,ksq-user\n+authentication.realm=KsqlServer-Props\n+\n+```\n+\n+For more detail on basic authentication, \n+[see above](#configure-ksqldb-for-basic-http-authentication).\n+\n+### Configuring HTTPS on the Internal and External Listeners\n+\n+If you want to use HTTPS on `listeners` as well as use SSL mutual\n+auth for internal communication on `ksql.internal.listener`, you will likely\n+require two different key pairs, since your host's identity to clients may be\n+different from its internal identity.  In order to create such a key store,\n+refer [below](#setting-up-a-key-store-and-trust-store).\n+\n+In such a configuration, you must specify which key pair is used for a given\n+listener by providing a key store alias.  For example, \n+if set, `ksql.ssl.keystore.alias.internal` will be used to find the key store entry\n+with the given alias when setting up the internal listener.  Similarly,\n+`ksql.ssl.keystore.alias.external` is used for the client listener `listeners`.\n+Below is an example configuration:\n+\n+```properties\n+# Contains the client certificate for this node under the alias 'client'.\n+# (e.g. key pair for external.example.com)\n+# Contains the internal certificate for this node under the alias 'internal_node1'.\n+# (e.g. key pair for node-1.internal.example.com)\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# The aliases referenced above\n+ksql.ssl.keystore.alias.external=client\n+ksql.ssl.keystore.alias.internal=internal_node1\n+\n+# Contains the certificates for nodes in the cluster.\n+# (e.g. certs for node-1.internal.example.com, node-2.internal.example.com)\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=https://external.example.com:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+# This enables mutual auth checking for the internal listener\n+ksql.internal.ssl.client.authentication=REQUIRED", "originalCommit": "dc801b4f9a8ab90b578d343bdc5e7003e7d2dec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MTA4OQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440371089", "bodyText": "Sure, added ksql.ssl.client.authentication=NONE since most configurations use another mechanism for client authentication.", "author": "AlanConfluent", "createdAt": "2020-06-15T18:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExMTgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExMjUxNg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440112516", "bodyText": "perfect!", "author": "big-andy-coates", "createdAt": "2020-06-15T11:34:37Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,6 +219,134 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n+Configure ksqlDB for Internal Authentication\n+--------------------------------------------\n+\n+ksqlDB supports securing inter-node communication using SSL mutual authentication.\n+\n+For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.html#configuring-listeners-of-a-ksqldb-cluster).\n+\n+### Using Authentication on the Internal Listener\n+\n+Your key store must contain the key pair for your internal listener set with\n+`ksql.internal.listener`.  If your internal certificate is not signed by a recognized\n+public Certificate Authority, a trust store is required to contain certificates for\n+nodes in your cluster.  Below is an example configuration:\n+\n+```properties\n+# Contains the internal key pair for this node.\n+# (e.g. key pair for node-1.internal.example.com)\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# Contains the certificates for nodes in the cluster.\n+# (e.g. certs for node-1.internal.example.com, node-2.internal.example.com)\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+# This enables mutual auth checking for the internal listener\n+ksql.internal.ssl.client.authentication=REQUIRED\n+```\n+\n+### Using Authentication for Both the Internal and External Listener\n+\n+Client facing basic HTTP authentication can be used alongside authentication for the \n+internal listener. This ensures that neither the client or internal\n+APIs can be accessed by unauthorized users.\n+Below is an example configuration:\n+\n+```properties\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+ksql.internal.ssl.client.authentication=REQUIRED\n+\n+authentication.method=BASIC\n+authentication.roles=admin,developer,user,ksq-user\n+authentication.realm=KsqlServer-Props\n+\n+```\n+\n+For more detail on basic authentication, \n+[see above](#configure-ksqldb-for-basic-http-authentication).\n+\n+### Configuring HTTPS on the Internal and External Listeners\n+\n+If you want to use HTTPS on `listeners` as well as use SSL mutual\n+auth for internal communication on `ksql.internal.listener`, you will likely\n+require two different key pairs, since your host's identity to clients may be\n+different from its internal identity.  In order to create such a key store,\n+refer [below](#setting-up-a-key-store-and-trust-store).\n+\n+In such a configuration, you must specify which key pair is used for a given\n+listener by providing a key store alias.  For example, \n+if set, `ksql.ssl.keystore.alias.internal` will be used to find the key store entry\n+with the given alias when setting up the internal listener.  Similarly,\n+`ksql.ssl.keystore.alias.external` is used for the client listener `listeners`.\n+Below is an example configuration:", "originalCommit": "dc801b4f9a8ab90b578d343bdc5e7003e7d2dec7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNDM1Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440114353", "bodyText": "Just a suggestion but:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (isInternalListener) {\n          \n          \n            \n                    final String internalAlias = ksqlRestConfig\n          \n          \n            \n                        .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n          \n          \n            \n                    setTlsOptions(ksqlRestConfig, options, internalAlias,\n          \n          \n            \n                        ksqlRestConfig.getClientAuthInternal());\n          \n          \n            \n                  } else {\n          \n          \n            \n                    final String externalAlias = ksqlRestConfig\n          \n          \n            \n                        .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG);\n          \n          \n            \n                    setTlsOptions(ksqlRestConfig, options, externalAlias, ksqlRestConfig.getClientAuth());\n          \n          \n            \n                  final String ksConfigName = isInternalListener:\n          \n          \n            \n                       ? KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG\n          \n          \n            \n                       : KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG;\n          \n          \n            \n                       \n          \n          \n            \n                  final String alias = ksqlRestConfig.getString(ksConfigName);\n          \n          \n            \n                  setTlsOptions(ksqlRestConfig, options, alias, ksqlRestConfig.getClientAuthInternal());", "author": "big-andy-coates", "createdAt": "2020-06-15T11:38:37Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -251,30 +255,57 @@ private static HttpServerOptions createHttpServerOptions(final KsqlRestConfig ks\n         .setPerFrameWebSocketCompressionSupported(true);\n \n     if (tls) {\n-      options.setUseAlpn(true).setSsl(true);\n-\n-      final String keyStorePath = ksqlRestConfig\n-          .getString(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n-      final Password keyStorePassword = ksqlRestConfig\n-          .getPassword(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG);\n-      if (keyStorePath != null && !keyStorePath.isEmpty()) {\n-        options.setKeyStoreOptions(\n-            new JksOptions().setPath(keyStorePath).setPassword(keyStorePassword.value()));\n+      if (isInternalListener) {\n+        final String internalAlias = ksqlRestConfig\n+            .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+        setTlsOptions(ksqlRestConfig, options, internalAlias,\n+            ksqlRestConfig.getClientAuthInternal());\n+      } else {\n+        final String externalAlias = ksqlRestConfig\n+            .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG);\n+        setTlsOptions(ksqlRestConfig, options, externalAlias, ksqlRestConfig.getClientAuth());", "originalCommit": "dc801b4f9a8ab90b578d343bdc5e7003e7d2dec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MjkyOA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440352928", "bodyText": "Done.", "author": "AlanConfluent", "createdAt": "2020-06-15T18:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNDM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNzc3MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440117770", "bodyText": "Avoid hardcoded ports in tests - it causes tests to fail if the ports in use, e.g.\n\nIf the build server is running two builds on the same box\nAn engineer is running two builds, for two different change sets, at the same time.\nAn engineer is running ksql to test something else, while they've also got a build running.\netc.\n\nI think you should be able to just set it to http://0.0.0.0:0 and the server will auto-pick a free port.  It certainly did in Jetty days, not sure about Vert.x.  Check with Tim if it doesn't work. I'm sure he'll know how to.\nPlease update all places the port is hardcoded.", "author": "big-andy-coates", "createdAt": "2020-06-15T11:45:51Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/SystemAuthenticationFunctionalTest.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.sendClusterStatusRequest;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForClusterToBeDiscovered;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus;\n+import static io.confluent.ksql.test.util.EmbeddedSingleNodeKafkaCluster.JAAS_KAFKA_PROPS_NAME;\n+import static io.confluent.ksql.test.util.EmbeddedSingleNodeKafkaCluster.VALID_USER1;\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.AdditionalMatchers.not;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.rest.client.BasicCredentials;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.KsqlHostInfoEntity;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.security.KsqlAuthorizationProvider;\n+import io.confluent.ksql.serde.FormatFactory;\n+import io.confluent.ksql.test.util.secure.MultiNodeKeyStore;\n+import io.confluent.ksql.test.util.secure.MultiNodeTrustStore;\n+import io.confluent.ksql.test.util.secure.ServerKeyStore;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.PageViewDataProvider;\n+import io.vertx.core.net.SocketAddress;\n+import java.io.IOException;\n+import java.security.Principal;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.experimental.runners.Enclosed;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@Category({IntegrationTest.class})\n+@RunWith(Enclosed.class)\n+public class SystemAuthenticationFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+\n+  private static final PageViewDataProvider PAGE_VIEWS_PROVIDER = new PageViewDataProvider();\n+  private static final String PAGE_VIEW_TOPIC = PAGE_VIEWS_PROVIDER.topicName();\n+  private static final String PAGE_VIEW_STREAM = PAGE_VIEWS_PROVIDER.kstreamName();\n+  private static final KsqlHostInfoEntity host0 = new KsqlHostInfoEntity(\"node-1.example.com\",\n+      8188);\n+  private static final KsqlHostInfoEntity host1 = new KsqlHostInfoEntity(\"node-2.example.com\",\n+      8189);\n+  private static final BiFunction<Integer, String, SocketAddress> LOCALHOST_FACTORY =\n+      (port, host) -> SocketAddress.inetSocketAddress(port, \"localhost\");\n+\n+  private static final Map<String, Object> JASS_AUTH_CONFIG = ImmutableMap.<String, Object>builder()\n+      .put(\"authentication.method\", \"BASIC\")\n+      .put(\"authentication.roles\", \"**\")\n+      // Reuse the Kafka JAAS config for KSQL authentication which has the same valid users\n+      .put(\"authentication.realm\", JAAS_KAFKA_PROPS_NAME)\n+      .put(\n+          KsqlConfig.KSQL_SECURITY_EXTENSION_CLASS,\n+          MockKsqlSecurityExtension.class.getName()\n+      )\n+      .build();\n+\n+  private static final Map<String, Object> COMMON_CONFIG = ImmutableMap.<String, Object>builder()\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 200)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 1000)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 1000)\n+      .put(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .put(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STANDBY_REPLICAS_CONFIG, 1)\n+      .put(KsqlConfig.KSQL_SHUTDOWN_TIMEOUT_MS_CONFIG, 1000)\n+      .putAll(ServerKeyStore.keyStoreProps())\n+      .build();\n+\n+  private static Map<String, String> internalKeyStoreProps(boolean node1) {\n+    Map<String, String> keyStoreProps = node1\n+        ? MultiNodeKeyStore.keyStoreNode1Props()\n+        : MultiNodeKeyStore.keyStoreNode2Props();\n+    Map<String, String> trustStoreProps = MultiNodeTrustStore.trustStoreNode1Node2Props();\n+    return ImmutableMap.of(\n+        SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG,\n+        keyStoreProps.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG),\n+        SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG,\n+        keyStoreProps.get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG),\n+        SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG,\n+        trustStoreProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG),\n+        SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG,\n+        trustStoreProps.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)\n+    );\n+  }\n+\n+  private static final BasicCredentials USER1 = BasicCredentials.of(\n+      VALID_USER1.username,\n+      VALID_USER1.password\n+  );\n+\n+  private static void commonClassSetup(final IntegrationTestHarness TEST_HARNESS,\n+      final TestKsqlRestApp REST_APP_0) {\n+    TEST_HARNESS.ensureTopics(2, PAGE_VIEW_TOPIC);\n+    TEST_HARNESS.produceRows(PAGE_VIEW_TOPIC, PAGE_VIEWS_PROVIDER, FormatFactory.JSON);\n+    RestIntegrationTestUtil.createStream(REST_APP_0, PAGE_VIEWS_PROVIDER, Optional.of(USER1));\n+    RestIntegrationTestUtil.makeKsqlRequest(\n+        REST_APP_0,\n+        \"CREATE STREAM S AS SELECT * FROM \" + PAGE_VIEW_STREAM + \";\",\n+        Optional.of(USER1)\n+    );\n+  }\n+\n+  @RunWith(MockitoJUnitRunner.class)\n+  public static class MutualAuth {\n+    private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+    private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+        .builder(TEST_HARNESS::kafkaBootstrapServers)\n+        .withEnabledKsqlClient(LOCALHOST_FACTORY)\n+        .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://0.0.0.0:8088\")", "originalCommit": "dc801b4f9a8ab90b578d343bdc5e7003e7d2dec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2NDMxNA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440364314", "bodyText": "This works fine for listeners, so I did that there.  There's a bit of an issue with doing this for KsqlRestConfig.INTERNAL_LISTENER_CONFIG because I have to also reference the port when setting KsqlRestConfig.ADVERTISED_LISTENER_CONFIG.  At the moment, configs have to be set by the time the server starts up, and yet using port 0, the port doesn't get resolved until the server starts.\nThis can possibly be resolved by reworking the code a bit, but that seems like work for a followup.", "author": "AlanConfluent", "createdAt": "2020-06-15T18:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNzc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExODc2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440118765", "bodyText": "Is it worth having two versions: one with and one without this function?  Seems like most things won't need the ability to override the host.", "author": "big-andy-coates", "createdAt": "2020-06-15T11:47:57Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/services/TestDefaultKsqlClientFactory.java", "diffHunk": "@@ -11,8 +13,9 @@\n public class TestDefaultKsqlClientFactory {\n \n   // Creates an instance with no auth\n-  public static SimpleKsqlClient instance(Map<String, Object> clientProps) {\n-    return new DefaultKsqlClient(Optional.empty(), clientProps);\n+  public static SimpleKsqlClient instance(Map<String, Object> clientProps,\n+      final BiFunction<Integer, String, SocketAddress> socketAddressFactory) {", "originalCommit": "dc801b4f9a8ab90b578d343bdc5e7003e7d2dec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2NDU2Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440364563", "bodyText": "Sure, added.", "author": "AlanConfluent", "createdAt": "2020-06-15T18:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExODc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTg3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440119872", "bodyText": "Worth adding java docs on the params?  The new socketAddressFactory probably isn't obvious", "author": "big-andy-coates", "createdAt": "2020-06-15T11:50:15Z", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -55,16 +58,33 @@ public KsqlClient(\n     this.basicAuthHeader = createBasicAuthHeader(\n         Objects.requireNonNull(credentials, \"credentials\"));\n     this.localProperties = Objects.requireNonNull(localProperties, \"localProperties\");\n+    this.socketAddressFactory = SocketAddress::inetSocketAddress;\n     this.httpNonTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, false);\n     this.httpTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, true);\n   }\n \n+  public KsqlClient(", "originalCommit": "dc801b4f9a8ab90b578d343bdc5e7003e7d2dec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2OTYwMA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440369600", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-15T18:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTg3Mg=="}], "type": "inlineReview"}, {"oid": "9454c9d1c9f1b282e4759e244366aa6d4a56bbac", "url": "https://github.com/confluentinc/ksql/commit/9454c9d1c9f1b282e4759e244366aa6d4a56bbac", "message": "feat: Adds SSL mutual auth support to intra-cluster requests", "committedDate": "2020-06-15T21:53:07Z", "type": "commit"}, {"oid": "f11bfb4bb65a2fa4561d4328128c72307efbdd2e", "url": "https://github.com/confluentinc/ksql/commit/f11bfb4bb65a2fa4561d4328128c72307efbdd2e", "message": "feat: Adds SSL mutual auth to system calls and authenticates then as a SystemUser", "committedDate": "2020-06-15T21:54:36Z", "type": "commit"}, {"oid": "1f2eb1fb046363463a23a085f12ae8db69f3f635", "url": "https://github.com/confluentinc/ksql/commit/1f2eb1fb046363463a23a085f12ae8db69f3f635", "message": "Uses normal keystore", "committedDate": "2020-06-15T21:55:22Z", "type": "commit"}, {"oid": "ea5b011c99afa1df22e35e71f64d4d8fcfb67bf4", "url": "https://github.com/confluentinc/ksql/commit/ea5b011c99afa1df22e35e71f64d4d8fcfb67bf4", "message": "Remove comment block", "committedDate": "2020-06-15T21:55:23Z", "type": "commit"}, {"oid": "6323bba25dbbe262aeb24636a36563077be36b7a", "url": "https://github.com/confluentinc/ksql/commit/6323bba25dbbe262aeb24636a36563077be36b7a", "message": "Gets everything working", "committedDate": "2020-06-15T21:56:17Z", "type": "commit"}, {"oid": "b19ce41bd7aaed62d7f8b41236f4ebbd798a8994", "url": "https://github.com/confluentinc/ksql/commit/b19ce41bd7aaed62d7f8b41236f4ebbd798a8994", "message": "Does docs and fixes style", "committedDate": "2020-06-15T21:56:18Z", "type": "commit"}, {"oid": "92840c2684233fc64a0e64f06a23048c8e495eb2", "url": "https://github.com/confluentinc/ksql/commit/92840c2684233fc64a0e64f06a23048c8e495eb2", "message": "Reverts configs", "committedDate": "2020-06-15T21:56:18Z", "type": "commit"}, {"oid": "13e31ed47153d3dc5bf5006234c0c432ac14fecf", "url": "https://github.com/confluentinc/ksql/commit/13e31ed47153d3dc5bf5006234c0c432ac14fecf", "message": "Removed unused field", "committedDate": "2020-06-15T21:56:18Z", "type": "commit"}, {"oid": "da8b0e9984326c60032f281af5958583a81360b9", "url": "https://github.com/confluentinc/ksql/commit/da8b0e9984326c60032f281af5958583a81360b9", "message": "Apply suggestions from code review\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>\nCo-authored-by: Andy Coates <8012398+big-andy-coates@users.noreply.github.com>", "committedDate": "2020-06-15T21:56:18Z", "type": "commit"}, {"oid": "dd7fa0f6a378e745322578be5e71362a208aea2e", "url": "https://github.com/confluentinc/ksql/commit/dd7fa0f6a378e745322578be5e71362a208aea2e", "message": "Feedback", "committedDate": "2020-06-15T21:56:46Z", "type": "commit"}, {"oid": "1523b4ae82a5b51df8e277a90df5dfb04b29e176", "url": "https://github.com/confluentinc/ksql/commit/1523b4ae82a5b51df8e277a90df5dfb04b29e176", "message": "Fixes lint warnings", "committedDate": "2020-06-15T21:57:03Z", "type": "commit"}, {"oid": "7cb00a20b2fa755cc65a303f6d6e80bf97853cf5", "url": "https://github.com/confluentinc/ksql/commit/7cb00a20b2fa755cc65a303f6d6e80bf97853cf5", "message": "Updated docs", "committedDate": "2020-06-15T21:57:04Z", "type": "commit"}, {"oid": "c0d3c26c73ed3b9892c34b326c04a99434824296", "url": "https://github.com/confluentinc/ksql/commit/c0d3c26c73ed3b9892c34b326c04a99434824296", "message": "Used aliases rather than new configs", "committedDate": "2020-06-15T21:57:04Z", "type": "commit"}, {"oid": "d4535ceeec7970aa4579fe456753178eca80fca5", "url": "https://github.com/confluentinc/ksql/commit/d4535ceeec7970aa4579fe456753178eca80fca5", "message": "Updated docs", "committedDate": "2020-06-15T21:57:04Z", "type": "commit"}, {"oid": "93d2ceeb2da501ab3b549542cd27b732e45239e5", "url": "https://github.com/confluentinc/ksql/commit/93d2ceeb2da501ab3b549542cd27b732e45239e5", "message": "Fixes warning for InputStream", "committedDate": "2020-06-15T21:57:04Z", "type": "commit"}, {"oid": "9e8a9b8631294ff1f7c48e2fe345fca625bba815", "url": "https://github.com/confluentinc/ksql/commit/9e8a9b8631294ff1f7c48e2fe345fca625bba815", "message": "Bunch of feedback", "committedDate": "2020-06-15T21:57:05Z", "type": "commit"}, {"oid": "2029ec68e31996e871717881f816ef469f8753ec", "url": "https://github.com/confluentinc/ksql/commit/2029ec68e31996e871717881f816ef469f8753ec", "message": "More feedback", "committedDate": "2020-06-15T21:57:05Z", "type": "commit"}, {"oid": "4820d75f92e61d09f21bc08a7f4965096e97565a", "url": "https://github.com/confluentinc/ksql/commit/4820d75f92e61d09f21bc08a7f4965096e97565a", "message": "fixes test", "committedDate": "2020-06-15T21:57:05Z", "type": "commit"}, {"oid": "25459cde3f7dbf42d39fa2bcbc0e48e81706c3ab", "url": "https://github.com/confluentinc/ksql/commit/25459cde3f7dbf42d39fa2bcbc0e48e81706c3ab", "message": "Feedback", "committedDate": "2020-06-15T21:57:05Z", "type": "commit"}, {"oid": "e01f92bcf2caba04796e6ce8c31c73d334ea15ac", "url": "https://github.com/confluentinc/ksql/commit/e01f92bcf2caba04796e6ce8c31c73d334ea15ac", "message": "Latest feedback", "committedDate": "2020-06-15T22:40:26Z", "type": "commit"}, {"oid": "e01f92bcf2caba04796e6ce8c31c73d334ea15ac", "url": "https://github.com/confluentinc/ksql/commit/e01f92bcf2caba04796e6ce8c31c73d334ea15ac", "message": "Latest feedback", "committedDate": "2020-06-15T22:40:26Z", "type": "forcePushed"}, {"oid": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "url": "https://github.com/confluentinc/ksql/commit/2c87b67575970d48f5c03594ac0be8a7f7fdad74", "message": "One last rejig of docs", "committedDate": "2020-06-15T22:56:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNDUyNg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440504526", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            client-facing and internal endpoints, and also supports many of the security\n          \n          \n            \n            client-facing and internal endpoints. ksqlDB also supports many of the security", "author": "JimGalasyn", "createdAt": "2020-06-15T23:39:40Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -6,21 +6,39 @@ description: Settings for security ksqlDB\n keywords: ksqldb, confguration, security, acl, ssl, sasl, keystore, truststore\n ---\n \n-ksqlDB supports authentication on its HTTP endpoints and also supports\n-many of the security features of the other services it communicates\n-with, like {{ site.aktm }} and {{ site.sr }}.\n-\n-- ksqlDB supports Basic HTTP authentication on its RESTful and WebSocket\n-  endpoints, which means that the endpoints can be protected by a\n-  username and password.\n-- ksqlDB supports {{ site.aktm }} security features such as\n-  [SSL for encryption](https://docs.confluent.io/current/kafka/encryption.html),\n-  [SASL for authentication](https://docs.confluent.io/current/kafka/authentication_sasl/index.html),\n-  and [authorization with ACLs](https://docs.confluent.io/current/kafka/authorization.html).\n-- ksqlDB supports\n-  [Schema Registry security features](https://docs.confluent.io/current/schema-registry/security/index.html)\n-  such SSL for encryption and mutual authentication for authorization.\n-- ksqlDB supports SSL on all network traffic.\n+ksqlDB supports several combinations of encryption and authentication on its\n+client-facing and internal endpoints, and also supports many of the security", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTAxOA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440505018", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            e.g. on-premise installations or manual installations on other cloud platforms.\n          \n          \n            \n            like on-premises installations or manual installations on other cloud platforms.", "author": "JimGalasyn", "createdAt": "2020-06-15T23:41:06Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -6,21 +6,39 @@ description: Settings for security ksqlDB\n keywords: ksqldb, confguration, security, acl, ssl, sasl, keystore, truststore\n ---\n \n-ksqlDB supports authentication on its HTTP endpoints and also supports\n-many of the security features of the other services it communicates\n-with, like {{ site.aktm }} and {{ site.sr }}.\n-\n-- ksqlDB supports Basic HTTP authentication on its RESTful and WebSocket\n-  endpoints, which means that the endpoints can be protected by a\n-  username and password.\n-- ksqlDB supports {{ site.aktm }} security features such as\n-  [SSL for encryption](https://docs.confluent.io/current/kafka/encryption.html),\n-  [SASL for authentication](https://docs.confluent.io/current/kafka/authentication_sasl/index.html),\n-  and [authorization with ACLs](https://docs.confluent.io/current/kafka/authorization.html).\n-- ksqlDB supports\n-  [Schema Registry security features](https://docs.confluent.io/current/schema-registry/security/index.html)\n-  such SSL for encryption and mutual authentication for authorization.\n-- ksqlDB supports SSL on all network traffic.\n+ksqlDB supports several combinations of encryption and authentication on its\n+client-facing and internal endpoints, and also supports many of the security\n+features of the other services it communicates with, like {{ site.aktm }} and\n+{{ site.sr }}.\n+\n+- [Securing ksqlDB on Confluent Cloud](#configure-ksqldb-for-confluent-cloud)\n+- [Securing ksqlDB on premise](#securing-ksqlDB-on-premise)\n+  - [Securing ksqlDB installation](#securing-ksqldb-installation)\n+    - [Securing interactive deployments](#securing-interactive-deployments)\n+      - [Securing single listener setup](#securing-single-listener-setup)\n+        - [Configuring listener for SSL encryption](#configuring-listener-for-ssl-encryption)\n+        - [Configuring listener for HTTP-BASIC authentication](#configuring-listener-for-http-basic-authentication)\n+      - [Securing dual listener setup](#securing-dual-listener-setup)\n+        - [Configuring internal for SSL-mutual authentication](#configuring-intenral-for-ssl-mutual-authentication)\n+        - [Configuring internal for SSL-mutual authentication + external for SSL encryption](#configuring-internal-for-ssl-mutual-authentication-+-external-for-ssl-encryption)\n+        - [Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication](#configuring-internal-for-ssl-mutual-authentication-+-external-for-http-basic-authentication)\n+    - [Securing headless deployments](#securing-headless-deployments)\n+\n+  - [Securing communication with other services](#securing-communication-with-other-services)\n+    - [Configure ksqlDB for Confluent Control Center](#configure-ksqldb-for-confluent-control-center)\n+    - [Configure ksqlDB for Secured Confluent Schema Registry](#configure-ksqldb-for-secured-confluent-schema-registry)\n+    - [Configure ksqlDB for Secured Apache Kafka clusters](#configure-ksqldb-for-secured-apache-kafka-clusters)\n+      - [Configuring Kafka Encrypted Communication](#configuring-kafa-encrypted-communication)\n+      - [Configuring Kafka Authentication](#configuring-kafka-authentication)\n+      - [Configure Authorization of ksqlDB with Kafka ACLs](#configure-authorization-of-ksqldb-with-kafka-acls)\n+        - [Confluent Platform v5.0 (Apache Kafka v2.0) and above](#confluent-platform-v5.0-(apache-kafka-v2.0)-and-above)\n+        - [Confluent Platform versions below v5.0 (Apache Kafka < v2.0)](#confluent-platform-versions-below-v.5.0-(apache-kafka-<-v2.0))\n+\n+Securing ksqlDB on premise\n+--------------------------\n+\n+This section covers how to secure installations of ksqlDB outside of Confluent Cloud,\n+e.g. on-premise installations or manual installations on other cloud platforms.", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTQ5Ng==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440505496", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Securing the interactive ksqlDB installation involves securing the HTTP endpoints the ksqlDB server is listening on.\n          \n          \n            \n            Securing the interactive ksqlDB installation involves securing the HTTP endpoints that the ksqlDB server is listening on.", "author": "JimGalasyn", "createdAt": "2020-06-15T23:42:39Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -36,8 +54,75 @@ configuration file specified.\n     or TAR archives. For more information, see\n     [On-Premises Deployments](https://docs.confluent.io/current/installation/installing_cp/index.html).\n \n-Configure ksqlDB for HTTPS\n---------------------------\n+\n+The section is split into:\n+\n+[Securing ksqlDB installation](#securing-ksqldb-installation): Covers how to secure access to ksqlDB itself\n+and its own internal communication.\n+\n+[Securing communication with other services](#securing-communication-with-other-services): Covers how to secure\n+communication with other services and access to the resources they hold.\n+\n+Securing ksqlDB installation\n+----------------------------\n+\n+ksqlDB supports two main deployment modes:\n+\n+[Securing interactive deployments](#securing-interactive-deployments): Interactive deployments are those where\n+the ksqlDB servers accept client connections.\n+\n+[Securing headless deployments](#securing-headless-deployments): headless\n+deployments are those where the ksqlDB servers do not accept client connections.\n+They read the SQL statements they should run from a file on-disk.\n+\n+\n+Securing interactive deployments\n+--------------------------------\n+\n+Securing the interactive ksqlDB installation involves securing the HTTP endpoints the ksqlDB server is listening on.", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTcwNw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440505707", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Securing single listener setup\n          \n          \n            \n            Securing single-listener setup", "author": "JimGalasyn", "createdAt": "2020-06-15T23:43:26Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -36,8 +54,75 @@ configuration file specified.\n     or TAR archives. For more information, see\n     [On-Premises Deployments](https://docs.confluent.io/current/installation/installing_cp/index.html).\n \n-Configure ksqlDB for HTTPS\n---------------------------\n+\n+The section is split into:\n+\n+[Securing ksqlDB installation](#securing-ksqldb-installation): Covers how to secure access to ksqlDB itself\n+and its own internal communication.\n+\n+[Securing communication with other services](#securing-communication-with-other-services): Covers how to secure\n+communication with other services and access to the resources they hold.\n+\n+Securing ksqlDB installation\n+----------------------------\n+\n+ksqlDB supports two main deployment modes:\n+\n+[Securing interactive deployments](#securing-interactive-deployments): Interactive deployments are those where\n+the ksqlDB servers accept client connections.\n+\n+[Securing headless deployments](#securing-headless-deployments): headless\n+deployments are those where the ksqlDB servers do not accept client connections.\n+They read the SQL statements they should run from a file on-disk.\n+\n+\n+Securing interactive deployments\n+--------------------------------\n+\n+Securing the interactive ksqlDB installation involves securing the HTTP endpoints the ksqlDB server is listening on.\n+\n+As well as accepting connections and requests from clients, a multi-node ksqlDB\n+cluster also requires inter-node communications. You can choose to configure\n+the external client and internal inter-node communication separately or over\n+a single listener:\n+\n+[Securing single listener setup](#securing-single-listener-setup): Ideal for\n+single-node installations, or where the inter-node communication is over the\n+same network interfaces as client communication.\n+\n+[Securing dual listener setup](#securing-dual-listener-setup): Useful where\n+inter-node communication is over a different network interfaces or requires\n+different authentication or encryption configuration.\n+\n+\n+Securing headless deployments\n+-----------------------------\n+\n+Unlike interactive deployments, there are no exposed REST APIs, so security\n+is greatly simplified.\n+\n+You may still have to [secure communication](#securing-communication-with-other-services) with other services.\n+\n+\n+Securing single listener setup", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNTk5OQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440505999", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Securing dual listener setup\n          \n          \n            \n            Securing dual-listener setup", "author": "JimGalasyn", "createdAt": "2020-06-15T23:44:23Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,13 +304,193 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n-Configure ksqlDB for Confluent Cloud\n+Securing dual listener setup", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNjA3OQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440506079", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            configurations.  This is most likely the case when ksqlDB is deployed as an\n          \n          \n            \n            configurations. This is most likely the case when ksqlDB is deployed as an", "author": "JimGalasyn", "createdAt": "2020-06-15T23:44:42Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,13 +304,193 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n-Configure ksqlDB for Confluent Cloud\n+Securing dual listener setup\n+----------------------------\n+\n+Using dual listeners for ksqlDB is appropriate when the client and\n+inter-node communication utilize different authentication and security\n+configurations.  This is most likely the case when ksqlDB is deployed as an", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNjUyOA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440506528", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication\n          \n          \n            \n            Configuring internal for SSL-mutual authentication and external for HTTP-BASIC authentication", "author": "JimGalasyn", "createdAt": "2020-06-15T23:46:15Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,13 +304,193 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n-Configure ksqlDB for Confluent Cloud\n+Securing dual listener setup\n+----------------------------\n+\n+Using dual listeners for ksqlDB is appropriate when the client and\n+inter-node communication utilize different authentication and security\n+configurations.  This is most likely the case when ksqlDB is deployed as an\n+IaaS service.\n+\n+The supported setups are SSL-mutual auth for the internal communication\n+combined with SSL encryption and authentication for the external client:\n+\n+[Configuring internal for SSL-mutual authentication](#configuring-intenral-for-ssl-mutual-authentication):\n+Creates secure and authenticated connections for inter-node communication,\n+but leaves the external\n+client API unsecured. This is most appropriate when clients are trusted, but\n+the internal APIs are protected from use.\n+\n+[Configuring internal for SSL-mutual authentication + external for SSL encryption](#configuring-internal-for-ssl-mutual-authentication-+-external-for-ssl-encryption):\n+Creates secure and authenticated connections for inter-node\n+communication and uses SSL for the external client API. This is most\n+likely to be pair with authentication below.\n+\n+[Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication](#configuring-internal-for-ssl-mutual-authentication-+-external-for-http-basic-authentication):\n+Creates secure and authenticated connections for inter-node\n+communication and uses basic authentication for the external client API.\n+This is most likely to be paired with SSL above.\n+\n+Configuring internal for SSL-mutual authentication\n+--------------------------------------------------\n+\n+ksqlDB supports securing inter-node communication using SSL mutual authentication.\n+\n+For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.md#configuring-listeners-of-a-ksqldb-cluster).\n+\n+Your key store must contain the key pair for your internal listener set with\n+`ksql.internal.listener`.  If your internal certificate is not signed by a recognized\n+public Certificate Authority, a trust store is required to contain certificates for\n+nodes in your cluster.  Below is an example configuration:\n+\n+```properties\n+# Contains the internal key pair for this node.\n+# (e.g. key pair for node-1.internal.example.com)\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# Contains the certificates for nodes in the cluster.\n+# (e.g. certs for node-1.internal.example.com, node-2.internal.example.com)\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+# This enables mutual auth checking for the internal listener\n+ksql.internal.ssl.client.authentication=REQUIRED\n+```\n+\n+Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNjc0Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440506742", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            --------------------------------------------------------------------------------\n          \n          \n            \n            ---------------------------------------------------------------------------------------------", "author": "JimGalasyn", "createdAt": "2020-06-15T23:46:59Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,13 +304,193 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n-Configure ksqlDB for Confluent Cloud\n+Securing dual listener setup\n+----------------------------\n+\n+Using dual listeners for ksqlDB is appropriate when the client and\n+inter-node communication utilize different authentication and security\n+configurations.  This is most likely the case when ksqlDB is deployed as an\n+IaaS service.\n+\n+The supported setups are SSL-mutual auth for the internal communication\n+combined with SSL encryption and authentication for the external client:\n+\n+[Configuring internal for SSL-mutual authentication](#configuring-intenral-for-ssl-mutual-authentication):\n+Creates secure and authenticated connections for inter-node communication,\n+but leaves the external\n+client API unsecured. This is most appropriate when clients are trusted, but\n+the internal APIs are protected from use.\n+\n+[Configuring internal for SSL-mutual authentication + external for SSL encryption](#configuring-internal-for-ssl-mutual-authentication-+-external-for-ssl-encryption):\n+Creates secure and authenticated connections for inter-node\n+communication and uses SSL for the external client API. This is most\n+likely to be pair with authentication below.\n+\n+[Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication](#configuring-internal-for-ssl-mutual-authentication-+-external-for-http-basic-authentication):\n+Creates secure and authenticated connections for inter-node\n+communication and uses basic authentication for the external client API.\n+This is most likely to be paired with SSL above.\n+\n+Configuring internal for SSL-mutual authentication\n+--------------------------------------------------\n+\n+ksqlDB supports securing inter-node communication using SSL mutual authentication.\n+\n+For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.md#configuring-listeners-of-a-ksqldb-cluster).\n+\n+Your key store must contain the key pair for your internal listener set with\n+`ksql.internal.listener`.  If your internal certificate is not signed by a recognized\n+public Certificate Authority, a trust store is required to contain certificates for\n+nodes in your cluster.  Below is an example configuration:\n+\n+```properties\n+# Contains the internal key pair for this node.\n+# (e.g. key pair for node-1.internal.example.com)\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# Contains the certificates for nodes in the cluster.\n+# (e.g. certs for node-1.internal.example.com, node-2.internal.example.com)\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+# This enables mutual auth checking for the internal listener\n+ksql.internal.ssl.client.authentication=REQUIRED\n+```\n+\n+Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication\n+--------------------------------------------------------------------------------", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNzI4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440507283", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Client facing basic HTTP authentication can be used alongside authentication for the\n          \n          \n            \n            Client-facing basic HTTP authentication can be used alongside authentication for the", "author": "JimGalasyn", "createdAt": "2020-06-15T23:48:57Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,13 +304,193 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n-Configure ksqlDB for Confluent Cloud\n+Securing dual listener setup\n+----------------------------\n+\n+Using dual listeners for ksqlDB is appropriate when the client and\n+inter-node communication utilize different authentication and security\n+configurations.  This is most likely the case when ksqlDB is deployed as an\n+IaaS service.\n+\n+The supported setups are SSL-mutual auth for the internal communication\n+combined with SSL encryption and authentication for the external client:\n+\n+[Configuring internal for SSL-mutual authentication](#configuring-intenral-for-ssl-mutual-authentication):\n+Creates secure and authenticated connections for inter-node communication,\n+but leaves the external\n+client API unsecured. This is most appropriate when clients are trusted, but\n+the internal APIs are protected from use.\n+\n+[Configuring internal for SSL-mutual authentication + external for SSL encryption](#configuring-internal-for-ssl-mutual-authentication-+-external-for-ssl-encryption):\n+Creates secure and authenticated connections for inter-node\n+communication and uses SSL for the external client API. This is most\n+likely to be pair with authentication below.\n+\n+[Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication](#configuring-internal-for-ssl-mutual-authentication-+-external-for-http-basic-authentication):\n+Creates secure and authenticated connections for inter-node\n+communication and uses basic authentication for the external client API.\n+This is most likely to be paired with SSL above.\n+\n+Configuring internal for SSL-mutual authentication\n+--------------------------------------------------\n+\n+ksqlDB supports securing inter-node communication using SSL mutual authentication.\n+\n+For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.md#configuring-listeners-of-a-ksqldb-cluster).\n+\n+Your key store must contain the key pair for your internal listener set with\n+`ksql.internal.listener`.  If your internal certificate is not signed by a recognized\n+public Certificate Authority, a trust store is required to contain certificates for\n+nodes in your cluster.  Below is an example configuration:\n+\n+```properties\n+# Contains the internal key pair for this node.\n+# (e.g. key pair for node-1.internal.example.com)\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# Contains the certificates for nodes in the cluster.\n+# (e.g. certs for node-1.internal.example.com, node-2.internal.example.com)\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+# This enables mutual auth checking for the internal listener\n+ksql.internal.ssl.client.authentication=REQUIRED\n+```\n+\n+Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication\n+--------------------------------------------------------------------------------\n+\n+Client facing basic HTTP authentication can be used alongside authentication for the", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNzM4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440507383", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Configuring internal for SSL-mutual authentication + external for SSL encryption\n          \n          \n            \n            Configuring internal for SSL-mutual authentication and external for SSL encryption", "author": "JimGalasyn", "createdAt": "2020-06-15T23:49:21Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,13 +304,193 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n-Configure ksqlDB for Confluent Cloud\n+Securing dual listener setup\n+----------------------------\n+\n+Using dual listeners for ksqlDB is appropriate when the client and\n+inter-node communication utilize different authentication and security\n+configurations.  This is most likely the case when ksqlDB is deployed as an\n+IaaS service.\n+\n+The supported setups are SSL-mutual auth for the internal communication\n+combined with SSL encryption and authentication for the external client:\n+\n+[Configuring internal for SSL-mutual authentication](#configuring-intenral-for-ssl-mutual-authentication):\n+Creates secure and authenticated connections for inter-node communication,\n+but leaves the external\n+client API unsecured. This is most appropriate when clients are trusted, but\n+the internal APIs are protected from use.\n+\n+[Configuring internal for SSL-mutual authentication + external for SSL encryption](#configuring-internal-for-ssl-mutual-authentication-+-external-for-ssl-encryption):\n+Creates secure and authenticated connections for inter-node\n+communication and uses SSL for the external client API. This is most\n+likely to be pair with authentication below.\n+\n+[Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication](#configuring-internal-for-ssl-mutual-authentication-+-external-for-http-basic-authentication):\n+Creates secure and authenticated connections for inter-node\n+communication and uses basic authentication for the external client API.\n+This is most likely to be paired with SSL above.\n+\n+Configuring internal for SSL-mutual authentication\n+--------------------------------------------------\n+\n+ksqlDB supports securing inter-node communication using SSL mutual authentication.\n+\n+For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.md#configuring-listeners-of-a-ksqldb-cluster).\n+\n+Your key store must contain the key pair for your internal listener set with\n+`ksql.internal.listener`.  If your internal certificate is not signed by a recognized\n+public Certificate Authority, a trust store is required to contain certificates for\n+nodes in your cluster.  Below is an example configuration:\n+\n+```properties\n+# Contains the internal key pair for this node.\n+# (e.g. key pair for node-1.internal.example.com)\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# Contains the certificates for nodes in the cluster.\n+# (e.g. certs for node-1.internal.example.com, node-2.internal.example.com)\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+# This enables mutual auth checking for the internal listener\n+ksql.internal.ssl.client.authentication=REQUIRED\n+```\n+\n+Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication\n+--------------------------------------------------------------------------------\n+\n+Client facing basic HTTP authentication can be used alongside authentication for the\n+internal listener. This ensures that neither the client or internal\n+APIs can be accessed by unauthorized users.\n+\n+!!! note\n+\tIf you're using Basic authentication, we recommended that you\n+    [configure ksqlDB to use HTTPS for secure communication](#configuring-listner-for-ssl-encryption),\n+    because the Basic protocol passes credentials in plain text.\n+\n+Below is an example configuration:\n+\n+```properties\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+ksql.internal.ssl.client.authentication=REQUIRED\n+\n+authentication.method=BASIC\n+authentication.roles=admin,developer,user,ksq-user\n+authentication.realm=KsqlServer-Props\n+\n+```\n+\n+For more detail on basic authentication,\n+[see above](#configure-ksqldb-for-basic-http-authentication).\n+\n+Configuring internal for SSL-mutual authentication + external for SSL encryption", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNzQzNQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440507435", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            --------------------------------------------------------------------------------\n          \n          \n            \n            ----------------------------------------------------------------------------------", "author": "JimGalasyn", "createdAt": "2020-06-15T23:49:37Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,13 +304,193 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n-Configure ksqlDB for Confluent Cloud\n+Securing dual listener setup\n+----------------------------\n+\n+Using dual listeners for ksqlDB is appropriate when the client and\n+inter-node communication utilize different authentication and security\n+configurations.  This is most likely the case when ksqlDB is deployed as an\n+IaaS service.\n+\n+The supported setups are SSL-mutual auth for the internal communication\n+combined with SSL encryption and authentication for the external client:\n+\n+[Configuring internal for SSL-mutual authentication](#configuring-intenral-for-ssl-mutual-authentication):\n+Creates secure and authenticated connections for inter-node communication,\n+but leaves the external\n+client API unsecured. This is most appropriate when clients are trusted, but\n+the internal APIs are protected from use.\n+\n+[Configuring internal for SSL-mutual authentication + external for SSL encryption](#configuring-internal-for-ssl-mutual-authentication-+-external-for-ssl-encryption):\n+Creates secure and authenticated connections for inter-node\n+communication and uses SSL for the external client API. This is most\n+likely to be pair with authentication below.\n+\n+[Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication](#configuring-internal-for-ssl-mutual-authentication-+-external-for-http-basic-authentication):\n+Creates secure and authenticated connections for inter-node\n+communication and uses basic authentication for the external client API.\n+This is most likely to be paired with SSL above.\n+\n+Configuring internal for SSL-mutual authentication\n+--------------------------------------------------\n+\n+ksqlDB supports securing inter-node communication using SSL mutual authentication.\n+\n+For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.md#configuring-listeners-of-a-ksqldb-cluster).\n+\n+Your key store must contain the key pair for your internal listener set with\n+`ksql.internal.listener`.  If your internal certificate is not signed by a recognized\n+public Certificate Authority, a trust store is required to contain certificates for\n+nodes in your cluster.  Below is an example configuration:\n+\n+```properties\n+# Contains the internal key pair for this node.\n+# (e.g. key pair for node-1.internal.example.com)\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# Contains the certificates for nodes in the cluster.\n+# (e.g. certs for node-1.internal.example.com, node-2.internal.example.com)\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+# This enables mutual auth checking for the internal listener\n+ksql.internal.ssl.client.authentication=REQUIRED\n+```\n+\n+Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication\n+--------------------------------------------------------------------------------\n+\n+Client facing basic HTTP authentication can be used alongside authentication for the\n+internal listener. This ensures that neither the client or internal\n+APIs can be accessed by unauthorized users.\n+\n+!!! note\n+\tIf you're using Basic authentication, we recommended that you\n+    [configure ksqlDB to use HTTPS for secure communication](#configuring-listner-for-ssl-encryption),\n+    because the Basic protocol passes credentials in plain text.\n+\n+Below is an example configuration:\n+\n+```properties\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+ksql.internal.ssl.client.authentication=REQUIRED\n+\n+authentication.method=BASIC\n+authentication.roles=admin,developer,user,ksq-user\n+authentication.realm=KsqlServer-Props\n+\n+```\n+\n+For more detail on basic authentication,\n+[see above](#configure-ksqldb-for-basic-http-authentication).\n+\n+Configuring internal for SSL-mutual authentication + external for SSL encryption\n+--------------------------------------------------------------------------------", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNzcxNQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440507715", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            different from its internal identity.  In order to create such a key store,\n          \n          \n            \n            different from its internal identity. To create such a key store,", "author": "JimGalasyn", "createdAt": "2020-06-15T23:50:37Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,13 +304,193 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n-Configure ksqlDB for Confluent Cloud\n+Securing dual listener setup\n+----------------------------\n+\n+Using dual listeners for ksqlDB is appropriate when the client and\n+inter-node communication utilize different authentication and security\n+configurations.  This is most likely the case when ksqlDB is deployed as an\n+IaaS service.\n+\n+The supported setups are SSL-mutual auth for the internal communication\n+combined with SSL encryption and authentication for the external client:\n+\n+[Configuring internal for SSL-mutual authentication](#configuring-intenral-for-ssl-mutual-authentication):\n+Creates secure and authenticated connections for inter-node communication,\n+but leaves the external\n+client API unsecured. This is most appropriate when clients are trusted, but\n+the internal APIs are protected from use.\n+\n+[Configuring internal for SSL-mutual authentication + external for SSL encryption](#configuring-internal-for-ssl-mutual-authentication-+-external-for-ssl-encryption):\n+Creates secure and authenticated connections for inter-node\n+communication and uses SSL for the external client API. This is most\n+likely to be pair with authentication below.\n+\n+[Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication](#configuring-internal-for-ssl-mutual-authentication-+-external-for-http-basic-authentication):\n+Creates secure and authenticated connections for inter-node\n+communication and uses basic authentication for the external client API.\n+This is most likely to be paired with SSL above.\n+\n+Configuring internal for SSL-mutual authentication\n+--------------------------------------------------\n+\n+ksqlDB supports securing inter-node communication using SSL mutual authentication.\n+\n+For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.md#configuring-listeners-of-a-ksqldb-cluster).\n+\n+Your key store must contain the key pair for your internal listener set with\n+`ksql.internal.listener`.  If your internal certificate is not signed by a recognized\n+public Certificate Authority, a trust store is required to contain certificates for\n+nodes in your cluster.  Below is an example configuration:\n+\n+```properties\n+# Contains the internal key pair for this node.\n+# (e.g. key pair for node-1.internal.example.com)\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# Contains the certificates for nodes in the cluster.\n+# (e.g. certs for node-1.internal.example.com, node-2.internal.example.com)\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+# This enables mutual auth checking for the internal listener\n+ksql.internal.ssl.client.authentication=REQUIRED\n+```\n+\n+Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication\n+--------------------------------------------------------------------------------\n+\n+Client facing basic HTTP authentication can be used alongside authentication for the\n+internal listener. This ensures that neither the client or internal\n+APIs can be accessed by unauthorized users.\n+\n+!!! note\n+\tIf you're using Basic authentication, we recommended that you\n+    [configure ksqlDB to use HTTPS for secure communication](#configuring-listner-for-ssl-encryption),\n+    because the Basic protocol passes credentials in plain text.\n+\n+Below is an example configuration:\n+\n+```properties\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+ksql.internal.ssl.client.authentication=REQUIRED\n+\n+authentication.method=BASIC\n+authentication.roles=admin,developer,user,ksq-user\n+authentication.realm=KsqlServer-Props\n+\n+```\n+\n+For more detail on basic authentication,\n+[see above](#configure-ksqldb-for-basic-http-authentication).\n+\n+Configuring internal for SSL-mutual authentication + external for SSL encryption\n+--------------------------------------------------------------------------------\n+\n+If you want to use HTTPS on `listeners` as well as use SSL mutual\n+auth for internal communication on `ksql.internal.listener`, you will likely\n+require two different key pairs, since your host's identity to clients may be\n+different from its internal identity.  In order to create such a key store,", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwNzkxMw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440507913", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            listener by providing a key store alias.  For example,\n          \n          \n            \n            listener by providing a key store alias.  For example,\n          \n      \n    \n    \n  \n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            listener by providing a key store alias.  For example,\n          \n          \n            \n            listener by providing a key store alias. For example,", "author": "JimGalasyn", "createdAt": "2020-06-15T23:51:14Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,13 +304,193 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n-Configure ksqlDB for Confluent Cloud\n+Securing dual listener setup\n+----------------------------\n+\n+Using dual listeners for ksqlDB is appropriate when the client and\n+inter-node communication utilize different authentication and security\n+configurations.  This is most likely the case when ksqlDB is deployed as an\n+IaaS service.\n+\n+The supported setups are SSL-mutual auth for the internal communication\n+combined with SSL encryption and authentication for the external client:\n+\n+[Configuring internal for SSL-mutual authentication](#configuring-intenral-for-ssl-mutual-authentication):\n+Creates secure and authenticated connections for inter-node communication,\n+but leaves the external\n+client API unsecured. This is most appropriate when clients are trusted, but\n+the internal APIs are protected from use.\n+\n+[Configuring internal for SSL-mutual authentication + external for SSL encryption](#configuring-internal-for-ssl-mutual-authentication-+-external-for-ssl-encryption):\n+Creates secure and authenticated connections for inter-node\n+communication and uses SSL for the external client API. This is most\n+likely to be pair with authentication below.\n+\n+[Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication](#configuring-internal-for-ssl-mutual-authentication-+-external-for-http-basic-authentication):\n+Creates secure and authenticated connections for inter-node\n+communication and uses basic authentication for the external client API.\n+This is most likely to be paired with SSL above.\n+\n+Configuring internal for SSL-mutual authentication\n+--------------------------------------------------\n+\n+ksqlDB supports securing inter-node communication using SSL mutual authentication.\n+\n+For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.md#configuring-listeners-of-a-ksqldb-cluster).\n+\n+Your key store must contain the key pair for your internal listener set with\n+`ksql.internal.listener`.  If your internal certificate is not signed by a recognized\n+public Certificate Authority, a trust store is required to contain certificates for\n+nodes in your cluster.  Below is an example configuration:\n+\n+```properties\n+# Contains the internal key pair for this node.\n+# (e.g. key pair for node-1.internal.example.com)\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# Contains the certificates for nodes in the cluster.\n+# (e.g. certs for node-1.internal.example.com, node-2.internal.example.com)\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+# This enables mutual auth checking for the internal listener\n+ksql.internal.ssl.client.authentication=REQUIRED\n+```\n+\n+Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication\n+--------------------------------------------------------------------------------\n+\n+Client facing basic HTTP authentication can be used alongside authentication for the\n+internal listener. This ensures that neither the client or internal\n+APIs can be accessed by unauthorized users.\n+\n+!!! note\n+\tIf you're using Basic authentication, we recommended that you\n+    [configure ksqlDB to use HTTPS for secure communication](#configuring-listner-for-ssl-encryption),\n+    because the Basic protocol passes credentials in plain text.\n+\n+Below is an example configuration:\n+\n+```properties\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+ksql.internal.ssl.client.authentication=REQUIRED\n+\n+authentication.method=BASIC\n+authentication.roles=admin,developer,user,ksq-user\n+authentication.realm=KsqlServer-Props\n+\n+```\n+\n+For more detail on basic authentication,\n+[see above](#configure-ksqldb-for-basic-http-authentication).\n+\n+Configuring internal for SSL-mutual authentication + external for SSL encryption\n+--------------------------------------------------------------------------------\n+\n+If you want to use HTTPS on `listeners` as well as use SSL mutual\n+auth for internal communication on `ksql.internal.listener`, you will likely\n+require two different key pairs, since your host's identity to clients may be\n+different from its internal identity.  In order to create such a key store,\n+refer [below](#setting-up-a-key-store-and-trust-store).\n+\n+In such a configuration, you must specify which key pair is used for a given\n+listener by providing a key store alias.  For example,", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwODA1Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440508052", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            with the given alias when setting up the internal listener.  Similarly,\n          \n          \n            \n            with the given alias when setting up the internal listener. Similarly,", "author": "JimGalasyn", "createdAt": "2020-06-15T23:51:44Z", "path": "docs/operate-and-deploy/installation/server-config/security.md", "diffHunk": "@@ -219,13 +304,193 @@ credentials when starting the CLI by using the `--user` and\n <ksql-install>bin/ksql --user fred --password letmein http://localhost:8088\n ```\n \n-Configure ksqlDB for Confluent Cloud\n+Securing dual listener setup\n+----------------------------\n+\n+Using dual listeners for ksqlDB is appropriate when the client and\n+inter-node communication utilize different authentication and security\n+configurations.  This is most likely the case when ksqlDB is deployed as an\n+IaaS service.\n+\n+The supported setups are SSL-mutual auth for the internal communication\n+combined with SSL encryption and authentication for the external client:\n+\n+[Configuring internal for SSL-mutual authentication](#configuring-intenral-for-ssl-mutual-authentication):\n+Creates secure and authenticated connections for inter-node communication,\n+but leaves the external\n+client API unsecured. This is most appropriate when clients are trusted, but\n+the internal APIs are protected from use.\n+\n+[Configuring internal for SSL-mutual authentication + external for SSL encryption](#configuring-internal-for-ssl-mutual-authentication-+-external-for-ssl-encryption):\n+Creates secure and authenticated connections for inter-node\n+communication and uses SSL for the external client API. This is most\n+likely to be pair with authentication below.\n+\n+[Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication](#configuring-internal-for-ssl-mutual-authentication-+-external-for-http-basic-authentication):\n+Creates secure and authenticated connections for inter-node\n+communication and uses basic authentication for the external client API.\n+This is most likely to be paired with SSL above.\n+\n+Configuring internal for SSL-mutual authentication\n+--------------------------------------------------\n+\n+ksqlDB supports securing inter-node communication using SSL mutual authentication.\n+\n+For more information about configuring `ksql.internal.listener`, see [Configuring Listeners of a ksqlDB Cluster](index.md#configuring-listeners-of-a-ksqldb-cluster).\n+\n+Your key store must contain the key pair for your internal listener set with\n+`ksql.internal.listener`.  If your internal certificate is not signed by a recognized\n+public Certificate Authority, a trust store is required to contain certificates for\n+nodes in your cluster.  Below is an example configuration:\n+\n+```properties\n+# Contains the internal key pair for this node.\n+# (e.g. key pair for node-1.internal.example.com)\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+# Contains the certificates for nodes in the cluster.\n+# (e.g. certs for node-1.internal.example.com, node-2.internal.example.com)\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+# This enables mutual auth checking for the internal listener\n+ksql.internal.ssl.client.authentication=REQUIRED\n+```\n+\n+Configuring internal for SSL-mutual authentication + external for HTTP-BASIC authentication\n+--------------------------------------------------------------------------------\n+\n+Client facing basic HTTP authentication can be used alongside authentication for the\n+internal listener. This ensures that neither the client or internal\n+APIs can be accessed by unauthorized users.\n+\n+!!! note\n+\tIf you're using Basic authentication, we recommended that you\n+    [configure ksqlDB to use HTTPS for secure communication](#configuring-listner-for-ssl-encryption),\n+    because the Basic protocol passes credentials in plain text.\n+\n+Below is an example configuration:\n+\n+```properties\n+ssl.keystore.location=/var/private/ssl/ksql.server.keystore.jks\n+ssl.keystore.password=xxxx\n+ssl.key.password=yyyy\n+\n+ssl.truststore.location=/var/private/ssl/ksql.server.truststore.jks\n+ssl.truststore.password=zzzz\n+\n+listeners=http://0.0.0.0:8088\n+ksql.internal.listener=https://node-1.internal.example.com:8099\n+\n+ksql.internal.ssl.client.authentication=REQUIRED\n+\n+authentication.method=BASIC\n+authentication.roles=admin,developer,user,ksq-user\n+authentication.realm=KsqlServer-Props\n+\n+```\n+\n+For more detail on basic authentication,\n+[see above](#configure-ksqldb-for-basic-http-authentication).\n+\n+Configuring internal for SSL-mutual authentication + external for SSL encryption\n+--------------------------------------------------------------------------------\n+\n+If you want to use HTTPS on `listeners` as well as use SSL mutual\n+auth for internal communication on `ksql.internal.listener`, you will likely\n+require two different key pairs, since your host's identity to clients may be\n+different from its internal identity.  In order to create such a key store,\n+refer [below](#setting-up-a-key-store-and-trust-store).\n+\n+In such a configuration, you must specify which key pair is used for a given\n+listener by providing a key store alias.  For example,\n+if set, `ksql.ssl.keystore.alias.internal` will be used to find the key store entry\n+with the given alias when setting up the internal listener.  Similarly,", "originalCommit": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "910b08697de0df726d6d7198a4d147ae37d0268d", "url": "https://github.com/confluentinc/ksql/commit/910b08697de0df726d6d7198a4d147ae37d0268d", "message": "Apply suggestions from code review\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>", "committedDate": "2020-06-16T00:04:29Z", "type": "commit"}, {"oid": "a7de9880dcb6ac4031037149ff6b33a00a3b4c3f", "url": "https://github.com/confluentinc/ksql/commit/a7de9880dcb6ac4031037149ff6b33a00a3b4c3f", "message": "Fixes many links in doc", "committedDate": "2020-06-16T00:51:36Z", "type": "commit"}]}