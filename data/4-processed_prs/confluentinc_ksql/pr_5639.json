{"pr_number": 5639, "pr_title": "docs: API docs for new Server endpoints", "pr_createdAt": "2020-06-18T11:45:13Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5639", "timeline": [{"oid": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "url": "https://github.com/confluentinc/ksql/commit/ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "message": "api docs", "committedDate": "2020-06-17T15:19:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyMjQzMw==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445022433", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\n          \n          \n            \n            !!! note\n          \n          \n            \n                These endpoints are used by the ksqlDB Java client. If you're using Java, consider", "author": "JimGalasyn", "createdAt": "2020-06-24T16:31:12Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyMjYwMg==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445022602", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            to consider using the Java client rather than using this API directly.\n          \n          \n            \n            using the Java client rather than using this API directly.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:31:29Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyMjc5OQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445022799", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The request method will be a POST.\n          \n          \n            \n            The request method is a POST.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:31:50Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyMjk4MA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445022980", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Requests will be made to the endpoint \"/query-stream\".\n          \n          \n            \n            Send requests to the `/query-stream` endpoint.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:32:09Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyMzM0OQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445023349", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            operation (newlines have been added here for the sake of clarity but the real JSON must not contain\n          \n          \n            \n            operation. Newlines have been added here for the sake of clarity, but actual JSON must not contain", "author": "JimGalasyn", "createdAt": "2020-06-24T16:32:45Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyMzQ4NQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445023485", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             unescaped newlines)\n          \n          \n            \n             unescaped newlines.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:33:01Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyMzYyNw==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445023627", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````\n          \n          \n            \n            ```json", "author": "JimGalasyn", "createdAt": "2020-06-24T16:33:12Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNDEwNg==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445024106", "bodyText": "(three backticks)", "author": "JimGalasyn", "createdAt": "2020-06-24T16:34:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyMzYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyMzg2MA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445023860", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````", "author": "JimGalasyn", "createdAt": "2020-06-24T16:33:39Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNDA0Mg==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445024042", "bodyText": "(three backticks)", "author": "JimGalasyn", "createdAt": "2020-06-24T16:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyMzg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNDI4Mg==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445024282", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The endpoint produces responses with two possible content types `application/json` and\n          \n          \n            \n            The endpoint produces responses with two possible content types: `application/json` and", "author": "JimGalasyn", "createdAt": "2020-06-24T16:34:20Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNDYyOA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445024628", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\n          \n          \n            \n            `application/vnd.ksqlapi.delimited.v1`. To specify the content type, set the `Accept`", "author": "JimGalasyn", "createdAt": "2020-06-24T16:34:56Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNDc4Nw==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445024787", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\n          \n          \n            \n            In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`,", "author": "JimGalasyn", "createdAt": "2020-06-24T16:35:12Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNDkzMA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445024930", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            then the results are returned as a header JSON object followed by zero or more JSON arrays\n          \n          \n            \n            the results are returned as a header JSON object followed by zero or more JSON arrays", "author": "JimGalasyn", "createdAt": "2020-06-24T16:35:29Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNTE5MQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445025191", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\n          \n          \n            \n            that are delimited by newlines. Newline-delimited formats are easy to parse by clients and don't require", "author": "JimGalasyn", "createdAt": "2020-06-24T16:35:54Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNTM3OQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445025379", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````\n          \n          \n            \n            ```json", "author": "JimGalasyn", "createdAt": "2020-06-24T16:36:11Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNjMwMA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445026300", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````", "author": "JimGalasyn", "createdAt": "2020-06-24T16:37:46Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNjQxNg==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445026416", "bodyText": "(three backticks)", "author": "JimGalasyn", "createdAt": "2020-06-24T16:37:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNjMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNjU3OQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445026579", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````", "author": "JimGalasyn", "createdAt": "2020-06-24T16:38:14Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNjY0Nw==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445026647", "bodyText": "(three backticks)", "author": "JimGalasyn", "createdAt": "2020-06-24T16:38:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNjU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNjc1OQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445026759", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````\n          \n          \n            \n            ```json", "author": "JimGalasyn", "createdAt": "2020-06-24T16:38:32Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNjk2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445026965", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you prefer to receive the entire response as valid JSON then you can request\n          \n          \n            \n            If you prefer to receive the entire response as valid JSON, request the", "author": "JimGalasyn", "createdAt": "2020-06-24T16:38:57Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNzMwNQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445027305", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            content type `application/json`. In which case you will receive the results, as a single JSON\n          \n          \n            \n            `application/json` content type. In this case, you receive the results as a single JSON", "author": "JimGalasyn", "createdAt": "2020-06-24T16:39:30Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNzc1Mw==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445027753", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            array, for example: (newlines have been added for clarity, the response body\n          \n          \n            \n            array, as shown in the following example. Newlines have been added for clarity, and the response body", "author": "JimGalasyn", "createdAt": "2020-06-24T16:40:19Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNzg3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445027872", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            won't contain newlines).\n          \n          \n            \n            won't contain newlines.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:40:31Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyODA0Mg==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445028042", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````\n          \n          \n            \n            ```json", "author": "JimGalasyn", "createdAt": "2020-06-24T16:40:46Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyODE1Nw==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445028157", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````", "author": "JimGalasyn", "createdAt": "2020-06-24T16:40:57Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyODI4NQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445028285", "bodyText": "(three backticks)", "author": "JimGalasyn", "createdAt": "2020-06-24T16:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyODE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyODk3OA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445028978", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Push queries can be explicitly terminated by the client by making a request to this endpoint\n          \n          \n            \n            You can terminate push queries explicitly in the client by making a request to this endpoint.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:42:15Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyOTE3NA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445029174", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The request method will be a POST.\n          \n          \n            \n            The request method is POST.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:42:30Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyOTUwOA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445029508", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Requests will be made to the endpoint \"/close-query\"\n          \n          \n            \n            Send requests to the `/close-query` endpoint.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:43:05Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyOTc5Mg==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445029792", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            query to close. (newlines have been added here for the sake of clarity but the real JSON must not\n          \n          \n            \n            query to close. Newlines are added here for the sake of clarity, but the actual JSON must not", "author": "JimGalasyn", "createdAt": "2020-06-24T16:43:33Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyOTg4OA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445029888", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            contain newlines)\n          \n          \n            \n            contain newlines.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:43:44Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMDAxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445030019", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````\n          \n          \n            \n            ```json", "author": "JimGalasyn", "createdAt": "2020-06-24T16:43:57Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMDEyNg==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445030126", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````", "author": "JimGalasyn", "createdAt": "2020-06-24T16:44:08Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMDIzOA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445030238", "bodyText": "(three backticks)", "author": "JimGalasyn", "createdAt": "2020-06-24T16:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMDEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMDM0NA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445030344", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The request method will be a POST.\n          \n          \n            \n            The request method is POST.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:44:30Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMDU5Nw==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445030597", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Requests will be made to the endpoint \"/insert-stream\".\n          \n          \n            \n            Send requests to the `/insert-stream` endpoint.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:44:54Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMDk3Ng==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445030976", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            operation (newlines have been added for clarity, the real JSON must not contain newlines):\n          \n          \n            \n            operation. Newlines are added for clarity, but the actual JSON must not contain newlines.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:45:27Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTA2NA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445031064", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````\n          \n          \n            \n            ```json", "author": "JimGalasyn", "createdAt": "2020-06-24T16:45:37Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTE3NA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445031174", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````", "author": "JimGalasyn", "createdAt": "2020-06-24T16:45:47Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTI3NQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445031275", "bodyText": "(three backticks)", "author": "JimGalasyn", "createdAt": "2020-06-24T16:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTM4NA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445031384", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````\n          \n          \n            \n            ```json", "author": "JimGalasyn", "createdAt": "2020-06-24T16:46:06Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTQ5NA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445031494", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````", "author": "JimGalasyn", "createdAt": "2020-06-24T16:46:16Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r\n+\"col2\": 2.3,\r\n+\"col3\", true\r\n+}\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTY3NQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445031675", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Each JSON object will be separated by a new line.\n          \n          \n            \n            Each JSON object is separated by a newline.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:46:32Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r\n+\"col2\": 2.3,\r\n+\"col3\", true\r\n+}\r\n+````\r\n+Each JSON object will be separated by a new line.\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTg0MQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445031841", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To terminate the insert stream the client should end the request.\n          \n          \n            \n            To terminate the insert stream, the client must end the request.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:46:48Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r\n+\"col2\": 2.3,\r\n+\"col3\", true\r\n+}\r\n+````\r\n+Each JSON object will be separated by a new line.\r\n+\r\n+To terminate the insert stream the client should end the request.\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMjE4NQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445032185", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Acks will be written to the response when each row has been\n          \n          \n            \n            An ack is written to the response when each row has been", "author": "JimGalasyn", "createdAt": "2020-06-24T16:47:21Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r\n+\"col2\": 2.3,\r\n+\"col3\", true\r\n+}\r\n+````\r\n+Each JSON object will be separated by a new line.\r\n+\r\n+To terminate the insert stream the client should end the request.\r\n+\r\n+Acks will be written to the response when each row has been\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMjQwOA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445032408", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            successfully committed to the underlying topic. Rows are committed in the order they are provided.\n          \n          \n            \n            committed successfully to the underlying topic. Rows are committed in the order they are provided.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:47:40Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r\n+\"col2\": 2.3,\r\n+\"col3\", true\r\n+}\r\n+````\r\n+Each JSON object will be separated by a new line.\r\n+\r\n+To terminate the insert stream the client should end the request.\r\n+\r\n+Acks will be written to the response when each row has been\r\n+successfully committed to the underlying topic. Rows are committed in the order they are provided.\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMjU2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445032565", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````\n          \n          \n            \n            ```json", "author": "JimGalasyn", "createdAt": "2020-06-24T16:47:53Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r\n+\"col2\": 2.3,\r\n+\"col3\", true\r\n+}\r\n+````\r\n+Each JSON object will be separated by a new line.\r\n+\r\n+To terminate the insert stream the client should end the request.\r\n+\r\n+Acks will be written to the response when each row has been\r\n+successfully committed to the underlying topic. Rows are committed in the order they are provided.\r\n+Each ack in the response is a JSON object, separated by newlines:\r\n+\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMjY5MA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445032690", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ````", "author": "JimGalasyn", "createdAt": "2020-06-24T16:48:05Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r\n+\"col2\": 2.3,\r\n+\"col3\", true\r\n+}\r\n+````\r\n+Each JSON object will be separated by a new line.\r\n+\r\n+To terminate the insert stream the client should end the request.\r\n+\r\n+Acks will be written to the response when each row has been\r\n+successfully committed to the underlying topic. Rows are committed in the order they are provided.\r\n+Each ack in the response is a JSON object, separated by newlines:\r\n+\r\n+````\r\n+{\"status\":\"ok\",\"seq\":0}\r\n+{\"status\":\"ok\",\"seq\":2}\r\n+{\"status\":\"ok\",\"seq\":1}\r\n+{\"status\":\"ok\",\"seq\":3}\r\n+````\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMjkxOA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445032918", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A successful ack will contain a field `status` with value `ok`.\n          \n          \n            \n            A successful ack contains a `status` field with value of `ok`.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:48:26Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r\n+\"col2\": 2.3,\r\n+\"col3\", true\r\n+}\r\n+````\r\n+Each JSON object will be separated by a new line.\r\n+\r\n+To terminate the insert stream the client should end the request.\r\n+\r\n+Acks will be written to the response when each row has been\r\n+successfully committed to the underlying topic. Rows are committed in the order they are provided.\r\n+Each ack in the response is a JSON object, separated by newlines:\r\n+\r\n+````\r\n+{\"status\":\"ok\",\"seq\":0}\r\n+{\"status\":\"ok\",\"seq\":2}\r\n+{\"status\":\"ok\",\"seq\":1}\r\n+{\"status\":\"ok\",\"seq\":3}\r\n+````\r\n+\r\n+A successful ack will contain a field `status` with value `ok`.\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMzI2NA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445033264", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            All ack responses also contain a field `seq` with a 64 bit signed integer value. This number\n          \n          \n            \n            All ack responses also contain a `seq` field with a 64-bit signed integer value. This number", "author": "JimGalasyn", "createdAt": "2020-06-24T16:48:59Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r\n+\"col2\": 2.3,\r\n+\"col3\", true\r\n+}\r\n+````\r\n+Each JSON object will be separated by a new line.\r\n+\r\n+To terminate the insert stream the client should end the request.\r\n+\r\n+Acks will be written to the response when each row has been\r\n+successfully committed to the underlying topic. Rows are committed in the order they are provided.\r\n+Each ack in the response is a JSON object, separated by newlines:\r\n+\r\n+````\r\n+{\"status\":\"ok\",\"seq\":0}\r\n+{\"status\":\"ok\",\"seq\":2}\r\n+{\"status\":\"ok\",\"seq\":1}\r\n+{\"status\":\"ok\",\"seq\":3}\r\n+````\r\n+\r\n+A successful ack will contain a field `status` with value `ok`.\r\n+\r\n+All ack responses also contain a field `seq` with a 64 bit signed integer value. This number\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMzY1NQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445033655", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In case of error, an error response (see below) will be sent. For an error response for a send, the\n          \n          \n            \n            In case of error, an error response (see below) is sent. For an error response for a send, the", "author": "JimGalasyn", "createdAt": "2020-06-24T16:49:37Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r\n+\"col2\": 2.3,\r\n+\"col3\", true\r\n+}\r\n+````\r\n+Each JSON object will be separated by a new line.\r\n+\r\n+To terminate the insert stream the client should end the request.\r\n+\r\n+Acks will be written to the response when each row has been\r\n+successfully committed to the underlying topic. Rows are committed in the order they are provided.\r\n+Each ack in the response is a JSON object, separated by newlines:\r\n+\r\n+````\r\n+{\"status\":\"ok\",\"seq\":0}\r\n+{\"status\":\"ok\",\"seq\":2}\r\n+{\"status\":\"ok\",\"seq\":1}\r\n+{\"status\":\"ok\",\"seq\":3}\r\n+````\r\n+\r\n+A successful ack will contain a field `status` with value `ok`.\r\n+\r\n+All ack responses also contain a field `seq` with a 64 bit signed integer value. This number\r\n+corresponds to the sequence of the insert on the request. The first send has sequence `0`, the second\r\n+`1`, the third `2`, etc. It allows the client to correlate the ack to the corresponding send.\r\n+\r\n+In case of error, an error response (see below) will be sent. For an error response for a send, the\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMzg3NA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445033874", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `seq` field will also be included. \n          \n          \n            \n            `seq` field is included.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:49:58Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r\n+\"col2\": 2.3,\r\n+\"col3\", true\r\n+}\r\n+````\r\n+Each JSON object will be separated by a new line.\r\n+\r\n+To terminate the insert stream the client should end the request.\r\n+\r\n+Acks will be written to the response when each row has been\r\n+successfully committed to the underlying topic. Rows are committed in the order they are provided.\r\n+Each ack in the response is a JSON object, separated by newlines:\r\n+\r\n+````\r\n+{\"status\":\"ok\",\"seq\":0}\r\n+{\"status\":\"ok\",\"seq\":2}\r\n+{\"status\":\"ok\",\"seq\":1}\r\n+{\"status\":\"ok\",\"seq\":3}\r\n+````\r\n+\r\n+A successful ack will contain a field `status` with value `ok`.\r\n+\r\n+All ack responses also contain a field `seq` with a 64 bit signed integer value. This number\r\n+corresponds to the sequence of the insert on the request. The first send has sequence `0`, the second\r\n+`1`, the third `2`, etc. It allows the client to correlate the ack to the corresponding send.\r\n+\r\n+In case of error, an error response (see below) will be sent. For an error response for a send, the\r\n+`seq` field will also be included. \r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzNDQ2Ng==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445034466", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Please note that acks can be returned in a different sequence to which the inserts were submitted. \n          \n          \n            \n            !!! note\n          \n          \n            \n                Acks can be returned in a different sequence to which the inserts were submitted.", "author": "JimGalasyn", "createdAt": "2020-06-24T16:51:04Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r\n+\"col2\": 2.3,\r\n+\"col3\", true\r\n+}\r\n+````\r\n+Each JSON object will be separated by a new line.\r\n+\r\n+To terminate the insert stream the client should end the request.\r\n+\r\n+Acks will be written to the response when each row has been\r\n+successfully committed to the underlying topic. Rows are committed in the order they are provided.\r\n+Each ack in the response is a JSON object, separated by newlines:\r\n+\r\n+````\r\n+{\"status\":\"ok\",\"seq\":0}\r\n+{\"status\":\"ok\",\"seq\":2}\r\n+{\"status\":\"ok\",\"seq\":1}\r\n+{\"status\":\"ok\",\"seq\":3}\r\n+````\r\n+\r\n+A successful ack will contain a field `status` with value `ok`.\r\n+\r\n+All ack responses also contain a field `seq` with a 64 bit signed integer value. This number\r\n+corresponds to the sequence of the insert on the request. The first send has sequence `0`, the second\r\n+`1`, the third `2`, etc. It allows the client to correlate the ack to the corresponding send.\r\n+\r\n+In case of error, an error response (see below) will be sent. For an error response for a send, the\r\n+`seq` field will also be included. \r\n+\r\n+Please note that acks can be returned in a different sequence to which the inserts were submitted. \r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyNzMxNw==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445027317", "bodyText": "Clarify that this is empty in the case of pull queries (and non-empty in the case of push queries).", "author": "vcrfxia", "createdAt": "2020-06-24T16:39:31Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyOTIwMg==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445029202", "bodyText": "Can we also add a note about the error response format? Specifically, the rows are JSON arrays unless an error is encountered while streaming, in which case a JSON object of a particular format is returned. I know last time we said this doesn't appear to actually happen even though the infrastructure is set up for it, but it'd still be useful to call out since clients should handle this case.", "author": "vcrfxia", "createdAt": "2020-06-24T16:42:32Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ3NTk5OQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445475999", "bodyText": "I don't think this can happen so doesn't make sense to me to add it to the docs.", "author": "purplefox", "createdAt": "2020-06-25T10:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyOTIwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcwNzI4MA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445707280", "bodyText": "Will we want to support errors in this way in the future? If not we should remove the functionality from the server to clean up the code. If so we should have a plan for how to update clients to support these errors if the error mechanism is added in the future. (The Java client already supports them, but authors of any new clients won't if the mechanism isn't documented.) It seems easier to have clients support the mechanism up front rather than having to go through and add support in the clients when we want to start using the mechanism.", "author": "vcrfxia", "createdAt": "2020-06-25T17:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyOTIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAyOTYxMg==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445029612", "bodyText": "As above: clarify that this is empty in the case of pull queries (and non-empty in the case of push queries).", "author": "vcrfxia", "createdAt": "2020-06-24T16:43:16Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMDA3OA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445030078", "bodyText": "Are there supposed to be commas after each of these lines? This doesn't look like valid JSON as written.", "author": "vcrfxia", "createdAt": "2020-06-24T16:44:03Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMDczMA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445030730", "bodyText": "The endpoint is /inserts-stream, not /insert-stream.", "author": "vcrfxia", "createdAt": "2020-06-24T16:45:04Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTYyNA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445031624", "bodyText": "Clarify that this is case-insensitive (uppercased by default). Users can surround the name in either backticks or double quotes to make it case-sensitive.", "author": "vcrfxia", "createdAt": "2020-06-24T16:46:27Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzNTc0NQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445035745", "bodyText": "Also, ksqlDB, not KSQL.", "author": "vcrfxia", "createdAt": "2020-06-24T16:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4MzA3OQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445483079", "bodyText": "Can you clarify what the semantics are here?\nCase insensitive means that:\nfoo will match streams \"foo\", \"FOO\", \"fOO\".\nand\nFOO will match streams \"foo\", \"FOO\", \"fOO\"\nIf we just uppercase what the client specifies then that seems different to case insensitive, i.e.\nfoo will match FOO, but not foo", "author": "purplefox", "createdAt": "2020-06-25T11:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcwNjYzOA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445706638", "bodyText": "You're correct; we just uppercase by default so it's not truly case-insensitive. I meant case-insensitivity in the sense that if users never use quotes/backticks (in all their requests and statements) then the behavior of ksqlDB is case-insensitive (because everything is always uppercased).", "author": "vcrfxia", "createdAt": "2020-06-25T17:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMTk4MQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445031981", "bodyText": "Clarify that these field names are case-insensitive (uppercased by default). Users can surround the names in either backticks or double quotes to make them case-sensitive.", "author": "vcrfxia", "createdAt": "2020-06-24T16:47:00Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMzk4MQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445033981", "bodyText": "Do we have a section on error responses? I agree it'd be useful to have.", "author": "vcrfxia", "createdAt": "2020-06-24T16:50:09Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/insert-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added for clarity, the real JSON must not contain newlines):\r\n+\r\n+````\r\n+{\r\n+\"target\": \"my-stream\" <----- The name of the KSQL stream to insert into\r\n+}\r\n+\r\n+````\r\n+\r\n+Followed by zero or more JSON objects representing the values to insert:\r\n+\r\n+````\r\n+{\r\n+\"col1\" : \"val1\",\r\n+\"col2\": 2.3,\r\n+\"col3\", true\r\n+}\r\n+````\r\n+Each JSON object will be separated by a new line.\r\n+\r\n+To terminate the insert stream the client should end the request.\r\n+\r\n+Acks will be written to the response when each row has been\r\n+successfully committed to the underlying topic. Rows are committed in the order they are provided.\r\n+Each ack in the response is a JSON object, separated by newlines:\r\n+\r\n+````\r\n+{\"status\":\"ok\",\"seq\":0}\r\n+{\"status\":\"ok\",\"seq\":2}\r\n+{\"status\":\"ok\",\"seq\":1}\r\n+{\"status\":\"ok\",\"seq\":3}\r\n+````\r\n+\r\n+A successful ack will contain a field `status` with value `ok`.\r\n+\r\n+All ack responses also contain a field `seq` with a 64 bit signed integer value. This number\r\n+corresponds to the sequence of the insert on the request. The first send has sequence `0`, the second\r\n+`1`, the third `2`, etc. It allows the client to correlate the ack to the corresponding send.\r\n+\r\n+In case of error, an error response (see below) will be sent. For an error response for a send, the\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ4NDcwNQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445484705", "bodyText": "It's the on the main api page", "author": "purplefox", "createdAt": "2020-06-25T11:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMzk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcwNzIwOQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445707209", "bodyText": "I think my confusion is whether \"see below\" makes sense or not. These docs are on their own page, so there is no \"below\", right? Replacing the \"see below\" with a link to the error section from the main page would clear up my confusion.", "author": "vcrfxia", "createdAt": "2020-06-25T17:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzMzk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzNDgxMA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445034810", "bodyText": "Perhaps replace with \"Inserting rows into an existing stream\" to clarify the use case?\nRegardless of whether we change the subheading, we should clarify that this endpoint only allows insertion of rows into ksqlDB streams and not tables. (I see the comment in the example specifies \"KSQL stream\" but I think this is worth calling out explicitly in the text as well.)", "author": "vcrfxia", "createdAt": "2020-06-24T16:51:37Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r\n+}\r\n+\r\n+````\r\n+ \r\n+### Streaming inserts\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzNzA3MA==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445037070", "bodyText": "Remove this comma so this is valid JSON.", "author": "vcrfxia", "createdAt": "2020-06-24T16:55:30Z", "path": "docs/developer-guide/ksqldb-rest-api/streaming-endpoint.md", "diffHunk": "@@ -0,0 +1,147 @@\n+---\r\n+layout: page\r\n+title: HTTP Streaming API\r\n+tagline: streaming endpoints\r\n+description: The HTTP Streaming API lets you execute pull or push queries and stream inserts to the\r\n+server\r\n+keywords: ksqlDB, query, insert, select\r\n+---\r\n+\r\n+Please note: These endpoints are used by the ksqlDB Java client. If you are using Java you might want\r\n+to consider using the Java client rather than using this API directly.\r\n+\r\n+These endpoints are only available when using HTTP 2.\r\n+\r\n+### Executing pull or push queries\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/query-stream\".\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the arguments for the\r\n+operation (newlines have been added here for the sake of clarity but the real JSON must not contain\r\n+ unescaped newlines)\r\n+\r\n+````\r\n+{\r\n+\"sql\": \"select * from foo\", <----- the SQL of the query to execute\r\n+\"properties\": {             <----- Optional properties for the query\r\n+    \"prop1\": \"val1\",\r\n+    \"prop2\": \"val2\"\r\n+   }\r\n+}\r\n+\r\n+````\r\n+\r\n+The endpoint produces responses with two possible content types `application/json` and\r\n+`application/vnd.ksqlapi.delimited.v1`. To choose one or the other you should set the `Accept`\r\n+header in the request. The default is `application/vnd.ksqlapi.delimited.v1`.\r\n+\r\n+In the case of a successful query, if the content type is `application/vnd.ksqlapi.delimited.v1`\r\n+then the results are returned as a header JSON object followed by zero or more JSON arrays\r\n+delimited by newlines. Newline delimited formats are easy to parse by clients, and don't require\r\n+a streaming JSON parser on the client in the case that intermediate results need to be output.\r\n+\r\n+````\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+}\r\n+````\r\n+\r\n+Followed by zero or more JSON arrays:\r\n+\r\n+````\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+````\r\n+\r\n+If you prefer to receive the entire response as valid JSON then you can request\r\n+content type `application/json`. In which case you will receive the results, as a single JSON\r\n+array, for example: (newlines have been added for clarity, the response body\r\n+won't contain newlines).\r\n+\r\n+````\r\n+[\r\n+{\r\n+\"queryId\", \"xyz123\",                          <---- unique ID of the query, used when terminating the query\r\n+\"columnNames\":[\"col\", \"col2\", \"col3\"],        <---- the names of the columns\r\n+\"columnTypes\":[\"BIGINT\", \"STRING\", \"BOOLEAN\"] <---- The types of the columns\r\n+},\r\n+[123, \"blah\", true]\r\n+[432, \"foo\", true]\r\n+[765, \"whatever\", false]\r\n+]\r\n+````\r\n+\r\n+### Terminating queries\r\n+\r\n+Push queries can be explicitly terminated by the client by making a request to this endpoint\r\n+\r\n+The request method will be a POST.\r\n+\r\n+Requests will be made to the endpoint \"/close-query\"\r\n+\r\n+The body of the request is a JSON object UTF-8 encoded as text, containing the id of the \r\n+query to close. (newlines have been added here for the sake of clarity but the real JSON must not\r\n+contain newlines)\r\n+\r\n+````\r\n+{\r\n+\"queryId\": \"xyz123\", <----- the ID of the query to terminate\r", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzODI2MQ==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445038261", "bodyText": "This should say /query endpoint rather than /query-stream endpoint, right?\nAlso, are we officially deprecating this endpoint? Are there any situations in which clients can't use HTTP/2?", "author": "vcrfxia", "createdAt": "2020-06-24T16:57:29Z", "path": "docs/developer-guide/api.md", "diffHunk": "@@ -1,22 +1,24 @@\n ---\n layout: page\n-title: ksqlDB REST API Reference\n-tagline: Run queries over REST\n+title: ksqlDB HTTP API Reference\n+tagline: Run queries over HTTP\n description: Learn how to communicate with ksqlDB by using HTTP\n ---\n \n - [Get the Status of a ksqlDB Server (/info endpoint)](ksqldb-rest-api/info-endpoint.md)\n - [Run a ksqlDB Statement (/ksql endpoint)](ksqldb-rest-api/ksql-endpoint.md)\n-- [Run A Query And Stream Back The Output (/query endpoint)](ksqldb-rest-api/query-endpoint.md)\n+- [Execute a push or pull query and stream the results back (/query-stream endpoint)](ksqldb-rest-api/streaming-endpoint.md)\n+- [Stream inserts to the server (/inserts-stream endpoint)](ksqldb-rest-api/streaming-endpoint.md)\n+- [Deprecated: Run A Pull or Push Query And Stream Back The Chunked Output (/query-stream endpoint)](ksqldb-rest-api/query-endpoint.md)", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcxMTg3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445711872", "bodyText": "The old /query implementation is very inefficient - it has a scheduled executor which polls the queue. If we don't deprecate this endpoint right now (because of HTTP 1.1 only clients) I would suggest extending the new query-stream endpoint so that if the protocol is HTTP1.x it sends back the response using chunked encoding. This would be fairly straightforward to do. Then the old endpoint can be deprecated and removed eventually.", "author": "purplefox", "createdAt": "2020-06-25T17:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzODI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzOTA2Mw==", "url": "https://github.com/confluentinc/ksql/pull/5639#discussion_r445039063", "bodyText": "nit: can we link to the subheadings on this page for each of these two, so users don't have to additionally figure out where to go on the page? Or we can have intro text at the top of the streaming-endpoint.md file with links to each of the subheadings, similar to the intro on this page. Or both :)", "author": "vcrfxia", "createdAt": "2020-06-24T16:58:50Z", "path": "docs/developer-guide/api.md", "diffHunk": "@@ -1,22 +1,24 @@\n ---\n layout: page\n-title: ksqlDB REST API Reference\n-tagline: Run queries over REST\n+title: ksqlDB HTTP API Reference\n+tagline: Run queries over HTTP\n description: Learn how to communicate with ksqlDB by using HTTP\n ---\n \n - [Get the Status of a ksqlDB Server (/info endpoint)](ksqldb-rest-api/info-endpoint.md)\n - [Run a ksqlDB Statement (/ksql endpoint)](ksqldb-rest-api/ksql-endpoint.md)\n-- [Run A Query And Stream Back The Output (/query endpoint)](ksqldb-rest-api/query-endpoint.md)\n+- [Execute a push or pull query and stream the results back (/query-stream endpoint)](ksqldb-rest-api/streaming-endpoint.md)\n+- [Stream inserts to the server (/inserts-stream endpoint)](ksqldb-rest-api/streaming-endpoint.md)", "originalCommit": "ab56ae3e3a1c0e4866c61ad41cf8e5f72c607a02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ffa24f5243a6415eb18ac8bf793b5a4e78f1622d", "url": "https://github.com/confluentinc/ksql/commit/ffa24f5243a6415eb18ac8bf793b5a4e78f1622d", "message": "Review updates", "committedDate": "2020-06-25T11:19:15Z", "type": "commit"}]}