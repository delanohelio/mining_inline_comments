{"pr_number": 5516, "pr_title": "feat: reload TLS certificate without restarting server", "pr_createdAt": "2020-05-31T00:51:17Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5516", "timeline": [{"oid": "83e607a16ffa2baea696297370871954458e1864", "url": "https://github.com/confluentinc/ksql/commit/83e607a16ffa2baea696297370871954458e1864", "message": "feat: implement auto cert reload", "committedDate": "2020-05-31T00:38:24Z", "type": "commit"}, {"oid": "dafa8e05e4e300853f37495f15dbc82282b5d948", "url": "https://github.com/confluentinc/ksql/commit/dafa8e05e4e300853f37495f15dbc82282b5d948", "message": "chore: checkstyle", "committedDate": "2020-05-31T00:45:52Z", "type": "commit"}, {"oid": "0ffaf29d8bac086c29b2352412ae422cc0745836", "url": "https://github.com/confluentinc/ksql/commit/0ffaf29d8bac086c29b2352412ae422cc0745836", "message": "chore: minor rename", "committedDate": "2020-05-31T00:51:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzOTU3NQ==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r432939575", "bodyText": "As a general design principle best not to rely on statics as they pollute the global namespace.", "author": "purplefox", "createdAt": "2020-05-31T11:58:23Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/FileWatcher.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardWatchEventKinds;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+// reference:\n+// https://gist.github.com/danielflower/f54c2fe42d32356301c68860a4ab21ed\n+// https://github.com/confluentinc/rest-utils/blob/master/core/src/main/java/io/confluent/rest/FileWatcher.java\n+public class FileWatcher implements Runnable {\n+\n+  private static final Logger log = LoggerFactory.getLogger(FileWatcher.class);\n+  private static final ExecutorService executor = Executors.newFixedThreadPool(1,", "originalCommit": "0ffaf29d8bac086c29b2352412ae422cc0745836", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzOTY1Mg==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r432939652", "bodyText": "Also you probably don't need a custom executor at all - you can use a Vert.x worker thread for this.", "author": "purplefox", "createdAt": "2020-05-31T11:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzOTU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzOTg2Ng==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r432939866", "bodyText": "I think this is more complex than it needs to be. Instead of individually starting and stopping each http server in each ServerVerticle I think it would be simpler just to add a restart() method to Server which simply stopped the Server and started it again, e.g.:\npublic void restart() {\n  stop();\n  start();\n}\n\nI haven't tried this, but seems like it should work (?)", "author": "purplefox", "createdAt": "2020-05-31T12:01:56Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -324,4 +345,28 @@ private static HttpServerOptions createHttpServerOptions(final KsqlRestConfig ks\n     return listeners;\n   }\n \n+  private static void configureTlsCertReload(\n+      final KsqlRestConfig config,\n+      final Set<ServerVerticle> serverVerticles\n+  ) {\n+    if (config.getBoolean(KsqlRestConfig.SSL_KEYSTORE_RELOAD_CONFIG)) {\n+      final Path watchLocation;\n+      if (!config.getString(KsqlRestConfig.SSL_KEYSTORE_WATCH_LOCATION_CONFIG).isEmpty()) {\n+        watchLocation = Paths.get(\n+            config.getString(KsqlRestConfig.SSL_KEYSTORE_WATCH_LOCATION_CONFIG));\n+      } else {\n+        watchLocation = Paths.get(config.getString(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG));\n+      }\n+\n+      try {\n+        FileWatcher.onFileChange(\n+            watchLocation,\n+            () -> serverVerticles.forEach(ServerVerticle::restartServer)", "originalCommit": "0ffaf29d8bac086c29b2352412ae422cc0745836", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNzE4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r433017183", "bodyText": "This does not work. (I had this initially.) As explained in the PR description:\n\nIt's necessary to recreate rather than simply restart the servers because Vert.x only loads TLS certs at the time that the KeyStoreHelper is created, which is only when servers are created.", "author": "vcrfxia", "createdAt": "2020-06-01T02:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzOTg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzMTU2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r433131565", "bodyText": "I'm referring to Server.start/stop not ServerVerticle.start/stop.\nIf you do that, it will take care of creating new Http Servers for you, no?", "author": "purplefox", "createdAt": "2020-06-01T09:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzOTg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM2Nzg4OA==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r433367888", "bodyText": "Ah, I understand your suggestion now. We'll still need custom logic to ensure the HTTP servers are restarted with the same ports, in the event that port 0 is specified (as is the case in our tests). It's not clear to me that this is actually simpler.", "author": "vcrfxia", "createdAt": "2020-06-01T17:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzOTg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3MTM5MA==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r433371390", "bodyText": "Here's a commit where I've made your suggested change: vcrfxia@612b215\nThe new test, TlsTest#shouldReloadCert() fails because the server ports changed during the restart but the client still tries to connect to the old port.\nIf we're OK with the ports changing on restart, we can update the test to recreate the client after the restart.", "author": "vcrfxia", "createdAt": "2020-06-01T17:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzOTg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQxNzk2Nw==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r433417967", "bodyText": "Discussed offline. The only use case for setting port 0 at the moment is in our tests, so we're not going to worry about preserving ports across restarts. As such, I've moved the restart logic from ServerVerticle to Server as suggested, and updated the test to re-create clients in order to use the most up-to-date port.", "author": "vcrfxia", "createdAt": "2020-06-01T18:40:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzOTg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzOTg5OA==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r432939898", "bodyText": "As previous comment, seems overcomplex - just stopped and starting the Server should do the trick?", "author": "purplefox", "createdAt": "2020-05-31T12:02:28Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -99,10 +100,39 @@ public void stop(final Promise<Void> stopPromise) {\n     }\n   }\n \n+  // Creates a new server, rather than simply stopping and restarting, in order to reload TLS certs\n+  public void restartServer() {", "originalCommit": "0ffaf29d8bac086c29b2352412ae422cc0745836", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNzI3MA==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r433017270", "bodyText": "As above -- I initially misunderstood the suggestion. I've made the switch now.", "author": "vcrfxia", "createdAt": "2020-06-01T02:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzOTg5OA=="}], "type": "inlineReview"}, {"oid": "4e0c36561b67102e733c4c49028096a9c9344d49", "url": "https://github.com/confluentinc/ksql/commit/4e0c36561b67102e733c4c49028096a9c9344d49", "message": "chore: use Vert.x worker rather than executor service", "committedDate": "2020-06-01T17:46:17Z", "type": "commit"}, {"oid": "48929a97b9e8af4de25959ae6736edba13e4e619", "url": "https://github.com/confluentinc/ksql/commit/48929a97b9e8af4de25959ae6736edba13e4e619", "message": "chore: move logic for restarting server from ServerVerticle to Server", "committedDate": "2020-06-01T18:36:55Z", "type": "commit"}, {"oid": "2849468643afe4d8f385c886cf39bd2bcf9b7189", "url": "https://github.com/confluentinc/ksql/commit/2849468643afe4d8f385c886cf39bd2bcf9b7189", "message": "test: client trust store should always be valid", "committedDate": "2020-06-01T19:01:37Z", "type": "commit"}, {"oid": "d5e0821cbf9649ee7af891c55e44b9638fc870c3", "url": "https://github.com/confluentinc/ksql/commit/d5e0821cbf9649ee7af891c55e44b9638fc870c3", "message": "chore: findbugs", "committedDate": "2020-06-02T03:48:09Z", "type": "commit"}, {"oid": "87917ea54b026c88c93eff9a3b92fd0f6e1a4f7d", "url": "https://github.com/confluentinc/ksql/commit/87917ea54b026c88c93eff9a3b92fd0f6e1a4f7d", "message": "fix: use separate thread for file watcher", "committedDate": "2020-06-02T21:19:38Z", "type": "commit"}, {"oid": "7ff1082b15566cc52fb7aed1006efd40a199aa30", "url": "https://github.com/confluentinc/ksql/commit/7ff1082b15566cc52fb7aed1006efd40a199aa30", "message": "test: prevent cert reload test from affecting other TLS tests", "committedDate": "2020-06-04T16:24:03Z", "type": "commit"}, {"oid": "7221eadf30d50666a81b461924636aa5b5aecd7d", "url": "https://github.com/confluentinc/ksql/commit/7221eadf30d50666a81b461924636aa5b5aecd7d", "message": "Merge branch 'master' into auto-cert-reload", "committedDate": "2020-06-04T16:24:47Z", "type": "commit"}, {"oid": "c700eb993b23c0367232456fe6b2c33680cfedec", "url": "https://github.com/confluentinc/ksql/commit/c700eb993b23c0367232456fe6b2c33680cfedec", "message": "test: add logging to debug potential flakiness with shouldReloadCert()", "committedDate": "2020-06-04T16:29:26Z", "type": "commit"}, {"oid": "b23542f9b62de47fa3535694231b8d991bd22490", "url": "https://github.com/confluentinc/ksql/commit/b23542f9b62de47fa3535694231b8d991bd22490", "message": "test: update assertion to be more informative on failure", "committedDate": "2020-06-04T19:12:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxODkzNg==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r435818936", "bodyText": "Is there any need to interrupt the thread here? If shutdown() is called from this same thread then you set the shutdown flag which means the run() method will return exit ok.", "author": "purplefox", "createdAt": "2020-06-05T09:59:11Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/FileWatcher.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardWatchEventKinds;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.util.Objects;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+// reference:\n+// https://gist.github.com/danielflower/f54c2fe42d32356301c68860a4ab21ed\n+// https://github.com/confluentinc/rest-utils/blob/master/core/src/main/java/io/confluent/rest/FileWatcher.java\n+/**\n+ * Watches a file and calls a callback when it is changed.\n+ */\n+public class FileWatcher implements Runnable {\n+\n+  private static final Logger log = LoggerFactory.getLogger(FileWatcher.class);\n+\n+  public interface Callback {\n+    void run() throws Exception;\n+  }\n+\n+  private volatile boolean shutdown;\n+  private final WatchService watchService;\n+  private final Path file;\n+  private final Callback callback;\n+  private Thread thread;\n+\n+  @SuppressFBWarnings(\n+      value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\",\n+      justification = \"Null check on file.getParent() is present\"\n+  )\n+  public FileWatcher(final Path file, final Callback callback) throws IOException {\n+    this.file = Objects.requireNonNull(file);\n+    Objects.requireNonNull(file.getParent(), \"Watch location must have parent\");\n+    this.watchService = FileSystems.getDefault().newWatchService();\n+    // Listen to both CREATE and MODIFY to reload, which handles delete then create.\n+    file.getParent().register(watchService,\n+        StandardWatchEventKinds.ENTRY_CREATE,\n+        StandardWatchEventKinds.ENTRY_MODIFY);\n+    this.callback = Objects.requireNonNull(callback);\n+  }\n+\n+  /**\n+   * Starts the file watcher in a separate thread\n+   */\n+  public synchronized void start() {\n+    log.info(\"Starting file watcher to watch for changes: \" + file);\n+    thread = new Thread(this);\n+    thread.start();\n+  }\n+\n+  /**\n+   * Stops watching the file and closes the watch service\n+   */\n+  public synchronized void shutdown() {\n+    shutdown = true;\n+    log.info(\"Stopped watching for TLS cert changes.\");\n+    if (thread != null) {", "originalCommit": "b23542f9b62de47fa3535694231b8d991bd22490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3MzUxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r436073519", "bodyText": "I had the redundancy as extra insurance that we wouldn't leak resources (in case something changes with the FileWatcher code and shutdown() is no longer foolproof) but I think that was overkill. I've removed the interrupt() and simplified the Server code as you suggested.", "author": "vcrfxia", "createdAt": "2020-06-05T17:51:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxODkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxOTY3NQ==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r435819675", "bodyText": "I don't think the startFileWatcher flag is necessary if you don't interrupt the watcher thread (see previous comment). This means you can simplify things and have a simple start/stop method as before and always create a new filewatcher in start().", "author": "purplefox", "createdAt": "2020-06-05T10:00:24Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -89,6 +93,10 @@ public Server(final Vertx vertx, final KsqlRestConfig config, final Endpoints en\n   }\n \n   public synchronized void start() {\n+    start(true);\n+  }\n+\n+  private synchronized void start(final boolean startFileWatcher) {", "originalCommit": "b23542f9b62de47fa3535694231b8d991bd22490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxOTgwNg==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r435819806", "bodyText": "As above, parameter is unnecessary", "author": "purplefox", "createdAt": "2020-06-05T10:00:39Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -156,12 +166,19 @@ public synchronized void start() {\n   }\n \n   public synchronized void stop() {\n+    stop(true);\n+  }\n+\n+  private synchronized void stop(final boolean stopFileWatcher) {", "originalCommit": "b23542f9b62de47fa3535694231b8d991bd22490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMTAwNA==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r435821004", "bodyText": "You can avoid this if FileWatcher extends Thread", "author": "purplefox", "createdAt": "2020-06-05T10:02:50Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/FileWatcher.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardWatchEventKinds;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.util.Objects;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+// reference:\n+// https://gist.github.com/danielflower/f54c2fe42d32356301c68860a4ab21ed\n+// https://github.com/confluentinc/rest-utils/blob/master/core/src/main/java/io/confluent/rest/FileWatcher.java\n+/**\n+ * Watches a file and calls a callback when it is changed.\n+ */\n+public class FileWatcher implements Runnable {\n+\n+  private static final Logger log = LoggerFactory.getLogger(FileWatcher.class);\n+\n+  public interface Callback {\n+    void run() throws Exception;\n+  }\n+\n+  private volatile boolean shutdown;\n+  private final WatchService watchService;\n+  private final Path file;\n+  private final Callback callback;\n+  private Thread thread;\n+\n+  @SuppressFBWarnings(\n+      value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\",\n+      justification = \"Null check on file.getParent() is present\"\n+  )\n+  public FileWatcher(final Path file, final Callback callback) throws IOException {\n+    this.file = Objects.requireNonNull(file);\n+    Objects.requireNonNull(file.getParent(), \"Watch location must have parent\");\n+    this.watchService = FileSystems.getDefault().newWatchService();\n+    // Listen to both CREATE and MODIFY to reload, which handles delete then create.\n+    file.getParent().register(watchService,\n+        StandardWatchEventKinds.ENTRY_CREATE,\n+        StandardWatchEventKinds.ENTRY_MODIFY);\n+    this.callback = Objects.requireNonNull(callback);\n+  }\n+\n+  /**\n+   * Starts the file watcher in a separate thread\n+   */\n+  public synchronized void start() {\n+    log.info(\"Starting file watcher to watch for changes: \" + file);\n+    thread = new Thread(this);", "originalCommit": "b23542f9b62de47fa3535694231b8d991bd22490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3MjE2Mw==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r436072163", "bodyText": "Ah yes, this is a lot better. Thanks for the suggestion! I thought what I was doing didn't feel right, heh :)", "author": "vcrfxia", "createdAt": "2020-06-05T17:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMTAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMTY4Nw==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r435821687", "bodyText": "Doesn't need to be synchronized if we don't have a thread member and shutdown is volatile", "author": "purplefox", "createdAt": "2020-06-05T10:04:16Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/FileWatcher.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardWatchEventKinds;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.util.Objects;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+// reference:\n+// https://gist.github.com/danielflower/f54c2fe42d32356301c68860a4ab21ed\n+// https://github.com/confluentinc/rest-utils/blob/master/core/src/main/java/io/confluent/rest/FileWatcher.java\n+/**\n+ * Watches a file and calls a callback when it is changed.\n+ */\n+public class FileWatcher implements Runnable {\n+\n+  private static final Logger log = LoggerFactory.getLogger(FileWatcher.class);\n+\n+  public interface Callback {\n+    void run() throws Exception;\n+  }\n+\n+  private volatile boolean shutdown;\n+  private final WatchService watchService;\n+  private final Path file;\n+  private final Callback callback;\n+  private Thread thread;\n+\n+  @SuppressFBWarnings(\n+      value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\",\n+      justification = \"Null check on file.getParent() is present\"\n+  )\n+  public FileWatcher(final Path file, final Callback callback) throws IOException {\n+    this.file = Objects.requireNonNull(file);\n+    Objects.requireNonNull(file.getParent(), \"Watch location must have parent\");\n+    this.watchService = FileSystems.getDefault().newWatchService();\n+    // Listen to both CREATE and MODIFY to reload, which handles delete then create.\n+    file.getParent().register(watchService,\n+        StandardWatchEventKinds.ENTRY_CREATE,\n+        StandardWatchEventKinds.ENTRY_MODIFY);\n+    this.callback = Objects.requireNonNull(callback);\n+  }\n+\n+  /**\n+   * Starts the file watcher in a separate thread\n+   */\n+  public synchronized void start() {\n+    log.info(\"Starting file watcher to watch for changes: \" + file);\n+    thread = new Thread(this);\n+    thread.start();\n+  }\n+\n+  /**\n+   * Stops watching the file and closes the watch service\n+   */\n+  public synchronized void shutdown() {", "originalCommit": "b23542f9b62de47fa3535694231b8d991bd22490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMjg4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r435822883", "bodyText": "Probably should log at error unless this is expected in normal operation?", "author": "purplefox", "createdAt": "2020-06-05T10:06:31Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/FileWatcher.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardWatchEventKinds;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.util.Objects;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+// reference:\n+// https://gist.github.com/danielflower/f54c2fe42d32356301c68860a4ab21ed\n+// https://github.com/confluentinc/rest-utils/blob/master/core/src/main/java/io/confluent/rest/FileWatcher.java\n+/**\n+ * Watches a file and calls a callback when it is changed.\n+ */\n+public class FileWatcher implements Runnable {\n+\n+  private static final Logger log = LoggerFactory.getLogger(FileWatcher.class);\n+\n+  public interface Callback {\n+    void run() throws Exception;\n+  }\n+\n+  private volatile boolean shutdown;\n+  private final WatchService watchService;\n+  private final Path file;\n+  private final Callback callback;\n+  private Thread thread;\n+\n+  @SuppressFBWarnings(\n+      value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\",\n+      justification = \"Null check on file.getParent() is present\"\n+  )\n+  public FileWatcher(final Path file, final Callback callback) throws IOException {\n+    this.file = Objects.requireNonNull(file);\n+    Objects.requireNonNull(file.getParent(), \"Watch location must have parent\");\n+    this.watchService = FileSystems.getDefault().newWatchService();\n+    // Listen to both CREATE and MODIFY to reload, which handles delete then create.\n+    file.getParent().register(watchService,\n+        StandardWatchEventKinds.ENTRY_CREATE,\n+        StandardWatchEventKinds.ENTRY_MODIFY);\n+    this.callback = Objects.requireNonNull(callback);\n+  }\n+\n+  /**\n+   * Starts the file watcher in a separate thread\n+   */\n+  public synchronized void start() {\n+    log.info(\"Starting file watcher to watch for changes: \" + file);\n+    thread = new Thread(this);\n+    thread.start();\n+  }\n+\n+  /**\n+   * Stops watching the file and closes the watch service\n+   */\n+  public synchronized void shutdown() {\n+    shutdown = true;\n+    log.info(\"Stopped watching for TLS cert changes.\");\n+    if (thread != null) {\n+      thread.interrupt();\n+    }\n+    try {\n+      watchService.close();\n+    } catch (IOException e) {\n+      log.info(\"Error closing watch service\", e);\n+    }\n+  }\n+\n+  @Override\n+  public void run() {\n+    try {\n+      while (!shutdown) {\n+        try {\n+          handleNextWatchNotification();\n+        } catch (InterruptedException e) {\n+          throw e;\n+        } catch (Exception e) {\n+          log.info(\"Watch service caught exception, will continue:\" + e);\n+        }\n+      }\n+    } catch (InterruptedException e) {\n+      log.info(\"Ending watch due to interrupt\");\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @SuppressFBWarnings(\n+      value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\",\n+      justification = \"Null check on file.getParent() is present above\"\n+  )\n+  private void handleNextWatchNotification() throws InterruptedException {\n+    // wait for key to be signalled\n+    final WatchKey key = watchService.take();\n+    log.info(\"Watch Key notified\");\n+    for (WatchEvent<?> event : key.pollEvents()) {\n+      final WatchEvent.Kind<?> kind = event.kind();\n+      if (kind == StandardWatchEventKinds.OVERFLOW) {\n+        log.debug(\"Watch event is OVERFLOW\");\n+        continue;\n+      }\n+      final WatchEvent<Path> ev = (WatchEvent<Path>)event;\n+      final Path changed = file.getParent().resolve(ev.context());\n+      log.debug(\"Watch file change: \" + ev.context() + \"=>\" + changed);\n+      // use Path.equals rather than Files.isSameFile to handle updated symlinks\n+      if (Files.exists(changed) && changed.equals(file)) {\n+        log.info(\"Change event for watched file: \" + file);\n+        try {\n+          callback.run();\n+        } catch (Exception e) {\n+          log.warn(\"Hit error callback on file change\", e);", "originalCommit": "b23542f9b62de47fa3535694231b8d991bd22490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMzkyOQ==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r435823929", "bodyText": "I think it would be good to test reloading the server more than once - i.e. changing the cert more than once, as there might be a bug in the filewatcher/reloading that only manifests after the reload has been done once.", "author": "purplefox", "createdAt": "2020-06-05T10:08:44Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/api/TlsTest.java", "diffHunk": "@@ -49,18 +61,82 @@ protected KsqlRestConfig createServerConfig() {\n     config.put(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, trustStorePassword);\n     config.put(KsqlRestConfig.VERTICLE_INSTANCES, 4);\n \n+    config.put(KsqlRestConfig.SSL_KEYSTORE_RELOAD_CONFIG, true);\n+\n     return new KsqlRestConfig(config);\n   }\n \n   @Override\n   protected WebClientOptions createClientOptions() {\n+    // for this test file, the client must use a different trust store location than the server\n+    // since the client store should always be valid even when the server store is loaded with an\n+    // invalid cert\n+    String clientTrustStorePath = ServerKeyStore.clientKeyStoreProps()\n+        .get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+    String clientTrustStorePassword = ServerKeyStore.clientKeyStoreProps()\n+        .get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG);\n+\n     return new WebClientOptions().setSsl(true).\n         setUseAlpn(true).\n         setProtocolVersion(HttpVersion.HTTP_2).\n-        setTrustAll(true).\n+        setTrustStoreOptions(\n+            new JksOptions().setPath(clientTrustStorePath).setPassword(clientTrustStorePassword)).\n         setVerifyHost(false).\n         setDefaultHost(\"localhost\").\n         setDefaultPort(server.getListeners().get(0).getPort());\n   }\n \n+  @Test\n+  public void shouldReloadCert() throws Exception {\n+    JsonObject requestBody = new JsonObject().put(\"sql\", DEFAULT_PULL_QUERY);\n+\n+    // Given: sanity check that a query succeeds\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+    assertThat(response.statusCode(), is(200));\n+    assertThat(response.statusMessage(), is(\"OK\"));\n+\n+    try {\n+      // When: load expired key store\n+      ServerKeyStore.loadExpiredServerKeyStore();\n+      assertThatEventually(\n+          \"Should fail to execute query with expired key store\",\n+          () -> {\n+            // re-create client since server port changes on restart\n+            this.client = createClient();\n+\n+            try {\n+              // this should fail\n+              sendRequest(\"/query-stream\", requestBody.toBuffer());\n+              return \"error: request should have failed but did not\";\n+            } catch (Exception e) {\n+              assertThat(e,\n+                  instanceOf(ExecutionException.class)); // thrown from CompletableFuture.get()\n+              return e.getMessage();\n+            }\n+          },\n+          containsString(\"javax.net.ssl.SSLHandshakeException: Failed to create SSL connection\"),\n+          TimeUnit.SECONDS.toMillis(1),\n+          TimeUnit.SECONDS.toMillis(1)\n+      );\n+    } finally { // restore cert regardless of failure above so as to not affect other tests\n+      // When: load valid store\n+      ServerKeyStore.loadValidServerKeyStore();", "originalCommit": "b23542f9b62de47fa3535694231b8d991bd22490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3MjYxNQ==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r436072615", "bodyText": "The test already reloads the server twice: once with a bad cert, and then again with a good cert. Are you suggesting we should repeat the cycle twice, for a total of four reloads?", "author": "vcrfxia", "createdAt": "2020-06-05T17:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMzkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4NTUyOA==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r436085528", "bodyText": "Ah, if you're already reloading more than once that seems fine :)", "author": "purplefox", "createdAt": "2020-06-05T18:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMzkyOQ=="}], "type": "inlineReview"}, {"oid": "195827043ce599aef515799b64574fe1d3abae76", "url": "https://github.com/confluentinc/ksql/commit/195827043ce599aef515799b64574fe1d3abae76", "message": "refactor: file watcher extends thread", "committedDate": "2020-06-05T17:46:35Z", "type": "commit"}, {"oid": "7a1d13695028acd42f4a7b9920457446304f962c", "url": "https://github.com/confluentinc/ksql/commit/7a1d13695028acd42f4a7b9920457446304f962c", "message": "fix: configure cert reload before deploying instances", "committedDate": "2020-06-05T17:47:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3MjQyNA==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r436872424", "bodyText": "Hey @purplefox , now that FileWatcher extends Thread, do you think it makes sense to get rid of this shutdown() method and instead call interrupt() to terminate the file watcher? I'm wondering whether it's canonical to have a \"clean\" shutdown method like this, or if interrupt() is understood to be used for that purpose.", "author": "vcrfxia", "createdAt": "2020-06-08T17:25:41Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/FileWatcher.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardWatchEventKinds;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.util.Objects;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+// reference:\n+// https://gist.github.com/danielflower/f54c2fe42d32356301c68860a4ab21ed\n+// https://github.com/confluentinc/rest-utils/blob/master/core/src/main/java/io/confluent/rest/FileWatcher.java\n+/**\n+ * Watches a file and calls a callback when it is changed.\n+ */\n+public class FileWatcher extends Thread {\n+\n+  private static final Logger log = LoggerFactory.getLogger(FileWatcher.class);\n+\n+  public interface Callback {\n+    void run() throws Exception;\n+  }\n+\n+  private volatile boolean shutdown;\n+  private final WatchService watchService;\n+  private final Path file;\n+  private final Callback callback;\n+\n+  @SuppressFBWarnings(\n+      value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\",\n+      justification = \"Null check on file.getParent() is present\"\n+  )\n+  public FileWatcher(final Path file, final Callback callback) throws IOException {\n+    this.file = Objects.requireNonNull(file);\n+    Objects.requireNonNull(file.getParent(), \"Watch location must have parent\");\n+    this.watchService = FileSystems.getDefault().newWatchService();\n+    // Listen to both CREATE and MODIFY to reload, which handles delete then create.\n+    file.getParent().register(watchService,\n+        StandardWatchEventKinds.ENTRY_CREATE,\n+        StandardWatchEventKinds.ENTRY_MODIFY);\n+    this.callback = Objects.requireNonNull(callback);\n+  }\n+\n+  /**\n+   * Closes the file watcher\n+   */\n+  public void shutdown() {", "originalCommit": "7a1d13695028acd42f4a7b9920457446304f962c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3OTI5Mw==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r436879293", "bodyText": "Merging PR for now -- will make this improvement in a follow-up (if we think it'd be an improvement).", "author": "vcrfxia", "createdAt": "2020-06-08T17:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3MjQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MTYzOQ==", "url": "https://github.com/confluentinc/ksql/pull/5516#discussion_r437241639", "bodyText": "I think it's preferable to shut cleanly without interrupting threads if you can. Interrupting threads is only necessary if the thread is blocked on something that is interruptable. In our case we only call shutdown() from the thread itself so we can guarantee it's not blocked so there's no need to interrupt anything.\nIf the method was intended to be used elsewhere from a different thread then we should call Thread.interrupt() but that's not the case here.\nAs a sanity check you could add this in shutdown() to make sure that is the case\nif (this != Thread.currentThread()) {\n   throw new IllegalStateException(\"Can only be called from file watcher thread\");\n}", "author": "purplefox", "createdAt": "2020-06-09T08:49:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3MjQyNA=="}], "type": "inlineReview"}]}