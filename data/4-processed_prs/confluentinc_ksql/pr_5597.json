{"pr_number": 5597, "pr_title": "fix: fail AVRO/Protobuf/JSON Schema statements if SR is missing", "pr_createdAt": "2020-06-10T22:04:22Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5597", "timeline": [{"oid": "36763838d9b578958b89728c8eb259b40f2940c7", "url": "https://github.com/confluentinc/ksql/commit/36763838d9b578958b89728c8eb259b40f2940c7", "message": "fix: fail statement eagerly if it creates a schema inference topic without schema registry", "committedDate": "2020-06-10T22:02:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzNzk4MQ==", "url": "https://github.com/confluentinc/ksql/pull/5597#discussion_r438437981", "bodyText": "Whoa, this is so useful! I've been using all sorts of crazy workarounds since I didn't know about this. Thanks for the tip \ud83d\ude05", "author": "vcrfxia", "createdAt": "2020-06-10T22:16:25Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/StandaloneExecutorFunctionalTest.java", "diffHunk": "@@ -51,15 +51,20 @@\n import org.junit.Before;\n import org.junit.BeforeClass;\n import org.junit.ClassRule;\n+import org.junit.FixMethodOrder;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.rules.TemporaryFolder;\n import org.junit.runner.RunWith;\n+import org.junit.runners.MethodSorters;\n import org.mockito.Mock;\n import org.mockito.junit.MockitoJUnitRunner;\n \n @Category({IntegrationTest.class})\n @RunWith(MockitoJUnitRunner.class)\n+// shouldFailOnAvroWithoutSchemasIfSchemaNotEvolvable fails if run after shouldHandleJsonWithSchemas\n+@FixMethodOrder(MethodSorters.NAME_ASCENDING)", "originalCommit": "36763838d9b578958b89728c8eb259b40f2940c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MDI2NA==", "url": "https://github.com/confluentinc/ksql/pull/5597#discussion_r438470264", "bodyText": "tbh, this isn't great practice \ud83d\ude05 but I didn't want to distract from the fix. In general tests shouldn't depend on ordering because then you can't parallelize them. Hopefully I'll have time to debug why this is happening, but I spent like 20min and couldn't immediately figure it out", "author": "agavra", "createdAt": "2020-06-10T23:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzNzk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzMDQ3Nw==", "url": "https://github.com/confluentinc/ksql/pull/5597#discussion_r438530477", "bodyText": "@agavra would it actually be possible for you to throw a nested KsqlSchemaRegistryNotConfiguredException here? In cloud, we want to throw a very specific error message related to this and we're passing in a cloud specific error message module in the cloud image.\nhttps://github.com/confluentinc/ksql/blob/master/ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/Errors.java#L236\nhttps://github.com/confluentinc/ksql/blob/master/ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/Errors.java#L218", "author": "stevenpyzhang", "createdAt": "2020-06-11T04:04:22Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java", "diffHunk": "@@ -118,6 +121,12 @@ private void registerSchema(\n       } catch (IOException | RestClientException e) {\n         throw new KsqlStatementException(\"Could not register schema for topic.\", statementText, e);\n       }\n+    } else {\n+      throw new KsqlStatementException(", "originalCommit": "36763838d9b578958b89728c8eb259b40f2940c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}