{"pr_number": 5123, "pr_title": "refactor: Migrate old websocket query endpoint", "pr_createdAt": "2020-04-21T07:32:43Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5123", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyNDkwMg==", "url": "https://github.com/confluentinc/ksql/pull/5123#discussion_r412724902", "bodyText": "This does not look like it's meant to be commented out...", "author": "vcrfxia", "createdAt": "2020-04-22T07:06:31Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -141,9 +141,9 @@ private Router setupRouter() {\n \n     PortedEndpoints.setupEndpoints(endpoints, server, router);\n \n-    if (proxyHandler != null) {\n-      proxyHandler.setupRoutes(router);\n-    }\n+    // if (proxyHandler != null) {", "originalCommit": "bf9358e92fbc45d390ce338c8f612e96fc0499f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxODg5OQ==", "url": "https://github.com/confluentinc/ksql/pull/5123#discussion_r412818899", "bodyText": "That's removed in another PR/commit (?). At least I don't see this after rebasing.", "author": "purplefox", "createdAt": "2020-04-22T09:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyNDkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyNTM5Mw==", "url": "https://github.com/confluentinc/ksql/pull/5123#discussion_r412725393", "bodyText": "With the changes in this PR, the only usages of this method are in SessionUtilTest.java. Can we update the tests there to test the new closeSilently() instead, and remove this old method?", "author": "vcrfxia", "createdAt": "2020-04-22T07:07:22Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/SessionUtil.java", "diffHunk": "@@ -34,6 +35,17 @@\n   private SessionUtil() {\n   }\n \n+  static void closeSilently(\n+      final ServerWebSocket webSocket,\n+      final CloseCodes code,\n+      final String message) {\n+    try {\n+      webSocket.close((short) code.getCode(), message);\n+    } catch (final Exception e) {\n+      LOG.info(\"Exception caught closing websocket\", e);\n+    }\n+  }\n+\n   static void closeSilently(", "originalCommit": "bf9358e92fbc45d390ce338c8f612e96fc0499f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxOTYwOQ==", "url": "https://github.com/confluentinc/ksql/pull/5123#discussion_r412819609", "bodyText": "+1 This is actually removed in a later PR", "author": "purplefox", "createdAt": "2020-04-22T09:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyNTM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyNjc5Nw==", "url": "https://github.com/confluentinc/ksql/pull/5123#discussion_r412726797", "bodyText": "Looks like we've changed behavior here since MultiMap.get() returns the first element when there are multiple, in contrast to the old behavior here that returned the last element. I don't imagine sending multiple statements in a websocket request is a common use case, but maybe it's worth remaining consistent. Up to you.", "author": "vcrfxia", "createdAt": "2020-04-22T07:09:53Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/WSQueryEndpoint.java", "diffHunk": "@@ -185,178 +130,98 @@ public WSQueryEndpoint(\n         Objects.requireNonNull(commandQueueCatchupTimeout, \"commandQueueCatchupTimeout\");\n     this.authorizationValidator =\n         Objects.requireNonNull(authorizationValidator, \"authorizationValidator\");\n-    this.securityExtension = Objects.requireNonNull(securityExtension, \"securityExtension\");\n-    this.serviceContextFactory =\n-        Objects.requireNonNull(serviceContextFactory, \"serviceContextFactory\");\n-    this.defaultServiceContextFactory =\n-        Objects.requireNonNull(defaultServiceContextFactory, \"defaultServiceContextFactory\");\n-    this.serverState = Objects.requireNonNull(serverState, \"serverState\");\n     this.errorHandler = Objects.requireNonNull(errorHandler, \"errorHandler\");\n-    this.schemaRegistryClientFactory =\n-        Objects.requireNonNull(schemaRegistryClientFactory, \"schemaRegistryClientFactory\");\n     this.pullQueryExecutor = Objects.requireNonNull(pullQueryExecutor, \"pullQueryExecutor\");\n   }\n \n-  @SuppressWarnings(\"unused\")\n-  @OnOpen\n-  public void onOpen(final Session session, final EndpointConfig unused) {\n-    log.debug(\"Opening websocket session {}\", session.getId());\n+  public void executeStreamQuery(final ServerWebSocket webSocket, final MultiMap requestParams,\n+      final KsqlSecurityContext ksqlSecurityContext) {\n \n     try {\n-      // Check if the user has authorization to open a WS session\n-      checkAuthorization(session);\n \n-      validateVersion(session);\n+      activenessRegistrar.updateLastRequestTime();\n \n-      final Optional<EndpointResponse> readyResponse = serverState.checkReady();\n-      if (readyResponse.isPresent()) {\n-        final String msg = ((KsqlErrorMessage) readyResponse.get().getEntity()).getMessage();\n-        SessionUtil.closeSilently(session, CloseCodes.TRY_AGAIN_LATER, msg);\n-        return;\n-      }\n+      validateVersion(requestParams);\n \n-      final KsqlRequest request = parseRequest(session);\n+      final KsqlRequest request = parseRequest(requestParams);\n \n       try {\n         CommandStoreUtil.waitForCommandSequenceNumber(commandQueue, request,\n             commandQueueCatchupTimeout);\n       } catch (final InterruptedException e) {\n         log.debug(\"Interrupted while waiting for command queue \"\n-            + \"to reach specified command sequence number\",\n+                + \"to reach specified command sequence number\",\n             e);\n-        SessionUtil.closeSilently(session, CloseCodes.UNEXPECTED_CONDITION, e.getMessage());\n+        SessionUtil.closeSilently(webSocket, CloseCodes.UNEXPECTED_CONDITION, e.getMessage());\n         return;\n       } catch (final TimeoutException e) {\n         log.debug(\"Timeout while processing request\", e);\n-        SessionUtil.closeSilently(session, CloseCodes.TRY_AGAIN_LATER, e.getMessage());\n+        SessionUtil.closeSilently(webSocket, CloseCodes.TRY_AGAIN_LATER, e.getMessage());\n         return;\n       }\n \n       final PreparedStatement<?> preparedStatement = parseStatement(request);\n \n-      securityContext = createSecurityContext(session.getUserPrincipal());\n-\n       final Statement statement = preparedStatement.getStatement();\n       final Class<? extends Statement> type = statement.getClass();\n \n-      validateKafkaAuthorization(statement);\n+      authorizationValidator.ifPresent(validator -> validator.checkAuthorization(\n+          ksqlSecurityContext,\n+          ksqlEngine.getMetaStore(),\n+          statement)\n+      );\n+\n+      final RequestContext requestContext = new RequestContext(webSocket, request,\n+          ksqlSecurityContext);\n+\n+      if (statement instanceof Query) {\n+        handleQuery(requestContext, (Query) statement);\n+      } else if (statement instanceof PrintTopic) {\n+        handlePrintTopic(requestContext, (PrintTopic) statement);\n+      } else {\n+        throw new IllegalArgumentException(\"Unexpected statement type \" + statement);\n+      }\n \n-      HANDLER_MAP\n-          .getOrDefault(type, WSQueryEndpoint::handleUnsupportedStatement)\n-          .handle(this, new RequestContext(session, request, securityContext), statement);\n+      webSocket.closeHandler(v -> {\n+        if (subscriber != null) {\n+          subscriber.close();\n+        }\n+      });\n     } catch (final TopicAuthorizationException e) {\n       log.debug(\"Error processing request\", e);\n       SessionUtil.closeSilently(\n-          session,\n+          webSocket,\n           CloseCodes.CANNOT_ACCEPT,\n           errorHandler.kafkaAuthorizationErrorMessage(e));\n     } catch (final Exception e) {\n       log.debug(\"Error processing request\", e);\n-      SessionUtil.closeSilently(session, CloseCodes.CANNOT_ACCEPT, e.getMessage());\n-    }\n-  }\n-\n-  @OnClose\n-  public void onClose(final Session session, final CloseReason closeReason) {\n-    if (subscriber != null) {\n-      subscriber.close();\n+      SessionUtil.closeSilently(webSocket, CloseCodes.CANNOT_ACCEPT, e.getMessage());\n     }\n-\n-    if (securityContext != null) {\n-      securityContext.getServiceContext().close();\n-    }\n-\n-    log.debug(\n-        \"Closing websocket session {} ({}): {}\",\n-        session.getId(),\n-        closeReason.getCloseCode(),\n-        closeReason.getReasonPhrase()\n-    );\n   }\n \n-  @SuppressWarnings(\"MethodMayBeStatic\")\n-  @OnError\n-  public void onError(final Session session, final Throwable t) {\n-    log.error(\"websocket error in session {}\", session.getId(), t);\n-    SessionUtil.closeSilently(session, CloseCodes.UNEXPECTED_CONDITION, t.getMessage());\n-  }\n+  private void validateVersion(final MultiMap requestParams) {\n \n-  private void checkAuthorization(final Session session) {\n-    final String method = \"POST\";\n-    final String path = this.getClass().getAnnotation(ServerEndpoint.class).value();\n-    final Principal user = session.getUserPrincipal();\n-\n-    securityExtension.getAuthorizationProvider().ifPresent(\n-        provider -> {\n-          try {\n-            provider.checkEndpointAccess(user, method, path);\n-          } catch (final Throwable t) {\n-            log.warn(String.format(\"User:%s is denied access to Websocket \"\n-                + \"%s endpoint\", user.getName(), path), t);\n-            throw new KsqlException(t);\n-          }\n-        }\n-    );\n-  }\n+    final String version = requestParams.get(Versions.KSQL_V1_WS_PARAM);\n \n-  private KsqlSecurityContext createSecurityContext(final Principal principal) {\n-    final ServiceContext serviceContext;\n-\n-    if (!securityExtension.getUserContextProvider().isPresent()) {\n-      serviceContext = defaultServiceContextFactory.create(ksqlConfig, Optional.empty(),\n-          schemaRegistryClientFactory);\n-    } else {\n-      // Creates a ServiceContext using the user's credentials, so the WS query topics are\n-      // accessed with the user permission context (defaults to KSQL service context)\n-\n-      serviceContext = securityExtension.getUserContextProvider()\n-          .map(provider ->\n-              serviceContextFactory.create(\n-                  ksqlConfig,\n-                  Optional.empty(),\n-                  provider.getKafkaClientSupplier(principal),\n-                  provider.getSchemaRegistryClientFactory(principal)))\n-          .get();\n-    }\n-\n-    return new KsqlSecurityContext(Optional.ofNullable(principal), serviceContext);\n-  }\n-\n-  private void validateVersion(final Session session) {\n-    final Map<String, List<String>> parameters = session.getRequestParameterMap();\n-    activenessRegistrar.updateLastRequestTime();\n-\n-    final List<String> versionParam = parameters.getOrDefault(\n-        Versions.KSQL_V1_WS_PARAM, Collections.singletonList(Versions.KSQL_V1_WS));\n-\n-    if (versionParam.isEmpty()) {\n+    if (version == null) {\n       return;\n     }\n \n-    if (versionParam.size() != 1) {\n-      throw new IllegalArgumentException(\"Received multiple api versions: \" + versionParam);\n-    }\n-\n-    if (!versionParam.get(0).equals(Versions.KSQL_V1_WS)) {\n-      throw new IllegalArgumentException(\"Received invalid api version: \" + versionParam);\n+    if (!Versions.KSQL_V1_WS.equals(version)) {\n+      throw new IllegalArgumentException(\"Received invalid api version: \" + version);\n     }\n   }\n \n-  private KsqlRequest parseRequest(final Session session) {\n+  private KsqlRequest parseRequest(final MultiMap requestParams) {\n     try {\n-      final List<String> jsonRequests = session.getRequestParameterMap()\n-          .getOrDefault(\"request\", Collections.emptyList());\n+      final String jsonRequest = requestParams.get(\"request\");\n \n-      if (jsonRequests == null || jsonRequests.isEmpty()) {\n-        throw new IllegalArgumentException(\"missing request parameter\");\n-      }\n-\n-      final String jsonRequest = Iterables.getLast(jsonRequests, \"\");", "originalCommit": "bf9358e92fbc45d390ce338c8f612e96fc0499f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMzIzMw==", "url": "https://github.com/confluentinc/ksql/pull/5123#discussion_r412823233", "bodyText": "Behaviour of multimap.get is to return the last element, so behaviour is the same.\nHonestly, I don't people are going to send a query with two requests, and if they do they will soon find out only the last one is being used.", "author": "purplefox", "createdAt": "2020-04-22T09:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyNjc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwODQ0Ng==", "url": "https://github.com/confluentinc/ksql/pull/5123#discussion_r413208446", "bodyText": "Really? The docs say MultiMap.get() returns the first element: https://vertx.io/docs/apidocs/io/vertx/core/MultiMap.html#get-java.lang.String-", "author": "vcrfxia", "createdAt": "2020-04-22T18:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyNjc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyODgzOA==", "url": "https://github.com/confluentinc/ksql/pull/5123#discussion_r412728838", "bodyText": "nit: inconsistent use of /ws/* above (and in ServerVerticle) in contrast to /ws/query here.", "author": "vcrfxia", "createdAt": "2020-04-22T07:13:04Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/PortedEndpoints.java", "diffHunk": "@@ -135,6 +136,8 @@ static void setupEndpoints(final Endpoints endpoints, final Server server,\n         .produces(Versions.KSQL_V1_JSON)\n         .produces(MediaType.APPLICATION_JSON)\n         .handler(new PortedEndpoints(endpoints, server)::handleServerMetadataClusterIdRequest);\n+    router.route(HttpMethod.GET, \"/ws/query\")", "originalCommit": "bf9358e92fbc45d390ce338c8f612e96fc0499f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMTY4MA==", "url": "https://github.com/confluentinc/ksql/pull/5123#discussion_r412821680", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-04-22T09:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyODgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyOTM5MQ==", "url": "https://github.com/confluentinc/ksql/pull/5123#discussion_r412729391", "bodyText": "nit: can we put this code into a helper method, e.g., createWebsocketEndpoint(...)?", "author": "vcrfxia", "createdAt": "2020-04-22T07:13:54Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -378,6 +375,40 @@ public void setupResources(final Configurable<?> config, final KsqlRestConfig ap\n       config.register(lagReportingResource.get());\n     }\n     config.register(new ServerStateDynamicBinding(serverState));\n+\n+    final StatementParser statementParser = new StatementParser(ksqlEngine);", "originalCommit": "bf9358e92fbc45d390ce338c8f612e96fc0499f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMTYxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5123#discussion_r412821619", "bodyText": "I'm going to leave it for now, as this gets moved around in a PR later in the stack", "author": "purplefox", "createdAt": "2020-04-22T09:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyOTM5MQ=="}], "type": "inlineReview"}, {"oid": "12f11830058c84bc9a54c0f5881f96807a4c4e1f", "url": "https://github.com/confluentinc/ksql/commit/12f11830058c84bc9a54c0f5881f96807a4c4e1f", "message": "migrate websocket", "committedDate": "2020-04-22T07:40:18Z", "type": "forcePushed"}, {"oid": "6c2fd7527514396062bfe08011ec4b7700abad59", "url": "https://github.com/confluentinc/ksql/commit/6c2fd7527514396062bfe08011ec4b7700abad59", "message": "migrate websocket", "committedDate": "2020-04-22T09:17:35Z", "type": "commit"}, {"oid": "6c2fd7527514396062bfe08011ec4b7700abad59", "url": "https://github.com/confluentinc/ksql/commit/6c2fd7527514396062bfe08011ec4b7700abad59", "message": "migrate websocket", "committedDate": "2020-04-22T09:17:35Z", "type": "forcePushed"}, {"oid": "36d9dd86746e9133debeb5b5bc3e2815e8f93136", "url": "https://github.com/confluentinc/ksql/commit/36d9dd86746e9133debeb5b5bc3e2815e8f93136", "message": "Enable compression on websockets + make sure message is truncated or chrome barfs", "committedDate": "2020-04-22T10:22:06Z", "type": "commit"}, {"oid": "b7b927f4d9306a8f97459d812630d5e0c9159bf8", "url": "https://github.com/confluentinc/ksql/commit/b7b927f4d9306a8f97459d812630d5e0c9159bf8", "message": "findbugs", "committedDate": "2020-04-22T11:52:52Z", "type": "commit"}]}