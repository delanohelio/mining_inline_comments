{"pr_number": 6363, "pr_title": "chore: wire in auto-register for key schemas", "pr_createdAt": "2020-10-05T19:19:26Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6363", "timeline": [{"oid": "4c83f1c9f88bf06aacad262a9fb9a2bc3330003b", "url": "https://github.com/confluentinc/ksql/commit/4c83f1c9f88bf06aacad262a9fb9a2bc3330003b", "message": "feat: wire in auto-register for key schemas", "committedDate": "2020-10-05T20:03:26Z", "type": "commit"}, {"oid": "4c83f1c9f88bf06aacad262a9fb9a2bc3330003b", "url": "https://github.com/confluentinc/ksql/commit/4c83f1c9f88bf06aacad262a9fb9a2bc3330003b", "message": "feat: wire in auto-register for key schemas", "committedDate": "2020-10-05T20:03:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxNDIxOQ==", "url": "https://github.com/confluentinc/ksql/pull/6363#discussion_r500314219", "bodyText": "Can we rename schema and format to valueSchema and valueFormat? I realize there's a little extra effort needed to maintain backwards compatibility for users of the testing tool but I think not doing the rename will be confusing down the line, especially since format is used throughout the rest of the codebase to mean both key and value format (e.g., CREATE STREAM ... WITH (FORMAT='JSON', ...); is valid now).", "author": "vcrfxia", "createdAt": "2020-10-06T14:09:11Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/model/TopicNode.java", "diffHunk": "@@ -39,20 +38,26 @@\n   private static final ObjectMapper OBJECT_MAPPER = TestJsonMapper.INSTANCE.get();\n \n   private final String name;\n+  private final JsonNode keySchema;\n   private final JsonNode schema;\n   private final int numPartitions;\n   private final int replicas;\n+  private final String keyFormat;\n   private final String format;\n \n   public TopicNode(\n       @JsonProperty(\"name\") final String name,\n+      @JsonProperty(\"keySchema\") final JsonNode keySchema,\n       @JsonProperty(\"schema\") final JsonNode schema,", "originalCommit": "4c83f1c9f88bf06aacad262a9fb9a2bc3330003b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM2NDk3Mg==", "url": "https://github.com/confluentinc/ksql/pull/6363#discussion_r500364972", "bodyText": "sure, I'll do this in a follow-up PR since it requires changing tons of test files", "author": "agavra", "createdAt": "2020-10-06T15:01:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxNDIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxNDc0MA==", "url": "https://github.com/confluentinc/ksql/pull/6363#discussion_r500314740", "bodyText": "Rename method from buildValueSchema to buildSchema to avoid confusion? (And rename the params in the method as well)", "author": "vcrfxia", "createdAt": "2020-10-06T14:09:38Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestCaseBuilderUtil.java", "diffHunk": "@@ -147,12 +148,27 @@ private static Topic createTopicFromStatement(\n       final CreateSource statement = (CreateSource) stmt.getStatement();\n       final CreateSourceProperties props = statement.getProperties();\n \n-      final FormatInfo valueFormatInfo = SourcePropertiesUtil.getValueFormat(props);\n-      final Format valueFormat = FormatFactory.fromName(valueFormatInfo.getFormat());\n+      final LogicalSchema logicalSchema = statement.getElements().toLogicalSchema();\n+\n+      final FormatInfo keyFormatInfo = SourcePropertiesUtil.getKeyFormat(props);\n+      final Format keyFormat = FormatFactory.fromName(keyFormatInfo.getFormat());\n+      final SerdeFeatures keySerdeFeats = buildKeyFeatures(\n+          keyFormat, logicalSchema);\n+\n+      final Optional<ParsedSchema> keySchema =\n+          keyFormat.supportsFeature(SerdeFeature.SCHEMA_INFERENCE)\n+              ? buildValueSchema(sql, logicalSchema.key(), keyFormatInfo, keyFormat, keySerdeFeats)", "originalCommit": "4c83f1c9f88bf06aacad262a9fb9a2bc3330003b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxNTI0Ng==", "url": "https://github.com/confluentinc/ksql/pull/6363#discussion_r500315246", "bodyText": "Rename from valueFormat to keyFormat to avoid confusion?", "author": "vcrfxia", "createdAt": "2020-10-06T14:10:07Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestCaseBuilderUtil.java", "diffHunk": "@@ -228,6 +238,21 @@ private static Topic createTopicFromStatement(\n     }\n   }\n \n+  private static SerdeFeatures buildKeyFeatures(\n+      final Format valueFormat,", "originalCommit": "4c83f1c9f88bf06aacad262a9fb9a2bc3330003b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxNzAxOA==", "url": "https://github.com/confluentinc/ksql/pull/6363#discussion_r500317018", "bodyText": "This method is called is called to retrieve the key schema above (line 180) even though the method hardcodes the value suffix. Is key schema inference meant to be supported in QTT / the testing tool in this PR or not? I see in initializeTopics() below that only the value schema is checked as well.", "author": "vcrfxia", "createdAt": "2020-10-06T14:11:56Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestExecutorUtil.java", "diffHunk": "@@ -177,28 +177,37 @@ private static Topic buildSinkTopic(\n   ) {\n     final String kafkaTopicName = sinkDataSource.getKafkaTopicName();\n \n-    final Optional<ParsedSchema> schema = getSchema(sinkDataSource, schemaRegistryClient);\n+    final Optional<ParsedSchema> keySchema = getSchema(\n+        sinkDataSource.getKsqlTopic().getKeyFormat().getFormat(),\n+        sinkDataSource.getKsqlTopic().getKafkaTopicName(),\n+        schemaRegistryClient\n+    );\n+    final Optional<ParsedSchema> valueSchema = getSchema(\n+        sinkDataSource.getKsqlTopic().getValueFormat().getFormat(),\n+        sinkDataSource.getKsqlTopic().getKafkaTopicName(),\n+        schemaRegistryClient\n+    );\n \n-    final Topic sinkTopic = new Topic(kafkaTopicName, schema);\n+    final Topic sinkTopic = new Topic(kafkaTopicName, keySchema, valueSchema);\n \n     stubKafkaService.ensureTopic(sinkTopic);\n     return sinkTopic;\n   }\n \n   private static Optional<ParsedSchema> getSchema(\n-      final DataSource dataSource,\n+      final String format,\n+      final String topicName,\n       final SchemaRegistryClient schemaRegistryClient\n   ) {\n     final Format valueFormat = FormatFactory\n-        .fromName(dataSource.getKsqlTopic().getValueFormat().getFormat());\n+        .fromName(format);\n \n     if (!valueFormat.supportsFeature(SerdeFeature.SCHEMA_INFERENCE)) {\n       return Optional.empty();\n     }\n \n     try {\n-      final String subject =\n-          dataSource.getKafkaTopicName() + KsqlConstants.SCHEMA_REGISTRY_VALUE_SUFFIX;\n+      final String subject = topicName + KsqlConstants.SCHEMA_REGISTRY_VALUE_SUFFIX;", "originalCommit": "4c83f1c9f88bf06aacad262a9fb9a2bc3330003b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM3NzI2MA==", "url": "https://github.com/confluentinc/ksql/pull/6363#discussion_r500377260", "bodyText": "I started going down the path of supporting QTT tests, but because AVRO key formats aren't yet supported I couldn't get too far with testing. I figured the changes I've made here will be useful in a bit so I just left them in - but it is (as you can tell) a little raw...\nI'll clean it up (also thanks for catching this!)", "author": "agavra", "createdAt": "2020-10-06T15:14:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxNzAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxOTg3MA==", "url": "https://github.com/confluentinc/ksql/pull/6363#discussion_r500319870", "bodyText": "nit: not your code but can we add a quick unit test to ensure that withoutPseudoAndKeyColsInValue() here isn't lost? There doesn't appear to be one right now.", "author": "vcrfxia", "createdAt": "2020-10-06T14:15:00Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java", "diffHunk": "@@ -76,27 +78,42 @@ private void registerForCreateSource(final ConfiguredStatement<? extends CreateS\n     // since this injector is chained after the TopicCreateInjector,\n     // we can assume that the kafka topic is always present in the\n     // statement properties\n+    final CreateSource statement = cs.getStatement();\n+    final LogicalSchema schema = statement.getElements().toLogicalSchema();\n \n-    final LogicalSchema schema = cs.getStatement().getElements().toLogicalSchema();\n-\n-    final FormatInfo valueFormat = SourcePropertiesUtil\n-        .getValueFormat(cs.getStatement().getProperties());\n+    final FormatInfo keyFormat = SourcePropertiesUtil.getKeyFormat(statement.getProperties());\n+    final SerdeFeatures keyFeatures = SerdeFeaturesFactory.buildKeyFeatures(\n+        schema,\n+        FormatFactory.of(keyFormat)\n+    );\n+    registerSchema(\n+        schema.key(),\n+        statement.getProperties().getKafkaTopic(),\n+        keyFormat,\n+        keyFeatures,\n+        cs.getSessionConfig().getConfig(false),\n+        cs.getStatementText(),\n+        false,\n+        KsqlConstants.SCHEMA_REGISTRY_KEY_SUFFIX\n+    );\n \n+    final FormatInfo valueFormat = SourcePropertiesUtil.getValueFormat(statement.getProperties());\n     final SerdeFeatures valFeatures = SerdeFeaturesFactory.buildValueFeatures(\n         schema,\n         FormatFactory.of(valueFormat),\n-        cs.getStatement().getProperties().getValueSerdeFeatures(),\n+        statement.getProperties().getValueSerdeFeatures(),\n         cs.getSessionConfig().getConfig(false)\n     );\n \n     registerSchema(\n-        schema,\n-        cs.getStatement().getProperties().getKafkaTopic(),\n+        schema.withoutPseudoAndKeyColsInValue().value(),", "originalCommit": "4c83f1c9f88bf06aacad262a9fb9a2bc3330003b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM1MjYwNA==", "url": "https://github.com/confluentinc/ksql/pull/6363#discussion_r500352604", "bodyText": "This might actually not be needed. Be interesting to see if this can be removed.", "author": "big-andy-coates", "createdAt": "2020-10-06T14:48:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxOTg3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODYyMw==", "url": "https://github.com/confluentinc/ksql/pull/6363#discussion_r500408623", "bodyText": "I confirmed anecdotally and also by following the code path that it isn't necessary. The statement as passed in as a statement (as written) and the logical schema is derived from the getElements of the statement.\nAlso withPseudoAndKeyColsInValue is only called from LogicalPlanner, Analyzer and SourceBuilder, all of which happen after the injector phase.", "author": "agavra", "createdAt": "2020-10-06T15:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxOTg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM1NjEzMA==", "url": "https://github.com/confluentinc/ksql/pull/6363#discussion_r500356130", "bodyText": "minor: consider adding a registerSchemas method, which takes the logical schema and both formats. Internally, it justs called registerSchema for key then value.\nThis would make the code easier to read and remove a bit of duplication.", "author": "big-andy-coates", "createdAt": "2020-10-06T14:52:17Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegisterInjector.java", "diffHunk": "@@ -115,24 +132,36 @@ private void registerForCreateAs(final ConfiguredStatement<? extends CreateAsSel\n         ));\n \n     registerSchema(\n-        queryMetadata.getLogicalSchema(),\n+        queryMetadata.getLogicalSchema().key(),\n+        queryMetadata.getResultTopic().getKafkaTopicName(),\n+        queryMetadata.getResultTopic().getKeyFormat().getFormatInfo(),\n+        queryMetadata.getPhysicalSchema().keySchema().features(),\n+        cas.getSessionConfig().getConfig(false),\n+        cas.getStatementText(),\n+        true,\n+        KsqlConstants.SCHEMA_REGISTRY_KEY_SUFFIX\n+    );\n+    registerSchema(\n+        queryMetadata.getLogicalSchema().withoutPseudoAndKeyColsInValue().value(),", "originalCommit": "4c83f1c9f88bf06aacad262a9fb9a2bc3330003b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a449f77fae4a77a83f692ca7500c66eea80f60cd", "url": "https://github.com/confluentinc/ksql/commit/a449f77fae4a77a83f692ca7500c66eea80f60cd", "message": "chore: address PR feedback", "committedDate": "2020-10-06T15:51:09Z", "type": "commit"}]}