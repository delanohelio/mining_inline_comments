{"pr_number": 6349, "pr_title": "feat: `NONE` format for key-less streams", "pr_createdAt": "2020-10-02T10:43:36Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6349", "timeline": [{"oid": "9b7419812277731dcc2f5a21cfd7124a17e389f8", "url": "https://github.com/confluentinc/ksql/commit/9b7419812277731dcc2f5a21cfd7124a17e389f8", "message": "feat: add NONE format\n\nfixes: https://github.com/confluentinc/ksql/issues/6221\n\nIntroduce a `NONE` format, used to indicate the key data, in key-less streams, should not be deserialized.", "committedDate": "2020-10-02T10:42:22Z", "type": "commit"}, {"oid": "451f166349180f7dc2048ae8afd508dfd310e31c", "url": "https://github.com/confluentinc/ksql/commit/451f166349180f7dc2048ae8afd508dfd310e31c", "message": "test: historical plans", "committedDate": "2020-10-02T10:42:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMjQ3NA==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498812474", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            -   [`NONE`](#none) used to indicate the data should not be derialized.\n          \n          \n            \n            -   [`NONE`](#none) used to indicate the data should not be deserialized.", "author": "vcrfxia", "createdAt": "2020-10-02T13:13:24Z", "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.", "originalCommit": "451f166349180f7dc2048ae8afd508dfd310e31c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMjc3Ng==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498812776", "bodyText": "Also, can we move this to the end of the list? Seems confusing to have it as the first item (before the actual formats).", "author": "vcrfxia", "createdAt": "2020-10-02T13:13:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMjQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyODk4MA==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498828980", "bodyText": "I deliberately put it at the top of the list as it's a 'special'  format.", "author": "big-andy-coates", "createdAt": "2020-10-02T13:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMjQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0Mjk2NQ==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498842965", "bodyText": "I realize but it still feels a bit jarring to have it listed first since it's usage will be relatively uncommon. If the goal is to call attention to the format as being different from the others, maybe we can split this list into two: one for \"regular formats\" and one for \"special formats\" or something similalr.", "author": "vcrfxia", "createdAt": "2020-10-02T14:05:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMjQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMzA5Nw==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498813097", "bodyText": "This is no longer true if the NONE format is not supported as a value format.", "author": "vcrfxia", "createdAt": "2020-10-02T13:14:31Z", "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.\n+-   [`DELIMITED`](#delimited) supports comma separated values.\n+-   [`JSON`](#json) and [`JSON_SR`](#json) support JSON values, with and within schema registry integration \n+-   [`AVRO`](#avro) supports AVRO serialized values. \n+-   [`KAFKA`](#kafka) supports primitives serialized using the standard Kafka serializers. \n+-   [`PROTOBUF`](#protobuf) supports Protocol Buffers.\n \n All formats are supported as value formats. Only a subset of formats are", "originalCommit": "451f166349180f7dc2048ae8afd508dfd310e31c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMzU5NA==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498813594", "bodyText": "Add link to config?", "author": "vcrfxia", "createdAt": "2020-10-02T13:15:22Z", "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.\n+-   [`DELIMITED`](#delimited) supports comma separated values.\n+-   [`JSON`](#json) and [`JSON_SR`](#json) support JSON values, with and within schema registry integration \n+-   [`AVRO`](#avro) supports AVRO serialized values. \n+-   [`KAFKA`](#kafka) supports primitives serialized using the standard Kafka serializers. \n+-   [`PROTOBUF`](#protobuf) supports Protocol Buffers.\n \n All formats are supported as value formats. Only a subset of formats are\n currently supported as key formats. See individual formats for details.\n \n+### NONE\n+\n+| Feature                      | Supported |\n+|------------------------------|-----------|\n+| As value format              | No        |\n+| As key format                | Yes       |\n+| [Schema Registry required][0]| No        |\n+| [Schema inference][1]        | No        |\n+| [Single field wrapping][2]   | No        |\n+| [Single field unwrapping][2] | No        | \n+\n+The `NONE` format is a special marker format that is used to indicate ksqlDB should not attempt to \n+deserialize that part of the  {{ site.ak }} record.\n+\n+It's main use is as the `KEY_FORMAT` of key-less streams, especially where a default key format \n+has been set, via `ksql.persistence.default.format.key`, that supports Schema inference. If the", "originalCommit": "451f166349180f7dc2048ae8afd508dfd310e31c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMzY3Mg==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498813672", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If the schema did no exist, the statment would be rejected.  In such situations, the key format can\n          \n          \n            \n            If the schema did not exist, the statement would be rejected.  In such situations, the key format can", "author": "vcrfxia", "createdAt": "2020-10-02T13:15:33Z", "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.\n+-   [`DELIMITED`](#delimited) supports comma separated values.\n+-   [`JSON`](#json) and [`JSON_SR`](#json) support JSON values, with and within schema registry integration \n+-   [`AVRO`](#avro) supports AVRO serialized values. \n+-   [`KAFKA`](#kafka) supports primitives serialized using the standard Kafka serializers. \n+-   [`PROTOBUF`](#protobuf) supports Protocol Buffers.\n \n All formats are supported as value formats. Only a subset of formats are\n currently supported as key formats. See individual formats for details.\n \n+### NONE\n+\n+| Feature                      | Supported |\n+|------------------------------|-----------|\n+| As value format              | No        |\n+| As key format                | Yes       |\n+| [Schema Registry required][0]| No        |\n+| [Schema inference][1]        | No        |\n+| [Single field wrapping][2]   | No        |\n+| [Single field unwrapping][2] | No        | \n+\n+The `NONE` format is a special marker format that is used to indicate ksqlDB should not attempt to \n+deserialize that part of the  {{ site.ak }} record.\n+\n+It's main use is as the `KEY_FORMAT` of key-less streams, especially where a default key format \n+has been set, via `ksql.persistence.default.format.key`, that supports Schema inference. If the\n+key format was not overridden, the server would attempt to load the key schema from the {{ site.sr }}.\n+If the schema existed, the key columns would be inferred from the schema, which may not be the intent.\n+If the schema did no exist, the statment would be rejected.  In such situations, the key format can", "originalCommit": "451f166349180f7dc2048ae8afd508dfd310e31c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxNTU4OA==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498815588", "bodyText": "Clarify that it's only columns for the relevant portion of the record that fails the statement? I know it's clear after a moment's thought but on first read this sentence as written is confusing, especially given the immediately preceding example that defines columns.\nThere's also room for misinterpretation in light of the discussion about schema inference above, which is a different scenario under which columns might not be defined.", "author": "vcrfxia", "createdAt": "2020-10-02T13:18:52Z", "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.\n+-   [`DELIMITED`](#delimited) supports comma separated values.\n+-   [`JSON`](#json) and [`JSON_SR`](#json) support JSON values, with and within schema registry integration \n+-   [`AVRO`](#avro) supports AVRO serialized values. \n+-   [`KAFKA`](#kafka) supports primitives serialized using the standard Kafka serializers. \n+-   [`PROTOBUF`](#protobuf) supports Protocol Buffers.\n \n All formats are supported as value formats. Only a subset of formats are\n currently supported as key formats. See individual formats for details.\n \n+### NONE\n+\n+| Feature                      | Supported |\n+|------------------------------|-----------|\n+| As value format              | No        |\n+| As key format                | Yes       |\n+| [Schema Registry required][0]| No        |\n+| [Schema inference][1]        | No        |\n+| [Single field wrapping][2]   | No        |\n+| [Single field unwrapping][2] | No        | \n+\n+The `NONE` format is a special marker format that is used to indicate ksqlDB should not attempt to \n+deserialize that part of the  {{ site.ak }} record.\n+\n+It's main use is as the `KEY_FORMAT` of key-less streams, especially where a default key format \n+has been set, via `ksql.persistence.default.format.key`, that supports Schema inference. If the\n+key format was not overridden, the server would attempt to load the key schema from the {{ site.sr }}.\n+If the schema existed, the key columns would be inferred from the schema, which may not be the intent.\n+If the schema did no exist, the statment would be rejected.  In such situations, the key format can\n+be set to `NONE`: \n+\n+```sql\n+CREATE STREAM KEY_LESS_STREAM (\n+    VAL STRING\n+  ) WITH (\n+    KEY_FORMAT='NONE',\n+    VALUE_FORMAT='JSON',\n+    KAFKA_TOPIC='foo'\n+  );\n+```\n+\n+Any statement using format `NONE` that defines columns will result in an error.", "originalCommit": "451f166349180f7dc2048ae8afd508dfd310e31c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxNjc5MA==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498816790", "bodyText": "What about the reverse scenario: the source stream has a key format defined and the CSAS removes the key (via PARTITION BY NULL). Does the user need to explicitly set the key format in the CSAS to NONE? I assume not, could be good to clarify in the docs.", "author": "vcrfxia", "createdAt": "2020-10-02T13:21:01Z", "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.\n+-   [`DELIMITED`](#delimited) supports comma separated values.\n+-   [`JSON`](#json) and [`JSON_SR`](#json) support JSON values, with and within schema registry integration \n+-   [`AVRO`](#avro) supports AVRO serialized values. \n+-   [`KAFKA`](#kafka) supports primitives serialized using the standard Kafka serializers. \n+-   [`PROTOBUF`](#protobuf) supports Protocol Buffers.\n \n All formats are supported as value formats. Only a subset of formats are\n currently supported as key formats. See individual formats for details.\n \n+### NONE\n+\n+| Feature                      | Supported |\n+|------------------------------|-----------|\n+| As value format              | No        |\n+| As key format                | Yes       |\n+| [Schema Registry required][0]| No        |\n+| [Schema inference][1]        | No        |\n+| [Single field wrapping][2]   | No        |\n+| [Single field unwrapping][2] | No        | \n+\n+The `NONE` format is a special marker format that is used to indicate ksqlDB should not attempt to \n+deserialize that part of the  {{ site.ak }} record.\n+\n+It's main use is as the `KEY_FORMAT` of key-less streams, especially where a default key format \n+has been set, via `ksql.persistence.default.format.key`, that supports Schema inference. If the\n+key format was not overridden, the server would attempt to load the key schema from the {{ site.sr }}.\n+If the schema existed, the key columns would be inferred from the schema, which may not be the intent.\n+If the schema did no exist, the statment would be rejected.  In such situations, the key format can\n+be set to `NONE`: \n+\n+```sql\n+CREATE STREAM KEY_LESS_STREAM (\n+    VAL STRING\n+  ) WITH (\n+    KEY_FORMAT='NONE',\n+    VALUE_FORMAT='JSON',\n+    KAFKA_TOPIC='foo'\n+  );\n+```\n+\n+Any statement using format `NONE` that defines columns will result in an error.\n+\n+If a `CREATE TABLE AS` or `CREATE STREAM AS` statement has a source with a key format of `NONE`, but\n+the newly created table or stream has key column, then you may either explicitly define the key \n+format to use in the `WITH` clause, or the default key format, as set in `ksql.persistence.default.format.key`\n+will be used.", "originalCommit": "451f166349180f7dc2048ae8afd508dfd310e31c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxNzA1Ng==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498817056", "bodyText": "nit: \"keyless\" is usually one word?", "author": "vcrfxia", "createdAt": "2020-10-02T13:21:31Z", "path": "docs/developer-guide/serialization.md", "diffHunk": "@@ -32,16 +32,75 @@ Serialization Formats\n \n ksqlDB supports these serialization formats:\n \n--   `DELIMITED` supports comma separated values. See [DELIMITED](#delimited) below.\n--   `JSON` and `JSON_SR` support JSON values. See [JSON](#json) below.\n--   `AVRO` supports AVRO serialized values. See [AVRO](#avro) below.\n--   `KAFKA` supports primitives serialized using the standard Kafka\n-    serializers. See [KAFKA](#kafka) below.\n--   `PROTOBUF` supports Protocol Buffers. See [Protobuf](#protobuf) below.\n+-   [`NONE`](#none) used to indicate the data should not be derialized.\n+-   [`DELIMITED`](#delimited) supports comma separated values.\n+-   [`JSON`](#json) and [`JSON_SR`](#json) support JSON values, with and within schema registry integration \n+-   [`AVRO`](#avro) supports AVRO serialized values. \n+-   [`KAFKA`](#kafka) supports primitives serialized using the standard Kafka serializers. \n+-   [`PROTOBUF`](#protobuf) supports Protocol Buffers.\n \n All formats are supported as value formats. Only a subset of formats are\n currently supported as key formats. See individual formats for details.\n \n+### NONE\n+\n+| Feature                      | Supported |\n+|------------------------------|-----------|\n+| As value format              | No        |\n+| As key format                | Yes       |\n+| [Schema Registry required][0]| No        |\n+| [Schema inference][1]        | No        |\n+| [Single field wrapping][2]   | No        |\n+| [Single field unwrapping][2] | No        | \n+\n+The `NONE` format is a special marker format that is used to indicate ksqlDB should not attempt to \n+deserialize that part of the  {{ site.ak }} record.\n+\n+It's main use is as the `KEY_FORMAT` of key-less streams, especially where a default key format \n+has been set, via `ksql.persistence.default.format.key`, that supports Schema inference. If the\n+key format was not overridden, the server would attempt to load the key schema from the {{ site.sr }}.\n+If the schema existed, the key columns would be inferred from the schema, which may not be the intent.\n+If the schema did no exist, the statment would be rejected.  In such situations, the key format can\n+be set to `NONE`: \n+\n+```sql\n+CREATE STREAM KEY_LESS_STREAM (", "originalCommit": "451f166349180f7dc2048ae8afd508dfd310e31c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyMDQ2NA==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498820464", "bodyText": "Is the thinking here that JSON works even if no key columns are specified, so we might as well always use JSON so that if a stream with no key columns is the source for a another stream/table down the line, then the sink stream/table will automatically get JSON as the key format, regardless of what the config default key format is?", "author": "vcrfxia", "createdAt": "2020-10-02T13:27:31Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/serde/InternalFormats.java", "diffHunk": "@@ -50,10 +52,15 @@ private InternalFormats() {\n    * @see SerdeFeaturesFactory#buildInternal\n    */\n   public static Formats of(final KeyFormat keyFormat, final ValueFormat valueFormat) {\n+    // Do not use NONE format for internal topics:", "originalCommit": "451f166349180f7dc2048ae8afd508dfd310e31c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyODYyNQ==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498828625", "bodyText": "Perhaps I've missed it but I don't see any QTT for testing this. Can we add one in order to prevent regressions here?", "author": "vcrfxia", "createdAt": "2020-10-02T13:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyMDQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgzNzcyMg==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498837722", "bodyText": "if no key columns are specified\n\nInternal topics always have a key column.\nThis is just stop-gap functionality. I'm working on better handling of internal key format in another PR.", "author": "big-andy-coates", "createdAt": "2020-10-02T13:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyMDQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0MTI1OQ==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498841259", "bodyText": "If that's the case, why would we ever arrive in this situation (of trying to build an internal topic with key format NONE)? Can we just fail if that happens, instead of converting the format to JSON?", "author": "vcrfxia", "createdAt": "2020-10-02T14:02:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyMDQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyNDU3NA==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498824574", "bodyText": "Not directly related to this PR: I notice the printing of the schema doesn't distinguish between KEY and PRIMARY KEY. What was the reasoning for that? Is it just easier to not worry about passing in information about source type to the schema, or is the current behavior preferred outside of the logistical concern too?", "author": "vcrfxia", "createdAt": "2020-10-02T13:34:27Z", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/none.json", "diffHunk": "@@ -0,0 +1,181 @@\n+{\n+  \"comments\": [\n+    \"NONE format testing.\"\n+  ],\n+  \"tests\": [\n+    {\n+      \"name\": \"as key format of keyless stream\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (foo INT) WITH (kafka_topic='input_topic', key_format='NONE', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": {\"foo\": 10}},\n+        {\"topic\": \"input_topic\", \"key\": \"data that should be ignored\", \"value\": {\"foo\": 11}},\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": null}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": {\"FOO\": 10}},\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": {\"FOO\": 11}},\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": null}\n+      ]\n+    },\n+    {\n+      \"name\": \"as key format of keyed stream\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='NONE', value_format='JSON');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`K` STRING KEY]\"\n+      }\n+    },\n+    {\n+      \"name\": \"as key format of table\",\n+      \"statements\": [\n+        \"CREATE TABLE INPUT (K STRING PRIMARY KEY, foo INT) WITH (kafka_topic='input_topic', key_format='NONE', value_format='JSON');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`K` STRING KEY]\"\n+      }\n+    },\n+    {\n+      \"name\": \"as value format with value columns\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (foo INT) WITH (kafka_topic='input_topic', value_format='NONE');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`FOO` INTEGER]\"\n+      }\n+    },\n+    {\n+      \"name\": \"in CSAS from keyless stream\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT WITH(key_format='NONE') AS SELECT * FROM INPUT;\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": \"ignored\", \"value\": {\"FOO\": 10}},\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": null}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": {\"FOO\": 10}},\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": null}\n+      ]\n+    },\n+    {\n+      \"name\": \"in CSAS partitioning by null\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID INT KEY, foo INT) WITH (kafka_topic='input_topic', key_format='KAFKA', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT WITH(key_format='NONE') AS SELECT * FROM INPUT PARTITION BY null;\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": 9, \"value\": {\"FOO\": 10}},\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": null}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": {\"FOO\": 10, \"ID\": 9}},\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": null}\n+      ]\n+    },\n+    {\n+      \"name\": \"explicitly set in CSAS with key\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (foo INT, bar INT) WITH (kafka_topic='input_topic', key_format='KAFKA', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT WITH (key_format='NONE') AS SELECT * FROM INPUT PARTITION BY BAR;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`BAR` INTEGER KEY]\"\n+      }\n+    },\n+    {\n+      \"name\": \"explicitly set in CTAS\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (foo INT, bar INT) WITH (kafka_topic='input_topic', key_format='KAFKA', value_format='JSON');\",\n+        \"CREATE TABLE OUTPUT WITH (key_format='NONE') AS SELECT BAR AS K, COUNT() FROM INPUT GROUP BY BAR;\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`K` INTEGER KEY]\"", "originalCommit": "451f166349180f7dc2048ae8afd508dfd310e31c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgzOTE1Mg==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498839152", "bodyText": "The text is coming from LogicalSchema / Column, which do not differentiate between primary key and key.\nWe could just strip off the KEY all together, but I don't really see it as a big thing.  The error message has enough information that the user can correct the error.", "author": "big-andy-coates", "createdAt": "2020-10-02T13:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyNDU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyNzAyMQ==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498827021", "bodyText": "Can we add a test for what happens if someone tries to set NONE as value format with no value columns? I assume this is not supported. It'd be good to check that the error message is sensible.", "author": "vcrfxia", "createdAt": "2020-10-02T13:38:43Z", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/none.json", "diffHunk": "@@ -0,0 +1,181 @@\n+{\n+  \"comments\": [\n+    \"NONE format testing.\"\n+  ],\n+  \"tests\": [\n+    {\n+      \"name\": \"as key format of keyless stream\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (foo INT) WITH (kafka_topic='input_topic', key_format='NONE', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT;\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": {\"foo\": 10}},\n+        {\"topic\": \"input_topic\", \"key\": \"data that should be ignored\", \"value\": {\"foo\": 11}},\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": null}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": {\"FOO\": 10}},\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": {\"FOO\": 11}},\n+        {\"topic\": \"OUTPUT\", \"key\": null, \"value\": null}\n+      ]\n+    },\n+    {\n+      \"name\": \"as key format of keyed stream\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (K STRING KEY, foo INT) WITH (kafka_topic='input_topic', key_format='NONE', value_format='JSON');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`K` STRING KEY]\"\n+      }\n+    },\n+    {\n+      \"name\": \"as key format of table\",\n+      \"statements\": [\n+        \"CREATE TABLE INPUT (K STRING PRIMARY KEY, foo INT) WITH (kafka_topic='input_topic', key_format='NONE', value_format='JSON');\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'NONE' format can only be used when no columns are defined. Got: [`K` STRING KEY]\"\n+      }\n+    },\n+    {\n+      \"name\": \"as value format with value columns\",", "originalCommit": "451f166349180f7dc2048ae8afd508dfd310e31c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0MjczMA==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498842730", "bodyText": "You'd think no value columns would not work right?  Nope... it works, and just fails if you try and use the source.\n(See #6352)", "author": "big-andy-coates", "createdAt": "2020-10-02T14:04:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyNzAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NTI5Mg==", "url": "https://github.com/confluentinc/ksql/pull/6349#discussion_r498845292", "bodyText": "That's unfortunate... is it worth slipping a line into the docs for the new NONE format to clarify that ksqlDB doesn't yet support empty value columns, so the NONE format should only be used as key format for now? Could also fail up front if users try to use the NONE format as a value format but that might not be worth the effort since it's code that will eventually be removed.", "author": "vcrfxia", "createdAt": "2020-10-02T14:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyNzAyMQ=="}], "type": "inlineReview"}, {"oid": "ce80465f860bad5d1b3cbff110310674e9384209", "url": "https://github.com/confluentinc/ksql/commit/ce80465f860bad5d1b3cbff110310674e9384209", "message": "Update docs/developer-guide/serialization.md\n\nCo-authored-by: Victoria Xia <victoria.f.xia281@gmail.com>", "committedDate": "2020-10-02T13:40:48Z", "type": "commit"}, {"oid": "6683779f8289fe5559415dd866097f298b1f92cb", "url": "https://github.com/confluentinc/ksql/commit/6683779f8289fe5559415dd866097f298b1f92cb", "message": "chore: requested changes", "committedDate": "2020-10-02T14:06:28Z", "type": "commit"}]}