{"pr_number": 6090, "pr_title": "docs: copy edit new query upgrade topic (DOCS-5200)", "pr_createdAt": "2020-08-25T18:00:33Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6090", "timeline": [{"oid": "9550cdfd59bb8ace2d51233d77032988ee879351", "url": "https://github.com/confluentinc/ksql/commit/9550cdfd59bb8ace2d51233d77032988ee879351", "message": "docs: query upgrade docs", "committedDate": "2020-08-25T01:35:39Z", "type": "commit"}, {"oid": "bb7c3fb1f2b04d6ecd742c9ed67e64aace43b12e", "url": "https://github.com/confluentinc/ksql/commit/bb7c3fb1f2b04d6ecd742c9ed67e64aace43b12e", "message": "docs: copy edit new query upgrade topic (DOCS-5200)", "committedDate": "2020-08-25T17:56:24Z", "type": "commit"}, {"oid": "4e3eee8880d14b8810cd3f6d712dccc7f40ee662", "url": "https://github.com/confluentinc/ksql/commit/4e3eee8880d14b8810cd3f6d712dccc7f40ee662", "message": "Update upgrades.md", "committedDate": "2020-08-25T18:22:35Z", "type": "commit"}, {"oid": "8bccc69dd0e9f2748c42da33f71a4cb29f602b85", "url": "https://github.com/confluentinc/ksql/commit/8bccc69dd0e9f2748c42da33f71a4cb29f602b85", "message": "Update upgrades.md", "committedDate": "2020-08-25T18:27:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM4MTA5MQ==", "url": "https://github.com/confluentinc/ksql/pull/6090#discussion_r477381091", "bodyText": "Bit late to the party here but wanted to say I really like this example! Great job @agavra (and @JimGalasyn ) -- this is an awesome docs topic \ud83d\ude04", "author": "vcrfxia", "createdAt": "2020-08-26T15:15:49Z", "path": "docs/concepts/upgrades.md", "diffHunk": "@@ -0,0 +1,176 @@\n+---\n+layout: page\n+title: Evolving Production Queries\n+tagline: Replacing existing queries\n+description: Learn how to manage your production deployments over time\n+keywords: ksqldb, upgrade, schema evolution\n+---\n+\n+Production deployments of databases are never static; they evolve as application\n+and business requirements change. To that end, all popular data stores have ways\n+of managing and manipulating existing data. For stream processing applications,\n+you may want to modify your application because of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either\n+  by user or engine)\n+\n+ksqlDB provides various mechanisms to interact with a query that's running in\n+production.\n+\n+1. *In-place upgrades*: users modify the behavior of a query, resuming from a\n+   previously committed offset. The syntax that ksqlDB uses to indicate an\n+   in-place upgrade is `CREATE OR REPLACE`.\n+1. *Replacing upgrades*: these upgrades require you to tear down existing\n+   queries, and start a new one from either `earliest` or `latest` offsets.\n+   To accomplish this, users you first issue a `TERMINATE <query_id>;` and a\n+   `DROP <source>` before creating the query again.\n+\n+## Understanding upgrades\n+\n+To better understand the different types of upgrades that exist on continuous\n+queries, we define a taxonomy on query upgrades as any combination of three\n+types of characteristics: _source query_, _upgrade_ and (optionally) _environment_.\n+\n+| **Category** | **Characteristic** | **Description** |\n+|----------|----------------|-------------|\n+| Query | Stateful | Stateful queries maintain local storage |\n+| | Windowed | Windowed queries maintain a limited amount of state specified by a window in time\n+| | Joined | Joined queries read from multiple sources\n+| | Multistage | Multistage queries contain intermediate, non-user visible topics in Kafka\n+| | Nondeterministic | Nondeterministic queries may produce different results when executing identical input\n+| | Simple | Queries with none of the above characteristics\n+| Upgrade | Transparent | Transparent upgrades change the way something is computed (e.g. improving a UDF performance)\n+| | Data Selection | Data selecting query upgrades change which/how many events are emitted\n+| | Schema Evolution | Schema evolving query upgrades change the output type of the data |\n+| | Source Modifying | These upgrades change the source data, whether by means of modifying a JOIN or swapping out a source |\n+| | Topology | These upgrades are invisible to the user, but change the topology, such as the number of sub-topologies or the ordering of operations (e.g. filter push down) |\n+| | Scaling | Scaling upgrades change the physical properties of the query in order to enable better performance characteristics. |\n+| | Unsupported | Unsupported upgrades are ones that will semantically change the query in an unsupported way. There are no plans to implement these migrations. |\n+| Environment | Backfill | Backfill requires the output data to be accurate not just from a point in time, but from the earliest point of retained history |\n+| | Cascading | Cascading environments contain queries that are not terminal, but rather feed into downstream stream processing tasks |\n+| | Exactly Once | Exactly Once environments do not allow for data duplication or missed events |\n+| | Ordered | Ordered environments require that a single offset delineates pre- and post-migration (no events are interleaved) |\n+| | Live | Live environments describe queries that cannot afford downtime, either by means of acting as live storage (e.g. responding to pull queries) or feeding into high availability systems (powering important functionality) |\n+\n+ksqlDB supports only in-place upgrades for _data selection_ and\n+_schema evolution_ upgrades on a limited subset of query characteristics.\n+ksqlDB doesn't guarantee validity of any environments when performing an\n+in-place upgrade.\n+\n+Any in place upgrades on windowed or joined sources, as well as upgrades on\n+any table aggregation, are not yet supported.\n+\n+## A motivating example\n+\n+Imagine a query that reads from a stream of purchases made at ksqlDB's flagship\n+store, ksqlMart, and filters out transactions that might be invalid:\n+\n+```sql\n+CREATE STREAM purchases (product_id INT KEY, name VARCHAR, cost DOUBLE, quantity INT);\n+CREATE STREAM valid_purchases AS SELECT * FROM purchases WHERE cost > 0.00 AND quantity > 0;\n+```\n+\n+### Data selection (simple)\n+\n+Over time, ksqlMart changes its return policy and begins issuing full refunds.\n+These events have a negative `cost` column value. Since these events are now\n+valid, ksqlMart needs to update the query to remove the `cost > 0.00` clause:\n+\n+```sql\n+CREATE OR REPLACE STREAM valid_purchases AS SELECT * FROM purchases WHERE quantity > 0;\n+```\n+\n+This `CREATE OR REPLACE` statement instructs ksqlDB to terminate the old query,\n+and create a new one with the new semantics that will continue from the last\n+event that the previous query processed. Note that this means any previously \n+processed data with negative cost will not be included, even if issuing the\n+query with `SET 'auto.offset.reset'='earliest';`.\n+\n+This query upgrade is a _simple_, _data selecting_ upgrade because it doesn't\n+involve any aggregations; the only change is the criteria to emit rows. ksqlDB\n+supports nearly all _data selection_ modifications on source queries.\n+\n+### Schema evolution\n+\n+Over time, ksqlMart gets more sophisticated in their usage of {{ site.ak }} to\n+monitor their input. They start publishing a new field to the `purchases` stream,\n+named `popularity`. In order to reflect this change in their `valid_purchases`\n+stream, they need to issue two different commands:\n+\n+```sql\n+CREATE OR REPLACE STREAM purchases (product_id INT KEY, name VARCHAR, cost DOUBLE, quantity INT, popularity DOUBLE); \n+CREATE OR REPLACE STREAM valid_purchases AS SELECT * FROM purchases WHERE quantity > 0;\n+```\n+\n+There are a few things to note in the above statements:\n+\n+1. DDL statements can be updated using `CREATE OR REPLACE`.\n+2. ksqlMart re-issued the `SELECT *` statement even though the statement text is\n+   identical to the previous statement they issued.\n+3. Why is (2) necessary? ksqlDB resolves `SELECT *` at the time the query was", "originalCommit": "8bccc69dd0e9f2748c42da33f71a4cb29f602b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}