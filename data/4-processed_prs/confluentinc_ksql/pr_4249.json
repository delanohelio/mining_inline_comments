{"pr_number": 4249, "pr_title": "fix: include path of field that causes JSON deserialization error", "pr_createdAt": "2020-01-08T15:44:06Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4249", "timeline": [{"oid": "4e1bd785bc300a4e892c8e477ad4c3b63abd73a4", "url": "https://github.com/confluentinc/ksql/commit/4e1bd785bc300a4e892c8e477ad4c3b63abd73a4", "message": "fix: include path of field that causes JSON deserialization error\n\nFixes: https://github.com/confluentinc/ksql/issues/4238\n\nFor complex types, the current deserialization error can be a bit lacking, as it does not include details of which field causes the error.  This commit enhances the JSON deserializer to include the JSON path of where the error occurred in the error message.\n\nThe design keep the happy path quick by using the call stack to maintain the stack of fields, rather than tracking them in some separate stack in memory. Figured this was worth while for such a performance sensitive area of the code.  There's no detectable perf hit from this change.\n\nI've also increased the times on the `SerdeBenchmark`, as from my own experience 10 seconds is not enough time for the JVM to optimise the byte code.\n\nPerf test on JSON deserialization before changes:\n\n```\n# JMH version: 1.21\n# VM version: JDK 1.8.0_162, Java HotSpot(TM) 64-Bit Server VM, 25.162-b12\n# VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/bin/java\n# VM options: -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=58499:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8\n# Warmup: 6 iterations, 30 s each\n# Measurement: 3 iterations, 60 s each\n# Timeout: 10 min per iteration\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Average time, time/op\n# Benchmark: io.confluent.ksql.benchmark.SerdeBenchmark.deserialize\n# Parameters: (schemaName = metrics, serializationFormat = JSON)\n\n# Run progress: 0.00% complete, ETA 00:06:00\n# Fork: 1 of 1\n# Warmup Iteration   1: 5.188 us/op\n# Warmup Iteration   2: 5.124 us/op\n# Warmup Iteration   3: 5.193 us/op\n# Warmup Iteration   4: 5.529 us/op\n# Warmup Iteration   5: 5.378 us/op\n# Warmup Iteration   6: 5.266 us/op\nIteration   1: 5.209 us/op\nIteration   2: 5.183 us/op\nIteration   3: 5.274 us/op\n\nResult \"io.confluent.ksql.benchmark.SerdeBenchmark.deserialize\":\n  5.222 \u00b1(99.9%) 0.854 us/op [Average]\n  (min, avg, max) = (5.183, 5.222, 5.274), stdev = 0.047\n  CI (99.9%): [4.368, 6.075] (assumes normal distribution)\n\n# Run complete. Total time: 00:06:01\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark                   (schemaName)  (serializationFormat)  Mode  Cnt  Score   Error  Units\nSerdeBenchmark.deserialize       metrics                   JSON  avgt    3  5.222 \u00b1 0.854  us/op\n ```\n\nAfter:\n\n```\n# JMH version: 1.21\n# VM version: JDK 1.8.0_162, Java HotSpot(TM) 64-Bit Server VM, 25.162-b12\n# VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre/bin/java\n# VM options: -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=60943:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8\n# Warmup: 6 iterations, 30 s each\n# Measurement: 3 iterations, 60 s each\n# Timeout: 10 min per iteration\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Average time, time/op\n# Benchmark: io.confluent.ksql.benchmark.SerdeBenchmark.deserialize\n# Parameters: (schemaName = metrics, serializationFormat = JSON)\n\n# Run progress: 0.00% complete, ETA 00:06:00\n# Fork: 1 of 1\n# Warmup Iteration   1: 5.284 us/op\n# Warmup Iteration   2: 5.114 us/op\n# Warmup Iteration   3: 5.185 us/op\n# Warmup Iteration   4: 5.105 us/op\n# Warmup Iteration   5: 5.171 us/op\n# Warmup Iteration   6: 5.119 us/op\nIteration   1: 5.208 us/op\nIteration   2: 5.248 us/op\nIteration   3: 5.198 us/op\n\nResult \"io.confluent.ksql.benchmark.SerdeBenchmark.deserialize\":\n  5.218 \u00b1(99.9%) 0.477 us/op [Average]\n  (min, avg, max) = (5.198, 5.218, 5.248), stdev = 0.026\n  CI (99.9%): [4.740, 5.695] (assumes normal distribution)\n\n# Run complete. Total time: 00:06:02\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark                   (schemaName)  (serializationFormat)  Mode  Cnt  Score   Error  Units\nSerdeBenchmark.deserialize       metrics                   JSON  avgt    3  5.218 \u00b1 0.477  us/op\n\n```", "committedDate": "2020-01-08T15:40:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1NjY4Ng==", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364556686", "bodyText": "What is this argument that controls whether to fail on error? Is this documented somewhere?", "author": "vcrfxia", "createdAt": "2020-01-09T04:39:23Z", "path": "ksql-benchmark/src/main/java/io/confluent/ksql/benchmark/SerdeBenchmark.java", "diffHunk": "@@ -192,20 +192,26 @@ public void setUp(final SchemaAndGenericRowState rowState) {\n     }\n   }\n \n+  @SuppressWarnings(\"MethodMayBeStatic\") // Tests can not be static\n   @Benchmark\n   public byte[] serialize(final SerdeState serdeState) {\n     return serdeState.serializer.serialize(TOPIC_NAME, serdeState.row);\n   }\n \n+  @SuppressWarnings(\"MethodMayBeStatic\") // Tests can not be static\n   @Benchmark\n   public GenericRow deserialize(final SerdeState serdeState) {\n     return serdeState.deserializer.deserialize(TOPIC_NAME, serdeState.bytes);\n   }\n \n-  public static void main(final String[] args) throws RunnerException {\n-    final Options opt = new OptionsBuilder()\n-        .include(SerdeBenchmark.class.getSimpleName())\n-        .build();\n+  public static void main(final String[] args) throws Exception {\n+\n+    final Options opt = args.length != 0\n+        ? new CommandLineOptions(args)\n+        : new OptionsBuilder()\n+            .include(SerdeBenchmark.class.getSimpleName())\n+            .shouldFailOnError(true)", "originalCommit": "4e1bd785bc300a4e892c8e477ad4c3b63abd73a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDc1NDYzNQ==", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364754635", "bodyText": "Not sure where it's documented. Just means if the code under test throws exceptions it fails, which is what we want.", "author": "big-andy-coates", "createdAt": "2020-01-09T14:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1NjY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1ODE4OQ==", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364558189", "bodyText": "I've also increased the times on the SerdeBenchmark, as from my own experience 10 seconds is not enough time for the JVM to optimise the byte code.\n\nPardon the naivete, but isn't the point of using JMH to avoid optimizations? Why are we trying to allow the JVM time to perform optimizations? Wouldn't that be less representative of how these segments of code are used in practice?", "author": "vcrfxia", "createdAt": "2020-01-09T04:48:55Z", "path": "ksql-benchmark/src/main/java/io/confluent/ksql/benchmark/SerdeBenchmark.java", "diffHunk": "@@ -68,8 +68,8 @@\n  */\n @BenchmarkMode(Mode.AverageTime)\n @OutputTimeUnit(TimeUnit.MICROSECONDS)\n-@Warmup(iterations = 3, time = 10)\n-@Measurement(iterations = 3, time = 10)\n+@Warmup(iterations = 6, time = 30)", "originalCommit": "4e1bd785bc300a4e892c8e477ad4c3b63abd73a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDc1NTI5Nw==", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364755297", "bodyText": "Not at all. We want to JVM to be given time to optimise the code. That's what the warm-up is all about. When KSQL is running in production it will be running for a long time and the JVM will optimise such code paths. So a meaningful benchmark needs to give the JVM time to do this before running tests.", "author": "big-andy-coates", "createdAt": "2020-01-09T14:05:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1ODE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5ODMwMg==", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364898302", "bodyText": "Perhaps my understanding gap is in JVM optimizations, then. It's true that when KSQL is running in production the JVM will have time to optimize this code, but KSQL running in production wouldn't just be running this serde code over and over again. Intuitively it feels like the JVM would be able to make stronger optimizations on the serde code if that's all that's being run, compared to the the serde code being run as part of other KSQL code. Is this not true / not a concern for benchmarking?", "author": "vcrfxia", "createdAt": "2020-01-09T18:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1ODE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1ODMxMA==", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364558310", "bodyText": "Very cool! I spent some time thinking about how to implement this and didn't come up with anything nearly as nice. Glad to have had the opportunity to learn from you :)", "author": "vcrfxia", "createdAt": "2020-01-09T04:49:36Z", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/KsqlJsonDeserializer.java", "diffHunk": "@@ -82,55 +84,53 @@ public KsqlJsonDeserializer(\n   }\n \n   @Override\n-  public void configure(final Map<String, ?> map, final boolean b) {\n+  public void configure(final Map<String, ?> map, final boolean isKey) {\n+    this.target = isKey ? \"key\" : \"value\";\n   }\n \n   @Override\n   public Object deserialize(final String topic, final byte[] bytes) {\n     try {\n-      final Object value = deserialize(bytes);\n+      final JsonNode value = bytes == null\n+          ? null\n+          : MAPPER.readTree(bytes);\n+\n+      final Object coerced = enforceFieldType(\n+          \"$\",\n+          new JsonValueContext(value, physicalSchema.serializedSchema())\n+      );\n+\n       if (LOG.isTraceEnabled()) {\n-        LOG.trace(\"Deserialized value. topic:{}, row:{}\", topic, value);\n+        LOG.trace(\"Deserialized {}. topic:{}, row:{}\", target, topic, coerced);\n       }\n-      return value;\n+\n+      return coerced;\n     } catch (final Exception e) {\n       throw new SerializationException(\n-          \"Error deserializing JSON message from topic: \" + topic, e);\n-    }\n-  }\n-\n-  private Object deserialize(final byte[] bytes) {\n-    try {\n-      if (bytes == null) {\n-        return null;\n-      }\n-\n-      final JsonNode value = MAPPER.readTree(bytes);\n-      return enforceFieldType(this, physicalSchema.serializedSchema(), value);\n-    } catch (final IOException e) {\n-      throw new SerializationException(e);\n+          \"mvn \" + target + \" from topic: \" + topic, e);\n     }\n   }\n \n   private static Object enforceFieldType(\n-      final KsqlJsonDeserializer deserializer,\n-      final Schema schema,\n-      final JsonNode columnVal\n+      final String pathPart,\n+      final JsonValueContext context\n   ) {\n-    return enforceFieldType(new JsonValueContext(deserializer, schema, columnVal));\n-  }\n-\n-  private static Object enforceFieldType(final JsonValueContext context) {\n     if (context.val == null || context.val instanceof NullNode) {\n       return null;\n     }\n \n-    final Function<JsonValueContext, Object> handler = HANDLERS.getOrDefault(\n-        context.schema.type(),\n-        type -> {\n-          throw new KsqlException(\"Type is not supported: \" + type);\n-        });\n-    return handler.apply(context);\n+    try {\n+      final Function<JsonValueContext, Object> handler = HANDLERS.getOrDefault(\n+          context.schema.type(),\n+          type -> {\n+            throw new KsqlException(\"Type is not supported: \" + type);\n+          });\n+      return handler.apply(context);\n+    } catch (final CoercionException e) {\n+      throw new CoercionException(e.getRawMessage(), pathPart + e.getPath(), e);", "originalCommit": "4e1bd785bc300a4e892c8e477ad4c3b63abd73a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDc1NTM4Nw==", "url": "https://github.com/confluentinc/ksql/pull/4249#discussion_r364755387", "bodyText": ":)", "author": "big-andy-coates", "createdAt": "2020-01-09T14:06:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU1ODMxMA=="}], "type": "inlineReview"}]}