{"pr_number": 4278, "pr_title": "feat: expression support in JOINs", "pr_createdAt": "2020-01-11T00:35:16Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4278", "timeline": [{"oid": "68496bfb6b51c601bf1889393ffcb1b60388a45b", "url": "https://github.com/confluentinc/ksql/commit/68496bfb6b51c601bf1889393ffcb1b60388a45b", "message": "feat: expression support in JOINs", "committedDate": "2020-01-13T18:58:41Z", "type": "commit"}, {"oid": "68496bfb6b51c601bf1889393ffcb1b60388a45b", "url": "https://github.com/confluentinc/ksql/commit/68496bfb6b51c601bf1889393ffcb1b60388a45b", "message": "feat: expression support in JOINs", "committedDate": "2020-01-13T18:58:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA5OTE0Nw==", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366099147", "bodyText": "Each step in the logical plan should have a unique node id, so we should pass in some prefix for that here and use it in buildRepartitionNode.", "author": "rodesai", "createdAt": "2020-01-14T00:25:53Z", "path": "ksql-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -286,10 +286,11 @@ private PlanNode buildSourceNode() {\n         new PlanNodeId(\"Join\"),\n         analysis.getSelectExpressions(),\n         joinInfo.get().getType(),\n-        leftSourceNode,\n-        rightSourceNode,\n-        joinInfo.get().getLeftJoinField(),\n-        joinInfo.get().getRightJoinField(),\n+        // it is always safe to build the repartition node - this operation will be\n+        // a no-op if a repartition is not required. if the source is a table, and\n+        // a repartition is needed, then an exception will be thrown\n+        buildRepartitionNode(leftSourceNode, joinInfo.get().getLeftJoinExpression()),", "originalCommit": "68496bfb6b51c601bf1889393ffcb1b60388a45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwMDQ0MA==", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366100440", "bodyText": "I'm not sure adding repartition nodes in the logical plan is the right way to go here. IMO the transformation performed by the nodes in the logical plan should correspond closely to the semantics of the corresponding transformation in the query, e.g.\nRepartitionNode implements PARTITION BY\nProjectNode implements SELECT <ITEMS>\nFilterNode implements WHERE <expr>\nI see two problems in this particular case:\n\n\nThe semantics of the repartition for the join might be different from the semantics of the repartition needed to perform a PARTITION BY. A PARTITION BY transforms the schema in a very specific way that may not make sense here. It's kind of hard to give a concrete example since we're still deciding on PARTITION BY semantics. But one example might be adding default column names for the new key columns (depending on the semantics we choose for it). If PARTITION BY semantics support adding columns in the PARTITION BY, those columns should get some generated name. But it wouldn't make sense to add those columns for the repartition done here.\n\n\nThe repartition here is really an implementation detail of the join. One place that comes to mind where this might come up down the line: we've discussed changing the join semantics to preserve the original key of the left side. The current behavior is really exposing implementation details in our query semantics. If we did that it would be awkward to have the original rekey in these repartition nodes and the post-join rekey in JoinNode", "author": "rodesai", "createdAt": "2020-01-14T00:30:55Z", "path": "ksql-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -286,10 +286,11 @@ private PlanNode buildSourceNode() {\n         new PlanNodeId(\"Join\"),\n         analysis.getSelectExpressions(),\n         joinInfo.get().getType(),\n-        leftSourceNode,\n-        rightSourceNode,\n-        joinInfo.get().getLeftJoinField(),\n-        joinInfo.get().getRightJoinField(),\n+        // it is always safe to build the repartition node - this operation will be\n+        // a no-op if a repartition is not required. if the source is a table, and\n+        // a repartition is needed, then an exception will be thrown\n+        buildRepartitionNode(leftSourceNode, joinInfo.get().getLeftJoinExpression()),\n+        buildRepartitionNode(rightSourceNode, joinInfo.get().getRightJoinExpression()),", "originalCommit": "68496bfb6b51c601bf1889393ffcb1b60388a45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ2OTI0Ng==", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366469246", "bodyText": "IMO the transformation performed by the nodes in the logical plan should correspond closely to the semantics of the corresponding transformation in the query\n\nMy knowledge on SQL theory and relational algebra is pretty minimal, but I feel that the fact that the nodes mirror the SQL statements is coincidental (a reflection of how new our codebase is) not characteristic. Most databases have a step that optimizes the logical plan independent of the physical plan so the output of the logical planner may only loosely resemble the original SQL query. Otherwise, why have the extra step to translate between the query nodes and the logical plan nodes?\nInstead, I think the logical nodes should define steps that describe the logical transformation and they should constitute the smallest reusable unit of logical work - otherwise reusing (composing) them and optimizing complex queries becomes unmanageable. The LogicalPlanner's job is to turn a SQL query into a logical plan.\n\nThe semantics of the repartition for the join might be different from the semantics of the repartition needed to perform a PARTITION BY ... If PARTITION BY semantics support adding columns in the PARTITION BY, those columns should get some generated name. But it wouldn't make sense to add those columns for the repartition done here.\n\nThis falls pretty well into my view of logical plan. In my view, if PARTITION BY supports adding columns then a single PARTITION BY should map to two logical nodes - a projection node (or a rename) and a partition node.\n\nThe repartition here is really an implementation detail of the join.\n\nI think things get a little tricky with PARTITION BY because it's the only step that spans the logical and the physical world. Really, we don't have a \"RekeyNode\" (which is perhaps a better name for the RepartitionNode) - but we have defined our Joins as only working on streams with the same key (and this a logical, not a physical, requirement).\n\nIf we did that it would be awkward to have the original rekey in these repartition nodes and the post-join rekey in JoinNode\n\nIt wouldn't be in the JoinNode - it would be yet another RepartitionNode (which, again, should probably be named RekeyNode).", "author": "agavra", "createdAt": "2020-01-14T17:20:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwMDQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwMDk2Ng==", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366100966", "bodyText": "We should just do this in SchemaKTable rather than checking the type here.", "author": "rodesai", "createdAt": "2020-01-14T00:33:10Z", "path": "ksql-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -334,6 +334,13 @@ KeyField findKeyField(final List<SelectExpression> selectExpressions) {\n       return (SchemaKStream<Struct>) this;\n     }\n \n+    if (this instanceof SchemaKTable) {", "originalCommit": "68496bfb6b51c601bf1889393ffcb1b60388a45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwMTQxMA==", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366101410", "bodyText": "nit: we should rename this type to something more specific (maybe ColumnReferenceResolver?)", "author": "rodesai", "createdAt": "2020-01-14T00:35:02Z", "path": "ksql-engine/src/main/java/io/confluent/ksql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -48,17 +55,27 @@\n     this.sourceSchemas = Objects.requireNonNull(sourceSchemas, \"sourceSchemas\");\n   }\n \n-  void analyzeExpression(final Expression expression, final boolean allowWindowMetaFields) {\n-    final Visitor visitor = new Visitor(allowWindowMetaFields);\n+  Set<ColumnRef> analyzeExpression(", "originalCommit": "68496bfb6b51c601bf1889393ffcb1b60388a45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwMTk2OQ==", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366101969", "bodyText": "You can use a TraversalExpressionVisitor here, which implements most of the traversal stuff for you", "author": "rodesai", "createdAt": "2020-01-14T00:37:25Z", "path": "ksql-engine/src/main/java/io/confluent/ksql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -48,17 +55,27 @@\n     this.sourceSchemas = Objects.requireNonNull(sourceSchemas, \"sourceSchemas\");\n   }\n \n-  void analyzeExpression(final Expression expression, final boolean allowWindowMetaFields) {\n-    final Visitor visitor = new Visitor(allowWindowMetaFields);\n+  Set<ColumnRef> analyzeExpression(\n+      final Expression expression,\n+      final boolean allowWindowMetaFields\n+  ) {\n+    final Set<ColumnRef> referencedColumns = new HashSet<>();\n+    final Visitor visitor = new Visitor(allowWindowMetaFields, referencedColumns);\n     visitor.process(expression, null);\n+    return referencedColumns;\n   }\n \n   private final class Visitor extends VisitParentExpressionVisitor<Object, Object> {", "originalCommit": "68496bfb6b51c601bf1889393ffcb1b60388a45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NjI5MQ==", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366566291", "bodyText": "nice!", "author": "agavra", "createdAt": "2020-01-14T20:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwMTk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwMjQ3OA==", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366102478", "bodyText": "If the column is not qualified, don't you need to check that it belongs to exactly one source, and include that source in the stream? If we are assuming all the columns are qualified then we should throw if the source is empty.", "author": "rodesai", "createdAt": "2020-01-14T00:39:22Z", "path": "ksql-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java", "diffHunk": "@@ -349,28 +349,66 @@ protected AstNode visitJoin(final Join node, final Void context) {\n         );\n       }\n \n-      final ColumnRef leftJoinField = getJoinFieldName(\n-          comparisonExpression,\n-          left.getAlias(),\n-          left.getDataSource().getSchema()\n-      );\n+      final Set<ColumnRef> colsUsedInLeft = new ExpressionAnalyzer(analysis.getFromSourceSchemas())\n+          .analyzeExpression(comparisonExpression.getLeft(), false);\n+      final Set<ColumnRef> colsUsedInRight = new ExpressionAnalyzer(analysis.getFromSourceSchemas())\n+          .analyzeExpression(comparisonExpression.getRight(), false);\n \n-      final ColumnRef rightJoinField = getJoinFieldName(\n-          comparisonExpression,\n-          right.getAlias(),\n-          right.getDataSource().getSchema()\n-      );\n+      final SourceName leftSourceName = getOnlySourceForJoin(\n+          comparisonExpression.getLeft(), comparisonExpression, colsUsedInLeft);\n+      final SourceName rightSourceName = getOnlySourceForJoin(\n+          comparisonExpression.getRight(), comparisonExpression, colsUsedInRight);\n+\n+      final boolean flipped = leftSourceName.equals(right.getAlias());\n+      if (!validJoin(flipped, left.getAlias(), right.getAlias(), leftSourceName, rightSourceName)) {\n+        throw new KsqlException(\n+            \"Each side of the join must reference exactly one source and not the same source. \"\n+                + \"Left side references \" + leftSourceName\n+                + \" and right references \" + rightSourceName\n+        );\n+      }\n \n       analysis.setJoin(new JoinInfo(\n-          leftJoinField,\n-          rightJoinField,\n+          flipped ? comparisonExpression.getRight() : comparisonExpression.getLeft(),\n+          flipped ? comparisonExpression.getLeft() : comparisonExpression.getRight(),\n           joinType,\n           node.getWithinExpression()\n       ));\n \n       return null;\n     }\n \n+    private boolean validJoin(\n+        final boolean flipped,\n+        final SourceName leftName,\n+        final SourceName rightName,\n+        final SourceName leftExpressionSource,\n+        final SourceName rightExpressionSource\n+    ) {\n+      final boolean validLeft = flipped || leftExpressionSource.equals(leftName);\n+      final boolean validRight = (flipped && rightExpressionSource.equals(leftName))\n+              || (!flipped && rightExpressionSource.equals(rightName));\n+      return validLeft && validRight;\n+    }\n+\n+    private SourceName getOnlySourceForJoin(\n+        final Expression exp,\n+        final ComparisonExpression join,\n+        final Set<ColumnRef> columnRefs\n+    ) {\n+      try {\n+        return columnRefs.stream()\n+            .map(ColumnRef::source)\n+            .filter(Optional::isPresent)", "originalCommit": "68496bfb6b51c601bf1889393ffcb1b60388a45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3MjExOA==", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366572118", "bodyText": "it is checked earlier that it belongs to only one source (in ExpressionAnalyzer#throwOnUnknownOrAmbiguousColumn) - I'll add a comment explaining this\nEDIT: actually, there's a possibility that they're all unambiguous but also not qualified. I'll make the ExpressionAnalyzer add the qualifier.", "author": "agavra", "createdAt": "2020-01-14T21:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwMjQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwNDMxNA==", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366104314", "bodyText": "if flipped is true, this doesn't check that the left expression source is the right data source. Maybe would be simpler to write as:\nfinal Set<SourceName> sourcesInCondition = ImmutableSet.of(leftExpressionSource, rightExpressionSource);\nreturn sourcesInCondition.contains(leftName) && sourcesInCondition.contains(rightName);", "author": "rodesai", "createdAt": "2020-01-14T00:47:27Z", "path": "ksql-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java", "diffHunk": "@@ -349,28 +349,66 @@ protected AstNode visitJoin(final Join node, final Void context) {\n         );\n       }\n \n-      final ColumnRef leftJoinField = getJoinFieldName(\n-          comparisonExpression,\n-          left.getAlias(),\n-          left.getDataSource().getSchema()\n-      );\n+      final Set<ColumnRef> colsUsedInLeft = new ExpressionAnalyzer(analysis.getFromSourceSchemas())\n+          .analyzeExpression(comparisonExpression.getLeft(), false);\n+      final Set<ColumnRef> colsUsedInRight = new ExpressionAnalyzer(analysis.getFromSourceSchemas())\n+          .analyzeExpression(comparisonExpression.getRight(), false);\n \n-      final ColumnRef rightJoinField = getJoinFieldName(\n-          comparisonExpression,\n-          right.getAlias(),\n-          right.getDataSource().getSchema()\n-      );\n+      final SourceName leftSourceName = getOnlySourceForJoin(\n+          comparisonExpression.getLeft(), comparisonExpression, colsUsedInLeft);\n+      final SourceName rightSourceName = getOnlySourceForJoin(\n+          comparisonExpression.getRight(), comparisonExpression, colsUsedInRight);\n+\n+      final boolean flipped = leftSourceName.equals(right.getAlias());\n+      if (!validJoin(flipped, left.getAlias(), right.getAlias(), leftSourceName, rightSourceName)) {\n+        throw new KsqlException(\n+            \"Each side of the join must reference exactly one source and not the same source. \"\n+                + \"Left side references \" + leftSourceName\n+                + \" and right references \" + rightSourceName\n+        );\n+      }\n \n       analysis.setJoin(new JoinInfo(\n-          leftJoinField,\n-          rightJoinField,\n+          flipped ? comparisonExpression.getRight() : comparisonExpression.getLeft(),\n+          flipped ? comparisonExpression.getLeft() : comparisonExpression.getRight(),\n           joinType,\n           node.getWithinExpression()\n       ));\n \n       return null;\n     }\n \n+    private boolean validJoin(", "originalCommit": "68496bfb6b51c601bf1889393ffcb1b60388a45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2OTcyOQ==", "url": "https://github.com/confluentinc/ksql/pull/4278#discussion_r366569729", "bodyText": "it does check because flipped is represents exactly this (flipped is true only if the left expression is the right data source) but I agree your logic is much cleaner :)", "author": "agavra", "createdAt": "2020-01-14T21:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEwNDMxNA=="}], "type": "inlineReview"}, {"oid": "164130cdfde616b4ddeccdfc5800bfc45b552d49", "url": "https://github.com/confluentinc/ksql/commit/164130cdfde616b4ddeccdfc5800bfc45b552d49", "message": "fix: rohans requested changes", "committedDate": "2020-01-14T21:36:39Z", "type": "commit"}]}