{"pr_number": 5115, "pr_title": "docs: add klip-24: key column semantics in queries.", "pr_createdAt": "2020-04-20T13:35:19Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5115", "timeline": [{"oid": "80f66e2dbe9b9ec61bd8661128a52f86c3f35180", "url": "https://github.com/confluentinc/ksql/commit/80f66e2dbe9b9ec61bd8661128a52f86c3f35180", "message": "docs: add klip-24", "committedDate": "2020-04-20T13:28:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxNDM0OQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411514349", "bodyText": "+1 I think this is a much cleaner way - I was working on aliasing for joins, and it gets very sticky (especially in the case of N-way joins). I might punt that work in favorite of this KLIP (I can implement the join part if you want, it should be pretty easy after #5081)", "author": "agavra", "createdAt": "2020-04-20T16:22:38Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,372 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+Additionally, we may want to consider dropping `I2.ID` from the result, given we know it is equal\n+to `I1.ID`. This effectively de-duplicates the data and saves on resources. Whether we do this is\n+TBD.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:", "originalCommit": "80f66e2dbe9b9ec61bd8661128a52f86c3f35180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411519191", "bodyText": "what do you think about having it so that if the user does not include the key field, they simply cannot access it? That way they don't need to explicitly specify it in the project, they just won't be able to access it otherwise.\nI think this is reasonable, as with plain SQL I wouldn't be able to access the GROUP BY field (for example) if I didn't include it in the projection (even if you CREATE TABLE AS SELECT ... GROUP BY foo)\npostgres=# CREATE TABLE input (id VARCHAR, count INTEGER);\nCREATE TABLE\npostgres=# INSERT INTO input (id, count) VALUES ('a', 1);\nINSERT 0 1\npostgres=# INSERT INTO input (id, count) VALUES ('b', 1);\nINSERT 0 1\npostgres=# CREATE TABLE agg AS SELECT SUM(count) FROM input GROUP BY id;\nSELECT 1\n--- notice that the ID column is nowhere to be found, even though it is the \"key\" for\n--- the table below\npostgres=# \\d agg\n                Table \"public.agg\"\n Column |  Type  | Collation | Nullable | Default\n--------+--------+-----------+----------+---------\n sum    | bigint |           |          |\npostgres=# SELECT * FROM agg;\n sum\n-----\n   1\n   1", "author": "agavra", "createdAt": "2020-04-20T16:29:07Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,372 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+Additionally, we may want to consider dropping `I2.ID` from the result, given we know it is equal\n+to `I1.ID`. This effectively de-duplicates the data and saves on resources. Whether we do this is\n+TBD.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.", "originalCommit": "80f66e2dbe9b9ec61bd8661128a52f86c3f35180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5MjgzNQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411592835", "bodyText": "I'm not sure I follow.\nWhat do you mean by 'can not access it'?\nI don't see a similarity between what you're doing in postgres with ksql.  In postgres the table 'agg' suerly doesn't have an ID column.  It's just a table containing the result of the query, which returns only a single column: 'sum'.", "author": "big-andy-coates", "createdAt": "2020-04-20T18:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5NzI0OA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411597248", "bodyText": "OK, so you're talking about the select, not the create table.", "author": "big-andy-coates", "createdAt": "2020-04-20T18:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwMTI4NA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411601284", "bodyText": "So... for others, @agavra proposing that we support something like:\nCREATE TABLE BAR AS SELECT COUNT(*) FROM FOO GROUP BY ID;\nWhich seems totally reasonable and something we should support! I like!\nUnder the hood we still need to track the ID key, but that's just an implementation detail.\nSELECT * FROM BAR;\nWould return only the count column.  The ID column would not be available in any downstream queries.\nThis is a good suggestion, but a much bigger change. Probably best left out of scope.\nTodo(ac): Consider including in the klip, but not implementing initially.", "author": "big-andy-coates", "createdAt": "2020-04-20T18:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcwOTkwNw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411709907", "bodyText": "The proposal is quite elegant. I had some initial concerns about downstream ramification (for example, table BAR could not be used in a join), but it seems acceptable.\nIn general, people who are used to RDBMS were often \"confused\" in the past that we enforce a PK and thus, if we can relax this restriction it might be good.\nHowever,  the proposed change would introduce some \"gap\" between what people see \"within ksqlDB\" and what is in the topic: if one uses a consumer to read the table topic, the key would still be there. It might be ok, I just want to raise awareness about it. This would also allow users to \"resurrect\" a key -- when defining a new table of the topic one can just \"re-declare\" the key in the DDL statement.", "author": "mjsax", "createdAt": "2020-04-20T21:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAzMzgzMg==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412033832", "bodyText": "Yep, agreed.\nI'm torn between including @agavra's suggestion in the KLIP, but initially not implementing it (as its a bigger change), and just covering it in rejected alternatives as possible future work.\nBasically, I'd like to avoid too much discussion on this cool / valid suggestion as I don't want it slowing down the approval of this KLIP.", "author": "big-andy-coates", "createdAt": "2020-04-21T09:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2NTY4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412165683", "bodyText": "Updated to outline this approach as a 'rejected alternative', that's rejected purely to limit scope of change.\nAlso, added #5125 to track this feature.\nHappy @agavra ?", "author": "big-andy-coates", "createdAt": "2020-04-21T13:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2NjMwNA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412166304", "bodyText": "I'm not convinced about this\nCREATE TABLE BAR AS SELECT COUNT(*) FROM FOO GROUP BY ID;\n\nIt feels like the kind of thing a user would do by mistake, and then be puzzled why they couldn't access ID. IIUC current discussion is not to actually implement this proposal yet, just maybe in the future, if that's right then I am fine to push this debate to the future :)", "author": "rmoff", "createdAt": "2020-04-21T13:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwODAyNQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412608025", "bodyText": "@rmoff -- the query you describe is supported by any RDBMS I am aware of (correct me if I am wrong)? I totally agree that the query does not make much sense, you just see a bunch of numbers (ie, the counts) but you don't know which count belongs to which ID...\nWe can argue, that we don't want to allow \"less useful\" queries like this one at all. But it is quite a \"gap\" compared to what RDBMS allow users to do. Would be very helpful to learn more from you about it? Is the current limitation of ksqlDB to always require a PK on a table a big deal? If not, maybe we can just keep it this requirement (for good reasons; if there is no PK, a table does not make much sense...)?", "author": "mjsax", "createdAt": "2020-04-22T01:45:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyNDcxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412724719", "bodyText": "I didn't realise it's supported by RDBMS. I would argue this both ways:\n\ud83d\udc49 On one hand, if they support it and it's valid SQL, I guess we should if it's easy to do\n\ud83d\udc48 On the other hand, as you say, if there is no PK, a table does not make much sense, and building this guardrail in would save users from themselves in building an object which they can't use. On an RDBMS I can imagine people building reports with some static SQL to pull back figures and dumping into a front end, i.e. I can see why people might use this shortcut. On a streaming database, it just doesn't make sense to me - and learning from the JOIN / KEY issue that plagued new users to KSQL since its inception, I'd suggest we err on the side of saving users from themselves at this stage.", "author": "rmoff", "createdAt": "2020-04-22T07:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkxNjI5NQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412916295", "bodyText": "if there is no PK, a table does not make much sense\n\nRemember, it's a MV really, not a table. It's totally valid to have an MV without a key column. (Internally, the DB might track one for implementation details).", "author": "big-andy-coates", "createdAt": "2020-04-22T11:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI1MTU3NA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r413251574", "bodyText": "IMHO, the argument also holds for a MV. If I just see a \"list of numbers\" how can I use it in my application? The result of the query only tells you how many unique IDs are there (GROUP BY ID) (ie, many many output row do I get) and what counts exists. But you don't know which count belongs to which ID. Not sure how this is useful?", "author": "mjsax", "createdAt": "2020-04-22T19:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwODU1OA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r413908558", "bodyText": "If we support lookups on things other than primary keys one day, then there are still lots of columns that can add value that aren't the key", "author": "agavra", "createdAt": "2020-04-23T15:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NDg0Ng==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414094846", "bodyText": "Not sure if I can follow? Can you elabrate?", "author": "mjsax", "createdAt": "2020-04-23T20:17:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUyNTQ4NA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411525484", "bodyText": "\ud83d\udc4e relying on order is super confusing. how often are people going to be copying keys into the value? if it's OK for it to be a little clunky, we can introduce a IDENTITY(foo) or COPY(foo) UDF that just returns the same value as the input. that way you could always do:\nCREATE TABLE OUTPUT AS SELECT ID, V0, V1, COPY(ID) AS V2 FROM INPUT\nI admit that feels like a workaround, but I don't think it's awful and it fits nicely into the existing model", "author": "agavra", "createdAt": "2020-04-20T16:37:50Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,372 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+Additionally, we may want to consider dropping `I2.ID` from the result, given we know it is equal\n+to `I1.ID`. This effectively de-duplicates the data and saves on resources. Whether we do this is\n+TBD.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+\n+### The thorn in the design's side\n+\n+Hopefully, all of the above seems simple and clear. Now for the tricky and murky bit...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+Outside of introducing some non-standard keyword into the statement, e.g.\n+\n+```sql\n+-- KEY keyword to indicate its a KEY column\n+CREATE TABLE OUTPUT AS SELECT ID AS V2 KEY, V0, V1 FROM INPUT;\n+-- resulting schema: V2 INT KEY, V0 INT, V1 INT\n+\n+-- VALUE keyword to indicate its a VALUE column\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1, ID AS V2 VALUE FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+Which are pretty yuck as its moving away from standard SQL.\n+\n+Or by adding some `WITH(KEY_COLUMNS=?)` style syntax, e.g.\n+\n+```sql\n+CREATE TABLE OUTPUT WITH(KEY_COLUMNS=[ID]) AS SELECT ID, V0, V1, ID AS V2 VALUE FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+Which is better, but still a little verbose. Also, it would be nice to not couple this KLIP to any\n+discussion about 'Should ksqlDB have `KEY` columns in the schema of CSAS statements or list them in\n+the WITH clause?'\n+\n+Aside from these, the only ways we can think of that are standard SQL would to treat the first\n+occurrence of the key column in the projection as naming the key column in the result, and any\n+subsequent copies to be value columns, (see example below). However, this reliance on the _order_\n+of columns is less than ideal. Anyone got any better ideas for a short term fix for this edge case?", "originalCommit": "80f66e2dbe9b9ec61bd8661128a52f86c3f35180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwMjU2Ng==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411602566", "bodyText": "I didn't like the ordering either!\nThe idea being that this function would mean the second ID in the projection is no longer a column reference, and therefore can not be confused with the key.\nNot really intuitive, but probably more intuitive that ordering!  Any other suggestions?", "author": "big-andy-coates", "createdAt": "2020-04-20T18:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUyNTQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMTg0MQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411721841", "bodyText": "Given that the use case does not seem to be super important, the idea of an UDF is actually quite neat IMHO. It does not seem to be worth to introduce a new non-standard keyword for this case.", "author": "mjsax", "createdAt": "2020-04-20T22:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUyNTQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAzNDg2Mw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412034863", "bodyText": "Totally with you on not wanting to rely on ordering, or new key words. Agree this will hopefully be an uncommon use case, but not one can ignore.  UDF sounds good, assuming no one else has any brighter ideas! :D", "author": "big-andy-coates", "createdAt": "2020-04-21T09:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUyNTQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3OTI4NQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412179285", "bodyText": "updated the KLIP.", "author": "big-andy-coates", "createdAt": "2020-04-21T13:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUyNTQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUyOTk3NQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411529975", "bodyText": "I don't think we should do this, it seems like other sql systems keeps the duplicate columns:\npostgres=# CREATE TABLE input (id VARCHAR, count INTEGER);\npostgres=# CREATE TABLE in2 (id VARCHAR, cost INTEGER);;\npostgres=# SELECT * FROM input JOIN in2 ON input.id = in2.id;\n id | count | id | cost\n----+-------+----+------\n a  |     1 | a  |  100", "author": "agavra", "createdAt": "2020-04-20T16:44:18Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,372 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+Additionally, we may want to consider dropping `I2.ID` from the result, given we know it is equal\n+to `I1.ID`. This effectively de-duplicates the data and saves on resources. Whether we do this is\n+TBD.", "originalCommit": "80f66e2dbe9b9ec61bd8661128a52f86c3f35180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNTgyMw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r411605823", "bodyText": "I guess the reason we know the two are equal is that we only support = on the join criteria., where as other sql systems are more flexible.\nIf we remove the other column, then we may be painting ourselves into a corner, if in the future we can support more than =.\nGood catch - I'll remove!", "author": "big-andy-coates", "createdAt": "2020-04-20T18:41:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUyOTk3NQ=="}], "type": "inlineReview"}, {"oid": "8a6151ec204168e71b088265ac97fd4f18094c5d", "url": "https://github.com/confluentinc/ksql/commit/8a6151ec204168e71b088265ac97fd4f18094c5d", "message": "chore: removal of the optional about removing the right key column", "committedDate": "2020-04-20T18:43:58Z", "type": "commit"}, {"oid": "6c769789f5b43e250a0ac6c7ac0b80bea799dfdb", "url": "https://github.com/confluentinc/ksql/commit/6c769789f5b43e250a0ac6c7ac0b80bea799dfdb", "message": "chore: update\n\nupdate with Almog's requested changes and suggestions and doc another edge case", "committedDate": "2020-04-21T13:41:15Z", "type": "commit"}, {"oid": "48273b799a6f0183adce82109a9fde3ea420eec1", "url": "https://github.com/confluentinc/ksql/commit/48273b799a6f0183adce82109a9fde3ea420eec1", "message": "add group by aliasing as possible solution", "committedDate": "2020-04-21T13:55:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1NjU2OA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412156568", "bodyText": "would this also be supported?\nCREATE TABLE OUTPUT AS SELECT (V0 + v1) AS K, COUNT() AS COUNT FROM INPUT GROUP BY K;", "author": "rmoff", "createdAt": "2020-04-21T12:51:45Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,352 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+\n+### The thorn in the design's side\n+\n+Hopefully, all of the above seems simple and clear. Now for the tricky and murky bit...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+Outside of introducing some non-standard keyword into the statement, e.g.\n+\n+```sql\n+-- KEY keyword to indicate its a KEY column\n+CREATE TABLE OUTPUT AS SELECT ID AS V2 KEY, V0, V1 FROM INPUT;\n+-- resulting schema: V2 INT KEY, V0 INT, V1 INT\n+\n+-- VALUE keyword to indicate its a VALUE column\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1, ID AS V2 VALUE FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+Which are pretty yuck as its moving away from standard SQL.\n+\n+Or by adding some `WITH(KEY_COLUMNS=?)` style syntax, e.g.\n+\n+```sql\n+CREATE TABLE OUTPUT WITH(KEY_COLUMNS=[ID]) AS SELECT ID, V0, V1, ID AS V2 VALUE FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+Which is better, but still a little verbose. Also, it would be nice to not couple this KLIP to any\n+discussion about 'Should ksqlDB have `KEY` columns in the schema of CSAS statements or list them in\n+the WITH clause?'\n+\n+Aside from these, the only ways we can think of that are standard SQL would to treat the first\n+occurrence of the key column in the projection as naming the key column in the result, and any\n+subsequent copies to be value columns, (see example below). However, this reliance on the _order_\n+of columns is less than ideal. Anyone got any better ideas for a short term fix for this edge case?\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+\n+\n+CREATE TABLE OUTPUT AS SELECT ID AS NEW_KEY, V0, V1, ID FROM INPUT;\n+-- resulting schema: NEW_KEY INT KEY, V0 INT, V1 INT, ID INT\n+```\n+\n+## What is in scope\n+\n+- Removal of implicit copying of key column,\n+  in favour of requiring key column in projection of persistent queries.\n+- Removal of non-standard GROUP BY, PARTITION BY and JOIN aliasing syntax,\n+  in favour of standard aliasing of the key column in the projection.\n+- removal of duplicate left join column on 'select *' joins.\n+- TBD: syntax for allowing user to add key column to value schema.\n+\n+## What is not in scope\n+\n+- Changes in syntax for changing the key column, e.g. allowing the projection to change the key\n+  column.  This out of scope and is only potential future work. It should be discussion separately.\n+- Replacing the use of the `KEY` keyword in CSAS statements with other syntax:\n+  this is mostly orthogonal to this change.\n+- everything else.\n+\n+## Value/Return\n+\n+Standardizing the key semantics in queries will lower the barrier for entry for users and engineers\n+alike, and reduce the support burden of explaining the subtleties. It will also simplify the code,\n+which should result in less bugs.\n+\n+Removing of the non-standard `GROUP BY`, `PARTITION BY` and `JON ON` aliasing in favour of aliasing\n+in the projection will improve out standards compliance.\n+\n+## Public APIS\n+\n+1. Persistent queries, i.e. those used in `CREATE TABLE AS`, `CREATE STREAM AS` and `INSERT INTO`\n+statements, will be required to _always_ include their key columns in their projection. An error\n+will be generated should the projection of a persistent query not include its key column. For\n+example:\n+\n+```sql\n+-- old syntax that worked:\n+CREATE TABLE OUTPUT AS SELECT COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- will now fail with an error explaining the projection must include the key column `V0`.sql\n+\n+-- corrected query:\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: V0 INT KEY, COUNT BIGINT\n+```\n+\n+2. The, as yet unreleased, non-standard `GROUP BY`, `PARTITION BY` and `JOIN ON` alias syntax will\n+be removed in favour of using the existing standard-compliant aliasing in the projection. For\n+example:\n+\n+```sql\n+-- 'any key' aliasing syntax that will be dropped:\n+CREATE TABLE OUTPUT AS SELECT COUNT() AS COUNT FROM INPUT GROUP BY (V0 + V1) AS K;\n+-- resulting schema: K INT KEY, COUNT BIGINT\n+\n+-- proposed key column aliasing in projection:\n+CREATE TABLE OUTPUT AS SELECT (V0 + v1) AS K, COUNT() AS COUNT FROM INPUT GROUP BY V0 + V1;", "originalCommit": "8a6151ec204168e71b088265ac97fd4f18094c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkxODQwOQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412918409", "bodyText": "This is actually a mistake in the KLIP - aliasing for multiple join columns will not be supported.\nAs to you're question: no it won't as the GROUP BY is applied to INPUT before the projection, hence K does not yet exist.", "author": "big-andy-coates", "createdAt": "2020-04-22T11:59:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1NjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MDg3Nw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414090877", "bodyText": "@big-andy-coates can we just swap in the expression associated with K before running the query? This will work in most SQL systems.", "author": "derekjn", "createdAt": "2020-04-23T20:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1NjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4MTczOA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r415681738", "bodyText": "What if INPUT has a column named K?  It would then be ambiguous as to which column the user was referring to in the grouping clause.\nSo... no, that doesn't work.", "author": "big-andy-coates", "createdAt": "2020-04-27T10:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1NjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkzNzU2Nw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r415937567", "bodyText": "We could just throw an ambiguous column reference error in that particular case. Here's an example of how this works in Postgres:\npostgres=# \\d test\n                Table \"public.test\"\n Column |  Type   | Collation | Nullable | Default \n--------+---------+-----------+----------+---------\n x      | integer |           |          | \n\npostgres=# select x+x as g, count(*) from test group by g;\n g  | count \n----+-------\n  4 |     2\n 10 |     2\n  6 |     2\n 14 |     2\n  2 |     2\n 16 |     2\n 12 |     2\n 20 |     2\n 18 |     2\n  8 |     2\n(10 rows)\n\nNow add a column g:\npostgres=# alter table test add column g integer;\nALTER TABLE\npostgres=# \\d test\n                Table \"public.test\"\n Column |  Type   | Collation | Nullable | Default \n--------+---------+-----------+----------+---------\n x      | integer |           |          | \n g      | integer |           |          | \n\npostgres=# select x+x as g, count(*) from test group by g;\nERROR:  column \"test.x\" must appear in the GROUP BY clause or be used in an aggregate function\nLINE 1: select x+x as g, count(*) from test group by g;", "author": "derekjn", "createdAt": "2020-04-27T15:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1NjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwOTgzNA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421009834", "bodyText": "Good to know - thanks.   So this would be out of scope for this Klip.", "author": "big-andy-coates", "createdAt": "2020-05-06T18:39:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1NjU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2MTA2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412161065", "bodyText": "I like the logic here. In the case of a SELECT * I think I1_ID would be better as it's clearer. If I2's join column was not ID then it's not immediately apparent why it's not present in the output. Not a strong preference though.", "author": "rmoff", "createdAt": "2020-04-21T12:57:48Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,352 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.", "originalCommit": "8a6151ec204168e71b088265ac97fd4f18094c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyMDUxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412920519", "bodyText": "Agreed. User can always alias it in the projection is they want.", "author": "big-andy-coates", "createdAt": "2020-04-22T12:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2MTA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2MjI0NA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412162244", "bodyText": "Can we also support the alias in the PARTITION BY?\nCREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY NEW_KEY;", "author": "rmoff", "createdAt": "2020-04-21T12:59:18Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,352 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;", "originalCommit": "8a6151ec204168e71b088265ac97fd4f18094c5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyMTcyMg==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412921722", "bodyText": "Above above for the GROUP BY example: the PARTITION BY is applied to INPUT before the projection. Hence NEW_KEY wouldn't exist and it would fail with an unknown column.", "author": "big-andy-coates", "createdAt": "2020-04-22T12:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2MjI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjA0NA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414092044", "bodyText": "Same as my previous comment. I think it would be a more intuitive UX to simply swap in the expression associated with an alias so that users can do what @rmoff asked about.", "author": "derekjn", "createdAt": "2020-04-23T20:12:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2MjI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExMDI2MQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414110261", "bodyText": "I think we don't support PARTITION BY on tables anyway? The PK does define the partitioning and we cannot just set a new PK via PARTITION BY. Hence, the example seems incorrect?", "author": "mjsax", "createdAt": "2020-04-23T20:42:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2MjI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3Mzk4NQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414673985", "bodyText": "Same as my previous comment. I think it would be a more intuitive UX to simply swap in the expression associated with an alias so that users can do what @rmoff asked about.\n\nI actually think this is counter intuitive, better this works in the same way as GROUP BY, but that's just IMHO.\nIn SQL you can't do:\nCREATE TABLE OUTPUT AS \n   SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT GROUP BY NEW_KEY;\nSo it follows you shouldn't be able to do:\nCREATE STREAM OUTPUT AS \n   SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY NEW_KEY;\nI don't think we should change this without knowing this is what users want and the ROI is there.  We'd need a KLIP for sure.", "author": "big-andy-coates", "createdAt": "2020-04-24T15:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2MjI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3NDM0MA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414674340", "bodyText": "I think we don't support PARTITION BY on tables anyway? The PK does define the partitioning and we cannot just set a new PK via PARTITION BY. Hence, the example seems incorrect?\n\nnit!  but yes, this is true, it should be a stream", "author": "big-andy-coates", "createdAt": "2020-04-24T15:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2MjI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2MzE1OQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412163159", "bodyText": "nit: s/of/have :)", "author": "rmoff", "createdAt": "2020-04-21T13:00:41Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,352 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:", "originalCommit": "8a6151ec204168e71b088265ac97fd4f18094c5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNjk5Nw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412226997", "bodyText": "I think this is ok to do.", "author": "rmoff", "createdAt": "2020-04-21T14:19:38Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,387 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+There is no reason why ksqlDB should not support creating sources in the future that do not contain\n+the key column. See the [rejected alternatives](#rejected_alternatives) section for more info.\n+\n+### Allowing the key column to be copied to the value\n+\n+Hopefully, all of the above seems simple and clear. Now for one of the more tricky and murky bits...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+We propose introducing a `COPY` function, (name TBD - maybe 'AS_VALUE'?), that can be used to\n+indicate the key column should be copied as a value column. For example,\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1, COPY(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+### Grouping by multiple expressions.\n+\n+KsqlDB supports grouping by multiple expressions, for example:\n+\n+```sql\n+SELECT V0, ABS(V1), COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+```\n+\n+However, it does not _yet_ support multiple key columns. If the above is converted to a persistent\n+query the key is generated by concatenating the string representation of the grouping expressions.\n+For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, ABS(V1) AS V1, COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+-- resulting schema: KSQL_COL_0 STRING KEY, V0 INT, V1 INT, COUNT BIGINT\n+-- where KSQL_COL_0 contains data in the form V0 + \"|+|\" + ABS(V1)\n+```\n+\n+Even though ksqlDB is currently combining the multiple grouping expressions, we propose that the\n+projection should still accept the individual columns, and recognise them as key columns. This will\n+be compatible with the upcoming multiple-key-column support.\n+\n+However, this posses a problem, as it does not provide a single place where the user can provide an\n+alias for the system generated `KSQL_COL_0` key column name. Any solution to allow providing an\n+alias would likely be incompatible with the planned multiple key column support. \n+\n+Hence, we propose leaving this edge case unsolved, i.e. users will _not_ be able to provide an alias", "originalCommit": "48273b799a6f0183adce82109a9fde3ea420eec1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzQ0Mg==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412227442", "bodyText": "since we're going to deliver multiple keys in the future, I don't see the benefit really of adding something non-standard now", "author": "rmoff", "createdAt": "2020-04-21T14:20:09Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,387 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+There is no reason why ksqlDB should not support creating sources in the future that do not contain\n+the key column. See the [rejected alternatives](#rejected_alternatives) section for more info.\n+\n+### Allowing the key column to be copied to the value\n+\n+Hopefully, all of the above seems simple and clear. Now for one of the more tricky and murky bits...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+We propose introducing a `COPY` function, (name TBD - maybe 'AS_VALUE'?), that can be used to\n+indicate the key column should be copied as a value column. For example,\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1, COPY(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+### Grouping by multiple expressions.\n+\n+KsqlDB supports grouping by multiple expressions, for example:\n+\n+```sql\n+SELECT V0, ABS(V1), COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+```\n+\n+However, it does not _yet_ support multiple key columns. If the above is converted to a persistent\n+query the key is generated by concatenating the string representation of the grouping expressions.\n+For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, ABS(V1) AS V1, COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+-- resulting schema: KSQL_COL_0 STRING KEY, V0 INT, V1 INT, COUNT BIGINT\n+-- where KSQL_COL_0 contains data in the form V0 + \"|+|\" + ABS(V1)\n+```\n+\n+Even though ksqlDB is currently combining the multiple grouping expressions, we propose that the\n+projection should still accept the individual columns, and recognise them as key columns. This will\n+be compatible with the upcoming multiple-key-column support.\n+\n+However, this posses a problem, as it does not provide a single place where the user can provide an\n+alias for the system generated `KSQL_COL_0` key column name. Any solution to allow providing an\n+alias would likely be incompatible with the planned multiple key column support. \n+\n+Hence, we propose leaving this edge case unsolved, i.e. users will _not_ be able to provide an alias\n+for the name of the key column resulting from multiple grouping expressions. This will be resolved\n+when support for multiple key columns is added.\n+\n+Alternatively, ksqlDB could support the non-strandard `GROUP BY (a, b) AS c` style aliasing, to allow", "originalCommit": "48273b799a6f0183adce82109a9fde3ea420eec1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzk3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412227972", "bodyText": "+1 for AS_VALUE, IMO COPY is too ambiguous", "author": "rmoff", "createdAt": "2020-04-21T14:20:45Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,387 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This KLIP proposes flipping this so that the key column is\n+_not_ implicitly copied across, and is therefore _required_ in persistent query projections.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Select star\n+\n+The differences with a 'select *' projection are more subtle.\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, but also adds an additional copy of the left key column.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` column in the case of the persistent query.\n+\n+We propose that the join should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column.\n+\n+Only the key column should exist and it should be called either (TBD):\n+  - `ID`, or\n+  - `I1_ID`.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE TABLE OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would of failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+There is no reason why ksqlDB should not support creating sources in the future that do not contain\n+the key column. See the [rejected alternatives](#rejected_alternatives) section for more info.\n+\n+### Allowing the key column to be copied to the value\n+\n+Hopefully, all of the above seems simple and clear. Now for one of the more tricky and murky bits...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+We propose introducing a `COPY` function, (name TBD - maybe 'AS_VALUE'?), that can be used to", "originalCommit": "48273b799a6f0183adce82109a9fde3ea420eec1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0MTYxMA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412441610", "bodyText": "Why do we need to introduce the special COPY function? With the changes in this KLIP, the key definition is inherited from the source in the FROM clause (unless we have a join, groupby or partition). Are the semantics that however many times a column (that is the key of the source) appears in the projection, every time it will be interpreted as the key? An alternative, which would be a bit more SQL like (in my mind at least) is to indicate the column that would be the primary key. So, something like:\nCREATE TABLE OUTPUT AS SELECT PRIMARY(ID) , V0, V1, ID AS V2 FROM INPUT;\n\nJust an idea though, not hung up on it. COPY gets the job done as well.", "author": "vpapavas", "createdAt": "2020-04-21T19:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1OTA2OA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412859068", "bodyText": "@big-andy-coates what would happen with the following query?\nCREATE TABLE OUTPUT (ID INT PRIMARY KEY, V0 INT, V1 INT, V2 INT) AS\n  SELECT ID, V0, V1, ID AS V2 FROM INPUT\nwould it work without the COPY function?\nI think the correct way to handle your query is having no key at all (which may be rejected until #5125 is done) unless a key is explicitly specified in the schema, like in the query I gave.\nSince partial schemas are already a thing in ksqlDB (#4566) a key could be set like this:\nCREATE TABLE OUTPUT (ID PRIMARY KEY) AS SELECT ID, V0, V1, ID AS V2 FROM INPUT\nwhich looks quite similar to the one @vpapavas proposed.\nThis also works with composite keys in the future:\nCREATE TABLE OUTPUT (PRIMARY KEY (ID, V1)) AS SELECT ID, V0, V1, ID AS V2 FROM INPUT\nwhat do you think?", "author": "PeterLindner", "createdAt": "2020-04-22T10:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyODAzNA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412928034", "bodyText": "@vpapavas\n\nWhy do we need to introduce the special COPY function?\n\nTo provide a way for the user to add a copy of the key column as a value column.\n\nWith the changes in this KLIP, the key definition is inherited from the source in the FROM clause (unless we have a join, groupby or partition).\n\nConfused... the current behaviour is to inherit the key columns. The KLIP proposes removing this inheritance!  Not sure why you seem to think the KLIP is proposing key column inheritance...?\n\nAre the semantics that however many times a column (that is the key of the source) appears in the projection, every time it will be interpreted as the key?\n\nWe only support a single key column at the moment, so no.  The issue is about allowing the user to copy the key into the value.\n\nAn alternative, which would be a bit more SQL like (in my mind at least) is to indicate the column that would be the primary key. So, something like:\nCREATE TABLE OUTPUT AS SELECT PRIMARY(ID) , V0, V1, ID AS V2 FROM INPUT;\n\nJust an idea though, not hung up on it. COPY gets the job done as well.\n\nAgreed this would work. However, it would logically follow that you should always need PRIMARY around the key column, which is a bit ugly.  Also, what about streams that don't have primary keys?\nIMHO, the nice thing about COPY is that its only needed if you want to copy a key column into the value: i.e. there's no extra syntax for doing normal/easy things, only for doing more uncommon things.", "author": "big-andy-coates", "createdAt": "2020-04-22T12:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkzMzE5Nw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r412933197", "bodyText": "@big-andy-coates what would happen with the following query?\nCREATE TABLE OUTPUT (ID INT PRIMARY KEY, V0 INT, V1 INT, V2 INT) AS\n  SELECT ID, V0, V1, ID AS V2 FROM INPUT\nwould it work without the COPY function?\nI think the correct way to handle your query is having no key at all (which may be rejected until #5125 is done) unless a key is explicitly specified in the schema, like in the query I gave.\nSince partial schemas are already a thing in ksqlDB (#4566) a key could be set like this:\nCREATE TABLE OUTPUT (ID PRIMARY KEY) AS SELECT ID, V0, V1, ID AS V2 FROM INPUT\nwhich looks quite similar to the one @vpapavas proposed.\nThis also works with composite keys in the future:\nCREATE TABLE OUTPUT (PRIMARY KEY (ID, V1)) AS SELECT ID, V0, V1, ID AS V2 FROM INPUT\nwhat do you think?\n\nHey @PeterLindner, that's an interesting idea!\nI'm not sure I agree the table should default to no primary key. That would mean more verbose syntax for the common case. (Plus, requiring KSQL to support key-less table MVs). Though, I guess its strictly more standard SQL as a RDBS wouldn't create OUTPUT with a primary key by default (well, I don't think it would - I'd need to check and sqlfiddle.com is down ;) ).\nHowever, this may be a better syntax for handling the edgecase where the user wants to put a copy of the key column in the value, e.g.\nCREATE TABLE OUTPUT (ID PRIMARY KEY) AS SELECT ID, V0, V1, ID AS V2 FROM INPUT\n-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n\nCREATE STREAM OUTPUT (ID KEY) AS SELECT ID, V0, V1, ID AS V2 FROM INPUT\n-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\nThe main downside of this approach is that it's more syntax / more work.\nThoughts others? @derekjn @rmoff @agavra @mjsax etc?", "author": "big-andy-coates", "createdAt": "2020-04-22T12:22:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4NzM5Ng==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r413087396", "bodyText": "Just realized I forgot the type in the partial schema... instead of defining the type as well like:\nCREATE TABLE OUTPUT (\nID INT PRIMARY KEY\n-- V0 INT omitted\n-- V1 INT omitted\n-- V2 INT omitted\n) ... \nThe following partial schema may be more intuitive:\nCREATE TABLE OUTPUT (\n-- ID INT omitted\n-- V0 INT omitted \n-- V1 INT omitted \n-- V2 INT omitted \nPRIMARY KEY (ID) \n) ... \nAnd analogous KEY (ID) for streams.\nFurthermore I realized that people may try to repartition a table with this syntax like:\nCREATE TABLE (PRIMARY KEY (V0)) AS SELECT ... \n-- expecting schema: V0 INT KEY, ID INT, V1 INT, V2 INT\ndon't know if that's a problem", "author": "PeterLindner", "createdAt": "2020-04-22T15:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM0NzM0MQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r413347341", "bodyText": "Interesting idea. I am not sure though if this would work? I think in SQL, a CRATE TABLE output <schema> AS SELECT requires that the result schema of the query it compatible to the schema definition, and thus the schema definition does not modify the query result/schema (what make a lot of sense to me; for example if you specify a PK constraint and the query result would violate the PK constraint the query would fail and the table would not even be created). The query semantics must be defined by the query itself, and must be the same w/ or w/o a preceding CT clause.\nTo me, it seems that the proposal tried to put the cart before the horse.", "author": "mjsax", "createdAt": "2020-04-22T21:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU3NzkzNw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r413577937", "bodyText": "@mjsax this means the select would need a PARTITION BY to be compatible with the schema in the first place? That sounds logical...\nWould it make sense to allow to PARTITION BY an already existing key for a table? That's either redundant or solves the edge case", "author": "PeterLindner", "createdAt": "2020-04-23T07:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwODgyMA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414108820", "bodyText": "Atm, we consider it redundant that thus don't even allow PARTITION BY for tables (If one does a GROUP BY a it's implicitly partitioned by a). It's only allowed for streams as there, it won't really change the schema (there is no PK) but only change the \"schema to kv mapping\" and thus the partitioning.", "author": "mjsax", "createdAt": "2020-04-23T20:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3NjkzMQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414676931", "bodyText": "This is a great discussion and I like the syntax. However, for the scope of this KLIP I'm going to go with a slightly more hack solution for the short to mid term. Otherwise, this grows to large!  Really appreciate your input @PeterLindner, as always.", "author": "big-andy-coates", "createdAt": "2020-04-24T15:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MDUxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r415070519", "bodyText": "@big-andy-coates I'm glad my random ideas are appreciated \ud83d\ude04\nI also found this MySQL doc for CREATE TABLE ... SELECT which technically is not the same because it does not create a materialized view but may help if you decide to work on the syntax later", "author": "PeterLindner", "createdAt": "2020-04-25T14:10:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIyNzk3Mg=="}], "type": "inlineReview"}, {"oid": "b02b6548b0a5e8a259608d43a0c4a535f3152f40", "url": "https://github.com/confluentinc/ksql/commit/b02b6548b0a5e8a259608d43a0c4a535f3152f40", "message": "remove incorrect use of aliasing on multi-column grouping", "committedDate": "2020-04-22T12:00:59Z", "type": "commit"}, {"oid": "da2ec54ed43189c78abf9e300a14dd8ec943bfcc", "url": "https://github.com/confluentinc/ksql/commit/da2ec54ed43189c78abf9e300a14dd8ec943bfcc", "message": "chore: it's so unfair.", "committedDate": "2020-04-22T12:06:08Z", "type": "commit"}, {"oid": "1bbd95e5ae5d91e2af332fe78b82fa91edc19e5a", "url": "https://github.com/confluentinc/ksql/commit/1bbd95e5ae5d91e2af332fe78b82fa91edc19e5a", "message": "chore: add outer join edge case", "committedDate": "2020-04-23T10:12:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMTg0OQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r413901849", "bodyText": "also, how would we handle expressions?", "author": "agavra", "createdAt": "2020-04-23T15:35:03Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -385,3 +450,56 @@ in downstream queries.\n This was rejected for this KLIP as it would involve considerably more work. This may be picked up in\n a future KLIP.\n \n+### Storing all join columns in the key of the result\n+\n+A more correct solution for handling columns within a join may look to store all join columns in the\n+Kafka record's key, for example:\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: I1_ID INT KEY, I2_ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note that both `I1_ID` and `I2_ID` are marked as key columns. Such an approach may be required if\n+ksqlDB is to support join criterion other than the current equality.\n+\n+However, this is rejected as a solution for now for the following reasons:\n+  a. Such a solution requires ksqlDB to support multiple key columns. It currently does not, and this\n+     KLIP is part of the work moving towards such support. Hence its a chicken and egg problem.\n+  b. Such a solution requires Streams to be able to correctly handle the multiple key columns\n+     correctly, which it currently does not.  This is particularly challenging for outer joins,\n+     where some key columns may initially be `null` and later populated. Any solution needs to ensure\n+     correct partitioning and update semantics for such rows.\n+\n+### System generated naming for the synthesised join column\n+\n+Where a join introduces a synthesised key column the column would have a system generated name.\n+Two naming strategies were rejected:\n+\n+#### `KSQL_COL_x`\n+\n+The synthesised column would take on a generated name in the form `KSQL_COL_x`, where `x` is an\n+integer and the name is guaranteed to be unique, i.e. to not clash with any other system generated\n+column names.\n+\n+This was rejected as the name would be hard for the user to know by looking at the query, i.e. the\n+presence of other columns with generated names may affect the name of the synthesised column. This\n+was deemed to make this solution unworkable.\n+\n+#### Data driven naming\n+\n+The synthesised column would take on a name generated from the join criteria. For example, a join\n+such as `A JOIN B ON A.ID = B.ID` would result in a key column named `A_ID__B_ID`.\n+\n+While this is deterministic and offers improved protection against column name clashes than a static\n+naming strategy, it was rejected as:\n+  a. it adds additional complexity to the code\n+  b. it adds additional cognitive load for users, i.e. the need to know the naming strategy and work\n+     out the name from the criteria.\n+  c. a change in the join criteria requires a change in the projection.\n+  d. name clashes are still possible.", "originalCommit": "1bbd95e5ae5d91e2af332fe78b82fa91edc19e5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3MTI0Mg==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414671242", "bodyText": "That too ;)", "author": "big-andy-coates", "createdAt": "2020-04-24T15:37:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMTg0OQ=="}], "type": "inlineReview"}, {"oid": "1599a97399fb1dc49ae084d0a967c434d2a3b504", "url": "https://github.com/confluentinc/ksql/commit/1599a97399fb1dc49ae084d0a967c434d2a3b504", "message": "Update klip-24-key-column-semantics-in-queries.md", "committedDate": "2020-04-24T15:37:52Z", "type": "commit"}, {"oid": "772ccf884819c2150f473f1ce58e61967a5bf2df", "url": "https://github.com/confluentinc/ksql/commit/772ccf884819c2150f473f1ce58e61967a5bf2df", "message": "Update klip-24-key-column-semantics-in-queries.md", "committedDate": "2020-04-24T15:43:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwMTYwNA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414701604", "bodyText": "nit: the the", "author": "mjsax", "createdAt": "2020-04-24T16:22:12Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the", "originalCommit": "772ccf884819c2150f473f1ce58e61967a5bf2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4MTM2MA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r415681360", "bodyText": "done", "author": "big-andy-coates", "createdAt": "2020-04-27T10:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwMTYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNjI3MA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414706270", "bodyText": "This is allowed? How is this implemented? It's unclear to me how it's compiled down correctly to a Kafka Streams program?", "author": "mjsax", "createdAt": "2020-04-24T16:29:38Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;", "originalCommit": "772ccf884819c2150f473f1ce58e61967a5bf2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4Nzc4OQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r415087789", "bodyText": "This is already supported. It just compiles down as a repartition.", "author": "big-andy-coates", "createdAt": "2020-04-25T15:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNjI3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEwMDIwMA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416100200", "bodyText": "Well. That's non-deterministic than...", "author": "mjsax", "createdAt": "2020-04-27T19:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNjI3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5MDU5NA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r420990594", "bodyText": "yup", "author": "big-andy-coates", "createdAt": "2020-05-06T18:07:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNjI3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5NjQ2OQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r420996469", "bodyText": "Thanks for clarifying.", "author": "mjsax", "createdAt": "2020-05-06T18:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNjI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwODA4NA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414708084", "bodyText": "nit: ROwKEY -> ROWKEY", "author": "mjsax", "createdAt": "2020-04-24T16:32:31Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+For both of the above joins the data stored in the Kafka record's key by ksqlDB / Streams does\n+not correspond to any column within either source. This is problematic.\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own. This precludes the user of a system generated name such as\n+`KSQL_COL_0`.\n+\n+Though not ideal, we propose that in the short term the synthesised column will be named `ROWKEY`,\n+as this is a name users are already familiar with. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 INT FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Requiring the user to include a synthesised column in the projection is not idea. However, we\n+propose this is best short term solution given the current functionality.\n+\n+Key to this solution is the ability for users to provide their own name for the synthesised key\n+column. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ROWKEY AS ID, I1.V0, I1.V1, I2.V0, I2.V1 INT FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+A more correct implementation might store both sides of the join criteria in the key for all join\n+types. However, such an approach would require support for multiple key columns and extensive\n+changes in Streams. See [rejected alternatives](#rejected_alternatives) for more info.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE STREAM OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT", "originalCommit": "772ccf884819c2150f473f1ce58e61967a5bf2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA4Nzg0Mw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r415087843", "bodyText": "lol. Super nit! - SQL is case insensitive by default :p", "author": "big-andy-coates", "createdAt": "2020-04-25T15:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwODA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwOTM4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414709383", "bodyText": "I guess, only the first query should work. After this KIP is merged, the second query should have a column called ROWKEY and thus should fail?", "author": "mjsax", "createdAt": "2020-04-24T16:34:34Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+For both of the above joins the data stored in the Kafka record's key by ksqlDB / Streams does\n+not correspond to any column within either source. This is problematic.\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own. This precludes the user of a system generated name such as\n+`KSQL_COL_0`.\n+\n+Though not ideal, we propose that in the short term the synthesised column will be named `ROWKEY`,\n+as this is a name users are already familiar with. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 INT FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Requiring the user to include a synthesised column in the projection is not idea. However, we\n+propose this is best short term solution given the current functionality.\n+\n+Key to this solution is the ability for users to provide their own name for the synthesised key\n+column. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ROWKEY AS ID, I1.V0, I1.V1, I2.V0, I2.V1 INT FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+A more correct implementation might store both sides of the join criteria in the key for all join\n+types. However, such an approach would require support for multiple key columns and extensive\n+changes in Streams. See [rejected alternatives](#rejected_alternatives) for more info.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE STREAM OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would have failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate", "originalCommit": "772ccf884819c2150f473f1ce58e61967a5bf2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4MTUwMA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r415681500", "bodyText": "clarified.", "author": "big-andy-coates", "createdAt": "2020-04-27T10:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwOTM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMzAzOQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414713039", "bodyText": "Personally, I don't buy this argument. The result of a query that returns a table changelog stream (even if it's a stream) should contain the PK IMHO and should be mandatory to have the PK in the SELECT clause... (the EMIT CHANGE should really just be an \"addendum\" to the query without altering what is allowed or not allowed). This difference in behavior is rather confusion and also does not allow to use those push queries (ie, that remove the PK) directly as persistent CT query, but require a rewrite. IMHO, it would be better to align the semantics.", "author": "mjsax", "createdAt": "2020-04-24T16:40:19Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+For both of the above joins the data stored in the Kafka record's key by ksqlDB / Streams does\n+not correspond to any column within either source. This is problematic.\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own. This precludes the user of a system generated name such as\n+`KSQL_COL_0`.\n+\n+Though not ideal, we propose that in the short term the synthesised column will be named `ROWKEY`,\n+as this is a name users are already familiar with. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 INT FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Requiring the user to include a synthesised column in the projection is not idea. However, we\n+propose this is best short term solution given the current functionality.\n+\n+Key to this solution is the ability for users to provide their own name for the synthesised key\n+column. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ROWKEY AS ID, I1.V0, I1.V1, I2.V0, I2.V1 INT FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+A more correct implementation might store both sides of the join criteria in the key for all join\n+types. However, such an approach would require support for multiple key columns and extensive\n+changes in Streams. See [rejected alternatives](#rejected_alternatives) for more info.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE STREAM OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would have failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a", "originalCommit": "772ccf884819c2150f473f1ce58e61967a5bf2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5MDUxNA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r415690514", "bodyText": "I can see your point of view. A push query of a table without the PK wouldn't be of much use, as the consumer of the data would never know if a specific row was an insert, update or a delete.\nThe same is not true of a push query of a stream, where, as you know, the key does not infer any insert/update/delete semantics.\nHowever, push queries are used by humans as much as by machines.  In the CLI a user may just want to see the data they're interested in scrolling across the screen.  They maybe only interested in a single column. Maybe they're looking for a certain value or pattern, or who knows what.  But the point is, I don't see any benefit from forcing a user to select the PK column(s) if they don't want them cluttering their screen.\nSo I'm afraid I'm against forcing PKs into transient query projections.\ncc @derekjn for a product view.", "author": "big-andy-coates", "createdAt": "2020-04-27T10:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMzAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEwNDM0MA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416104340", "bodyText": "The same is not true of a push query of a stream, where, as you know, the key does not infer any insert/update/delete semantics.\n\nSure. But as you know, I personally find our current query categorization confusing and not helpful, and applying a \"rule\" to a query that returns a fact stream to a query that returns a changelog stream, because both a in the same category of \"push queries\", is not a good argument IMHO.", "author": "mjsax", "createdAt": "2020-04-27T19:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMzAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2ODYwMg==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r420968602", "bodyText": "That's not really my argument :p\nI'm saying we should let users select whatever they want in the CLI and via other means.  If they don't want the key, that's their business, not ours.", "author": "big-andy-coates", "createdAt": "2020-05-06T17:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMzAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE0OTQ1MQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421149451", "bodyText": "I am most worried about consistency:\nCurrently, the following is supported:\n// transient\nSELECT count(foo) FROM stream GROUP BY bar EMIT CHANGES;\n// persistent\nCREATE TABLE table AS SELECT count(foo) FROM GROUP BY bar;\nNote, that the actual query SELECT count(foo) FROM stream GROUP BY bar is exactly the same for both cases.  This allows to deploy a transient query without any change as a persistent query.\nWith your proposal, the following inconsistency arrises:\n// transient\nSELECT count(foo) FROM stream GROUP BY bar EMIT CHANGES;\n// fails -> PK missing\nCREATE TABLE table AS SELECT count(foo) FROM GROUP BY bar;\n\n// need to rewrite the query and add the PK `bar` to make it work\nCREATE TABLE table AS SELECT bar, count(foo) FROM GROUP BY bar;\nThis seems to be issue with regard to UX, because transient queries and persistent queries would now support \"different SQL\".\nHence, if we require the PK in the transient query, we not only guide users away from writing \"non-sense\" (ie, not really useful) queries, but also avoid this inconsistency:\n// transient -> fails\nSELECT count(foo) FROM stream GROUP BY bar EMIT CHANGES;\n// persistent -> fails\nCREATE TABLE table AS SELECT count(foo) FROM GROUP BY bar;\n\n// work both\n// transient\nSELECT bar, count(foo) FROM stream GROUP BY bar EMIT CHANGES;\n// persistent\nCREATE TABLE table AS SELECT bar, count(foo) FROM GROUP BY bar;", "author": "mjsax", "createdAt": "2020-05-06T23:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMzAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1MDIxNA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421150214", "bodyText": "However, push queries are used by humans as much as by machines.\n\nI think it's important to consider one of the most common contexts within which humans use  transient push queries: iterating on queries before creating them as persistent queries. For this reason, I'm in favor of requiring the PK for push queries. Being able to take a push query (verbatim) and turn it into a persistent query is pretty important from a UX perspective IMO.\nI totally understand the reasoning behind not requiring a PK for transient queries, but personally I just don't feel that it would offset the downside of the aforementioned UX inconsistency. I think that predictability and consistency are more important than elegance in this case.", "author": "derekjn", "createdAt": "2020-05-06T23:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMzAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyMzY1MA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421323650", "bodyText": "IMHO this is total madness.  This is assuming that every human using push queries is doing so to build a persistent query. Where does such an assumption come from?\nConsider yourself working with a traditional db system.  You're selecting some data from a table, which has a primary key.  For whatever reason, you're interested seeing only some of the columns, and that doesn't include the primary key columns.  Does the db stop you doing this? Of course not!\nCan you imagine:\n-- Given table K1, K2, K3 => V0, V1, V2\n\n-- I just want to see column V0:\nSELECT V0 FROM S;\n-- ERROR: Computer says no; you need to include K1, K2, K3 in your projection, even though you're not interested in them.\nMadness!\nWould I want to use such a system? No!\nAlso, what about a query such as:\n-- how many rows have a non-null V1?\nSELECT COUNT(V1) FROM S;\nThis is valid SQL... and useful. Sure, this doesn't work at the moment in ksql, but it's a requested feature.  The result doesn't even have a key to include!\nMy point is there are valid, useful, (push) queries that users will want to run that don't return data with a primary key.  Obviously, such queries can't be converted into a persistent query that builds a MV/table, as such MVs currently require a primary key.  But doesn't mean we shouldn't allow the user to execute them.\nI strongly disagree that any and every push query must be convertible into a persistent query, (while we require MVs to have a primary key).\nIf the user is building a push query that they want to convert into a persistent table query, then they will get a helpful error message when they do convert it if they don't have the key column included.  This is a much better UX in my opinion than stopping the user from doing what they want to do just because they won't be able to convert their query into a persistent query, which they may have no intention of doing.", "author": "big-andy-coates", "createdAt": "2020-05-07T08:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMzAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM0MDg2Mg==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421340862", "bodyText": "Another example:\nSELECT COUNT(*) FROM S GROUP BY 1;\nThis is valid right now and will return the number of rows in the table, of the number of rows in the changelog.  Are we saying this should fail, because the key is not in the projection? We'd require them to do what?\nSELECT 1, COUNT(*) FROM S GROUP BY 1;\nWhy????", "author": "big-andy-coates", "createdAt": "2020-05-07T08:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMzAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU2NjI5NQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421566295", "bodyText": "I think the different mind set really comes from \"pull\" vs \"push\" queries. For \"pull\" queries, what you say is more acceptable. However, for \"push\" queries, as you receive multiple records per row, without the key column you cannot make any sense out of it. What doos\nSELECT COUNT(foo) FROM S GROUP BY bar EMIT CHANGE;\ngive you? If you get two updated 3, 5 you don't know if there are 2 rows with value 3 and 5 respectively, or if there is one row that was updated from 3 to 5.\nFor a pull query it would of course be different: a table with two rows would return 3 and 5 (what might still be useful even if you don't know the PK of each key) while a table with only one row would either return 3 (if you query before the update) or 5 (if you query after the update).\nAnd I also believe, the the lions shares of push queries is during development to figure out the right persistent query one wants to delpoy.", "author": "mjsax", "createdAt": "2020-05-07T14:50:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMzAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYwMjU5Nw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421602597", "bodyText": "After much discussion, this will be fixed by: #5303", "author": "big-andy-coates", "createdAt": "2020-05-07T15:39:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMzAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYxNzcyNQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421617725", "bodyText": "In the end it's subjective which one is better/worse. Flexibility vs consistency.\nAs this KLIP is about persistent queries it seem ok to not change transient queries for now.", "author": "mjsax", "createdAt": "2020-05-07T16:00:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMzAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxNjA5Nw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r414716097", "bodyText": "As the proposal is to use ROWKEY column for outer joins, it seems the same pattern could be applied for this case to allow people to rename the PK?", "author": "mjsax", "createdAt": "2020-04-24T16:45:16Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+For both of the above joins the data stored in the Kafka record's key by ksqlDB / Streams does\n+not correspond to any column within either source. This is problematic.\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own. This precludes the user of a system generated name such as\n+`KSQL_COL_0`.\n+\n+Though not ideal, we propose that in the short term the synthesised column will be named `ROWKEY`,\n+as this is a name users are already familiar with. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 INT FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Requiring the user to include a synthesised column in the projection is not idea. However, we\n+propose this is best short term solution given the current functionality.\n+\n+Key to this solution is the ability for users to provide their own name for the synthesised key\n+column. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ROWKEY AS ID, I1.V0, I1.V1, I2.V0, I2.V1 INT FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+A more correct implementation might store both sides of the join criteria in the key for all join\n+types. However, such an approach would require support for multiple key columns and extensive\n+changes in Streams. See [rejected alternatives](#rejected_alternatives) for more info.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE STREAM OUTPUT AS SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE STREAM OUTPUT AS SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROwKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+CREATE TABLE OUTPUT AS SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+\n+-- Note: the equivalent query would have failed before the any-key-name work:\n+CREATE TABLE OUTPUT AS SELECT ROWKEY, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'ROWKEY'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that this query should work, without any modification, and without storing duplicate\n+data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+There is no reason why ksqlDB should not support creating sources in the future that do not contain\n+the key column. See the [rejected alternatives](#rejected_alternatives) section for more info.\n+\n+### Allowing the key column to be copied to the value\n+\n+Hopefully, all of the above seems simple and clear. Now for one of the more tricky and murky bits...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+We propose introducing a `AS_VALUE` function that can be used to\n+indicate the key column should be copied as a value column. For example,\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1, AS_VALUE(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+### Grouping by multiple expressions.\n+\n+KsqlDB supports grouping by multiple expressions, for example:\n+\n+```sql\n+SELECT V0, ABS(V1), COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+```\n+\n+However, it does not _yet_ support multiple key columns. If the above is converted to a persistent\n+query the key is generated by concatenating the string representation of the grouping expressions.\n+For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS SELECT V0, ABS(V1) AS V1, COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+-- resulting schema: KSQL_COL_0 STRING KEY, V0 INT, V1 INT, COUNT BIGINT\n+-- where KSQL_COL_0 contains data in the form V0 + \"|+|\" + ABS(V1)\n+```\n+\n+Even though ksqlDB is currently combining the multiple grouping expressions, we propose that the\n+projection should still accept the individual columns, and recognise them as key columns. This will\n+be compatible with the upcoming multiple-key-column support.\n+\n+However, this posses a problem, as it does not provide a single place where the user can provide an\n+alias for the system generated `KSQL_COL_0` key column name. Any solution to allow providing an\n+alias would likely be incompatible with the planned multiple key column support. \n+\n+Hence, we propose leaving this edge case unsolved, i.e. users will _not_ be able to provide an alias", "originalCommit": "772ccf884819c2150f473f1ce58e61967a5bf2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwMTA1MQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r415701051", "bodyText": "Hummmm.... you've got a point.\nHowever, I think there's a subtle difference we may want to consider.\nWith a grouping statement on multiple things, the current implementation combines all the result columns into a single STRING value.  So the Kafka message's key contains all the grouping data, just in a nasty format.  No additional column is being synthesised.\nConversely, for outer joins the Kafka message's key contains the result of COALESCE(leftJoinExp, rightJoinExp), i.e. unlike the grouping statement, it does NOT contain all the joining data: it loses the data about any side being null.\nBecause of this subtle difference we know that the upcoming structured keys work will allow users to alias the multiple grouping expressions in the projection. However, the issue with joins can not be fixed with structured key support alone.\nIf we go the same route for groupings as we've proposed for joins, then we end up with:\nCREATE TABLE OUTPUT AS\n   SELECT ROWKEY AS K, COUNT() FROM INPUT GROUP BY V0, V1;\n\n-- vs --\n\nCREATE TABLE OUTPUT AS\n   SELECT V0, V1, COUNT() FROM INPUT GROUP BY V0, V1;\nThere's certainly arguments for going either way. Personally, I'm happy with what's been proposed for groupings in the KLIP.\ncc @derekjn for a product view.", "author": "big-andy-coates", "createdAt": "2020-04-27T10:36:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxNjA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyODcwMw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416128703", "bodyText": "I guess we agree that the end-state should be the last query you showed:\nCREATE TABLE OUTPUT AS\n   SELECT V0, V1, COUNT() FROM INPUT GROUP BY V0, V1;\n(With a proper structured key <V0,V1> stored in the message key).\nI guess the question is what intermediate state we want to be in. The query from above is a valid query now however, it does not really expose the PK that is stored in the ROWKEY.\nFrom the KLIP:\n\nwe propose that the projection should still accept the individual columns, and recognise them as key columns\n\nNot sure if I can follow. If both columns V0 and V1 are store in the value, how can this be done?\nAs this KLIP seems to try to expose the actual message key in the schema, it seems consequent to add ROWKEY for this case as an intermediate step. I understand, that it might look like a step backward for a language POV as the above query that is valid now, would not be valid until we reach the end-state and it becomes valid again...", "author": "mjsax", "createdAt": "2020-04-27T20:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxNjA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk3MTM5MQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r420971391", "bodyText": "To be clear the KLIP is proposing that the following will be valid even before structured keys:\nCREATE TABLE OUTPUT AS\n   SELECT V0, V1, COUNT() FROM INPUT GROUP BY V0, V1;\nAnd both V0 and V1 will be stored in the key in a munged together column called KSQL_COL_0,  not in the value.\nYes, we could support:\nCREATE TABLE OUTPUT AS\n   SELECT KSQL_COL_0, COUNT() FROM INPUT GROUP BY V0, V1;\nBut sures will be left wondering where KSQL_COL_0 came from.\nGiven than we're adding support for multiple key columns next, product are happy with not supporting aliasing of the resulting key column name.", "author": "big-andy-coates", "createdAt": "2020-05-06T17:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxNjA5Nw=="}], "type": "inlineReview"}, {"oid": "a337830a29425a76f5469901fe34b6a825b18361", "url": "https://github.com/confluentinc/ksql/commit/a337830a29425a76f5469901fe34b6a825b18361", "message": "chore: updated with mjsax's requested changes", "committedDate": "2020-04-27T10:38:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwNjU2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r415706565", "bodyText": "I'm still not convinced about the use of ROWKEY for the synthesised column in some joins. I'm currently coding this up and will play around to see what works best.\nOne concern with ROWKEY is that a lot of existing users will have sources with a ROWKEY key column, meaning there'll be a column clash, which is nasty.\nAlternatives are:\n\na new reserved JOINKEY column name.\nsystem generated KSQL_COL_x style name.\na special UDF that resolves to the new synthesised column, e.g.\n\nCREATE TABLE OUTPUT AS\n   SELECT JOINKEY(S1.ID, S2.ID), S1.V0, S2.V1 \n      FROM SI FULL OUTER JOIN S2 ON S1.ID = S2.ID;\n-- resulting schema: KSQL_COL_0 INT KEY, S1_V0 INT, S2_V1\n\n-- or with an alias:\n\nCREATE TABLE OUTPUT AS\n   SELECT JOINKEY(S1.ID, S2.ID) AS ID, S1.V0, S2.V1 \n      FROM SI FULL OUTER JOIN S2 ON S1.ID = S2.ID;\n-- resulting schema: ID INT KEY, S1_V0 INT, S2_V1\nI'm actually leaning to the JOINKEY() UDF as it allows for better validation than a synthesised column.\ncc @derekjn, @agavra @mjsax : any issue with the JOINKEY() UDF?", "author": "big-andy-coates", "createdAt": "2020-04-27T10:45:27Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,506 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = I2.ID;\n+\n+-- full outer join:\n+CREATE TABLE OUTPUT AS SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+For both of the above joins the data stored in the Kafka record's key by ksqlDB / Streams does\n+not correspond to any column within either source. This is problematic.\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own. This precludes the user of a system generated name such as\n+`KSQL_COL_0`.\n+\n+Though not ideal, we propose that in the short term the synthesised column will be named `ROWKEY`,\n+as this is a name users are already familiar with. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:", "originalCommit": "772ccf884819c2150f473f1ce58e61967a5bf2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg2Nzg5NQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r415867895", "bodyText": "I've concluded my investigation into this and the easiest solution to implement, and the one that avoids nasty edge cases, is the JOINKEY() udf.\nI've updated the KLIP to reflect this, and moved ROWKEY to the rejected alternatives section, along with more information about why the alternatives were rejected.", "author": "big-andy-coates", "createdAt": "2020-04-27T14:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwNjU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE0NTgyMw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416145823", "bodyText": "I am not particular happy to require users to call an UDF to make the query work... That seems even worse than requiring them to include the PK column in the SELECT clause.\nI understand the motivation (ie, the complexity to use ROWKEY or similar rejected alternatives); however, I am a little worried about the user experience. To what extend do we need to carry the burden and to what extend can/shall we put it into the users?", "author": "mjsax", "createdAt": "2020-04-27T21:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwNjU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5NDc5NA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r420994794", "bodyText": "Though I agree this is not ideal, I can't think of a workable alternative in the short term.\nDeadlines being what they are, this code is already implemented and merged.  Though not documented yet.  Can we agree this is not ideal, but can always be improved in a later KLIP", "author": "big-andy-coates", "createdAt": "2020-05-06T18:14:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwNjU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODEyNA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421198124", "bodyText": "this code is already implemented and merged\n\nand merged -- the KLIP is not finalized yet? Interesting \"process\".", "author": "mjsax", "createdAt": "2020-05-07T02:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwNjU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxMzEwMw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421313103", "bodyText": "Lol, indeed.\nBeen thinking on this. Totally agree JOINKEY is horrible. My plan is to get everything else merged and turn on, and WITH(KEY) removed. This will massively simplify the code.  With that done, I can spend some time to see how things fall out if we remove the requirement for JOINKEY, but allow JOINKEY is the user wants, e.g. to define an alias.", "author": "big-andy-coates", "createdAt": "2020-05-07T08:00:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwNjU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYxNjgwMw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421616803", "bodyText": "Well. Leave it up to you.", "author": "mjsax", "createdAt": "2020-05-07T15:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwNjU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYxNzQ2OA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421617468", "bodyText": "Issue that tracks getting rid of JoinKey: #5304", "author": "big-andy-coates", "createdAt": "2020-05-07T16:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwNjU2NQ=="}], "type": "inlineReview"}, {"oid": "3bde52b015a9a4979878adaf73982082c8eb57e3", "url": "https://github.com/confluentinc/ksql/commit/3bde52b015a9a4979878adaf73982082c8eb57e3", "message": "chore: update to use JOINKEY udf for synthetic join columns", "committedDate": "2020-04-27T14:35:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTMzMA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416131330", "bodyText": "typo: it to fail", "author": "mjsax", "createdAt": "2020-04-27T20:38:13Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,574 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to", "originalCommit": "3bde52b015a9a4979878adaf73982082c8eb57e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MjQ1Ng==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r420962456", "bodyText": "I don't see the typo... can you spell it out please?", "author": "big-andy-coates", "createdAt": "2020-05-06T17:24:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTMzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE0NjYyMg==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421146622", "bodyText": "Not sure any more... Sorry.", "author": "mjsax", "createdAt": "2020-05-06T23:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMzIwNQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416133205", "bodyText": "Where does the name ID come from? It's not specified in the query via AS ID? Do you mean\nCREATE TABLE OUTPUT AS\n   SELECT ROWKEY AS ID, * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;", "author": "mjsax", "createdAt": "2020-04-27T20:41:23Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,574 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT", "originalCommit": "3bde52b015a9a4979878adaf73982082c8eb57e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2NDcyNQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r420964725", "bodyText": "This is existing functionality, not proposed functionality.  The ID comes from I1.ID, but has the source removed. It can't be called I1_ID as that could clash with the column of the value column of the same name.\nThis KLIP proposes it should be I1_ID and the value column should be removed. (See the very next section)", "author": "big-andy-coates", "createdAt": "2020-05-06T17:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMzIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1NTg4MQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421155881", "bodyText": "My point is: the input schemas have 3 columns each, and thus the output schema should have 6 columns, not 7.\nInstead of maintaining I1.ID twice, ie, in the value as I1_ID and in the key as ID we just \"move\" the I1.ID column into the key only and don't have it in the value:\noutput schema: I1_ID INT KEY, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n\nThis seems to be much easier to understand?", "author": "mjsax", "createdAt": "2020-05-06T23:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMzIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxNDI2Mg==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421314262", "bodyText": "That's exactly what the KLIP is proposing.\nYou're reading the section on 'current behaviour' and not the section on 'proposed behaviour'!!! Read the next section!!!!", "author": "big-andy-coates", "createdAt": "2020-05-07T08:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMzIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU2MDc5Mg==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r421560792", "bodyText": "I thought that the current behavior would add a column ROWKEY (as only this KLIP would allow users to set a different name(?", "author": "mjsax", "createdAt": "2020-05-07T14:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMzIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzNjEwMQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416136101", "bodyText": "typo: by by use", "author": "mjsax", "createdAt": "2020-04-27T20:46:18Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,574 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+First, consider a full outer join on columns from the left and right sources:\n+\n+```sql\n+-- full outer join:\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+The data stored in the Kafka message's key will be equal to either the left join column, the right\n+join column or both, depending on whether only one side matches or both:\n+\n+|                  | I1.ID | I2.ID | Message Key |\n+| ---------------- | ----- | ----- | ----------- |\n+| both sides match | 10    | 10    | 10          |\n+| left side only   | 10    | null  | 10          |\n+| right side only  | null  | 10    | 10          |\n+\n+As you can see, the message key is not equivalent to either of the source columns. This is\n+problematic.\n+\n+The same is also true of other join types where no sides within the join criteria are a simple\n+column reference, a.k.a. non-column joins. For example:\n+\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = ABS(I2.ID);\n+```\n+\n+Again, the message key is not equivalent to any column for the sources involved in the join. (Note:\n+if either side of the join criteria is a simple column reference, then the Kafka message's key is\n+equivalent to that column, and hence no additional column is synthesised by the join).\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own.\n+\n+Though not ideal, we propose that in the short term the synthesised column can be included in the\n+projection by by use of a new `JOINKEY` udf. For example, the above examples that used `*` in", "originalCommit": "3bde52b015a9a4979878adaf73982082c8eb57e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2NzQ4Nw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r420967487", "bodyText": "thanks.", "author": "big-andy-coates", "createdAt": "2020-05-06T17:32:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzNjEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE0MDYyMw==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416140623", "bodyText": "typo: to correctly handle [...] correctly,\n\nwhich it currently does not\n\nAnd maybe never will. However, as discussed in person, there seems to be a solution by compiling down some additional logic into the Kafka Streams program.", "author": "mjsax", "createdAt": "2020-04-27T20:53:25Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,574 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+First, consider a full outer join on columns from the left and right sources:\n+\n+```sql\n+-- full outer join:\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+The data stored in the Kafka message's key will be equal to either the left join column, the right\n+join column or both, depending on whether only one side matches or both:\n+\n+|                  | I1.ID | I2.ID | Message Key |\n+| ---------------- | ----- | ----- | ----------- |\n+| both sides match | 10    | 10    | 10          |\n+| left side only   | 10    | null  | 10          |\n+| right side only  | null  | 10    | 10          |\n+\n+As you can see, the message key is not equivalent to either of the source columns. This is\n+problematic.\n+\n+The same is also true of other join types where no sides within the join criteria are a simple\n+column reference, a.k.a. non-column joins. For example:\n+\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = ABS(I2.ID);\n+```\n+\n+Again, the message key is not equivalent to any column for the sources involved in the join. (Note:\n+if either side of the join criteria is a simple column reference, then the Kafka message's key is\n+equivalent to that column, and hence no additional column is synthesised by the join).\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own.\n+\n+Though not ideal, we propose that in the short term the synthesised column can be included in the\n+projection by by use of a new `JOINKEY` udf. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:\n+\n+```sql\n+-- full outer join:\n+CREATE TABLE OUTPUT AS\n+   SELECT JOINKEY(I1.ID, I2.ID), I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1\n+      FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: KSQL_COL_0 INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS\n+   SELECT JOINKEY(ABS(I1.ID), ABS(I2.ID)), I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 INT\n+      FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = ABS(I2.ID);\n+-- resulting schema: KSQL_COL_0 INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Key to this solution, is the ability for users to provide their own name for the synthesised key\n+column. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT JOINKEY(I1.ID, I2.ID) AS ID, I1.V0, I1.V1, I2.V0, I2.V1 INT\n+      FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Requiring the user to include a synthesised column in the projection is not idea. However, we\n+propose this is best short term solution given the current functionality.\n+\n+A more correct implementation might store both sides of the join criteria in the key for all join\n+types. However, such an approach would require support for multiple key columns and extensive\n+changes in Streams. See [rejected alternatives](#rejected_alternatives) for more info.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE STREAM OUTPUT AS\n+   SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE STREAM OUTPUT AS\n+   SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE STREAM OUTPUT AS\n+   SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROWKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that the last query above should work, without any modification, and without storing\n+duplicate data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS\n+   SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+There is no reason why ksqlDB should not support creating sources in the future that do not contain\n+the key column. See the [rejected alternatives](#rejected_alternatives) section for more info.\n+\n+### Allowing the key column to be copied to the value\n+\n+Hopefully, all of the above seems simple and clear. Now for one of the more tricky and murky bits...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+We propose introducing a `AS_VALUE` function that can be used to\n+indicate the key column should be copied as a value column. For example,\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1, AS_VALUE(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+### Grouping by multiple expressions.\n+\n+KsqlDB supports grouping by multiple expressions, for example:\n+\n+```sql\n+SELECT V0, ABS(V1), COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+```\n+\n+However, it does not _yet_ support multiple key columns. If the above is converted to a persistent\n+query the key is generated by concatenating the string representation of the grouping expressions.\n+For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, ABS(V1) AS V1, COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+-- resulting schema: KSQL_COL_0 STRING KEY, V0 INT, V1 INT, COUNT BIGINT\n+-- where KSQL_COL_0 contains data in the form V0 + \"|+|\" + ABS(V1)\n+```\n+\n+Even though ksqlDB is currently combining the multiple grouping expressions, we propose that the\n+projection should still accept the individual columns, and recognise them as key columns. This will\n+be compatible with the upcoming multiple-key-column support.\n+\n+However, this posses a problem, as it does not provide a single place where the user can provide an\n+alias for the system generated `KSQL_COL_0` key column name. Any solution to allow providing an\n+alias would likely be incompatible with the planned multiple key column support. \n+\n+Hence, we propose leaving this edge case unsolved, i.e. users will _not_ be able to provide an alias\n+for the name of the key column resulting from multiple grouping expressions. This will be resolved\n+when support for multiple key columns is added.\n+\n+Alternatively, ksqlDB could support the non-strandard `GROUP BY (a, b) AS c` style aliasing, to allow\n+users to provide their own name. This support could be removed once multiple key columns are \n+supported.\n+\n+If anyone has any suggestions on how we can support this in a compatible manner, please speak up!\n+\n+## What is in scope\n+\n+- Removal of implicit copying of key column,\n+  in favour of requiring key column in projection of persistent queries.\n+- Removal of non-standard GROUP BY, PARTITION BY and JOIN aliasing syntax,\n+  in favour of standard aliasing of the key column in the projection.\n+- removal of duplicate left join column on 'select *' joins.\n+- Addition of `COPY` function to allow users to add key column to value schema.\n+- TODO(ac): group by multiple fields...\n+\n+## What is not in scope\n+\n+- Changes in syntax for changing the key column, e.g. allowing the projection to change the key\n+  column.  This out of scope and is only potential future work. It should be discussion separately.\n+- Replacing the use of the `KEY` keyword in CSAS statements with other syntax:\n+  this is mostly orthogonal to this change.\n+- everything else.\n+\n+## Value/Return\n+\n+Standardizing the key semantics in queries will lower the barrier for entry for users and engineers\n+alike, and reduce the support burden of explaining the subtleties. It will also simplify the code,\n+which should result in less bugs.\n+\n+Removing of the non-standard `GROUP BY`, `PARTITION BY` and `JON ON` aliasing in favour of aliasing\n+in the projection will improve out standards compliance.\n+\n+## Public APIS\n+\n+1. Persistent queries, i.e. those used in `CREATE TABLE AS`, `CREATE STREAM AS` and `INSERT INTO`\n+statements, will be required to _always_ include their key columns in their projection. An error\n+will be generated should the projection of a persistent query not include its key column. For\n+example:\n+\n+```sql\n+-- old syntax that worked:\n+CREATE TABLE OUTPUT AS\n+   SELECT COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- will now fail with an error explaining the projection must include the key column `V0`.sql\n+\n+-- corrected query:\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: V0 INT KEY, COUNT BIGINT\n+```\n+\n+2. The, as yet unreleased, non-standard `GROUP BY`, `PARTITION BY` and `JOIN ON` alias syntax will\n+be removed in favour of using the existing standard-compliant aliasing in the projection. For\n+example:\n+\n+```sql\n+-- 'any key' aliasing syntax that will be dropped:\n+CREATE TABLE OUTPUT AS\n+   SELECT COUNT() AS COUNT FROM INPUT GROUP BY V0 AS K;\n+-- resulting schema: K INT KEY, COUNT BIGINT\n+\n+-- proposed key column aliasing in projection:\n+CREATE TABLE OUTPUT AS\n+   SELECT V0 AS K, COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: K INT KEY, COUNT BIGINT\n+```\n+\n+3. Removal of duplicate left join column on `select *` joins. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- current result schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- note join key is duplicated in ID, I1_ID and I2_ID columns.\n+\n+-- proposed result schema either (TBD):\n+-- a): ID INT KEY, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- note join key is duplicated in ID and I2_ID columns, only.\n+-- b): I1_ID INT KEY, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- note join key is duplicated in I1_ID and I2_ID columns, only.\n+```\n+\n+4. Syntax for allowing key column to be added as value column:\n+\n+A new `COPY` method will be added to allow users to copy the key column into the value. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1, COPY(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+Name of `COPY` TBD. Alternatives:\n+ - `IDENTITY`\n+ - `AS_VALUE`\n+\n+## Design\n+\n+N/A: the change is a simple(ish) syntax change.\n+\n+## Test plan\n+\n+All preexisting queries, i.e. those with plans serialized to the command topic, will continue to\n+work and we have extensive tests covering this.\n+\n+Existing functional (QTT) tested will be converted to the new syntax with any missing cases added.\n+\n+As a purely syntactical change, nothing else is required.\n+\n+## LOEs and Delivery Milestones\n+\n+This is a small change, deliverable as a single milestone.\n+\n+## Documentation Updates\n+\n+Docs and examples in the ksqlDB repo, and any ksqlDB usage in the 'examples' repo, will be checked\n+to ensure the match the new syntax.\n+\n+## Compatibility Implications\n+\n+All preexisting queries, i.e. those with plans serialized to the command topic, will continue to\n+work and we have extensive tests covering this.\n+\n+Some existing SQL, if reissued, will fail if a persistent query's projection does not include the\n+key column. However, a helpful error message will inform the user of the changes they need to make\n+to resolve this.  Resolution is simple: just add the key column to the projection!\n+\n+## Security Implications\n+\n+None.\n+\n+## Rejected alternatives\n+\n+### Magic key column copying if no key column in persistent query's projection.\n+\n+Design as above, but not _requiring_ the key column in the projection. Instead, allow the key\n+column in the projection and implicitly copy it across if its not there.  This was rejected for two\n+key reasons:\n+  a. Potentially confusing 'magic implicits' - the output contains columns the projection doesn't\n+     specify.\n+  b. It over complicates the implementation.\n+\n+### Full support for no key column in persistent query's projection.\n+\n+Design as above, but allowing persistent query projections to not include the key column in the\n+projection. If not present, the created data source would have no _exposed_ key column.\n+\n+Given that the created source is actually a materialized view, it seems completely reasonable to\n+allow users to control the set of columns the view exposes. Any requirement internally for the key,\n+e.g. to allow updates to be processed correctly, would remain. The key would just not be available\n+in downstream queries.\n+\n+This was rejected for this KLIP as it would involve considerably more work. This may be picked up in\n+a future KLIP.\n+\n+### Storing all join columns in the key of the result\n+\n+A more correct solution for handling columns within a join may look to store all join columns in the\n+Kafka record's key, for example:\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: I1_ID INT KEY, I2_ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note that both `I1_ID` and `I2_ID` are marked as key columns. Such an approach may be required if\n+ksqlDB is to support join criterion other than the current equality.\n+\n+However, this is rejected as a solution for now for the following reasons:\n+  a. Such a solution requires ksqlDB to support multiple key columns. It currently does not, and this\n+     KLIP is part of the work moving towards such support. Hence its a chicken and egg problem.\n+  b. Such a solution requires Streams to be able to correctly handle the multiple key columns\n+     correctly, which it currently does not.  This is particularly challenging for outer joins,", "originalCommit": "3bde52b015a9a4979878adaf73982082c8eb57e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk3MjUxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r420972519", "bodyText": "Updated text.  Rest is ... tbd.", "author": "big-andy-coates", "createdAt": "2020-05-06T17:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE0MDYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE0MTExNQ==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r416141115", "bodyText": "typo: to the any source", "author": "mjsax", "createdAt": "2020-04-27T20:54:11Z", "path": "design-proposals/klip-24-key-column-semantics-in-queries.md", "diffHunk": "@@ -0,0 +1,574 @@\n+# KLIP 24 - KEY column semantics in queries\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBD\n+\n+**tl;dr:** Persistent queries do not allow the key column in the projection as key columns are\n+currently _implicitly_ copied across. This is not intuitive to anyone familiar with SQL. This KLIP\n+proposes flipping this so that the key column is _not_ implicitly copied across.\n+\n+## Motivation and background\n+\n+Below, we contrast the differences between transient and persistent queries and their current key\n+column handling semantics.\n+\n+Note: in all the example sql in this KLIP:\n+ * `EMIT CHANGES` had been removed for brevity.\n+ * `ROWTIME` had been ignored for brevity.\n+ * Schemas use `KEY` to denote the column stored in the Kafka record's key.\n+ * `PRIMARY KEY` is not used for brevity.\n+ * All input sources use the schema `ID INT KEY, V0 INT, V1 INT`, unless otherwise stated.\n+\n+Transient push and pull queries only return the columns in their projection. This is inline with\n+standard SQL. Conversely, persistent queries _implicitly_ copy the key column across, and don't\n+allow the key column in the projection.\n+\n+### Simple query\n+\n+The difference in key column handling can be seen with a simple query:\n+\n+```sql\n+SELECT ID, V0, V1 FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1 FROM INPUT;\n+-- fails with error about duplicate 'ID' column.\n+```\n+\n+Where as the above transient query works and returns all columns, converting it to a persistent\n+query causes it to fail with a duplicate column error, because `ID` is _implicitly_ being copied to\n+the OUTPUT schema, and the `ID` in the projection is creating a value column called `ID`. That's two\n+columns named `ID` and hence the query fails.\n+\n+We propose that the above `CREATE TABLE` statement should work, as the projection is equivalent to\n+`select *`, which works.\n+\n+### Non-join select star\n+\n+For non-join queries, both transient and persistent queries select all the columns in the schema:\n+\n+```sql\n+SELECT * FROM INPUT;\n+-- resulting columns: ID INT, V0 INT, V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT (Same as above)\n+```\n+\n+### Joins\n+\n+The differences with joins is more subtle.\n+\n+With a join query, a transient query selects all columns from all sources. A persistent query adds\n+all columns from all sources, and also adds an additional column that stores the result of the join\n+criteria.\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- vs --\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema (any key name enabled): ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- resulting schema (any key name disabled): ROWKEY INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note the addition of an additional `ID` or `ROWKEY` column in the case of the persistent query.\n+\n+#### Inner and left outer joins on column references\n+\n+For inner and left outer joins where the left join criteria is a column reference the\n+additional `ID` column is a duplicate of the `I1.ID` column.\n+\n+We propose that such joins should not duplicate the left join column `I1.ID` into both the `ID` key\n+and `I1_ID` value column. Instead, the key column should be named `I1_ID` and no copy should be stored\n+in the value.\n+\n+#### Full outer joins and non-column joins\n+\n+Where the join is a full outer join, or where the left join criteria is not a column reference, the\n+problem is more nuanced.\n+\n+First, consider a full outer join on columns from the left and right sources:\n+\n+```sql\n+-- full outer join:\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+```\n+\n+The data stored in the Kafka message's key will be equal to either the left join column, the right\n+join column or both, depending on whether only one side matches or both:\n+\n+|                  | I1.ID | I2.ID | Message Key |\n+| ---------------- | ----- | ----- | ----------- |\n+| both sides match | 10    | 10    | 10          |\n+| left side only   | 10    | null  | 10          |\n+| right side only  | null  | 10    | 10          |\n+\n+As you can see, the message key is not equivalent to either of the source columns. This is\n+problematic.\n+\n+The same is also true of other join types where no sides within the join criteria are a simple\n+column reference, a.k.a. non-column joins. For example:\n+\n+\n+```sql\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = ABS(I2.ID);\n+```\n+\n+Again, the message key is not equivalent to any column for the sources involved in the join. (Note:\n+if either side of the join criteria is a simple column reference, then the Kafka message's key is\n+equivalent to that column, and hence no additional column is synthesised by the join).\n+\n+This KLIP proposes that the projection should include _all the columns expected in the result_.\n+Logically, this must include this new key column. Yet, this new key column is an artifact of the\n+current join implementation, so what should it be called and how should the user include it in the\n+projection?\n+\n+The synthesised column is currently named `ROWKEY`. However, the 'any key name' feature removes the\n+`ROWKEY` system column in favour of user supplied names or system generated ones in the form\n+`KSQL_COL_x`.\n+\n+If we are to require users to explicitly include this synthesised column in any projection with\n+explicit columns, i.e. non select-star projections, then the user must be able to determine the name\n+and be able to provide their own.\n+\n+Though not ideal, we propose that in the short term the synthesised column can be included in the\n+projection by by use of a new `JOINKEY` udf. For example, the above examples that used `*` in\n+their projections could be expanded to the following explicit column lists:\n+\n+```sql\n+-- full outer join:\n+CREATE TABLE OUTPUT AS\n+   SELECT JOINKEY(I1.ID, I2.ID), I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1\n+      FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: KSQL_COL_0 INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+-- inner join on expression:\n+CREATE TABLE OUTPUT AS\n+   SELECT JOINKEY(ABS(I1.ID), ABS(I2.ID)), I1.ID, I1.V0, I1.V1, I2.ID, I2.V0, I2.V1 INT\n+      FROM INPUT I1 JOIN INPUT_2 I2 ON ABS(I1.ID) = ABS(I2.ID);\n+-- resulting schema: KSQL_COL_0 INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Key to this solution, is the ability for users to provide their own name for the synthesised key\n+column. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT JOINKEY(I1.ID, I2.ID) AS ID, I1.V0, I1.V1, I2.V0, I2.V1 INT\n+      FROM INPUT I1 OUTER JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Requiring the user to include a synthesised column in the projection is not idea. However, we\n+propose this is best short term solution given the current functionality.\n+\n+A more correct implementation might store both sides of the join criteria in the key for all join\n+types. However, such an approach would require support for multiple key columns and extensive\n+changes in Streams. See [rejected alternatives](#rejected_alternatives) for more info.\n+\n+### Removal of non-standard Aliasing\n+\n+The [allow any key name](https://github.com/confluentinc/ksql/issues/3536) feature has introduced\n+the ability to provide an alias within a `PARTITION BY`, `GROUP BY` and `JOIN` clause. These are\n+non-standard, but required in the current model to allow users to name the key column in the schema.\n+For example:\n+\n+```sql\n+-- without alias:\n+CREATE STREAM OUTPUT AS\n+   SELECT ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: KSQL_COL_0 INT KEY, ID;\n+-- note the system generated column name.\n+\n+-- with alias\n+CREATE STREAM OUTPUT AS\n+   SELECT ID FROM INPUT PARTITION BY V0 - V1 AS NEW_KEY;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+However, the same functionality can be achieved using standard sql if the key column is required\n+in the projection, for example:\n+\n+```sql\n+CREATE STREAM OUTPUT AS\n+   SELECT V0 - V1 AS NEW_KEY, ID FROM INPUT PARTITION BY V0 - V1;\n+-- resulting schema: NEW_KEY INT KEY, ID;\n+```\n+\n+### Any key name\n+\n+Persistent queries failing if the projection contained the key column existed before the work to\n+[allow any key name](https://github.com/confluentinc/ksql/issues/3536), though this work also\n+exacerbated the situation, as the key column is no longer always called `ROWKEY`. Instead, users can\n+pick any name for the key column, and the key column takes on the name of any `PARTITION BY`,\n+`GROUP BY` or `JOIN ON` on a single column. This causes seemingly correct and common patterns to\n+fail with duplicate column errors:\n+\n+```sql\n+-- Before 'any key name':\n+CREATE STREAM INPUT (ROWKEY INT KEY, V0 INT, V1 INT) WITH (...);\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: ROWKEY INT KEY, V0 INT, COUNT BIGINT\n+-- Note: ROWKEY & V0 store the same data, which isn't ideal.\n+\n+-- vs --\n+\n+-- After 'any key name':\n+CREATE STREAM INPUT (ID INT KEY, V0 INT, V1 INT) WITH (...);\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, COUNT(*) AS COUNT FROM INPUT GROUP BY V0;\n+-- fails with duplicate column error on 'V0'.\n+```\n+\n+As you can see from above, the common pattern of selecting the group by key and the aggregate fails.\n+To 'fix' the query the user must remove `V0` from the projection - which is counter intuitive, as\n+the user wishes this column in the result.\n+\n+We propose that the last query above should work, without any modification, and without storing\n+duplicate data.\n+\n+### Requiring the key column in a projection in persistent queries\n+\n+By flipping the semantics so that the key column is not _implicitly_ copied across in persistent\n+queries we place the burden on the user to _explicitly_ specify it in the projection.\n+\n+Where as it is possible to have a transient query without the key column in the projection, as a\n+transient query is simply returning tabular data and has no concept of a key column, persistent\n+queries do have the concept of a key column, and changing that column is only allowed via an\n+explicit `PARTITION BY` or `GROUP BY` statement.  Therefore users will _always_ have to specify the\n+key column in the projection of persistent queries.\n+\n+For example, the following statements, which previously executed, will now fail:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, V1 FROM INPUT;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT COUNT(*) FROM INPUT GROUP BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE STREAM OUTPUT AS\n+   SELECT V0, ID FROM INPUT PARTITION BY V1;\n+-- fails as key column not in projection.\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT I1.V0, I2.V2 FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- fails as key column not in projection.\n+```\n+\n+We propose this is acceptable, and preferable to the current model.\n+\n+There is no reason why ksqlDB should not support creating sources in the future that do not contain\n+the key column. See the [rejected alternatives](#rejected_alternatives) section for more info.\n+\n+### Allowing the key column to be copied to the value\n+\n+Hopefully, all of the above seems simple and clear. Now for one of the more tricky and murky bits...\n+\n+The observant among you may be thinking 'ah, but what if I _want_ to put a copy of the key column\n+into the value?'. With current syntax you can do:\n+\n+```sql\n+-- current syntax:\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, V1, ID AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+With the proposed syntax the `ID AS V2` would be treated an aliased key column, resulting in the\n+schema 'V2 INT KEY, V0 INT, V1 INT'. So, how does the user create an copy of the key in the value,\n+if that's what they need to do?\n+\n+We propose introducing a `AS_VALUE` function that can be used to\n+indicate the key column should be copied as a value column. For example,\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1, AS_VALUE(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+### Grouping by multiple expressions.\n+\n+KsqlDB supports grouping by multiple expressions, for example:\n+\n+```sql\n+SELECT V0, ABS(V1), COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+```\n+\n+However, it does not _yet_ support multiple key columns. If the above is converted to a persistent\n+query the key is generated by concatenating the string representation of the grouping expressions.\n+For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, ABS(V1) AS V1, COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n+-- resulting schema: KSQL_COL_0 STRING KEY, V0 INT, V1 INT, COUNT BIGINT\n+-- where KSQL_COL_0 contains data in the form V0 + \"|+|\" + ABS(V1)\n+```\n+\n+Even though ksqlDB is currently combining the multiple grouping expressions, we propose that the\n+projection should still accept the individual columns, and recognise them as key columns. This will\n+be compatible with the upcoming multiple-key-column support.\n+\n+However, this posses a problem, as it does not provide a single place where the user can provide an\n+alias for the system generated `KSQL_COL_0` key column name. Any solution to allow providing an\n+alias would likely be incompatible with the planned multiple key column support. \n+\n+Hence, we propose leaving this edge case unsolved, i.e. users will _not_ be able to provide an alias\n+for the name of the key column resulting from multiple grouping expressions. This will be resolved\n+when support for multiple key columns is added.\n+\n+Alternatively, ksqlDB could support the non-strandard `GROUP BY (a, b) AS c` style aliasing, to allow\n+users to provide their own name. This support could be removed once multiple key columns are \n+supported.\n+\n+If anyone has any suggestions on how we can support this in a compatible manner, please speak up!\n+\n+## What is in scope\n+\n+- Removal of implicit copying of key column,\n+  in favour of requiring key column in projection of persistent queries.\n+- Removal of non-standard GROUP BY, PARTITION BY and JOIN aliasing syntax,\n+  in favour of standard aliasing of the key column in the projection.\n+- removal of duplicate left join column on 'select *' joins.\n+- Addition of `COPY` function to allow users to add key column to value schema.\n+- TODO(ac): group by multiple fields...\n+\n+## What is not in scope\n+\n+- Changes in syntax for changing the key column, e.g. allowing the projection to change the key\n+  column.  This out of scope and is only potential future work. It should be discussion separately.\n+- Replacing the use of the `KEY` keyword in CSAS statements with other syntax:\n+  this is mostly orthogonal to this change.\n+- everything else.\n+\n+## Value/Return\n+\n+Standardizing the key semantics in queries will lower the barrier for entry for users and engineers\n+alike, and reduce the support burden of explaining the subtleties. It will also simplify the code,\n+which should result in less bugs.\n+\n+Removing of the non-standard `GROUP BY`, `PARTITION BY` and `JON ON` aliasing in favour of aliasing\n+in the projection will improve out standards compliance.\n+\n+## Public APIS\n+\n+1. Persistent queries, i.e. those used in `CREATE TABLE AS`, `CREATE STREAM AS` and `INSERT INTO`\n+statements, will be required to _always_ include their key columns in their projection. An error\n+will be generated should the projection of a persistent query not include its key column. For\n+example:\n+\n+```sql\n+-- old syntax that worked:\n+CREATE TABLE OUTPUT AS\n+   SELECT COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- will now fail with an error explaining the projection must include the key column `V0`.sql\n+\n+-- corrected query:\n+CREATE TABLE OUTPUT AS\n+   SELECT V0, COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: V0 INT KEY, COUNT BIGINT\n+```\n+\n+2. The, as yet unreleased, non-standard `GROUP BY`, `PARTITION BY` and `JOIN ON` alias syntax will\n+be removed in favour of using the existing standard-compliant aliasing in the projection. For\n+example:\n+\n+```sql\n+-- 'any key' aliasing syntax that will be dropped:\n+CREATE TABLE OUTPUT AS\n+   SELECT COUNT() AS COUNT FROM INPUT GROUP BY V0 AS K;\n+-- resulting schema: K INT KEY, COUNT BIGINT\n+\n+-- proposed key column aliasing in projection:\n+CREATE TABLE OUTPUT AS\n+   SELECT V0 AS K, COUNT() AS COUNT FROM INPUT GROUP BY V0;\n+-- resulting schema: K INT KEY, COUNT BIGINT\n+```\n+\n+3. Removal of duplicate left join column on `select *` joins. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT I2 ON I1.ID = I2.ID;\n+-- current result schema: ID INT KEY, I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- note join key is duplicated in ID, I1_ID and I2_ID columns.\n+\n+-- proposed result schema either (TBD):\n+-- a): ID INT KEY, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- note join key is duplicated in ID and I2_ID columns, only.\n+-- b): I1_ID INT KEY, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+-- note join key is duplicated in I1_ID and I2_ID columns, only.\n+```\n+\n+4. Syntax for allowing key column to be added as value column:\n+\n+A new `COPY` method will be added to allow users to copy the key column into the value. For example:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+   SELECT ID, V0, V1, COPY(ID) AS V2 FROM INPUT;\n+-- resulting schema: ID INT KEY, V0 INT, V1 INT, V2 INT\n+```\n+\n+Name of `COPY` TBD. Alternatives:\n+ - `IDENTITY`\n+ - `AS_VALUE`\n+\n+## Design\n+\n+N/A: the change is a simple(ish) syntax change.\n+\n+## Test plan\n+\n+All preexisting queries, i.e. those with plans serialized to the command topic, will continue to\n+work and we have extensive tests covering this.\n+\n+Existing functional (QTT) tested will be converted to the new syntax with any missing cases added.\n+\n+As a purely syntactical change, nothing else is required.\n+\n+## LOEs and Delivery Milestones\n+\n+This is a small change, deliverable as a single milestone.\n+\n+## Documentation Updates\n+\n+Docs and examples in the ksqlDB repo, and any ksqlDB usage in the 'examples' repo, will be checked\n+to ensure the match the new syntax.\n+\n+## Compatibility Implications\n+\n+All preexisting queries, i.e. those with plans serialized to the command topic, will continue to\n+work and we have extensive tests covering this.\n+\n+Some existing SQL, if reissued, will fail if a persistent query's projection does not include the\n+key column. However, a helpful error message will inform the user of the changes they need to make\n+to resolve this.  Resolution is simple: just add the key column to the projection!\n+\n+## Security Implications\n+\n+None.\n+\n+## Rejected alternatives\n+\n+### Magic key column copying if no key column in persistent query's projection.\n+\n+Design as above, but not _requiring_ the key column in the projection. Instead, allow the key\n+column in the projection and implicitly copy it across if its not there.  This was rejected for two\n+key reasons:\n+  a. Potentially confusing 'magic implicits' - the output contains columns the projection doesn't\n+     specify.\n+  b. It over complicates the implementation.\n+\n+### Full support for no key column in persistent query's projection.\n+\n+Design as above, but allowing persistent query projections to not include the key column in the\n+projection. If not present, the created data source would have no _exposed_ key column.\n+\n+Given that the created source is actually a materialized view, it seems completely reasonable to\n+allow users to control the set of columns the view exposes. Any requirement internally for the key,\n+e.g. to allow updates to be processed correctly, would remain. The key would just not be available\n+in downstream queries.\n+\n+This was rejected for this KLIP as it would involve considerably more work. This may be picked up in\n+a future KLIP.\n+\n+### Storing all join columns in the key of the result\n+\n+A more correct solution for handling columns within a join may look to store all join columns in the\n+Kafka record's key, for example:\n+\n+```sql\n+SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting columns: I1_ID INT, I1_V0 INT, I1_V1 INT, I2_ID INT, I2_V0 INT, I2_V1 INT\n+\n+CREATE TABLE OUTPUT AS\n+   SELECT * FROM INPUT I1 JOIN INPUT_2 I2 ON I1.ID = I2.ID;\n+-- resulting schema: I1_ID INT KEY, I2_ID INT KEY, I1_V0 INT, I1_V1 INT, I2_V0 INT, I2_V1 INT\n+```\n+\n+Note that both `I1_ID` and `I2_ID` are marked as key columns. Such an approach may be required if\n+ksqlDB is to support join criterion other than the current equality.\n+\n+However, this is rejected as a solution for now for the following reasons:\n+  a. Such a solution requires ksqlDB to support multiple key columns. It currently does not, and this\n+     KLIP is part of the work moving towards such support. Hence its a chicken and egg problem.\n+  b. Such a solution requires Streams to be able to correctly handle the multiple key columns\n+     correctly, which it currently does not.  This is particularly challenging for outer joins,\n+     where some key columns may initially be `null` and later populated. Any solution needs to ensure\n+     correct partitioning and update semantics for such rows.\n+\n+### System generated naming for the synthesised join column\n+\n+Where a join introduces a synthesised key column the column would have a system generated name.\n+\n+Requiring the user to include a column within the projection that does not belong to the any source", "originalCommit": "3bde52b015a9a4979878adaf73982082c8eb57e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk3MzEyNA==", "url": "https://github.com/confluentinc/ksql/pull/5115#discussion_r420973124", "bodyText": "thanks,.", "author": "big-andy-coates", "createdAt": "2020-05-06T17:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE0MTExNQ=="}], "type": "inlineReview"}, {"oid": "519a7b75af167f52b991858dd7b1e9e582b0c4f1", "url": "https://github.com/confluentinc/ksql/commit/519a7b75af167f52b991858dd7b1e9e582b0c4f1", "message": "chore: updated with latest comments", "committedDate": "2020-05-06T18:04:07Z", "type": "commit"}, {"oid": "2698f8ccde0021fb38ed7ea6322cfd793ef92240", "url": "https://github.com/confluentinc/ksql/commit/2698f8ccde0021fb38ed7ea6322cfd793ef92240", "message": "Merge branch 'master' into klip-24-key-column-query-semantics", "committedDate": "2020-05-06T18:41:24Z", "type": "commit"}]}