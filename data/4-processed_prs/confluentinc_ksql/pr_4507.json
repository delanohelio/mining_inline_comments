{"pr_number": 4507, "pr_title": "chore: Primitive Keys comes to PRINT TOPIC", "pr_createdAt": "2020-02-10T21:28:39Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4507", "timeline": [{"oid": "d2a8b1cd6b8267cf15c189f1d42eaae009dd3673", "url": "https://github.com/confluentinc/ksql/commit/d2a8b1cd6b8267cf15c189f1d42eaae009dd3673", "message": "chore: refactor PRINT TOPIC functionality\n\n - prep for key formats\n - standardized output, regardless of format, to: `rowkey: <ts>, key: <key>, value: <value>`.\n - format is no longer determined from first record: first batch is inspected\n - added MIXED format, where format varies per-row.  This defaults to formatting as a string.\n - PRINT TOPIC no longer filters out null values. Each record in the topic results in a output row, which will help highlight data issues.\n - outputs a message if it failed to deserialize a record, which will help highlight data issues.\n - formatting is now lazy, meaning we avoid the formatting cost where INTERVAL != 1", "committedDate": "2020-02-10T21:25:10Z", "type": "commit"}, {"oid": "b772d877ba665fbfbe709c35b81e3b01f00a72c3", "url": "https://github.com/confluentinc/ksql/commit/b772d877ba665fbfbe709c35b81e3b01f00a72c3", "message": "chore: output KEY format", "committedDate": "2020-02-10T22:17:40Z", "type": "commit"}, {"oid": "f2ed450c3d36d4642faafa52d9e11e4c42da420f", "url": "https://github.com/confluentinc/ksql/commit/f2ed450c3d36d4642faafa52d9e11e4c42da420f", "message": "chore: add KAFKA format", "committedDate": "2020-02-10T23:17:56Z", "type": "commit"}, {"oid": "7beca3c9d325edade23cf3daa006cbcd44302682", "url": "https://github.com/confluentinc/ksql/commit/7beca3c9d325edade23cf3daa006cbcd44302682", "message": "chore: tidy up", "committedDate": "2020-02-10T23:26:59Z", "type": "commit"}, {"oid": "a1c0637858918ef5c437e9e6027b01a37561c735", "url": "https://github.com/confluentinc/ksql/commit/a1c0637858918ef5c437e9e6027b01a37561c735", "message": "docs: update docs", "committedDate": "2020-02-11T00:03:06Z", "type": "commit"}, {"oid": "34c973b1e317a9ca7f3c8b9e70d2a0be4853654d", "url": "https://github.com/confluentinc/ksql/commit/34c973b1e317a9ca7f3c8b9e70d2a0be4853654d", "message": "chore: remove outstanding todos\n\nfor another PR...", "committedDate": "2020-02-11T00:03:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5MTcyNw==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377391727", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ksqlDB will attempt to determine the format of the data in the topic and wil output what its thinks is\n          \n          \n            \n            ksqlDB attempts to determine the format of the data in the topic and outputs what it thinks are", "author": "JimGalasyn", "createdAt": "2020-02-11T00:13:02Z", "path": "docs-md/developer-guide/ksqldb-reference/print.md", "diffHunk": "@@ -39,13 +39,24 @@ The following statement shows how to print all of the records in a topic named\n PRINT ksql__commands FROM BEGINNING;\r\n ```\r\n \r\n+ksqlDB will attempt to determine the format of the data in the topic and wil output what its thinks is\r", "originalCommit": "34c973b1e317a9ca7f3c8b9e70d2a0be4853654d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5MTk1OQ==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377391959", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               For example, it is not possible to distinguish between serialized `BIGINT` and `DOUBLE`s, as\n          \n          \n            \n               For example, it is not possible to distinguish between serialized `BIGINT` and `DOUBLE` values, because", "author": "JimGalasyn", "createdAt": "2020-02-11T00:13:50Z", "path": "docs-md/developer-guide/ksqldb-reference/print.md", "diffHunk": "@@ -39,13 +39,24 @@ The following statement shows how to print all of the records in a topic named\n PRINT ksql__commands FROM BEGINNING;\r\n ```\r\n \r\n+ksqlDB will attempt to determine the format of the data in the topic and wil output what its thinks is\r\n+the key and value formats at the top of the output.\r\n+\r\n+!!! note\r\n+   Attempting to determine a data format from only the serialized bytes is not an exact science!\r\n+   For example, it is not possible to distinguish between serialized `BIGINT` and `DOUBLE`s, as\r", "originalCommit": "34c973b1e317a9ca7f3c8b9e70d2a0be4853654d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5MjA3Mw==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377392073", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               they both occupy 8 bytes. Short strings can also be mistaken for serialized numbers.\n          \n          \n            \n               they both occupy eight bytes. Short strings can also be mistaken for serialized numbers.", "author": "JimGalasyn", "createdAt": "2020-02-11T00:14:17Z", "path": "docs-md/developer-guide/ksqldb-reference/print.md", "diffHunk": "@@ -39,13 +39,24 @@ The following statement shows how to print all of the records in a topic named\n PRINT ksql__commands FROM BEGINNING;\r\n ```\r\n \r\n+ksqlDB will attempt to determine the format of the data in the topic and wil output what its thinks is\r\n+the key and value formats at the top of the output.\r\n+\r\n+!!! note\r\n+   Attempting to determine a data format from only the serialized bytes is not an exact science!\r\n+   For example, it is not possible to distinguish between serialized `BIGINT` and `DOUBLE`s, as\r\n+   they both occupy 8 bytes. Short strings can also be mistaken for serialized numbers.\r", "originalCommit": "34c973b1e317a9ca7f3c8b9e70d2a0be4853654d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cc623bebb23bf6393b350381c684121790cc77c9", "url": "https://github.com/confluentinc/ksql/commit/cc623bebb23bf6393b350381c684121790cc77c9", "message": "chore: changes requested by Jim", "committedDate": "2020-02-11T09:01:00Z", "type": "commit"}, {"oid": "8498603c6d58ce4e424c93196c2c28b9735277eb", "url": "https://github.com/confluentinc/ksql/commit/8498603c6d58ce4e424c93196c2c28b9735277eb", "message": "chore: fix spotbugs", "committedDate": "2020-02-11T19:26:53Z", "type": "commit"}, {"oid": "ee087d12132cf8d798167953fcd3ee99cfd3f59e", "url": "https://github.com/confluentinc/ksql/commit/ee087d12132cf8d798167953fcd3ee99cfd3f59e", "message": "docs: fix quoting on examples", "committedDate": "2020-02-11T19:30:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NjQ4Ng==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377846486", "bodyText": "nit (not your code): constants for 3 and 1 (no idea what these mean \ud83d\ude02 )", "author": "agavra", "createdAt": "2020-02-11T19:21:46Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())", "originalCommit": "cc623bebb23bf6393b350381c684121790cc77c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NDA2OQ==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377864069", "bodyText": "neither do I! :D", "author": "big-andy-coates", "createdAt": "2020-02-11T19:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NjQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NzQ5OA==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377847498", "bodyText": "nit(personal preference): for internal variables I actually prefer nulls to Optionals as we're not exposing it anywhere and then we don't need to keep calling get everywhere when we know it'll be not-null at that point", "author": "agavra", "createdAt": "2020-02-11T19:23:33Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+      if (!keyFormatter.isPresent()) {\n+        keyFormatter = getKeyFormatter(records);\n+      }\n+\n+      if (!valueFormatter.isPresent()) {\n+        valueFormatter = getValueFormatter(records);\n+      }\n+\n+      return StreamSupport.stream(records.spliterator(), false)\n+          .map(this::delayedFormat)\n           .collect(Collectors.toList());\n     }\n \n-    public Format getFormat() {\n-      return formatter == null ? Format.UNDEFINED : formatter.getFormat();\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") // will not be empty if needed", "originalCommit": "cc623bebb23bf6393b350381c684121790cc77c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NDM5NQ==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377864395", "bodyText": "Next PR removes these anyway.  Though I still prefer encoding optionality into the type system.", "author": "big-andy-coates", "createdAt": "2020-02-11T19:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NzQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MTc0OA==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377851748", "bodyText": "can you add some documentation on how this \"algorithm\" works? i.e. explain how it chooses the formatter, what the default is and the batching mechanism", "author": "agavra", "createdAt": "2020-02-11T19:31:20Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {", "originalCommit": "cc623bebb23bf6393b350381c684121790cc77c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NDgxMw==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377864813", "bodyText": "Good call. It's changing in the next PR. I'll add a local todo to add docs.", "author": "big-andy-coates", "createdAt": "2020-02-11T19:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MTc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MjM3Mg==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377852372", "bodyText": "I'm not sure I understand why we needed to turn this into a String?", "author": "agavra", "createdAt": "2020-02-11T19:32:36Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+      if (!keyFormatter.isPresent()) {\n+        keyFormatter = getKeyFormatter(records);\n+      }\n+\n+      if (!valueFormatter.isPresent()) {\n+        valueFormatter = getValueFormatter(records);\n+      }\n+\n+      return StreamSupport.stream(records.spliterator(), false)\n+          .map(this::delayedFormat)\n           .collect(Collectors.toList());\n     }\n \n-    public Format getFormat() {\n-      return formatter == null ? Format.UNDEFINED : formatter.getFormat();\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") // will not be empty if needed\n+    private Supplier<String> delayedFormat(final ConsumerRecord<Bytes, Bytes> record) {\n+      return () -> {\n+        try {\n+          final String rowTime = record.timestamp() == ConsumerRecord.NO_TIMESTAMP\n+              ? \"N/A\"\n+              : dateFormat.format(new Date(record.timestamp()));\n+\n+          final String rowKey = record.key() == null || record.key().get() == null\n+              ? \"<null>\"\n+              : keyFormatter.get().print(record.key());\n+\n+          final String value = record.value() == null || record.value().get() == null\n+              ? \"<null>\"\n+              : valueFormatter.get().print(record.value());\n+\n+          return \"rowtime: \" + rowTime\n+              + \", \" + \"key: \" + rowKey\n+              + \", value: \" + value;\n+        } catch (IOException e) {\n+          log.warn(\"Exception formatting record\", e);\n+          return \"Failed to parse row\";\n+        }\n+      };\n+    }\n+\n+    public String getKeyFormat() {\n+      return keyFormatter\n+          .map(Formatter::getFormat)\n+          .orElse(Format.UNDEFINED.toString());\n+    }\n+\n+    public String getValueFormat() {\n+      return valueFormatter\n+          .map(Formatter::getFormat)\n+          .orElse(Format.UNDEFINED.toString());\n+    }\n+\n+    private Optional<Formatter> getKeyFormatter(\n+        final Iterable<ConsumerRecord<Bytes, Bytes>> records\n+    ) {\n+      if (Iterables.isEmpty(records)) {\n+        return Optional.empty();\n+      }\n+\n+      final Stream<Bytes> valueStream = StreamSupport\n+          .stream(records.spliterator(), false)\n+          .map(ConsumerRecord::key);\n+\n+      return findFormatter(valueStream);\n+    }\n+\n+    private Optional<Formatter> getValueFormatter(\n+        final Iterable<ConsumerRecord<Bytes, Bytes>> records\n+    ) {\n+      if (Iterables.isEmpty(records)) {\n+        return Optional.empty();\n+      }\n+\n+      final Stream<Bytes> valueStream = StreamSupport\n+          .stream(records.spliterator(), false)\n+          .map(ConsumerRecord::value);\n+\n+      return findFormatter(valueStream);\n+    }\n+\n+    private Optional<Formatter> findFormatter(final Stream<Bytes> dataStream) {\n+      final List<Formatter> formatters = dataStream\n+          .filter(Objects::nonNull)\n+          .filter(d -> d.get() != null)\n+          .map(this::findFormatter)\n+          .collect(Collectors.toList());\n+\n+      final Set<String> formats = formatters.stream()\n+          .map(Formatter::getFormat)\n+          .collect(Collectors.toSet());", "originalCommit": "cc623bebb23bf6393b350381c684121790cc77c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NTc5Mg==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377865792", "bodyText": "Because the format now has more info in it, e.g. KAFKA (STRING).  The (STRING) is additional info.\nHowever, again, this will change in the next PR.", "author": "big-andy-coates", "createdAt": "2020-02-11T19:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MjM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MzA4NA==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377853084", "bodyText": "nit: getKeyFormatName", "author": "agavra", "createdAt": "2020-02-11T19:34:07Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+      if (!keyFormatter.isPresent()) {\n+        keyFormatter = getKeyFormatter(records);\n+      }\n+\n+      if (!valueFormatter.isPresent()) {\n+        valueFormatter = getValueFormatter(records);\n+      }\n+\n+      return StreamSupport.stream(records.spliterator(), false)\n+          .map(this::delayedFormat)\n           .collect(Collectors.toList());\n     }\n \n-    public Format getFormat() {\n-      return formatter == null ? Format.UNDEFINED : formatter.getFormat();\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") // will not be empty if needed\n+    private Supplier<String> delayedFormat(final ConsumerRecord<Bytes, Bytes> record) {\n+      return () -> {\n+        try {\n+          final String rowTime = record.timestamp() == ConsumerRecord.NO_TIMESTAMP\n+              ? \"N/A\"\n+              : dateFormat.format(new Date(record.timestamp()));\n+\n+          final String rowKey = record.key() == null || record.key().get() == null\n+              ? \"<null>\"\n+              : keyFormatter.get().print(record.key());\n+\n+          final String value = record.value() == null || record.value().get() == null\n+              ? \"<null>\"\n+              : valueFormatter.get().print(record.value());\n+\n+          return \"rowtime: \" + rowTime\n+              + \", \" + \"key: \" + rowKey\n+              + \", value: \" + value;\n+        } catch (IOException e) {\n+          log.warn(\"Exception formatting record\", e);\n+          return \"Failed to parse row\";\n+        }\n+      };\n+    }\n+\n+    public String getKeyFormat() {", "originalCommit": "cc623bebb23bf6393b350381c684121790cc77c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NjkxOA==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377866918", "bodyText": "Maybe. Though what's being returned hasn't changed really. Sure it returned an enum before, but the only place that was used changed it to a string.  Now it returns a string containing the details of the format.\nIf it stays in the new code I'll look into the naming.", "author": "big-andy-coates", "createdAt": "2020-02-11T20:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MzA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MzU2OQ==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377853569", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String getFormat();\n          \n          \n            \n                String getFormatName();", "author": "agavra", "createdAt": "2020-02-11T19:35:07Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -52,96 +60,196 @@ private TopicStream() {\n \n     private final KafkaAvroDeserializer avroDeserializer;\n     private final String topicName;\n-    private final DateFormat dateFormat =\n-        SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault());\n+    private final DateFormat dateFormat;\n+\n+    private Optional<Formatter> keyFormatter = Optional.empty();\n+    private Optional<Formatter> valueFormatter = Optional.empty();\n \n-    private Formatter formatter;\n+    public RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName\n+    ) {\n+      this(\n+          schemaRegistryClient,\n+          topicName,\n+          SimpleDateFormat.getDateTimeInstance(3, 1, Locale.getDefault())\n+      );\n+    }\n \n-    public RecordFormatter(final SchemaRegistryClient schemaRegistryClient,\n-                           final String topicName) {\n-      this.topicName = Objects.requireNonNull(topicName, \"topicName\");\n+    @VisibleForTesting\n+    RecordFormatter(\n+        final SchemaRegistryClient schemaRegistryClient,\n+        final String topicName,\n+        final DateFormat dateFormat\n+    ) {\n+      this.topicName = requireNonNull(topicName, \"topicName\");\n       this.avroDeserializer = new KafkaAvroDeserializer(schemaRegistryClient);\n+      this.dateFormat = requireNonNull(dateFormat, \"dateFormat\");\n     }\n \n-    public List<String> format(final ConsumerRecords<String, Bytes> records) {\n-      return StreamSupport\n-          .stream(records.records(topicName).spliterator(), false)\n-          .filter(Objects::nonNull)\n-          .filter(r -> r.value() != null)\n-          .filter(r -> r.value().get() != null)\n-          .filter(r -> r.value().get().length != 0)\n-          .map((record) -> {\n-            if (formatter == null) {\n-              formatter = getFormatter(record);\n-            }\n-            try {\n-              return formatter.print(record);\n-            } catch (IOException e) {\n-              log.warn(\"Exception formatting record\", e);\n-              return null;\n-            }\n-          })\n-          .filter(Objects::nonNull)\n+    public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+      if (!keyFormatter.isPresent()) {\n+        keyFormatter = getKeyFormatter(records);\n+      }\n+\n+      if (!valueFormatter.isPresent()) {\n+        valueFormatter = getValueFormatter(records);\n+      }\n+\n+      return StreamSupport.stream(records.spliterator(), false)\n+          .map(this::delayedFormat)\n           .collect(Collectors.toList());\n     }\n \n-    public Format getFormat() {\n-      return formatter == null ? Format.UNDEFINED : formatter.getFormat();\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\") // will not be empty if needed\n+    private Supplier<String> delayedFormat(final ConsumerRecord<Bytes, Bytes> record) {\n+      return () -> {\n+        try {\n+          final String rowTime = record.timestamp() == ConsumerRecord.NO_TIMESTAMP\n+              ? \"N/A\"\n+              : dateFormat.format(new Date(record.timestamp()));\n+\n+          final String rowKey = record.key() == null || record.key().get() == null\n+              ? \"<null>\"\n+              : keyFormatter.get().print(record.key());\n+\n+          final String value = record.value() == null || record.value().get() == null\n+              ? \"<null>\"\n+              : valueFormatter.get().print(record.value());\n+\n+          return \"rowtime: \" + rowTime\n+              + \", \" + \"key: \" + rowKey\n+              + \", value: \" + value;\n+        } catch (IOException e) {\n+          log.warn(\"Exception formatting record\", e);\n+          return \"Failed to parse row\";\n+        }\n+      };\n+    }\n+\n+    public String getKeyFormat() {\n+      return keyFormatter\n+          .map(Formatter::getFormat)\n+          .orElse(Format.UNDEFINED.toString());\n+    }\n+\n+    public String getValueFormat() {\n+      return valueFormatter\n+          .map(Formatter::getFormat)\n+          .orElse(Format.UNDEFINED.toString());\n+    }\n+\n+    private Optional<Formatter> getKeyFormatter(\n+        final Iterable<ConsumerRecord<Bytes, Bytes>> records\n+    ) {\n+      if (Iterables.isEmpty(records)) {\n+        return Optional.empty();\n+      }\n+\n+      final Stream<Bytes> valueStream = StreamSupport\n+          .stream(records.spliterator(), false)\n+          .map(ConsumerRecord::key);\n+\n+      return findFormatter(valueStream);\n+    }\n+\n+    private Optional<Formatter> getValueFormatter(\n+        final Iterable<ConsumerRecord<Bytes, Bytes>> records\n+    ) {\n+      if (Iterables.isEmpty(records)) {\n+        return Optional.empty();\n+      }\n+\n+      final Stream<Bytes> valueStream = StreamSupport\n+          .stream(records.spliterator(), false)\n+          .map(ConsumerRecord::value);\n+\n+      return findFormatter(valueStream);\n+    }\n+\n+    private Optional<Formatter> findFormatter(final Stream<Bytes> dataStream) {\n+      final List<Formatter> formatters = dataStream\n+          .filter(Objects::nonNull)\n+          .filter(d -> d.get() != null)\n+          .map(this::findFormatter)\n+          .collect(Collectors.toList());\n+\n+      final Set<String> formats = formatters.stream()\n+          .map(Formatter::getFormat)\n+          .collect(Collectors.toSet());\n+\n+      switch (formats.size()) {\n+        case 0:\n+          // No viable records (will try again with next batch):\n+          return Optional.empty();\n+\n+        case 1:\n+          // Single format:\n+          return Optional.of(formatters.get(0));\n+\n+        default:\n+          // Mixed format topic:\n+          return Format.MIXED.maybeGetFormatter(topicName, null, avroDeserializer);\n+      }\n     }\n \n-    private Formatter getFormatter(final ConsumerRecord<String, Bytes> record) {\n+    private Formatter findFormatter(final Bytes data) {\n       return Arrays.stream(Format.values())\n-          .map(f -> f.maybeGetFormatter(topicName, record, avroDeserializer, dateFormat))\n+          .map(f -> f.maybeGetFormatter(topicName, data, avroDeserializer))\n           .filter(Optional::isPresent)\n           .map(Optional::get)\n           .findFirst()\n-          .orElseThrow(() -> new RuntimeException(\"Unexpected\"));\n+          .orElseThrow(() -> new IllegalStateException(\"Unexpected\"));\n     }\n   }\n \n   interface Formatter {\n \n-    String print(ConsumerRecord<String, Bytes> consumerRecord) throws IOException;\n+    String print(Bytes data) throws IOException;\n \n-    Format getFormat();\n+    String getFormat();", "originalCommit": "cc623bebb23bf6393b350381c684121790cc77c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NzA1NQ==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377867055", "bodyText": "As above.", "author": "big-andy-coates", "createdAt": "2020-02-11T20:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1MzU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1NzAyMQ==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377857021", "bodyText": "this comment is a little confusing - so what if they're indistinguishable? Are we returning Optional.empty because we'd rather default to DELIMITED than \"inline\" JSON?", "author": "agavra", "createdAt": "2020-02-11T19:41:40Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStream.java", "diffHunk": "@@ -150,87 +258,128 @@ public Format getFormat() {\n       @Override\n       public Optional<Formatter> maybeGetFormatter(\n           final String topicName,\n-          final ConsumerRecord<String, Bytes> record,\n-          final KafkaAvroDeserializer avroDeserializer,\n-          final DateFormat dateFormat) {\n+          final Bytes data,\n+          final KafkaAvroDeserializer avroDeserializer\n+      ) {\n         try {\n-          final JsonNode jsonNode = JsonMapper.INSTANCE.mapper.readTree(record.value().toString());\n+          final JsonNode jsonNode = JsonMapper.INSTANCE.mapper.readTree(data.toString());\n \n-          // If the JsonNode is not structured like 'key:value', then do not use JSON to print\n-          // this value\n-          if (!(jsonNode instanceof ObjectNode)) {\n+          if (!(jsonNode instanceof ObjectNode) && !(jsonNode instanceof ArrayNode)) {\n+            // Other valid JSON types, e.g. NumericNode, BooleanNode, etc\n+            // are indistinguishable from single column delimited format:", "originalCommit": "cc623bebb23bf6393b350381c684121790cc77c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2NzQ0Mg==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377867442", "bodyText": "If this stays in the next version I'll add more info. However, I don't think it will be.", "author": "big-andy-coates", "createdAt": "2020-02-11T20:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1NzAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1ODc1Nw==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377858757", "bodyText": "is it possible that the format has changed between last time we did a format and now (e.g. first few records happened to deserialize as JSON, but actually it was KAFKA or something like that)? if so should we print it again?", "author": "agavra", "createdAt": "2020-02-11T19:44:57Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStreamWriter.java", "diffHunk": "@@ -60,59 +62,66 @@ public static TopicStreamWriter create(\n             serviceContext,\n             consumerProperties,\n             printTopic),\n-        printTopic.getTopic().toString(),\n+        printTopic.getTopic(),\n         printTopic.getIntervalValue(),\n         disconnectCheckInterval,\n         printTopic.getLimit());\n   }\n \n   TopicStreamWriter(\n       final SchemaRegistryClient schemaRegistryClient,\n-      final KafkaConsumer<String, Bytes> topicConsumer,\n+      final KafkaConsumer<Bytes, Bytes> topicConsumer,\n       final String topicName,\n       final long interval,\n       final Duration disconnectCheckInterval,\n       final OptionalInt limit\n   ) {\n-    this.topicConsumer = topicConsumer;\n-    this.schemaRegistryClient = schemaRegistryClient;\n-    this.topicName = topicName;\n+    this.topicConsumer = requireNonNull(topicConsumer, \"topicConsumer\");\n+    this.schemaRegistryClient = requireNonNull(schemaRegistryClient, \"schemaRegistryClient\");\n+    this.topicName = requireNonNull(topicName, \"topicName\");\n     this.interval = interval;\n-    this.limit = limit;\n-    this.disconnectCheckInterval = Objects\n-        .requireNonNull(disconnectCheckInterval, \"disconnectCheckInterval\");\n-\n+    this.limit = requireNonNull(limit, \"limit\");\n+    this.disconnectCheckInterval =\n+        requireNonNull(disconnectCheckInterval, \"disconnectCheckInterval\");\n     this.messagesWritten = 0;\n     this.messagesPolled = 0;\n+\n+    if (interval < 1) {\n+      throw new IllegalArgumentException(\"INTERVAL must be greater than one, but was: \" + interval);\n+    }\n   }\n \n   @Override\n   public void write(final OutputStream out) {\n     try {\n       final RecordFormatter formatter = new RecordFormatter(schemaRegistryClient, topicName);\n+\n       boolean printFormat = true;\n       while (true) {\n-        final ConsumerRecords<String, Bytes> records = topicConsumer.poll(disconnectCheckInterval);\n+        final ConsumerRecords<Bytes, Bytes> records = topicConsumer.poll(disconnectCheckInterval);\n         if (records.isEmpty()) {\n-          out.write(\"\\n\".getBytes(StandardCharsets.UTF_8));\n+          out.write(\"\\n\".getBytes(UTF_8));\n           out.flush();\n-        } else {\n-          final List<String> values = formatter.format(records);\n-          for (final String value : values) {\n-            if (printFormat) {\n-              printFormat = false;\n-              out.write((\"Format:\" + formatter.getFormat().name() + \"\\n\")\n-                            .getBytes(StandardCharsets.UTF_8));\n-            }\n-            if (messagesPolled++ % interval == 0) {\n-              messagesWritten++;\n-              out.write(value.getBytes(StandardCharsets.UTF_8));\n-              out.flush();\n-            }\n+          continue;\n+        }\n+\n+        final List<Supplier<String>> values = formatter.format(records.records(topicName));\n+        for (final Supplier<String> value : values) {\n+          if (printFormat) {", "originalCommit": "cc623bebb23bf6393b350381c684121790cc77c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2ODU0MQ==", "url": "https://github.com/confluentinc/ksql/pull/4507#discussion_r377868541", "bodyText": "That's not how it works.\nThe formatter previously based its choice of format on the first record and then stuck with that. The new version improves this slightly by looking at the first batch of records. However, once the format is detected its never changed.\nThis boolean hasn't changed either. It just ensures the format is output before the first row of data.\nAgain, as discussed offline, this is also changing in the next verison.", "author": "big-andy-coates", "createdAt": "2020-02-11T20:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1ODc1Nw=="}], "type": "inlineReview"}]}