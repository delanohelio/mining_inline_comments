{"pr_number": 4889, "pr_title": "fix: If startup hangs (esp on preconditions), shutdown server correctly", "pr_createdAt": "2020-03-24T23:08:30Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4889", "timeline": [{"oid": "bc2092cd983c4825962a94c434d85b28aea2a86b", "url": "https://github.com/confluentinc/ksql/commit/bc2092cd983c4825962a94c434d85b28aea2a86b", "message": "fix: If startup hangs (esp on preconditions), shutdown server correctly", "committedDate": "2020-03-24T22:57:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MTMzMA==", "url": "https://github.com/confluentinc/ksql/pull/4889#discussion_r398461330", "bodyText": "Why are we using a checked exception here?  We don't really use checked exceptions any more. They're a PITA! Why not extend KsqlServerException?", "author": "big-andy-coates", "createdAt": "2020-03-26T10:22:13Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -391,6 +404,13 @@ private KsqlFailedPrecondition(final String message) {\n     }\n   }\n \n+  static final class AbortApplicationStartException extends Exception {", "originalCommit": "bc2092cd983c4825962a94c434d85b28aea2a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4MzU5OA==", "url": "https://github.com/confluentinc/ksql/pull/4889#discussion_r398883598", "bodyText": "Sure.  Extended KsqlServerException.", "author": "AlanConfluent", "createdAt": "2020-03-26T20:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MTMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MzEyOQ==", "url": "https://github.com/confluentinc/ksql/pull/4889#discussion_r398463129", "bodyText": "nit: Rather than taking a AtomicBoolean, why not take a Supplier<Boolean>?  The latter is more general and flexible, allowing method that returns a boolean to be used.\nYou can then wire this up by passing stopRetrying::get.", "author": "big-andy-coates", "createdAt": "2020-03-26T10:25:09Z", "path": "ksqldb-common/src/main/java/io/confluent/ksql/util/RetryUtil.java", "diffHunk": "@@ -53,6 +55,7 @@ public static void retryWithBackoff(\n       final int initialWaitMs,\n       final int maxWaitMs,\n       final Runnable runnable,\n+      final AtomicBoolean stopRetrying,", "originalCommit": "bc2092cd983c4825962a94c434d85b28aea2a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5MTIyNg==", "url": "https://github.com/confluentinc/ksql/pull/4889#discussion_r398891226", "bodyText": "Good suggestion.", "author": "AlanConfluent", "createdAt": "2020-03-26T21:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MzEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2NTY1Ng==", "url": "https://github.com/confluentinc/ksql/pull/4889#discussion_r398465656", "bodyText": "You can do this with less code with:\nassertThrows(\n   RuntimeException.class,\n   () -> RetryUtil.retryWithBackoff(3, 1, 100, runnable, sleep, stopRetrying, Collections.emptyList())\n);", "author": "big-andy-coates", "createdAt": "2020-03-26T10:29:20Z", "path": "ksqldb-common/src/test/java/io/confluent/ksql/util/RetryUtilTest.java", "diffHunk": "@@ -80,4 +85,27 @@ public void shouldThrowPassThroughExceptions() {\n     }\n     verify(runnable, times(1)).run();\n   }\n+\n+  @Test\n+  public void shouldRespectStopRetrying() {\n+    doThrow(new RuntimeException(\"error\")).when(runnable).run();\n+    int[] times = new int[1];\n+    doAnswer(invocationOnMock -> {\n+      // Interrupts on the 2nd sleep\n+      if (times[0]++ == 1) {\n+        stopRetrying.set(true);\n+      }\n+      return null;\n+    }).when(sleep).accept(any());\n+    try {\n+      RetryUtil.retryWithBackoff(3, 1, 100, runnable, sleep, stopRetrying, Collections.emptyList());\n+      fail(\"retry should have thrown\");\n+    } catch (final RuntimeException e) {\n+    }", "originalCommit": "bc2092cd983c4825962a94c434d85b28aea2a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5NTM5OQ==", "url": "https://github.com/confluentinc/ksql/pull/4889#discussion_r398895399", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-03-26T21:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2NTY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2NzEzNQ==", "url": "https://github.com/confluentinc/ksql/pull/4889#discussion_r398467135", "bodyText": "This message seems a little confusing. It's an error, but the text sounds more like a success...  maybe\nlog.error(\"Failed to meet preconditions. Existing...\", e);", "author": "big-andy-coates", "createdAt": "2020-03-26T10:31:45Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -404,17 +424,27 @@ private void checkPreconditions() {\n     }\n   }\n \n-  private void waitForPreconditions() {\n+  private void waitForPreconditions() throws AbortApplicationStartException {\n     final List<Predicate<Exception>> predicates = ImmutableList.of(\n         e -> !(e instanceof KsqlFailedPrecondition)\n     );\n-    RetryUtil.retryWithBackoff(\n-        Integer.MAX_VALUE,\n-        1000,\n-        30000,\n-        this::checkPreconditions,\n-        predicates\n-    );\n+    try {\n+      RetryUtil.retryWithBackoff(\n+          Integer.MAX_VALUE,\n+          1000,\n+          30000,\n+          this::checkPreconditions,\n+          shuttingDown,\n+          predicates\n+      );\n+    } catch (KsqlFailedPrecondition e) {\n+      log.error(\"Finished Precondition retrying\", e);", "originalCommit": "bc2092cd983c4825962a94c434d85b28aea2a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4NDU0OQ==", "url": "https://github.com/confluentinc/ksql/pull/4889#discussion_r398884549", "bodyText": "Yeah, I agree.  Changed.", "author": "AlanConfluent", "createdAt": "2020-03-26T20:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2NzEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2OTQwNA==", "url": "https://github.com/confluentinc/ksql/pull/4889#discussion_r398469404", "bodyText": "If we're interrupting the start up thread, then there's a high chance we'll see interrupt exceptions being thrown. Yet I don't see anywhere that we catch this, now expected, exception.  This may lead to the exception being logged out, which isn't ideal if its expected.\nMaybe the code in startAsync need to also catch interrupted exceptions and log out the Aborting application start?", "author": "big-andy-coates", "createdAt": "2020-03-26T10:35:25Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -456,6 +486,13 @@ private void initialize(final KsqlConfig configWithApplicationServer) {\n   @SuppressWarnings(\"checkstyle:NPathComplexity\")\n   @Override\n   public void triggerShutdown() {\n+    // First, make sure the server wasn't stuck in startup.  Set the shutdown flag and interrupt the\n+    // startup thread if it's been hanging.\n+    shuttingDown.set(true);\n+    if (startAsyncThread != null) {\n+      startAsyncThread.interrupt();", "originalCommit": "bc2092cd983c4825962a94c434d85b28aea2a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5MDM3OA==", "url": "https://github.com/confluentinc/ksql/pull/4889#discussion_r398890378", "bodyText": "In this particular case, it's caught in RetryUtil:\nduration -> {\n          try {\n            Thread.sleep(duration);\n          } catch (final InterruptedException e) {\n            log.debug(\"retryWithBackoff interrupted while sleeping\");\n          }\n        },\n\nI believe it would only throw this exception if someone did something that could be interrupted (like sleeping), and since it's a checked exception, they would have to catch it explicitly (or let it bubble up explicitly).  In this case, I would want them to catch it and then throw a AbortApplicationStartException which is already handled.  So I don't think catching InterruptedExceptions at the startAsync level would be required.  Is that reasonable?", "author": "AlanConfluent", "createdAt": "2020-03-26T21:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2OTQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2OTY5OA==", "url": "https://github.com/confluentinc/ksql/pull/4889#discussion_r398469698", "bodyText": "If we make AbortApplicationStartException a non-checked exception we can drop all these throws...", "author": "big-andy-coates", "createdAt": "2020-03-26T10:35:55Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/KsqlRestApplicationTest.java", "diffHunk": "@@ -415,7 +421,7 @@ public void shouldNotInitializeUntilPreconditionsChecked() {\n   }\n \n   @Test\n-  public void shouldConfigureRocksDBConfigSetter() {\n+  public void shouldConfigureRocksDBConfigSetter() throws AbortApplicationStartException {", "originalCommit": "bc2092cd983c4825962a94c434d85b28aea2a86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5MDY0Ng==", "url": "https://github.com/confluentinc/ksql/pull/4889#discussion_r398890646", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-03-26T21:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2OTY5OA=="}], "type": "inlineReview"}]}