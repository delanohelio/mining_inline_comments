{"pr_number": 4713, "pr_title": "feat: Integrate new API with existing security framework", "pr_createdAt": "2020-03-05T16:19:33Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4713", "timeline": [{"oid": "43fcb0b5c8c64a56d7233c1ac98d4682c2b9d36c", "url": "https://github.com/confluentinc/ksql/commit/43fcb0b5c8c64a56d7233c1ac98d4682c2b9d36c", "message": "integrate security", "committedDate": "2020-03-05T16:28:43Z", "type": "forcePushed"}, {"oid": "5918afe08a95504f057f028d50f97e5c453d6d4f", "url": "https://github.com/confluentinc/ksql/commit/5918afe08a95504f057f028d50f97e5c453d6d4f", "message": "integrate security", "committedDate": "2020-03-06T06:29:04Z", "type": "commit"}, {"oid": "2360124cfa7f68d8b008f32a57d1ebb8dd689696", "url": "https://github.com/confluentinc/ksql/commit/2360124cfa7f68d8b008f32a57d1ebb8dd689696", "message": "integrate security", "committedDate": "2020-03-06T06:29:04Z", "type": "commit"}, {"oid": "981f3181da09eba3d75e08684076b5d073aa3baa", "url": "https://github.com/confluentinc/ksql/commit/981f3181da09eba3d75e08684076b5d073aa3baa", "message": "integrate security", "committedDate": "2020-03-06T11:13:25Z", "type": "commit"}, {"oid": "981f3181da09eba3d75e08684076b5d073aa3baa", "url": "https://github.com/confluentinc/ksql/commit/981f3181da09eba3d75e08684076b5d073aa3baa", "message": "integrate security", "committedDate": "2020-03-06T11:13:25Z", "type": "forcePushed"}, {"oid": "e574c5832423bf1759174f4dff29bd22c0785511", "url": "https://github.com/confluentinc/ksql/commit/e574c5832423bf1759174f4dff29bd22c0785511", "message": "auth tests", "committedDate": "2020-03-06T12:52:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNzUzMg==", "url": "https://github.com/confluentinc/ksql/pull/4713#discussion_r389207532", "bodyText": "Why does the filter complete successfully if the user is null? That seems like reason to fail since it means no user was authenticated.", "author": "vcrfxia", "createdAt": "2020-03-07T00:46:25Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/api/auth/KsqlAuthorizationFilter.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.auth;\n+\n+import io.confluent.ksql.security.KsqlAuthorizationProvider;\n+import io.vertx.core.Handler;\n+import io.vertx.core.WorkerExecutor;\n+import io.vertx.ext.auth.User;\n+import io.vertx.ext.web.RoutingContext;\n+import java.security.Principal;\n+\n+public class KsqlAuthorizationFilter implements Handler<RoutingContext> {\n+\n+  private final WorkerExecutor workerExecutor;\n+  private final KsqlAuthorizationProvider ksqlAuthorizationProvider;\n+\n+  public KsqlAuthorizationFilter(final WorkerExecutor workerExecutor,\n+      final KsqlAuthorizationProvider ksqlAuthorizationProvider) {\n+    this.workerExecutor = workerExecutor;\n+    this.ksqlAuthorizationProvider = ksqlAuthorizationProvider;\n+  }\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+\n+    workerExecutor.executeBlocking(\n+        promise -> {\n+          final User user = routingContext.user();\n+          if (user == null) {\n+            promise.complete();", "originalCommit": "e574c5832423bf1759174f4dff29bd22c0785511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0MzE1OA==", "url": "https://github.com/confluentinc/ksql/pull/4713#discussion_r389243158", "bodyText": "Authentication come before the authorization here. In the case the user failed authentication then a 401 will be returned and this won't be executed.\nIf the user passes authentication a User object will be created and set on the routing context.\nIn the case there is no authentication enabled, the user will be null and there will be no authorization either.", "author": "purplefox", "createdAt": "2020-03-07T10:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNzUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2MTg0NQ==", "url": "https://github.com/confluentinc/ksql/pull/4713#discussion_r389261845", "bodyText": "In the case there is no authentication enabled, the user will be null and there will be no authorization either.\n\nBut the filter is only set if authentication is enabled, which seems like a sound model (in terms of expected usage of the filter) going forward as well. As in, if I were writing an application and plugged in an authorization module, I'd expect it to fail for an unauthenticated user. Is that not standard?", "author": "vcrfxia", "createdAt": "2020-03-07T15:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNzUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1NDQ0NQ==", "url": "https://github.com/confluentinc/ksql/pull/4713#discussion_r389354445", "bodyText": "I actually changed this in the next PR :)", "author": "purplefox", "createdAt": "2020-03-08T10:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNzUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNzU3MA==", "url": "https://github.com/confluentinc/ksql/pull/4713#discussion_r389207570", "bodyText": "Should this return 403 instead?", "author": "vcrfxia", "createdAt": "2020-03-07T00:46:38Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/api/auth/KsqlAuthorizationFilter.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.auth;\n+\n+import io.confluent.ksql.security.KsqlAuthorizationProvider;\n+import io.vertx.core.Handler;\n+import io.vertx.core.WorkerExecutor;\n+import io.vertx.ext.auth.User;\n+import io.vertx.ext.web.RoutingContext;\n+import java.security.Principal;\n+\n+public class KsqlAuthorizationFilter implements Handler<RoutingContext> {\n+\n+  private final WorkerExecutor workerExecutor;\n+  private final KsqlAuthorizationProvider ksqlAuthorizationProvider;\n+\n+  public KsqlAuthorizationFilter(final WorkerExecutor workerExecutor,\n+      final KsqlAuthorizationProvider ksqlAuthorizationProvider) {\n+    this.workerExecutor = workerExecutor;\n+    this.ksqlAuthorizationProvider = ksqlAuthorizationProvider;\n+  }\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+\n+    workerExecutor.executeBlocking(\n+        promise -> {\n+          final User user = routingContext.user();\n+          if (user == null) {\n+            promise.complete();\n+            return;\n+          }\n+          final Principal principal = new ApiPrincipal(user.principal().getString(\"username\"));\n+          try {\n+            ksqlAuthorizationProvider\n+                .checkEndpointAccess(principal, routingContext.request().method().toString(),\n+                    routingContext.normalisedPath());\n+          } catch (Exception e) {\n+            promise.fail(e);\n+            return;\n+          }\n+          promise.complete();\n+        },\n+        ar -> {\n+          if (ar.succeeded()) {\n+            routingContext.next();\n+          } else {\n+            routingContext.fail(401, ar.cause());", "originalCommit": "e574c5832423bf1759174f4dff29bd22c0785511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0MzE5Ng==", "url": "https://github.com/confluentinc/ksql/pull/4713#discussion_r389243196", "bodyText": "You're right :) I think I already made this change (along with some others along the same lines) in the next PR.", "author": "purplefox", "createdAt": "2020-03-07T10:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNzU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNzk3OA==", "url": "https://github.com/confluentinc/ksql/pull/4713#discussion_r389207978", "bodyText": "Love the refactor of proxy client and target handling from this file into ProxyHandler -- much cleaner! Thanks :)", "author": "vcrfxia", "createdAt": "2020-03-07T00:49:16Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -49,26 +46,25 @@\n   private final Endpoints endpoints;\n   private final HttpServerOptions httpServerOptions;\n   private final Server server;\n-  private final boolean proxyEnabled;\n+  private final ProxyHandler proxyHandler;\n   private ConnectionQueryManager connectionQueryManager;\n   private volatile HttpServer httpServer;\n \n-  private HttpClient proxyClient;\n-  private SocketAddress proxyTarget;\n-\n   public ServerVerticle(final Endpoints endpoints, final HttpServerOptions httpServerOptions,\n       final Server server, final boolean proxyEnabled) {\n     this.endpoints = Objects.requireNonNull(endpoints);\n     this.httpServerOptions = Objects.requireNonNull(httpServerOptions);\n     this.server = Objects.requireNonNull(server);\n-    this.proxyEnabled = proxyEnabled;\n+    if (proxyEnabled) {\n+      this.proxyHandler = new ProxyHandler(server);\n+    } else {\n+      this.proxyHandler = null;\n+    }\n   }\n \n   @Override\n   public void start(final Promise<Void> startPromise) {\n-    this.proxyClient = proxyEnabled ? vertx", "originalCommit": "e574c5832423bf1759174f4dff29bd22c0785511", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNzk5NQ==", "url": "https://github.com/confluentinc/ksql/pull/4713#discussion_r389207995", "bodyText": "Interesting that these three tests are essentially duplicates of super.shouldExecutePullQuery(); (and similar) but I can't think of an easy way to get the last assertion in there without the duplication.\nHappy to leave this as is, just thinking -out loud- on a screen.", "author": "vcrfxia", "createdAt": "2020-03-07T00:49:22Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/api/AuthTest.java", "diffHunk": "@@ -137,6 +175,60 @@ public void shouldFailInsertRequestWithIncorrectRole() throws Exception {\n     shouldFailInsertRequest(USER_WITH_INCORRECT_ROLE, USER_WITH_INCORRECT_ROLE_PWD);\n   }\n \n+  @Test\n+  public void shouldExecutePullQueryWithApiSecurityContext() throws Exception {", "originalCommit": "e574c5832423bf1759174f4dff29bd22c0785511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0MzM2Nw==", "url": "https://github.com/confluentinc/ksql/pull/4713#discussion_r389243367", "bodyText": "Yeah, I'm not super happy about it either. I think we need to think about how we can tidy up / find a better way of reusing tests in different contexts.\nAnother possibility is we extract the tests we want to reuse into a different class and call it directly from the concrete test class - i.e. use composition instead of relying on inheritance.", "author": "purplefox", "createdAt": "2020-03-07T10:04:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNzk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODA1MA==", "url": "https://github.com/confluentinc/ksql/pull/4713#discussion_r389208050", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private void shouldNotAllowAccessifPermissionCheckThrowsException(\n          \n          \n            \n              private void shouldNotAllowAccessIfPermissionCheckThrowsException(\n          \n      \n    \n    \n  \n\nsuper nit: typo", "author": "vcrfxia", "createdAt": "2020-03-07T00:49:47Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/api/AuthTest.java", "diffHunk": "@@ -215,4 +307,50 @@ private void shouldFailInsertRequest(final String username, final String passwor\n     request.sendBuffer(requestBody, requestFuture);\n     return requestFuture.get();\n   }\n+\n+  private void assertAuthorisedSecurityContext(String username) {\n+    assertThat(testEndpoints.getLastApiSecurityContext(), is(notNullValue()));\n+    assertThat(testEndpoints.getLastApiSecurityContext().getPrincipal().isPresent(), is(true));\n+    assertThat(testEndpoints.getLastApiSecurityContext().getPrincipal().get().getName(),\n+        is(username));\n+  }\n+\n+  private void shouldAllowAccessWithPermissionCheck(final String expectedUser,\n+      final String expectedMethod, final String expectedPath,\n+      final ExceptionThrowingRunnable action) throws Exception {\n+    stopServer();\n+    stopClient();\n+    AtomicReference<Principal> principalAtomicReference = new AtomicReference<>();\n+    AtomicReference<String> methodAtomicReference = new AtomicReference<>();\n+    AtomicReference<String> pathAtomicReference = new AtomicReference<>();\n+    this.authorizationProvider = (user, method, path) -> {\n+      principalAtomicReference.set(user);\n+      methodAtomicReference.set(method);\n+      pathAtomicReference.set(path);\n+    };\n+    createServer(createServerConfig());\n+    client = createClient();\n+    action.run();\n+    assertThat(principalAtomicReference.get().getName(), is(expectedUser));\n+    assertThat(methodAtomicReference.get(), is(expectedMethod));\n+    assertThat(pathAtomicReference.get(), is(expectedPath));\n+  }\n+\n+  private void shouldNotAllowAccessifPermissionCheckThrowsException(", "originalCommit": "e574c5832423bf1759174f4dff29bd22c0785511", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODI1MQ==", "url": "https://github.com/confluentinc/ksql/pull/4713#discussion_r389208251", "bodyText": "Having a single AuthTest file rather than separate test files for basic auth and the authorization filter seems fine for now but I wonder how this file will scale as we add other auth mechanisms. Don't see a great way to split them apart so I'm inclined to leave this for now, though I am curious if you have thoughts on how to scale these auth tests going forward.", "author": "vcrfxia", "createdAt": "2020-03-07T00:51:09Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/api/AuthTest.java", "diffHunk": "@@ -35,9 +45,9 @@\n import org.slf4j.LoggerFactory;\n \n @RunWith(CoreApiTestRunner.class)\n-public class BasicAuthTest extends ApiTest {\n+public class AuthTest extends ApiTest {", "originalCommit": "e574c5832423bf1759174f4dff29bd22c0785511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0MzM4OA==", "url": "https://github.com/confluentinc/ksql/pull/4713#discussion_r389243388", "bodyText": "Agreed, as per previous comment :)", "author": "purplefox", "createdAt": "2020-03-07T10:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODI1MQ=="}], "type": "inlineReview"}, {"oid": "89e9b40de6333a76b5b7c7be445bf633ed126ac0", "url": "https://github.com/confluentinc/ksql/commit/89e9b40de6333a76b5b7c7be445bf633ed126ac0", "message": "fixed typo in test", "committedDate": "2020-03-07T10:07:14Z", "type": "commit"}, {"oid": "5c5dde54dcba06dd13adadfb2432777b3100abd2", "url": "https://github.com/confluentinc/ksql/commit/5c5dde54dcba06dd13adadfb2432777b3100abd2", "message": "fixed flaky test", "committedDate": "2020-03-07T10:49:42Z", "type": "commit"}]}