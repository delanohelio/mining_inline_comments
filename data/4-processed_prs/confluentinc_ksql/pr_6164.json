{"pr_number": 6164, "pr_title": "feat: CommandRunner enters degraded state when corruption detected in metastore", "pr_createdAt": "2020-09-08T17:43:19Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6164", "timeline": [{"oid": "f9fb5a9ed42973250f92c3ded0cf110527a6493b", "url": "https://github.com/confluentinc/ksql/commit/f9fb5a9ed42973250f92c3ded0cf110527a6493b", "message": "test commit", "committedDate": "2020-09-09T18:08:34Z", "type": "forcePushed"}, {"oid": "e6a8fb6438be7978fb56d9c22035d29c63c4a3ff", "url": "https://github.com/confluentinc/ksql/commit/e6a8fb6438be7978fb56d9c22035d29c63c4a3ff", "message": "refactor", "committedDate": "2020-09-09T22:55:14Z", "type": "forcePushed"}, {"oid": "2ec47d4e8c36c34ea632e008e0bf39524af93d6d", "url": "https://github.com/confluentinc/ksql/commit/2ec47d4e8c36c34ea632e008e0bf39524af93d6d", "message": "refactor", "committedDate": "2020-09-10T16:40:49Z", "type": "forcePushed"}, {"oid": "e294016e7fb5b1be4cc7e03ea2a2907eaefa116c", "url": "https://github.com/confluentinc/ksql/commit/e294016e7fb5b1be4cc7e03ea2a2907eaefa116c", "message": "refactor", "committedDate": "2020-09-10T18:40:00Z", "type": "forcePushed"}, {"oid": "e8b51f7d6858d4edcdf19473e0e3e337caf71d24", "url": "https://github.com/confluentinc/ksql/commit/e8b51f7d6858d4edcdf19473e0e3e337caf71d24", "message": "refactor", "committedDate": "2020-09-11T00:02:23Z", "type": "forcePushed"}, {"oid": "853d09381c3f11f1aa79fd10615d92241c33eeea", "url": "https://github.com/confluentinc/ksql/commit/853d09381c3f11f1aa79fd10615d92241c33eeea", "message": "refactor", "committedDate": "2020-09-11T07:17:38Z", "type": "forcePushed"}, {"oid": "d6552e437eac3af84fdef1a4649d1cf7f813110f", "url": "https://github.com/confluentinc/ksql/commit/d6552e437eac3af84fdef1a4649d1cf7f813110f", "message": "refactor", "committedDate": "2020-09-11T19:37:12Z", "type": "forcePushed"}, {"oid": "a707f5043d8b988de942045fa3079e8fda0ec7a3", "url": "https://github.com/confluentinc/ksql/commit/a707f5043d8b988de942045fa3079e8fda0ec7a3", "message": "refactor", "committedDate": "2020-09-11T23:01:02Z", "type": "forcePushed"}, {"oid": "20d4787572a5d47610a7f55f222942d83a04a67a", "url": "https://github.com/confluentinc/ksql/commit/20d4787572a5d47610a7f55f222942d83a04a67a", "message": "refactor", "committedDate": "2020-09-11T23:54:38Z", "type": "forcePushed"}, {"oid": "d51e6e1c1b74502411dc3442890f55fe192ff347", "url": "https://github.com/confluentinc/ksql/commit/d51e6e1c1b74502411dc3442890f55fe192ff347", "message": "refactor", "committedDate": "2020-09-12T00:13:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzOTE2Mg==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r491239162", "bodyText": "I think it's best to just early exit if we see that there's corruption, instead of calling backupRecord again. I know it's safe to keep calling backupRecord, but generally when we see that the current state isn't what we expect it's best to just bail. So I'd rewrite this as:\nfor (ConsumerRecord<byte[], []> r : iterable) {\n    backupRecord(r);\n    if (commandTopicBackup.commandTopicCorruption()) {\n        return records;\n    }\n    records.add(record);\n}\nreturn records;", "author": "rodesai", "createdAt": "2020-09-18T23:56:43Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopic.java", "diffHunk": "@@ -79,12 +80,18 @@ public void start() {\n \n   public Iterable<ConsumerRecord<byte[], byte[]>> getNewCommands(final Duration timeout) {\n     final Iterable<ConsumerRecord<byte[], byte[]>> iterable = commandConsumer.poll(timeout);\n+    final List<ConsumerRecord<byte[], byte[]>> records = new ArrayList<>();\n \n     if (iterable != null) {\n-      iterable.forEach(this::backupRecord);\n+      iterable.forEach(record -> {", "originalCommit": "d51e6e1c1b74502411dc3442890f55fe192ff347", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzOTU2Nw==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r491239567", "bodyText": "you could also have backupRecord return a boolean rather than calling commandTopicCorruption() to simplify this a bit.", "author": "rodesai", "createdAt": "2020-09-18T23:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzOTE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzOTg0MQ==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r491239841", "bodyText": "can we condense these 2 into 1 config? if the backup location is set then just enable backups. Also why do we ever want to disable backups?", "author": "rodesai", "createdAt": "2020-09-19T00:00:53Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -656,14 +656,30 @@ static KsqlRestApplication buildApplication(\n \n     final String commandTopicName = ReservedInternalTopics.commandTopic(ksqlConfig);\n \n+    CommandTopicBackup commandTopicBackup = new CommandTopicBackupNoOp();\n+    if (ksqlConfig.getBoolean(KsqlConfig.KSQL_ENABLE_METASTORE_BACKUP)) {\n+      if (ksqlConfig.getString(KsqlConfig.KSQL_METASTORE_BACKUP_LOCATION).isEmpty()) {", "originalCommit": "d51e6e1c1b74502411dc3442890f55fe192ff347", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1NTc3Ng==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492255776", "bodyText": "I've combined the configs now. @spena do you know the scenario for turning off backups?", "author": "stevenpyzhang", "createdAt": "2020-09-21T18:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzOTg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MjUzMQ==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r491242531", "bodyText": "I think all our state tracking logic in this class can be simplified. The current pattern is to set a bunch of booleans and compute status from every request. This logic is getting pretty complex, and we're polluting the interface here with a bunch of status-getting methods (e.g. getStatus, getDegradedReason, getDegradedMsg, etc). I think it would be simpler to just have the command runner explicitly set the status:\npublic static enum CommandRunnerDegradedReason {\n    Function<Errors, String> msgFactory;\n\n    public String getMsg(final Errors errors) {\n        return msgFactory(errors);\n    }\n\n    CommandRunnerDegradedReason(Function<Errors, String> msgFactory) {\n        this.msgFactory = msgFactory;\n    }\n\n    NONE(errors -> \"\"),\n    CORRUPTED(Errors:: commandRunnerDegradedBackupCorruptedErrorMessage),\n    INCOMPATIBLE_COMMAND(Errrors:: commandRunnerDegradedIncompatibleCommandsErrorMessage)\n}\n\npublic static class Status {\n    CommandRunnerStatus state;\n    Optional<CommandRunnerDegradedReason> degradedReason;\n\n    public CommandRunnerStatus getState() {\n        return state;\n    }\n    public CommandRunnerDegradedReason getDegradedReason() {\n        return degradedReason;\n    }\n}\n\nprivate Status state = new Status(RUNNING, Optional.empty());\n\npublic Status getState() {\n    return State; \n} \n\npublic void run() {\n    try {\n        while (!closed) {\n            if (incompatibleCommandDetected) {\n                state = new Status(DEGRADED, Optional.of(INCOMPATIBLE_COMMAND))\n                closeEarly(); \n            }  else if (backup.corrupted()) {\n                state = new Status(DEGRADED, Optional.of(CORRUPTED))\n                closeEarly(); \n            } else {\n                 \u2026\n\u2026", "author": "rodesai", "createdAt": "2020-09-19T00:19:00Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandRunner.java", "diffHunk": "@@ -16,7 +16,9 @@\n package io.confluent.ksql.rest.server.computation;\n \n import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.ksql.rest.Errors;", "originalCommit": "d51e6e1c1b74502411dc3442890f55fe192ff347", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4NDc5Ng==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492384796", "bodyText": "Done", "author": "stevenpyzhang", "createdAt": "2020-09-21T22:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MjUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0Mjc4Ng==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r491242786", "bodyText": "going to remove this?", "author": "rodesai", "createdAt": "2020-09-19T00:20:36Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/KsqlResource.java", "diffHunk": "@@ -280,23 +284,25 @@ public EndpointResponse handleKsqlStatements(\n       );\n \n       LOG.info(\"Processed successfully: \" + request);\n-      addCommandRunnerDegradedWarning(\n+      addCommandRunnerWarning(\n           entities,\n-          errorHandler,\n-          () -> commandRunner.checkCommandRunnerStatus()\n-              == CommandRunner.CommandRunnerStatus.DEGRADED);\n+          commandRunnerWarning);\n       return EndpointResponse.ok(entities);\n     } catch (final KsqlRestException e) {\n       LOG.info(\"Processed unsuccessfully: \" + request + \", reason: \" + e.getMessage());\n+      e.printStackTrace();", "originalCommit": "d51e6e1c1b74502411dc3442890f55fe192ff347", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0Mjk0Nw==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r491242947", "bodyText": "Can we add test cases that ensure that within a batch, we process everything that is valid (so all commands for which the version is valid, and all commands up to the backup corruption point)?", "author": "rodesai", "createdAt": "2020-09-19T00:21:45Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/computation/CommandRunnerTest.java", "diffHunk": "@@ -286,9 +300,32 @@ public void shouldProcessPartialListOfCommandsOnIncomaptibleCommandInFetch() {\n     inOrder.verify(statementExecutor).handleRestore(eq(queuedCommand2));\n \n     assertThat(commandRunner.checkCommandRunnerStatus(), is(CommandRunner.CommandRunnerStatus.DEGRADED));\n+    assertThat(commandRunner.getCommandRunnerDegradedWarning(), is(INCOMPATIBLE_COMMANDS_ERROR_MESSAGE));\n+    assertThat(commandRunner.getCommandRunnerDegradedReason(), is(CommandRunner.CommandRunnerDegradedReason.INCOMPATIBLE_COMMAND));\n     verify(statementExecutor, never()).handleRestore(queuedCommand3);\n   }\n ", "originalCommit": "d51e6e1c1b74502411dc3442890f55fe192ff347", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0OTU2Ng==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492249566", "bodyText": "We're implicitly assuming that commands returned from the CommandStore aren't corrupted.\nI also don't think we're able to have fine tuned corruption detection in CommandRunner. Assuming we did have corrupted commands returned from the CommandStore in the batch, the function to check for corruption doesn't indicate which command is corrupted so all we'd know is that corruption was detected after the batch was fetched.\nThere should be existing tests testing when the incompatibleCommandChecker throws an exception while checking a batch and everything up to the incompatible command is processed by the InteractiveStatementExecutor", "author": "stevenpyzhang", "createdAt": "2020-09-21T18:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0Mjk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0NTIxOA==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r491245218", "bodyText": "passing the backup here leaks an implementation detail of the command topic (that we're using a backup to detect corruption/deletion). Instead, let's extend the CommandStore interface to include a corruptionDetected method that returns a boolean that we use here.", "author": "rodesai", "createdAt": "2020-09-19T00:37:56Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandRunner.java", "diffHunk": "@@ -94,7 +107,9 @@ public CommandRunner(\n       final String ksqlServiceId,\n       final Duration commandRunnerHealthTimeout,\n       final String metricsGroupPrefix,\n-      final Deserializer<Command> commandDeserializer\n+      final Deserializer<Command> commandDeserializer,\n+      final CommandTopicBackup commandTopicBackup,", "originalCommit": "d51e6e1c1b74502411dc3442890f55fe192ff347", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1NTg5MA==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492255890", "bodyText": "done", "author": "stevenpyzhang", "createdAt": "2020-09-21T18:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0NTIxOA=="}], "type": "inlineReview"}, {"oid": "53a47a9a48ad3aa544a908ebb4b26ced31b8385b", "url": "https://github.com/confluentinc/ksql/commit/53a47a9a48ad3aa544a908ebb4b26ced31b8385b", "message": "refactor", "committedDate": "2020-09-21T04:56:50Z", "type": "forcePushed"}, {"oid": "9d93b691e3bfea723183944baebcb2e8b49471ad", "url": "https://github.com/confluentinc/ksql/commit/9d93b691e3bfea723183944baebcb2e8b49471ad", "message": "feedback", "committedDate": "2020-09-21T18:54:12Z", "type": "forcePushed"}, {"oid": "24ccdb738cafa036941c465c7861c4168f46ddf2", "url": "https://github.com/confluentinc/ksql/commit/24ccdb738cafa036941c465c7861c4168f46ddf2", "message": "refactor logic in CommandRunner", "committedDate": "2020-09-21T22:27:05Z", "type": "forcePushed"}, {"oid": "6e8a7e23fb4593c05af86d1809b6389b37a660af", "url": "https://github.com/confluentinc/ksql/commit/6e8a7e23fb4593c05af86d1809b6389b37a660af", "message": "refactor logic in CommandRunner", "committedDate": "2020-09-21T22:33:42Z", "type": "forcePushed"}, {"oid": "a2ea14a9576be082af5f49594a68d4d3071edff6", "url": "https://github.com/confluentinc/ksql/commit/a2ea14a9576be082af5f49594a68d4d3071edff6", "message": "test commit", "committedDate": "2020-09-22T00:19:33Z", "type": "commit"}, {"oid": "776652bf4b6bcbe2c763b3645698140876778a88", "url": "https://github.com/confluentinc/ksql/commit/776652bf4b6bcbe2c763b3645698140876778a88", "message": "refactor", "committedDate": "2020-09-22T00:20:18Z", "type": "commit"}, {"oid": "ca1ec7ebed329596f86a4942c1a1bfc0ef9d37d1", "url": "https://github.com/confluentinc/ksql/commit/ca1ec7ebed329596f86a4942c1a1bfc0ef9d37d1", "message": "feedback", "committedDate": "2020-09-22T00:20:19Z", "type": "commit"}, {"oid": "3733265fac28c09f8c13515f42d419dadec4a0cb", "url": "https://github.com/confluentinc/ksql/commit/3733265fac28c09f8c13515f42d419dadec4a0cb", "message": "refactor logic in CommandRunner", "committedDate": "2020-09-22T00:20:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NjU4Mg==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492486582", "bodyText": "I'd drop these methods and just have 1 get CommandRunnerStatus() method that callers can call to get the current status, and then the caller can pull out the info that is of interest.", "author": "rodesai", "createdAt": "2020-09-22T05:48:23Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandRunner.java", "diffHunk": "@@ -346,14 +354,77 @@ public CommandQueue getCommandQueue() {\n     return commandStore;\n   }\n \n+  public CommandRunnerStatus checkCommandRunnerStatus() {\n+    if (state.getStatus() == CommandRunnerStatus.DEGRADED) {\n+      return CommandRunnerStatus.DEGRADED;\n+    }\n+\n+    final Pair<QueuedCommand, Instant> currentCommand = currentCommandRef.get();\n+    if (currentCommand == null) {\n+      state = lastPollTime.get() == null\n+          || Duration.between(lastPollTime.get(), clock.instant()).toMillis()\n+              < NEW_CMDS_TIMEOUT.toMillis() * 3\n+              ? new Status(CommandRunnerStatus.RUNNING, CommandRunnerDegradedReason.NONE)\n+                  : new Status(CommandRunnerStatus.ERROR, CommandRunnerDegradedReason.NONE);\n+      \n+    } else {\n+      state = Duration.between(currentCommand.right, clock.instant()).toMillis()\n+        < commandRunnerHealthTimeout.toMillis()\n+        ? new Status(CommandRunnerStatus.RUNNING, CommandRunnerDegradedReason.NONE)\n+              : new Status(CommandRunnerStatus.ERROR, CommandRunnerDegradedReason.NONE);\n+    }\n+\n+    return state.getStatus();\n+  }\n+\n+  public CommandRunnerDegradedReason getCommandRunnerDegradedReason() {", "originalCommit": "3733265fac28c09f8c13515f42d419dadec4a0cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4Njk1Ng==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492486956", "bodyText": "nit: move all inner classes to the same place (beginning of the class)", "author": "rodesai", "createdAt": "2020-09-22T05:49:54Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandRunner.java", "diffHunk": "@@ -346,14 +354,77 @@ public CommandQueue getCommandQueue() {\n     return commandStore;\n   }\n \n+  public CommandRunnerStatus checkCommandRunnerStatus() {\n+    if (state.getStatus() == CommandRunnerStatus.DEGRADED) {\n+      return CommandRunnerStatus.DEGRADED;\n+    }\n+\n+    final Pair<QueuedCommand, Instant> currentCommand = currentCommandRef.get();\n+    if (currentCommand == null) {\n+      state = lastPollTime.get() == null\n+          || Duration.between(lastPollTime.get(), clock.instant()).toMillis()\n+              < NEW_CMDS_TIMEOUT.toMillis() * 3\n+              ? new Status(CommandRunnerStatus.RUNNING, CommandRunnerDegradedReason.NONE)\n+                  : new Status(CommandRunnerStatus.ERROR, CommandRunnerDegradedReason.NONE);\n+      \n+    } else {\n+      state = Duration.between(currentCommand.right, clock.instant()).toMillis()\n+        < commandRunnerHealthTimeout.toMillis()\n+        ? new Status(CommandRunnerStatus.RUNNING, CommandRunnerDegradedReason.NONE)\n+              : new Status(CommandRunnerStatus.ERROR, CommandRunnerDegradedReason.NONE);\n+    }\n+\n+    return state.getStatus();\n+  }\n+\n+  public CommandRunnerDegradedReason getCommandRunnerDegradedReason() {\n+    return state.getDegradedReason();\n+  }\n+\n+  public String getCommandRunnerDegradedWarning() {\n+    return getCommandRunnerDegradedReason().getMsg(errorHandler);\n+  }\n+\n+  public static class Status {", "originalCommit": "3733265fac28c09f8c13515f42d419dadec4a0cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "40b014dea8d36512f7550051f3ff38fe36371b49", "url": "https://github.com/confluentinc/ksql/commit/40b014dea8d36512f7550051f3ff38fe36371b49", "message": "refactor logic in CommandRunner", "committedDate": "2020-09-22T17:02:35Z", "type": "commit"}, {"oid": "40b014dea8d36512f7550051f3ff38fe36371b49", "url": "https://github.com/confluentinc/ksql/commit/40b014dea8d36512f7550051f3ff38fe36371b49", "message": "refactor logic in CommandRunner", "committedDate": "2020-09-22T17:02:35Z", "type": "forcePushed"}, {"oid": "a72b6db4a2c29c10d33ab4f18d0dc7067b43f90e", "url": "https://github.com/confluentinc/ksql/commit/a72b6db4a2c29c10d33ab4f18d0dc7067b43f90e", "message": "fix server info resource", "committedDate": "2020-09-22T17:36:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0MTE5MA==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492941190", "bodyText": "I'm not sure if we should remove this config. The idea behind having two configs, one to enable/disable and one to specify the location, was to allow users to disable backups temporary without removing the location. This to ensure users won't incorrectly type the location. KSQL creates the directory if the location doesn't exist.\nAlso, initially I thought of specifying a default backup location, so users would only enable/disable. If we can do this by setting the default to the streams directory, then having the on/off config would be very beneficial.", "author": "spena", "createdAt": "2020-09-22T18:18:29Z", "path": "ksqldb-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -309,12 +309,6 @@\n   public static final String KSQL_CREATE_OR_REPLACE_ENABLED_DOC =\n       \"Feature flag for CREATE OR REPLACE\";\n \n-  public static final String KSQL_ENABLE_METASTORE_BACKUP = \"ksql.enable.metastore.backup\";", "originalCommit": "a72b6db4a2c29c10d33ab4f18d0dc7067b43f90e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk2MTA4MA==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492961080", "bodyText": "They could just comment out the the backup location config to disable temporarily though right?", "author": "stevenpyzhang", "createdAt": "2020-09-22T18:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0MTE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0MjE4MQ==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492942181", "bodyText": "Is this finalCommandTopicBackup necessary? Seems you can use the same commandTopicBackup variable. It will have either the NoOp or the Impl instances.", "author": "spena", "createdAt": "2020-09-22T18:20:15Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -657,14 +657,24 @@ static KsqlRestApplication buildApplication(\n \n     final String commandTopicName = ReservedInternalTopics.commandTopic(ksqlConfig);\n \n+    CommandTopicBackup commandTopicBackup = new CommandTopicBackupNoOp();\n+    if (!ksqlConfig.getString(KsqlConfig.KSQL_METASTORE_BACKUP_LOCATION).isEmpty()) {\n+      commandTopicBackup = new CommandTopicBackupImpl(\n+          ksqlConfig.getString(KsqlConfig.KSQL_METASTORE_BACKUP_LOCATION),\n+          commandTopicName\n+      );\n+    }\n+    final CommandTopicBackup finalCommandTopicBackup = commandTopicBackup;", "originalCommit": "a72b6db4a2c29c10d33ab4f18d0dc7067b43f90e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk2MTExMA==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492961110", "bodyText": "I think that was leftover from when I was passing the backup to the CommandRunner, which was later changed so that CommandRunner checks corruption from the CommandStore instead.\nI'll move this entire chunk of creating the backup back into the CommandStore again", "author": "stevenpyzhang", "createdAt": "2020-09-22T18:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0MjE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0Njc1Mw==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492946753", "bodyText": "Suggestion (up to you to change it):\nShouldn't we use a different term instead of corruption? For me, corruption means something happened in the backup file that cannot be read or deserialized (perhaps due to a file or line corrupted, missing byte or something). But in this case it's just the command topic is missing or the command topic is out of sync with the backup file. Perhaps syncErrorDetected ?\nSame comment about the commandTopicBackup.commandTopicCorruption()", "author": "spena", "createdAt": "2020-09-22T18:27:16Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/CommandStore.java", "diffHunk": "@@ -338,6 +328,11 @@ private long getCommandTopicOffset() {\n     }\n   }\n \n+  @Override\n+  public boolean corruptionDetected() {", "originalCommit": "a72b6db4a2c29c10d33ab4f18d0dc7067b43f90e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0OTU4NQ==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492949585", "bodyText": "Should we log a WARN message here?", "author": "spena", "createdAt": "2020-09-22T18:31:55Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopic.java", "diffHunk": "@@ -79,12 +80,19 @@ public void start() {\n \n   public Iterable<ConsumerRecord<byte[], byte[]>> getNewCommands(final Duration timeout) {\n     final Iterable<ConsumerRecord<byte[], byte[]>> iterable = commandConsumer.poll(timeout);\n+    final List<ConsumerRecord<byte[], byte[]>> records = new ArrayList<>();\n \n     if (iterable != null) {\n-      iterable.forEach(this::backupRecord);\n+      for (ConsumerRecord<byte[], byte[]> record : iterable) {\n+        backupRecord(record);\n+        if (commandTopicBackup.commandTopicCorruption()) {\n+          return records;", "originalCommit": "a72b6db4a2c29c10d33ab4f18d0dc7067b43f90e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0OTY2MA==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492949660", "bodyText": "Should we log a WARN message here?", "author": "spena", "createdAt": "2020-09-22T18:32:04Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopic.java", "diffHunk": "@@ -100,6 +108,10 @@ public void start() {\n       log.debug(\"Received {} records from poll\", records.count());\n       for (final ConsumerRecord<byte[], byte[]> record : records) {\n         backupRecord(record);\n+        \n+        if (commandTopicBackup.commandTopicCorruption()) {\n+          return restoreCommands;", "originalCommit": "a72b6db4a2c29c10d33ab4f18d0dc7067b43f90e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk1MDY5Mw==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492950693", "bodyText": "Can we throw an exception instead of logging this message? We should probably catch the error in the CommandTopic class instead of checking for the sync error. Whoever calls the writeCommandToBackup will know that the issue is not recoverable, so the exception is good to have. A log message is just informative, but the old method was actually doing something with that (i.e. creating a new backup file).", "author": "spena", "createdAt": "2020-09-22T18:33:55Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -147,16 +151,20 @@ public void writeRecord(final ConsumerRecord<byte[], byte[]> record) {\n   }\n \n   void writeCommandToBackup(final ConsumerRecord<CommandId, Command> record) {\n+    if (corruptionDetected) {\n+      LOG.warn(\"Failure to write command topic data to backup. \"", "originalCommit": "a72b6db4a2c29c10d33ab4f18d0dc7067b43f90e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk1MTEwOA==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492951108", "bodyText": "Should't backupRecord throw an exception instead?", "author": "spena", "createdAt": "2020-09-22T18:34:30Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopic.java", "diffHunk": "@@ -79,12 +80,19 @@ public void start() {\n \n   public Iterable<ConsumerRecord<byte[], byte[]>> getNewCommands(final Duration timeout) {\n     final Iterable<ConsumerRecord<byte[], byte[]>> iterable = commandConsumer.poll(timeout);\n+    final List<ConsumerRecord<byte[], byte[]>> records = new ArrayList<>();\n \n     if (iterable != null) {\n-      iterable.forEach(this::backupRecord);\n+      for (ConsumerRecord<byte[], byte[]> record : iterable) {\n+        backupRecord(record);\n+        if (commandTopicBackup.commandTopicCorruption()) {", "originalCommit": "a72b6db4a2c29c10d33ab4f18d0dc7067b43f90e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk1NDA0MQ==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492954041", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.info(\"Previous command topic backup does not match the new command topic data.\");\n          \n          \n            \n                    LOG.warn(\"Backup is out of sync with the current command topic. Backups will not work until the previous command topic is restored or all backup files are deleted (fresh start).\");", "author": "spena", "createdAt": "2020-09-22T18:39:29Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/CommandTopicBackupImpl.java", "diffHunk": "@@ -147,16 +151,20 @@ public void writeRecord(final ConsumerRecord<byte[], byte[]> record) {\n   }\n \n   void writeCommandToBackup(final ConsumerRecord<CommandId, Command> record) {\n+    if (corruptionDetected) {\n+      LOG.warn(\"Failure to write command topic data to backup. \"\n+          + \"Corruption detected in command topic.\");\n+      return;\n+    }\n+\n     if (isRestoring()) {\n       if (isRecordInLatestReplay(record)) {\n         // Ignore backup because record was already replayed\n         return;\n       } else {\n-        LOG.info(\"Previous command topic backup does not match the new command topic data. \"\n-            + \"A new backup file will be created.\");\n-        createNewBackupFile();\n-        latestReplay.clear();\n-        LOG.info(\"New backup file created: {}\", replayFile.getPath());\n+        LOG.info(\"Previous command topic backup does not match the new command topic data.\");", "originalCommit": "a72b6db4a2c29c10d33ab4f18d0dc7067b43f90e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk1NTMwNA==", "url": "https://github.com/confluentinc/ksql/pull/6164#discussion_r492955304", "bodyText": "All backups must be deleted, otherwise ksql won't start because another backup will be out of sync with the command topic.", "author": "spena", "createdAt": "2020-09-22T18:41:38Z", "path": "ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/DefaultErrorMessages.java", "diffHunk": "@@ -19,12 +19,27 @@\n \n public class DefaultErrorMessages implements ErrorMessages {\n \n-  public static final String COMMAND_RUNNER_DEGRADED_ERROR_MESSAGE =\n+  public static final String COMMAND_RUNNER_DEGRADED_INCOMPATIBLE_COMMANDS_ERROR_MESSAGE =\n       \"The server has encountered an incompatible entry in its log \"\n           + \"and cannot process further DDL statements.\"\n           + System.lineSeparator()\n           + \"This is most likely due to the service being rolled back to an earlier version.\";\n \n+  public static final String COMMAND_RUNNER_DEGRADED_BACKUP_CORRUPTED_ERROR_MESSAGE =\n+      \"The server has detected that the command topic may be corrupted. The backup of the \"\n+          + \"command topic does not match the current contents of command topic.\"\n+          + System.lineSeparator()\n+          + \"DDL statements will not be processed until either:\"\n+          + System.lineSeparator()\n+          + \"1. The current command topic is deleted and the backup file is used \"\n+          + \"to restore the command topic.\"\n+          + System.lineSeparator()\n+          + \"2. The current backup file is deleted.\"", "originalCommit": "a72b6db4a2c29c10d33ab4f18d0dc7067b43f90e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}