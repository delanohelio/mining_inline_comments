{"pr_number": 6434, "pr_title": "docs: note PARTITION BY requirement for aggregations (DOCS-5550)", "pr_createdAt": "2020-10-14T22:06:39Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6434", "timeline": [{"oid": "5d2ac03c0248e6cd74fdbfc7b4448098b65baa7e", "url": "https://github.com/confluentinc/ksql/commit/5d2ac03c0248e6cd74fdbfc7b4448098b65baa7e", "message": "docs: note PARTITION BY requirement for aggregations (DOCS-5550)", "committedDate": "2020-10-14T22:05:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAxNjg1OQ==", "url": "https://github.com/confluentinc/ksql/pull/6434#discussion_r505016859", "bodyText": "I think VARCHAR KEY should be removed here. Type and key specification are only for CT/CS statements. Also, single quotes instead of double quotes around 'fixed_key'", "author": "mikebin", "createdAt": "2020-10-14T22:19:19Z", "path": "docs/developer-guide/syntax-reference.md", "diffHunk": "@@ -99,6 +99,31 @@ You can create your own aggregation logic by implementing a User Defined\n Aggregation Function (UDAF). For more information, see\n [UDAFs](../concepts/functions.md#udafs).\n \n+Aggregations return results per partition. To get results across all partitions,\n+you can use PARTITION BY with a fixed key, for example:\n+\n+```sql\n+CREATE STREAM allplaycounts AS\n+  SELECT \"fixed_key\" VARCHAR KEY, COUNT(*) FROM", "originalCommit": "5d2ac03c0248e6cd74fdbfc7b4448098b65baa7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAzNzcxOA==", "url": "https://github.com/confluentinc/ksql/pull/6434#discussion_r505037718", "bodyText": "Instead of \"big bucket (partition)\", maybe just \"partition\"", "author": "mikebin", "createdAt": "2020-10-14T22:47:36Z", "path": "docs/developer-guide/syntax-reference.md", "diffHunk": "@@ -99,6 +99,31 @@ You can create your own aggregation logic by implementing a User Defined\n Aggregation Function (UDAF). For more information, see\n [UDAFs](../concepts/functions.md#udafs).\n \n+Aggregations return results per partition. To get results across all partitions,\n+you can use PARTITION BY with a fixed key, for example:\n+\n+```sql\n+CREATE STREAM allplaycounts AS\n+  SELECT \"fixed_key\" VARCHAR KEY, COUNT(*) FROM\n+    playcountsstream PARTITION BY \"fixed_key\";\n+```\n+\n+Also, you can get results across all partitions as part of the aggregate query,\n+instead of requiring a separate step to partition by a fixed key. In the\n+following example, GROUP BY causes COUNT to aggregate over all records.\n+\n+```sql\n+SELECT 'totalCount', COUNT(*) FROM\n+  ksql_processing_log GROUP BY 'totalCount';\n+```\n+\n+Grouping by a single constant indicates that ksqlDB uses one big bucket", "originalCommit": "5d2ac03c0248e6cd74fdbfc7b4448098b65baa7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAzOTc2OA==", "url": "https://github.com/confluentinc/ksql/pull/6434#discussion_r505039768", "bodyText": "Maybe this whole example with PARTITION BY is no longer needed? Instead, could say\n\nTo get results across all partitions, you can use GROUP BY with a fixed key\n\nand just show the group by example below. Probably best to get input from the ksqlDB team on whether that's reasonable or not.", "author": "mikebin", "createdAt": "2020-10-14T22:50:24Z", "path": "docs/developer-guide/syntax-reference.md", "diffHunk": "@@ -99,6 +99,31 @@ You can create your own aggregation logic by implementing a User Defined\n Aggregation Function (UDAF). For more information, see\n [UDAFs](../concepts/functions.md#udafs).\n \n+Aggregations return results per partition. To get results across all partitions,\n+you can use PARTITION BY with a fixed key, for example:", "originalCommit": "5d2ac03c0248e6cd74fdbfc7b4448098b65baa7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA0MTYxNw==", "url": "https://github.com/confluentinc/ksql/pull/6434#discussion_r505041617", "bodyText": "Maybe instead of\n\nWe recommend this approach even if you're using GROUP BY because otherwise ...\n\nIt could say:\n\nWe recommend this if you're grouping by a fixed key because otherwise ....", "author": "mikebin", "createdAt": "2020-10-14T22:53:10Z", "path": "docs/developer-guide/syntax-reference.md", "diffHunk": "@@ -99,6 +99,31 @@ You can create your own aggregation logic by implementing a User Defined\n Aggregation Function (UDAF). For more information, see\n [UDAFs](../concepts/functions.md#udafs).\n \n+Aggregations return results per partition. To get results across all partitions,\n+you can use PARTITION BY with a fixed key, for example:\n+\n+```sql\n+CREATE STREAM allplaycounts AS\n+  SELECT \"fixed_key\" VARCHAR KEY, COUNT(*) FROM\n+    playcountsstream PARTITION BY \"fixed_key\";\n+```\n+\n+Also, you can get results across all partitions as part of the aggregate query,\n+instead of requiring a separate step to partition by a fixed key. In the\n+following example, GROUP BY causes COUNT to aggregate over all records.\n+\n+```sql\n+SELECT 'totalCount', COUNT(*) FROM\n+  ksql_processing_log GROUP BY 'totalCount';\n+```\n+\n+Grouping by a single constant indicates that ksqlDB uses one big bucket\n+(partition) containing all of the records for the aggregation. If you're\n+creating a persistent query, you can set the partition count of the sink\n+topic to 1 by using WITH(PARTITIONS=1). We recommend this approach even", "originalCommit": "5d2ac03c0248e6cd74fdbfc7b4448098b65baa7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d00f1b1bb403a09f1658982ec54a34b24a9e0a20", "url": "https://github.com/confluentinc/ksql/commit/d00f1b1bb403a09f1658982ec54a34b24a9e0a20", "message": "docs: incorporate feedback", "committedDate": "2020-10-16T21:13:39Z", "type": "commit"}]}