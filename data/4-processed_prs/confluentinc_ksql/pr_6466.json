{"pr_number": 6466, "pr_title": "test: more avro key testing & schema verification", "pr_createdAt": "2020-10-20T01:09:35Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6466", "timeline": [{"oid": "21dcbb9d8cae411990e39e8c340c75eb227bb6e9", "url": "https://github.com/confluentinc/ksql/commit/21dcbb9d8cae411990e39e8c340c75eb227bb6e9", "message": "test: more avro key testing & schema verification", "committedDate": "2020-10-20T01:47:48Z", "type": "forcePushed"}, {"oid": "e35bcd9b660af14579265f0dea9d286ca35b91f7", "url": "https://github.com/confluentinc/ksql/commit/e35bcd9b660af14579265f0dea9d286ca35b91f7", "message": "test: more avro key testing & schema verification", "committedDate": "2020-10-20T03:16:02Z", "type": "commit"}, {"oid": "e35bcd9b660af14579265f0dea9d286ca35b91f7", "url": "https://github.com/confluentinc/ksql/commit/e35bcd9b660af14579265f0dea9d286ca35b91f7", "message": "test: more avro key testing & schema verification", "committedDate": "2020-10-20T03:16:02Z", "type": "forcePushed"}, {"oid": "bbf5a5a93971e0211a5074692e1aca87402d0452", "url": "https://github.com/confluentinc/ksql/commit/bbf5a5a93971e0211a5074692e1aca87402d0452", "message": "chore: suppress checkstyle", "committedDate": "2020-10-20T15:47:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2ODgyNw==", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508668827", "bodyText": "nit: can we move this matcher logic into PostTopicNode, so someone updating PostTopicNode is less likely to forget to update the matcher? The other QTT classes all follow a particular pattern with this, for example: https://github.com/confluentinc/ksql/blob/master/ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/model/SourceNode.java#L114", "author": "vcrfxia", "createdAt": "2020-10-20T16:23:43Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/model/PostConditionsNode.java", "diffHunk": "@@ -133,7 +138,34 @@ Pattern buildBlackList() {\n     @SuppressWarnings(\"unchecked\")\n     Matcher<Iterable<PostTopicNode>> buildTopics() {\n       final Matcher<PostTopicNode>[] matchers = topics.stream()\n-          .map(Matchers::is)\n+          .map(topic -> new BaseMatcher<PostTopicNode>() {", "originalCommit": "bbf5a5a93971e0211a5074692e1aca87402d0452", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2OTk2Ng==", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508669966", "bodyText": "Can we add a comment explaining that we need this special case because protobuf schemas aren't valid JSON? If I hadn't coincidentally encountered this in SerdeUtil (link) the other day, I would've been confused by this.\nRelatedly, it sucks that we have to duplicate this special-casing in multiple places... can't think of a good alternative at the moment though.", "author": "vcrfxia", "createdAt": "2020-10-20T16:25:23Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestExecutor.java", "diffHunk": "@@ -229,6 +241,22 @@ public void buildAndExecuteQuery(\n     }\n   }\n \n+  private static JsonNode fromSchemaMetadata(final Optional<SchemaMetadata> metadata) {\n+    if (!metadata.isPresent()) {\n+      return NullNode.getInstance();\n+    }\n+\n+    if (ProtobufFormat.NAME.equals(metadata.get().getSchemaType())) {", "originalCommit": "bbf5a5a93971e0211a5074692e1aca87402d0452", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5NDc0Nw==", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508694747", "bodyText": "I was originally going to refactor all of it to just be a string, but then that made the QTT tests really annoying to write (escaped JSON inside JSON strings really sucks)", "author": "agavra", "createdAt": "2020-10-20T17:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2OTk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MDQ5MA==", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508670490", "bodyText": "Can we also add array and map for completeness? Same for the other tests (group by, partition by, etc). I don't think the coverage needs to be as thorough as what you've added for struct but I still think it'd be good to cover our bases.", "author": "vcrfxia", "createdAt": "2020-10-20T16:26:12Z", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/as_value.json", "diffHunk": "@@ -149,6 +149,27 @@\n           {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID DECIMAL(4,2) KEY, ID_COPY DECIMAL(4,2), V1 INT\"}\n         ]\n       }\n+    },\n+    {\n+      \"name\": \"STRUCT\",", "originalCommit": "bbf5a5a93971e0211a5074692e1aca87402d0452", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MTE3OQ==", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508671179", "bodyText": "nit: unwrap singles is implicitly set on all key formats that support both wrapping and unwrapping, including AVRO. (I was confused for a moment when I read first this since I thought Avro was somehow special.)", "author": "vcrfxia", "createdAt": "2020-10-20T16:27:17Z", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/group-by.json", "diffHunk": "@@ -2272,6 +2313,277 @@\n         {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"COUNT\": 1}},\n         {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 2}}\n       ]\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"AVRO primitive key\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, VAL BOOLEAN) WITH (kafka_topic='test_topic', format='AVRO');\",\n+        \"CREATE TABLE OUTPUT AS SELECT VAL, COUNT() AS COUNT FROM TEST GROUP BY VAL;\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"keySchema\": {\"type\": \"int\"},\n+          \"keyFormat\": \"AVRO\",\n+          \"valueSchema\": {\"name\": \"ignored\", \"type\": \"record\", \"fields\": [{\"name\": \"VAL\", \"type\": \"boolean\"}]},\n+          \"valueFormat\": \"AVRO\"\n+        }\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"VAL\": true}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"VAL\": false}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"VAL\": true}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\n+            \"comment\": \"unwrap singles is implicitly set on AVRO key formats\",", "originalCommit": "bbf5a5a93971e0211a5074692e1aca87402d0452", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MTIxNw==", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508671217", "bodyText": "This test looks identical to the one above it?", "author": "vcrfxia", "createdAt": "2020-10-20T16:27:21Z", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/group-by.json", "diffHunk": "@@ -2272,6 +2313,277 @@\n         {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"COUNT\": 1}},\n         {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 2}}\n       ]\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"AVRO primitive key\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, VAL BOOLEAN) WITH (kafka_topic='test_topic', format='AVRO');\",\n+        \"CREATE TABLE OUTPUT AS SELECT VAL, COUNT() AS COUNT FROM TEST GROUP BY VAL;\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"keySchema\": {\"type\": \"int\"},\n+          \"keyFormat\": \"AVRO\",\n+          \"valueSchema\": {\"name\": \"ignored\", \"type\": \"record\", \"fields\": [{\"name\": \"VAL\", \"type\": \"boolean\"}]},\n+          \"valueFormat\": \"AVRO\"\n+        }\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"VAL\": true}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"VAL\": false}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"VAL\": true}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\n+            \"comment\": \"unwrap singles is implicitly set on AVRO key formats\",\n+            \"name\" : \"OUTPUT\",\n+            \"type\" : \"TABLE\",\n+            \"schema\" : \"`VAL` BOOLEAN KEY, `COUNT` BIGINT\",\n+            \"keyFormat\" : {\n+              \"format\" : \"AVRO\"\n+            },\n+            \"valueFormat\" : \"AVRO\",\n+            \"keyFeatures\" : [ \"UNWRAP_SINGLES\" ],\n+            \"valueFeatures\" : [ ]\n+          }\n+        ]\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"AVRO struct key group by primitive\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID STRUCT<F1 INT> KEY, VAL BOOLEAN) WITH (kafka_topic='test_topic', format='AVRO');\",\n+        \"CREATE TABLE OUTPUT AS SELECT VAL, COUNT() AS COUNT FROM TEST GROUP BY VAL;\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"keySchema\": {\"name\": \"key\", \"type\": \"record\", \"fields\": [{\"name\": \"F1\", \"type\": [\"null\", \"int\"]}]},\n+          \"keyFormat\": \"AVRO\",\n+          \"valueSchema\": {\"name\": \"ignored\", \"type\": \"record\", \"fields\": [{\"name\": \"VAL\", \"type\": \"boolean\"}]},\n+          \"valueFormat\": \"AVRO\"\n+        }\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 0}, \"value\": {\"VAL\": true}},\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 0}, \"value\": {\"VAL\": false}},\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 1}, \"value\": {\"VAL\": true}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\n+            \"comment\": \"unwrap singles is implicitly set on AVRO key formats\",\n+            \"name\" : \"OUTPUT\",\n+            \"type\" : \"TABLE\",\n+            \"schema\" : \"`VAL` BOOLEAN KEY, `COUNT` BIGINT\",\n+            \"keyFormat\" : {\n+              \"format\" : \"AVRO\"\n+            },\n+            \"valueFormat\" : \"AVRO\",\n+            \"keyFeatures\" : [ \"UNWRAP_SINGLES\" ],\n+            \"valueFeatures\" : [ ]\n+          }\n+        ]\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"AVRO group by struct\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='AVRO');\",\n+        \"CREATE TABLE OUTPUT AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);\"\n+      ],\n+      \"topics\": [\n+        {\n+          \"name\": \"test_topic\",\n+          \"keySchema\": {\"type\": \"int\"},\n+          \"keyFormat\": \"AVRO\",\n+          \"valueSchema\": {\"name\": \"ignored\", \"type\": \"record\", \"fields\": [{\"name\": \"A\", \"type\": \"int\"}, {\"name\": \"B\", \"type\": \"int\"}]},\n+          \"valueFormat\": \"AVRO\"\n+        }\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"A\": 1, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"A\": 2, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"A\": 1, \"B\": 1}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 2, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\n+            \"comment\": \"unwrap singles is implicitly set on AVRO key formats\",\n+            \"name\" : \"OUTPUT\",\n+            \"type\" : \"TABLE\",\n+            \"schema\" : \"`ROWKEY` STRUCT<A INTEGER, B INTEGER> KEY, `COUNT` BIGINT\",\n+            \"keyFormat\" : {\n+              \"format\" : \"AVRO\"\n+            },\n+            \"valueFormat\" : \"AVRO\",\n+            \"keyFeatures\" : [ \"UNWRAP_SINGLES\" ],\n+            \"valueFeatures\" : [ ]\n+          }\n+        ],\n+        \"topics\": {\n+          \"topics\": [\n+            {\n+              \"name\": \"OUTPUT\",\n+              \"keyFormat\" : { \"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"] },\n+              \"keySchema\": {\n+                \"type\": \"record\",\n+                \"name\": \"KsqlDataSourceSchema\",\n+                \"namespace\": \"io.confluent.ksql.avro_schemas\",\n+                \"fields\": [\n+                  { \"name\": \"A\", \"type\": [ \"null\", \"int\" ], \"default\": null },\n+                  { \"name\": \"B\", \"type\": [ \"null\", \"int\" ], \"default\": null }\n+                ]\n+              },\n+              \"valueFormat\" : { \"format\" : \"AVRO\" },\n+              \"valueSchema\": {\n+                \"type\": \"record\",\n+                \"name\": \"KsqlDataSourceSchema\",\n+                \"namespace\": \"io.confluent.ksql.avro_schemas\",\n+                \"fields\": [\n+                  { \"name\": \"COUNT\", \"type\": [ \"null\", \"long\" ], \"default\": null }\n+                ]\n+              }\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"JSON group by struct\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE OUTPUT AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"A\": 1, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"A\": 2, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"A\": 1, \"B\": 1}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 2, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 2}}\n+      ]\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"JSON group by struct convert key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE OUTPUT WITH (key_format='AVRO') AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 0, \"value\": {\"A\": 1, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"A\": 2, \"B\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"A\": 1, \"B\": 1}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 2, \"B\": 1}, \"value\": {\"COUNT\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"A\": 1, \"B\": 1}, \"value\": {\"COUNT\": 2}}\n+      ],\n+      \"post\": {\n+        \"topics\": {\n+          \"topics\": [\n+            {\n+              \"name\": \"OUTPUT\",\n+              \"keyFormat\" : { \"format\" : \"AVRO\", \"features\": [\"UNWRAP_SINGLES\"] },\n+              \"keySchema\": {\n+                \"type\": \"record\",\n+                \"name\": \"KsqlDataSourceSchema\",\n+                \"namespace\": \"io.confluent.ksql.avro_schemas\",\n+                \"fields\": [\n+                  { \"name\": \"A\", \"type\": [ \"null\", \"int\" ], \"default\": null },\n+                  { \"name\": \"B\", \"type\": [ \"null\", \"int\" ], \"default\": null }\n+                ]\n+              },\n+              \"valueFormat\" : { \"format\" : \"JSON\" }\n+            }\n+          ]\n+        }\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"JSON group by struct convert to incompatible key format\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE OUTPUT WITH (key_format='DELIMITED') AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);\"\n+      ],\n+      \"expectedException\": {\n+        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n+        \"message\": \"The 'DELIMITED' format does not support type 'STRUCT', column: `ROWKEY`\"\n+      }\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"Struct key used in aggregate expression\",\n+      \"statements\": [\n+        \"CREATE STREAM TEST (ID STRUCT<F1 INT> KEY, VAL INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE OUTPUT AS SELECT ID, SUM(ID->F1) AS sum FROM TEST GROUP BY ID;\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 1}, \"value\": {\"VAL\": 1}},\n+        {\"topic\": \"test_topic\", \"key\": {\"F1\": 2}, \"value\": {\"VAL\": 2}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": {\"F1\": 1}, \"value\": {\"SUM\": 1}},\n+        {\"topic\": \"OUTPUT\", \"key\": {\"F1\": 2}, \"value\": {\"SUM\": 3}}\n+      ]\n+    },\n+    {\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": \"true\"\n+      },\n+      \"name\": \"Struct key used in aggregate expression\",", "originalCommit": "bbf5a5a93971e0211a5074692e1aca87402d0452", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1NDM4OQ==", "url": "https://github.com/confluentinc/ksql/pull/6466#discussion_r508754389", "bodyText": "eh, I forgot to remove the one above it (which actually fails - the data is different)", "author": "agavra", "createdAt": "2020-10-20T18:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MTIxNw=="}], "type": "inlineReview"}, {"oid": "68b36046822cdc1a6d5b775c2f9fdc596cf726c3", "url": "https://github.com/confluentinc/ksql/commit/68b36046822cdc1a6d5b775c2f9fdc596cf726c3", "message": "chore: PR feedback", "committedDate": "2020-10-20T18:48:05Z", "type": "commit"}]}