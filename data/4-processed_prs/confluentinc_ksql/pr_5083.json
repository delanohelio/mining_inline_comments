{"pr_number": 5083, "pr_title": "docs: n-way join docs", "pr_createdAt": "2020-04-16T17:45:59Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5083", "timeline": [{"oid": "85704e136a25e30ead07aee66ebe844de77358ba", "url": "https://github.com/confluentinc/ksql/commit/85704e136a25e30ead07aee66ebe844de77358ba", "message": "docs: n-way join docs", "committedDate": "2020-04-16T17:46:37Z", "type": "commit"}, {"oid": "85704e136a25e30ead07aee66ebe844de77358ba", "url": "https://github.com/confluentinc/ksql/commit/85704e136a25e30ead07aee66ebe844de77358ba", "message": "docs: n-way join docs", "committedDate": "2020-04-16T17:46:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc4NjY0Mg==", "url": "https://github.com/confluentinc/ksql/pull/5083#discussion_r409786642", "bodyText": "Would it make sense to include the error message in the docs? This way if someone is searching google for the error (which is typical), they can land up here and educate themselves.", "author": "apurvam", "createdAt": "2020-04-16T19:08:42Z", "path": "docs-md/developer-guide/joins/join-streams-and-tables.md", "diffHunk": "@@ -299,3 +299,44 @@ table, if the corresponding key exists already in the join result table.\n | 14        |                  | d                |                  |                  | [null, d]        |\n | 15        | D                |                  | [D, d]           | [D, d]           | [D, d]           |\n \n+N-Way Joins\n+-----------\n+\n+ksqlDB supports joining more than two sources in a single statement. These\n+joins are semantically equivalent to joining N sources consecutively, and\n+the order of the joins is controlled by the order in which the joins are\n+written.\n+\n+Let's take the following query as an example, where `A` is a stream of events\n+and `B` and `C` are both tables:\n+```sql\n+CREATE STREAM joined AS SELECT * FROM A\n+        JOIN B ON A.id = B.product_id\n+        JOIN C ON A.id = C.purchased_id;\n+```\n+\n+The output of this query would be a stream, and the intermediate join result\n+would be the stream `A \u22c8 B`. If `C` were a stream instead of a table, we would \n+rewrite the join accordingly by adding a `WITHIN` clause because joining `A \u22c8 B`\n+with `C` is a stream-stream join:\n+\n+```sql\n+CREATE STREAM joined AS SELECT * FROM A\n+        JOIN B ON A.id = B.product_id\n+        JOIN C WITHIN 10 SECONDS ON A.id = C.purchased_id;\n+```\n+\n+### Limitations of N-Way Joins\n+\n+The limitations and restrictions described in the sections above apply to each intermediate \n+step in N-way joins. For example, `FULL OUTER` joins between streams and tables are\n+not supported. This means that if any stage in the N-way join resolves to a `FULL OUTER`\n+join between a strem and a table the entire query will fail:", "originalCommit": "85704e136a25e30ead07aee66ebe844de77358ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc5ODEwNA==", "url": "https://github.com/confluentinc/ksql/pull/5083#discussion_r409798104", "bodyText": "Excellent idea!", "author": "JimGalasyn", "createdAt": "2020-04-16T19:29:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc4NjY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc5MjA2Mw==", "url": "https://github.com/confluentinc/ksql/pull/5083#discussion_r409792063", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's take the following query as an example, where `A` is a stream of events\n          \n          \n            \n            Consider the following query as an example, where `A` is a stream of events", "author": "JimGalasyn", "createdAt": "2020-04-16T19:18:40Z", "path": "docs-md/developer-guide/joins/join-streams-and-tables.md", "diffHunk": "@@ -299,3 +299,44 @@ table, if the corresponding key exists already in the join result table.\n | 14        |                  | d                |                  |                  | [null, d]        |\n | 15        | D                |                  | [D, d]           | [D, d]           | [D, d]           |\n \n+N-Way Joins\n+-----------\n+\n+ksqlDB supports joining more than two sources in a single statement. These\n+joins are semantically equivalent to joining N sources consecutively, and\n+the order of the joins is controlled by the order in which the joins are\n+written.\n+\n+Let's take the following query as an example, where `A` is a stream of events", "originalCommit": "85704e136a25e30ead07aee66ebe844de77358ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc5MjMzMg==", "url": "https://github.com/confluentinc/ksql/pull/5083#discussion_r409792332", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The output of this query would be a stream, and the intermediate join result\n          \n          \n            \n            The output of this query is a stream, and the intermediate join result", "author": "JimGalasyn", "createdAt": "2020-04-16T19:19:07Z", "path": "docs-md/developer-guide/joins/join-streams-and-tables.md", "diffHunk": "@@ -299,3 +299,44 @@ table, if the corresponding key exists already in the join result table.\n | 14        |                  | d                |                  |                  | [null, d]        |\n | 15        | D                |                  | [D, d]           | [D, d]           | [D, d]           |\n \n+N-Way Joins\n+-----------\n+\n+ksqlDB supports joining more than two sources in a single statement. These\n+joins are semantically equivalent to joining N sources consecutively, and\n+the order of the joins is controlled by the order in which the joins are\n+written.\n+\n+Let's take the following query as an example, where `A` is a stream of events\n+and `B` and `C` are both tables:\n+```sql\n+CREATE STREAM joined AS SELECT * FROM A\n+        JOIN B ON A.id = B.product_id\n+        JOIN C ON A.id = C.purchased_id;\n+```\n+\n+The output of this query would be a stream, and the intermediate join result", "originalCommit": "85704e136a25e30ead07aee66ebe844de77358ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc5NTc2Ng==", "url": "https://github.com/confluentinc/ksql/pull/5083#discussion_r409795766", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            would be the stream `A \u22c8 B`. If `C` were a stream instead of a table, we would \n          \n          \n            \n            is the stream `A \u22c8 B`. If `C` were a stream instead of a table, you would", "author": "JimGalasyn", "createdAt": "2020-04-16T19:25:21Z", "path": "docs-md/developer-guide/joins/join-streams-and-tables.md", "diffHunk": "@@ -299,3 +299,44 @@ table, if the corresponding key exists already in the join result table.\n | 14        |                  | d                |                  |                  | [null, d]        |\n | 15        | D                |                  | [D, d]           | [D, d]           | [D, d]           |\n \n+N-Way Joins\n+-----------\n+\n+ksqlDB supports joining more than two sources in a single statement. These\n+joins are semantically equivalent to joining N sources consecutively, and\n+the order of the joins is controlled by the order in which the joins are\n+written.\n+\n+Let's take the following query as an example, where `A` is a stream of events\n+and `B` and `C` are both tables:\n+```sql\n+CREATE STREAM joined AS SELECT * FROM A\n+        JOIN B ON A.id = B.product_id\n+        JOIN C ON A.id = C.purchased_id;\n+```\n+\n+The output of this query would be a stream, and the intermediate join result\n+would be the stream `A \u22c8 B`. If `C` were a stream instead of a table, we would ", "originalCommit": "85704e136a25e30ead07aee66ebe844de77358ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc5NjgwOA==", "url": "https://github.com/confluentinc/ksql/pull/5083#discussion_r409796808", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            rewrite the join accordingly by adding a `WITHIN` clause because joining `A \u22c8 B`\n          \n          \n            \n            rewrite the join accordingly by adding a `WITHIN` clause, because joining `A \u22c8 B`", "author": "JimGalasyn", "createdAt": "2020-04-16T19:27:22Z", "path": "docs-md/developer-guide/joins/join-streams-and-tables.md", "diffHunk": "@@ -299,3 +299,44 @@ table, if the corresponding key exists already in the join result table.\n | 14        |                  | d                |                  |                  | [null, d]        |\n | 15        | D                |                  | [D, d]           | [D, d]           | [D, d]           |\n \n+N-Way Joins\n+-----------\n+\n+ksqlDB supports joining more than two sources in a single statement. These\n+joins are semantically equivalent to joining N sources consecutively, and\n+the order of the joins is controlled by the order in which the joins are\n+written.\n+\n+Let's take the following query as an example, where `A` is a stream of events\n+and `B` and `C` are both tables:\n+```sql\n+CREATE STREAM joined AS SELECT * FROM A\n+        JOIN B ON A.id = B.product_id\n+        JOIN C ON A.id = C.purchased_id;\n+```\n+\n+The output of this query would be a stream, and the intermediate join result\n+would be the stream `A \u22c8 B`. If `C` were a stream instead of a table, we would \n+rewrite the join accordingly by adding a `WITHIN` clause because joining `A \u22c8 B`", "originalCommit": "85704e136a25e30ead07aee66ebe844de77358ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc5NzAyNA==", "url": "https://github.com/confluentinc/ksql/pull/5083#discussion_r409797024", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The limitations and restrictions described in the sections above apply to each intermediate \n          \n          \n            \n            The limitations and restrictions described in the previous sections apply to each intermediate", "author": "JimGalasyn", "createdAt": "2020-04-16T19:27:45Z", "path": "docs-md/developer-guide/joins/join-streams-and-tables.md", "diffHunk": "@@ -299,3 +299,44 @@ table, if the corresponding key exists already in the join result table.\n | 14        |                  | d                |                  |                  | [null, d]        |\n | 15        | D                |                  | [D, d]           | [D, d]           | [D, d]           |\n \n+N-Way Joins\n+-----------\n+\n+ksqlDB supports joining more than two sources in a single statement. These\n+joins are semantically equivalent to joining N sources consecutively, and\n+the order of the joins is controlled by the order in which the joins are\n+written.\n+\n+Let's take the following query as an example, where `A` is a stream of events\n+and `B` and `C` are both tables:\n+```sql\n+CREATE STREAM joined AS SELECT * FROM A\n+        JOIN B ON A.id = B.product_id\n+        JOIN C ON A.id = C.purchased_id;\n+```\n+\n+The output of this query would be a stream, and the intermediate join result\n+would be the stream `A \u22c8 B`. If `C` were a stream instead of a table, we would \n+rewrite the join accordingly by adding a `WITHIN` clause because joining `A \u22c8 B`\n+with `C` is a stream-stream join:\n+\n+```sql\n+CREATE STREAM joined AS SELECT * FROM A\n+        JOIN B ON A.id = B.product_id\n+        JOIN C WITHIN 10 SECONDS ON A.id = C.purchased_id;\n+```\n+\n+### Limitations of N-Way Joins\n+\n+The limitations and restrictions described in the sections above apply to each intermediate ", "originalCommit": "85704e136a25e30ead07aee66ebe844de77358ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc5NzE4OA==", "url": "https://github.com/confluentinc/ksql/pull/5083#discussion_r409797188", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            join between a strem and a table the entire query will fail:\n          \n          \n            \n            join between a strem and a table the entire query fails:", "author": "JimGalasyn", "createdAt": "2020-04-16T19:28:04Z", "path": "docs-md/developer-guide/joins/join-streams-and-tables.md", "diffHunk": "@@ -299,3 +299,44 @@ table, if the corresponding key exists already in the join result table.\n | 14        |                  | d                |                  |                  | [null, d]        |\n | 15        | D                |                  | [D, d]           | [D, d]           | [D, d]           |\n \n+N-Way Joins\n+-----------\n+\n+ksqlDB supports joining more than two sources in a single statement. These\n+joins are semantically equivalent to joining N sources consecutively, and\n+the order of the joins is controlled by the order in which the joins are\n+written.\n+\n+Let's take the following query as an example, where `A` is a stream of events\n+and `B` and `C` are both tables:\n+```sql\n+CREATE STREAM joined AS SELECT * FROM A\n+        JOIN B ON A.id = B.product_id\n+        JOIN C ON A.id = C.purchased_id;\n+```\n+\n+The output of this query would be a stream, and the intermediate join result\n+would be the stream `A \u22c8 B`. If `C` were a stream instead of a table, we would \n+rewrite the join accordingly by adding a `WITHIN` clause because joining `A \u22c8 B`\n+with `C` is a stream-stream join:\n+\n+```sql\n+CREATE STREAM joined AS SELECT * FROM A\n+        JOIN B ON A.id = B.product_id\n+        JOIN C WITHIN 10 SECONDS ON A.id = C.purchased_id;\n+```\n+\n+### Limitations of N-Way Joins\n+\n+The limitations and restrictions described in the sections above apply to each intermediate \n+step in N-way joins. For example, `FULL OUTER` joins between streams and tables are\n+not supported. This means that if any stage in the N-way join resolves to a `FULL OUTER`\n+join between a strem and a table the entire query will fail:", "originalCommit": "85704e136a25e30ead07aee66ebe844de77358ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c03e38a232527d6952a4a4d7244639f9d7393ff5", "url": "https://github.com/confluentinc/ksql/commit/c03e38a232527d6952a4a4d7244639f9d7393ff5", "message": "docs: address comments", "committedDate": "2020-04-16T20:17:40Z", "type": "commit"}]}