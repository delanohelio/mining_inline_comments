{"pr_number": 4609, "pr_title": "refactor: Refactor KsqlClient to use Vert.x", "pr_createdAt": "2020-02-22T12:04:54Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4609", "timeline": [{"oid": "a6e6babbb0dc8c3d04c2dab772d4e8257340b47b", "url": "https://github.com/confluentinc/ksql/commit/a6e6babbb0dc8c3d04c2dab772d4e8257340b47b", "message": "refactor KsqlClient to use Vert.x instead of jax-ws", "committedDate": "2020-02-24T21:41:35Z", "type": "forcePushed"}, {"oid": "7ec09a3642829102b66cac108b1488db4d4f5695", "url": "https://github.com/confluentinc/ksql/commit/7ec09a3642829102b66cac108b1488db4d4f5695", "message": "refactor KsqlClient to use Vert.x instead of jax-ws", "committedDate": "2020-02-25T08:20:10Z", "type": "commit"}, {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "url": "https://github.com/confluentinc/ksql/commit/be5c6a22f6ae395271f04b725daaf46570f3f83d", "message": "fix ssl tests", "committedDate": "2020-02-25T08:20:10Z", "type": "commit"}, {"oid": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "url": "https://github.com/confluentinc/ksql/commit/be5c6a22f6ae395271f04b725daaf46570f3f83d", "message": "fix ssl tests", "committedDate": "2020-02-25T08:20:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NDg0NA==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384954844", "bodyText": "Closing on newlines does not seem valid, since the TopicStreamWriter may insert them: \n  \n    \n      ksql/ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/TopicStreamWriter.java\n    \n    \n         Line 107\n      in\n      6bcbd51\n    \n    \n    \n    \n\n        \n          \n           print.println(); \n        \n    \n  \n\n\nI see you've got handling for similar new lines from the QueryStreamWriter, and a test for it in KsqlClientTest. Can we add the analogous for print topic handling as well?", "author": "vcrfxia", "createdAt": "2020-02-27T07:37:38Z", "path": "ksql-cli/src/main/java/io/confluent/ksql/cli/Cli.java", "diffHunk": "@@ -510,4 +466,105 @@ private void setRequestPipelining(final boolean newSetting) {\n       requestPipelining = newSetting;\n     }\n   }\n+\n+  private class QueryStreamSubscriber extends BaseSubscriber<StreamedRow> {\n+\n+    private final CompletableFuture<Void> future;\n+    private boolean closed;\n+    private long rowsRead;\n+\n+    QueryStreamSubscriber(final Context context, final CompletableFuture<Void> future) {\n+      super(context);\n+      this.future = Objects.requireNonNull(future);\n+    }\n+\n+    @Override\n+    protected void afterSubscribe(final Subscription subscription) {\n+      makeRequest(1);\n+    }\n+\n+    @Override\n+    protected synchronized void handleValue(final StreamedRow row) {\n+      if (closed) {\n+        return;\n+      }\n+      terminal.printStreamedRow(row);\n+      terminal.flush();\n+      if (row.isTerminal()) {\n+        future.complete(null);\n+        close();\n+        return;\n+      }\n+      if (row.getRow().isPresent()) {\n+        rowsRead++;\n+        if (streamedQueryRowLimit != null && streamedQueryRowLimit == rowsRead) {\n+          future.complete(null);\n+          close();\n+          return;\n+        }\n+      }\n+      makeRequest(1);\n+    }\n+\n+    @Override\n+    protected void handleComplete() {\n+      future.complete(null);\n+    }\n+\n+    @Override\n+    protected void handleError(final Throwable t) {\n+      future.completeExceptionally(t);\n+    }\n+\n+    synchronized void close() {\n+      closed = true;\n+      context.runOnContext(v -> cancel());\n+    }\n+  }\n+\n+  private class PrintTopicSubscriber extends BaseSubscriber<String> {\n+\n+    private final CompletableFuture<Void> future;\n+    private boolean closed;\n+\n+    PrintTopicSubscriber(final Context context, final CompletableFuture<Void> future) {\n+      super(context);\n+      this.future = Objects.requireNonNull(future);\n+    }\n+\n+    @Override\n+    protected void afterSubscribe(final Subscription subscription) {\n+      makeRequest(1);\n+    }\n+\n+    @Override\n+    protected synchronized void handleValue(final String line) {\n+      if (closed) {\n+        return;\n+      }\n+      if (line.isEmpty()) {\n+        close();", "originalCommit": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5NjA4Mg==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384996082", "bodyText": "Ack, good catch.", "author": "purplefox", "createdAt": "2020-02-27T09:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NDg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NTYwNw==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384955607", "bodyText": "Do we need null checks here and on SSL_KEYSTORE_PASSWORD_CONFIG below? The old SslUtilTest file has a test to verify that the keystore password defaults to the empty string if not provided, which does not appear to have been copied over to the new KsqlClientTests.", "author": "vcrfxia", "createdAt": "2020-02-27T07:39:39Z", "path": "ksql-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -38,37 +44,86 @@\n     JsonMapper.INSTANCE.mapper.registerModule(new KsqlTypesDeserializationModule(false));\n   }\n \n-  private final Client httpClient;\n+  public static final String DISABLE_HOSTNAME_VERIFICATION_PROP_NAME\n+      = \"ksql.client.disable.hostname.verification\";\n+  public static final String TLS_ENABLED_PROP_NAME = \"ksql.client.enable.tls\";\n+\n+  private final Vertx vertx;\n+  private final HttpClient httpClient;\n   private final LocalProperties localProperties;\n+  private final Optional<String> basicAuthHeader;\n+  private final boolean isTls;\n \n   public KsqlClient(\n       final Map<String, String> clientProps,\n       final Optional<BasicCredentials> credentials,\n-      final LocalProperties localProperties\n+      final LocalProperties localProperties,\n+      final HttpClientOptions httpClientOptions\n   ) {\n-    this(HttpClientBuilder.buildClient(clientProps), credentials, localProperties);\n+    this.localProperties = requireNonNull(localProperties, \"localProperties\");\n+    this.basicAuthHeader = createBasicAuthHeader(\n+        Objects.requireNonNull(credentials, \"credentials\"));\n+    this.vertx = Vertx.vertx();\n+    if (\"true\".equals(clientProps.get(DISABLE_HOSTNAME_VERIFICATION_PROP_NAME))) {\n+      httpClientOptions.setVerifyHost(false);\n+    }\n+    if (\"true\".equals(clientProps.get(TLS_ENABLED_PROP_NAME))) {\n+      httpClientOptions.setSsl(true);\n+      isTls = true;\n+    } else {\n+      isTls = false;\n+    }\n+    final String trustStoreLocation = clientProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+    if (trustStoreLocation != null) {\n+      httpClientOptions.setTrustStoreOptions(new JksOptions().setPath(trustStoreLocation)\n+          .setPassword(clientProps.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)));", "originalCommit": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxNzE4Mg==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r385017182", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-27T09:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NTYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NTkxNQ==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384955915", "bodyText": "Why was this retry logic removed?", "author": "vcrfxia", "createdAt": "2020-02-27T07:40:30Z", "path": "ksql-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlTarget.java", "diffHunk": "@@ -171,89 +178,123 @@ private KsqlRequest ksqlRequest(\n   }\n \n   private <T> RestResponse<T> get(final String path, final Class<T> type) {\n-    try (Response response = target\n-        .path(path)\n-        .request(MediaType.APPLICATION_JSON_TYPE)\n-        .headers(headers())\n-        .get()\n-    ) {\n-      return KsqlClientUtil.toRestResponse(response, path, r -> r.readEntity(type));\n-    } catch (final Exception e) {\n-      throw new KsqlRestClientException(\"Error issuing GET to KSQL server. path:\" + path, e);\n-    }\n+    return executeRequestSync(HttpMethod.GET, path, null, r -> deserialize(r.getBody(), type));\n   }\n \n   private <T> RestResponse<T> post(\n       final String path,\n       final Object jsonEntity,\n-      final Optional<Integer> readTimeoutMs,\n-      final boolean closeResponse,\n-      final Function<Response, T> mapper\n+      final Function<ResponseWithBody, T> mapper\n   ) {\n-    Response response = null;\n+    return executeRequestSync(HttpMethod.POST, path, jsonEntity, mapper);\n+  }\n \n-    try {\n-      response = target\n-          .path(path)\n-          .request(MediaType.APPLICATION_JSON_TYPE)\n-          .property(ClientProperties.READ_TIMEOUT, readTimeoutMs.orElse(0))\n-          .headers(headers())\n-          .post(Entity.json(jsonEntity));\n-\n-      return KsqlClientUtil.toRestResponse(response, path, mapper);\n-    } catch (final ProcessingException e) {\n-      if (shouldRetry(readTimeoutMs, e)) {", "originalCommit": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxODA2MQ==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r385018061", "bodyText": "Aiui, the retry was necessary in the old code because a blocking read was used. This meant the reading the thread was unable to service anything else, like a terminal interrupt. With Vert.x the reads are all non blocking so we don't have this issue.", "author": "purplefox", "createdAt": "2020-02-27T09:51:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NTkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg4OTkwNg==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r385889906", "bodyText": "Retries are also useful in case there are transient connectivity issues, though, right? By having retries in the client we shield the user from seeing bizarre, transient failures. Do we still achieve this in the new version?", "author": "vcrfxia", "createdAt": "2020-02-28T19:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NTkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NzAyMg==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384957022", "bodyText": "Does the new client throw a sensible error message if the provided TLS keystore or truststore location does not exist, or if the password is incorrect? (This old logic for TLS keystore/truststore handling threw an explicit error in these cases, but I don't see analogous logic in the new implementation.)", "author": "vcrfxia", "createdAt": "2020-02-27T07:43:28Z", "path": "ksql-rest-client/src/main/java/io/confluent/ksql/rest/client/ssl/SslUtil.java", "diffHunk": "@@ -1,90 +0,0 @@\n-/*\n- * Copyright 2019 Confluent Inc.\n- *\n- * Licensed under the Confluent Community License (the \"License\"); you may not use\n- * this file except in compliance with the License.  You may obtain a copy of the\n- * License at\n- *\n- * http://www.confluent.io/confluent-community-license\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package io.confluent.ksql.rest.client.ssl;\n-\n-import io.confluent.ksql.util.KsqlException;\n-import io.confluent.rest.RestConfig;\n-import java.io.FileInputStream;\n-import java.security.KeyStore;\n-import java.util.Map;\n-import java.util.Optional;\n-import javax.net.ssl.HostnameVerifier;\n-import org.apache.http.conn.ssl.NoopHostnameVerifier;\n-import org.apache.kafka.common.config.ConfigException;\n-\n-public final class SslUtil {\n-\n-  private SslUtil() {\n-  }\n-\n-  static Optional<KeyStore> loadKeyStore(final Map<String, String> props) {\n-    return load(props,\n-        RestConfig.SSL_KEYSTORE_LOCATION_CONFIG,\n-        RestConfig.SSL_KEYSTORE_PASSWORD_CONFIG,\n-        RestConfig.SSL_KEYSTORE_TYPE_CONFIG);\n-  }\n-\n-  static Optional<KeyStore> loadTrustStore(final Map<String, String> props) {\n-    return load(props,\n-        RestConfig.SSL_TRUSTSTORE_LOCATION_CONFIG,\n-        RestConfig.SSL_TRUSTSTORE_PASSWORD_CONFIG,\n-        RestConfig.SSL_TRUSTSTORE_TYPE_CONFIG);\n-  }\n-\n-  static String getKeyPassword(final Map<String, String> props) {\n-    return props.getOrDefault(RestConfig.SSL_KEY_PASSWORD_CONFIG, \"\");\n-  }\n-\n-  static Optional<HostnameVerifier> getHostNameVerifier(final Map<String, String> props) {\n-    final String algo = props.getOrDefault(\n-        RestConfig.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG, \"\");\n-\n-    if (algo.isEmpty()) {\n-      return Optional.of(NoopHostnameVerifier.INSTANCE);\n-    }\n-\n-    if (algo.equalsIgnoreCase(\"https\")) {\n-      return Optional.empty();\n-    }\n-\n-    throw new ConfigException(\n-        RestConfig.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG, algo, \"Not supported\");\n-  }\n-\n-  private static Optional<KeyStore> load(\n-      final Map<String, String> props,\n-      final String locationConfig,\n-      final String passwordConfig,\n-      final String typeConfig\n-  ) {\n-    final String location = props.getOrDefault(locationConfig, \"\");\n-    if (location.isEmpty()) {\n-      return Optional.empty();\n-    }\n-\n-    try (FileInputStream stream = new FileInputStream(location)) {\n-\n-      final String password = props.getOrDefault(passwordConfig, \"\");\n-      final String type = props.getOrDefault(typeConfig, \"JKS\");\n-\n-      final KeyStore keyStore = KeyStore.getInstance(type);\n-      keyStore.load(stream, password.toCharArray());\n-      return Optional.of(keyStore);\n-    } catch (final Exception e) {\n-      throw new KsqlException(\"Failed to load keyStore: \" + location, e);", "originalCommit": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzODY5NA==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r385038694", "bodyText": "Yep, this comes from Vert.x. I'll add tests to verify.", "author": "purplefox", "createdAt": "2020-02-27T10:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NzAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NzM1Nw==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384957357", "bodyText": "The new handlePrintedTopic() logic does not appear to set this status message. Can we add it back?", "author": "vcrfxia", "createdAt": "2020-02-27T07:44:29Z", "path": "ksql-cli/src/main/java/io/confluent/ksql/cli/Cli.java", "diffHunk": "@@ -380,42 +344,34 @@ private void handlePrintedTopic(\n       final String printTopic,\n       final SqlBaseParser.PrintTopicContext ignored\n   ) {\n-    final RestResponse<InputStream> topicResponse =\n+    final RestResponse<StreamPublisher<String>> topicResponse =\n         makeKsqlRequest(printTopic, restClient::makePrintTopicRequest);\n \n     if (topicResponse.isSuccessful()) {\n-      try (Scanner topicStreamScanner = new Scanner(topicResponse.getResponse(), UTF_8.name());\n-          StatusClosable toClose = terminal.setStatusMessage(\"Press CTRL-C to interrupt\")", "originalCommit": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyMDgwMg==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r385020802", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-27T09:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1NzM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1ODU0Nw==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384958547", "bodyText": "Not your code, but I don't see terminal.flush() called after this -- is that necessary?", "author": "vcrfxia", "createdAt": "2020-02-27T07:47:50Z", "path": "ksql-cli/src/main/java/io/confluent/ksql/cli/Cli.java", "diffHunk": "@@ -309,68 +298,43 @@ private void printKsqlResponse(final RestResponse<KsqlEntityList> response) {\n     }\n   }\n \n-  private void streamResults(final QueryStream queryStream) {\n-    final Future<?> queryStreamFuture = queryStreamExecutorService.submit(() -> {\n-      for (long rowsRead = 0; limitNotReached(rowsRead) && queryStream.hasNext(); ) {\n-        final StreamedRow row = queryStream.next();\n-\n-        terminal.printStreamedRow(row);\n-        if (row.isTerminal()) {\n-          break;\n-        }\n-\n-        if (row.getRow().isPresent()) {\n-          rowsRead++;\n-        }\n-      }\n-    });\n-\n-    terminal.handle(Terminal.Signal.INT, signal -> {\n-      terminal.handle(Terminal.Signal.INT, Terminal.SignalHandler.SIG_IGN);\n-      queryStream.close();\n-    });\n-\n-    try {\n-      if (streamedQueryTimeoutMs != null) {\n-        try {\n-          queryStreamFuture.get(streamedQueryTimeoutMs, TimeUnit.MILLISECONDS);\n-        } catch (final TimeoutException exception) {\n-          queryStream.close();\n-        }\n-      }\n-\n-      queryStreamFuture.get();\n-    } catch (final InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-    } catch (final ExecutionException e) {\n-      if (e.getCause() instanceof RuntimeException) {\n-        throw (RuntimeException)e.getCause();\n-      }\n-      throw new RuntimeException(e.getCause());\n-    } finally {\n-      terminal.writer().println(\"Query terminated\");\n-      terminal.flush();\n-    }\n-  }\n-\n-  private boolean limitNotReached(final long rowsRead) {\n-    return streamedQueryRowLimit == null || rowsRead < streamedQueryRowLimit;\n-  }\n-\n   @SuppressWarnings({\"try\", \"unused\"}) // ignored param is required to compile.\n   private void handleQuery(\n       final String statement,\n       final SqlBaseParser.QueryStatementContext query\n   ) {\n-    final RestResponse<QueryStream> queryResponse =\n-        makeKsqlRequest(statement, restClient::makeQueryRequest);\n+    final RestResponse<StreamPublisher<StreamedRow>> queryResponse =\n+        makeKsqlRequest(statement, restClient::makeQueryRequestStreamed);\n \n     if (!queryResponse.isSuccessful()) {\n       terminal.printErrorMessage(queryResponse.getErrorMessage());", "originalCommit": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyMTc4OA==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r385021788", "bodyText": "I'll add it anyway, no harm.", "author": "purplefox", "createdAt": "2020-02-27T09:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1ODU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1ODgxOA==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384958818", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  topicResponse.getResponse().subscribe(subscriber);\n          \n          \n            \n                  publisher.subscribe(subscriber);", "author": "vcrfxia", "createdAt": "2020-02-27T07:48:29Z", "path": "ksql-cli/src/main/java/io/confluent/ksql/cli/Cli.java", "diffHunk": "@@ -380,42 +344,34 @@ private void handlePrintedTopic(\n       final String printTopic,\n       final SqlBaseParser.PrintTopicContext ignored\n   ) {\n-    final RestResponse<InputStream> topicResponse =\n+    final RestResponse<StreamPublisher<String>> topicResponse =\n         makeKsqlRequest(printTopic, restClient::makePrintTopicRequest);\n \n     if (topicResponse.isSuccessful()) {\n-      try (Scanner topicStreamScanner = new Scanner(topicResponse.getResponse(), UTF_8.name());\n-          StatusClosable toClose = terminal.setStatusMessage(\"Press CTRL-C to interrupt\")\n-      ) {\n-        final Future<?> topicPrintFuture = queryStreamExecutorService.submit(() -> {\n-          while (!Thread.currentThread().isInterrupted() && topicStreamScanner.hasNextLine()) {\n-            final String line = topicStreamScanner.nextLine();\n-            if (!line.isEmpty()) {\n-              terminal.writer().println(line);\n-              terminal.flush();\n-            }\n-          }\n-        });\n-\n-        terminal.handle(Terminal.Signal.INT, signal -> {\n-          terminal.handle(Terminal.Signal.INT, Terminal.SignalHandler.SIG_IGN);\n-          topicPrintFuture.cancel(true);\n-        });\n+      final CompletableFuture<Void> future = new CompletableFuture<>();\n+      final StreamPublisher<String> publisher = topicResponse.getResponse();\n+      final PrintTopicSubscriber subscriber = new PrintTopicSubscriber(publisher.getContext(),\n+          future);\n+      topicResponse.getResponse().subscribe(subscriber);", "originalCommit": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyMjI0OA==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r385022248", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-27T09:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1ODgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1OTI1NQ==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384959255", "bodyText": "nit: unnecessary in light of the additions to givenTrustStoreConfigured() and givenClientConfguredWithoutTruststore().", "author": "vcrfxia", "createdAt": "2020-02-27T07:49:36Z", "path": "ksql-cli/src/test/java/io/confluent/ksql/cli/SslFunctionalTest.java", "diffHunk": "@@ -109,15 +110,20 @@ public static void classSetUp() {\n \n   @Before\n   public void setUp() {\n-    clientProps = Collections.emptyMap();\n+    clientProps = new HashMap<>();\n+    clientProps.put(KsqlClient.DISABLE_HOSTNAME_VERIFICATION_PROP_NAME, \"true\");", "originalCommit": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyMjg4Ng==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r385022886", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-27T09:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1OTI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1OTU1Mg==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384959552", "bodyText": "nit: this can just be awaitLatch(latch).", "author": "vcrfxia", "createdAt": "2020-02-27T07:50:13Z", "path": "ksql-common/src/test/java/io/confluent/ksql/reactive/ReactiveSubscriberTest.java", "diffHunk": "@@ -87,7 +86,7 @@ public void cancel() {\n     assertThatEventually(afterSubScribeCalled::get, is(true));\n     subscriber.onNext(\"record0\");\n     subscriber.onComplete();\n-    awaitLatch(latch);\n+    assertThat(latch.await(2000, TimeUnit.MILLISECONDS), is(true));", "originalCommit": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyMzI0NQ==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r385023245", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-27T10:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1OTU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1OTgyMg==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384959822", "bodyText": "I'm not familiar with HTTP connection pooling -- is 100 a typical pool size? Feels large.", "author": "vcrfxia", "createdAt": "2020-02-27T07:50:54Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -137,4 +129,9 @@ private KsqlTarget getTarget(final KsqlTarget target, final Optional<String> aut\n         .map(target::authorizationHeader)\n         .orElse(target);\n   }\n+\n+  private static HttpClientOptions createClientOptions() {\n+    return new HttpClientOptions().setMaxPoolSize(100);", "originalCommit": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyODU5OA==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r385028598", "bodyText": "Maybe, but it's just an upper limit, connections won't be created unless they're required.", "author": "purplefox", "createdAt": "2020-02-27T10:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk1OTgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk2MDE0MA==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384960140", "bodyText": "Can we have the other constructor call this one, in order to minimize divergence between tests and production code?", "author": "vcrfxia", "createdAt": "2020-02-27T07:51:43Z", "path": "ksql-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -38,37 +44,86 @@\n     JsonMapper.INSTANCE.mapper.registerModule(new KsqlTypesDeserializationModule(false));\n   }\n \n-  private final Client httpClient;\n+  public static final String DISABLE_HOSTNAME_VERIFICATION_PROP_NAME\n+      = \"ksql.client.disable.hostname.verification\";\n+  public static final String TLS_ENABLED_PROP_NAME = \"ksql.client.enable.tls\";\n+\n+  private final Vertx vertx;\n+  private final HttpClient httpClient;\n   private final LocalProperties localProperties;\n+  private final Optional<String> basicAuthHeader;\n+  private final boolean isTls;\n \n   public KsqlClient(\n       final Map<String, String> clientProps,\n       final Optional<BasicCredentials> credentials,\n-      final LocalProperties localProperties\n+      final LocalProperties localProperties,\n+      final HttpClientOptions httpClientOptions\n   ) {\n-    this(HttpClientBuilder.buildClient(clientProps), credentials, localProperties);\n+    this.localProperties = requireNonNull(localProperties, \"localProperties\");\n+    this.basicAuthHeader = createBasicAuthHeader(\n+        Objects.requireNonNull(credentials, \"credentials\"));\n+    this.vertx = Vertx.vertx();\n+    if (\"true\".equals(clientProps.get(DISABLE_HOSTNAME_VERIFICATION_PROP_NAME))) {\n+      httpClientOptions.setVerifyHost(false);\n+    }\n+    if (\"true\".equals(clientProps.get(TLS_ENABLED_PROP_NAME))) {\n+      httpClientOptions.setSsl(true);\n+      isTls = true;\n+    } else {\n+      isTls = false;\n+    }\n+    final String trustStoreLocation = clientProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+    if (trustStoreLocation != null) {\n+      httpClientOptions.setTrustStoreOptions(new JksOptions().setPath(trustStoreLocation)\n+          .setPassword(clientProps.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)));\n+      final String keyStoreLocation = clientProps.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n+      if (keyStoreLocation != null) {\n+        httpClientOptions.setKeyStoreOptions(new JksOptions().setPath(keyStoreLocation)\n+            .setPassword(clientProps.get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)));\n+      }\n+    }\n+    this.httpClient = vertx.createHttpClient(httpClientOptions);\n   }\n \n   @VisibleForTesting\n   KsqlClient(", "originalCommit": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzMzI3Ng==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r385033276", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-27T10:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk2MDE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk2MDM3MQ==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384960371", "bodyText": "GET hardcoded for httpMethod in error message.", "author": "vcrfxia", "createdAt": "2020-02-27T07:52:23Z", "path": "ksql-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlTarget.java", "diffHunk": "@@ -171,89 +178,123 @@ private KsqlRequest ksqlRequest(\n   }\n \n   private <T> RestResponse<T> get(final String path, final Class<T> type) {\n-    try (Response response = target\n-        .path(path)\n-        .request(MediaType.APPLICATION_JSON_TYPE)\n-        .headers(headers())\n-        .get()\n-    ) {\n-      return KsqlClientUtil.toRestResponse(response, path, r -> r.readEntity(type));\n-    } catch (final Exception e) {\n-      throw new KsqlRestClientException(\"Error issuing GET to KSQL server. path:\" + path, e);\n-    }\n+    return executeRequestSync(HttpMethod.GET, path, null, r -> deserialize(r.getBody(), type));\n   }\n \n   private <T> RestResponse<T> post(\n       final String path,\n       final Object jsonEntity,\n-      final Optional<Integer> readTimeoutMs,\n-      final boolean closeResponse,\n-      final Function<Response, T> mapper\n+      final Function<ResponseWithBody, T> mapper\n   ) {\n-    Response response = null;\n+    return executeRequestSync(HttpMethod.POST, path, jsonEntity, mapper);\n+  }\n \n-    try {\n-      response = target\n-          .path(path)\n-          .request(MediaType.APPLICATION_JSON_TYPE)\n-          .property(ClientProperties.READ_TIMEOUT, readTimeoutMs.orElse(0))\n-          .headers(headers())\n-          .post(Entity.json(jsonEntity));\n-\n-      return KsqlClientUtil.toRestResponse(response, path, mapper);\n-    } catch (final ProcessingException e) {\n-      if (shouldRetry(readTimeoutMs, e)) {\n-        return post(path, jsonEntity, calcReadTimeout(readTimeoutMs), closeResponse, mapper);\n-      }\n-      throw new KsqlRestClientException(\"Error issuing POST to KSQL server. path:\" + path, e);\n-    } catch (final Exception e) {\n-      throw new KsqlRestClientException(\"Error issuing POST to KSQL server. path:\" + path, e);\n-    } finally {\n-      if (response != null && closeResponse) {\n-        response.close();\n-      }\n-    }\n+  private void executeRequestAsync(\n+      final String path,\n+      final Object jsonEntity\n+  ) {\n+    execute(HttpMethod.POST, path, jsonEntity, (resp, vcf) -> {\n+    }).exceptionally(t -> {\n+      log.error(\"Unexpected exception in async request\", t);\n+      return null;\n+    });\n   }\n \n-  private Future<Response> postAsync(\n+  private <T> RestResponse<T> executeRequestSync(\n+      final HttpMethod httpMethod,\n       final String path,\n-      final Object jsonEntity,\n-      final Optional<Integer> readTimeoutMs\n+      final Object requestBody,\n+      final Function<ResponseWithBody, T> mapper\n   ) {\n-    try {\n-      // Performs an asynchronous request\n-      return target\n-          .path(path)\n-          .request(MediaType.APPLICATION_JSON_TYPE)\n-          .property(ClientProperties.READ_TIMEOUT, readTimeoutMs.orElse(0))\n-          .headers(headers())\n-          .async()\n-          .post(Entity.json(jsonEntity));\n-    } catch (final ProcessingException e) {\n-      if (shouldRetry(readTimeoutMs, e)) {\n-        return postAsync(path, jsonEntity, calcReadTimeout(readTimeoutMs));\n-      }\n-      throw new KsqlRestClientException(\"Error issuing POST to KSQL server. path:\" + path, e);\n-    } catch (final Exception e) {\n-      throw new KsqlRestClientException(\"Error issuing POST to KSQL server. path:\" + path, e);\n-    }\n+    return executeSync(httpMethod, path, requestBody, mapper, (resp, vcf) -> {\n+      resp.bodyHandler(buff -> vcf.complete(new ResponseWithBody(resp, buff)));\n+    });\n   }\n \n-  private MultivaluedMap<String, Object> headers() {\n-    final MultivaluedMap<String, Object> headers = new MultivaluedHashMap<>();\n-    authHeader.ifPresent(v -> headers.add(HttpHeaders.AUTHORIZATION, v));\n-    return headers;\n+  private <T> RestResponse<StreamPublisher<T>> executeQueryRequestWithStreamResponse(\n+      final String ksql,\n+      final Optional<Long> previousCommandSeqNum,\n+      final Function<Buffer, T> mapper\n+  ) {\n+    final KsqlRequest ksqlRequest = createKsqlRequest(ksql, previousCommandSeqNum);\n+    final AtomicReference<StreamPublisher<T>> pubRef = new AtomicReference<>();\n+    return executeSync(HttpMethod.POST, QUERY_PATH, ksqlRequest, resp -> pubRef.get(),\n+        (resp, vcf) -> {\n+          if (resp.statusCode() == 200) {\n+            pubRef.set(new StreamPublisher<>(Vertx.currentContext(),\n+                resp, mapper, vcf));\n+            vcf.complete(new ResponseWithBody(resp));\n+          } else {\n+            resp.bodyHandler(body -> vcf.complete(new ResponseWithBody(resp, body)));\n+          }\n+        });\n   }\n \n-  private static boolean shouldRetry(\n-      final Optional<Integer> readTimeoutMs,\n-      final ProcessingException e\n+  private <T> RestResponse<T> executeSync(\n+      final HttpMethod httpMethod,\n+      final String path,\n+      final Object requestBody,\n+      final Function<ResponseWithBody, T> mapper,\n+      final BiConsumer<HttpClientResponse, CompletableFuture<ResponseWithBody>> responseHandler\n   ) {\n-    return readTimeoutMs.map(timeout -> timeout < MAX_TIMEOUT).orElse(false)\n-        && e.getCause() instanceof SocketTimeoutException;\n+    final CompletableFuture<ResponseWithBody> vcf =\n+        execute(httpMethod, path, requestBody, responseHandler);\n+\n+    final ResponseWithBody response;\n+    try {\n+      response = vcf.get();\n+    } catch (Exception e) {\n+      throw new KsqlRestClientException(\"Error issuing GET to KSQL server. path:\" + path, e);", "originalCommit": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzMzUyNA==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r385033524", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-02-27T10:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk2MDM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk2MDU4NQ==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r384960585", "bodyText": "nit: rename to closeConnection() or something similar?", "author": "vcrfxia", "createdAt": "2020-02-27T07:52:59Z", "path": "ksql-rest-client/src/test/java/io/confluent/ksql/rest/client/FakeApiServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.client;\n+\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.Promise;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.http.HttpServerRequest;\n+import io.vertx.ext.web.Router;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.BodyHandler;\n+import java.util.concurrent.CompletableFuture;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FakeApiServer extends AbstractVerticle {\n+\n+  private static final Logger log = LoggerFactory.getLogger(FakeApiServer.class);\n+\n+  private final HttpServerOptions httpServerOptions;\n+\n+  private HttpServer httpServer;\n+  private volatile int port;\n+\n+  private HttpMethod httpMethod;\n+  private String path;\n+  private Buffer body;\n+  private MultiMap headers;\n+\n+  private Object responseObject;\n+  private Buffer responseBuffer;\n+  private volatile CompletableFuture<Buffer> bodyFuture;\n+  private boolean connectionClosed;\n+  private int errorCode = -1;\n+\n+  public FakeApiServer(final HttpServerOptions httpServerOptions) {\n+    this.httpServerOptions = httpServerOptions;\n+  }\n+\n+  @Override\n+  public void start(final Promise<Void> startPromise) {\n+    httpServer = vertx.createHttpServer(httpServerOptions).requestHandler(setupRouter())\n+        .exceptionHandler(FakeApiServer::unhandledExceptionHandler);\n+    httpServer.listen(ar -> {\n+      if (ar.succeeded()) {\n+        port = ar.result().actualPort();\n+        startPromise.complete();\n+      } else {\n+        startPromise.fail(ar.cause());\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public void stop(final Promise<Void> stopPromise) {\n+    if (httpServer == null) {\n+      stopPromise.complete();\n+    } else {\n+      httpServer.close(stopPromise.future());\n+    }\n+  }\n+\n+  private Router setupRouter() {\n+    final Router router = Router.router(vertx);\n+    router.route()\n+        .handler(BodyHandler.create())\n+        .handler(this::handleRequest);\n+    return router;\n+  }\n+\n+  private static void unhandledExceptionHandler(Throwable t) {\n+    t.printStackTrace();\n+  }\n+\n+  private synchronized void handleRequest(final RoutingContext routingContext) {\n+    HttpServerRequest request = routingContext.request();\n+    request.connection().closeHandler(v -> connectionClosed());\n+\n+    httpMethod = request.method();\n+    path = request.path();\n+    headers = request.headers();\n+    body = routingContext.getBody();\n+    if (bodyFuture != null) {\n+      bodyFuture.complete(body);\n+    }\n+    if (errorCode != -1) {\n+      request.response().setStatusCode(errorCode);\n+    }\n+    if (responseBuffer != null) {\n+      request.response().end(responseBuffer);\n+    } else if (responseObject != null) {\n+      request.response().end(KsqlClientUtil.serialize(responseObject));\n+    } else {\n+      request.response().end();\n+    }\n+  }\n+\n+  public synchronized HttpMethod getHttpMethod() {\n+    return httpMethod;\n+  }\n+\n+  public synchronized String getPath() {\n+    return path;\n+  }\n+\n+  public Buffer waitForRequestBody() throws Exception {\n+    this.bodyFuture = new CompletableFuture<>();\n+    return bodyFuture.get();\n+  }\n+\n+  public synchronized Buffer getBody() {\n+    return body;\n+  }\n+\n+  public synchronized MultiMap getHeaders() {\n+    return headers;\n+  }\n+\n+  public synchronized void setResponseObject(final Object responseBody) {\n+    this.responseObject = responseBody;\n+  }\n+\n+  public synchronized void setResponseBuffer(final Buffer responseBuffer) {\n+    this.responseBuffer = responseBuffer;\n+  }\n+\n+  public int getPort() {\n+    return port;\n+  }\n+\n+  private synchronized void connectionClosed() {", "originalCommit": "be5c6a22f6ae395271f04b725daaf46570f3f83d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzMzg0NQ==", "url": "https://github.com/confluentinc/ksql/pull/4609#discussion_r385033845", "bodyText": "This is a handler that is called after the connection is closed, so I think it is ok.", "author": "purplefox", "createdAt": "2020-02-27T10:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk2MDU4NQ=="}], "type": "inlineReview"}, {"oid": "b614d9c7ded0f00673a543dfac08f78d47fef23b", "url": "https://github.com/confluentinc/ksql/commit/b614d9c7ded0f00673a543dfac08f78d47fef23b", "message": "updates after review", "committedDate": "2020-02-27T10:40:29Z", "type": "commit"}]}