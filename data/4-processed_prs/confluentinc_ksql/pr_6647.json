{"pr_number": 6647, "pr_title": "fix: propagate null-valued records in repartition", "pr_createdAt": "2020-11-19T22:46:59Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6647", "timeline": [{"oid": "237d3519fea25a26d8c0e9ca3179445a8cc37f87", "url": "https://github.com/confluentinc/ksql/commit/237d3519fea25a26d8c0e9ca3179445a8cc37f87", "message": "fix: propagate null-valued records in repartition", "committedDate": "2020-11-19T22:39:41Z", "type": "commit"}, {"oid": "a9c0de09da22cd6552c140b3b7b5056893a9c3dc", "url": "https://github.com/confluentinc/ksql/commit/a9c0de09da22cd6552c140b3b7b5056893a9c3dc", "message": "chore: historic plans", "committedDate": "2020-11-19T22:42:01Z", "type": "commit"}, {"oid": "ad0f0311b3e3d5844f570179486bfacda4badc76", "url": "https://github.com/confluentinc/ksql/commit/ad0f0311b3e3d5844f570179486bfacda4badc76", "message": "chore: style", "committedDate": "2020-11-19T22:48:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI1NjQ3NQ==", "url": "https://github.com/confluentinc/ksql/pull/6647#discussion_r527256475", "bodyText": "Is there a reason this was previously List<?> rather than List<Object>? I don't fully understand the meaning of this change, but it lets us avoid an unchecked cast downstream.", "author": "vcrfxia", "createdAt": "2020-11-19T22:49:53Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/StructKeyUtil.java", "diffHunk": "@@ -58,7 +58,7 @@ public static KeyBuilder keyBuilder(final ColumnName name, final SqlType type) {\n   }\n \n   @SuppressWarnings(\"unchecked\")\n-  public static List<?> asList(final Object key) {\n+  public static List<Object> asList(final Object key) {", "originalCommit": "a9c0de09da22cd6552c140b3b7b5056893a9c3dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4MzA5Mw==", "url": "https://github.com/confluentinc/ksql/pull/6647#discussion_r527283093", "bodyText": "https://stackoverflow.com/a/35273095/2258040 - for our use case, I don't think it really makes sense to return List<?>", "author": "agavra", "createdAt": "2020-11-19T23:59:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI1NjQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI1Njg1OA==", "url": "https://github.com/confluentinc/ksql/pull/6647#discussion_r527256858", "bodyText": "I don't love the package this was moved to but couldn't think of anywhere better. Suggestions welcome!", "author": "vcrfxia", "createdAt": "2020-11-19T22:50:40Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ColumnExtractor.java", "diffHunk": "@@ -13,7 +13,7 @@\n  * specific language governing permissions and limitations under the License.\n  */\n \n-package io.confluent.ksql.analyzer;\n+package io.confluent.ksql.execution.util;", "originalCommit": "a9c0de09da22cd6552c140b3b7b5056893a9c3dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4MjQyNQ==", "url": "https://github.com/confluentinc/ksql/pull/6647#discussion_r527282425", "bodyText": "\ud83e\udd37 it's not a public API so it doesn't really matter to me", "author": "agavra", "createdAt": "2020-11-19T23:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI1Njg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4MzYyMw==", "url": "https://github.com/confluentinc/ksql/pull/6647#discussion_r527283623", "bodyText": "we probably need to make sure that partitionByCols.size() is the same as the number of keys (otherwise it's possible that they selected only key columns, but not all of them)", "author": "agavra", "createdAt": "2020-11-20T00:00:46Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -87,12 +90,19 @@ public static PartitionByParams build(\n       // is already present in the current value\n       mapper = (k, v) -> new KeyValue<>(null, v);\n     } else {\n-      final Function<GenericRow, Object> evaluator = buildExpressionEvaluator(\n+      final Set<? extends ColumnReferenceExp> partitionByCols =\n+          ColumnExtractor.extractColumns(partitionBy);\n+      final boolean isKeyExpression = partitionByCols.stream()\n+          .map(ColumnReferenceExp::getColumnName)\n+          .allMatch(sourceSchema::isKeyColumn);", "originalCommit": "ad0f0311b3e3d5844f570179486bfacda4badc76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg3NjkyOA==", "url": "https://github.com/confluentinc/ksql/pull/6647#discussion_r527876928", "bodyText": "Not sure I understand. The validation that all key columns are selected happens elsewhere. This piece of code just determines whether only the old key is needed to compute the new key (partition by expression) or if the value is needed as well. If the former, we can propagate null-valued records, else we can't.", "author": "vcrfxia", "createdAt": "2020-11-20T17:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4MzYyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg4NjA1NA==", "url": "https://github.com/confluentinc/ksql/pull/6647#discussion_r527886054", "bodyText": "Renamed isKeyColumn -> partitionByInvolvesKeyColsOnly to clarify.", "author": "vcrfxia", "createdAt": "2020-11-20T18:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4MzYyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5NzE5MA==", "url": "https://github.com/confluentinc/ksql/pull/6647#discussion_r527897190", "bodyText": "ah! that makes more sense. I had misread what this code was doing.", "author": "agavra", "createdAt": "2020-11-20T18:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4MzYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMyNzY2MA==", "url": "https://github.com/confluentinc/ksql/pull/6647#discussion_r527327660", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final boolean acceptsKey;\n          \n          \n            \n                private final boolean operatesOnKeyOnly;\n          \n      \n    \n    \n  \n\nA little hard for me to understand it inline without context on what this PR does:\n      final Object newKey = evaluator.evaluator.apply(\n          evaluator.acceptsKey\n          ? GenericRow.fromList(StructKeyUtil.asList(k))\n          : v\n      );", "author": "agavra", "createdAt": "2020-11-20T01:02:12Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -202,6 +217,23 @@ private static LogicalSchema buildSchema(\n     final String errorMsg = \"Error computing new key from expression \"\n         + expressionMetadata.getExpression();\n \n-    return row -> expressionMetadata.evaluate(row, null, logger, () -> errorMsg);\n+    return new PartitionByExpressionEvaluator(\n+        row -> expressionMetadata.evaluate(row, null, logger, () -> errorMsg),\n+        isKeyExpression\n+    );\n+  }\n+\n+  private static class PartitionByExpressionEvaluator {\n+\n+    private final Function<GenericRow, Object> evaluator;\n+    private final boolean acceptsKey;", "originalCommit": "ad0f0311b3e3d5844f570179486bfacda4badc76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg4NzcxNA==", "url": "https://github.com/confluentinc/ksql/pull/6647#discussion_r527887714", "bodyText": "I think this is addressed by your suggestion below? I went with evaluateOnKeyOnly though I don't feel strongly.", "author": "vcrfxia", "createdAt": "2020-11-20T18:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMyNzY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMzMTMyMA==", "url": "https://github.com/confluentinc/ksql/pull/6647#discussion_r527331320", "bodyText": "I suspect this isn't the only place where this bug happens (a null value doesn't get properly passed into an ExpressionEvaluator \ud83e\udd14). I had a PR at one point going to try to have ExpressionMetadata#evaluate take in both a key and a value instead of just a GenericRow which would have prevented this issue. Unfortunately, I couldn't get joins to work because the joiner doesn't actually have access to the key \ud83d\ude2d\ntldr, I think it would be good if we encapsulate as much of this \"put the keys and only the keys into the generic row if the row was null\" into the PartitionByExpressionEvaluator and have that implement BiFunction<Struct, GenericRow, Object> so at least the part that creates the key is all in the same place that calls the evaluator:\n      final Object newKey = evaluator.evaluator.apply(\n          evaluator.acceptsKey\n          ? GenericRow.fromList(StructKeyUtil.asList(k))\n          : v\n      );\nI would also just pass in expressionMetadata into the PartitionByExpressionEvaluator instead of passing it in as a lambda so that it's centralized and we don't have to track down where it's being called and what's getting passed into it", "author": "agavra", "createdAt": "2020-11-20T01:14:13Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -202,6 +217,23 @@ private static LogicalSchema buildSchema(\n     final String errorMsg = \"Error computing new key from expression \"\n         + expressionMetadata.getExpression();\n \n-    return row -> expressionMetadata.evaluate(row, null, logger, () -> errorMsg);\n+    return new PartitionByExpressionEvaluator(\n+        row -> expressionMetadata.evaluate(row, null, logger, () -> errorMsg),", "originalCommit": "ad0f0311b3e3d5844f570179486bfacda4badc76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg4NzMyMg==", "url": "https://github.com/confluentinc/ksql/pull/6647#discussion_r527887322", "bodyText": "Ah, thanks for the suggestion -- much cleaner!\nWhat's the benefit of implementing BiFunction<Object, GenericRow, Object> rather than simply have a method? I've currently got\n  Object evaluate(final Object key, final GenericRow value) {\n      final GenericRow row = evaluateOnKeyOnly\n          ? GenericRow.fromList(StructKeyUtil.asList(key))\n          : value;\n      return expressionMetadata.evaluate(row, null, logger, errorMsg);\n    }", "author": "vcrfxia", "createdAt": "2020-11-20T18:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMzMTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg5NjkyNw==", "url": "https://github.com/confluentinc/ksql/pull/6647#discussion_r527896927", "bodyText": "there is none, I think that's great (especially if nowhere else expects the BiFunction)", "author": "agavra", "createdAt": "2020-11-20T18:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMzMTMyMA=="}], "type": "inlineReview"}, {"oid": "bd0e3389e1202ba80474671424c9ce80c93b267d", "url": "https://github.com/confluentinc/ksql/commit/bd0e3389e1202ba80474671424c9ce80c93b267d", "message": "chore: feedback", "committedDate": "2020-11-20T18:12:13Z", "type": "commit"}]}