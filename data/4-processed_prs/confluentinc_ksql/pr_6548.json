{"pr_number": 6548, "pr_title": "fix: Bypass window store cache when doing windowed pull queries", "pr_createdAt": "2020-10-29T23:58:39Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6548", "timeline": [{"oid": "7efd45441ce8edaf5fa0a24fdb905a6e060227bc", "url": "https://github.com/confluentinc/ksql/commit/7efd45441ce8edaf5fa0a24fdb905a6e060227bc", "message": "fix: Removes the streams cache for window stores since this hurts pull query performance", "committedDate": "2020-10-27T23:29:50Z", "type": "commit"}, {"oid": "a95014a096bc6024e38309ef4a6f38f9a31203fb", "url": "https://github.com/confluentinc/ksql/commit/a95014a096bc6024e38309ef4a6f38f9a31203fb", "message": "Checkpoint that kina works, added session too", "committedDate": "2020-10-29T20:12:22Z", "type": "commit"}, {"oid": "38fc46423dc06ff693c3b0f1d70564a8ca4ca34d", "url": "https://github.com/confluentinc/ksql/commit/38fc46423dc06ff693c3b0f1d70564a8ca4ca34d", "message": "Changes to new methodology", "committedDate": "2020-10-29T22:12:09Z", "type": "commit"}, {"oid": "1fce993ed8dd1ab928a09f320471e777bf70d218", "url": "https://github.com/confluentinc/ksql/commit/1fce993ed8dd1ab928a09f320471e777bf70d218", "message": "Removes old code and gets style validated", "committedDate": "2020-10-29T23:22:30Z", "type": "commit"}, {"oid": "5062bba83ad4f7fabba134430872bb7517258369", "url": "https://github.com/confluentinc/ksql/commit/5062bba83ad4f7fabba134430872bb7517258369", "message": "Adds more tests", "committedDate": "2020-10-29T23:50:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEzNTQ2NQ==", "url": "https://github.com/confluentinc/ksql/pull/6548#discussion_r515135465", "bodyText": "This is interesting; why does it happen?\n...Ah, I see. It's because the RocksDBSessionStore wraps a SegmentedBytesStore.\nThe rest seems fairly obvious, but this one might be subtle enough to warrant  a comment.", "author": "vvcephei", "createdAt": "2020-10-30T14:24:37Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/SessionStoreCacheBypass.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams.materialization.ks;\n+\n+import io.confluent.ksql.GenericRow;\n+import java.lang.reflect.Field;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.errors.InvalidStateStoreException;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.processor.StateStore;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+import org.apache.kafka.streams.state.ReadOnlySessionStore;\n+import org.apache.kafka.streams.state.SessionStore;\n+import org.apache.kafka.streams.state.StateSerdes;\n+import org.apache.kafka.streams.state.internals.CompositeReadOnlySessionStore;\n+import org.apache.kafka.streams.state.internals.MeteredSessionStore;\n+import org.apache.kafka.streams.state.internals.StateStoreProvider;\n+import org.apache.kafka.streams.state.internals.WrappedStateStore;\n+\n+public final class SessionStoreCacheBypass {\n+\n+  private static final Field PROVIDER_FIELD;\n+  private static final Field STORE_NAME_FIELD;\n+  private static final Field STORE_TYPE_FIELD;\n+  static final Field SERDES_FIELD;\n+\n+  static {\n+    try {\n+      PROVIDER_FIELD = CompositeReadOnlySessionStore.class.getDeclaredField(\"storeProvider\");\n+      PROVIDER_FIELD.setAccessible(true);\n+      STORE_NAME_FIELD = CompositeReadOnlySessionStore.class.getDeclaredField(\"storeName\");\n+      STORE_NAME_FIELD.setAccessible(true);\n+      STORE_TYPE_FIELD\n+          = CompositeReadOnlySessionStore.class.getDeclaredField(\"queryableStoreType\");\n+      STORE_TYPE_FIELD.setAccessible(true);\n+      SERDES_FIELD = MeteredSessionStore.class.getDeclaredField(\"serdes\");\n+      SERDES_FIELD.setAccessible(true);\n+    } catch (final NoSuchFieldException e) {\n+      throw new RuntimeException(\"Stream internals changed unexpectedly!\", e);\n+    }\n+  }\n+\n+  private SessionStoreCacheBypass() {}\n+\n+  interface SessionStoreCacheBypassFetcher {\n+\n+    KeyValueIterator<Windowed<Struct>, GenericRow> fetch(\n+        ReadOnlySessionStore<Struct, GenericRow> store,\n+        Struct key\n+    );\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static KeyValueIterator<Windowed<Struct>, GenericRow> fetch(\n+      final ReadOnlySessionStore<Struct, GenericRow> store,\n+      final Struct key\n+  ) {\n+    Objects.requireNonNull(key, \"key can't be null\");\n+\n+    final StateStoreProvider provider;\n+    final String storeName;\n+    final QueryableStoreType<ReadOnlySessionStore<Struct, GenericRow>> storeType;\n+    try {\n+      provider = (StateStoreProvider) PROVIDER_FIELD.get(store);\n+      storeName = (String) STORE_NAME_FIELD.get(store);\n+      storeType = (QueryableStoreType<ReadOnlySessionStore<Struct, GenericRow>>)\n+          STORE_TYPE_FIELD.get(store);\n+    } catch (final IllegalAccessException e) {\n+      throw new RuntimeException(\"Stream internals changed unexpectedly!\", e);\n+    }\n+    final List<ReadOnlySessionStore<Struct, GenericRow>> stores\n+        = provider.stores(storeName, storeType);\n+    for (final ReadOnlySessionStore<Struct, GenericRow> sessionStore : stores) {\n+      try {\n+        final KeyValueIterator<Windowed<Struct>, GenericRow> result\n+            = fetchUncached(sessionStore, key);\n+        // returns the first non-empty iterator\n+        if (!result.hasNext()) {\n+          result.close();\n+        } else {\n+          return result;\n+        }\n+      } catch (final InvalidStateStoreException e) {\n+        throw new InvalidStateStoreException(\n+            \"State store is not available anymore and may have been migrated to another instance; \"\n+                + \"please re-discover its location from the state metadata.\", e);\n+      }\n+    }\n+    return new EmptyKeyValueIterator();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private static KeyValueIterator<Windowed<Struct>, GenericRow> fetchUncached(\n+      final ReadOnlySessionStore<Struct, GenericRow> sessionStore,\n+      final Struct key\n+  ) {\n+    if (sessionStore instanceof MeteredSessionStore) {\n+      final StateSerdes<Struct, GenericRow> serdes;\n+      try {\n+        serdes = (StateSerdes<Struct, GenericRow>) SERDES_FIELD.get(sessionStore);\n+      } catch (final IllegalAccessException e) {\n+        throw new RuntimeException(\"Stream internals changed unexpectedly!\", e);\n+      }\n+\n+      final Bytes rawKey = Bytes.wrap(serdes.rawKey(key));\n+      SessionStore<Bytes, byte[]> wrapped\n+          = ((MeteredSessionStore<Struct, GenericRow>) sessionStore).wrapped();\n+      while (wrapped instanceof WrappedStateStore) {\n+        final StateStore store = ((WrappedStateStore<?, ?, ?>) wrapped).wrapped();\n+        if (!(store instanceof SessionStore)) {\n+          break;\n+        }", "originalCommit": "5062bba83ad4f7fabba134430872bb7517258369", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxMjIyNA==", "url": "https://github.com/confluentinc/ksql/pull/6548#discussion_r515412224", "bodyText": "Yes, it's exactly as you mentioned.  Stopping at the last SessionStore is sufficient since it is below the cache and still has the expected interface for fetching.  Added a few comments about that.", "author": "AlanConfluent", "createdAt": "2020-10-30T22:41:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEzNTQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE0MjM2Mg==", "url": "https://github.com/confluentinc/ksql/pull/6548#discussion_r515142362", "bodyText": "It looks like this test verifies that we bottom out at a wrapped store when it doesn't wrap a WindowStore, right?\nIt seems like a similar test could positively verify that we actually do skip the caching layer, or any other wrapped layer, but I didn't see that test. Did I miss it?", "author": "vvcephei", "createdAt": "2020-10-30T14:34:53Z", "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/materialization/ks/WindowStoreCacheBypassTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams.materialization.ks;\n+\n+import static io.confluent.ksql.execution.streams.materialization.ks.WindowStoreCacheBypass.SERDES_FIELD;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.GenericRow;\n+import java.time.Instant;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.SchemaBuilder;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.errors.InvalidStateStoreException;\n+import org.apache.kafka.streams.processor.StateStore;\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+import org.apache.kafka.streams.state.ReadOnlyWindowStore;\n+import org.apache.kafka.streams.state.StateSerdes;\n+import org.apache.kafka.streams.state.ValueAndTimestamp;\n+import org.apache.kafka.streams.state.WindowStore;\n+import org.apache.kafka.streams.state.WindowStoreIterator;\n+import org.apache.kafka.streams.state.internals.CompositeReadOnlyWindowStore;\n+import org.apache.kafka.streams.state.internals.MeteredWindowStore;\n+import org.apache.kafka.streams.state.internals.StateStoreProvider;\n+import org.apache.kafka.streams.state.internals.WrappedStateStore;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class WindowStoreCacheBypassTest {\n+\n+  private static final Schema SCHEMA = SchemaBuilder.struct().field(\"a\", SchemaBuilder.int32());\n+  private static final Struct SOME_KEY = new Struct(SCHEMA).put(\"a\", 1);\n+  private static final byte[] BYTES = new byte[] {'a', 'b'};\n+\n+  @Mock\n+  private QueryableStoreType<ReadOnlyWindowStore<Struct, ValueAndTimestamp<GenericRow>>>\n+      queryableStoreType;\n+  @Mock\n+  private StateStoreProvider provider;\n+  @Mock\n+  private MeteredWindowStore<Struct, ValueAndTimestamp<GenericRow>> meteredWindowStore;\n+  @Mock\n+  private WindowStore<Bytes, byte[]> windowStore;\n+  @Mock\n+  private WrappedWindowStore<Bytes, byte[]> wrappedWindowStore;\n+  @Mock\n+  private StateStore stateStore;\n+  @Mock\n+  private WindowStoreIterator<byte[]> windowStoreIterator;\n+  @Mock\n+  private StateSerdes<Struct, ValueAndTimestamp<GenericRow>> serdes;\n+\n+  private CompositeReadOnlyWindowStore<Struct, ValueAndTimestamp<GenericRow>> store;\n+  private WrappedStateStore<StateStore, Struct, ValueAndTimestamp<GenericRow>> wrappedStateStore;\n+\n+  @Before\n+  public void setUp() {\n+    store = new CompositeReadOnlyWindowStore<>(provider, queryableStoreType, \"foo\");\n+  }\n+\n+  @Test\n+  public void shouldCallUnderlyingStore() throws IllegalAccessException {\n+    when(provider.stores(any(), any())).thenReturn(ImmutableList.of(meteredWindowStore));\n+    SERDES_FIELD.set(meteredWindowStore, serdes);\n+    when(serdes.rawKey(any())).thenReturn(BYTES);\n+    when(meteredWindowStore.wrapped()).thenReturn(wrappedWindowStore);\n+    when(wrappedWindowStore.wrapped()).thenReturn(windowStore);\n+    when(windowStore.fetch(any(), any(), any())).thenReturn(windowStoreIterator);\n+    when(windowStoreIterator.hasNext()).thenReturn(false);\n+\n+    WindowStoreCacheBypass.fetch(store, SOME_KEY, Instant.ofEpochMilli(100), Instant.ofEpochMilli(200));\n+    verify(windowStore).fetch(new Bytes(BYTES), Instant.ofEpochMilli(100L), Instant.ofEpochMilli(200L));\n+  }\n+\n+  @Test\n+  public void shouldAvoidNonWindowStore() throws IllegalAccessException {", "originalCommit": "5062bba83ad4f7fabba134430872bb7517258369", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyMjAzOQ==", "url": "https://github.com/confluentinc/ksql/pull/6548#discussion_r515422039", "bodyText": "The logic was technically cache agnostic.  So long as the last WindowStore layer is not a cache, which we know it wouldn't be since the caching layer is built upon that, this check would hopefully be sufficient.\nI changed the bypassing logic so that it verifies that it actually passes the caching layer when it's run and the tests verify that as well.", "author": "AlanConfluent", "createdAt": "2020-10-30T23:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE0MjM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyNTkxOQ==", "url": "https://github.com/confluentinc/ksql/pull/6548#discussion_r515425919", "bodyText": "Actually, I removed the bypass check because it's possible that the user can configure it without a cache.  I don't really want to try to reproduce the logic for determining if cache is enabled, so I removed this bypass check.", "author": "AlanConfluent", "createdAt": "2020-10-30T23:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE0MjM2Mg=="}], "type": "inlineReview"}, {"oid": "81089d81c2bef1f39dc87f8f9ee00b6b0bc9197e", "url": "https://github.com/confluentinc/ksql/commit/81089d81c2bef1f39dc87f8f9ee00b6b0bc9197e", "message": "Remove unused field in test", "committedDate": "2020-10-30T18:20:02Z", "type": "commit"}, {"oid": "7cfe7deb0909a8519fc61884e05f7693f13450bc", "url": "https://github.com/confluentinc/ksql/commit/7cfe7deb0909a8519fc61884e05f7693f13450bc", "message": "Feedback again", "committedDate": "2020-10-30T23:44:43Z", "type": "commit"}, {"oid": "7cfe7deb0909a8519fc61884e05f7693f13450bc", "url": "https://github.com/confluentinc/ksql/commit/7cfe7deb0909a8519fc61884e05f7693f13450bc", "message": "Feedback again", "committedDate": "2020-10-30T23:44:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjE3Nw==", "url": "https://github.com/confluentinc/ksql/pull/6548#discussion_r515716177", "bodyText": "Why did you add these?", "author": "vpapavas", "createdAt": "2020-11-02T02:48:32Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryFunctionalTest.java", "diffHunk": "@@ -129,6 +129,7 @@\n       .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8188\")\n       .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS, true)\n       .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"cache.max.bytes.buffering\", 10000)", "originalCommit": "7cfe7deb0909a8519fc61884e05f7693f13450bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1Njk2MA==", "url": "https://github.com/confluentinc/ksql/pull/6548#discussion_r516156960", "bodyText": "I just added them to one of the pull query tests because I wanted to exercise the cache bypassing code in a functional test.  It's hard to set up a realistic scenario in unit tests since it's not easy to construct all of the state store layers as they actually exist.\nIf something basic goes wrong in the reflection or types with underlying streams when faced with the cache, these tests should fail.  The real test for this will be the automated benchmarks which test that this bypassing effect works as intended.", "author": "AlanConfluent", "createdAt": "2020-11-02T17:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjE3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1NzU1Nw==", "url": "https://github.com/confluentinc/ksql/pull/6548#discussion_r516157557", "bodyText": "Ok, makes sense", "author": "vpapavas", "createdAt": "2020-11-02T17:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjE3Nw=="}], "type": "inlineReview"}]}