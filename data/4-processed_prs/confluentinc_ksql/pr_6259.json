{"pr_number": 6259, "pr_title": "docs: KLIP-38 for Variable Substitution", "pr_createdAt": "2020-09-18T20:09:42Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6259", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3ODA2Mg==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491178062", "bodyText": "Is this because the ksqlDB language is itself case-insensitive?", "author": "colinhicks", "createdAt": "2020-09-18T20:35:33Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.", "originalCommit": "86bad6aa26418ae7d093c189c2c2350845ac5984", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyODEzNw==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491228137", "bodyText": "Yes. We could be case-sensitive, but I didn't see the reason of that if our SQL statements are insensitive. One quick example while writing examples is I was defining variables in uppercase, then making references in lowercase without noticing it. I thought users would face the same situation, so better to keep this insensitive.", "author": "spena", "createdAt": "2020-09-18T22:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3ODA2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE1ODA1OQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492158059", "bodyText": "I think that makes sense. For reference MySQL's variables are also case-insensitive.", "author": "colinhicks", "createdAt": "2020-09-21T15:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3ODA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4MTM4Mg==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491181382", "bodyText": "This seems like an important limitation. With \"hard-coded\" here, are you referring to language elements beyond the set of literals (i.e. null, number, boolean, string)?\nThis would mean for example that you couldn't use a variable for a source name, correct? In other words this wouldn't be possible:\nCREATE STREAM {stream_name} (...\nINSERT INTO {stream_name} (...", "author": "colinhicks", "createdAt": "2020-09-18T20:43:46Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.", "originalCommit": "86bad6aa26418ae7d093c189c2c2350845ac5984", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyOTcyNA==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491229724", "bodyText": "I'm still opened to use variables as column-names and other expressions, such as: CREATE STREAM .. WHERE {expression}. I had something else in mind initially when defining a char variable and replacing the variable including single- or double- quotes. That wouldn't have worked with column names. But now I completed the klip, I think we could support other places.\nI still want to stay away of replacing reserved words. I noticed other systems (hive & spark) seem tp allow replacing the whole statement, like:\nksql> define select =  'select * from stream emit changes;';\nksql> {select}\n\nI'm not sure we want to do that. It's easier to implement, but I'm not sure is correct. Most of the DBs in the market do not allow that. What do you think?", "author": "spena", "createdAt": "2020-09-18T23:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4MTM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE1Mjc4NQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492152785", "bodyText": "I think supporting identifiers like source name, column name, in addition to literals would be best.\nI agree we should probably not support arbitrary statement fragments.", "author": "colinhicks", "createdAt": "2020-09-21T15:28:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4MTM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMjE3OQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492302179", "bodyText": "Done. I made a reference to support identifiers for column and source names.", "author": "spena", "createdAt": "2020-09-21T19:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4MTM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4MjIxMQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491182211", "bodyText": "nit: I suggest making the variable value different than the variable name. Something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ksql> DEFINE topic_prod = 'topic_prod';\n          \n          \n            \n            ksql> DEFINE topic_qa = 'topic_qa';\n          \n          \n            \n            ksql> DEFINE topic_prod = 'my_prod_topic';\n          \n          \n            \n            ksql> DEFINE topic_qa = 'my_qa_topic';", "author": "colinhicks", "createdAt": "2020-09-18T20:45:37Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.\n+\n+For instance (`{VAR}` is used a reference where variables are permitted):\n+```\n+ksql> CREATE STREAM <name> (col1 INT, col2 STRING) WITH (kafka_topic='{VAR}', format='{VAR}', replicas={VAR}, ...);\n+ksql> INSERT INTO <stream> (col1, col2) VALUES ({VAR}, '{VAR}');\n+ksql> SELECT * FROM <stream> WHERE col1 == {VAR} and col2 == '{VAR}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_{var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '{offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP {WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'topic_prod';\n+ksql> DEFINE topic_qa = 'topic_qa';", "originalCommit": "86bad6aa26418ae7d093c189c2c2350845ac5984", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4MzQ0MA==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491183440", "bodyText": "At first glance, it seems like this could be more confusing than it's worth. (As much as I love Lisp-like nesting \ud83d\ude02 .) Do you have other use-cases in mind?", "author": "colinhicks", "createdAt": "2020-09-18T20:47:56Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.\n+\n+For instance (`{VAR}` is used a reference where variables are permitted):\n+```\n+ksql> CREATE STREAM <name> (col1 INT, col2 STRING) WITH (kafka_topic='{VAR}', format='{VAR}', replicas={VAR}, ...);\n+ksql> INSERT INTO <stream> (col1, col2) VALUES ({VAR}, '{VAR}');\n+ksql> SELECT * FROM <stream> WHERE col1 == {VAR} and col2 == '{VAR}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_{var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '{offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP {WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'topic_prod';\n+ksql> DEFINE topic_qa = 'topic_qa';\n+\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}'); ", "originalCommit": "86bad6aa26418ae7d093c189c2c2350845ac5984", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMDMxMQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491230311", "bodyText": "Yeah. The StringSubstitutor library allows that, so I thought that was a nice feature without complicating the ksqlDB code. But from the user side, they could end up with a long \"chorizo\" that would confuse them {topic_{env_{num}_{user}}}. We can ask for feedback to some users.", "author": "spena", "createdAt": "2020-09-18T23:09:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4MzQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NTg1Mw==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491185853", "bodyText": "Will this mean that variables defined lexically after a statement that refers to them will use the latest value? As an illustration, what would be the result of following in headless mode?\nDEFINE topic = 'foo';\nCREATE STREAM ... WITH (kafka_topic='{topic}');\nDEFINE topic = 'bar';", "author": "colinhicks", "createdAt": "2020-09-18T20:53:57Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.\n+\n+For instance (`{VAR}` is used a reference where variables are permitted):\n+```\n+ksql> CREATE STREAM <name> (col1 INT, col2 STRING) WITH (kafka_topic='{VAR}', format='{VAR}', replicas={VAR}, ...);\n+ksql> INSERT INTO <stream> (col1, col2) VALUES ({VAR}, '{VAR}');\n+ksql> SELECT * FROM <stream> WHERE col1 == {VAR} and col2 == '{VAR}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_{var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '{offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP {WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'topic_prod';\n+ksql> DEFINE topic_qa = 'topic_qa';\n+\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}'); \n+```\n+\n+### 5. Enable/disable substitution variables\n+\n+When using CLI, we'll use the `SET CLI VARIABLE-SUBSTITUTION (ON|OFF)` command to enable/disable subsitution. Default will be `ON`.\n+```\n+ksql> SET CLI VARIABLE-SUBSTITUTION OFF;\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}');\n+Error: Fail because {topic_{env}} topic name is invalid. \n+```\n+The error message is just an example of what ksqlDB will display.\n+\n+When using SQL scripts in headless mode, we need to provide a server setting to enable/disable variable substitution. The setting will be\n+`ksql.enable.headless.variable.substitution` as Boolean (default = true). The reason is that `SET CLI` is a CLI-specific command not available\n+in headless execution. Also, CLI should not request the Server is variable substitution is enabled as that should be a user decision to substitute or not.\n+\n+### 6. Implementation\n+\n+For CLI, variable substitution will happen in the CLI side before making a ksqlDB request to the server. This allows less changes in ksqlDB code as we have  \n+the `SET CLI` to enable/disable, and variables will be living in the CLI server memory, so we have quickly access to them.\n+\n+For headless, variable substitution will happen in the server side. Seems the `KsqlContext` is the right place for that.\n+\n+Variable substitution will be done by using two pre-parsing steps. First, it will use the `KsqlParser.parse()` method to verify variable substitution rules.  \n+These rules will be defined in the `SqlBase.g4` syntax file. Once this step passes, then we'll use the `StringSubstitutor` class from Apache libraries to  \n+replace `{...}` variables. This library gives us easily variable replacement including nested variables, and others features we can use in the future, such as", "originalCommit": "86bad6aa26418ae7d093c189c2c2350845ac5984", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NjExNQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491186115", "bodyText": "We can also discuss not supporting substitution in headless mode.", "author": "colinhicks", "createdAt": "2020-09-18T20:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NTg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMTAyNg==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491231026", "bodyText": "The above example will end up with CREATE STREAM ... WITH (kafka_topic='foo');, then the variable topic will change to bar, but it won't cause any changes to the previous stream. Variables will not be persisted, so they will be evaluated and replaces at run-time and before sending the request to the server.\nAbout headless. Let's talk about it. Being headless a mode we won't want to support more, it would make sense not to do it. It will keep the code less complex too.", "author": "spena", "createdAt": "2020-09-18T23:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NTg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NzczMw==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491187733", "bodyText": "Should we also consider substitution in the context of the Java Client API? If so, what would a session be in this context?", "author": "colinhicks", "createdAt": "2020-09-18T20:58:46Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by\n+QTT (or ksqlDB functional tests) to replace variables. It's better to keep the same format between testing and production to avoid\n+confusion.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='{format}', replicas={replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are not case sensitive. A reference to `{replicas}` is the same as `{REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed only in specific SQL statements, and only in places where literals or hard-coded values can be used.\n+Variables cannot be used as column-names, reserved keywords, etc.\n+\n+For instance (`{VAR}` is used a reference where variables are permitted):\n+```\n+ksql> CREATE STREAM <name> (col1 INT, col2 STRING) WITH (kafka_topic='{VAR}', format='{VAR}', replicas={VAR}, ...);\n+ksql> INSERT INTO <stream> (col1, col2) VALUES ({VAR}, '{VAR}');\n+ksql> SELECT * FROM <stream> WHERE col1 == {VAR} and col2 == '{VAR}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_{var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '{offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP {WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'topic_prod';\n+ksql> DEFINE topic_qa = 'topic_qa';\n+\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}'); \n+```\n+\n+### 5. Enable/disable substitution variables\n+\n+When using CLI, we'll use the `SET CLI VARIABLE-SUBSTITUTION (ON|OFF)` command to enable/disable subsitution. Default will be `ON`.\n+```\n+ksql> SET CLI VARIABLE-SUBSTITUTION OFF;\n+ksql> CREATE STREAM ... WITH (kafka_topic='{topic_{env}}');\n+Error: Fail because {topic_{env}} topic name is invalid. \n+```\n+The error message is just an example of what ksqlDB will display.\n+\n+When using SQL scripts in headless mode, we need to provide a server setting to enable/disable variable substitution. The setting will be\n+`ksql.enable.headless.variable.substitution` as Boolean (default = true). The reason is that `SET CLI` is a CLI-specific command not available\n+in headless execution. Also, CLI should not request the Server is variable substitution is enabled as that should be a user decision to substitute or not.\n+\n+### 6. Implementation\n+\n+For CLI, variable substitution will happen in the CLI side before making a ksqlDB request to the server. This allows less changes in ksqlDB code as we have  \n+the `SET CLI` to enable/disable, and variables will be living in the CLI server memory, so we have quickly access to them.", "originalCommit": "86bad6aa26418ae7d093c189c2c2350845ac5984", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMDU4Ng==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491230586", "bodyText": "Mmm, forgot about that. REST API is out of scope because a session is usually a request which is one command. But Java API might be different. I'll investigate that see how it opens sessions.", "author": "spena", "createdAt": "2020-09-18T23:10:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NzczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ2NjcxMA==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491466710", "bodyText": "@colinhicks do we need to support Cloud? If we don't support REST API then we can't support it. Only way to support REST and Cloud is to open a session in the server, send all variables to the server so they're stored in that temporal session, and replace variables in the server side. It's more involved, but we'll allow Cloud users to use it.", "author": "spena", "createdAt": "2020-09-19T15:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NzczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzODEwMg==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492138102", "bodyText": "We can think of this as a feature of clients, where each client that supports string substitution applies any transformations before sending the SQL to the server.\nThe Confluent Cloud UI is a ksqlDB client that can implement support for substitution at some point. It does not need to support it initially.", "author": "colinhicks", "createdAt": "2020-09-21T15:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NzczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ1Njg5Nw==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r491456897", "bodyText": "I might change the prefix/suffix for '${}' to avoid conflicting with JSON literal strings.", "author": "spena", "createdAt": "2020-09-19T14:33:10Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,288 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+All variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `{}` characters (i.e. `{replicas}`). These characters are also used by", "originalCommit": "86bad6aa26418ae7d093c189c2c2350845ac5984", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3NDU3NQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492274575", "bodyText": "+1 for ${}.", "author": "colinhicks", "createdAt": "2020-09-21T18:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ1Njg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMjMzOA==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492302338", "bodyText": "Done", "author": "spena", "createdAt": "2020-09-21T19:40:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ1Njg5Nw=="}], "type": "inlineReview"}, {"oid": "d4d905feae50519b77d5c2a572f0129f927a3d1e", "url": "https://github.com/confluentinc/ksql/commit/d4d905feae50519b77d5c2a572f0129f927a3d1e", "message": "docs: addressed feedback 1\n\n- Use ${} instead of {} to avoid JSON literal conflicts\n- Use variables for other identifiers such as column names and source names\n- Minor doc fixes", "committedDate": "2020-09-21T20:48:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxMTU4Nw==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492311587", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # KLIP 34 - Variable Substitution\n          \n          \n            \n            # KLIP 38 - Variable Substitution", "author": "agavra", "createdAt": "2020-09-21T19:58:42Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,295 @@\n+# KLIP 34 - Variable Substitution", "originalCommit": "9223aa69d48769e130e37e78fd1552840cfa168b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNDYwNg==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492414606", "bodyText": "Done", "author": "spena", "createdAt": "2020-09-22T00:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxMTU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5NzI0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492397249", "bodyText": "can you link to the Oracle docs here for future reference (is it https://docs.oracle.com/cd/E18283_01/server.112/e16604/ch_twelve017.htm ?)\nThough if I had to choose, I think the SQL+ syntax here is a little unintuitive. MySQL: https://docs.oracle.com/cd/E17952_01/mysql-5.7-en/user-variables.html uses something that to me is more intuitive (and is similar to SqlServer)", "author": "agavra", "createdAt": "2020-09-21T23:14:08Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  ", "originalCommit": "d4d905feae50519b77d5c2a572f0129f927a3d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxMjA1NQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492412055", "bodyText": "Oracle SQL*Plus\nhttps://blogs.oracle.com/opal/sqlplus-101-substitution-variables\nI wanted to use a similar character like Mysql. I also like the @, but the StringSubstitutor library doesn't allow me to us only the @. I have to add a suffix to the variable, so a @var@ or :var: would work.", "author": "spena", "createdAt": "2020-09-22T00:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5NzI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxMjc3OA==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492412778", "bodyText": "And regarding the SET. I didn't want to mix the current SET syntax which uses single-quotes for keynames, and I wasn't sure what other keyword to add to make reference to user-variables. Any proposal?\nksql> SET 'auto.offset.reset' = 'earliest';\nksql> SET VAR var1 = 'hola';", "author": "spena", "createdAt": "2020-09-22T00:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5NzI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1ODc1NA==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r493058754", "bodyText": "If there's precedent (Hive, Impala, Spark and Presto) I think we can stick with your proposal as users will be accustomed to this already.", "author": "agavra", "createdAt": "2020-09-22T22:01:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5NzI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5ODkzMw==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492398933", "bodyText": "If we're following Oracle SQL+ why not use & or && to reference the variables?", "author": "agavra", "createdAt": "2020-09-21T23:19:17Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `${}` characters (i.e. `${replicas}`).", "originalCommit": "d4d905feae50519b77d5c2a572f0129f927a3d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNDQzMw==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492414433", "bodyText": "In Oracle, the & prompts users to type the variable value when not defined, and && to reuse the variable after the user has typed a value. That behavior is out of scope, so we either use & or something else. And I had the problem with the StringSubstitutor that requires a suffix too, so &var&?\nEither we write our own string parsing or get in love with some characters to wrap the variables names :).\nBtw, the ${var} is used in Hive, Impala, Spark and Presto. We're not alone. They use SET, though, for setting variables, but they do not override server settings or they use a different name for user variables. For instance, Hive uses SET hiveconf:var1 = 'value' and it is referenced as ${hiveconf:var1} just to differentiate between user variables and system overrides ${system:varSys1}.", "author": "spena", "createdAt": "2020-09-22T00:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5ODkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMDY1Mw==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492400653", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `ksql.enable.headless.variable.substitution` as Boolean (default = true). The reason is that `SET CLI` is a CLI-specific command not available\n          \n          \n            \n            `ksql.headless.variable.substitution.enable` as Boolean (default = true). The reason is that `SET CLI` is a CLI-specific command not available", "author": "agavra", "createdAt": "2020-09-21T23:24:44Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `${}` characters (i.e. `${replicas}`).\n+\n+Noe: We need to make changes in QTT tests to use `${}` references instead of `{}` for consistency.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='${format}', replicas=${replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are case-insensitive. A reference to `${replicas}` is the same as `${REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed in specific SQL statements. They can be used to replace text and non-text literals, and identifiers such as\n+column names and stream/table names. Variables cannot be used as reserved keywords.\n+\n+For instance:\n+\n+Note: `{VAR}` is used a reference where variables are permitted.\n+```\n+ksql> CREATE STREAM ${streamName} (${colName1} INT, ${colName2} STRING) \\\n+      WITH (kafka_topic='${topicName}', format='${format}', replicas=${replicas}, ...);\n+      \n+ksql> INSERT INTO ${streamName} (${colName1}, ${colName2}) \\\n+      VALUES (${val1}, '${val2}');\n+\n+ksql> SELECT * FROM ${streamName} \\\n+      WHERE ${colName1} == ${val1} and ${colName2} == '${val2}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.\n+\n+Variables can also be assigned to other variables:\n+```\n+ksql> DEFINE var1 = 'topic';\n+ksql> DEFINE var2 = 'other_${var1}';\n+ksql> DEFINE var2;\n+DEFINE var2    = 'other_topic'\n+```\n+\n+Variables can also be assigned to set server or CLI settings:\n+```\n+ksql> DEFINE offset = 'earliest'\n+ksql> SET 'auto.offset.reset' = '${offset}';\n+\n+ksql> DEFINE wrap_toggle = 'ON'\n+ksql> SET CLI WRAP ${WRAP_TOGGLE}\n+```\n+\n+Variables can also be used as nested variables:\n+```\n+ksql> DEFINE env = 'prod';\n+\n+ksql> DEFINE topic_prod = 'my_prod_topic';\n+ksql> DEFINE topic_qa = 'my_qa_topic';\n+\n+ksql> CREATE STREAM ... WITH (kafka_topic='${topic_${env}}'); \n+```\n+\n+### 5. Enable/disable substitution variables\n+\n+When using CLI, we'll use the `SET CLI VARIABLE-SUBSTITUTION (ON|OFF)` command to enable/disable subsitution. Default will be `ON`.\n+```\n+ksql> SET CLI VARIABLE-SUBSTITUTION OFF;\n+ksql> CREATE STREAM ... WITH (kafka_topic='${topic_${env}}');\n+Error: Fail because ${topic_${env}} topic name is invalid. \n+```\n+The error message is just an example of what ksqlDB will display.\n+\n+When using SQL scripts in headless mode, we need to provide a server setting to enable/disable variable substitution. The setting will be\n+`ksql.enable.headless.variable.substitution` as Boolean (default = true). The reason is that `SET CLI` is a CLI-specific command not available", "originalCommit": "d4d905feae50519b77d5c2a572f0129f927a3d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNDU3Nw==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492414577", "bodyText": "Done.", "author": "spena", "createdAt": "2020-09-22T00:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMDY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMjEwNw==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492402107", "bodyText": "what if I don't want a literal ${foo} to be replaced? e.g. I actually want ${foo} to be the value in the statement (SELECT '${foo}' as dolla_foo FROM bar)? do i need to turn substitution off and then on after I issue the statement?", "author": "agavra", "createdAt": "2020-09-21T23:29:49Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 34 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `${}` characters (i.e. `${replicas}`).\n+\n+Noe: We need to make changes in QTT tests to use `${}` references instead of `{}` for consistency.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='${format}', replicas=${replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are case-insensitive. A reference to `${replicas}` is the same as `${REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed in specific SQL statements. They can be used to replace text and non-text literals, and identifiers such as\n+column names and stream/table names. Variables cannot be used as reserved keywords.\n+\n+For instance:", "originalCommit": "d4d905feae50519b77d5c2a572f0129f927a3d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNzUxNg==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492417516", "bodyText": "Yes,\nksql> set variable-substitution off;\nksql> SELECT '${foo}' as dolla_foo FROM bar;\nksql> set variable-substitution on;\n\nI was playing with escape characters, but the \\${foo} fails, and the \\\\${foo} results in SELECT '\\${foo}'.\nI wanted to be fancier and behave like Mysql and Posgtres. They do not substitute variables inside quotes. For instance:\nksql> CREATE ... WITH (kafka_topic=@topicName);\nor\nksql> CREATE ... WITH (kafka_topic=:topicName);\n\nI would have to trick the StringSubstitutor a little bit to reject replacing variables inside quotes, it's not a problem. The problem I had was how to replace this:\nksql> define colName = 'name';\nksql> SELECT id, ${colName} FROM stream;\n\nwould become:\nksql> SELECT id, \"name\" FROM stream;   // valid statement \nor\nksql> SELECT id, name FROM stream;     // valid statement\n\nHard to know.  You can do prepared statements in Mysql, but that's very hacky.\nhttps://stackoverflow.com/questions/4428761/mysql-field-name-from-variable", "author": "spena", "createdAt": "2020-09-22T00:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMjEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1OTEyOQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r493059129", "bodyText": "I don't think implementation should drive the design. We should define what design we want here in the KLIP, and then if it's tough to implement we can issue a known bug report and fix it later.\ncc @colinhicks do you think we need to hammer this issue out before we approve the KLIP?", "author": "agavra", "createdAt": "2020-09-22T22:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMjEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUwNTcwNQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r494505705", "bodyText": "ksql> set variable-substitution off;\nksql> SELECT '${foo}' as dolla_foo FROM bar;\nksql> set variable-substitution on;\n\nThis seems like a reasonable limitation to me.", "author": "colinhicks", "createdAt": "2020-09-24T17:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQwMjEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcxNTk1NQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492715955", "bodyText": "Do we have plans to support variable substitution in the UI? The UI handles setting properties differently from the CLI: rather than the SET/UNSET syntax for session properties supported by the CLI, query properties instead have to be set using the dropdown in the UI editor. This divergence from the CLI has confused users in the past and I worry that having a different mechanism for defining variables in the UI will lead to similar confusion.", "author": "vcrfxia", "createdAt": "2020-09-22T13:04:36Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+", "originalCommit": "57d885e63b31382fb53f1b6ff77521296fc3963a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY4NDY1OQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r493684659", "bodyText": "Yes, it's gonna be different in the UI than the CLI. I raised this question to @colinhicks too, and seems we'll have this feature separately from the UI. The reason? We'll have to work on opening temporary sessions between the client/server connections, then send variables to the server and stored them temporary there, then do the replacement in the server. That's more involved work.\nWe might need to do these changes in the future to make better UX for users.", "author": "spena", "createdAt": "2020-09-23T15:25:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcxNTk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyNTM4Mw==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492725383", "bodyText": "+1 to defining a new method for this rather than trying to piggyback off existing methods. If we don't support variable substitution in the REST API, the Java client will have to maintain variables in its own code, similar to the CLI. If we updated the CLI to use the Java client (#6269) we'd have fewer issues like these in the future but that's out of scope for this work for sure.", "author": "vcrfxia", "createdAt": "2020-09-22T13:18:05Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.", "originalCommit": "57d885e63b31382fb53f1b6ff77521296fc3963a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyNjcwOA==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492726708", "bodyText": "What's the benefit in having SOURCE allow users to execute statements similar to RUN SCRIPT? It seems confusing to have two ways to do this with only a very subtle distinction (variables set in SOURCE persist into the sessions outside the scope of the command while those for RUN SCRIPT don't). Can we have SOURCE only load variables from a file, and then ask users to use RUN SCRIPT afterwards if they want to also load statements?", "author": "vcrfxia", "createdAt": "2020-09-22T13:20:00Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be", "originalCommit": "57d885e63b31382fb53f1b6ff77521296fc3963a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY5NDE4OA==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r493694188", "bodyText": "We could that too. I'm not sure how users will use their scripts, though. Are they willing to split their scripts between vars and commands?\nI just though of using the bash behavior:\n$ cat /tmp/s1\nexport ID=1\necho id=$ID\n\n$ cat /tmp/s2\nexport ID=2\necho id=$ID\n\n$ source /tmp/s1\nid=1\n$ bash /tmp/s2\nid=2\n\n// Uses the ID set in by the source command\n$ echo $ID\n1\n\nMysql uses SOURCE too, and it allows variables and commands.\nhttps://dev.mysql.com/doc/refman/5.7/en/mysql-batch-commands.html", "author": "spena", "createdAt": "2020-09-23T15:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyNjcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4OTMxMA==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r497089310", "bodyText": "Does MySQL also have a RUN SCRIPT? I tend to agree with Victoria that this seems a little confusing.", "author": "agavra", "createdAt": "2020-09-29T22:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyNjcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyODE2Mw==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492728163", "bodyText": "Is it normal for variables to not be allowed as keywords? I don't mind but if we go with this we need to make sure we have good error messages since a natural extension (unless it's just my naivete speaking?) from the example below:\nksql> CREATE STREAM ${streamName} (${colName1} INT, ${colName2} STRING) \\\n      WITH (kafka_topic='${topicName}', format='${format}', replicas=${replicas}, ...);\n\nis to wonder about\nksql> CREATE STREAM ${streamName} (${colName1} ${colType1}, ${colName2} ${colType2}) \\\n      WITH (kafka_topic='${topicName}', format='${format}', replicas=${replicas}, ...);\n\nwhich won't be accepted based on this proposal. Hopefully the error message makes it very clear why.", "author": "vcrfxia", "createdAt": "2020-09-22T13:22:00Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `${}` characters (i.e. `${replicas}`).\n+\n+Noe: We need to make changes in QTT tests to use `${}` references instead of `{}` for consistency.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='${format}', replicas=${replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are case-insensitive. A reference to `${replicas}` is the same as `${REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed in specific SQL statements. They can be used to replace text and non-text literals, and identifiers such as\n+column names and stream/table names. Variables cannot be used as reserved keywords.", "originalCommit": "57d885e63b31382fb53f1b6ff77521296fc3963a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY5NjYwNg==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r493696606", "bodyText": "That really depends. Some big-data DBs allow any substitution, but other DBs (mysql, oracle, ...) do not allow replacing keywords. They have a different way to do that, though.\nHere's the discussion with @colinhicks about it.\n#6259 (comment)", "author": "spena", "createdAt": "2020-09-23T15:42:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyODE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA5MDA1OA==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r497090058", "bodyText": "I think given the goal (running these scripts in different environments) it's probably OK to not allow the types", "author": "agavra", "createdAt": "2020-09-29T22:10:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyODE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA5NDUyOQ==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r497094529", "bodyText": "Agreed it's fine to not allow keyword substitutions -- as long as we have good error messages. The error messages on syntax errors we have today are pretty abysmal... :)", "author": "vcrfxia", "createdAt": "2020-09-29T22:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyODE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyOTgyNA==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492729824", "bodyText": "It's interesting to me that the contents of variables are substituted into the statement directly, and it's left to the user to get the quoting of the variables correct. This makes sense but it'd be great to have helpful error messages when this goes wrong. For example, if the user mistakenly submits\nksql> CREATE STREAM ${streamName} (${colName1} INT, ${colName2} STRING) \\\n      WITH (kafka_topic=${topicName}, format='${format}', replicas=${replicas}, ...);\n\ninstead of\nksql> CREATE STREAM ${streamName} (${colName1} INT, ${colName2} STRING) \\\n      WITH (kafka_topic='${topicName}', format='${format}', replicas=${replicas}, ...);\n\nwhere the difference is that they're missing quotes around the topic name, it'd be great to have a useful error message so they aren't left guessing in the dark.", "author": "vcrfxia", "createdAt": "2020-09-22T13:24:14Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `${}` characters (i.e. `${replicas}`).\n+\n+Noe: We need to make changes in QTT tests to use `${}` references instead of `{}` for consistency.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='${format}', replicas=${replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are case-insensitive. A reference to `${replicas}` is the same as `${REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed in specific SQL statements. They can be used to replace text and non-text literals, and identifiers such as\n+column names and stream/table names. Variables cannot be used as reserved keywords.\n+\n+For instance:\n+\n+Note: `{VAR}` is used a reference where variables are permitted.\n+```\n+ksql> CREATE STREAM ${streamName} (${colName1} INT, ${colName2} STRING) \\\n+      WITH (kafka_topic='${topicName}', format='${format}', replicas=${replicas}, ...);\n+      \n+ksql> INSERT INTO ${streamName} (${colName1}, ${colName2}) \\\n+      VALUES (${val1}, '${val2}');", "originalCommit": "57d885e63b31382fb53f1b6ff77521296fc3963a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcwMDE5MA==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r493700190", "bodyText": "Right. I'll try to add a customized error. I was thinking on leverage the parsing errors, which displays an error when using ${topicName}. I'll see if the second parser can detect those undesired places.", "author": "spena", "createdAt": "2020-09-23T15:47:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcyOTgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjczMDk2Mg==", "url": "https://github.com/confluentinc/ksql/pull/6259#discussion_r492730962", "bodyText": "fail with the current SQL parsing error found when parsing the variable string\n\nAs mentioned above, I think we'll want better error messages here. The SQL parsing errors we see today are awful in terms of debuggability and I worry that variable substitution will make this all the more confusing. Can we make improving these error messages in scope for this work, or is that too much?", "author": "vcrfxia", "createdAt": "2020-09-22T13:25:39Z", "path": "design-proposals/klip-38-variable-substitution.md", "diffHunk": "@@ -0,0 +1,302 @@\n+# KLIP 38 - Variable Substitution\n+\n+**Author**: Sergio Pe\u00f1a (@spena) |\n+**Release Target**: 0.14 |\n+**Status**: _In Discussion_ |\n+**Discussion**: TBD\n+\n+**tl;dr:** _Allow users to use variable substitution in SQL statements. Variable substitution enable users to write SQL scripts with customized output based on their environment needs._\n+\n+## Motivation and background\n+\n+The current plan to provide tooling and syntax for ksqlDB migrations enable users to write SQL scripts\n+that can be run in CI/CD environments to verify their schema will work as expected. Also, it is very common for users\n+to run their SQL scripts in different environments (QA, Devel, Prod, ...) to validate ksqlDB functionality. In order\n+to give more flexibility on customizing their SQL output, we can support variable substitution to help separate\n+environment-specific configuration variables from SQL code.\n+\n+This KLIP proposes a new syntax to define and interact with user variables, and implementation details to allow\n+variable substitution in SQL commands.\n+\n+Issue: https://github.com/confluentinc/ksql/issues/6199\n+\n+## What is in scope\n+\n+* Define a new syntax to declare and interact with user variables\n+* Allow variable substitution in SQL commands\n+* Discuss the context and scope for variable substitution\n+* Provide a configuration to enable/disable variable substitution\n+* Support variable substitution in interactive and headless mode\n+\n+## What is not in scope\n+\n+* Provide support to prompt users to type a variable value if it wasn't defined (Other DBs support this)\n+* Support variable substitution of environment and other non-user variables\n+* Provide a set of pre-defined variables to use in the current session\n+* Support variable substitution in the REST API (cannot store variables after consecutive requests)\n+\n+## Value/Return\n+\n+Users will write richer SQL scripts with customized output based on user variables.\n+\n+These SQL scripts may run using specific settings (topic names/format, replicas/partitions, expressions)\n+allowing users to easily test the behavior in different environments (CI/CD, QA clusters, Devel/Prod environments, etc).\n+\n+## Public APIS\n+\n+* New syntax will be added to interact with user variables\n+* A new CLI command and/or configuration will be added to disable/enable variable substitution\n+* SQL syntax will be modified to support variable references\n+\n+## Design\n+\n+### 1. Syntax\n+\n+#### New syntax decision\n+\n+ksqlDB has a syntax to SET server and CLI properties. The use is `SET` for server properties, and `SET CLI` for CLI settings.\n+\n+For instance:\n+```\n+ksql> SET 'auto.offset.reset' = 'earliest';\n+ksql> SET CLI WRAP OFF;\n+```\n+\n+The quickest assumption is that we can use `SET` for user variables as well. But, we cannot re-use any of the above syntax because\n+of conflicts with current server and CLI setting names. So a new keyword must be use.\n+\n+Some ideas:\n+```\n+SET LOCAL   var1 = 'val1';\n+SET SESSION var1 = 'val1';\n+SET VAR     var1 = 'val1';\n+```\n+\n+`LOCAL` is confusing for users coming from other DBs environments. `LOCAL` is used to keep the scope on per-transaction basis. After a statement\n+is executed, the variable is destroyed.\n+\n+`SESSION` may be also confusing. `SESSION` is used on other DBs to override system variables for that session only. System variables are like ksqlDB\n+server properties.\n+\n+`VAR` seems a better name.\n+\n+However, we're now overloading the use of `SET` statements. For instance, in the future, we might want to use `SET ROLE`  to set the current role\n+fo the user when interacting with an RBAC server. But, if we want to print variable information, how would we do it?\n+```\n+SET VAR var1;  # prints var1 name\n+SET VAR;       # lists all variables\n+SET;           # what to do? lists all server, cli, variables, etc?\n+```\n+\n+Also, the use of single-quotes in `SET` server settings is tedious to type. So after removing them, we'll have two different sets:\n+* `SET 'server_property' = 'server_value'`\n+* `SET VAR variable = `variable_value'\n+\n+This looks confusing too. So we have to decide for a new syntax for substitution variables.\n+\n+Other DBs use different syntax to create user variables (DECLARE, DEFINE, \\set, SET). For ksqlDB, I'll choose to use `DEFINE` and `UNDEFINE` which\n+is what Oracle SQL*plus uses. Any user coming from this DB will immediately understand the command.  \n+This is opened to discussion, but will continue with this for now.\n+\n+#### Creating and printing substitution variables\n+\n+The command to interact with substitution variables is `DEFINE`.  \n+`DEFINE` will allow us to define a new variable, print the variable value and list all current defined variables.\n+\n+Syntax:\n+```\n+DEFINE [name [= 'value']];\n+\n+Where: \n+  name     is the variable name to define\n+  value    is the variable value\n+```\n+Valid variables names start with a letter or underscore (\\_) followed by zero or more alphanumeric characters or underscores.\n+\n+All variable values need to be wrapped using single quotes. All variables are stored as string values in memory, and when\n+replaced, the value without the quotes will be used. ksqlDB parsing will be in charge of determining the format at that\n+time.\n+\n+The reason not to remove single-quotes from values is to allow spaces, and to leave the syntax open for using data types in the future if required.  \n+Also, having decide the format at run-time (i.e. `define n = 3.34238`) is tricky as we could lose precision in case of decimals. Better stay with Strings for now.\n+\n+Define a new variable:\n+```\n+ksql> DEFINE replicas = '3';\n+ksql> DEFINE partitions = '5';\n+```\n+\n+Print a defined variable value:\n+```\n+ksql> DEFINE replicas;\n+DEFINE replicas   = '3'\n+```\n+\n+List all defined variables:\n+```\n+ksql> DEFINE;\n+DEFINE replicas   = '3'\n+DEFINE partitions = '5'\n+```\n+\n+#### Deleting substitution variables\n+\n+The `UNDEFINE` command deletes the variable.\n+\n+Syntax:\n+```\n+UNDEFINE name;\n+```\n+\n+### 2. Scope\n+\n+This variable has a session scope.\n+\n+Variables will live during the session of a ksqlDB connection, then destroyed when the connection is closed. Only the user\n+in that session can interact with the defined substitution variables. No other users can interact with other users' variables.\n+\n+In CLI, the session is opened when starting the CLI with the `ksql` command, and destroyed when typing `exit`.\n+\n+In Java API client, the session is opened when `Client.create()` is called, and closed when `Client.close()` is called. Variables\n+may be defined using a client method instead of a new syntax. This is to ensure users know the scope starts after the `create()` call.\n+\n+TBD: Define a Java API method for variable substitution.\n+\n+In headless, the session is opened when starting the ksqlDB server with a SQL script. The variables stay alive until the server is\n+killed.\n+\n+Variables are not persisted anywhere. They are living in memory as long as the session is not terminated.\n+\n+#### RUN SCRIPT command\n+\n+If a `RUN SCRIPT` command is executed in a CLI session, then any variable defined there will be local to the execution context of the\n+script. The variables will override any variable previously defined in the session. When the script is completed, all local variables\n+defined will be destroyed. This ensures users do not override their session variables by accident when running `RUN SCRIPT` commands.\n+\n+#### The SOURCE command\n+\n+To allow users load variables and keep their scope in the session, then the new `SOURCE` command will be added. This will override\n+any previously defined variables, and will be destroyed until the user leaves the session.\n+\n+Syntax:\n+```\n+SOURCE '<script_file>';\n+```\n+\n+The `SOURCE` command will work like a `RUN SCRIPT`. If other SQL statements are in the file, then those statements will also be\n+executed, thus to avoid limiting users from using DDL/DML commands while defining variables at the same time from one single script.\n+\n+`SOURCE` will be used only on the CLI and headless mode. REST API will not accept it because files may be out of the scope of the server filesystem.\n+\n+### 3. Referencing substitution variables\n+\n+Variables will be referenced by wrapping the variable between `${}` characters (i.e. `${replicas}`).\n+\n+Noe: We need to make changes in QTT tests to use `${}` references instead of `{}` for consistency.\n+\n+Example:\n+```\n+ksql> DEFINE format = 'AVRO';\n+ksql> DEFINE replicas = '3';\n+ksql> CREATE STREAM stream1 (id INT) WITH (kafka_topic='stream1', value_format='${format}', replicas=${replicas});\n+```\n+\n+Substitution will not attempt to add single-quotes to the values. Users will need to know the data type to use when using a variable. The ksqlDB\n+server will be in charge of parsing and failing if the type is not allowed.\n+\n+Note: Variables are case-insensitive. A reference to `${replicas}` is the same as `${REPLICAS}`.\n+\n+### 4. Context for substitution variables\n+\n+Variable substitution will be allowed in specific SQL statements. They can be used to replace text and non-text literals, and identifiers such as\n+column names and stream/table names. Variables cannot be used as reserved keywords.\n+\n+For instance:\n+\n+Note: `{VAR}` is used a reference where variables are permitted.\n+```\n+ksql> CREATE STREAM ${streamName} (${colName1} INT, ${colName2} STRING) \\\n+      WITH (kafka_topic='${topicName}', format='${format}', replicas=${replicas}, ...);\n+      \n+ksql> INSERT INTO ${streamName} (${colName1}, ${colName2}) \\\n+      VALUES (${val1}, '${val2}');\n+\n+ksql> SELECT * FROM ${streamName} \\\n+      WHERE ${colName1} == ${val1} and ${colName2} == '${val2}' EMIT CHANGES; \n+```\n+Any attempt of using variables on non-permitted places will fail with the current SQL parsing error found when parsing the variable string.", "originalCommit": "57d885e63b31382fb53f1b6ff77521296fc3963a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "20eb900f5c94d1a3153c3f7c5c7e05dfe718f15f", "url": "https://github.com/confluentinc/ksql/commit/20eb900f5c94d1a3153c3f7c5c7e05dfe718f15f", "message": "fix: address feedback\n\n- fix minor doc details", "committedDate": "2020-09-24T16:25:11Z", "type": "forcePushed"}, {"oid": "1e0d551fb2db3157895e36648c28169eae77b04f", "url": "https://github.com/confluentinc/ksql/commit/1e0d551fb2db3157895e36648c28169eae77b04f", "message": "docs: KLIP-38 for Variable Substitution", "committedDate": "2020-10-07T21:26:10Z", "type": "commit"}, {"oid": "010a86c21ac791185f70e020f2ce39a7e6d222e5", "url": "https://github.com/confluentinc/ksql/commit/010a86c21ac791185f70e020f2ce39a7e6d222e5", "message": "docs: addressed feedback 1\n\n- Use ${} instead of {} to avoid JSON literal conflicts\n- Use variables for other identifiers such as column names and source names\n- Minor doc fixes", "committedDate": "2020-10-07T21:26:10Z", "type": "commit"}, {"oid": "139b81d1627a968d38acdaf771f9c5baae3e6f5f", "url": "https://github.com/confluentinc/ksql/commit/139b81d1627a968d38acdaf771f9c5baae3e6f5f", "message": "fix: address feedback\n\n- fix minor doc details", "committedDate": "2020-10-07T21:26:10Z", "type": "commit"}, {"oid": "c406bfb86a9193156247bcd784667c25bf549e2c", "url": "https://github.com/confluentinc/ksql/commit/c406bfb86a9193156247bcd784667c25bf549e2c", "message": "fix: add server-side variable substitution and other details", "committedDate": "2020-10-07T21:26:10Z", "type": "forcePushed"}, {"oid": "5481d8b74f5b6ba5d532148baf553b05936633c1", "url": "https://github.com/confluentinc/ksql/commit/5481d8b74f5b6ba5d532148baf553b05936633c1", "message": "fix: add server-side variable substitution and other details", "committedDate": "2020-10-07T21:41:01Z", "type": "commit"}, {"oid": "5481d8b74f5b6ba5d532148baf553b05936633c1", "url": "https://github.com/confluentinc/ksql/commit/5481d8b74f5b6ba5d532148baf553b05936633c1", "message": "fix: add server-side variable substitution and other details", "committedDate": "2020-10-07T21:41:01Z", "type": "forcePushed"}, {"oid": "52f80e5bd6c1b12863aa677f4c6b20f29812f66d", "url": "https://github.com/confluentinc/ksql/commit/52f80e5bd6c1b12863aa677f4c6b20f29812f66d", "message": "fix: remove SOURCE command proposal", "committedDate": "2020-10-08T14:48:14Z", "type": "commit"}, {"oid": "52f80e5bd6c1b12863aa677f4c6b20f29812f66d", "url": "https://github.com/confluentinc/ksql/commit/52f80e5bd6c1b12863aa677f4c6b20f29812f66d", "message": "fix: remove SOURCE command proposal", "committedDate": "2020-10-08T14:48:14Z", "type": "forcePushed"}]}