{"pr_number": 6144, "pr_title": "test: stabilise TlsTest", "pr_createdAt": "2020-09-02T21:40:35Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6144", "timeline": [{"oid": "425be4f80022a36ff41027ddffa7fd7f2708c8e2", "url": "https://github.com/confluentinc/ksql/commit/425be4f80022a36ff41027ddffa7fd7f2708c8e2", "message": "test: stabilise TlsTest\n\nfixes an issue where the TlsTest was failing because the file watcher wasn't detecting the change of the Tls cert from valid to invalid.  This was because of a limitation of JDK 8, which has only second resolution for `FileTime`, meaning the `WatchService` can miss updated made to files that existed before the watch was registered, if the update happened after the watch was started and the updated didn't change the last modified time, i.e. the last modified time both before and after the update was in the second second.\n\nThe fix is to insert a sleep to ensure at least one whole second has elapsed.\n\nIn production code, this one second window of bad behaviour is highly unlikely to be hit, and there's no real way to solve it, except upgrading to JDK 9.", "committedDate": "2020-09-02T21:39:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxMTUwNw==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r482611507", "bodyText": "why did we change this to swallow interrupted exceptions? seems like an atni-pattern", "author": "agavra", "createdAt": "2020-09-03T00:13:55Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/FileWatcher.java", "diffHunk": "@@ -45,45 +46,45 @@\n   private volatile boolean shutdown;\n   private final WatchService watchService;\n   private final Path file;\n+  private final Path dir;\n   private final Callback callback;\n+  private final WatchKey key;\n \n   @SuppressFBWarnings(\n       value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\",\n       justification = \"Null check on file.getParent() is present\"\n   )\n   public FileWatcher(final Path file, final Callback callback) throws IOException {\n     this.file = Objects.requireNonNull(file);\n-    Objects.requireNonNull(file.getParent(), \"Watch location must have parent\");\n+    this.dir = Objects.requireNonNull(file.getParent(), \"Watch location must have parent\");\n     this.watchService = FileSystems.getDefault().newWatchService();\n+    this.callback = Objects.requireNonNull(callback);\n+\n     // Listen to both CREATE and MODIFY to reload, which handles delete then create.\n-    file.getParent().register(watchService,\n+    this.key = dir.register(watchService,\n         StandardWatchEventKinds.ENTRY_CREATE,\n         StandardWatchEventKinds.ENTRY_MODIFY);\n-    this.callback = Objects.requireNonNull(callback);\n   }\n \n   /**\n    * Closes the file watcher\n    */\n   public void shutdown() {\n+    log.info(\"Stopping file watcher from watching for changes: \" + file);\n     shutdown = true;\n   }\n \n   @Override\n   public void run() {\n     log.info(\"Starting file watcher to watch for changes: \" + file);\n     try {\n-      while (!shutdown) {\n+      while (!shutdown && key.isValid()) {\n         try {\n           handleNextWatchNotification();\n-        } catch (InterruptedException e) {\n-          throw e;\n         } catch (Exception e) {", "originalCommit": "425be4f80022a36ff41027ddffa7fd7f2708c8e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc1NzcyMw==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r484757723", "bodyText": "Because the code doesn't interrupt the thread any more.", "author": "big-andy-coates", "createdAt": "2020-09-08T08:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxMTUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyNjU5MA==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r485026590", "bodyText": "I still don't think that we should be swallowing the interrupted exception - I don't see the benefit (we lose nothing by keeping it, we might lose something by removing it). Just because the code today doesn't intentionally interrupt this thread, it doesn't mean that future code won't or that there is some code we didn't audit that does.", "author": "agavra", "createdAt": "2020-09-08T15:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxMTUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcwNTUyMQ==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r485705521", "bodyText": "It's generally considered bad practice to us interrupts to control thread lifecycles.  Given we're not, if someone wants to shutdown this thread they should call shutdown on the watcher and the code will do the right thing.  If they try interrupting the thread then the code will log a unexpected exception error and continue - this to me is the right behaviour: interrupt exceptions aren't expected and shouldn't be used to control the lifecycle of this thread.\nConversely, allowing interrupts to shutdown the thread would mean the thread would shutdown but the shutdown flag would be false.  Now someone else comes along and adds code that checks this flag to test the thread is not shutdown... and we have a bug!\nIn short, if we don't want to use exceptions for normal thread lifecycle control, then we should treat interrupted exceptions like any other unexpected exception.", "author": "big-andy-coates", "createdAt": "2020-09-09T15:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxMTUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcxOTA2OA==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r485719068", "bodyText": "I didn't mean to suggest that we should shutdown the thread on interrupt but at we should catch it and reset the thread's interrupt flag to make sure we don't loose this information. I'll defer to Brian Goetz's article as he makes the point way better than I can: https://www.ibm.com/developerworks/library/j-jtp05236/index.html\nThe relevant part:\n\nIf you catch InterruptedException but cannot rethrow it, you should preserve evidence that the interruption occurred so that code higher up on the call stack can learn of the interruption and respond to it if it wants to. This task is accomplished by calling interrupt() to \"reinterrupt\" the current thread, as shown in Listing 3. At the very least, whenever you catch InterruptedException and don't rethrow it, reinterrupt the current thread before returning.\nThe worst thing you can do with InterruptedException is swallow it -- catch it and neither rethrow it nor reassert the thread's interrupted status. The standard approach to dealing with an exception you didn't plan for -- catch it and log it -- also counts as swallowing the interruption because code higher up on the call stack won't be able to find out about it. (Logging InterruptedException is also just silly because by the time a human reads the log, it is too late to do anything about it.)", "author": "agavra", "createdAt": "2020-09-09T15:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxMTUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxMjAzNQ==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r482612035", "bodyText": "should we backoff or something here? I feel like polling every second is going to make this thread take up way more resources that it needs to (how often do certs change? monthly?)\nI'm also not entirely sure why this poll is necessary (why not just use take)?", "author": "agavra", "createdAt": "2020-09-03T00:15:26Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/FileWatcher.java", "diffHunk": "@@ -95,23 +96,23 @@ public void run() {\n   }\n \n   @SuppressWarnings(\"unchecked\")\n-  @SuppressFBWarnings(\n-      value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\",\n-      justification = \"Null check on file.getParent() is present above\"\n-  )\n   private void handleNextWatchNotification() throws InterruptedException {\n-    // wait for key to be signalled\n-    final WatchKey key = watchService.take();\n-    log.info(\"Watch Key notified\");\n+    final WatchKey key = watchService.poll(1, TimeUnit.SECONDS);\n+    if (key == null) {", "originalCommit": "425be4f80022a36ff41027ddffa7fd7f2708c8e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA0NzMwMQ==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r483047301", "bodyText": "+1 I'm confused why this change was made.", "author": "vcrfxia", "createdAt": "2020-09-03T15:01:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxMjAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2MDU5NA==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r484760594", "bodyText": "take blocks and requires the use of interrupts to shutdown the thread. This is generally considered an anti-pattern and goes against the \"use exceptions for exceptional cases only\" paradigm.\nNot that the old code interrupted the thread to shut it down, which mean it would only shutdown on the next file change after the shutdown call.  Likely, this wasn't an issue in tests as:\na) the tests probably weren't waiting for this thread to shutdown\nb) the directory the tests were using was also used by other tests and processes and so sees lots of file changes.\nBut this could be an issue in the final product, as the JVM wouldn't exit until this thread shutdown.\nExiting the poll every second, and then immediately looping and re-entering the poll, will take almost no CPU cycles and allows it to exit gracefully, and is generally considered a better pattern to one involving interrupting the thread.\nAs for adding a backoff... I really don't think a thread waking every second and looping is worth worrying about and adding more code.  Time and code is better spent elsewhere, and less code means less bugs.", "author": "big-andy-coates", "createdAt": "2020-09-08T08:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxMjAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyNTUzNQ==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r485025535", "bodyText": "This is generally considered an anti-pattern and goes against the \"use exceptions for exceptional cases only\" paradigm.\n\nI agree that requiring interrupts to shutdown the thread should be avoided, but I've seen different workarounds to this problem (specifically when using BlockingQueue) - the most popular of which is adding a sentinel into the queue to wake up the blocked thread.\nI'm not familiar with WatchService, but is it possible to do something similar (e.g. touch a lock file)? I understand your reasoning now, so if there isn't clean we can do then I'm happy proceeding with this", "author": "agavra", "createdAt": "2020-09-08T15:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxMjAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcwNzYyMw==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r485707623", "bodyText": "Sounds like more code for the sake of it.   Are you really worried about a thread waking every second and looping?", "author": "big-andy-coates", "createdAt": "2020-09-09T15:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxMjAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA0Njg3MQ==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r483046871", "bodyText": "I've seen it take a number of seconds for the server to restart with the new cert after it's loaded. Even if the test fails, we should wait for the new cert to be loaded, which is why there's an assertThatEventually here, otherwise the next test that runs will likely fail.", "author": "vcrfxia", "createdAt": "2020-09-03T15:01:19Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/api/TlsTest.java", "diffHunk": "@@ -117,27 +122,47 @@ public void shouldReloadCert() throws Exception {\n           TimeUnit.SECONDS.toMillis(1),\n           TimeUnit.SECONDS.toMillis(1)\n       );\n+    } catch (final Throwable e) {\n+      failed = true;\n+      throw e;\n     } finally {\n       // restore cert regardless of failure above so as to not affect other tests\n       // When: load valid store\n-      SERVER_KEY_STORE.loadValidServerKeyStore();\n-\n-      assertThatEventually(\n-          \"Should successfully execute query with valid key store\",\n-          () -> {\n-            // re-create client since server port changes on restart\n-            this.client = createClient();\n-\n-            try {\n-              return sendRequest(\"/query-stream\", requestBody.toBuffer()).statusCode();\n-            } catch (Exception e) {\n-              return 0;\n-            }\n-          },\n-          is(200),\n-          TimeUnit.SECONDS.toMillis(1),\n-          TimeUnit.SECONDS.toMillis(1)\n-      );\n+      SERVER_KEY_STORE.writeValidServerKeyStore();\n+\n+      if (!failed) {", "originalCommit": "425be4f80022a36ff41027ddffa7fd7f2708c8e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2NjIxMA==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r484766210", "bodyText": "Actually, as I've changed ServerKeyStore to be non-static, there's no need for this to happen any more.  There's only one test in the class, and this class won't interfere with other classes... so no need to change, right?", "author": "big-andy-coates", "createdAt": "2020-09-08T09:05:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA0Njg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkyNDIzNQ==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r484924235", "bodyText": "Looks like my comment from the previous PR wasn't addressed before merging: #6053 (comment)\nI contend there should be multiple tests running in this class \ud83d\ude04", "author": "vcrfxia", "createdAt": "2020-09-08T13:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA0Njg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMzM4Ng==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r485503386", "bodyText": "I'll sort that and this then ;)", "author": "big-andy-coates", "createdAt": "2020-09-09T10:21:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA0Njg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA0NzA5MA==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r483047090", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void willStopIfDirectoryDeleted() throws Exception {\n          \n          \n            \n              public void shouldStopIfDirectoryDeleted() throws Exception {\n          \n      \n    \n    \n  \n\nSame for the test below.", "author": "vcrfxia", "createdAt": "2020-09-03T15:01:35Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/api/server/FileWatcherTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.timeout;\n+import static org.mockito.Mockito.verify;\n+\n+import io.confluent.ksql.api.server.FileWatcher.Callback;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.FileTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class FileWatcherTest {\n+\n+  @ClassRule\n+  public static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  @Mock\n+  private Callback callback;\n+  public Path filePath;\n+  private FileWatcher watcher;\n+  private byte[] someBytes;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    filePath = TMP.newFolder().toPath().resolve(UUID.randomUUID().toString());\n+    someBytes = \"data\".getBytes(UTF_8);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    watcher.shutdown();\n+  }\n+\n+  @Test\n+  public void shouldDetectFileCreated() throws Exception {\n+    // Given:\n+    watcher = new FileWatcher(filePath, callback);\n+    watcher.start();\n+\n+    // When:\n+    Files.write(filePath, someBytes, StandardOpenOption.CREATE_NEW);\n+\n+    // Then:\n+    verify(callback, timeout(TimeUnit.MINUTES.toMillis(1))).run();\n+  }\n+\n+  @Test\n+  public void shouldDetectFileUpdated() throws Exception {\n+    // Given:\n+    Files.write(filePath, someBytes, StandardOpenOption.CREATE_NEW);\n+\n+    waitForLastModifiedTick();\n+\n+    watcher = new FileWatcher(filePath, callback);\n+    watcher.start();\n+\n+    // When:\n+    Files.write(filePath, someBytes);\n+\n+    // Then:\n+    verify(callback, timeout(TimeUnit.MINUTES.toMillis(1))).run();\n+  }\n+\n+  @Test\n+  public void shouldShutdownAsync() throws Exception {\n+    watcher = new FileWatcher(filePath, callback);\n+    watcher.start();\n+\n+    // When:\n+    watcher.shutdown();\n+\n+    // Then:\n+    assertThatEventually(watcher::isAlive, is(false));\n+  }\n+\n+  @Test\n+  public void willStopIfDirectoryDeleted() throws Exception {", "originalCommit": "425be4f80022a36ff41027ddffa7fd7f2708c8e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc1ODUyNw==", "url": "https://github.com/confluentinc/ksql/pull/6144#discussion_r484758527", "bodyText": "Well... I don't think it should, it just happens that it will.  Hence the naming.\nI wanted a test that captured the current behaviour, but named so that it doesn't say that is how it 'should' be.", "author": "big-andy-coates", "createdAt": "2020-09-08T08:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA0NzA5MA=="}], "type": "inlineReview"}, {"oid": "8ecd7de537bc107ebad71a8a80b7cc9e838458ca", "url": "https://github.com/confluentinc/ksql/commit/8ecd7de537bc107ebad71a8a80b7cc9e838458ca", "message": "chore: requested changes", "committedDate": "2020-09-09T15:37:11Z", "type": "commit"}, {"oid": "eaaccf79d1e4184ae4a332250e7ddc7463b4845c", "url": "https://github.com/confluentinc/ksql/commit/eaaccf79d1e4184ae4a332250e7ddc7463b4845c", "message": "test: remove flaky test", "committedDate": "2020-09-10T19:29:08Z", "type": "commit"}]}