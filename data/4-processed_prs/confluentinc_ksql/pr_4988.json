{"pr_number": 4988, "pr_title": "chore: add analysis/formatting around multi-way joins", "pr_createdAt": "2020-04-03T18:39:32Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4988", "timeline": [{"oid": "cb5013b803f213b1b66de72e1bd1388db5530ceb", "url": "https://github.com/confluentinc/ksql/commit/cb5013b803f213b1b66de72e1bd1388db5530ceb", "message": "fix: rebase removed import", "committedDate": "2020-04-06T17:01:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAzMjUzMQ==", "url": "https://github.com/confluentinc/ksql/pull/4988#discussion_r405032531", "bodyText": "Just curious, does it matter that you keep passing in left?  What if two of the rights are the same.  Seems like it would miss the self-join check.", "author": "AlanConfluent", "createdAt": "2020-04-07T18:43:27Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java", "diffHunk": "@@ -286,12 +286,23 @@ protected AstNode visitJoin(final Join node, final Void context) {\n       process(node.getLeft(), context);\n       node.getRights().forEach(right -> process(right.getRelation(), context));\n \n-      final JoinNode.JoinType joinType = getJoinType(node);\n-\n       final AliasedDataSource left = analysis.getFromDataSources().get(0);\n-      final AliasedDataSource right = analysis.getFromDataSources().get(1);\n \n-      final JoinedSource source = Iterables.getOnlyElement(node.getRights());\n+      final ImmutableList<JoinedSource> rights = node.getRights();\n+      for (int i = 0; i < rights.size(); i++) {\n+        final JoinedSource source = rights.get(i);\n+        visitJoinedSource(left, analysis.getFromDataSources().get(i + 1), source);", "originalCommit": "cb5013b803f213b1b66de72e1bd1388db5530ceb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA3NjkwMw==", "url": "https://github.com/confluentinc/ksql/pull/4988#discussion_r405076903", "bodyText": "good catch - I think I need to rework some of this (especially after talking with @vpapavas)", "author": "agavra", "createdAt": "2020-04-07T20:01:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAzMjUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAzNzExNg==", "url": "https://github.com/confluentinc/ksql/pull/4988#discussion_r405037116", "bodyText": "Is this part of a followup?", "author": "AlanConfluent", "createdAt": "2020-04-07T18:51:05Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -425,6 +426,8 @@ private PlanNode buildSourceNode() {\n \n     if (sources.size() == 1) {\n       throw new IllegalStateException(\"Expected more than one source. Got \" + sources.size());\n+    } else if (sources.size() != 2) {\n+      throw new KsqlException(\"ksqlDB does not support multi-way joins.\");", "originalCommit": "cb5013b803f213b1b66de72e1bd1388db5530ceb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA3NzAyMA==", "url": "https://github.com/confluentinc/ksql/pull/4988#discussion_r405077020", "bodyText": "yup! I wanted to split it up into smaller PRs", "author": "agavra", "createdAt": "2020-04-07T20:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAzNzExNg=="}], "type": "inlineReview"}, {"oid": "36cedf0d719cec3ee0ba381ce1323fd05c814423", "url": "https://github.com/confluentinc/ksql/commit/36cedf0d719cec3ee0ba381ce1323fd05c814423", "message": "chore: add analysis/formatting around multi-way joins", "committedDate": "2020-04-09T00:49:55Z", "type": "commit"}, {"oid": "36cedf0d719cec3ee0ba381ce1323fd05c814423", "url": "https://github.com/confluentinc/ksql/commit/36cedf0d719cec3ee0ba381ce1323fd05c814423", "message": "chore: add analysis/formatting around multi-way joins", "committedDate": "2020-04-09T00:49:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyNDc5OQ==", "url": "https://github.com/confluentinc/ksql/pull/4988#discussion_r406924799", "bodyText": "I feel like I've seen a lot of the same bits of code error checking column references, such as in Analyze where it does column name validation.  Wondering if this can be consolidated a bit.", "author": "AlanConfluent", "createdAt": "2020-04-10T20:18:16Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/rewrite/DataSourceExtractor.java", "diffHunk": "@@ -58,64 +53,37 @@\n \n   public void extractDataSources(final AstNode node) {\n     new Visitor().process(node, null);\n-    commonColumnNames.addAll(Sets.intersection(leftColumnNames, rightColumnNames));\n-  }\n-\n-  public SourceName getFromAlias() {\n-    return fromAlias;\n-  }\n-\n-  public SourceName getLeftAlias() {\n-    return leftAlias;\n-  }\n-\n-  public SourceName getRightAlias() {\n-    return rightAlias;\n   }\n \n-  public Set<DataSource> getAllSources() {\n-    return Collections.unmodifiableSet(allSources);\n+  public Set<AliasedDataSource> getAllSources() {\n+    return ImmutableSet.copyOf(allSources);\n   }\n \n   public Set<ColumnName> getCommonColumnNames() {\n     return Collections.unmodifiableSet(commonColumnNames);\n   }\n \n-  public SourceName getFromName() {\n-    return fromName;\n-  }\n-\n-  public SourceName getLeftName() {\n-    return leftName;\n-  }\n-\n-  public SourceName getRightName() {\n-    return rightName;\n-  }\n-\n   public boolean isJoin() {\n     return isJoin;\n   }\n \n   public SourceName getAliasFor(final ColumnName columnName) {\n-    if (isJoin) {\n-      if (commonColumnNames.contains(columnName)) {\n-        throw new KsqlException(\"Column '\" + columnName.text() + \"' is ambiguous.\");\n-      }\n-\n-      if (leftColumnNames.contains(columnName)) {\n-        return leftAlias;\n-      }\n-\n-      if (rightColumnNames.contains(columnName)) {\n-        return rightAlias;\n-      }\n+    if (!isJoin) {\n+      return Iterables.getOnlyElement(allSources).getAlias();\n+    }\n \n-      throw new KsqlException(\n-          \"Column '\" + columnName.text() + \"' cannot be resolved.\"\n-      );\n+    final List<SourceName> source = allSources.stream()\n+        .filter(aliased -> aliased.getDataSource().getSchema().findColumn(columnName).isPresent())\n+        .map(AliasedDataSource::getAlias)\n+        .collect(Collectors.toList());\n+\n+    if (source.size() > 1) {", "originalCommit": "36cedf0d719cec3ee0ba381ce1323fd05c814423", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkzNjY0Ng==", "url": "https://github.com/confluentinc/ksql/pull/4988#discussion_r406936646", "bodyText": "totally agree - I think this whole class should be removed, but that's a problem for another time :)", "author": "agavra", "createdAt": "2020-04-10T20:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyNDc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkzMTU4NQ==", "url": "https://github.com/confluentinc/ksql/pull/4988#discussion_r406931585", "bodyText": "I assume this is in place of the join code, which you've removed.  Why was join special-cased before?", "author": "AlanConfluent", "createdAt": "2020-04-10T20:33:50Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/rewrite/DataSourceExtractor.java", "diffHunk": "@@ -126,50 +94,34 @@ public Void visitRelation(final Relation relation, final Void ctx) {\n \n     @Override\n     public Void visitAliasedRelation(final AliasedRelation relation, final Void ctx) {\n-      fromAlias = relation.getAlias();\n-      fromName = ((Table) relation.getRelation()).getName();\n+      final SourceName fromName = ((Table) relation.getRelation()).getName();\n       final DataSource source = metaStore.getSource(fromName);\n       if (source == null) {\n         throw new KsqlException(fromName.text() + \" does not exist.\");\n       }\n \n-      allSources.add(source);\n+      allSources.add(new AliasedDataSource(relation.getAlias(), source));", "originalCommit": "36cedf0d719cec3ee0ba381ce1323fd05c814423", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkzMzk1NA==", "url": "https://github.com/confluentinc/ksql/pull/4988#discussion_r406933954", "bodyText": "you are right, this does the same thing, but is just cleaner IMO - when there were just two sides of a join it wasn't too bad to special case it, but I don't think there was any good reason to", "author": "agavra", "createdAt": "2020-04-10T20:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkzMTU4NQ=="}], "type": "inlineReview"}]}