{"pr_number": 6628, "pr_title": "chore: support complex key pull queries", "pr_createdAt": "2020-11-17T01:28:26Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6628", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg4NjA1Mw==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r524886053", "bodyText": "Do we want to support generic expressions in pull query WHERE clauses at this time? Last I spoke to @AlanConfluent it sounded like we wanted to limit support to literal expressions (i.e., those that create arrays and structs with literal values) for now.", "author": "vcrfxia", "createdAt": "2020-11-17T05:03:16Z", "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/pull-queries-against-materialized-aggregates.json", "diffHunk": "@@ -1927,17 +1914,90 @@\n       }\n     },\n     {\n-      \"name\": \"IN: fail on non-literal key\",\n+      \"name\": \"non-windowed - function in where clause\",", "originalCommit": "60e2c17146102441da6556b34ebdff228f627c25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMxNjQwMQ==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525316401", "bodyText": "it would be more work to not support this than to support this. Is there any reason why we don't want to?", "author": "agavra", "createdAt": "2020-11-17T16:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg4NjA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NTk4Mw==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525555983", "bodyText": "What should be supported is functions on literals, maps and arrays of literals but not functions on columns?", "author": "vpapavas", "createdAt": "2020-11-17T22:05:48Z", "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/pull-queries-against-materialized-aggregates.json", "diffHunk": "@@ -1927,17 +1914,103 @@\n       }\n     },\n     {\n-      \"name\": \"IN: fail on non-literal key\",\n+      \"name\": \"IN: fail on column reference key\",\n       \"statements\": [\n         \"CREATE STREAM INPUT (ID INT KEY, IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n         \"CREATE TABLE AGGREGATE AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;\",\n-        \"SELECT * FROM AGGREGATE WHERE ID IN (CAST(1 AS INTEGER));\"\n+        \"SELECT * FROM AGGREGATE WHERE ID IN (COUNT + 1);\"\n       ],\n       \"expectedError\": {\n         \"type\": \"io.confluent.ksql.rest.entity.KsqlStatementErrorMessage\",\n-        \"message\": \"Only comparison to literals is currently supported: (ID IN (CAST(1 AS INTEGER)))\",\n+        \"message\": \"Unsupported column reference in pull query: (COUNT + 1)\",", "originalCommit": "d48b3b6d96d97676a0d7dfc1284cef242b727746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NjUyOA==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525556528", "bodyText": "yes, essentially anything static (column references can't be used anywhere)", "author": "agavra", "createdAt": "2020-11-17T22:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NTk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1OTU5MA==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525559590", "bodyText": "Discussed offline. In this PR we only want to support non-literal keys (maps and structs) and expressions that use only literals.", "author": "vpapavas", "createdAt": "2020-11-17T22:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NTk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2MDIzNA==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525560234", "bodyText": "Could we maybe make the IN take more than one key since that is its primary use case? Something like:\nSELECT * FROM AGGREGATE WHERE ID IN (CAST(10 AS INTEGER), CAST(\"11\" AS INTEGER));", "author": "vpapavas", "createdAt": "2020-11-17T22:14:12Z", "path": "ksqldb-functional-tests/src/test/resources/rest-query-validation-tests/pull-queries-against-materialized-aggregates.json", "diffHunk": "@@ -1927,17 +1914,103 @@\n       }\n     },\n     {\n-      \"name\": \"IN: fail on non-literal key\",\n+      \"name\": \"IN: fail on column reference key\",\n       \"statements\": [\n         \"CREATE STREAM INPUT (ID INT KEY, IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n         \"CREATE TABLE AGGREGATE AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;\",\n-        \"SELECT * FROM AGGREGATE WHERE ID IN (CAST(1 AS INTEGER));\"\n+        \"SELECT * FROM AGGREGATE WHERE ID IN (COUNT + 1);\"\n       ],\n       \"expectedError\": {\n         \"type\": \"io.confluent.ksql.rest.entity.KsqlStatementErrorMessage\",\n-        \"message\": \"Only comparison to literals is currently supported: (ID IN (CAST(1 AS INTEGER)))\",\n+        \"message\": \"Unsupported column reference in pull query: (COUNT + 1)\",\n         \"status\": 400\n       }\n+    },\n+    {\n+      \"name\": \"non-windowed - function in where clause\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID STRING KEY, IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE TABLE AGGREGATE AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;\",\n+        \"SELECT ID, COUNT, ROWTIME FROM AGGREGATE WHERE ID=CONCAT('1','0');\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"timestamp\": 12345, \"key\": \"11\", \"value\": {}},\n+        {\"topic\": \"test_topic\", \"timestamp\": 12365, \"key\": \"10\", \"value\": {}}\n+      ],\n+      \"responses\": [\n+        {\"admin\": {\"@type\": \"currentStatus\"}},\n+        {\"admin\": {\"@type\": \"currentStatus\"}},\n+        {\"query\": [\n+          {\"header\":{\"schema\":\"`ID` STRING KEY, `COUNT` BIGINT, `ROWTIME` BIGINT\"}},\n+          {\"row\":{\"columns\":[\"10\", 1, 12365]}}\n+        ]}\n+      ]\n+    },\n+    {\n+      \"name\": \"non-windowed - array keys\",\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID ARRAY<STRING> KEY, IGNORED INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE AGGREGATE AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;\",\n+        \"SELECT ID, COUNT, ROWTIME FROM AGGREGATE WHERE ID=ARRAY['1','0'];\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"timestamp\": 12345, \"key\": [\"1\", \"1\"], \"value\": {}},\n+        {\"topic\": \"test_topic\", \"timestamp\": 12365, \"key\": [\"1\", \"0\"], \"value\": {}}\n+      ],\n+      \"responses\": [\n+        {\"admin\": {\"@type\": \"currentStatus\"}},\n+        {\"admin\": {\"@type\": \"currentStatus\"}},\n+        {\"query\": [\n+          {\"header\":{\"schema\":\"`ID` ARRAY<STRING> KEY, `COUNT` BIGINT, `ROWTIME` BIGINT\"}},\n+          {\"row\":{\"columns\":[[\"1\", \"0\"], 1, 12365]}}\n+        ]}\n+      ]\n+    },\n+    {\n+      \"name\": \"non-windowed - struct keys\",\n+      \"properties\": {\n+        \"ksql.key.format.enabled\": true\n+      },\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID STRUCT<f1 STRING, f2 STRING> KEY, IGNORED INT) WITH (kafka_topic='test_topic', format='JSON');\",\n+        \"CREATE TABLE AGGREGATE AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;\",\n+        \"SELECT ID, COUNT, ROWTIME FROM AGGREGATE WHERE ID=STRUCT(F1:='1',F2:='0');\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"timestamp\": 12345, \"key\": {\"F1\": \"1\", \"F2\": \"1\"}, \"value\": {}},\n+        {\"topic\": \"test_topic\", \"timestamp\": 12365, \"key\": {\"F1\": \"1\", \"F2\": \"0\"}, \"value\": {}}\n+      ],\n+      \"responses\": [\n+        {\"admin\": {\"@type\": \"currentStatus\"}},\n+        {\"admin\": {\"@type\": \"currentStatus\"}},\n+        {\"query\": [\n+          {\"header\":{\"schema\":\"`ID` STRUCT<`F1` STRING, `F2` STRING> KEY, `COUNT` BIGINT, `ROWTIME` BIGINT\"}},\n+          {\"row\":{\"columns\":[{\"F1\": \"1\", \"F2\": \"0\"}, 1, 12365]}}\n+        ]}\n+      ]\n+    },\n+    {\n+      \"name\": \"IN: support non-literal key\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID INT KEY, IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE TABLE AGGREGATE AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;\",\n+        \"SELECT * FROM AGGREGATE WHERE ID IN (CAST(10 AS INTEGER));\"", "originalCommit": "d48b3b6d96d97676a0d7dfc1284cef242b727746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3NDg0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525574849", "bodyText": "This is just done because GenericExpressionResolver isn't as low overhead right?", "author": "AlanConfluent", "createdAt": "2020-11-17T22:44:25Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -778,31 +798,40 @@ private static Object extractKeyWhereClause(\n     }\n \n     final Expression other = getNonColumnRefSide(comparison);\n-    if (!(other instanceof Literal)) {\n-      throw new KsqlException(\"Ony comparison to literals is currently supported: \" + comparison);\n-    }\n-\n-    if (other instanceof NullLiteral) {\n-      throw new KsqlException(\"Primary key columns can not be NULL: \" + comparison);\n-    }\n-\n-    final Object right = ((Literal) other).getValue();\n-    return coerceKey(schema, right, windowed);\n+    final Column keyColumn = schema.key().get(0);\n+    return resolveKey(other, keyColumn, executionContext, config, comparison);\n   }\n \n-  private static Object coerceKey(\n-      final LogicalSchema schema,\n-      final Object right,\n-      final boolean windowed\n+  private static Object resolveKey(\n+      final Expression exp,\n+      final Column keyColumn,\n+      final KsqlExecutionContext executionContext,\n+      final KsqlConfig config,\n+      final Expression errorMessageHint\n   ) {\n-    if (schema.key().size() != 1) {\n-      throw invalidWhereClauseException(\"Only single KEY column supported\", windowed);\n+    final Object obj;\n+    if (exp instanceof NullLiteral) {\n+      obj = null;\n+    } else if (exp instanceof Literal) {\n+      // skip the GenericExpressionResolver because this is", "originalCommit": "d48b3b6d96d97676a0d7dfc1284cef242b727746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4MDYzNw==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525580637", "bodyText": "yup, that was exactly the idea", "author": "agavra", "createdAt": "2020-11-17T22:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3NDg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3ODYyMw==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525578623", "bodyText": "Just curious, how much overhead is it to compile the java into bytecode, load the bytecode, and then run it.  It makes a lot of sense when you compile once and then run many times, but in this case, there's a 1:1 relationship.  In general, it seems like interpreting the expression would be lower overhead and possibly faster.  Do we do it this way because this is the main method that currently exists for \"evaluating a sql expression\"?\nI'd be curious to run a benchmark doing just expression lookups (rather than literals).", "author": "AlanConfluent", "createdAt": "2020-11-17T22:52:08Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/generic/GenericExpressionResolver.java", "diffHunk": "@@ -76,11 +83,12 @@ public Object resolve(final Expression expression) {\n \n     @Override\n     protected Object visitExpression(final Expression expression, final Void context) {\n+      new EnsureNoColReferences(expression).process(expression, context);\n       final ExpressionMetadata metadata =\n           CodeGenRunner.compileExpression(", "originalCommit": "d48b3b6d96d97676a0d7dfc1284cef242b727746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzMTE5MA==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525631190", "bodyText": "Talked offline about this, we'll look into running specialized benchmarks to see how much the overhead is. Given that this is just \"new\" functionality, we won't block the PR on this and we'll run those benchmarks going forward.", "author": "agavra", "createdAt": "2020-11-18T01:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3ODYyMw=="}], "type": "inlineReview"}, {"oid": "5dd79121d58e310f4cac749c0dbfa5a1f53fec48", "url": "https://github.com/confluentinc/ksql/commit/5dd79121d58e310f4cac749c0dbfa5a1f53fec48", "message": "chore: support complex key pull queries", "committedDate": "2020-11-19T00:29:33Z", "type": "commit"}, {"oid": "a4b4c4cd82f4549cd198a5ce358b1432e9311161", "url": "https://github.com/confluentinc/ksql/commit/a4b4c4cd82f4549cd198a5ce358b1432e9311161", "message": "chore: update to better error message", "committedDate": "2020-11-19T00:29:51Z", "type": "commit"}, {"oid": "5cb93e548b265cd4e09e1993f47d6be469394405", "url": "https://github.com/confluentinc/ksql/commit/5cb93e548b265cd4e09e1993f47d6be469394405", "message": "test: update test case for multiple IN statements", "committedDate": "2020-11-19T00:29:53Z", "type": "commit"}, {"oid": "2756cfb722218ff67e9f48ef70661da751b988f8", "url": "https://github.com/confluentinc/ksql/commit/2756cfb722218ff67e9f48ef70661da751b988f8", "message": "chore: rebase with master", "committedDate": "2020-11-19T00:58:12Z", "type": "commit"}, {"oid": "2756cfb722218ff67e9f48ef70661da751b988f8", "url": "https://github.com/confluentinc/ksql/commit/2756cfb722218ff67e9f48ef70661da751b988f8", "message": "chore: rebase with master", "committedDate": "2020-11-19T00:58:12Z", "type": "forcePushed"}, {"oid": "28c43d43dd2ff72c27ccde079ff6da375a9a4c75", "url": "https://github.com/confluentinc/ksql/commit/28c43d43dd2ff72c27ccde079ff6da375a9a4c75", "message": "chore: fix checkstyle", "committedDate": "2020-11-19T01:24:34Z", "type": "commit"}]}