{"pr_number": 6160, "pr_title": "fix: delete zombie consumer groups \ud83e\udddf", "pr_createdAt": "2020-09-04T01:02:16Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6160", "timeline": [{"oid": "55d72a7834a3fbeed0e78056ce6a21624d102970", "url": "https://github.com/confluentinc/ksql/commit/55d72a7834a3fbeed0e78056ce6a21624d102970", "message": "fix: delete zombie consumer groups \ud83e\udddf", "committedDate": "2020-09-04T01:19:26Z", "type": "commit"}, {"oid": "55d72a7834a3fbeed0e78056ce6a21624d102970", "url": "https://github.com/confluentinc/ksql/commit/55d72a7834a3fbeed0e78056ce6a21624d102970", "message": "fix: delete zombie consumer groups \ud83e\udddf", "committedDate": "2020-09-04T01:19:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0NzcyNg==", "url": "https://github.com/confluentinc/ksql/pull/6160#discussion_r486547726", "bodyText": "If this is only used for testing, isn't it safer/better to move it to the testing code? You already have a method for adding tasks, all you need is a getter and then you can achieve the same, no?", "author": "vpapavas", "createdAt": "2020-09-10T18:24:31Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/QueryCleanupService.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.AbstractExecutionThreadService;\n+import io.confluent.ksql.schema.registry.SchemaRegistryUtil;\n+import io.confluent.ksql.services.ServiceContext;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@code QueryCleanupService} helps cleanup external resources from queries\n+ * out of the main line of query execution. This ensures that tasks that might\n+ * take a long time don't happen on the CLI feedback path (such as cleaning up\n+ * consumer groups).\n+ *\n+ * <p>NOTE: this cleanup service is intended to be used across threads and across\n+ * real/sandboxed engines.</p>\n+ */\n+@SuppressWarnings(\"UnstableApiUsage\")\n+class QueryCleanupService extends AbstractExecutionThreadService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(QueryCleanupService.class);\n+  private static final Runnable SHUTDOWN_SENTINEL = () -> { };\n+\n+  private final BlockingQueue<Runnable> cleanupTasks;\n+\n+  QueryCleanupService() {\n+    cleanupTasks = new LinkedBlockingDeque<>();\n+  }\n+\n+  @Override\n+  protected void run() {\n+    try {\n+      while (true) {\n+        final Runnable task = cleanupTasks.take();\n+        if (task == SHUTDOWN_SENTINEL) {\n+          return;\n+        }\n+\n+        task.run();\n+      }\n+    } catch (final InterruptedException e) {\n+      // gracefully exit if this method was interrupted and reset\n+      // the interrupt flag\n+      Thread.currentThread().interrupt();\n+    }\n+  }\n+\n+  @Override\n+  protected void triggerShutdown() {\n+    cleanupTasks.add(SHUTDOWN_SENTINEL);\n+  }\n+\n+  public Set<String> pendingApplicationIds() {\n+    return cleanupTasks.stream()\n+        .filter(QueryCleanupTask.class::isInstance)\n+        .map(QueryCleanupTask.class::cast)\n+        .map(t -> t.appId).collect(ImmutableSet.toImmutableSet());\n+  }\n+\n+  public void addCleanupTask(final QueryCleanupTask task) {\n+    cleanupTasks.add(task);\n+  }\n+\n+  @VisibleForTesting\n+  void awaitAllPreviousProcessed() {", "originalCommit": "55d72a7834a3fbeed0e78056ce6a21624d102970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5OTUyMg==", "url": "https://github.com/confluentinc/ksql/pull/6160#discussion_r486599522", "bodyText": "I tried this, but it's hard to do it without breaking the synchronization guarantees. Though maybe you gave me another idea I'll try out.", "author": "agavra", "createdAt": "2020-09-10T19:59:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0NzcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0ODc4MQ==", "url": "https://github.com/confluentinc/ksql/pull/6160#discussion_r486548781", "bodyText": "Do we want these three cleanups to happen atomically, i.e all or nothing?", "author": "vpapavas", "createdAt": "2020-09-10T18:25:51Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/QueryCleanupService.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.AbstractExecutionThreadService;\n+import io.confluent.ksql.schema.registry.SchemaRegistryUtil;\n+import io.confluent.ksql.services.ServiceContext;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@code QueryCleanupService} helps cleanup external resources from queries\n+ * out of the main line of query execution. This ensures that tasks that might\n+ * take a long time don't happen on the CLI feedback path (such as cleaning up\n+ * consumer groups).\n+ *\n+ * <p>NOTE: this cleanup service is intended to be used across threads and across\n+ * real/sandboxed engines.</p>\n+ */\n+@SuppressWarnings(\"UnstableApiUsage\")\n+class QueryCleanupService extends AbstractExecutionThreadService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(QueryCleanupService.class);\n+  private static final Runnable SHUTDOWN_SENTINEL = () -> { };\n+\n+  private final BlockingQueue<Runnable> cleanupTasks;\n+\n+  QueryCleanupService() {\n+    cleanupTasks = new LinkedBlockingDeque<>();\n+  }\n+\n+  @Override\n+  protected void run() {\n+    try {\n+      while (true) {\n+        final Runnable task = cleanupTasks.take();\n+        if (task == SHUTDOWN_SENTINEL) {\n+          return;\n+        }\n+\n+        task.run();\n+      }\n+    } catch (final InterruptedException e) {\n+      // gracefully exit if this method was interrupted and reset\n+      // the interrupt flag\n+      Thread.currentThread().interrupt();\n+    }\n+  }\n+\n+  @Override\n+  protected void triggerShutdown() {\n+    cleanupTasks.add(SHUTDOWN_SENTINEL);\n+  }\n+\n+  public Set<String> pendingApplicationIds() {\n+    return cleanupTasks.stream()\n+        .filter(QueryCleanupTask.class::isInstance)\n+        .map(QueryCleanupTask.class::cast)\n+        .map(t -> t.appId).collect(ImmutableSet.toImmutableSet());\n+  }\n+\n+  public void addCleanupTask(final QueryCleanupTask task) {\n+    cleanupTasks.add(task);\n+  }\n+\n+  @VisibleForTesting\n+  void awaitAllPreviousProcessed() {\n+    // add a task to the end of the queue to make sure that\n+    // we've finished processing everything up until this point\n+    cleanupTasks.add(() -> { });\n+\n+    // busy wait is fine here because this should only be\n+    // used in tests - if we ever have the need to make this\n+    // production ready, then we should properly implement this\n+    // with a condition variable wait/notify pattern\n+    while (!cleanupTasks.isEmpty()) {\n+      Thread.yield();\n+    }\n+  }\n+\n+  static class QueryCleanupTask implements Runnable {\n+    private final String appId;\n+    private final boolean isTransient;\n+    private final ServiceContext serviceContext;\n+\n+    QueryCleanupTask(\n+        final ServiceContext serviceContext,\n+        final String appId,\n+        final boolean isTransient\n+    ) {\n+      this.appId = appId;\n+      this.isTransient = isTransient;\n+      this.serviceContext = serviceContext;\n+    }\n+\n+    @Override\n+    public void run() {\n+      tryRun(", "originalCommit": "55d72a7834a3fbeed0e78056ce6a21624d102970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5OTY0Nw==", "url": "https://github.com/confluentinc/ksql/pull/6160#discussion_r486599647", "bodyText": "no, if one of them fails we should still try to clean the others", "author": "agavra", "createdAt": "2020-09-10T19:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0ODc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU1MDUyOQ==", "url": "https://github.com/confluentinc/ksql/pull/6160#discussion_r486550529", "bodyText": "Why not use the actual value of heartbeat.interval.ms? Why hardcode it to 3 seconds?", "author": "vpapavas", "createdAt": "2020-09-10T18:28:15Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/services/KafkaConsumerGroupClientImpl.java", "diffHunk": "@@ -100,4 +105,23 @@ public ConsumerGroupSummary describeConsumerGroup(final String group) {\n       throw new KafkaResponseGetFailedException(\"Failed to list Kafka consumer groups offsets\", e);\n     }\n   }\n+\n+  @Override\n+  public void deleteConsumerGroups(final Set<String> groups) {\n+    final AtomicInteger retryCount = new AtomicInteger(0);\n+    try {\n+      // it takes heartbeat.interval.ms after a consumer is closed for the broker\n+      // to recognize that there are no more consumers in the consumer group - for\n+      // that reason, we retry after 3 seconds (the default heartbeat.interval.ms)\n+      // in the case that we get a GroupNotEmptyException\n+      ExecutorUtil.executeWithRetries(\n+          () -> adminClient.get().deleteConsumerGroups(groups).all().get(),\n+          e -> (e instanceof RetriableException)\n+              || (e instanceof GroupNotEmptyException && retryCount.getAndIncrement() < 5),\n+          () -> Duration.of(3, ChronoUnit.SECONDS)", "originalCommit": "55d72a7834a3fbeed0e78056ce6a21624d102970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMDU0Ng==", "url": "https://github.com/confluentinc/ksql/pull/6160#discussion_r486600546", "bodyText": "it's a consumer config so it can be different for each consumer (and unfortunately this isn't a constant in the kafka code, so I can't just use a constant from that class directly)", "author": "agavra", "createdAt": "2020-09-10T20:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU1MDUyOQ=="}], "type": "inlineReview"}, {"oid": "51ec960e0e5ee803aa5f6e660bff586f148fb7fa", "url": "https://github.com/confluentinc/ksql/commit/51ec960e0e5ee803aa5f6e660bff586f148fb7fa", "message": "test: move test-only code out of QueryCleanupService", "committedDate": "2020-09-10T20:25:34Z", "type": "commit"}]}