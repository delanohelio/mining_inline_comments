{"pr_number": 4468, "pr_title": "feat: Adds a new RoutingFilter, MaximumLagFilter that looks at offset lags", "pr_createdAt": "2020-02-06T22:29:10Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4468", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEzNzIxMA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376137210", "bodyText": "since this is applied to both active and standbys, should we name this differently?  ksql.query.pull.max.tolerable.offset.lag ?", "author": "vinothchandar", "createdAt": "2020-02-06T23:19:57Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -182,6 +182,13 @@\n           + \"to ksql.streams.num.standby.replicas >= 1\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_STANDBY_READS_DEFAULT = false;\n \n+  public static final String KSQL_QUERY_PULL_STANDBY_READS_MAX_OFFSET_LAG_CONFIG =", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1NTU3Mg==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376155572", "bodyText": "Sure, changed to ksql.query.pull.max.allowed.offset.lag.  Tolerable is a bit of a funny word. :-)", "author": "AlanConfluent", "createdAt": "2020-02-07T00:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEzNzIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0MDc2NQ==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376140765", "bodyText": "at some point, to handle some corner cases with network partitions, we probably need to expire lag information reported. (we discussed this a while ago if you recall).. Can we file a follow up to explore that?>", "author": "vinothchandar", "createdAt": "2020-02-06T23:31:24Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {\n+      return lagByHost.getOrDefault(hostInfo, Optional.empty())", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MTc4MA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376151780", "bodyText": "LivenessFilter should prevent doing pull queries to those servers within Xms.  Also, this will prevent hosts that have been cut off for too long.  Do we really need additional expiration?\nI can do that in a followup change.  I had originally had that, but (at least given how I had originally written things) it was more complex than seemed necessary.  Given the current architecture, it's quite easy to introduce.", "author": "AlanConfluent", "createdAt": "2020-02-07T00:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0MDc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU2NDkwMg==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376564902", "bodyText": "#4487", "author": "AlanConfluent", "createdAt": "2020-02-07T19:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0MDc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU5NDU5Mw==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376594593", "bodyText": "yes.. lets file a follow up issue so we don't lose track?", "author": "vinothchandar", "createdAt": "2020-02-07T20:35:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0MDc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwNDI1Nw==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376604257", "bodyText": "I posted the issue above #4487", "author": "AlanConfluent", "createdAt": "2020-02-07T20:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0MDc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0MTI0Mw==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376141243", "bodyText": "optional: this is the queryId of the persistent query that materialized the table right? can we name/doc this more clearly?", "author": "vinothchandar", "createdAt": "2020-02-06T23:32:54Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {\n+      return lagByHost.getOrDefault(hostInfo, Optional.empty())\n+          .map(hostLag -> {\n+            // Compute the lag from the maximum end offset we've seen\n+            final long endOffset = maxEndOffset.orElse(hostLag.getEndOffsetPosition());\n+            final long offsetLag = Math.max(endOffset - hostLag.getCurrentOffsetPosition(), 0);\n+            return offsetLag <= allowedOffsetLag;\n+          })\n+          // If we don't have lag info, we'll be conservative and include the host\n+          .orElse(true);\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Creates a FreshnessFilter\n+   * @param lagReportingAgent The optional lag reporting agent.\n+   * @param routingOptions The routing options\n+   * @param hosts The set of all hosts that have the store, including actives and standbys\n+   * @param applicationQueryId The application query id", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MjMwMQ==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376152301", "bodyText": "I took this name from elsewhere, I believe.  I'll make the documentation clearer.  Feel free to give me another name if you have one.", "author": "AlanConfluent", "createdAt": "2020-02-07T00:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0MTI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU5NTkzNw==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376595937", "bodyText": "tableQueryId ? I am not sure if thats an improvement. In applicationQueryId , application refers to a KafkaStreams application, which we understand.. but to anyone else looking at it with just ksql lens, applicationQueryId seems to indicate something global for that ksql server. I ll leave it you. :) Just wanted to clarify what triggered my comment", "author": "vinothchandar", "createdAt": "2020-02-07T20:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0MTI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0NzkzNQ==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376147935", "bodyText": "Confirming my understanding: I see that LagInfoEntity just holds data for a given store partition and this lagByHost map is a filtered version of the data we track in the lag agent, getHostsPartitionLagInfo() effectively filter the data for the store/partition we are interested in?\nnit: rename to lagInfoByHost ?", "author": "vinothchandar", "createdAt": "2020-02-06T23:55:00Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {\n+      return lagByHost.getOrDefault(hostInfo, Optional.empty())\n+          .map(hostLag -> {\n+            // Compute the lag from the maximum end offset we've seen\n+            final long endOffset = maxEndOffset.orElse(hostLag.getEndOffsetPosition());\n+            final long offsetLag = Math.max(endOffset - hostLag.getCurrentOffsetPosition(), 0);\n+            return offsetLag <= allowedOffsetLag;\n+          })\n+          // If we don't have lag info, we'll be conservative and include the host\n+          .orElse(true);\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Creates a FreshnessFilter\n+   * @param lagReportingAgent The optional lag reporting agent.\n+   * @param routingOptions The routing options\n+   * @param hosts The set of all hosts that have the store, including actives and standbys\n+   * @param applicationQueryId The application query id\n+   * @param storeName The state store name\n+   * @param partition The partition of the topic\n+   * @return a new FreshnessFilter, unless lag reporting is disabled.\n+   */\n+  public static Optional<MaximumLagFilter> create(\n+      final Optional<LagReportingAgent> lagReportingAgent,\n+      final RoutingOptions routingOptions,\n+      final List<KsqlHostInfo> hosts,\n+      final String applicationQueryId,\n+      final String storeName,\n+      final int partition\n+  ) {\n+    if (!lagReportingAgent.isPresent()) {\n+      return Optional.empty();\n+    }\n+    final QueryStateStoreId queryStateStoreId = QueryStateStoreId.of(applicationQueryId, storeName);\n+    final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost = hosts.stream()", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MzI5NA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376153294", "bodyText": "That's all right.\nSure, I'll change the name.  I think getHostsPartitionLagInfo reflected previous versions of the method that are gone, so I like your name better.\n\"by host\" implies it will return a map of all hosts, so maybe lagInfoForHost?", "author": "AlanConfluent", "createdAt": "2020-02-07T00:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0NzkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU5NjI4NQ==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376596285", "bodyText": "lagInfoForHost +1 as well", "author": "vinothchandar", "createdAt": "2020-02-07T20:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0NzkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0ODQ0NQ==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376148445", "bodyText": "getHostsPartitionLagInfo() also checks for live hosts. given how we are wiring the filters now, do we still need to special handling  below\nif (!aliveHosts.contains(host)) {\n      return Optional.empty();\n    }", "author": "vinothchandar", "createdAt": "2020-02-06T23:56:44Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {\n+      return lagByHost.getOrDefault(hostInfo, Optional.empty())\n+          .map(hostLag -> {\n+            // Compute the lag from the maximum end offset we've seen\n+            final long endOffset = maxEndOffset.orElse(hostLag.getEndOffsetPosition());\n+            final long offsetLag = Math.max(endOffset - hostLag.getCurrentOffsetPosition(), 0);\n+            return offsetLag <= allowedOffsetLag;\n+          })\n+          // If we don't have lag info, we'll be conservative and include the host\n+          .orElse(true);\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Creates a FreshnessFilter\n+   * @param lagReportingAgent The optional lag reporting agent.\n+   * @param routingOptions The routing options\n+   * @param hosts The set of all hosts that have the store, including actives and standbys\n+   * @param applicationQueryId The application query id\n+   * @param storeName The state store name\n+   * @param partition The partition of the topic\n+   * @return a new FreshnessFilter, unless lag reporting is disabled.\n+   */\n+  public static Optional<MaximumLagFilter> create(\n+      final Optional<LagReportingAgent> lagReportingAgent,\n+      final RoutingOptions routingOptions,\n+      final List<KsqlHostInfo> hosts,\n+      final String applicationQueryId,\n+      final String storeName,\n+      final int partition\n+  ) {\n+    if (!lagReportingAgent.isPresent()) {\n+      return Optional.empty();\n+    }\n+    final QueryStateStoreId queryStateStoreId = QueryStateStoreId.of(applicationQueryId, storeName);\n+    final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost = hosts.stream()\n+        .collect(ImmutableMap.toImmutableMap(\n+            Function.identity(),\n+            host -> lagReportingAgent.get().getHostsPartitionLagInfo(", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1NzE3Mw==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376157173", "bodyText": "No, we don't.  Removed.", "author": "AlanConfluent", "createdAt": "2020-02-07T00:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0ODQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTE2MA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376149160", "bodyText": "I am concerned about this cloning done on every call. does this create a new copy of the config map each call? Should we better way to build a composite objects out of these two configs?", "author": "vinothchandar", "createdAt": "2020-02-06T23:59:21Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -213,11 +215,16 @@ private TableRowsEntity handlePullQuery(\n       final ServiceContext serviceContext,\n       final PullQueryContext pullQueryContext\n   ) {\n+    final KsqlConfig ksqlConfigWithOverrides = statement.getConfig()", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MjkyNA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376162924", "bodyText": "Ok, removed this.  Now I just do the simple check for it in overrides myself.", "author": "AlanConfluent", "createdAt": "2020-02-07T00:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTM3MA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376149370", "bodyText": "add a note in the configs doc, that this can be overridden per query?", "author": "vinothchandar", "createdAt": "2020-02-07T00:00:00Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -957,4 +967,19 @@ private ColumnReferenceRewriter() {\n       return Optional.of(new UnqualifiedColumnReferenceExp(node.getReference()));\n     }\n   }\n+\n+  private static final class ConfigRoutingOptions implements RoutingOptions {\n+\n+    private final KsqlConfig ksqlConfig;\n+\n+    ConfigRoutingOptions(final KsqlConfig ksqlConfig) {\n+      this.ksqlConfig = ksqlConfig;\n+    }\n+\n+    @Override\n+    public long getOffsetLagAllowed() {\n+      return ksqlConfig.getLong(\n+          KsqlConfig.KSQL_QUERY_PULL_STANDBY_READS_MAX_OFFSET_LAG_CONFIG);", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2NDI0Mw==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376164243", "bodyText": "Added.", "author": "AlanConfluent", "createdAt": "2020-02-07T00:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTQ0Ng==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376149446", "bodyText": "for my understanding, if standby reads are disabled why do we bother adding the other filters?", "author": "agavra", "createdAt": "2020-02-07T00:00:18Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -740,16 +742,21 @@ static KsqlRestApplication buildApplication(\n     return Optional.empty();\n   }\n \n-  private static RoutingFilters initializeRoutingFilters(\n+  private static RoutingFilterFactory initializeRoutingFilterFactory(\n       final KsqlConfig ksqlConfig,\n-      final Optional<HeartbeatAgent> heartbeatAgent) {\n-    final ImmutableList.Builder<RoutingFilter> filterBuilder = ImmutableList.builder();\n-    if (!ksqlConfig.getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS)) {\n-      filterBuilder.add(new ActiveHostFilter());\n-    }\n-    filterBuilder.add(new LivenessFilter(heartbeatAgent));\n-    final RoutingFilters routingFilters = new RoutingFilters(filterBuilder.build());\n-    return routingFilters;\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final Optional<LagReportingAgent> lagReportingAgent) {\n+    return (routingOptions, hosts, active, applicationQueryId, storeName, partition) -> {\n+      final ImmutableList.Builder<RoutingFilter> filterBuilder = ImmutableList.builder();\n+      if (!ksqlConfig.getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS)) {\n+        filterBuilder.add(new ActiveHostFilter(active));\n+      }", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2ODcyNA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376168724", "bodyText": "You could argue that there's value in allowing for these filters, even if standby reads are disabled. They would allow for failing the request immediately due to an active failing the LivenessFilter (as opposed to attempting the request anyway) or if a rebalance occurs, the active could be very behind and fail the MaximumLagFilter because even the active is very stale.  Of course these only happen if you enable heartbeats and lag reporting.  Otherwise they're noops.\nBut you're right that the primary use is to read from standbys.  If you don't think there's value in the above, I'll put them in an else clause.", "author": "AlanConfluent", "createdAt": "2020-02-07T01:11:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4MTk4NQ==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376181985", "bodyText": "We should have the liveness filter enabled regardless..  for the same reason you cite.\n\nThey would allow for failing the request immediately due to an active failing the LivenessFilter\n\nRepeatedly trying to open a tcp socket in a fast loop will kill latency. and also server CPU.\nthe ActiveHostFilter can be turned off ofc if standbys are not enabled.", "author": "vinothchandar", "createdAt": "2020-02-07T02:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUwMTI0NA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376501244", "bodyText": "sounds good :)", "author": "agavra", "createdAt": "2020-02-07T17:01:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTQ0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUzMjAzMg==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376532032", "bodyText": "@vinothchandar Not sure what you mean by turning off the ActiveHostFilter. We need that to keep only the active (in the list of hosts to try) when routing to standbys is not enabled.", "author": "vpapavas", "createdAt": "2020-02-07T18:12:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MDMyNg==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376150326", "bodyText": "should we allow values less than 0? feels like a misconfiguration", "author": "agavra", "createdAt": "2020-02-07T00:03:12Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3MzcyNg==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376173726", "bodyText": "Good point.  Added a validator for the config that ensures it's zero or positive.", "author": "AlanConfluent", "createdAt": "2020-02-07T01:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MDMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MDYzNg==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376150636", "bodyText": "wouldn't the conservative thing be to exclude the host? if I asked for an offset lag of 0 and I get a host that just came online (so I don't have lag info yet) I'd be surprised by this!", "author": "agavra", "createdAt": "2020-02-07T00:04:18Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {\n+      return lagByHost.getOrDefault(hostInfo, Optional.empty())\n+          .map(hostLag -> {\n+            // Compute the lag from the maximum end offset we've seen\n+            final long endOffset = maxEndOffset.orElse(hostLag.getEndOffsetPosition());\n+            final long offsetLag = Math.max(endOffset - hostLag.getCurrentOffsetPosition(), 0);\n+            return offsetLag <= allowedOffsetLag;\n+          })\n+          // If we don't have lag info, we'll be conservative and include the host\n+          .orElse(true);", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4MTg1Mw==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376181853", "bodyText": "Vinoth and I were chatting about this a bit.  I think falling back on either value has its drawbacks.  If we defaulted to false, then we might start failing requests because we have no lags when we could have at least made an attempt to get some value they have.  On the other hand, it might be behind and could return overly stale data and we have no way of knowing.\nI'm inclined to do false as you say.  I think the real solution is mitigating not having the data with these issues: #4471 #4472", "author": "AlanConfluent", "createdAt": "2020-02-07T02:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MDYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MDgyNg==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376150826", "bodyText": "can we document this parameter? it's a little unclear what it means to me (i.e. why would I prefer this over whats in the map - maxEndOffset.orElse(hostLag.getEndOffsetPosition()))\nEDIT: after reading more of the code this makes sense to me - it's the latest end offset that any of the replicas has seen (so it's independent of how caught up any of them actually are).", "author": "agavra", "createdAt": "2020-02-07T00:05:03Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4NDQ2OA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376184468", "bodyText": "Yep, you got it.\nI added more documentation to this constructor as well as the filtering itself.", "author": "AlanConfluent", "createdAt": "2020-02-07T02:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MDgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MzM3OA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376153378", "bodyText": "if the maxEndOffset is not present it seems like something bad happened (nobody knows where the real end of the kafka topic is)... is it safe to ignore that?", "author": "agavra", "createdAt": "2020-02-07T00:14:07Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {\n+      return lagByHost.getOrDefault(hostInfo, Optional.empty())\n+          .map(hostLag -> {\n+            // Compute the lag from the maximum end offset we've seen\n+            final long endOffset = maxEndOffset.orElse(hostLag.getEndOffsetPosition());", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4NTEzNA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376185134", "bodyText": "It shouldn't be possible because the value should be the greatest end offset seen in the map and this code shouldn't be called at all if there are no lags reported.\nI'll assert that the value exists and get rid of the optional here.", "author": "AlanConfluent", "createdAt": "2020-02-07T02:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MzM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MTU4NA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376161584", "bodyText": "13?", "author": "vinothchandar", "createdAt": "2020-02-07T00:44:52Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/MaximumLagFilterTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.confluent.ksql.rest.server;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class MaximumLagFilterTest {\n+\n+  private static KsqlHostInfo HOST = new KsqlHostInfo(\"host\", 8088);\n+  private static KsqlHostInfo HOST2 = new KsqlHostInfo(\"host2\", 8088);\n+  private static List<KsqlHostInfo> HOSTS = ImmutableList.of(HOST, HOST2);\n+  private static String APPLICATION_ID = \"app_id\";\n+  private static String STATE_STORE = \"state_store\";\n+  private static int PARTITION = 3;\n+  private static LagInfoEntity LAG = new LagInfoEntity(3, 12, 9);\n+  private static LagInfoEntity LAG2 = new LagInfoEntity(7, 15, 8);\n+\n+  @Mock\n+  private LagReportingAgent lagReportingAgent;\n+  @Mock\n+  private RoutingOptions routingOptions;\n+\n+  private MaximumLagFilter filter;\n+\n+  @Before\n+  public void setUp() {\n+    when(lagReportingAgent.getHostsPartitionLagInfo(eq(HOST),\n+        eq(QueryStateStoreId.of(APPLICATION_ID, STATE_STORE)), eq(PARTITION)))\n+        .thenReturn(Optional.of(LAG));\n+    when(lagReportingAgent.getHostsPartitionLagInfo(eq(HOST2),\n+        eq(QueryStateStoreId.of(APPLICATION_ID, STATE_STORE)), eq(PARTITION)))\n+        .thenReturn(Optional.of(LAG2));\n+  }\n+\n+\n+  @Test\n+  public void filter_shouldIncludeBelowThreshold() {\n+    // The max end offset is 15, so the lag for HOST is 12", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4OTEwNw==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376189107", "bodyText": "For HOST with LAG = new LagInfoEntity(3, 12, 9); the current offset is 3, but rather than use 12 as the end offset to compute lag, it uses 15, the end offset of LAG2, so 15 - 3 is the lag for HOST.", "author": "AlanConfluent", "createdAt": "2020-02-07T02:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MTU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MTY0OQ==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376161649", "bodyText": "nit: HOST1?", "author": "vinothchandar", "createdAt": "2020-02-07T00:45:08Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/MaximumLagFilterTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.confluent.ksql.rest.server;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class MaximumLagFilterTest {\n+\n+  private static KsqlHostInfo HOST = new KsqlHostInfo(\"host\", 8088);", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4OTE5OA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376189198", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-02-07T02:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MTY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MTczNQ==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376161735", "bodyText": "lol :) .. bear with me. LAG1?", "author": "vinothchandar", "createdAt": "2020-02-07T00:45:28Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/MaximumLagFilterTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.confluent.ksql.rest.server;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class MaximumLagFilterTest {\n+\n+  private static KsqlHostInfo HOST = new KsqlHostInfo(\"host\", 8088);\n+  private static KsqlHostInfo HOST2 = new KsqlHostInfo(\"host2\", 8088);\n+  private static List<KsqlHostInfo> HOSTS = ImmutableList.of(HOST, HOST2);\n+  private static String APPLICATION_ID = \"app_id\";\n+  private static String STATE_STORE = \"state_store\";\n+  private static int PARTITION = 3;\n+  private static LagInfoEntity LAG = new LagInfoEntity(3, 12, 9);", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4OTI2OQ==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376189269", "bodyText": "Done!", "author": "AlanConfluent", "createdAt": "2020-02-07T02:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MTczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MzA0Nw==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376163047", "bodyText": "This object is useful for query time options more than server options. Maybe I can change the name?\n\nresponding here.. Good with this for now. API looks much cleaner with an interface", "author": "vinothchandar", "createdAt": "2020-02-07T00:50:17Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/RoutingOptions.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+/**\n+ * These are options used for locating the host to retrieve data from.\n+ */\n+public interface RoutingOptions {", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2NDQ4OQ==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376164489", "bodyText": "Even without a ranking interface.. given we place the activeHost first.. I think we are guaranteed to send to active if its alive and not restoring (i.e laggy)", "author": "vinothchandar", "createdAt": "2020-02-07T00:55:21Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -81,18 +87,17 @@\n     final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n     LOG.debug(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n \n-    final Stream<KsqlHostInfo> active = Stream.of(asKsqlHost(activeHost));\n-    final Stream<KsqlHostInfo> standby = standByHosts\n-        .stream()\n-        .map(this::asKsqlHost);\n-    final Stream<KsqlHostInfo> hostStream = Stream.concat(active, standby);\n+    final List<KsqlHostInfo> allHosts = Stream.concat(Stream.of(activeHost), standByHosts.stream())", "originalCommit": "3f29c37b083521f11ec3896b0df116f171b6e847", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4OTk1MA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376189950", "bodyText": "Yep, I think that's true.  Given our discussion earlier about always ranking active first, even during restore, ranking is solely for the benefit of multiple standbys.  Maybe this is low value given that there are likely to be 1 or at most 2 standbys in practice.  What do you think?", "author": "AlanConfluent", "createdAt": "2020-02-07T02:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2NDQ4OQ=="}], "type": "inlineReview"}, {"oid": "c5477a4a9899201fbbfc2b6b89d092dea3e448c4", "url": "https://github.com/confluentinc/ksql/commit/c5477a4a9899201fbbfc2b6b89d092dea3e448c4", "message": "feat: Adds a new RoutingFilter, MaxAllowedLagFilter that looks at offset lags", "committedDate": "2020-02-07T20:30:44Z", "type": "commit"}, {"oid": "906306eceed6694b3012b218c50ed2830f70af3a", "url": "https://github.com/confluentinc/ksql/commit/906306eceed6694b3012b218c50ed2830f70af3a", "message": "Change config name", "committedDate": "2020-02-07T20:30:45Z", "type": "commit"}, {"oid": "44234f92d7b56812460598601fe1b6a739db02b1", "url": "https://github.com/confluentinc/ksql/commit/44234f92d7b56812460598601fe1b6a739db02b1", "message": "Changes name to MaximimLagFilter", "committedDate": "2020-02-07T20:30:45Z", "type": "commit"}, {"oid": "0c33e57f3c2d265906207606011d711b300a31d4", "url": "https://github.com/confluentinc/ksql/commit/0c33e57f3c2d265906207606011d711b300a31d4", "message": "Feedback", "committedDate": "2020-02-07T20:30:45Z", "type": "commit"}, {"oid": "c31cd20dc40c0fc9149967bb00f7d11e15d472cc", "url": "https://github.com/confluentinc/ksql/commit/c31cd20dc40c0fc9149967bb00f7d11e15d472cc", "message": "More feedback", "committedDate": "2020-02-07T20:30:45Z", "type": "commit"}, {"oid": "c31cd20dc40c0fc9149967bb00f7d11e15d472cc", "url": "https://github.com/confluentinc/ksql/commit/c31cd20dc40c0fc9149967bb00f7d11e15d472cc", "message": "More feedback", "committedDate": "2020-02-07T20:30:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU5ODAyOA==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376598028", "bodyText": "Should this be LONG.MAX_VALUE?", "author": "vinothchandar", "createdAt": "2020-02-07T20:42:52Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -182,6 +184,14 @@\n           + \"to ksql.streams.num.standby.replicas >= 1\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_STANDBY_READS_DEFAULT = false;\n \n+  public static final String KSQL_QUERY_PULL_MAX_ALLOWED_OFFSET_LAG_CONFIG =\n+      \"ksql.query.pull.max.allowed.offset.lag\";\n+  public static final Long KSQL_QUERY_PULL_MAX_ALLOWED_OFFSET_LAG_DEFAULT = 0L;", "originalCommit": "c31cd20dc40c0fc9149967bb00f7d11e15d472cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU5OTAyNQ==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376599025", "bodyText": "0 means, we don't query standbys at all (they will always have non-zero lag right).. So someone enabling standby.reads will be forced to also set this, to issue those queries.. I can imagine a lot of tickets we get where users complain standby routing is not working etc..\nmight be better to err on the other side? and as users become concerned about stale values, they will reach out and we point at this config.. wdyt", "author": "vinothchandar", "createdAt": "2020-02-07T20:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU5ODAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwMzAxNQ==", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376603015", "bodyText": "Sure, I didn't really know if the default should be super low, super high, or some actual target in the middle.  I'm fine to do Long.MAX_VALUE as a default.", "author": "AlanConfluent", "createdAt": "2020-02-07T20:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU5ODAyOA=="}], "type": "inlineReview"}, {"oid": "d5222a6fd290d86fe248a73665ac1d2ef35fa4e5", "url": "https://github.com/confluentinc/ksql/commit/d5222a6fd290d86fe248a73665ac1d2ef35fa4e5", "message": "Fixes tests", "committedDate": "2020-02-08T00:22:35Z", "type": "commit"}]}