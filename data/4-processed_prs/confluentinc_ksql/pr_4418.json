{"pr_number": 4418, "pr_title": "fix: Make host status map entries in Heartbeat Handler immutable", "pr_createdAt": "2020-02-01T00:42:48Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4418", "timeline": [{"oid": "ef5a27f5c6b3037bdeb05a0686f93cc7d0f31a0b", "url": "https://github.com/confluentinc/ksql/commit/ef5a27f5c6b3037bdeb05a0686f93cc7d0f31a0b", "message": "made concurrent map immutable, applied andy's and almog's comments", "committedDate": "2020-02-01T01:28:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMDcwNw==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374220707", "bodyText": "this should be failing the ImmutabilityTest because these aren't final - not sure why it's passing", "author": "agavra", "createdAt": "2020-02-03T16:58:18Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/HostStatus.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.util;\n+\n+import com.google.errorprone.annotations.Immutable;\n+\n+/**\n+ * Represent the status of a ksql host in the cluster as determined by the Heartbeat agent.\n+ * A host can alive or dead annotated with the timestamp of the last update in status.\n+ */\n+@Immutable\n+public class HostStatus {\n+\n+  private boolean hostAlive;\n+  private long lastStatusUpdateMs;", "originalCommit": "ff4579f22d53a51c65439bd26d2eb6b1a6ba22dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMDg1Nw==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374220857", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public HostStatus setLastStatusUpdateMs(final long lastStatusUpdateMs) {\n          \n          \n            \n              public HostStatus withLastStatusUpdateMs(final long lastStatusUpdateMs) {", "author": "agavra", "createdAt": "2020-02-03T16:58:32Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/HostStatus.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.util;\n+\n+import com.google.errorprone.annotations.Immutable;\n+\n+/**\n+ * Represent the status of a ksql host in the cluster as determined by the Heartbeat agent.\n+ * A host can alive or dead annotated with the timestamp of the last update in status.\n+ */\n+@Immutable\n+public class HostStatus {\n+\n+  private boolean hostAlive;\n+  private long lastStatusUpdateMs;\n+\n+  public HostStatus(\n+      final boolean hostAlive,\n+      final long lastStatusUpdateMs\n+  ) {\n+    this.hostAlive = hostAlive;\n+    this.lastStatusUpdateMs = lastStatusUpdateMs;\n+  }\n+\n+  public HostStatus withHostAlive(final boolean hostAlive) {\n+    return new HostStatus(hostAlive, lastStatusUpdateMs);\n+  }\n+\n+  public HostStatus setLastStatusUpdateMs(final long lastStatusUpdateMs) {", "originalCommit": "ff4579f22d53a51c65439bd26d2eb6b1a6ba22dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMTY2MQ==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374221661", "bodyText": "nit: we usually use regular String concatenation generated by IntelliJ (see most other POJOs as examples) - same goes for HostStatus", "author": "agavra", "createdAt": "2020-02-03T16:59:57Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlHost.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.util;\n+\n+import com.google.errorprone.annotations.Immutable;\n+\n+/**\n+ * Immutable representation of {@link org.apache.kafka.streams.state.HostInfo HostInfo}\n+ * from KStreams.\n+ */\n+@Immutable\n+public class KsqlHost {\n+\n+  private final String host;\n+  private final int port;\n+\n+  public KsqlHost(final String host, final int port) {\n+    this.host = host;\n+    this.port = port;\n+  }\n+\n+  @Override\n+  public boolean equals(final Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    final KsqlHost hostInfo = (KsqlHost) o;\n+    return port == hostInfo.port && host.equals(hostInfo.host);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    int result = host.hashCode();\n+    result = 31 * result + port;\n+    return result;\n+  }\n+\n+  public String host() {\n+    return host;\n+  }\n+\n+  public int port() {\n+    return port;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return new StringBuilder()", "originalCommit": "ff4579f22d53a51c65439bd26d2eb6b1a6ba22dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI0MTk1Ng==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374241956", "bodyText": "For this class, I followed the implementation (and conventions) of KStreams, since I am just copying it over to ensure immutability", "author": "vpapavas", "createdAt": "2020-02-03T17:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMTY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI0NDM1Ng==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374244356", "bodyText": "By do we do string concatenation since it is inefficient?", "author": "vpapavas", "createdAt": "2020-02-03T17:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMTY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI0NzcwNg==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374247706", "bodyText": "Honestly, it's cosmetic (the compiler turns them into the same thing) but the fewer choices we need to make (and the more we can follow convention) the easier it is to write code", "author": "agavra", "createdAt": "2020-02-03T17:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMTY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMTg5Mw==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374221893", "bodyText": "nit: we usually use the Objects.hash(...) to generate hash codes", "author": "agavra", "createdAt": "2020-02-03T17:00:21Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlHost.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.util;\n+\n+import com.google.errorprone.annotations.Immutable;\n+\n+/**\n+ * Immutable representation of {@link org.apache.kafka.streams.state.HostInfo HostInfo}\n+ * from KStreams.\n+ */\n+@Immutable\n+public class KsqlHost {\n+\n+  private final String host;\n+  private final int port;\n+\n+  public KsqlHost(final String host, final int port) {\n+    this.host = host;\n+    this.port = port;\n+  }\n+\n+  @Override\n+  public boolean equals(final Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    final KsqlHost hostInfo = (KsqlHost) o;\n+    return port == hostInfo.port && host.equals(hostInfo.host);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    int result = host.hashCode();\n+    result = 31 * result + port;\n+    return result;", "originalCommit": "ff4579f22d53a51c65439bd26d2eb6b1a6ba22dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMjA2Mg==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374222062", "bodyText": "nit: good to have hashCode and equals implemented on POJOs", "author": "agavra", "createdAt": "2020-02-03T17:00:42Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/HostStatus.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.util;\n+\n+import com.google.errorprone.annotations.Immutable;\n+\n+/**\n+ * Represent the status of a ksql host in the cluster as determined by the Heartbeat agent.\n+ * A host can alive or dead annotated with the timestamp of the last update in status.\n+ */\n+@Immutable\n+public class HostStatus {", "originalCommit": "ff4579f22d53a51c65439bd26d2eb6b1a6ba22dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMzAzMA==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374223030", "bodyText": "to truly enforce immutability, it might (cc @big-andy-coates) make sense to make a class specifically wrapping ImmutableMap<KsqlHost, HostStatus> and mark it @Immutable. That way the ImmutableTester will make sure it is recursively immutable.\nAlso, wrapping this class could help us with handling the localhost in a cleaner way - you could initialize it passing in the local KsqlHost and handle it as an edge case in the get() method. Same goes for some other complicated logic that could be pushed into this class.\nThis can be done as a follow-up to unblock your other PRs.", "author": "agavra", "createdAt": "2020-02-03T17:02:23Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -77,19 +75,19 @@\n   private static final int SERVICE_TIMEOUT_SEC = 2;\n   private static final int CHECK_HEARTBEAT_DELAY_MS = 1000;\n   private static final int SEND_HEARTBEAT_DELAY_MS = 100;\n+  private static final int DISCOVER_CLUSTER_DELAY_MS = 50;\n   private static final Logger LOG = LoggerFactory.getLogger(HeartbeatAgent.class);\n \n   private final KsqlEngine engine;\n   private final ServiceContext serviceContext;\n   private final HeartbeatConfig config;\n   private final List<HostStatusListener> hostStatusListeners;\n-  private final ConcurrentHashMap<String, TreeMap<Long, HeartbeatInfo>> receivedHeartbeats;\n-  private final ConcurrentHashMap<String, HostStatusEntity> hostsStatus;\n+  private final ConcurrentHashMap<KsqlHost, TreeMap<Long, HeartbeatInfo>> receivedHeartbeats;\n+  private final AtomicReference<ImmutableMap<KsqlHost, HostStatus>> hostsStatus;", "originalCommit": "ff4579f22d53a51c65439bd26d2eb6b1a6ba22dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI5Njk4OQ==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374296989", "bodyText": "After more discussions and thought, the map should not be immutable. I am changing it back to be a concurrent map of immutable objects", "author": "vpapavas", "createdAt": "2020-02-03T19:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMzAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwNTM1MA==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374305350", "bodyText": "Can you explain your reasoning?", "author": "agavra", "createdAt": "2020-02-03T19:50:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMzAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMzMDU2Nw==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374330567", "bodyText": "We need finer-grained control over the map (as per your next comment). Moreover, ensuring immutability per key, value is enough", "author": "vpapavas", "createdAt": "2020-02-03T20:44:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMzAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyNjkzNw==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374226937", "bodyText": "If DiscoverClusterService runs and discovers a new host while this block is running, we will overwrite whatever changes happened there. This might be okay, as eventually the DisocverClusterService will \"rediscover\" whatever was overwritten, but this is something to point out - at a minimum we should comment acknowledging that, at best we may want to synchronize the two. Same goes for L258\nmore concerning is perhaps the other way - a concurrent DiscoverClusterService#runOneIteration will overwrite the processheartbeats result", "author": "agavra", "createdAt": "2020-02-03T17:10:09Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -237,47 +216,55 @@ protected ScheduledExecutorService executor() {\n      * @param windowEnd the end time in ms of the current window\n      */\n     private void processHeartbeats(final long windowStart, final long windowEnd) {\n+\n+      final Map<KsqlHost, HostStatus> copyOnWrite = new HashMap<>(hostsStatus.get());\n       // No heartbeats received -> mark all hosts as dead\n       if (receivedHeartbeats.isEmpty()) {\n-        hostsStatus.replaceAll((host, status) -> {\n-          if (!host.equals(localHostString)) {\n-            return status.copyWithStatus(false);\n+        copyOnWrite.replaceAll((host, status) -> {\n+          if (!host.equals(localHost)) {\n+            return status.withHostAlive(false);\n           }\n           return status;\n         });\n+        hostsStatus.set(ImmutableMap.copyOf(copyOnWrite));", "originalCommit": "ff4579f22d53a51c65439bd26d2eb6b1a6ba22dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyODYzMQ==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374228631", "bodyText": "nit - only needs one lookup:\ncopyOnWrite.computeIfPresent(ksqlHost, (host, status) -> status.withHostAlive(isAlive).setLastStatusUpdateMs(windowEnd));", "author": "agavra", "createdAt": "2020-02-03T17:13:27Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -237,47 +216,55 @@ protected ScheduledExecutorService executor() {\n      * @param windowEnd the end time in ms of the current window\n      */\n     private void processHeartbeats(final long windowStart, final long windowEnd) {\n+\n+      final Map<KsqlHost, HostStatus> copyOnWrite = new HashMap<>(hostsStatus.get());\n       // No heartbeats received -> mark all hosts as dead\n       if (receivedHeartbeats.isEmpty()) {\n-        hostsStatus.replaceAll((host, status) -> {\n-          if (!host.equals(localHostString)) {\n-            return status.copyWithStatus(false);\n+        copyOnWrite.replaceAll((host, status) -> {\n+          if (!host.equals(localHost)) {\n+            return status.withHostAlive(false);\n           }\n           return status;\n         });\n+        hostsStatus.set(ImmutableMap.copyOf(copyOnWrite));\n+        return;\n       }\n \n-      for (String host : hostsStatus.keySet()) {\n-        if (host.equals(localHostString)) {\n+      for (Entry<KsqlHost, HostStatus> hostEntry: copyOnWrite.entrySet()) {\n+        final KsqlHost ksqlHost = hostEntry.getKey();\n+        final HostStatus hostStatus = hostEntry.getValue();\n+        if (ksqlHost.equals(localHost)) {\n           continue;\n         }\n-        final TreeMap<Long, HeartbeatInfo> heartbeats = receivedHeartbeats.get(host);\n+        final TreeMap<Long, HeartbeatInfo> heartbeats = receivedHeartbeats.get(ksqlHost);\n         //For previously discovered hosts, if they have not received any heartbeats, mark them dead\n         if (heartbeats == null || heartbeats.isEmpty()) {\n-          hostsStatus.computeIfPresent(host, (h, s) -> s.copyWithStatus(false));\n+          copyOnWrite.computeIfPresent(ksqlHost, (host, status) -> status.withHostAlive(false));\n         } else {\n           final TreeMap<Long, HeartbeatInfo> copy;\n           synchronized (heartbeats) {\n-            LOG.debug(\"Process heartbeats: {} of host: {}\", heartbeats, host);\n+            LOG.debug(\"Process heartbeats: {} of host: {}\", heartbeats, ksqlHost);\n             // 1. remove heartbeats older than window\n             heartbeats.headMap(windowStart).clear();\n             copy = new TreeMap<>(heartbeats.subMap(windowStart, true, windowEnd, true));\n           }\n           // 2. count consecutive missed heartbeats and mark as alive or dead\n-          final  boolean isAlive = decideStatus(host, windowStart, windowEnd, copy);\n-          hostsStatus.computeIfPresent(host,\n-              (h, s) -> new HostStatusEntity(s.getHostInfoEntity(), isAlive, windowEnd));\n+          final  boolean isAlive = decideStatus(ksqlHost, windowStart, windowEnd, copy);\n+          copyOnWrite.computeIfPresent(ksqlHost, (host, status) -> status.withHostAlive(isAlive));\n+          copyOnWrite.computeIfPresent(ksqlHost, (host, status) ->\n+              status.setLastStatusUpdateMs(windowEnd));", "originalCommit": "ff4579f22d53a51c65439bd26d2eb6b1a6ba22dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyOTAwNw==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374229007", "bodyText": "what do you think about info logging this if missedCount > 0?", "author": "agavra", "createdAt": "2020-02-03T17:14:13Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -306,7 +293,7 @@ private boolean decideStatus(final String host, final long windowStart, final lo\n         missedCount = (windowEnd - prev - 1) / config.heartbeatSendIntervalMs;\n       }\n \n-      LOG.debug(\"Host: {} has {} missing heartbeats\", host, missedCount);\n+      LOG.debug(\"Host: {} has {} missing heartbeats\", ksqlHost, missedCount);", "originalCommit": "ff4579f22d53a51c65439bd26d2eb6b1a6ba22dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzMDU0OQ==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374230549", "bodyText": "nit: we shouldn't have println in prod code :)", "author": "agavra", "createdAt": "2020-02-03T17:17:08Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -323,22 +310,23 @@ private boolean decideStatus(final String host, final long windowStart, final lo\n \n     @Override\n     protected void runOneIteration() {\n-      for (Entry<String, HostStatusEntity> hostStatusEntry: hostsStatus.entrySet()) {\n-        final String host = hostStatusEntry.getKey();\n-        final HostStatusEntity status = hostStatusEntry.getValue();\n+      for (Entry<KsqlHost, HostStatus> hostStatusEntry: hostsStatus.get().entrySet()) {\n+        final KsqlHost remoteHost = hostStatusEntry.getKey();\n         try {\n-          if (!host.equals(localHostString)) {\n-            final URI remoteUri = buildLocation(localURL, status.getHostInfoEntity().getHost(),\n-                                          status.getHostInfoEntity().getPort());\n-            LOG.debug(\"Send heartbeat to host {} at {}\", status.getHostInfoEntity().getHost(),\n-                      clock.millis());\n-            serviceContext.getKsqlClient().makeAsyncHeartbeatRequest(remoteUri, localHostInfo,\n-                                                                     clock.millis());\n+          if (!remoteHost.equals(localHost)) {\n+            final URI remoteUri = ServerUtil.buildRemoteUri(\n+                localURL, remoteHost.host(), remoteHost.port());\n+            System.out.println(localHost + \" Send heartbeat to host \" + remoteHost\n+                                   + \" at timestamp \" + System.currentTimeMillis());", "originalCommit": "ff4579f22d53a51c65439bd26d2eb6b1a6ba22dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzMDgxOA==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374230818", "bodyText": "ditto - please make sure to do a find-and-replace throughout the changed files to see if any others slipped through", "author": "agavra", "createdAt": "2020-02-03T17:17:39Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -323,22 +310,23 @@ private boolean decideStatus(final String host, final long windowStart, final lo\n \n     @Override\n     protected void runOneIteration() {\n-      for (Entry<String, HostStatusEntity> hostStatusEntry: hostsStatus.entrySet()) {\n-        final String host = hostStatusEntry.getKey();\n-        final HostStatusEntity status = hostStatusEntry.getValue();\n+      for (Entry<KsqlHost, HostStatus> hostStatusEntry: hostsStatus.get().entrySet()) {\n+        final KsqlHost remoteHost = hostStatusEntry.getKey();\n         try {\n-          if (!host.equals(localHostString)) {\n-            final URI remoteUri = buildLocation(localURL, status.getHostInfoEntity().getHost(),\n-                                          status.getHostInfoEntity().getPort());\n-            LOG.debug(\"Send heartbeat to host {} at {}\", status.getHostInfoEntity().getHost(),\n-                      clock.millis());\n-            serviceContext.getKsqlClient().makeAsyncHeartbeatRequest(remoteUri, localHostInfo,\n-                                                                     clock.millis());\n+          if (!remoteHost.equals(localHost)) {\n+            final URI remoteUri = ServerUtil.buildRemoteUri(\n+                localURL, remoteHost.host(), remoteHost.port());\n+            System.out.println(localHost + \" Send heartbeat to host \" + remoteHost\n+                                   + \" at timestamp \" + System.currentTimeMillis());\n+            LOG.debug(\"Send heartbeat to host {} at {}\", remoteHost, clock.millis());\n+            serviceContext.getKsqlClient().makeAsyncHeartbeatRequest(\n+                remoteUri, localHost, clock.millis());\n           }\n         } catch (Throwable t) {\n-          LOG.error(\"Request to server: \" + status.getHostInfoEntity().getHost() + \":\"\n-                        + status.getHostInfoEntity().getPort()\n-                        + \" failed with exception: \" + t.getMessage(), t);\n+          System.out.println(localHost + \" FAILED to Send heartbeat to host \" + remoteHost\n+                                 + \" at timestamp \" + System.currentTimeMillis());", "originalCommit": "ff4579f22d53a51c65439bd26d2eb6b1a6ba22dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzMzQ4OA==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374233488", "bodyText": "nit: let's use the standard pattern here as well", "author": "agavra", "createdAt": "2020-02-03T17:22:53Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostStatusEntity.java", "diffHunk": "@@ -67,17 +63,18 @@ public boolean equals(final Object o) {\n     }\n \n     final HostStatusEntity that = (HostStatusEntity) o;\n-    return Objects.equals(hostInfoEntity, that.hostInfoEntity)\n-        && hostAlive == that.hostAlive && lastStatusUpdateMs == that.lastStatusUpdateMs;\n+    return hostAlive == that.hostAlive\n+        && lastStatusUpdateMs == that.lastStatusUpdateMs\n+        && Objects.equals(hostStoreLags, that.hostStoreLags);\n   }\n \n   @Override\n   public int hashCode() {\n-    return Objects.hash(hostInfoEntity, hostAlive, lastStatusUpdateMs);\n+    return Objects.hash(hostAlive, lastStatusUpdateMs, hostStoreLags);\n   }\n \n   @Override\n   public String toString() {\n-    return hostInfoEntity + \",\" + hostAlive + \",\" + lastStatusUpdateMs;\n+    return hostAlive + \",\" + lastStatusUpdateMs;", "originalCommit": "ff4579f22d53a51c65439bd26d2eb6b1a6ba22dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI5NjMyMQ==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374296321", "bodyText": "I don't understand what is wrong here", "author": "vpapavas", "createdAt": "2020-02-03T19:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzMzQ4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwNTkxOQ==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374305919", "bodyText": "The standard pattern is:\n  @Override\n  public String toString() {\n    return \"FormatInfo{\"\n        + \"format=\" + format\n        + \", fullSchemaName=\" + fullSchemaName\n        + \", delimiter=\" + delimiter\n        + '}';\n  }\nThis (1) gives you the class name, and (2) gives you the field names for each. IntelliJ can automatically generate this for you.", "author": "agavra", "createdAt": "2020-02-03T19:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzMzQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzMzcyNw==", "url": "https://github.com/confluentinc/ksql/pull/4418#discussion_r374233727", "bodyText": "nit: let's use the standard pattern here as well", "author": "agavra", "createdAt": "2020-02-03T17:23:20Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/LagReportingMessage.java", "diffHunk": "@@ -56,17 +56,17 @@ public boolean equals(final Object o) {\n     }\n \n     final LagReportingMessage that = (LagReportingMessage) o;\n-    return Objects.equals(hostInfo, that.hostInfo)\n+    return Objects.equals(ksqlHost, that.ksqlHost)\n         && Objects.equals(hostStoreLags, that.hostStoreLags);\n   }\n \n   @Override\n   public int hashCode() {\n-    return Objects.hash(hostInfo, hostStoreLags);\n+    return Objects.hash(ksqlHost, hostStoreLags);\n   }\n \n   @Override\n   public String toString() {\n-    return hostInfo + \",\" + hostStoreLags;\n+    return ksqlHost + \",\" + hostStoreLags;", "originalCommit": "ff4579f22d53a51c65439bd26d2eb6b1a6ba22dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a4b8f6d605cf9f27141342940238e64d2a0ddd61", "url": "https://github.com/confluentinc/ksql/commit/a4b8f6d605cf9f27141342940238e64d2a0ddd61", "message": "heartbeat agent", "committedDate": "2020-02-03T19:34:07Z", "type": "commit"}, {"oid": "2a7f04166fe75d67eb2693a2814e7f408ad1859f", "url": "https://github.com/confluentinc/ksql/commit/2a7f04166fe75d67eb2693a2814e7f408ad1859f", "message": "made concurrent map immutable, applied andy's and almog's comments", "committedDate": "2020-02-03T19:34:07Z", "type": "commit"}, {"oid": "5749132819ef396076e230f1e09fcb60e60d2911", "url": "https://github.com/confluentinc/ksql/commit/5749132819ef396076e230f1e09fcb60e60d2911", "message": "fixed tests", "committedDate": "2020-02-03T19:34:08Z", "type": "commit"}, {"oid": "346a96cf946ede6b2c6a2c5a9d3814dd95359443", "url": "https://github.com/confluentinc/ksql/commit/346a96cf946ede6b2c6a2c5a9d3814dd95359443", "message": "applied almog's comments", "committedDate": "2020-02-03T19:34:08Z", "type": "commit"}, {"oid": "6c1b1068ba1a0349e770f987130e4486b5ca193f", "url": "https://github.com/confluentinc/ksql/commit/6c1b1068ba1a0349e770f987130e4486b5ca193f", "message": "nit", "committedDate": "2020-02-03T19:39:34Z", "type": "commit"}, {"oid": "6c1b1068ba1a0349e770f987130e4486b5ca193f", "url": "https://github.com/confluentinc/ksql/commit/6c1b1068ba1a0349e770f987130e4486b5ca193f", "message": "nit", "committedDate": "2020-02-03T19:39:34Z", "type": "forcePushed"}, {"oid": "659ed3dbbed195db314b29a0dcd5732d5d5600c5", "url": "https://github.com/confluentinc/ksql/commit/659ed3dbbed195db314b29a0dcd5732d5d5600c5", "message": "fixed toString", "committedDate": "2020-02-03T20:41:34Z", "type": "commit"}]}