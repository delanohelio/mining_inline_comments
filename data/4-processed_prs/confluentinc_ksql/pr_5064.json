{"pr_number": 5064, "pr_title": "feat: support multi-way joins", "pr_createdAt": "2020-04-14T19:19:02Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5064", "timeline": [{"oid": "84d95457e81f0c6c910a7e94419c7619a71511b4", "url": "https://github.com/confluentinc/ksql/commit/84d95457e81f0c6c910a7e94419c7619a71511b4", "message": "feat: support multi-way joins", "committedDate": "2020-04-15T16:03:44Z", "type": "forcePushed"}, {"oid": "b04f8e3a6fcabfdae30f9620a92f4ca1bf4d21f9", "url": "https://github.com/confluentinc/ksql/commit/b04f8e3a6fcabfdae30f9620a92f4ca1bf4d21f9", "message": "feat: support multi-way joins", "committedDate": "2020-04-15T16:41:30Z", "type": "forcePushed"}, {"oid": "3ddff681aeaf28bd632df84c889a7a4c70d847ff", "url": "https://github.com/confluentinc/ksql/commit/3ddff681aeaf28bd632df84c889a7a4c70d847ff", "message": "feat: support multi-way joins", "committedDate": "2020-04-15T16:46:18Z", "type": "commit"}, {"oid": "3ddff681aeaf28bd632df84c889a7a4c70d847ff", "url": "https://github.com/confluentinc/ksql/commit/3ddff681aeaf28bd632df84c889a7a4c70d847ff", "message": "feat: support multi-way joins", "committedDate": "2020-04-15T16:46:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4OTM3MA==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409089370", "bodyText": "suggestion: Feels like this whole method would be better being somewhere outside of LogicalPlanner.", "author": "big-andy-coates", "createdAt": "2020-04-15T19:41:28Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -444,45 +443,42 @@ private PlanNode buildSourceNode() {\n           + analysis.getAllDataSources());\n     }\n \n-    return buildJoin((Join) tree);\n+    return buildJoin((Join) tree, \"\");\n   }\n \n-\n   /**\n-   * @param root  the root of the Join Tree\n+   * @param root    the root of the Join Tree\n+   * @param prefix  the prefix to uniquely identify the plan node\n    * @return the PlanNode representing this Join Tree\n    */\n-  private PlanNode buildJoin(final Join root) {\n+  private PlanNode buildJoin(final Join root, final String prefix) {", "originalCommit": "3ddff681aeaf28bd632df84c889a7a4c70d847ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTExODE2OQ==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409118169", "bodyText": "I figured it would be easier to refactor it (cf your comment #5023 (review)) if everything was in one place, but if you want I can split this one out now", "author": "agavra", "createdAt": "2020-04-15T20:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4OTM3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5NTMxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409195319", "bodyText": "np.", "author": "big-andy-coates", "createdAt": "2020-04-15T23:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4OTM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MDU5MA==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409090590", "bodyText": "This feels wrong - can we now rely on polymorphism here? i,.e. can we not simply call the source nodes and have then do the right thing, rather than having these instanceof conditionals?", "author": "big-andy-coates", "createdAt": "2020-04-15T19:43:53Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/JoinNode.java", "diffHunk": "@@ -116,9 +116,11 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n   public Stream<ColumnName> resolveSelectStar(\n       final Optional<SourceName> sourceName, final boolean valueOnly\n   ) {\n-    return getSources().stream()\n-        .filter(s -> !sourceName.isPresent() || sourceName.equals(s.getSourceName()))\n-        .flatMap(s -> s.resolveSelectStar(sourceName, false));\n+    return getSources()\n+            .stream()\n+            .flatMap(s -> s instanceof JoinNode ? s.getSources().stream() : Stream.of(s))", "originalCommit": "3ddff681aeaf28bd632df84c889a7a4c70d847ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEyMjg2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409122865", "bodyText": "What I want to achieve is very specific to nested Join nodes. That means I have three ways I see to solve this:\n\nuse instanceof and just flatten the sources here (existing solution)\nadd a new method getLeafSources (seems like overkill)\nchange getSources() to recurse (I tried this and it didn't work out of the box, so it requires more changes)\n\nI think the third option makes the most sense, I'll do that in a follow-up PR since it wasn't a one-shot change.", "author": "agavra", "createdAt": "2020-04-15T20:45:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MDU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEyODE0Nw==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409128147", "bodyText": "EDIT: getSources() shouldn't recurse because it should give you exactly this node's sources. so it's between adding a new method and keeping it as is. I think I like it as is, but let me know if you feel strongly", "author": "agavra", "createdAt": "2020-04-15T20:55:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MDU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5NTI4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409195283", "bodyText": "Don't feel strongly about it - just feels wrong. Without bringing the code down and trying out your changes I don't know a better way - so happy to merge.", "author": "big-andy-coates", "createdAt": "2020-04-15T23:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MDU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MjA5Mw==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409092093", "bodyText": "can we not search and replace STT with stream-table-table and II with inner-inner etc?  This would make the test name less cryptic IMHO...", "author": "big-andy-coates", "createdAt": "2020-04-15T19:46:50Z", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/multi-joins.json", "diffHunk": "@@ -0,0 +1,782 @@\n+{\n+  \"comments\": [\n+    \"NOTE: these tests only attempt to cover multi-join scenarios; ensuring the validity of the \",\n+    \"sub-join topologies is delegated to joins.json\",\n+    \"\",\n+    \"The first part of the name is the join sequence - STT, for example, means STREAM-TABLE-TABLE \",\n+    \"The second part of the name is the type of join - II, for example, means INNER INNER \",\n+    \"The third part of the name is descriptive of any additional information, if present.\"\n+  ],\n+  \"tests\": [\n+    {\n+      \"name\": \"STT - II\",", "originalCommit": "3ddff681aeaf28bd632df84c889a7a4c70d847ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MjQyMg==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409092422", "bodyText": "Given you have ksql.any.key.name.enabled enabled... why are all your keys named ROWKEY?", "author": "big-andy-coates", "createdAt": "2020-04-15T19:47:26Z", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/multi-joins.json", "diffHunk": "@@ -0,0 +1,782 @@\n+{\n+  \"comments\": [\n+    \"NOTE: these tests only attempt to cover multi-join scenarios; ensuring the validity of the \",\n+    \"sub-join topologies is delegated to joins.json\",\n+    \"\",\n+    \"The first part of the name is the join sequence - STT, for example, means STREAM-TABLE-TABLE \",\n+    \"The second part of the name is the type of join - II, for example, means INNER INNER \",\n+    \"The third part of the name is descriptive of any additional information, if present.\"\n+  ],\n+  \"tests\": [\n+    {\n+      \"name\": \"STT - II\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ROWKEY INT KEY, ID bigint) WITH (kafka_topic='left', value_format='JSON');\",", "originalCommit": "3ddff681aeaf28bd632df84c889a7a4c70d847ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEyMzEyNA==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409123124", "bodyText": "Suggest a better name?", "author": "agavra", "createdAt": "2020-04-15T20:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MjQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5NTQzOA==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409195438", "bodyText": "ID INT KEY, STRING NAME", "author": "big-andy-coates", "createdAt": "2020-04-15T23:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MjQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5NTkzNw==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409195937", "bodyText": "fair enough - i'll change this in my next PR!", "author": "agavra", "createdAt": "2020-04-15T23:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MjQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MzYxMw==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409093613", "bodyText": "Boo: output should not include key columns  in the value :(", "author": "big-andy-coates", "createdAt": "2020-04-15T19:49:41Z", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/multi-joins.json", "diffHunk": "@@ -0,0 +1,782 @@\n+{\n+  \"comments\": [\n+    \"NOTE: these tests only attempt to cover multi-join scenarios; ensuring the validity of the \",\n+    \"sub-join topologies is delegated to joins.json\",\n+    \"\",\n+    \"The first part of the name is the join sequence - STT, for example, means STREAM-TABLE-TABLE \",\n+    \"The second part of the name is the type of join - II, for example, means INNER INNER \",\n+    \"The third part of the name is descriptive of any additional information, if present.\"\n+  ],\n+  \"tests\": [\n+    {\n+      \"name\": \"STT - II\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ROWKEY INT KEY, ID bigint) WITH (kafka_topic='left', value_format='JSON');\",\n+        \"CREATE TABLE T2 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right', value_format='JSON');\",\n+        \"CREATE TABLE T3 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right2', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT as SELECT s1.ID, t2.ID, t3.ID FROM S1 JOIN T2 ON S1.ROWKEY = T2.ROWKEY JOIN T3 ON S1.ROWKEY = T3.ROWKEY;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.any.key.name.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"right2\", \"key\": 0, \"value\": {\"id\": 3}, \"timestamp\": 10},\n+        {\"topic\": \"right\", \"key\": 0, \"value\": {\"id\": 2}, \"timestamp\": 11},\n+        {\"topic\": \"left\", \"key\": 0, \"value\": {\"id\": 1}, \"timestamp\": 12},\n+        {\"topic\": \"left\", \"key\": 1, \"value\": {\"id\": 1}, \"timestamp\": 14}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 0, \"value\": {\"S1_ID\": 1, \"T2_ID\": 2, \"T3_ID\": 3}, \"timestamp\":  12}\n+      ],\n+      \"post\": {\n+        \"topics\": {\"blacklist\": \".*-repartition\"},\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ROWKEY INT KEY, S1_ID BIGINT, T2_ID BIGINT, T3_ID BIGINT\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"STT - LL\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ROWKEY INT KEY, ID bigint) WITH (kafka_topic='left', value_format='JSON');\",\n+        \"CREATE TABLE T2 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right', value_format='JSON');\",\n+        \"CREATE TABLE T3 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right2', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT as SELECT s1.ID, t2.ID, t3.ID FROM S1 LEFT JOIN T2 ON S1.ROWKEY = T2.ROWKEY LEFT JOIN T3 ON S1.ROWKEY = T3.ROWKEY;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.any.key.name.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"left\", \"key\": 0, \"value\": {\"id\": 1}, \"timestamp\": 9},\n+        {\"topic\": \"right\", \"key\": 0, \"value\": {\"id\": 2}, \"timestamp\": 10},\n+        {\"topic\": \"left\", \"key\": 0, \"value\": {\"id\": 1}, \"timestamp\": 11},\n+        {\"topic\": \"right2\", \"key\": 0, \"value\": {\"id\": 3}, \"timestamp\": 12},\n+        {\"topic\": \"left\", \"key\": 0, \"value\": {\"id\": 1}, \"timestamp\": 13}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 0, \"value\": {\"S1_ID\": 1, \"T2_ID\": null, \"T3_ID\": null}, \"timestamp\":  9},\n+        {\"topic\": \"OUTPUT\", \"key\": 0, \"value\": {\"S1_ID\": 1, \"T2_ID\": 2, \"T3_ID\": null}, \"timestamp\":  11},\n+        {\"topic\": \"OUTPUT\", \"key\": 0, \"value\": {\"S1_ID\": 1, \"T2_ID\": 2, \"T3_ID\": 3}, \"timestamp\":  13}\n+      ],\n+      \"post\": {\n+        \"topics\": {\"blacklist\": \".*-repartition\"},\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ROWKEY INT KEY, S1_ID BIGINT, T2_ID BIGINT, T3_ID BIGINT\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"STT - LI\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ROWKEY INT KEY, ID bigint) WITH (kafka_topic='left', value_format='JSON');\",\n+        \"CREATE TABLE T2 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right', value_format='JSON');\",\n+        \"CREATE TABLE T3 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right2', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT as SELECT s1.ID, t2.ID, t3.ID FROM S1 LEFT JOIN T2 ON S1.ROWKEY = T2.ROWKEY JOIN T3 ON S1.ROWKEY = T3.ROWKEY;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.any.key.name.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"left\", \"key\": 0, \"value\": {\"id\": 1}, \"timestamp\": 9},\n+        {\"topic\": \"right\", \"key\": 0, \"value\": {\"id\": 2}, \"timestamp\": 10},\n+        {\"topic\": \"left\", \"key\": 0, \"value\": {\"id\": 1}, \"timestamp\": 11},\n+        {\"topic\": \"right2\", \"key\": 0, \"value\": {\"id\": 3}, \"timestamp\": 12},\n+        {\"topic\": \"left\", \"key\": 0, \"value\": {\"id\": 1}, \"timestamp\": 13}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 0, \"value\": {\"S1_ID\": 1, \"T2_ID\": 2, \"T3_ID\": 3}, \"timestamp\":  13}\n+      ],\n+      \"post\": {\n+        \"topics\": {\"blacklist\": \".*-repartition\"},\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ROWKEY INT KEY, S1_ID BIGINT, T2_ID BIGINT, T3_ID BIGINT\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"STT - IL\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ROWKEY INT KEY, ID bigint) WITH (kafka_topic='left', value_format='JSON');\",\n+        \"CREATE TABLE T2 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right', value_format='JSON');\",\n+        \"CREATE TABLE T3 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right2', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT as SELECT s1.ID, t2.ID, t3.ID FROM S1 JOIN T2 ON S1.ROWKEY = T2.ROWKEY LEFT JOIN T3 ON S1.ROWKEY = T3.ROWKEY;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.any.key.name.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"left\", \"key\": 0, \"value\": {\"id\": 1}, \"timestamp\": 9},\n+        {\"topic\": \"right\", \"key\": 0, \"value\": {\"id\": 2}, \"timestamp\": 10},\n+        {\"topic\": \"left\", \"key\": 0, \"value\": {\"id\": 1}, \"timestamp\": 11},\n+        {\"topic\": \"right2\", \"key\": 0, \"value\": {\"id\": 3}, \"timestamp\": 12},\n+        {\"topic\": \"left\", \"key\": 0, \"value\": {\"id\": 1}, \"timestamp\": 13}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 0, \"value\": {\"S1_ID\": 1, \"T2_ID\": 2, \"T3_ID\": null}, \"timestamp\":  11},\n+        {\"topic\": \"OUTPUT\", \"key\": 0, \"value\": {\"S1_ID\": 1, \"T2_ID\": 2, \"T3_ID\": 3}, \"timestamp\":  13}\n+      ],\n+      \"post\": {\n+        \"topics\": {\"blacklist\": \".*-repartition\"},\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ROWKEY INT KEY, S1_ID BIGINT, T2_ID BIGINT, T3_ID BIGINT\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"STT - II - rekey\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ROWKEY INT KEY, K INT, ID bigint) WITH (kafka_topic='left', value_format='JSON');\",\n+        \"CREATE TABLE T2 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right', value_format='JSON');\",\n+        \"CREATE TABLE T3 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right2', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT as SELECT s1.ID, t2.ID, t3.ID FROM S1 JOIN T2 ON S1.K = T2.ROWKEY JOIN T3 ON S1.K = T3.ROWKEY;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.any.key.name.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"right2\", \"key\": 1, \"value\": {\"id\": 3}, \"timestamp\": 10},\n+        {\"topic\": \"right\", \"key\": 1, \"value\": {\"id\": 2}, \"timestamp\": 11},\n+        {\"topic\": \"left\", \"key\": 0, \"value\": {\"k\": 1, \"id\": 1}, \"timestamp\": 12}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-L_Join-repartition\", \"key\": 1, \"value\": {\"S1_K\": 1, \"S1_ID\": 1, \"S1_ROWTIME\": 12, \"S1_ROWKEY\": 0}, \"timestamp\": 12},\n+        {\"topic\": \"OUTPUT\", \"key\": 1, \"value\": {\"S1_ID\": 1, \"T2_ID\": 2, \"T3_ID\": 3}, \"timestamp\":  12}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"K INT KEY, S1_ID BIGINT, T2_ID BIGINT, T3_ID BIGINT\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"STT - II - rekey with expression\",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ROWKEY INT KEY, K INT, ID bigint) WITH (kafka_topic='left', value_format='JSON');\",\n+        \"CREATE TABLE T2 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right', value_format='JSON');\",\n+        \"CREATE TABLE T3 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right2', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT as SELECT s1.ID, t2.ID, t3.ID FROM S1 JOIN T2 ON S1.K + 1 = T2.ROWKEY JOIN T3 ON S1.K + 1 = T3.ROWKEY;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.any.key.name.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"right2\", \"key\": 1, \"value\": {\"id\": 3}, \"timestamp\": 10},\n+        {\"topic\": \"right\", \"key\": 1, \"value\": {\"id\": 2}, \"timestamp\": 11},\n+        {\"topic\": \"left\", \"key\": 0, \"value\": {\"k\": 0, \"id\": 1}, \"timestamp\": 12}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"_confluent-ksql-some.ksql.service.idquery_CSAS_OUTPUT_0-L_Join-repartition\", \"key\": 1, \"value\": {\"S1_K\": 0, \"S1_ID\": 1, \"S1_ROWTIME\": 12, \"S1_ROWKEY\": 0, \"S1_KSQL_COL_0\": 1}, \"timestamp\": 12},\n+        {\"topic\": \"OUTPUT\", \"key\": 1, \"value\": {\"S1_ID\": 1, \"T2_ID\": 2, \"T3_ID\": 3}, \"timestamp\":  12}\n+      ],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"KSQL_COL_0 INT KEY, S1_ID BIGINT, T2_ID BIGINT, T3_ID BIGINT\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"STT - II - select * \",\n+      \"statements\": [\n+        \"CREATE STREAM S1 (ROWKEY INT KEY, ID bigint) WITH (kafka_topic='left', value_format='JSON');\",\n+        \"CREATE TABLE T2 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right', value_format='JSON');\",\n+        \"CREATE TABLE T3 (ROWKEY INT PRIMARY KEY, ID bigint) WITH (kafka_topic='right2', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT as SELECT * FROM S1 JOIN T2 ON S1.ROWKEY = T2.ROWKEY JOIN T3 ON S1.ROWKEY = T3.ROWKEY;\"\n+      ],\n+      \"properties\": {\n+        \"ksql.any.key.name.enabled\": true\n+      },\n+      \"inputs\": [\n+        {\"topic\": \"right2\", \"key\": 0, \"value\": {\"id\": 3}, \"timestamp\": 10},\n+        {\"topic\": \"right\", \"key\": 0, \"value\": {\"id\": 2}, \"timestamp\": 11},\n+        {\"topic\": \"left\", \"key\": 0, \"value\": {\"id\": 1}, \"timestamp\": 12}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 0, \"value\": {\"S1_ROWTIME\": 12, \"S1_ROWKEY\": 0, \"S1_ID\": 1, \"T2_ROWTIME\": 12, \"T2_ROWKEY\": 0, \"T2_ID\": 2, \"T3_ROWTIME\": 12, \"T3_ROWKEY\": 0, \"T3_ID\": 3}, \"timestamp\":  12}", "originalCommit": "3ddff681aeaf28bd632df84c889a7a4c70d847ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEyNTM5NA==", "url": "https://github.com/confluentinc/ksql/pull/5064#discussion_r409125394", "bodyText": "should be transparently resolved with #3731", "author": "agavra", "createdAt": "2020-04-15T20:49:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MzYxMw=="}], "type": "inlineReview"}, {"oid": "07070ca67adcbf4363355e9f884fc99337f72389", "url": "https://github.com/confluentinc/ksql/commit/07070ca67adcbf4363355e9f884fc99337f72389", "message": "test: improve QTT test names for multijoins", "committedDate": "2020-04-15T20:50:25Z", "type": "commit"}]}