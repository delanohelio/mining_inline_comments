{"pr_number": 5518, "pr_title": "docs: add docs for synthetic keys", "pr_createdAt": "2020-06-01T15:56:33Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5518", "timeline": [{"oid": "6140b672f2b132a32c88eeb2fed4cc59fe018cec", "url": "https://github.com/confluentinc/ksql/commit/6140b672f2b132a32c88eeb2fed4cc59fe018cec", "message": "docs: add docs for synthetic keys", "committedDate": "2020-06-01T15:53:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM0MTkxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5518#discussion_r433341919", "bodyText": "straightforward", "author": "derekjn", "createdAt": "2020-06-01T16:18:09Z", "path": "docs/developer-guide/joins/synthetic-keys.md", "diffHunk": "@@ -6,4 +6,88 @@ description: Learn which joins result in synthetic key columns and how to work w\n keywords: ksqldb, join, key, rowkey\n ---\n \n-Coming soon.\n\\ No newline at end of file\n+Some joins have a synthetic key column in their result. This is a column that does not come from any\n+source. Lets start with an example to help explain what these synthetic key columns are and why they\n+are required:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+  SELECT * FROM L FULL OUTER JOIN R ON L.ID = R.ID;\n+```\n+\n+The above statement seems straight forward enough: create a new table that's the result of", "originalCommit": "6140b672f2b132a32c88eeb2fed4cc59fe018cec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3NDIyNg==", "url": "https://github.com/confluentinc/ksql/pull/5518#discussion_r433374226", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            source. Lets start with an example to help explain what these synthetic key columns are and why they\n          \n          \n            \n            source. Here's an example to help explain what synthetic key columns are and why they", "author": "JimGalasyn", "createdAt": "2020-06-01T17:18:05Z", "path": "docs/developer-guide/joins/synthetic-keys.md", "diffHunk": "@@ -6,4 +6,88 @@ description: Learn which joins result in synthetic key columns and how to work w\n keywords: ksqldb, join, key, rowkey\n ---\n \n-Coming soon.\n\\ No newline at end of file\n+Some joins have a synthetic key column in their result. This is a column that does not come from any\n+source. Lets start with an example to help explain what these synthetic key columns are and why they", "originalCommit": "6140b672f2b132a32c88eeb2fed4cc59fe018cec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3NDQxNw==", "url": "https://github.com/confluentinc/ksql/pull/5518#discussion_r433374417", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The above statement seems straight forward enough: create a new table that's the result of\n          \n          \n            \n            The previous statement seems straightforward enough: create a new table that's the result of", "author": "JimGalasyn", "createdAt": "2020-06-01T17:18:28Z", "path": "docs/developer-guide/joins/synthetic-keys.md", "diffHunk": "@@ -6,4 +6,88 @@ description: Learn which joins result in synthetic key columns and how to work w\n keywords: ksqldb, join, key, rowkey\n ---\n \n-Coming soon.\n\\ No newline at end of file\n+Some joins have a synthetic key column in their result. This is a column that does not come from any\n+source. Lets start with an example to help explain what these synthetic key columns are and why they\n+are required:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+  SELECT * FROM L FULL OUTER JOIN R ON L.ID = R.ID;\n+```\n+\n+The above statement seems straight forward enough: create a new table that's the result of", "originalCommit": "6140b672f2b132a32c88eeb2fed4cc59fe018cec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3NDUwNw==", "url": "https://github.com/confluentinc/ksql/pull/5518#discussion_r433374507", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            performing a full outer join of two source tables, joining on their ID columns. One might expect\n          \n          \n            \n            performing a full outer join of two source tables, joining on their ID columns. You might expect", "author": "JimGalasyn", "createdAt": "2020-06-01T17:18:40Z", "path": "docs/developer-guide/joins/synthetic-keys.md", "diffHunk": "@@ -6,4 +6,88 @@ description: Learn which joins result in synthetic key columns and how to work w\n keywords: ksqldb, join, key, rowkey\n ---\n \n-Coming soon.\n\\ No newline at end of file\n+Some joins have a synthetic key column in their result. This is a column that does not come from any\n+source. Lets start with an example to help explain what these synthetic key columns are and why they\n+are required:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+  SELECT * FROM L FULL OUTER JOIN R ON L.ID = R.ID;\n+```\n+\n+The above statement seems straight forward enough: create a new table that's the result of\n+performing a full outer join of two source tables, joining on their ID columns. One might expect", "originalCommit": "6140b672f2b132a32c88eeb2fed4cc59fe018cec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3NDgyMg==", "url": "https://github.com/confluentinc/ksql/pull/5518#discussion_r433374822", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Unfortunately, until ksqlDB supports structured keys the join must result in a table with a single\n          \n          \n            \n            Unfortunately, until ksqlDB supports structured keys, the join must result in a table with a single", "author": "JimGalasyn", "createdAt": "2020-06-01T17:19:13Z", "path": "docs/developer-guide/joins/synthetic-keys.md", "diffHunk": "@@ -6,4 +6,88 @@ description: Learn which joins result in synthetic key columns and how to work w\n keywords: ksqldb, join, key, rowkey\n ---\n \n-Coming soon.\n\\ No newline at end of file\n+Some joins have a synthetic key column in their result. This is a column that does not come from any\n+source. Lets start with an example to help explain what these synthetic key columns are and why they\n+are required:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+  SELECT * FROM L FULL OUTER JOIN R ON L.ID = R.ID;\n+```\n+\n+The above statement seems straight forward enough: create a new table that's the result of\n+performing a full outer join of two source tables, joining on their ID columns. One might expect\n+that such a join would result in a table with a compound primary key containing both `L.ID` and\n+`R.ID`, and that's what will happen once ksqlDB supports\n+[structured keys][1].\n+\n+Unfortunately, until ksqlDB supports structured keys the join must result in a table with a single", "originalCommit": "6140b672f2b132a32c88eeb2fed4cc59fe018cec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3NTQyNg==", "url": "https://github.com/confluentinc/ksql/pull/5518#discussion_r433375426", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            primary key column. In the above join, as it is a full-outer join, either `L.ID` or `R.ID` may be\n          \n          \n            \n            primary key column. Because the previous join is a full-outer join, either `L.ID` or `R.ID` may be", "author": "JimGalasyn", "createdAt": "2020-06-01T17:20:18Z", "path": "docs/developer-guide/joins/synthetic-keys.md", "diffHunk": "@@ -6,4 +6,88 @@ description: Learn which joins result in synthetic key columns and how to work w\n keywords: ksqldb, join, key, rowkey\n ---\n \n-Coming soon.\n\\ No newline at end of file\n+Some joins have a synthetic key column in their result. This is a column that does not come from any\n+source. Lets start with an example to help explain what these synthetic key columns are and why they\n+are required:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+  SELECT * FROM L FULL OUTER JOIN R ON L.ID = R.ID;\n+```\n+\n+The above statement seems straight forward enough: create a new table that's the result of\n+performing a full outer join of two source tables, joining on their ID columns. One might expect\n+that such a join would result in a table with a compound primary key containing both `L.ID` and\n+`R.ID`, and that's what will happen once ksqlDB supports\n+[structured keys][1].\n+\n+Unfortunately, until ksqlDB supports structured keys the join must result in a table with a single\n+primary key column. In the above join, as it is a full-outer join, either `L.ID` or `R.ID` may be", "originalCommit": "6140b672f2b132a32c88eeb2fed4cc59fe018cec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3NTg1NA==", "url": "https://github.com/confluentinc/ksql/pull/5518#discussion_r433375854", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            missing, i.e. `NULL`, or both may have the same value. However, the data produced to {{ site.aktm }}\n          \n          \n            \n            missing (`NULL`), or both may have the same value. But the data produced to {{ site.aktm }}", "author": "JimGalasyn", "createdAt": "2020-06-01T17:21:06Z", "path": "docs/developer-guide/joins/synthetic-keys.md", "diffHunk": "@@ -6,4 +6,88 @@ description: Learn which joins result in synthetic key columns and how to work w\n keywords: ksqldb, join, key, rowkey\n ---\n \n-Coming soon.\n\\ No newline at end of file\n+Some joins have a synthetic key column in their result. This is a column that does not come from any\n+source. Lets start with an example to help explain what these synthetic key columns are and why they\n+are required:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+  SELECT * FROM L FULL OUTER JOIN R ON L.ID = R.ID;\n+```\n+\n+The above statement seems straight forward enough: create a new table that's the result of\n+performing a full outer join of two source tables, joining on their ID columns. One might expect\n+that such a join would result in a table with a compound primary key containing both `L.ID` and\n+`R.ID`, and that's what will happen once ksqlDB supports\n+[structured keys][1].\n+\n+Unfortunately, until ksqlDB supports structured keys the join must result in a table with a single\n+primary key column. In the above join, as it is a full-outer join, either `L.ID` or `R.ID` may be\n+missing, i.e. `NULL`, or both may have the same value. However, the data produced to {{ site.aktm }}", "originalCommit": "6140b672f2b132a32c88eeb2fed4cc59fe018cec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3NjA0MQ==", "url": "https://github.com/confluentinc/ksql/pull/5518#discussion_r433376041", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            will always have the message key set to the non-null `ID` column, as shown in the following table:\n          \n          \n            \n            always has the message key set to the non-null `ID` column, as shown in the following table:", "author": "JimGalasyn", "createdAt": "2020-06-01T17:21:25Z", "path": "docs/developer-guide/joins/synthetic-keys.md", "diffHunk": "@@ -6,4 +6,88 @@ description: Learn which joins result in synthetic key columns and how to work w\n keywords: ksqldb, join, key, rowkey\n ---\n \n-Coming soon.\n\\ No newline at end of file\n+Some joins have a synthetic key column in their result. This is a column that does not come from any\n+source. Lets start with an example to help explain what these synthetic key columns are and why they\n+are required:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+  SELECT * FROM L FULL OUTER JOIN R ON L.ID = R.ID;\n+```\n+\n+The above statement seems straight forward enough: create a new table that's the result of\n+performing a full outer join of two source tables, joining on their ID columns. One might expect\n+that such a join would result in a table with a compound primary key containing both `L.ID` and\n+`R.ID`, and that's what will happen once ksqlDB supports\n+[structured keys][1].\n+\n+Unfortunately, until ksqlDB supports structured keys the join must result in a table with a single\n+primary key column. In the above join, as it is a full-outer join, either `L.ID` or `R.ID` may be\n+missing, i.e. `NULL`, or both may have the same value. However, the data produced to {{ site.aktm }}\n+will always have the message key set to the non-null `ID` column, as shown in the following table:", "originalCommit": "6140b672f2b132a32c88eeb2fed4cc59fe018cec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3NjQzMA==", "url": "https://github.com/confluentinc/ksql/pull/5518#discussion_r433376430", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            columns. Hence, it is a new column: a synthetic column, i.e. a column that does not belong to each \n          \n          \n            \n            columns. Instead, it's a new column: a *synthetic* column, which means a column that doesn't belong to either", "author": "JimGalasyn", "createdAt": "2020-06-01T17:22:13Z", "path": "docs/developer-guide/joins/synthetic-keys.md", "diffHunk": "@@ -6,4 +6,88 @@ description: Learn which joins result in synthetic key columns and how to work w\n keywords: ksqldb, join, key, rowkey\n ---\n \n-Coming soon.\n\\ No newline at end of file\n+Some joins have a synthetic key column in their result. This is a column that does not come from any\n+source. Lets start with an example to help explain what these synthetic key columns are and why they\n+are required:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+  SELECT * FROM L FULL OUTER JOIN R ON L.ID = R.ID;\n+```\n+\n+The above statement seems straight forward enough: create a new table that's the result of\n+performing a full outer join of two source tables, joining on their ID columns. One might expect\n+that such a join would result in a table with a compound primary key containing both `L.ID` and\n+`R.ID`, and that's what will happen once ksqlDB supports\n+[structured keys][1].\n+\n+Unfortunately, until ksqlDB supports structured keys the join must result in a table with a single\n+primary key column. In the above join, as it is a full-outer join, either `L.ID` or `R.ID` may be\n+missing, i.e. `NULL`, or both may have the same value. However, the data produced to {{ site.aktm }}\n+will always have the message key set to the non-null `ID` column, as shown in the following table:\n+\n+| L.ID  | R.ID | Kafka message key |\n+|-------|------|:------------------|\n+|  10   | null | 10                |\n+|  null | 7    | 7                 |\n+|  8    | 8    | 8                 |\n+\n+Clearly, the data stored in the {{ site.ak }} message's key does not match either of the source `ID`\n+columns. Hence, it is a new column: a synthetic column, i.e. a column that does not belong to each ", "originalCommit": "6140b672f2b132a32c88eeb2fed4cc59fe018cec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3Njc5NQ==", "url": "https://github.com/confluentinc/ksql/pull/5518#discussion_r433376795", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The default name of a synthetic key column is `ROWKEY`. However, if any sources used in the join \n          \n          \n            \n            The default name of a synthetic key column is `ROWKEY`. But if any sources used in the join", "author": "JimGalasyn", "createdAt": "2020-06-01T17:22:51Z", "path": "docs/developer-guide/joins/synthetic-keys.md", "diffHunk": "@@ -6,4 +6,88 @@ description: Learn which joins result in synthetic key columns and how to work w\n keywords: ksqldb, join, key, rowkey\n ---\n \n-Coming soon.\n\\ No newline at end of file\n+Some joins have a synthetic key column in their result. This is a column that does not come from any\n+source. Lets start with an example to help explain what these synthetic key columns are and why they\n+are required:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+  SELECT * FROM L FULL OUTER JOIN R ON L.ID = R.ID;\n+```\n+\n+The above statement seems straight forward enough: create a new table that's the result of\n+performing a full outer join of two source tables, joining on their ID columns. One might expect\n+that such a join would result in a table with a compound primary key containing both `L.ID` and\n+`R.ID`, and that's what will happen once ksqlDB supports\n+[structured keys][1].\n+\n+Unfortunately, until ksqlDB supports structured keys the join must result in a table with a single\n+primary key column. In the above join, as it is a full-outer join, either `L.ID` or `R.ID` may be\n+missing, i.e. `NULL`, or both may have the same value. However, the data produced to {{ site.aktm }}\n+will always have the message key set to the non-null `ID` column, as shown in the following table:\n+\n+| L.ID  | R.ID | Kafka message key |\n+|-------|------|:------------------|\n+|  10   | null | 10                |\n+|  null | 7    | 7                 |\n+|  8    | 8    | 8                 |\n+\n+Clearly, the data stored in the {{ site.ak }} message's key does not match either of the source `ID`\n+columns. Hence, it is a new column: a synthetic column, i.e. a column that does not belong to each \n+source table.\n+\n+## What joins result in synthetic key columns?\n+\n+Any join where the key column in the result does not match any source column is said to have a \n+synthetic key column.\n+\n+The following types of joins result in a synthetic key column being added to the result schema:\n+\n+1. `FULL OUTER` joins, for example:\n+\n+    ```sql\n+   CREATE TABLE OUTPUT AS\n+      SELECT * FROM L FULL OUTER JOIN R ON L.ID = R.ID;\n+    ```\n+\n+ \n+2. Any join where all expressions used in the join `ON` criteria are not simple column references.\n+   For example: \n+\n+    ```sql\n+   -- join on expressions other than column references:\n+   CREATE TABLE OUTPUT AS\n+      SELECT * FROM L JOIN R ON ABS(L.ID) = ABS(R.ID);\n+    ```\n+\n+## What name is assigned to a Synthetic key column?\n+\n+The default name of a synthetic key column is `ROWKEY`. However, if any sources used in the join ", "originalCommit": "6140b672f2b132a32c88eeb2fed4cc59fe018cec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3Njk1OQ==", "url": "https://github.com/confluentinc/ksql/pull/5518#discussion_r433376959", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            already contain a column called `ROWKEY` then the synthetic key column will be named `ROWKEY_1`, or\n          \n          \n            \n            already contain a column named `ROWKEY`, the synthetic key column is named `ROWKEY_1`, or", "author": "JimGalasyn", "createdAt": "2020-06-01T17:23:09Z", "path": "docs/developer-guide/joins/synthetic-keys.md", "diffHunk": "@@ -6,4 +6,88 @@ description: Learn which joins result in synthetic key columns and how to work w\n keywords: ksqldb, join, key, rowkey\n ---\n \n-Coming soon.\n\\ No newline at end of file\n+Some joins have a synthetic key column in their result. This is a column that does not come from any\n+source. Lets start with an example to help explain what these synthetic key columns are and why they\n+are required:\n+\n+```sql\n+CREATE TABLE OUTPUT AS\n+  SELECT * FROM L FULL OUTER JOIN R ON L.ID = R.ID;\n+```\n+\n+The above statement seems straight forward enough: create a new table that's the result of\n+performing a full outer join of two source tables, joining on their ID columns. One might expect\n+that such a join would result in a table with a compound primary key containing both `L.ID` and\n+`R.ID`, and that's what will happen once ksqlDB supports\n+[structured keys][1].\n+\n+Unfortunately, until ksqlDB supports structured keys the join must result in a table with a single\n+primary key column. In the above join, as it is a full-outer join, either `L.ID` or `R.ID` may be\n+missing, i.e. `NULL`, or both may have the same value. However, the data produced to {{ site.aktm }}\n+will always have the message key set to the non-null `ID` column, as shown in the following table:\n+\n+| L.ID  | R.ID | Kafka message key |\n+|-------|------|:------------------|\n+|  10   | null | 10                |\n+|  null | 7    | 7                 |\n+|  8    | 8    | 8                 |\n+\n+Clearly, the data stored in the {{ site.ak }} message's key does not match either of the source `ID`\n+columns. Hence, it is a new column: a synthetic column, i.e. a column that does not belong to each \n+source table.\n+\n+## What joins result in synthetic key columns?\n+\n+Any join where the key column in the result does not match any source column is said to have a \n+synthetic key column.\n+\n+The following types of joins result in a synthetic key column being added to the result schema:\n+\n+1. `FULL OUTER` joins, for example:\n+\n+    ```sql\n+   CREATE TABLE OUTPUT AS\n+      SELECT * FROM L FULL OUTER JOIN R ON L.ID = R.ID;\n+    ```\n+\n+ \n+2. Any join where all expressions used in the join `ON` criteria are not simple column references.\n+   For example: \n+\n+    ```sql\n+   -- join on expressions other than column references:\n+   CREATE TABLE OUTPUT AS\n+      SELECT * FROM L JOIN R ON ABS(L.ID) = ABS(R.ID);\n+    ```\n+\n+## What name is assigned to a Synthetic key column?\n+\n+The default name of a synthetic key column is `ROWKEY`. However, if any sources used in the join \n+already contain a column called `ROWKEY` then the synthetic key column will be named `ROWKEY_1`, or", "originalCommit": "6140b672f2b132a32c88eeb2fed4cc59fe018cec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "72864b8a185b5f0ded1fcc440e904328c20b39a3", "url": "https://github.com/confluentinc/ksql/commit/72864b8a185b5f0ded1fcc440e904328c20b39a3", "message": "chore: requested changes and fuller test", "committedDate": "2020-06-02T08:53:29Z", "type": "commit"}]}