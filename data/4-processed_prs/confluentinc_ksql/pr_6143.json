{"pr_number": 6143, "pr_title": "feat: terminate persistent query on DROP command", "pr_createdAt": "2020-09-02T20:52:43Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6143", "timeline": [{"oid": "f09028581e73fea45a25272b448642bcb30e1ea9", "url": "https://github.com/confluentinc/ksql/commit/f09028581e73fea45a25272b448642bcb30e1ea9", "message": "feat: terminate persistent query on DROP command", "committedDate": "2020-09-02T21:45:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYzMDg4Mg==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r482630882", "bodyText": "what happens if you drop a stream that a transient query is reading from?", "author": "agavra", "createdAt": "2020-09-03T00:58:16Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/KsqlEngine.java", "diffHunk": "@@ -218,7 +218,7 @@ public TransientQueryMetadata executeQuery(\n               statement.getConfigOverrides())\n           .executeQuery(statement);\n       registerQuery(query);\n-      primaryContext.registerQuery(query);\n+      primaryContext.registerQuery(Optional.empty(), query);", "originalCommit": "f09028581e73fea45a25272b448642bcb30e1ea9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODg2NA==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r483148864", "bodyText": "The Optional.empty() makes reference to the stream/table who owns this query. Transient queries do not have such stream/table, so the empty parameter. However, I found that the stream/table that has no persistent queries running can be dropped even if it has transient queries running. Seems a bug in all versions of ksql 'cause I don't see transient queries registered in the referential integrity entries. I will fix this bug in another github issue to review it separately, and understand the following behavior once implemented:\nksql> drop stream s1;\nCannot drop S1.\nThe following queries read from this source: [_confluent-ksql-default_transient_2601039483758810470_1599154165566].\nThe following queries write into this source: [].\nYou need to terminate them before dropping S1.\n\n^ What if there are several push queries running? Does it makes sense to show the queryID or add another line for # of transient queries reading?", "author": "spena", "createdAt": "2020-09-03T17:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYzMDg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE2MDgxOQ==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r483160819", "bodyText": "ack\n\nWhat if there are several push queries running? Does it makes sense to show the queryID or add another line for # of transient queries reading?\n\nI think your suggestion of adding another line for # of transient queries reading is OK. This will become extra important to handle properly when we have scalable push queries (cc @AlanConfluent)", "author": "agavra", "createdAt": "2020-09-03T18:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYzMDg4Mg=="}], "type": "inlineReview"}, {"oid": "466af0fc8b258fdf28f2a00d117692f20f9327c9", "url": "https://github.com/confluentinc/ksql/commit/466af0fc8b258fdf28f2a00d117692f20f9327c9", "message": "feat: terminate CREATE_AS query on DROP command", "committedDate": "2020-09-14T15:32:01Z", "type": "forcePushed"}, {"oid": "9242079cf0fd6913088f59570055426a53541d93", "url": "https://github.com/confluentinc/ksql/commit/9242079cf0fd6913088f59570055426a53541d93", "message": "refactor: remove unused code", "committedDate": "2020-10-23T19:55:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NDQzNw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512264437", "bodyText": "what do you think about making this part of the DdlCommand that's passed in instead of passing it in separately? I feel like this makes sense to me because (1) it's only used for some of the DdlCommand types and (2) it would be persisted into the command topic so we can make sure that things get properly tracked in recovery. It might be a bigger change, so it can wait if we want to get this in before the 0.14 cut", "author": "agavra", "createdAt": "2020-10-26T20:59:27Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java", "diffHunk": "@@ -57,17 +58,25 @@ public DdlCommandExec(final MutableMetaStore metaStore) {\n   public DdlCommandResult execute(\n       final String sql,\n       final DdlCommand ddlCommand,\n-      final boolean withQuery) {\n-    return new Executor(sql, withQuery).execute(ddlCommand);\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgwMDA5Mw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512800093", "bodyText": "Right. It was a big change when I was looking into this. I'll follow up with this for the next release.", "author": "spena", "createdAt": "2020-10-27T15:38:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NDQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NjE4Mw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512266183", "bodyText": "any reason not to make this a Set<QueryId>? I feel that keeping this strongly typed is a benefit, especially if we want to leverage QueryId more heavily in the future", "author": "agavra", "createdAt": "2020-10-26T21:02:39Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -134,6 +146,17 @@ EngineContext createSandbox(final ServiceContext serviceContext) {\n     return Collections.unmodifiableMap(persistentQueries);\n   }\n \n+  Set<String> getQueriesWithSink(final SourceName sourceName) {", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3MTI3MA==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512971270", "bodyText": "No reason. It's actually better your suggestion.\nDone.", "author": "spena", "createdAt": "2020-10-27T19:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NjE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2OTI5Mg==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512269292", "bodyText": "is there any way to avoid special casing DropSourceCommand and just passing what we need into the executor? (applies below as well)", "author": "agavra", "createdAt": "2020-10-26T21:08:30Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -208,16 +231,90 @@ DdlCommand createDdlCommand(\n   String executeDdl(\n       final String sqlExpression,\n       final DdlCommand command,\n-      final boolean withQuery\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n   ) {\n-    final DdlCommandResult result = ddlCommandExec.execute(sqlExpression, command, withQuery);\n+    if (command instanceof DropSourceCommand) {\n+      throwIfOtherQueriesExist(((DropSourceCommand) command).getSourceName());\n+    }", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3MzU5Nw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512973597", "bodyText": "This  casing also bothers me, but I the only way I found is to pass the EngineContext to the DdlCommandExec, and do the checks when dropping the source inside, even stop the query inside too. It requires that DdlCommandExec know queries, so I wasn't sure if we wanted to do that there. I left it here as queries is in the engine context.\nIf you like the idea of passing the EngineContext to the DdlCommandExec, then I can do it in a follow-up PR for 0.15. What do you think?", "author": "spena", "createdAt": "2020-10-27T19:33:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2OTI5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4NDA2Mw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512984063", "bodyText": "makes sense, let's keep it as is for now and we can explore a refactor another time if this bites us", "author": "agavra", "createdAt": "2020-10-27T19:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2OTI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MTA5Mw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512271093", "bodyText": "nit: can we add a comment explaining why we terminate the CAS query after we drop the source? It's not clear for me reading the code (without looking at other files) why we don't do it before.", "author": "agavra", "createdAt": "2020-10-26T21:11:38Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -208,16 +231,90 @@ DdlCommand createDdlCommand(\n   String executeDdl(\n       final String sqlExpression,\n       final DdlCommand command,\n-      final boolean withQuery\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n   ) {\n-    final DdlCommandResult result = ddlCommandExec.execute(sqlExpression, command, withQuery);\n+    if (command instanceof DropSourceCommand) {\n+      throwIfOtherQueriesExist(((DropSourceCommand) command).getSourceName());\n+    }\n+\n+    final DdlCommandResult result =\n+        ddlCommandExec.execute(sqlExpression, command, withQuery, withQuerySources);\n     if (!result.isSuccess()) {\n       throw new KsqlStatementException(result.getMessage(), sqlExpression);\n     }\n+\n+    if (command instanceof DropSourceCommand) {", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3MzcwNQ==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512973705", "bodyText": "Done", "author": "spena", "createdAt": "2020-10-27T19:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MTA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MjAwMA==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512272000", "bodyText": "when could this ever be null? maybe we should throw some error if it is null?", "author": "agavra", "createdAt": "2020-10-26T21:13:24Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -208,16 +231,90 @@ DdlCommand createDdlCommand(\n   String executeDdl(\n       final String sqlExpression,\n       final DdlCommand command,\n-      final boolean withQuery\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n   ) {\n-    final DdlCommandResult result = ddlCommandExec.execute(sqlExpression, command, withQuery);\n+    if (command instanceof DropSourceCommand) {\n+      throwIfOtherQueriesExist(((DropSourceCommand) command).getSourceName());\n+    }\n+\n+    final DdlCommandResult result =\n+        ddlCommandExec.execute(sqlExpression, command, withQuery, withQuerySources);\n     if (!result.isSuccess()) {\n       throw new KsqlStatementException(result.getMessage(), sqlExpression);\n     }\n+\n+    if (command instanceof DropSourceCommand) {\n+      terminateCreateAsQuery(((DropSourceCommand) command).getSourceName());\n+    }\n+\n     return result.getMessage();\n   }\n \n-  void registerQuery(final QueryMetadata query) {\n+  private void terminateCreateAsQuery(final SourceName sourceName) {\n+    createAsQueries.computeIfPresent(sourceName, (ignore , queryId) -> {\n+      final PersistentQueryMetadata query = persistentQueries.get(queryId);\n+      if (query != null) {", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3NDAyMg==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512974022", "bodyText": "I removed it. Seems we'll never be null.", "author": "spena", "createdAt": "2020-10-27T19:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MjAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MzE5Mw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512273193", "bodyText": "if this condition is ever not met, don't we have some referential integrity issue? if we added a query to the otherQueries under the sourceName key, shouldn't it always be the case that there exists a query and the sink is sourceName? same question goes for getOtherQueriesWithSource", "author": "agavra", "createdAt": "2020-10-26T21:15:41Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -208,16 +231,90 @@ DdlCommand createDdlCommand(\n   String executeDdl(\n       final String sqlExpression,\n       final DdlCommand command,\n-      final boolean withQuery\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n   ) {\n-    final DdlCommandResult result = ddlCommandExec.execute(sqlExpression, command, withQuery);\n+    if (command instanceof DropSourceCommand) {\n+      throwIfOtherQueriesExist(((DropSourceCommand) command).getSourceName());\n+    }\n+\n+    final DdlCommandResult result =\n+        ddlCommandExec.execute(sqlExpression, command, withQuery, withQuerySources);\n     if (!result.isSuccess()) {\n       throw new KsqlStatementException(result.getMessage(), sqlExpression);\n     }\n+\n+    if (command instanceof DropSourceCommand) {\n+      terminateCreateAsQuery(((DropSourceCommand) command).getSourceName());\n+    }\n+\n     return result.getMessage();\n   }\n \n-  void registerQuery(final QueryMetadata query) {\n+  private void terminateCreateAsQuery(final SourceName sourceName) {\n+    createAsQueries.computeIfPresent(sourceName, (ignore , queryId) -> {\n+      final PersistentQueryMetadata query = persistentQueries.get(queryId);\n+      if (query != null) {\n+        query.close();\n+      }\n+\n+      return null;\n+    });\n+  }\n+\n+  private Set<String> getOtherQueriesWithSink(final SourceName sourceName) {\n+    final ImmutableSet.Builder<String> queries = ImmutableSet.builder();\n+\n+    if (otherQueries.containsKey(sourceName)) {\n+      otherQueries.get(sourceName).forEach(queryId -> {\n+        final PersistentQueryMetadata query = persistentQueries.get(queryId);\n+        if (query != null && query.getSinkName().equals(sourceName)) {", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4MDI0Mw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512980243", "bodyText": "The query that is referenced is not always a sink. See this example:\n// insert1  \n// query: INSERT INTO s1 SELECT FROM s0; \n// sink: s1, sources: s0\notherQueries\n- s1 -> [insert1]\n- s0 -> [insert1]\n\n  \n// insert2 \n// query: INSERT INTO s2 SELECT FROM s1; \n// sink: s2, sources: s1\notherQueries\n- s2 -> [insert2]\n- s1 -> [insert1, insert2]\n- s0 -> [insert1]\n\nThe queries with sink for s1 should only be insert1, but not insert2. So I need to get that list and check that the sink for those queries matches the source name I'm looking at (same for source for those queries).\nI initially thought of using two maps, otherQueriesSources and otherQueriesSinks. But I was just adding too much stuff in the code, and I saw this improvement of having only one. We don't have too many queries to cause a performance penalty walking through the queries of the desired source.\nI made a small change to see this filter better, like:\nfinal Set<QueryId> sinkQueries = getOtherQueries(sourceName, FILTER_QUERIES_WITH_SINK);\nfinal Set<QueryId> sourceQueries = getOtherQueries(sourceName, FILTER_QUERIES_WITH_SOURCE);", "author": "spena", "createdAt": "2020-10-27T19:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MzE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NzgzNw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512277837", "bodyText": "I noticed that otherQueries is thread safe, but now we're putting non-threadsafe entries inside it (HashSet). If it needs to be thread safe, we should put in a concurrent data structure (I'm guessing just Collections.synchronized(new HashSet<>()) is good enough)", "author": "agavra", "createdAt": "2020-10-26T21:24:44Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -238,10 +335,17 @@ void registerQuery(final QueryMetadata query) {\n       }\n \n       persistentQueries.put(queryId, persistentQuery);\n-      metaStore.updateForPersistentQuery(\n-          queryId.toString(),\n-          persistentQuery.getSourceNames(),\n-          ImmutableSet.of(persistentQuery.getSinkName()));\n+      if (createAsQuery) {\n+        createAsQueries.put(persistentQuery.getSinkName(), queryId);\n+      } else {\n+        final Iterable<SourceName> allSourceNames = Iterables.concat(\n+            Collections.singleton(persistentQuery.getSinkName()),\n+            persistentQuery.getSourceNames()\n+        );\n+\n+        allSourceNames.forEach(sourceName ->\n+            otherQueries.computeIfAbsent(sourceName, x -> new HashSet<>()).add(queryId));", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4MDMzMg==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512980332", "bodyText": "Done", "author": "spena", "createdAt": "2020-10-27T19:42:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NzgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTUwOA==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512281508", "bodyText": "can we document what the difference between these two are?", "author": "agavra", "createdAt": "2020-10-26T21:32:06Z", "path": "ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java", "diffHunk": "@@ -295,25 +277,45 @@ public boolean deleteType(final String name) {\n   private static final class SourceInfo {\n \n     private final DataSource source;\n-    private final ReferentialIntegrityTableEntry referentialIntegrity;\n+    private final Set<SourceName> linkedSources = new ConcurrentHashSet<>();\n+    private final Set<SourceName> referentialSources = new ConcurrentHashSet<>();", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4MDM4OQ==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512980389", "bodyText": "Done", "author": "spena", "createdAt": "2020-10-27T19:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTg2MQ==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512281861", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new SourceInfo(source, linkedSources, referentialSources);\n          \n          \n            \n                  return copyWith(source);", "author": "agavra", "createdAt": "2020-10-26T21:32:50Z", "path": "ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java", "diffHunk": "@@ -295,25 +277,45 @@ public boolean deleteType(final String name) {\n   private static final class SourceInfo {\n \n     private final DataSource source;\n-    private final ReferentialIntegrityTableEntry referentialIntegrity;\n+    private final Set<SourceName> linkedSources = new ConcurrentHashSet<>();\n+    private final Set<SourceName> referentialSources = new ConcurrentHashSet<>();\n \n     private SourceInfo(\n         final DataSource source\n     ) {\n       this.source = Objects.requireNonNull(source, \"source\");\n-      this.referentialIntegrity = new ReferentialIntegrityTableEntry();\n     }\n \n     private SourceInfo(\n         final DataSource source,\n-        final ReferentialIntegrityTableEntry referentialIntegrity\n+        final Set<SourceName> linkedSources,\n+        final Set<SourceName> referentialSources\n     ) {\n       this.source = Objects.requireNonNull(source, \"source\");\n-      this.referentialIntegrity = referentialIntegrity.copy();\n+      this.linkedSources.addAll(\n+          Objects.requireNonNull(linkedSources, \"linkedSources\"));\n+      this.referentialSources.addAll(\n+          Objects.requireNonNull(referentialSources, \"referentialSources\"));\n     }\n \n     public SourceInfo copy() {\n-      return new SourceInfo(source, referentialIntegrity);\n+      return new SourceInfo(source, linkedSources, referentialSources);", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4MTAxMQ==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512981011", "bodyText": "I ended up removing this copyWith. You made a comment in the putSource method that you were confusing, and I changed it to avoid calling this copy.", "author": "spena", "createdAt": "2020-10-27T19:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTk0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512281949", "bodyText": "we should probably make deep copies of the linked/referential sources", "author": "agavra", "createdAt": "2020-10-26T21:33:02Z", "path": "ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java", "diffHunk": "@@ -295,25 +277,45 @@ public boolean deleteType(final String name) {\n   private static final class SourceInfo {\n \n     private final DataSource source;\n-    private final ReferentialIntegrityTableEntry referentialIntegrity;\n+    private final Set<SourceName> linkedSources = new ConcurrentHashSet<>();\n+    private final Set<SourceName> referentialSources = new ConcurrentHashSet<>();\n \n     private SourceInfo(\n         final DataSource source\n     ) {\n       this.source = Objects.requireNonNull(source, \"source\");\n-      this.referentialIntegrity = new ReferentialIntegrityTableEntry();\n     }\n \n     private SourceInfo(\n         final DataSource source,\n-        final ReferentialIntegrityTableEntry referentialIntegrity\n+        final Set<SourceName> linkedSources,\n+        final Set<SourceName> referentialSources\n     ) {\n       this.source = Objects.requireNonNull(source, \"source\");\n-      this.referentialIntegrity = referentialIntegrity.copy();\n+      this.linkedSources.addAll(\n+          Objects.requireNonNull(linkedSources, \"linkedSources\"));\n+      this.referentialSources.addAll(\n+          Objects.requireNonNull(referentialSources, \"referentialSources\"));\n     }\n \n     public SourceInfo copy() {\n-      return new SourceInfo(source, referentialIntegrity);\n+      return new SourceInfo(source, linkedSources, referentialSources);\n+    }\n+\n+    public SourceInfo copyWith(final DataSource source) {\n+      return new SourceInfo(source, linkedSources, referentialSources);", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4MTg3NQ==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512981875", "bodyText": "The copies are done inside the constructor. I decided to do it there because the Maps should be mutable. Although nobody else is calling the constructor with immutable sets, I am used to doing it that way.", "author": "spena", "createdAt": "2020-10-27T19:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4Mjc1OA==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512282758", "bodyText": "I'm a little confused here, shouldn't existing already have the SourceName as dataSource? why are we calling copyWith(dataSource)?", "author": "agavra", "createdAt": "2020-10-26T21:34:35Z", "path": "ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/MetaStoreImpl.java", "diffHunk": "@@ -93,116 +94,97 @@ public void putSource(final DataSource dataSource, final boolean allowReplace) {\n       });\n     }\n \n-    dataSources.put(dataSource.getName(), new SourceInfo(dataSource));\n+    dataSources.put(dataSource.getName(),\n+        (existing != null) ? existing.copyWith(dataSource) : new SourceInfo(dataSource));", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4MjUxOA==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512982518", "bodyText": "Removed. We don't need to add the dataSource anymore when calling putSource with replace and if the dataSource already exists.", "author": "spena", "createdAt": "2020-10-27T19:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4Mjc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk5NTMyNQ==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512995325", "bodyText": "I reverted back this change. I need to replace the existing dataSource because it may contain changes in the Schema (caused by AlterStream). But I need a copy of the internal linked/referential sources.", "author": "spena", "createdAt": "2020-10-27T20:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4Mjc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4Mzk5NA==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512283994", "bodyText": "I'm worried that it's not actually a deep copy. if we call metaStore.linkSource(), for example, on the copy - it will also add it to the source (see my comment above about deep copying). Can you add a test that covers this?", "author": "agavra", "createdAt": "2020-10-26T21:36:54Z", "path": "ksqldb-metastore/src/test/java/io/confluent/ksql/metastore/MetaStoreImplTest.java", "diffHunk": "@@ -116,30 +113,22 @@ public void shouldDeepCopyTypesOnCopy() {\n   }\n \n   @Test\n-  public void shouldDeepCopySourceReferentialIntegrityDataOnCopy() {\n+  public void shouldDeepCopyLinkedAndReferentialSourcesOnCopy() {", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4MjY4OQ==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512982689", "bodyText": "Added. There wasn't any error, though.", "author": "spena", "createdAt": "2020-10-27T19:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4Mzk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4NDcwNA==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512284704", "bodyText": "why are we deleting this test? we haven't made the class not thread safe?", "author": "agavra", "createdAt": "2020-10-26T21:38:15Z", "path": "ksqldb-metastore/src/test/java/io/confluent/ksql/metastore/MetaStoreImplTest.java", "diffHunk": "@@ -359,82 +309,11 @@ public void shouldBeThreadSafe() {\n           when(source.getName()).thenReturn(SourceName.of(\"source\" + idx));\n           metaStore.putSource(source, false);\n           metaStore.getSource(source.getName());\n-\n           metaStore.getAllDataSources();\n-\n-          final String queryId = \"query\" + idx;\n-          metaStore.updateForPersistentQuery(\n-              queryId,\n-              ImmutableSet.of(source.getName()),\n-              ImmutableSet.of(source.getName()));\n-\n-          metaStore.getQueriesWithSource(source.getName());\n-          metaStore.getQueriesWithSink(source.getName());\n-\n           metaStore.copy();\n-\n-          metaStore.removePersistentQuery(queryId);\n           metaStore.deleteSource(source.getName());\n         });\n \n     assertThat(metaStore.getAllDataSources().keySet(), is(empty()));\n   }\n-\n-  @Test(timeout = 10_000)\n-  public void shouldBeThreadSafeAroundRefIntegrity() throws Exception {", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4MzE2Mw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512983163", "bodyText": "That test is verifying queries weren't altered inside the metastore. The metastore doesn't work with queries anymore, so I removed it. It was useless.", "author": "spena", "createdAt": "2020-10-27T19:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4NDcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4NTkxOQ==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512285919", "bodyText": "can this fail for any reason? we might be left in a state where we drop the source but still have a query running into it. That would be very bad \ud83d\ude22 is there any way to make the drop & terminate an atomic operation?", "author": "agavra", "createdAt": "2020-10-26T21:40:26Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -208,16 +231,90 @@ DdlCommand createDdlCommand(\n   String executeDdl(\n       final String sqlExpression,\n       final DdlCommand command,\n-      final boolean withQuery\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n   ) {\n-    final DdlCommandResult result = ddlCommandExec.execute(sqlExpression, command, withQuery);\n+    if (command instanceof DropSourceCommand) {\n+      throwIfOtherQueriesExist(((DropSourceCommand) command).getSourceName());\n+    }\n+\n+    final DdlCommandResult result =\n+        ddlCommandExec.execute(sqlExpression, command, withQuery, withQuerySources);\n     if (!result.isSuccess()) {\n       throw new KsqlStatementException(result.getMessage(), sqlExpression);\n     }\n+\n+    if (command instanceof DropSourceCommand) {\n+      terminateCreateAsQuery(((DropSourceCommand) command).getSourceName());", "originalCommit": "2f5a62f5f06fc16a62dec86307c552b3635e0605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4ODI4MQ==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r512988281", "bodyText": "It's hard to make this atomic. I would need to change the code to mark the Metastore source as deleted, but not real deletion. Then attempt to terminate the query, if successful, then do the real delete, otherwise undo the deletion mark.\nAnother solution I thought was to attempt to terminate the query before deleting the source, but there is another referential check inside the Metastore that should be done before terminating the query, so I couldn't either.\nAnyway, seems the only reason the query.close() would fail is if the closeTimeout is invalid. I made a change in the QueryMetadata to build the Duration.fromMillis during the constructor. That way we are sure the close won't fail because of that. And the other reasons that could make this to fail are thrown after the query was marked for PENDING_SHUTDOWN. After this is set, the stream cannot be closed again 'cause it will still pending shutting down. Not sure what else to do there.", "author": "spena", "createdAt": "2020-10-27T19:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4NTkxOQ=="}], "type": "inlineReview"}, {"oid": "a891fc6ea0eaddc31cbe9a2f0f188a0bc68f1278", "url": "https://github.com/confluentinc/ksql/commit/a891fc6ea0eaddc31cbe9a2f0f188a0bc68f1278", "message": "chore: apply suggestions from Almog's feedback\n\n- return QueryId on getQueriesWithSink() instead of String\n- Add a syncrhonized HashSet to otherQueries\n- Add more tests to validate deep copy on Metastore\n- Remove unnecessary copyWith()\n- Add comments to linkedSources and referentialSources\n- Remove unecessary null check\n- Add comment why terminate is done after delete source\n- Other minor fixes", "committedDate": "2020-10-27T19:27:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3Njg2NA==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r513176864", "bodyText": "can we test also something that depends on B before drop? e.g.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \"CREATE STREAM B AS SELECT * FROM A;\",\n          \n          \n            \n                    \"DROP STREAM B;\",\n          \n          \n            \n                    \"CREATE STREAM B AS SELECT * FROM A;\",\n          \n          \n            \n                    \"CREATE STREAM C AS SELECT * FROM B;\",\n          \n          \n            \n                    \"DROP STREAM C;\",\n          \n          \n            \n                    \"DROP STREAM B;\",", "author": "agavra", "createdAt": "2020-10-28T04:41:37Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/computation/RecoveryTest.java", "diffHunk": "@@ -676,6 +676,28 @@ public void shouldRecoverDrop() {\n     shouldRecover(commands);\n   }\n \n+  @Test\n+  public void shouldRecoverDrop() {\n+    server1.submitCommands(\n+        \"CREATE STREAM A (COLUMN STRING) WITH (KAFKA_TOPIC='A', VALUE_FORMAT='JSON');\",\n+        \"CREATE STREAM B AS SELECT * FROM A;\",\n+        \"DROP STREAM B;\"\n+    );\n+    shouldRecover(commands);\n+  }\n+\n+  @Test\n+  public void shouldRecoverDropWithRecreates() {\n+    server1.submitCommands(\n+        \"CREATE STREAM A (COLUMN STRING) WITH (KAFKA_TOPIC='A', VALUE_FORMAT='JSON');\",\n+        \"CREATE STREAM B AS SELECT * FROM A;\",\n+        \"DROP STREAM B;\",", "originalCommit": "1fa7a114b5f469de1c0dfaba03856a6b1ec83790", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyNDc2Mw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r513824763", "bodyText": "nit: reading this code, I'm always confused about what otherQueries actually is and it makes me revisit the code often. Can we come up with a better name here?\nAlternatively, maybe it makes sense to have a data structure:\nclass SourceQueryTracker {\n  SourceName target;\n  QueryId createTargetAsQuery;\n  Set<QueryId> nonCreateThatWriteIntoQuery;\n  Set<QueryId> queriesThatReadFromTarget;\n}\n\nprivate final Map<SourceName, SinkQueryTracker> queryTrackers;\nThat would also make it much easier to reason about thread safety. Just make everything in here totally synchronized.", "author": "agavra", "createdAt": "2020-10-28T23:39:05Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -72,6 +86,8 @@\n   private final Map<QueryId, PersistentQueryMetadata> persistentQueries;\n   private final Set<QueryMetadata> allLiveQueries = ConcurrentHashMap.newKeySet();\n   private final QueryCleanupService cleanupService;\n+  private final Map<SourceName, QueryId> createAsQueries = new ConcurrentHashMap<>();\n+  private final Map<SourceName, Set<QueryId>> otherQueries = new ConcurrentHashMap<>();", "originalCommit": "1fa7a114b5f469de1c0dfaba03856a6b1ec83790", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgzMzczMw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r513833733", "bodyText": "why don't we add this query to the otherQueries? It can still read from another (or more) source, right? If we don't do that, our error message that says \"queries that read from this source: [foo, bar]\" will be wrong (can we add a test for that too?)", "author": "agavra", "createdAt": "2020-10-29T00:07:46Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -238,10 +323,18 @@ void registerQuery(final QueryMetadata query) {\n       }\n \n       persistentQueries.put(queryId, persistentQuery);\n-      metaStore.updateForPersistentQuery(\n-          queryId.toString(),\n-          persistentQuery.getSourceNames(),\n-          ImmutableSet.of(persistentQuery.getSinkName()));\n+      if (createAsQuery) {\n+        createAsQueries.put(persistentQuery.getSinkName(), queryId);", "originalCommit": "1fa7a114b5f469de1c0dfaba03856a6b1ec83790", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgzNDExMw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r513834113", "bodyText": "I know that this part is enforced by the metastore, which is why we don't use FILTER_QUERIES_WITH_SOURCE anywhere in this class other than here. That seems a little fragile to rely on this lose coupling. I think it's OK for now, but at a minimum add a comment so the next person debugging knows where to look", "author": "agavra", "createdAt": "2020-10-29T00:09:09Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -208,16 +238,71 @@ DdlCommand createDdlCommand(\n   String executeDdl(\n       final String sqlExpression,\n       final DdlCommand command,\n-      final boolean withQuery\n+      final boolean withQuery,\n+      final Set<SourceName> withQuerySources\n   ) {\n-    final DdlCommandResult result = ddlCommandExec.execute(sqlExpression, command, withQuery);\n+    if (command instanceof DropSourceCommand) {\n+      throwIfOtherQueriesExist(((DropSourceCommand) command).getSourceName());\n+    }\n+\n+    final DdlCommandResult result =\n+        ddlCommandExec.execute(sqlExpression, command, withQuery, withQuerySources);\n     if (!result.isSuccess()) {\n       throw new KsqlStatementException(result.getMessage(), sqlExpression);\n     }\n+\n+    if (command instanceof DropSourceCommand) {\n+      // terminate the query (linked by create_as commands) after deleting the source to avoid\n+      // other commands to create queries from this source while the query is being terminated\n+      maybeTerminateCreateAsQuery(((DropSourceCommand) command).getSourceName());\n+    }\n+\n     return result.getMessage();\n   }\n \n-  void registerQuery(final QueryMetadata query) {\n+  private void maybeTerminateCreateAsQuery(final SourceName sourceName) {\n+    createAsQueries.computeIfPresent(sourceName, (ignore , queryId) -> {\n+      persistentQueries.get(queryId).close();\n+      return null;\n+    });\n+  }\n+\n+  private Set<QueryId> getOtherQueries(\n+      final SourceName sourceName,\n+      final BiPredicate<SourceName, PersistentQueryMetadata> filterQueries\n+  ) {\n+    return otherQueries.getOrDefault(sourceName, Collections.emptySet()).stream()\n+        .map(persistentQueries::get)\n+        .filter(query -> filterQueries.test(sourceName, query))\n+        .map(QueryMetadata::getQueryId)\n+        .collect(Collectors.toSet());\n+  }\n+\n+  private void throwIfOtherQueriesExist(final SourceName sourceName) {\n+    final Set<QueryId> sinkQueries = getOtherQueries(sourceName, FILTER_QUERIES_WITH_SINK);\n+    final Set<QueryId> sourceQueries = getOtherQueries(sourceName, FILTER_QUERIES_WITH_SOURCE);", "originalCommit": "1fa7a114b5f469de1c0dfaba03856a6b1ec83790", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgzNDk2Mw==", "url": "https://github.com/confluentinc/ksql/pull/6143#discussion_r513834963", "bodyText": "nit: we use this below, can we make a helper method out of it?", "author": "agavra", "createdAt": "2020-10-29T00:12:03Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineContext.java", "diffHunk": "@@ -238,10 +323,18 @@ void registerQuery(final QueryMetadata query) {\n       }\n \n       persistentQueries.put(queryId, persistentQuery);\n-      metaStore.updateForPersistentQuery(\n-          queryId.toString(),\n-          persistentQuery.getSourceNames(),\n-          ImmutableSet.of(persistentQuery.getSinkName()));\n+      if (createAsQuery) {\n+        createAsQueries.put(persistentQuery.getSinkName(), queryId);\n+      } else {\n+        final Iterable<SourceName> allSourceNames = Iterables.concat(\n+            Collections.singleton(persistentQuery.getSinkName()),\n+            persistentQuery.getSourceNames()\n+        );", "originalCommit": "1fa7a114b5f469de1c0dfaba03856a6b1ec83790", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "de62bb3e8e0be6cd63b11498be646ae47e4c08f5", "url": "https://github.com/confluentinc/ksql/commit/de62bb3e8e0be6cd63b11498be646ae47e4c08f5", "message": "refactor: call getQueriesWithSink() from KsqlEngine instead of Metastore", "committedDate": "2020-11-05T19:10:38Z", "type": "commit"}, {"oid": "360fd0a1df79b8542845d3442a52d6074bbaacb7", "url": "https://github.com/confluentinc/ksql/commit/360fd0a1df79b8542845d3442a52d6074bbaacb7", "message": "feat: terminate persistent query on DROP command", "committedDate": "2020-11-05T19:12:41Z", "type": "commit"}, {"oid": "486b53bc6e4178d3fd28d85aaa7f4112db2d8f29", "url": "https://github.com/confluentinc/ksql/commit/486b53bc6e4178d3fd28d85aaa7f4112db2d8f29", "message": "refactor: remove unused referential code from Metastore", "committedDate": "2020-11-05T19:29:04Z", "type": "commit"}, {"oid": "2e5700b32e5d96da35af10de93a2f9542b1e0f3e", "url": "https://github.com/confluentinc/ksql/commit/2e5700b32e5d96da35af10de93a2f9542b1e0f3e", "message": "fix: support restore & compact", "committedDate": "2020-11-05T19:52:06Z", "type": "commit"}, {"oid": "9238981d60861fc064ef919bc12201bd5f37c5ab", "url": "https://github.com/confluentinc/ksql/commit/9238981d60861fc064ef919bc12201bd5f37c5ab", "message": "chore: apply suggestions from Almog's feedback\n\n- return QueryId on getQueriesWithSink() instead of String\n- Add a syncrhonized HashSet to otherQueries\n- Add more tests to validate deep copy on Metastore\n- Remove unecessary null check\n- Add comment why terminate is done after delete source\n- Other minor fixes", "committedDate": "2020-11-05T19:54:16Z", "type": "commit"}, {"oid": "b097de80837b9da97f6f461b1a9be7b4813b5f37", "url": "https://github.com/confluentinc/ksql/commit/b097de80837b9da97f6f461b1a9be7b4813b5f37", "message": "chore: apply Almog's suggestions\n\n- rename otherQueries to insertQueries\n- helper method to concat query sink and sources", "committedDate": "2020-11-05T19:55:02Z", "type": "commit"}, {"oid": "b097de80837b9da97f6f461b1a9be7b4813b5f37", "url": "https://github.com/confluentinc/ksql/commit/b097de80837b9da97f6f461b1a9be7b4813b5f37", "message": "chore: apply Almog's suggestions\n\n- rename otherQueries to insertQueries\n- helper method to concat query sink and sources", "committedDate": "2020-11-05T19:55:02Z", "type": "forcePushed"}]}