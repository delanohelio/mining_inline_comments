{"pr_number": 6663, "pr_title": "Pull query thread leak", "pr_createdAt": "2020-11-23T23:35:41Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6663", "timeline": [{"oid": "53b98cdac31cd03d6d6cdb29ec94fd25d69e3c30", "url": "https://github.com/confluentinc/ksql/commit/53b98cdac31cd03d6d6cdb29ec94fd25d69e3c30", "message": "chore: fix leaked executor service in pull query handling\n\nThis fixes a leaked executor service with 100 threads that is being created once-per-request for pull queries.", "committedDate": "2020-11-23T23:29:10Z", "type": "commit"}, {"oid": "8c0400597448ec04159d8a9bc151856302bb19ca", "url": "https://github.com/confluentinc/ksql/commit/8c0400597448ec04159d8a9bc151856302bb19ca", "message": "test: enhance test to catch leaked threads next time", "committedDate": "2020-11-23T23:30:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2ODE2Nw==", "url": "https://github.com/confluentinc/ksql/pull/6663#discussion_r529068167", "bodyText": "This must have accidentally been introduced in the refactor.  I'm surprised it didn't show up in benchmarking if the threads were being leaked.  I think that technically, it would have been eventually garbage collected once the executor was GCed, but it is certainly preferable to shut it down immediately.", "author": "AlanConfluent", "createdAt": "2020-11-23T23:42:45Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineExecutor.java", "diffHunk": "@@ -164,10 +164,12 @@ PullQueryResult executePullQuery(\n           ksqlConfig,\n           analysis,\n           statement);\n-      final HARouting routing = new HARouting(\n+\n+      try (HARouting routing = new HARouting(", "originalCommit": "8c0400597448ec04159d8a9bc151856302bb19ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA3MTI3NQ==", "url": "https://github.com/confluentinc/ksql/pull/6663#discussion_r529071275", "bodyText": "Are we sure the change was properly picked up when benchmarked? It looks like it used to be created once per PullQueryExecutor (which I think was once per request). It could be that the benchmarks didn't catch it because the newFixedThreadPool is good about not allocating 100 threads unless it needs them (so we were really only leaking one thread each time). I still suspect that this would have very quickly caused OOM (cannot allocate native thread) after we issue a few thousand pull queries.", "author": "agavra", "createdAt": "2020-11-23T23:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2ODE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA3Mjc0Mg==", "url": "https://github.com/confluentinc/ksql/pull/6663#discussion_r529072742", "bodyText": "It is GC'd, but leaving threads lying around is not good practice as they are an OS resource and hold a chunk of memory too.  A bug such as this can result in requests failing due to insufficient resources, especially in something like pull queries that can see high call volumes.", "author": "big-andy-coates", "createdAt": "2020-11-23T23:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2ODE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA3NjA0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6663#discussion_r529076049", "bodyText": "PullQueryExecutor was created once per application before the refactor.  @vpapavas did benchmark this with the new physical plan code, but it must not have shown up only doing high qps for ~30 minutes at a time.  Well, good to catch before hitting the soak cluster.", "author": "AlanConfluent", "createdAt": "2020-11-24T00:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2ODE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4NzA4NQ==", "url": "https://github.com/confluentinc/ksql/pull/6663#discussion_r529087085", "bodyText": "If it's not too big of a change for this PR, it would be great to make the threadpool one per application.  Otherwise we can do it after this PR.  We should make sure we do that before 0.15 regardless.", "author": "AlanConfluent", "createdAt": "2020-11-24T00:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2ODE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM1MjgwNA==", "url": "https://github.com/confluentinc/ksql/pull/6663#discussion_r529352804", "bodyText": "#6666", "author": "big-andy-coates", "createdAt": "2020-11-24T09:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2ODE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2ODkxMw==", "url": "https://github.com/confluentinc/ksql/pull/6663#discussion_r529068913", "bodyText": "Very useful.  How did you discover the leak without this kind of test in place to begin with?", "author": "AlanConfluent", "createdAt": "2020-11-23T23:44:48Z", "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/rest/RestQueryTranslationTest.java", "diffHunk": "@@ -121,6 +127,17 @@ public void tearDown() {\n     REST_APP.closePersistentQueries();\n     REST_APP.dropSourcesExcept();\n     TEST_HARNESS.getKafkaCluster().deleteAllTopics(TestKsqlRestApp.getCommandTopicName());\n+\n+    if (STARTING_THREADS.get() == null) {", "originalCommit": "8c0400597448ec04159d8a9bc151856302bb19ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA3MTY1OA==", "url": "https://github.com/confluentinc/ksql/pull/6663#discussion_r529071658", "bodyText": "I knew there was an issue because RQTT wouldn't run locally in the IDE for me.  Then investigated  with VisualVM :D", "author": "big-andy-coates", "createdAt": "2020-11-23T23:52:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2ODkxMw=="}], "type": "inlineReview"}]}