{"pr_number": 6475, "pr_title": "feat: support `IN` operator for non-pull queries", "pr_createdAt": "2020-10-20T18:08:28Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6475", "timeline": [{"oid": "2154012b395fafcf7a1707bff7741d0d1a3e66ea", "url": "https://github.com/confluentinc/ksql/commit/2154012b395fafcf7a1707bff7741d0d1a3e66ea", "message": "feat: support `IN` operator for non-pull queries\n\nfixes: https://github.com/confluentinc/ksql/issues/6473\n\nAdds support for `IN` operator for push and persistent queries.", "committedDate": "2020-10-20T18:07:25Z", "type": "commit"}, {"oid": "c4d9fd2fb5863ba47f9902caf69700450b501f17", "url": "https://github.com/confluentinc/ksql/commit/c4d9fd2fb5863ba47f9902caf69700450b501f17", "message": "test: historical plans", "committedDate": "2020-10-20T18:07:41Z", "type": "commit"}, {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "url": "https://github.com/confluentinc/ksql/commit/4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "message": "docs: docs", "committedDate": "2020-10-20T18:38:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5MzM3MA==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508793370", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The IN operator allows you to specify multiple values in a `WHERE` clause.\n          \n          \n            \n            The IN operator enables specifying multiple values in a `WHERE` clause.", "author": "JimGalasyn", "createdAt": "2020-10-20T19:44:47Z", "path": "docs/developer-guide/ksqldb-reference/operators.md", "diffHunk": "@@ -66,6 +67,17 @@ SELECT USERID,\n   EMIT CHANGES;\r\n ```\r\n \r\n+IN\r\n+--\r\n+\r\n+The IN operator allows you to specify multiple values in a `WHERE` clause.\r", "originalCommit": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5NDUyNA==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508794524", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The IN operator is a shorthand for multiple `OR` conditions.\n          \n          \n            \n            It provides the equivalent of multiple `OR` conditions.", "author": "JimGalasyn", "createdAt": "2020-10-20T19:46:48Z", "path": "docs/developer-guide/ksqldb-reference/operators.md", "diffHunk": "@@ -66,6 +67,17 @@ SELECT USERID,\n   EMIT CHANGES;\r\n ```\r\n \r\n+IN\r\n+--\r\n+\r\n+The IN operator allows you to specify multiple values in a `WHERE` clause.\r\n+\r\n+The IN operator is a shorthand for multiple `OR` conditions.\r", "originalCommit": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5NDgxOQ==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508794819", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Short hand for multiple `OR` conditions.\n          \n          \n            \n            Specifies multiple `OR` conditions.", "author": "JimGalasyn", "createdAt": "2020-10-20T19:47:19Z", "path": "docs/developer-guide/ksqldb-reference/quick-reference.md", "diffHunk": "@@ -427,6 +427,23 @@ SELECT user_id\n   EMIT CHANGES;\r\n ```\r\n \r\n+## IN\r\n+Short hand for multiple `OR` conditions.\r", "originalCommit": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwMzE3Ng==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508903176", "bodyText": "Is it really a condition?  I think of condition as something that evaluates to a boolean.  I assume it works for any expression.", "author": "AlanConfluent", "createdAt": "2020-10-20T23:43:05Z", "path": "docs/developer-guide/ksqldb-reference/quick-reference.md", "diffHunk": "@@ -427,6 +427,23 @@ SELECT user_id\n   EMIT CHANGES;\r\n ```\r\n \r\n+## IN\r\n+Short hand for multiple `OR` conditions.\r\n+\r\n+```sql hl_lines\"3\"\r\n+  SELECT select_expr [., ...]\r\n+    FROM from_stream | from_table\r\n+    WHERE condition IN (exp0, exp1, exp2);\r", "originalCommit": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyNzE2MQ==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r509127161", "bodyText": "good call - cut & paste issue ;)", "author": "big-andy-coates", "createdAt": "2020-10-21T09:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwMzE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwOTg2NA==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508909864", "bodyText": "I assume this catches the case where the pValue is null and rEntry.getValue() isn't.\nIf they are both null, then they would be considered not to match, per the null handler, right?  Is that the intended behavior for a map?", "author": "AlanConfluent", "createdAt": "2020-10-20T23:57:35Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/codegen/helpers/InListEvaluator.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.codegen.helpers;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.math.BigDecimal;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.Struct;\n+\n+/**\n+ * Used in the code generation to evaluate SQL 'IN (a, b, c)' expressions.\n+ *\n+ * <p>For tests, see {@code in.json} QTT test.\n+ *\n+ * @see io.confluent.ksql.execution.expression.tree.InPredicate\n+ */\n+public final class InListEvaluator {\n+\n+  private static final Object NO_MATCH = new Object();\n+\n+  private static final ImmutableList<Handler> HANDLERS = ImmutableList.<Handler>builder()\n+      .add(InListEvaluator::nullsNeverMatch)\n+      .add(handler(List.class, InListEvaluator::arraysMatch))\n+      .add(handler(Map.class, InListEvaluator::mapsMatch))\n+      .add(handler(Struct.class, InListEvaluator::structsMatch))\n+      .add(InListEvaluator::exactMatch)\n+      .add(handler(String.class, Object.class, InListEvaluator::requiredParsedMatches))\n+      .add(handler(Object.class, String.class, InListEvaluator::possibleParsedMatches))\n+      .add(handler(Long.class, Integer.class, InListEvaluator::upCastInt))\n+      .add(handler(Double.class, BigDecimal.class, InListEvaluator::downCastDecimal))\n+      .build();\n+\n+  private static final ImmutableMap<Class<?>, Function<String, ?>> STRING_PARSERS = ImmutableMap\n+      .<Class<?>, Function<String, ?>>builder()\n+      .put(Boolean.class, InListEvaluator::stringToBoolean)\n+      .put(Integer.class, Integer::valueOf)\n+      .put(Long.class, Long::valueOf)\n+      .put(Double.class, Double::valueOf)\n+      .put(BigDecimal.class, BigDecimal::new)\n+      .build();\n+\n+  private InListEvaluator() {\n+  }\n+\n+  /**\n+   * Looks for {@code value} in {@code values}.\n+   *\n+   * <p>SQL NULLs never match.\n+   *\n+   * <p>Conversion from INT to BIGINT is handled.\n+   *\n+   * <p>Conversion from DECIMAL to DOUBLE is handled.\n+   *\n+   * <p>Conversion between STRING and other primitive keys is handled.\n+   *\n+   * <p>Invalid conversions are ignored.\n+   *\n+   * @param value the value to look for\n+   * @param values the values to look in\n+   * @return {@code true} if {@code value} is in {@code values}.\n+   */\n+  public static boolean matches(final Object value, final Object... values) {\n+    if (value == null) {\n+      // SQL NULL never matches anything:\n+      return false;\n+    }\n+\n+    for (final Object v : values) {\n+      if (v == null) {\n+        // SQL NULL never matches anything:\n+        continue;\n+      }\n+\n+      if (isMatch(value, v)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private static boolean isMatch(final Object requiredValue, final Object possibleMatch) {\n+    for (final Handler handler : HANDLERS) {\n+      final Optional<Boolean> result = handler.accept(requiredValue, possibleMatch);\n+      if (result.isPresent()) {\n+        return result.get();\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private static Optional<Boolean> nullsNeverMatch(\n+      final Object requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    if (requiredValue == null || possibleMatch == null) {\n+      // SQL NULL never matches anything:\n+      return Optional.of(false);\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Boolean> exactMatch(\n+      final Object requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    if (requiredValue.equals(possibleMatch)) {\n+      return Optional.of(true);\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Object parseString(\n+      final String value,\n+      final Class<?> requiredType\n+  ) {\n+    final Function<String, ?> parser = STRING_PARSERS.get(requiredType);\n+    if (parser == null) {\n+      return NO_MATCH;\n+    }\n+\n+    try {\n+      return parser.apply(value);\n+    } catch (final NumberFormatException e) {\n+      return NO_MATCH;\n+    }\n+  }\n+\n+  private static boolean requiredParsedMatches(\n+      final String requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    return possibleParsedMatches(possibleMatch, requiredValue);\n+  }\n+\n+  private static boolean possibleParsedMatches(\n+      final Object requiredValue,\n+      final String possibleMatch\n+  ) {\n+    final Object parsed = parseString(possibleMatch, requiredValue.getClass());\n+    return requiredValue.equals(parsed);\n+  }\n+\n+  private static boolean upCastInt(\n+      final Long requiredValue,\n+      final Integer possibleMatch\n+  ) {\n+    return requiredValue.equals(possibleMatch.longValue());\n+  }\n+\n+  private static boolean downCastDecimal(\n+      final Double requiredValue,\n+      final BigDecimal possibleMatch\n+  ) {\n+    final double d = possibleMatch.doubleValue();\n+    if (!new BigDecimal(String.valueOf(d)).equals(possibleMatch)) {\n+      // Lossy conversion:\n+      return false;\n+    }\n+\n+    return requiredValue.equals(d);\n+  }\n+\n+\n+  private static Object stringToBoolean(final String value) {\n+    switch (value.toUpperCase()) {\n+      case \"T\":\n+      case \"TRUE\":\n+        return true;\n+\n+      case \"F\":\n+      case \"FALSE\":\n+        return false;\n+\n+      default:\n+        return NO_MATCH;\n+    }\n+  }\n+\n+  private static boolean arraysMatch(final List<?> requiredValue, final List<?> possibleMatch) {\n+    final Iterator<?> rIt = requiredValue.iterator();\n+    final Iterator<?> pIt = possibleMatch.iterator();\n+\n+    while (rIt.hasNext() && pIt.hasNext()) {\n+      final Object rNext = rIt.next();\n+      final Object pNext = pIt.next();\n+\n+      if (!isMatch(rNext, pNext)) {\n+        return false;\n+      }\n+    }\n+\n+    return !rIt.hasNext() && !pIt.hasNext();\n+  }\n+\n+  private static boolean mapsMatch(final Map<?, ?> requiredValue, final Map<?, ?> possibleMatch) {\n+    if (requiredValue.size() != possibleMatch.size()) {\n+      return false;\n+    }\n+\n+    for (final Entry<?, ?> rEntry : requiredValue.entrySet()) {\n+      final Object pValue = possibleMatch.get(rEntry.getKey());\n+\n+      if (!isMatch(rEntry.getValue(), pValue)) {", "originalCommit": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTExNDE3NQ==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r509114175", "bodyText": "I assume this catches the case where the pValue is null and rEntry.getValue() isn't.\n\nYes it does\n\nIf they are both null, then they would be considered not to match, per the null handler, right?\n\nCorrect\n\nIs that the intended behavior for a map?\n\nYep.", "author": "big-andy-coates", "createdAt": "2020-10-21T09:06:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwOTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxNjgxMg==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508916812", "bodyText": "Is it not possible to have the reverse as well, BigDecimal is required and Double is matched against?  Is that not the case with the integer/long as well?\nIt would be good to do some test that cover these casting cases.", "author": "AlanConfluent", "createdAt": "2020-10-21T00:20:48Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/codegen/helpers/InListEvaluator.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.codegen.helpers;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.math.BigDecimal;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.Struct;\n+\n+/**\n+ * Used in the code generation to evaluate SQL 'IN (a, b, c)' expressions.\n+ *\n+ * <p>For tests, see {@code in.json} QTT test.\n+ *\n+ * @see io.confluent.ksql.execution.expression.tree.InPredicate\n+ */\n+public final class InListEvaluator {\n+\n+  private static final Object NO_MATCH = new Object();\n+\n+  private static final ImmutableList<Handler> HANDLERS = ImmutableList.<Handler>builder()\n+      .add(InListEvaluator::nullsNeverMatch)\n+      .add(handler(List.class, InListEvaluator::arraysMatch))\n+      .add(handler(Map.class, InListEvaluator::mapsMatch))\n+      .add(handler(Struct.class, InListEvaluator::structsMatch))\n+      .add(InListEvaluator::exactMatch)\n+      .add(handler(String.class, Object.class, InListEvaluator::requiredParsedMatches))\n+      .add(handler(Object.class, String.class, InListEvaluator::possibleParsedMatches))\n+      .add(handler(Long.class, Integer.class, InListEvaluator::upCastInt))\n+      .add(handler(Double.class, BigDecimal.class, InListEvaluator::downCastDecimal))\n+      .build();\n+\n+  private static final ImmutableMap<Class<?>, Function<String, ?>> STRING_PARSERS = ImmutableMap\n+      .<Class<?>, Function<String, ?>>builder()\n+      .put(Boolean.class, InListEvaluator::stringToBoolean)\n+      .put(Integer.class, Integer::valueOf)\n+      .put(Long.class, Long::valueOf)\n+      .put(Double.class, Double::valueOf)\n+      .put(BigDecimal.class, BigDecimal::new)\n+      .build();\n+\n+  private InListEvaluator() {\n+  }\n+\n+  /**\n+   * Looks for {@code value} in {@code values}.\n+   *\n+   * <p>SQL NULLs never match.\n+   *\n+   * <p>Conversion from INT to BIGINT is handled.\n+   *\n+   * <p>Conversion from DECIMAL to DOUBLE is handled.\n+   *\n+   * <p>Conversion between STRING and other primitive keys is handled.\n+   *\n+   * <p>Invalid conversions are ignored.\n+   *\n+   * @param value the value to look for\n+   * @param values the values to look in\n+   * @return {@code true} if {@code value} is in {@code values}.\n+   */\n+  public static boolean matches(final Object value, final Object... values) {\n+    if (value == null) {\n+      // SQL NULL never matches anything:\n+      return false;\n+    }\n+\n+    for (final Object v : values) {\n+      if (v == null) {\n+        // SQL NULL never matches anything:\n+        continue;\n+      }\n+\n+      if (isMatch(value, v)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private static boolean isMatch(final Object requiredValue, final Object possibleMatch) {\n+    for (final Handler handler : HANDLERS) {\n+      final Optional<Boolean> result = handler.accept(requiredValue, possibleMatch);\n+      if (result.isPresent()) {\n+        return result.get();\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private static Optional<Boolean> nullsNeverMatch(\n+      final Object requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    if (requiredValue == null || possibleMatch == null) {\n+      // SQL NULL never matches anything:\n+      return Optional.of(false);\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Boolean> exactMatch(\n+      final Object requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    if (requiredValue.equals(possibleMatch)) {\n+      return Optional.of(true);\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Object parseString(\n+      final String value,\n+      final Class<?> requiredType\n+  ) {\n+    final Function<String, ?> parser = STRING_PARSERS.get(requiredType);\n+    if (parser == null) {\n+      return NO_MATCH;\n+    }\n+\n+    try {\n+      return parser.apply(value);\n+    } catch (final NumberFormatException e) {\n+      return NO_MATCH;\n+    }\n+  }\n+\n+  private static boolean requiredParsedMatches(\n+      final String requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    return possibleParsedMatches(possibleMatch, requiredValue);\n+  }\n+\n+  private static boolean possibleParsedMatches(\n+      final Object requiredValue,\n+      final String possibleMatch\n+  ) {\n+    final Object parsed = parseString(possibleMatch, requiredValue.getClass());\n+    return requiredValue.equals(parsed);\n+  }\n+\n+  private static boolean upCastInt(\n+      final Long requiredValue,\n+      final Integer possibleMatch\n+  ) {\n+    return requiredValue.equals(possibleMatch.longValue());\n+  }\n+\n+  private static boolean downCastDecimal(", "originalCommit": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEzODQzNg==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r509138436", "bodyText": "Good catch. On it...", "author": "big-andy-coates", "createdAt": "2020-10-21T09:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxNjgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxODc3Mw==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508918773", "bodyText": "Is it not considered a type error to mix types in the in list?  You would also think that it would be an error if the types weren't comparable.", "author": "AlanConfluent", "createdAt": "2020-10-21T00:27:45Z", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/in.json", "diffHunk": "@@ -0,0 +1,223 @@\n+{\n+  \"tests\": [\n+    {\n+      \"name\": \"expressions\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID INT KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (VAL, VAL * 2);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": 10, \"value\": {\"VAL\": 10}},\n+        {\"topic\": \"input_topic\", \"key\": 12, \"value\": {\"VAL\": 20}},\n+        {\"topic\": \"input_topic\", \"key\": 11, \"value\": {\"VAL\": 110}},\n+        {\"topic\": \"input_topic\", \"key\": 38, \"value\": {\"VAL\": 19}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": 10}},\n+        {\"topic\": \"OUTPUT\", \"key\": 38, \"value\": {\"VAL\": 19}}\n+      ]\n+    },\n+    {\n+      \"name\": \"nulls\",\n+      \"comment\": \"Null is not equivalent to null, i.e. it never matches\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID INT KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (11,NULL,VAL);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": {\"VAL\":10}},\n+        {\"topic\": \"input_topic\", \"key\": null, \"value\": {\"VAL\":null}},\n+        {\"topic\": \"input_topic\", \"key\": 11, \"value\": {\"VAL\":10}},\n+        {\"topic\": \"input_topic\", \"key\": 19, \"value\": {\"VAL\":10}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 11, \"value\": {\"VAL\": 10}}\n+      ]\n+    },\n+    {\n+      \"name\": \"inverted\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID INT KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID NOT IN (11,20,10);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": 10, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 12, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 11, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 19, \"value\": {}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 12, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 19, \"value\": {\"VAL\": null}}\n+      ]\n+    },\n+    {\n+      \"name\": \"boolean\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID BOOLEAN KEY, VAL BOOLEAN, VAL2 STRING) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (true, 'Not a boolean', 10) OR VAL IN ('TruE', ARRAY[1]) OR VAL2 IN (true);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": true, \"value\": {\"VAL\": false}},\n+        {\"topic\": \"input_topic\", \"key\": false, \"value\": {\"VAL\": true}},\n+        {\"topic\": \"input_topic\", \"key\": false, \"value\": {\"VAL\": false}},\n+        {\"topic\": \"input_topic\", \"key\": false, \"value\": {\"VAL2\": \"true\"}},\n+        {\"topic\": \"input_topic\", \"key\": false, \"value\": {\"VAL2\": \"t\"}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": true, \"value\": {\"VAL\": false, \"VAL2\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"VAL\": true, \"VAL2\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"VAL\": null, \"VAL2\": \"true\"}},\n+        {\"topic\": \"OUTPUT\", \"key\": false, \"value\": {\"VAL\": null, \"VAL2\": \"t\"}}\n+      ]\n+    },\n+    {\n+      \"name\": \"int\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID INT KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (11,20,10,'not a number',false,12.0, ARRAY[1]);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": 10, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 12, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 11, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 19, \"value\": {}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 11, \"value\": {\"VAL\": null}}\n+      ]\n+    },\n+    {\n+      \"name\": \"bigint\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID BIGINT KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (123456789123456789,20,10,'not a number',false,12.0, ARRAY[1]);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": 10, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 12, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 123456789123456789, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 19, \"value\": {}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 123456789123456789, \"value\": {\"VAL\": null}}\n+      ]\n+    },\n+    {\n+      \"name\": \"double\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID DOUBLE KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (10, 10.1, '10.2', 10.30, '10.40', 'not a number', false, ARRAY[1]);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": 10.0, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 10.1, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 10.2, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 10.3, \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": 10.4, \"value\": {}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 10.1, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 10.2, \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": 10.4, \"value\": {\"VAL\": null}}\n+      ]\n+    },\n+    {\n+      \"name\": \"string\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID STRING KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN ('k', 10, '10.1', 10.30, 'not a match', false, ARRAY[1]);\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"input_topic\", \"key\": \"k\", \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": \"no\", \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": \"10\", \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": \"10.0\", \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": \"10.1\", \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": \"10.10\", \"value\": {}},\n+        {\"topic\": \"input_topic\", \"key\": \"false\", \"value\": {}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": \"k\", \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": \"10\", \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": \"10.1\", \"value\": {\"VAL\": null}},\n+        {\"topic\": \"OUTPUT\", \"key\": \"false\", \"value\": {\"VAL\": null}}\n+      ]\n+    },\n+    {\n+      \"name\": \"decimal\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (ID DECIMAL(4,2) KEY, VAL INT) WITH (kafka_topic='input_topic', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT * FROM INPUT WHERE ID IN (10, 10.0, 10.10, 10.201, '10.30', '10.4', '10.400', 'not a match', false, ARRAY[1]);\"", "originalCommit": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyMzM4Ng==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r509123386", "bodyText": "It's ... complicated.\nA standard SQL engine might accept something like ID IN ('10', 12, 11.9901, '76.887') where ID is any numeric or string type, ass its coercing the types, but it might reject something like ID IN ('10', 12, 11.9901, 'not a number') if ID is a numeric type, but not if its a string type.\nLikewise, a standard SQL engine might convert 'TRUE', 'true', 't' to true, etc.\nSo it should be possible to do textCol IN (10, true, 'hello'), as textCol could contain '10', 'true' or 'hello'.\nAnd of course, the list may contain expressions as well we literals. If ID is a numeric type, and one of the expressions is a STRING, then the content of that string may or may not be a number.  So while I could of added code to detect string literals that can't be converted to the required type, and fail, given we can't do the same for non-literal expressions... I took the easy way out! I was just trying to 'rattle an initial implementation off'.\nWe could also look at the expression type and all the types in the IN element list and fail if they can never be compatible. e.g. ID IN (true, false) where ID is neither a string or a boolean.  But again, this is more work, though maybe better UX.\nGeneral driver was to not be too strict. I'd rather let some things through that will never match, than not let some things through that could match.\nWhat say you??", "author": "big-andy-coates", "createdAt": "2020-10-21T09:19:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxODc3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ1NjE5Mw==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r509456193", "bodyText": "It is a bit complicated.\nI agree that special-casing literals to catch certain type error cases that you could not catch up front with with general expressions doesn't seem like a high value change to make. That's why relying on strict types would be nice because you know that at analysis time and are ensured that whatever evaluated expressions you see during execution must conform to expected types.  But, if a standard SQL engine does a lot of this coercion, then I agree people may expect it.\nI'd always lean towards being stricter and avoiding coercions, but if that's not an option, then what you have seems like a reasonable tradeoff.", "author": "AlanConfluent", "createdAt": "2020-10-21T17:07:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxODc3Mw=="}], "type": "inlineReview"}, {"oid": "39dc8304255420b9a673d16f0d21b6e5e3ba4985", "url": "https://github.com/confluentinc/ksql/commit/39dc8304255420b9a673d16f0d21b6e5e3ba4985", "message": "Update docs/developer-guide/ksqldb-reference/operators.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>", "committedDate": "2020-10-21T09:04:53Z", "type": "commit"}, {"oid": "3079b3eb16d1b8b82729191ca72a2af902aff26f", "url": "https://github.com/confluentinc/ksql/commit/3079b3eb16d1b8b82729191ca72a2af902aff26f", "message": "Update docs/developer-guide/ksqldb-reference/operators.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>", "committedDate": "2020-10-21T09:05:01Z", "type": "commit"}, {"oid": "4dfc6c6c9776aad5b48ecedc8979cb534943871e", "url": "https://github.com/confluentinc/ksql/commit/4dfc6c6c9776aad5b48ecedc8979cb534943871e", "message": "Update docs/developer-guide/ksqldb-reference/quick-reference.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>", "committedDate": "2020-10-21T09:05:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY3MjIwNg==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r513672206", "bodyText": "I just noticed that IN is already mentioned above.", "author": "AlanConfluent", "createdAt": "2020-10-28T18:29:28Z", "path": "docs/reference/sql/appendix.md", "diffHunk": "@@ -58,6 +58,7 @@ The following table shows all keywords in the language.\n | `INTERVAL`     | number of messages to skip in `PRINT` | `PRINT <topic-name> INTERVAL 5;`                                     |\n | `INTO`         | stream/table to insert values         | `INSERT INTO stream_name ...`                                        |\n | `IS`           |                                       |                                                                      |\n+| `IN`           | in operator                           | `SELECT * FROM S WHERE ID IN (1, 2, 9, 24);`                         |", "originalCommit": "4dfc6c6c9776aad5b48ecedc8979cb534943871e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "af4c611e612b82321a019dffe56171b2036f6aea", "url": "https://github.com/confluentinc/ksql/commit/af4c611e612b82321a019dffe56171b2036f6aea", "message": "chore: merge from master", "committedDate": "2020-11-02T17:12:49Z", "type": "commit"}, {"oid": "b4d653ebba0ccb96724b17b03b814d4e5cd0555c", "url": "https://github.com/confluentinc/ksql/commit/b4d653ebba0ccb96724b17b03b814d4e5cd0555c", "message": "Merge branch 'master' into in_exp", "committedDate": "2020-11-03T14:01:12Z", "type": "commit"}, {"oid": "6bf6b0c2096eedd37cb8ac58dd1c65a68282def4", "url": "https://github.com/confluentinc/ksql/commit/6bf6b0c2096eedd37cb8ac58dd1c65a68282def4", "message": "chore: merge from master", "committedDate": "2020-11-11T09:34:11Z", "type": "commit"}, {"oid": "230e5c47ba2605a7ca92ead31c16279aad73ccec", "url": "https://github.com/confluentinc/ksql/commit/230e5c47ba2605a7ca92ead31c16279aad73ccec", "message": "chore: revert unnecessary", "committedDate": "2020-11-11T09:37:59Z", "type": "commit"}, {"oid": "e5a48210c94a7c4e8692d42648f3543e3efbc44c", "url": "https://github.com/confluentinc/ksql/commit/e5a48210c94a7c4e8692d42648f3543e3efbc44c", "message": "chore: refactor", "committedDate": "2020-11-13T20:14:03Z", "type": "commit"}]}