{"pr_number": 6504, "pr_title": "feat: support variable substitution in SQL statements", "pr_createdAt": "2020-10-22T21:37:21Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6504", "timeline": [{"oid": "9d64a3d41eb6fe31cf38728cfdc7297be8f4d0e5", "url": "https://github.com/confluentinc/ksql/commit/9d64a3d41eb6fe31cf38728cfdc7297be8f4d0e5", "message": "chore: suppress warnings in tests", "committedDate": "2020-10-23T14:28:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1NTQ3Nw==", "url": "https://github.com/confluentinc/ksql/pull/6504#discussion_r512255477", "bodyText": "The text is a bit confusing. You mean: \"Identifier names cannot start with '@' and may only contain alphanumeric values and '_'. \"", "author": "vpapavas", "createdAt": "2020-10-26T20:42:53Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/VariableSubstitutor.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.parser;\n+\n+import static io.confluent.ksql.util.ParserUtil.getLocation;\n+import static io.confluent.ksql.util.ParserUtil.isQuoted;\n+import static io.confluent.ksql.util.ParserUtil.sanitize;\n+import static io.confluent.ksql.util.ParserUtil.unquote;\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import java.math.BigDecimal;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.commons.text.StringSubstitutor;\n+\n+public final class VariableSubstitutor {\n+  private VariableSubstitutor() {\n+  }\n+\n+  private static final Pattern VALID_IDENTIFIER_NAMES = Pattern.compile(\"[A-Za-z_][A-Za-z0-9_@]*\");\n+  public static final String PREFIX = \"${\";\n+  public static final String SUFFIX = \"}\";\n+\n+  static class VariablesLookup {\n+    public static Set<String> lookup(final String text) {\n+      final Set<String> variables = new HashSet<>();\n+\n+      // Used only to lookup for variables\n+      final StringSubstitutor substr = new StringSubstitutor(key -> {\n+        variables.add(key);\n+        return null;\n+      });\n+\n+      substr.setVariablePrefix(PREFIX);\n+      substr.setVariableSuffix(SUFFIX);\n+      substr.replace(text); // Nothing is replaced. It just lookups for variables.\n+\n+      return variables;\n+    }\n+  }\n+\n+  public static String substitute(\n+      final KsqlParser.ParsedStatement parsedStatement,\n+      final Map<String, String> valueMap\n+  ) {\n+    final String statementText = parsedStatement.getStatementText();\n+    final SqlSubstitutorVisitor visitor = new SqlSubstitutorVisitor(statementText, valueMap);\n+    return visitor.replace(parsedStatement.getStatement());\n+  }\n+\n+  // CHECKSTYLE_RULES.OFF: ClassDataAbstractionCoupling\n+  private static final class SqlSubstitutorVisitor extends SqlBaseBaseVisitor<Void> {\n+    // CHECKSTYLE_RULES.ON: ClassDataAbstractionCoupling\n+\n+    private final String statementText;\n+    private final Map<String, String> valueMap;\n+\n+    // Contains sanitized values for variable substitution\n+    private Map<String, String> sanitizedValueMap;\n+\n+    SqlSubstitutorVisitor(final String statementText, final Map<String, String> valueMap) {\n+      this.statementText = requireNonNull(statementText, \"statementText\");\n+      this.valueMap = requireNonNull(valueMap, \"valueMap\");\n+      this.sanitizedValueMap = new HashMap<>(valueMap.size());\n+    }\n+\n+    public String replace(final SqlBaseParser.SingleStatementContext singleStatementContext) {\n+      // walk the statement tree to validate and sanitize variables\n+      visit(singleStatementContext);\n+\n+      // replace all variables with sanitized values\n+      return StringSubstitutor.replace(statementText, sanitizedValueMap);\n+    }\n+\n+    @Override\n+    public Void visitStringLiteral(final SqlBaseParser.StringLiteralContext context) {\n+      final String text = unquote(context.getText(), \"\\'\");\n+      for (String variableName : VariablesLookup.lookup(text)) {\n+        if (valueMap.containsKey(variableName)) {\n+          sanitizedValueMap.putIfAbsent(variableName, sanitize(valueMap.get(variableName)));\n+        }\n+      }\n+\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitVariableLiteral(final SqlBaseParser.VariableLiteralContext context) {\n+      final String variableRef = context.getText();\n+      final String variableName = unwrap(variableRef);\n+      final String variableValue = valueMap.getOrDefault(variableName, variableRef);\n+\n+      throwIfInvalidLiteral(variableValue, getLocation(context));\n+      sanitizedValueMap.putIfAbsent(variableName, sanitize(variableValue));\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitVariableIdentifier(final SqlBaseParser.VariableIdentifierContext context) {\n+      final String variableRef = context.getText();\n+      final String variableName = unwrap(variableRef);\n+      final String variableValue = valueMap.getOrDefault(variableName, variableRef);\n+\n+      throwIfInvalidIdentifier(variableValue, getLocation(context));\n+      sanitizedValueMap.putIfAbsent(variableName, variableValue);\n+      return null;\n+    }\n+\n+    private String getIdentifierText(final String value) {\n+      final char firstChar = value.charAt(0);\n+      final char lastChar = value.charAt(value.length() - 1);\n+\n+      if (firstChar == '\"' && lastChar == '\"') {\n+        return unquote(value, \"\\\"\");\n+      } else if (firstChar == '`' && lastChar == '`') {\n+        return unquote(value, \"`\");\n+      } else {\n+        return value;\n+      }\n+    }\n+\n+    static String unwrap(final String value) {\n+      return value.substring(PREFIX.length(), value.length() - SUFFIX.length());\n+    }\n+\n+    private void throwIfInvalidIdentifier(\n+        final String value,\n+        final Optional<NodeLocation> location\n+    ) {\n+      final String identifierText = getIdentifierText(value);\n+\n+      if (!VALID_IDENTIFIER_NAMES.matcher(identifierText).matches()) {\n+        throw new ParseFailedException(\n+            \"Illegal argument at \" + location.map(NodeLocation::toString).orElse(\"?\")\n+                + \". Identifier names may only contain alphanumeric values, '_' \"\n+                + \"or not starting with '@'. Got: '\" + value + \"'\",", "originalCommit": "87ae8139fd5be5696e545d42cfa4f69fedeee40b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NTY2Mw==", "url": "https://github.com/confluentinc/ksql/pull/6504#discussion_r512275663", "bodyText": "Thanks. That sounds much better.\nDone", "author": "spena", "createdAt": "2020-10-26T21:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1NTQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1Njc1OA==", "url": "https://github.com/confluentinc/ksql/pull/6504#discussion_r512256758", "bodyText": "This works (identifying sql injection) because variable names must not contain spaces, etc? Basically, only alphanumeric and '_'?", "author": "vpapavas", "createdAt": "2020-10-26T20:45:12Z", "path": "ksqldb-parser/src/test/java/io/confluent/ksql/parser/VariableSubstitutorTest.java", "diffHunk": "@@ -0,0 +1,221 @@\n+package io.confluent.ksql.parser;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.Assert.assertThrows;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.util.Pair;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class VariableSubstitutorTest {\n+  private static final KsqlParser KSQL_PARSER = new DefaultKsqlParser();\n+\n+  @Test\n+  public void shouldSubstituteVariableOnDescribe() {\n+    // Given\n+    final Map<String, String> variablesMap = new ImmutableMap.Builder<String, String>() {{\n+      put(\"identifier\", \"_id_\");\n+      put(\"quotedIdentifier\", \"\\\"_id_\\\"\");\n+      put(\"backQuotedIdentifier\", \"`_id_`\");\n+    }}.build();\n+\n+    final List<Pair<String, String>> statements = Arrays.asList(\n+        // DESCRIBE\n+        Pair.of(\"DESCRIBE ${identifier};\", \"DESCRIBE _id_;\"),\n+        Pair.of(\"DESCRIBE ${quotedIdentifier};\", \"DESCRIBE \\\"_id_\\\";\"),\n+        Pair.of(\"DESCRIBE ${backQuotedIdentifier};\", \"DESCRIBE `_id_`;\"),\n+\n+        // DESCRIBE EXTENDED\n+        Pair.of(\"DESCRIBE EXTENDED ${identifier};\", \"DESCRIBE EXTENDED _id_;\"),\n+        Pair.of(\"DESCRIBE EXTENDED ${quotedIdentifier};\", \"DESCRIBE EXTENDED \\\"_id_\\\";\"),\n+        Pair.of(\"DESCRIBE EXTENDED ${backQuotedIdentifier};\", \"DESCRIBE EXTENDED `_id_`;\"),\n+\n+        // DESCRIBE FUNCTION\n+        Pair.of(\"DESCRIBE FUNCTION ${identifier};\", \"DESCRIBE FUNCTION _id_;\"),\n+        Pair.of(\"DESCRIBE FUNCTION ${quotedIdentifier};\", \"DESCRIBE FUNCTION \\\"_id_\\\";\"),\n+        Pair.of(\"DESCRIBE FUNCTION ${backQuotedIdentifier};\", \"DESCRIBE FUNCTION `_id_`;\"),\n+\n+        // DESCRIBE CONNECTOR\n+        Pair.of(\"DESCRIBE CONNECTOR ${identifier};\", \"DESCRIBE CONNECTOR _id_;\"),\n+        Pair.of(\"DESCRIBE CONNECTOR ${quotedIdentifier};\", \"DESCRIBE CONNECTOR \\\"_id_\\\";\"),\n+        Pair.of(\"DESCRIBE CONNECTOR ${backQuotedIdentifier};\", \"DESCRIBE CONNECTOR `_id_`;\")\n+    );\n+\n+    // When/Then\n+    assertReplacedStatements(statements, variablesMap);\n+  }\n+\n+  @Test\n+  public void shouldThrowOnDescribeWhenInvalidVariables() {\n+    // Given\n+    final Map<String, String> variablesMap = new ImmutableMap.Builder<String, String>() {{\n+      // Attempts to use a keyword\n+      put(\"identifier\", \"EXTENDED _id_\");\n+      put(\"quotedIdentifier\", \"EXTENDED \\\"_id_\\\"\");\n+      put(\"backQuotedIdentifier\", \"EXTENDED `_id_`\");\n+      put(\"singleQuoteIdentifier\", \"EXTENDED '_id_'\");\n+\n+      // Attempts to use a keyword inside quotes\n+      put(\"quotedIdentifier2\", \"\\\"EXTENDED _id_\\\"\");\n+      put(\"backQuotedIdentifier2\", \"`EXTENDED _id_`\");\n+      put(\"singleQuoteIdentifier2\", \"'EXTENDED _id_'\");\n+    }}.build();\n+\n+    final List<Pair<String, String>> statements = Arrays.asList(\n+        // DESCRIBE\n+        Pair.of(\"DESCRIBE ${identifier};\", \"Got: 'EXTENDED _id_'\"),\n+        Pair.of(\"DESCRIBE ${quotedIdentifier};\", \"Got: 'EXTENDED \\\"_id_\\\"'\"),\n+        Pair.of(\"DESCRIBE ${backQuotedIdentifier};\", \"Got: 'EXTENDED `_id_`'\"),\n+        Pair.of(\"DESCRIBE ${singleQuoteIdentifier};\", \"Got: 'EXTENDED '_id_''\"),\n+        Pair.of(\"DESCRIBE ${quotedIdentifier2};\", \"Got: '\\\"EXTENDED _id_\\\"'\"),\n+        Pair.of(\"DESCRIBE ${backQuotedIdentifier2};\", \"Got: '`EXTENDED _id_`'\"),\n+        Pair.of(\"DESCRIBE ${singleQuoteIdentifier2};\", \"Got: ''EXTENDED _id_''\")\n+    );\n+\n+    assertThrowOnInvalidVariables(statements, variablesMap);\n+  }\n+\n+  @Test\n+  public void shouldSubstituteVariableOnInsert() {\n+    // Given\n+    final Map<String, String> variablesMap = new ImmutableMap.Builder<String, String>() {{\n+      put(\"identifier\", \"_id_\");\n+      put(\"num\", \"1\");\n+      put(\"dec\", \"0.32\");\n+      put(\"bool\", \"false\");\n+      put(\"str\", \"'john'\");\n+    }}.build();\n+\n+    final List<Pair<String, String>> statements = Arrays.asList(\n+        // INSERT VALUES\n+        Pair.of(\"INSERT INTO ${identifier} VALUES (${num}, ${bool}, ${dec}, ${str});\",\n+            \"INSERT INTO _id_ VALUES (1, false, 0.32, 'john');\")\n+    );\n+\n+    // When/Then\n+    assertReplacedStatements(statements, variablesMap);\n+  }\n+\n+  @Test\n+  public void shouldSubstituteVariableOnCreate() {\n+    // Given\n+    final Map<String, String> variablesMap = new ImmutableMap.Builder<String, String>() {{\n+      put(\"identifier\", \"_id_\");\n+      put(\"quotedIdentifier\", \"\\\"_id_\\\"\");\n+      put(\"backQuotedIdentifier\", \"`_id_`\");\n+      put(\"topicName\", \"'name1'\");\n+      put(\"replicas\", \"3\");\n+    }}.build();\n+\n+    final List<Pair<String, String>> statements = Arrays.asList(\n+        // CREATE STREAM\n+        Pair.of(\"CREATE STREAM ${identifier} WITH (kafka_topic=${topicName}, replicas=${replicas});\",\n+            \"CREATE STREAM _id_ WITH (kafka_topic='name1', replicas=3);\"),\n+\n+        Pair.of(\"CREATE STREAM ${quotedIdentifier} WITH (kafka_topic=${topicName}, replicas=${replicas});\",\n+            \"CREATE STREAM \\\"_id_\\\" WITH (kafka_topic='name1', replicas=3);\"),\n+\n+        Pair.of(\"CREATE STREAM ${backQuotedIdentifier} WITH (kafka_topic=${topicName}, replicas=${replicas});\",\n+            \"CREATE STREAM `_id_` WITH (kafka_topic='name1', replicas=3);\"),\n+\n+        Pair.of(\"CREATE STREAM ${backQuotedIdentifier} WITH (kafka_topic=${topicName}, replicas=${replicas});\",\n+            \"CREATE STREAM `_id_` WITH (kafka_topic='name1', replicas=3);\")\n+    );\n+\n+    // When/Then\n+    assertReplacedStatements(statements, variablesMap);\n+  }\n+\n+  @Test\n+  public void shouldSanitizeStatements() {\n+    // Given\n+    final Map<String, String> variablesMap = new ImmutableMap.Builder<String, String>() {{\n+      put(\"escapeQuote\", \"'t1', value_format='AVRO'\");\n+    }}.build();\n+\n+    final List<Pair<String, String>> statements = Arrays.asList(\n+        // CREATE\n+        Pair.of(\"CREATE STREAM s1 WITH (kafka_topic=${escapeQuote});\",\n+            \"CREATE STREAM s1 WITH (kafka_topic='t1'', value_format=''AVRO');\")\n+    );\n+\n+    // When/Then\n+    assertReplacedStatements(statements, variablesMap);\n+  }\n+\n+  @Test\n+  public void shouldThrowOnSQLInjection() {", "originalCommit": "87ae8139fd5be5696e545d42cfa4f69fedeee40b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTQ2Mw==", "url": "https://github.com/confluentinc/ksql/pull/6504#discussion_r512281463", "bodyText": "Variable names do not contain spaces, but values can. However, it all depends on how to reference the values in the statement. All values must be enclosed into single-quotes, but single-quotes are not part of the value in the statement.\nFor instance:\n// This should throw an error because ${id} has spaces.\nksql> define id = '5 and id != 5';\nksql> SELECT * FROM s1 WHERE id = ${id};\n\n// This is a valid statement. The query will print | 5 and id != 5 | in column 1 because it is referenced inside the single-quotes, which defines the column as String.\nksql> define id = '5 and id != 5';\nksql> SELECT '${id}' FROM ...", "author": "spena", "createdAt": "2020-10-26T21:32:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1Njc1OA=="}], "type": "inlineReview"}, {"oid": "2b47ee3ad2d08e59aa815cae352cb6a6c05f63e2", "url": "https://github.com/confluentinc/ksql/commit/2b47ee3ad2d08e59aa815cae352cb6a6c05f63e2", "message": "feat: substitute variables in SQL statements", "committedDate": "2020-10-26T21:19:57Z", "type": "commit"}, {"oid": "6616f11e767c95106cc10663bade3eaa11f45ef0", "url": "https://github.com/confluentinc/ksql/commit/6616f11e767c95106cc10663bade3eaa11f45ef0", "message": "feat: add config to enable/disable variable substitution", "committedDate": "2020-10-26T21:19:57Z", "type": "commit"}, {"oid": "2a8274d698a9dd8e6ef938024a4dcc9c093e7519", "url": "https://github.com/confluentinc/ksql/commit/2a8274d698a9dd8e6ef938024a4dcc9c093e7519", "message": "chore: suppress warnings in tests", "committedDate": "2020-10-26T21:19:57Z", "type": "commit"}, {"oid": "739bf262663f15c1d611f1604c99c0d1a032da29", "url": "https://github.com/confluentinc/ksql/commit/739bf262663f15c1d611f1604c99c0d1a032da29", "message": "chore: apply Vicky's feedback", "committedDate": "2020-10-26T21:19:57Z", "type": "commit"}, {"oid": "739bf262663f15c1d611f1604c99c0d1a032da29", "url": "https://github.com/confluentinc/ksql/commit/739bf262663f15c1d611f1604c99c0d1a032da29", "message": "chore: apply Vicky's feedback", "committedDate": "2020-10-26T21:19:57Z", "type": "forcePushed"}]}