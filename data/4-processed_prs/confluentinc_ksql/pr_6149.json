{"pr_number": 6149, "pr_title": "feat: Support Comparisons on complex types", "pr_createdAt": "2020-09-03T11:13:55Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6149", "timeline": [{"oid": "5fc9c11851106ba7ffb2c6d56951777e9180b4dd", "url": "https://github.com/confluentinc/ksql/commit/5fc9c11851106ba7ffb2c6d56951777e9180b4dd", "message": "feat: Support Comparisons on complex types", "committedDate": "2020-09-03T11:12:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzE2Mg==", "url": "https://github.com/confluentinc/ksql/pull/6149#discussion_r486723162", "bodyText": "is there any reason to convert to an array? I believe we could just use List#equals", "author": "agavra", "createdAt": "2020-09-11T01:38:32Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/codegen/SqlToJavaVisitor.java", "diffHunk": "@@ -478,6 +478,42 @@ private String visitStringComparisonExpression(final ComparisonExpression.Type t\n       }\n     }\n \n+    private String visitArrayComparisonExpression(final ComparisonExpression.Type type) {\n+      switch (type) {\n+        case EQUAL:\n+          return \"java.util.Arrays.deepEquals(%1$s.toArray(), %2$s.toArray())\";", "originalCommit": "5fc9c11851106ba7ffb2c6d56951777e9180b4dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk1NjUzMQ==", "url": "https://github.com/confluentinc/ksql/pull/6149#discussion_r486956531", "bodyText": "+1", "author": "big-andy-coates", "createdAt": "2020-09-11T10:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzY5Mg==", "url": "https://github.com/confluentinc/ksql/pull/6149#discussion_r486723692", "bodyText": "can you add tests for nested data types? I'm not entirely sure what happens in that case (e.g. an array of structs, or a struct with a nested struct/array)", "author": "agavra", "createdAt": "2020-09-11T01:40:25Z", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/binary-comparison.json", "diffHunk": "@@ -182,37 +181,53 @@\n       ]\n     },\n     {\n-      \"name\": \"comparison array fails\",\n+      \"name\": \"array comparison\",", "originalCommit": "5fc9c11851106ba7ffb2c6d56951777e9180b4dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2MDcxMw==", "url": "https://github.com/confluentinc/ksql/pull/6149#discussion_r486960713", "bodyText": "Likewise, add similar style tests covering IS DISTINCT FROM and IS NOT DISTINCT FROM.\nSee https://modern-sql.com/feature/is-distinct-from for how they should work with nulls.", "author": "big-andy-coates", "createdAt": "2020-09-11T10:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk1ODczMg==", "url": "https://github.com/confluentinc/ksql/pull/6149#discussion_r486958732", "bodyText": "These all need to handle Type.IS_DISTINCT_FROM as well.\nThis also suggests you're missing QTT test cases covering IS NOT DISTINCT FROM and IS DISTINCT FROM for these three complex types.", "author": "big-andy-coates", "createdAt": "2020-09-11T10:32:57Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ComparisonUtil.java", "diffHunk": "@@ -81,6 +84,21 @@ private static boolean handleBoolean(final Type operator, final SqlType right) {\n         && (operator == Type.EQUAL || operator == Type.NOT_EQUAL);\n   }\n \n+  private static boolean handleArray(final Type operator, final SqlType right) {\n+    return right.baseType() == SqlBaseType.ARRAY\n+        && (operator == Type.EQUAL || operator == Type.NOT_EQUAL);\n+  }\n+\n+  private static boolean handleMap(final Type operator, final SqlType right) {\n+    return right.baseType() == SqlBaseType.MAP\n+        && (operator == Type.EQUAL || operator == Type.NOT_EQUAL);\n+  }\n+\n+  private static boolean handleStruct(final Type operator, final SqlType right) {\n+    return right.baseType() == SqlBaseType.STRUCT\n+        && (operator == Type.EQUAL || operator == Type.NOT_EQUAL);\n+  }", "originalCommit": "5fc9c11851106ba7ffb2c6d56951777e9180b4dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "208c481a3b936185c418f720da336efc19cf21c4", "url": "https://github.com/confluentinc/ksql/commit/208c481a3b936185c418f720da336efc19cf21c4", "message": "feat: Support Comparisons on complex types 2", "committedDate": "2020-09-16T13:41:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkyMTE1OA==", "url": "https://github.com/confluentinc/ksql/pull/6149#discussion_r493921158", "bodyText": "nit: can we put all of these into a method so that we can repeat it below? (e.g. isEqualityOperator(operator)) if we do that we might even be able to dismiss the checkstyle suppressions", "author": "agavra", "createdAt": "2020-09-23T22:03:24Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ComparisonUtil.java", "diffHunk": "@@ -76,9 +79,32 @@ private static boolean handleString(final Type operator, final SqlType right) {\n     return right.baseType() == SqlBaseType.STRING;\n   }\n \n+  @SuppressWarnings({\"checkstyle:BooleanExpressionComplexity\", \"checkstyle:LineLength\"})\n   private static boolean handleBoolean(final Type operator, final SqlType right) {\n     return right.baseType() == SqlBaseType.BOOLEAN\n-        && (operator == Type.EQUAL || operator == Type.NOT_EQUAL);\n+        && (operator == Type.EQUAL || operator == Type.NOT_EQUAL\n+            || operator == Type.IS_DISTINCT_FROM || operator == Type.IS_NOT_DISTINCT_FROM);", "originalCommit": "208c481a3b936185c418f720da336efc19cf21c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NDIxNA==", "url": "https://github.com/confluentinc/ksql/pull/6149#discussion_r495884214", "bodyText": "Refactored", "author": "uurl", "createdAt": "2020-09-28T11:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkyMTE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkyMjExMg==", "url": "https://github.com/confluentinc/ksql/pull/6149#discussion_r493922112", "bodyText": "we should still check that comparisons fail that should fail (e.g. > and <)", "author": "agavra", "createdAt": "2020-09-23T22:05:43Z", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/binary-comparison.json", "diffHunk": "@@ -182,37 +197,83 @@\n       ]\n     },\n     {\n-      \"name\": \"comparison array fails\",\n+      \"name\": \"is not distinct from (2)\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (A INT KEY, B BOOLEAN, C BIGINT, D DOUBLE, E DECIMAL(4,3), F STRING, G ARRAY<INT>, H MAP<STRING, INT>, I STRUCT<ID INT>) WITH (kafka_topic='test_topic', value_format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS SELECT A, A IS NOT DISTINCT FROM 1, B IS NOT DISTINCT FROM true, C IS NOT DISTINCT FROM 11, D IS NOT DISTINCT FROM 1.1, E IS NOT DISTINCT FROM 1.20, F IS NOT DISTINCT FROM 'foo', G IS NOT DISTINCT FROM ARRAY[1,2], H IS NOT DISTINCT FROM MAP('a':=1), I IS NOT DISTINCT FROM STRUCT(ID:=2) FROM INPUT;\"\n+      ],\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"B\": true, \"C\": 11, \"D\": 1.1, \"E\": 1.20, \"F\": \"foo\", \"G\": [1,2], \"H\": {\"a\":  1}, \"I\": {\"id\": 2}}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"B\": false, \"C\": 10, \"D\": 1.0, \"E\": 1.21, \"F\": \"Foo\", \"G\": [1], \"H\": {\"b\":  1}, \"I\": {\"id\": 3}}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 1, \"value\": {\"KSQL_COL_0\": true, \"KSQL_COL_1\": true, \"KSQL_COL_2\": true, \"KSQL_COL_3\": true, \"KSQL_COL_4\": true, \"KSQL_COL_5\": true, \"KSQL_COL_6\": true, \"KSQL_COL_7\": true, \"KSQL_COL_8\": true}},\n+        {\"topic\": \"OUTPUT\", \"key\": 2, \"value\": {\"KSQL_COL_0\": false, \"KSQL_COL_1\": false, \"KSQL_COL_2\": false, \"KSQL_COL_3\": false, \"KSQL_COL_4\": false, \"KSQL_COL_5\": false, \"KSQL_COL_6\": false, \"KSQL_COL_7\": false, \"KSQL_COL_8\": false}}\n+      ]\n+    },\n+    {\n+      \"name\": \"array comparison\",\n       \"statements\": [\n         \"CREATE STREAM INPUT (A INT KEY, B ARRAY<INT>, C ARRAY<INT>) WITH (kafka_topic='test_topic', value_format='JSON');\",\n-        \"CREATE STREAM OUTPUT AS SELECT A, B = C FROM INPUT;\"\n+        \"CREATE STREAM OUTPUT AS SELECT A, B = C, B <> C, B IS NOT DISTINCT FROM C, B IS DISTINCT FROM C FROM INPUT;\"\n       ],\n-      \"expectedException\": {\n-        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n-        \"message\": \"Cannot compare B (ARRAY<INTEGER>) to C (ARRAY<INTEGER>) with EQUAL.\"\n-      }\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"B\": [1,2], \"C\": [1,2.0]}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"B\": [1,2], \"C\": [1]}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 1, \"value\": {\"KSQL_COL_0\": true, \"KSQL_COL_1\": false, \"KSQL_COL_2\": true, \"KSQL_COL_3\": false}},\n+        {\"topic\": \"OUTPUT\", \"key\": 2, \"value\": {\"KSQL_COL_0\": false, \"KSQL_COL_1\": true, \"KSQL_COL_2\": false, \"KSQL_COL_3\": true}}\n+      ]\n     },\n     {\n-      \"name\": \"comparison map fails\",\n+      \"name\": \"map comparison\",\n       \"statements\": [\n         \"CREATE STREAM INPUT (A INT KEY, B MAP<STRING, INT>, C MAP<STRING, INT>) WITH (kafka_topic='test_topic', value_format='JSON');\",\n-        \"CREATE STREAM OUTPUT AS SELECT A, B = C FROM INPUT;\"\n+        \"CREATE STREAM OUTPUT AS SELECT A, B = C, B <> C, B IS NOT DISTINCT FROM C, B IS DISTINCT FROM C FROM INPUT;\"\n       ],\n-      \"expectedException\": {\n-        \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n-        \"message\": \"Cannot compare B (MAP<STRING, INTEGER>) to C (MAP<STRING, INTEGER>) with EQUAL.\"\n-      }\n+      \"inputs\": [\n+        {\"topic\": \"test_topic\", \"key\": 1, \"value\": {\"B\": {\"a\": 1}, \"C\": {\"a\": 1.0}}},\n+        {\"topic\": \"test_topic\", \"key\": 2, \"value\": {\"B\": {\"a\": 1}, \"C\": {\"a\": 2}}},\n+        {\"topic\": \"test_topic\", \"key\": 3, \"value\": {\"B\": {\"a\": 1}, \"C\": {\"b\": 1}}}\n+      ],\n+      \"outputs\": [\n+        {\"topic\": \"OUTPUT\", \"key\": 1, \"value\": {\"KSQL_COL_0\": true, \"KSQL_COL_1\": false, \"KSQL_COL_2\": true, \"KSQL_COL_3\": false}},\n+        {\"topic\": \"OUTPUT\", \"key\": 2, \"value\": {\"KSQL_COL_0\": false, \"KSQL_COL_1\": true, \"KSQL_COL_2\": false, \"KSQL_COL_3\": true}},\n+        {\"topic\": \"OUTPUT\", \"key\": 3, \"value\": {\"KSQL_COL_0\": false, \"KSQL_COL_1\": true, \"KSQL_COL_2\": false, \"KSQL_COL_3\": true}}\n+      ]\n     },\n     {\n-      \"name\": \"comparison struct fails\",", "originalCommit": "208c481a3b936185c418f720da336efc19cf21c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MTk4Nw==", "url": "https://github.com/confluentinc/ksql/pull/6149#discussion_r495881987", "bodyText": "Restored", "author": "uurl", "createdAt": "2020-09-28T11:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkyMjExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkyMjM2OA==", "url": "https://github.com/confluentinc/ksql/pull/6149#discussion_r493922368", "bodyText": "thanks for updating these tests too! we'll need to regenerate the historical plans. you can do this by running PlannedTestGeneratorTest (and uncomment @Ignore)", "author": "agavra", "createdAt": "2020-09-23T22:06:18Z", "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/binary-comparison.json", "diffHunk": "@@ -6,31 +6,31 @@\n     {\n       \"name\": \"equals\",\n       \"statements\": [\n-        \"CREATE STREAM INPUT (A INT KEY, B BOOLEAN, C BIGINT, D DOUBLE, E DECIMAL(4,3), F STRING) WITH (kafka_topic='test_topic', value_format='JSON');\",\n-        \"CREATE STREAM OUTPUT AS SELECT A, A = 1, B = true, C = 11, D = 1.1, E = 1.20, F = 'foo' FROM INPUT;\"\n+        \"CREATE STREAM INPUT (A INT KEY, B BOOLEAN, C BIGINT, D DOUBLE, E DECIMAL(4,3), F STRING, G ARRAY<INT>, H MAP<STRING, INT>, I STRUCT<ID INT>) WITH (kafka_topic='test_topic', value_format='JSON');\",", "originalCommit": "208c481a3b936185c418f720da336efc19cf21c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MTgwMA==", "url": "https://github.com/confluentinc/ksql/pull/6149#discussion_r495881800", "bodyText": "Ready @agavra", "author": "uurl", "createdAt": "2020-09-28T11:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkyMjM2OA=="}], "type": "inlineReview"}, {"oid": "b81b29433cfb8f01dad7bfe73dd349602bd85df6", "url": "https://github.com/confluentinc/ksql/commit/b81b29433cfb8f01dad7bfe73dd349602bd85df6", "message": "feat: Support Comparisons on complex types 3", "committedDate": "2020-09-28T11:49:14Z", "type": "commit"}, {"oid": "99caf7a67b05266d6b30994ae7ea0d015a15e317", "url": "https://github.com/confluentinc/ksql/commit/99caf7a67b05266d6b30994ae7ea0d015a15e317", "message": "feat: Support Comparisons on complex types 3", "committedDate": "2020-09-28T11:51:55Z", "type": "commit"}]}