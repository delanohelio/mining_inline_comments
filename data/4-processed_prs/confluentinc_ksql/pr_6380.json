{"pr_number": 6380, "pr_title": "chore: support inference of key schemas from Schema Registry", "pr_createdAt": "2020-10-07T22:52:09Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6380", "timeline": [{"oid": "ee84abd37f5933527a8c56a213f32c07d55bf7cf", "url": "https://github.com/confluentinc/ksql/commit/ee84abd37f5933527a8c56a213f32c07d55bf7cf", "message": "chore: rename SCHEMA_ID to VALUE_SCHEMA_ID", "committedDate": "2020-10-07T14:54:38Z", "type": "commit"}, {"oid": "5c737657b02730aa215db5996222e84fcb052a10", "url": "https://github.com/confluentinc/ksql/commit/5c737657b02730aa215db5996222e84fcb052a10", "message": "chore: support getting key schemas from supplier", "committedDate": "2020-10-07T16:04:52Z", "type": "commit"}, {"oid": "e0f168f0deedd0a103c3b2a36ce9dd3ea8024086", "url": "https://github.com/confluentinc/ksql/commit/e0f168f0deedd0a103c3b2a36ce9dd3ea8024086", "message": "chore: support key schema inference in injector", "committedDate": "2020-10-07T22:13:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM1NjM0Mw==", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r501356343", "bodyText": "This previous code had the following behavior: if VALUE_SCHEMA_ID was explicitly supplied by the user, then the create properties were not updated with the schema ID returned from the topic schema supplier. The new behavior is to always update the create properties with the schema ID returned from the topic schema supplier. Unless I'm mistaken, the topic schema supplier implementation always returns the same schema ID that was supplied, if relevant. Even if this changes in the future (not sure why it would), I think the new behavior is more accurate since the create properties after the injector runs reflect exactly what the engine is going to execute.", "author": "vcrfxia", "createdAt": "2020-10-07T22:56:46Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/DefaultSchemaInjector.java", "diffHunk": "@@ -91,94 +94,167 @@ public DefaultSchemaInjector(final TopicSchemaSupplier schemaSupplier) {\n   private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n-    if (hasValueElements(statement) || !valueFormatSupportsSchemaInference(statement)) {\n+    final Optional<SchemaAndId> keySchema = getKeySchema(statement);\n+    final Optional<SchemaAndId> valueSchema = getValueSchema(statement);\n+    if (!keySchema.isPresent() && !valueSchema.isPresent()) {\n       return Optional.empty();\n     }\n \n-    final SchemaAndId valueSchema = getValueSchema(statement);\n-    final CreateSource withSchema = addSchemaFields(statement, valueSchema);\n+    final CreateSource withSchema = addSchemaFields(statement, keySchema, valueSchema);\n     final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withSchema);\n     final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n         .of(prepared, statement.getSessionConfig());\n \n     return Optional.of(configured);\n   }\n \n-  private SchemaAndId getValueSchema(\n+  private Optional<SchemaAndId> getKeySchema(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n     final CreateSourceProperties props = statement.getStatement().getProperties();\n+    final FormatInfo keyFormat = SourcePropertiesUtil.getKeyFormat(props);\n \n-    final FormatInfo expectedValueFormat = SourcePropertiesUtil.getValueFormat(props);\n+    if (hasKeyElements(statement) || !formatSupportsSchemaInference(keyFormat)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(getSchema(\n+        props.getKafkaTopic(),\n+        props.getKeySchemaId(),\n+        keyFormat,\n+        statement.getStatementText(),\n+        true\n+    ));\n+  }\n+\n+  private Optional<SchemaAndId> getValueSchema(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    final CreateSourceProperties props = statement.getStatement().getProperties();\n+    final FormatInfo valueFormat = SourcePropertiesUtil.getValueFormat(props);\n \n-    final SchemaResult result = schemaSupplier\n-        .getValueSchema(props.getKafkaTopic(), props.getSchemaId(), expectedValueFormat);\n+    if (hasValueElements(statement) || !formatSupportsSchemaInference(valueFormat)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(getSchema(\n+        props.getKafkaTopic(),\n+        props.getValueSchemaId(),\n+        valueFormat,\n+        statement.getStatementText(),\n+        false\n+    ));\n+  }\n+\n+  private SchemaAndId getSchema(\n+      final String topicName,\n+      final Optional<Integer> schemaId,\n+      final FormatInfo expectedFormat,\n+      final String statementText,\n+      final boolean isKey\n+  ) {\n+    final SchemaResult result = isKey\n+        ? schemaSupplier.getKeySchema(topicName, schemaId, expectedFormat)\n+        : schemaSupplier.getValueSchema(topicName, schemaId, expectedFormat);\n \n     if (result.failureReason.isPresent()) {\n       final Exception cause = result.failureReason.get();\n       throw new KsqlStatementException(\n           cause.getMessage(),\n-          statement.getStatementText(),\n+          statementText,\n           cause);\n     }\n \n     return result.schemaAndId.get();\n   }\n \n-  private static boolean hasValueElements(\n+  private static boolean hasKeyElements(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n     return statement.getStatement().getElements().stream()\n-        .anyMatch(e -> e.getNamespace().equals(Namespace.VALUE));\n+        .anyMatch(e -> e.getNamespace().isKey());\n   }\n \n-  private static boolean valueFormatSupportsSchemaInference(\n+  private static boolean hasValueElements(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n-    final FormatInfo valueFormat = SourcePropertiesUtil\n-        .getValueFormat(statement.getStatement().getProperties());\n+    return statement.getStatement().getElements().stream()\n+        .anyMatch(e -> !e.getNamespace().isKey());\n+  }\n \n-    return FormatFactory.of(valueFormat).supportsFeature(SerdeFeature.SCHEMA_INFERENCE);\n+  private static boolean formatSupportsSchemaInference(final FormatInfo format) {\n+    return FormatFactory.of(format).supportsFeature(SerdeFeature.SCHEMA_INFERENCE);\n   }\n \n   private static CreateSource addSchemaFields(\n       final ConfiguredStatement<CreateSource> preparedStatement,\n-      final SchemaAndId schema\n+      final Optional<SchemaAndId> keySchema,\n+      final Optional<SchemaAndId> valueSchema\n   ) {\n-    final TableElements elements = buildElements(schema.columns, preparedStatement);\n+    final TableElements elements = buildElements(preparedStatement, keySchema, valueSchema);\n \n     final CreateSource statement = preparedStatement.getStatement();\n     final CreateSourceProperties properties = statement.getProperties();\n \n-    if (properties.getSchemaId().isPresent()) {\n-      return statement.copyWith(elements, properties);\n-    }\n-    return statement.copyWith(elements, properties.withSchemaId(schema.id));", "originalCommit": "e0f168f0deedd0a103c3b2a36ce9dd3ea8024086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4NTA2Mw==", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r501385063", "bodyText": "I think that if we're going down the route of structs-as-keys, then this should not flatten into multiple table elements (I have yet to look at the SchemaSupplier code, I suspect that's what should be handling this). To ensure this, for now I think this should assert that there is no more than one key column.", "author": "agavra", "createdAt": "2020-10-08T00:34:13Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/DefaultSchemaInjector.java", "diffHunk": "@@ -91,94 +94,167 @@ public DefaultSchemaInjector(final TopicSchemaSupplier schemaSupplier) {\n   private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n-    if (hasValueElements(statement) || !valueFormatSupportsSchemaInference(statement)) {\n+    final Optional<SchemaAndId> keySchema = getKeySchema(statement);\n+    final Optional<SchemaAndId> valueSchema = getValueSchema(statement);\n+    if (!keySchema.isPresent() && !valueSchema.isPresent()) {\n       return Optional.empty();\n     }\n \n-    final SchemaAndId valueSchema = getValueSchema(statement);\n-    final CreateSource withSchema = addSchemaFields(statement, valueSchema);\n+    final CreateSource withSchema = addSchemaFields(statement, keySchema, valueSchema);\n     final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withSchema);\n     final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n         .of(prepared, statement.getSessionConfig());\n \n     return Optional.of(configured);\n   }\n \n-  private SchemaAndId getValueSchema(\n+  private Optional<SchemaAndId> getKeySchema(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n     final CreateSourceProperties props = statement.getStatement().getProperties();\n+    final FormatInfo keyFormat = SourcePropertiesUtil.getKeyFormat(props);\n \n-    final FormatInfo expectedValueFormat = SourcePropertiesUtil.getValueFormat(props);\n+    if (hasKeyElements(statement) || !formatSupportsSchemaInference(keyFormat)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(getSchema(\n+        props.getKafkaTopic(),\n+        props.getKeySchemaId(),\n+        keyFormat,\n+        statement.getStatementText(),\n+        true\n+    ));\n+  }\n+\n+  private Optional<SchemaAndId> getValueSchema(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    final CreateSourceProperties props = statement.getStatement().getProperties();\n+    final FormatInfo valueFormat = SourcePropertiesUtil.getValueFormat(props);\n \n-    final SchemaResult result = schemaSupplier\n-        .getValueSchema(props.getKafkaTopic(), props.getSchemaId(), expectedValueFormat);\n+    if (hasValueElements(statement) || !formatSupportsSchemaInference(valueFormat)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(getSchema(\n+        props.getKafkaTopic(),\n+        props.getValueSchemaId(),\n+        valueFormat,\n+        statement.getStatementText(),\n+        false\n+    ));\n+  }\n+\n+  private SchemaAndId getSchema(\n+      final String topicName,\n+      final Optional<Integer> schemaId,\n+      final FormatInfo expectedFormat,\n+      final String statementText,\n+      final boolean isKey\n+  ) {\n+    final SchemaResult result = isKey\n+        ? schemaSupplier.getKeySchema(topicName, schemaId, expectedFormat)\n+        : schemaSupplier.getValueSchema(topicName, schemaId, expectedFormat);\n \n     if (result.failureReason.isPresent()) {\n       final Exception cause = result.failureReason.get();\n       throw new KsqlStatementException(\n           cause.getMessage(),\n-          statement.getStatementText(),\n+          statementText,\n           cause);\n     }\n \n     return result.schemaAndId.get();\n   }\n \n-  private static boolean hasValueElements(\n+  private static boolean hasKeyElements(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n     return statement.getStatement().getElements().stream()\n-        .anyMatch(e -> e.getNamespace().equals(Namespace.VALUE));\n+        .anyMatch(e -> e.getNamespace().isKey());\n   }\n \n-  private static boolean valueFormatSupportsSchemaInference(\n+  private static boolean hasValueElements(\n       final ConfiguredStatement<CreateSource> statement\n   ) {\n-    final FormatInfo valueFormat = SourcePropertiesUtil\n-        .getValueFormat(statement.getStatement().getProperties());\n+    return statement.getStatement().getElements().stream()\n+        .anyMatch(e -> !e.getNamespace().isKey());\n+  }\n \n-    return FormatFactory.of(valueFormat).supportsFeature(SerdeFeature.SCHEMA_INFERENCE);\n+  private static boolean formatSupportsSchemaInference(final FormatInfo format) {\n+    return FormatFactory.of(format).supportsFeature(SerdeFeature.SCHEMA_INFERENCE);\n   }\n \n   private static CreateSource addSchemaFields(\n       final ConfiguredStatement<CreateSource> preparedStatement,\n-      final SchemaAndId schema\n+      final Optional<SchemaAndId> keySchema,\n+      final Optional<SchemaAndId> valueSchema\n   ) {\n-    final TableElements elements = buildElements(schema.columns, preparedStatement);\n+    final TableElements elements = buildElements(preparedStatement, keySchema, valueSchema);\n \n     final CreateSource statement = preparedStatement.getStatement();\n     final CreateSourceProperties properties = statement.getProperties();\n \n-    if (properties.getSchemaId().isPresent()) {\n-      return statement.copyWith(elements, properties);\n-    }\n-    return statement.copyWith(elements, properties.withSchemaId(schema.id));\n+    final CreateSourceProperties withSchemaIds = properties.withSchemaIds(\n+        keySchema.map(s -> s.id),\n+        valueSchema.map(s -> s.id));\n+    return statement.copyWith(elements, withSchemaIds);\n   }\n \n   private static TableElements buildElements(\n-      final List<? extends SimpleColumn> valueColumns,\n-      final ConfiguredStatement<CreateSource> preparedStatement\n+      final ConfiguredStatement<CreateSource> preparedStatement,\n+      final Optional<SchemaAndId> keySchema,\n+      final Optional<SchemaAndId> valueSchema\n   ) {\n     final List<TableElement> elements = new ArrayList<>();\n \n-    getKeyColumns(preparedStatement)\n-        .forEach(elements::add);\n+    if (keySchema.isPresent()) {\n+      final Namespace namespace = getKeyNamespace(preparedStatement.getStatement());\n+      keySchema.get().columns.stream()\n+          .map(col -> new TableElement(namespace, col.name(), new Type(col.type())))\n+          .forEach(elements::add);", "originalCommit": "e0f168f0deedd0a103c3b2a36ce9dd3ea8024086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY5NDM2Nw==", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r501694367", "bodyText": "Is the schema injector the right place for this assertion? I was under the impression that the schema injector should just blindly populate columns based on schemas from Schema Registry, and that the engine should be responsible for validation. The engine already validates that only a single key column is present.", "author": "vcrfxia", "createdAt": "2020-10-08T12:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4NTA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4Njg3NA==", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r501386874", "bodyText": "as I alluded to above, I think the behavior here needs to be different for keys/values. Namely, when we call the translator.toColumns(parsedSchema) we should only ever return one column for keys.\nI think we can leave that for a separate PR, and for this PR we can just assert that it only returns one column (i.e. we only support primitive keys and single field structs)", "author": "agavra", "createdAt": "2020-10-08T00:41:01Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegistryTopicSchemaSupplier.java", "diffHunk": "@@ -74,52 +93,57 @@ public SchemaResult getValueSchema(\n       }\n \n       final ParsedSchema schema = srClient.getSchemaBySubjectAndId(subject, id);\n-      return fromParsedSchema(topicName, id, schema, expectedFormat);\n+      return fromParsedSchema(topicName, id, schema, expectedFormat, isKey);", "originalCommit": "e0f168f0deedd0a103c3b2a36ce9dd3ea8024086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY5NDg1MA==", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r501694850", "bodyText": "Same question as above -- does it make sense to have that type of validation in the schema supplier, rather than in the engine? Seems like we'd be duplicating validation logic by adding it here as well.", "author": "vcrfxia", "createdAt": "2020-10-08T12:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4Njg3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxMjcxMA==", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r501812710", "bodyText": "I think it makes sense to include it here but not in the schema injector (which is why I said perhaps this should be done in SchemaSupplier). The reason for that is that there are two separate pieces of logic: (1) how do we translate a connect schema to a ksqlDB schema and (2) do we support multi-column ksqlDB key schemas?\nTo me, they're different because I could decided that (1) should either (a) always convert a schema into a single column struct or (b) always convert a struct schema to multiple columns. That's orthogonal to how we decide (2) - in fact we could support (2) with either 1a or 1b.\nThe reason I think we need the assertion here for this PR is that we haven't chosen between 1a and 1b - so it makes sense to fail early.", "author": "agavra", "createdAt": "2020-10-08T15:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4Njg3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxNDAzNw==", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r501814037", "bodyText": "The other reason is that the error here can make more sense. We can fail with \"your schema in schema registry has multiple columns, we do not support inference for such schemas...\" vs. getting an error at the engine \"ksqlDB does not support multiple key columns\"", "author": "agavra", "createdAt": "2020-10-08T15:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4Njg3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NzAyOA==", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r502457028", "bodyText": "Sure, I'm convinced -- updated the schema supplier to fail if multiple key columns are found.", "author": "vcrfxia", "createdAt": "2020-10-09T14:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4Njg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5MjAzMQ==", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r501392031", "bodyText": "nit: I used this pattern quite a bit, maybe we should move it to a util and refactor this? (and then we can also make SCHEMA_REGISTRY_*_SUFFIX private and just use this method) can be done in follow-up PR", "author": "agavra", "createdAt": "2020-10-08T01:01:01Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/schema/ksql/inference/SchemaRegistryTopicSchemaSupplier.java", "diffHunk": "@@ -175,4 +201,11 @@ private static SchemaResult notCompatible(\n             + \"Schema:\" + schema,\n         cause));\n   }\n+\n+  private static String getSubject(final String topicName, final boolean isKey) {", "originalCommit": "e0f168f0deedd0a103c3b2a36ce9dd3ea8024086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1ODMzNQ==", "url": "https://github.com/confluentinc/ksql/pull/6380#discussion_r502458335", "bodyText": "I only see two uses of SCHEMA_REGISTRY_KEY_SUFFIX in the codebase so I've extracted those into a util method and made the constant private. However, there are a bunch of other uses of SCHEMA_REGISTRY_VALUE_SUFFIX that I want to leave for now to make it easier to audit to ensure proper handling of key schemas (at least parity with value schemas) so I've left those in for now. We can finish this refactor in a follow-up PR once the other bits of key schema support are in. Tracking in #6395", "author": "vcrfxia", "createdAt": "2020-10-09T14:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM5MjAzMQ=="}], "type": "inlineReview"}, {"oid": "e4de239431d7d7ffd36ff75c88bf509743b18071", "url": "https://github.com/confluentinc/ksql/commit/e4de239431d7d7ffd36ff75c88bf509743b18071", "message": "test: fix test", "committedDate": "2020-10-08T12:56:25Z", "type": "commit"}, {"oid": "643ddc6b781d652a4a6fa4890e7960c7612a949d", "url": "https://github.com/confluentinc/ksql/commit/643ddc6b781d652a4a6fa4890e7960c7612a949d", "message": "chore: throw from schema supplier on multiple key columns", "committedDate": "2020-10-09T13:53:51Z", "type": "commit"}, {"oid": "2d17d3293f5f44294ed02236aaa293173828d5ca", "url": "https://github.com/confluentinc/ksql/commit/2d17d3293f5f44294ed02236aaa293173828d5ca", "message": "refactor: util method for SR suffixes", "committedDate": "2020-10-09T14:03:58Z", "type": "commit"}, {"oid": "88ac55f162b70bdcf8374a835019e4b6835ba8c7", "url": "https://github.com/confluentinc/ksql/commit/88ac55f162b70bdcf8374a835019e4b6835ba8c7", "message": "Merge branch 'master' into key-schema-register", "committedDate": "2020-10-12T13:04:20Z", "type": "commit"}, {"oid": "120ce6ab1c304338058df29eed4384c72676883c", "url": "https://github.com/confluentinc/ksql/commit/120ce6ab1c304338058df29eed4384c72676883c", "message": "fix: throw on unsupported key format from injector", "committedDate": "2020-10-12T17:09:08Z", "type": "commit"}]}