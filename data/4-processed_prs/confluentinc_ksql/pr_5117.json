{"pr_number": 5117, "pr_title": "docs: add klip 25 - removal of WITH(KEY) syntax", "pr_createdAt": "2020-04-20T14:39:41Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5117", "timeline": [{"oid": "ba90da660e26abdaca3e480dfa7b64829427b36e", "url": "https://github.com/confluentinc/ksql/commit/ba90da660e26abdaca3e480dfa7b64829427b36e", "message": "docs: add klip 25 - removal of WITH(KEY) syntax", "committedDate": "2020-04-20T14:38:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0NDA5MA==", "url": "https://github.com/confluentinc/ksql/pull/5117#discussion_r411544090", "bodyText": "\ud83d\udc74 \ud83c\udfeb \ud83d\udd23", "author": "agavra", "createdAt": "2020-04-20T17:05:27Z", "path": "design-proposals/klip-25-removal-of-with-key-syntax.md", "diffHunk": "@@ -0,0 +1,163 @@\n+# KLIP Number - Title\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBC\n+\n+**tl;dr:** The `WITH(KEY)` syntax is the cause of much confusion and errors as it requires users to\n+have an _exact_ copy of the Kafka record's key in a field in the value. It allows users to provide\n+a more meaningful alias for the system `ROWKEY` column in their queries. Unfortunately, the\n+implementation of the `WITH(KEY)` feature is incomplete and buggy. With the introduction of the\n+feature that allows the key column to have any name, the main benefit of the `WITH(KEY)` feature has\n+been removed, leaving only the confusion and errors. We propose it should be removed.\n+\n+## Motivation and background\n+\n+The `WITH(KEY)` syntax allows a user to provide an alias for the `ROWKEY` system column in ksqlDB:\n+\n+```sql\n+-- old skool syntax", "originalCommit": "ba90da660e26abdaca3e480dfa7b64829427b36e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNTAwNQ==", "url": "https://github.com/confluentinc/ksql/pull/5117#discussion_r411725005", "bodyText": "Orthogonal to this KLIP: why is this not allowed? Seems weird to me and I believe it would be ok with standard SQL and I see. no reason (given the current improvements for key handling) to not allow this? Are there any plans to fix it (I guess it won't need a KLIP; seems to be a follow up bug fix / improvement after the current work on keys is done)?", "author": "mjsax", "createdAt": "2020-04-20T22:08:34Z", "path": "design-proposals/klip-25-removal-of-with-key-syntax.md", "diffHunk": "@@ -0,0 +1,163 @@\n+# KLIP Number - Title\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBC\n+\n+**tl;dr:** The `WITH(KEY)` syntax is the cause of much confusion and errors as it requires users to\n+have an _exact_ copy of the Kafka record's key in a field in the value. It allows users to provide\n+a more meaningful alias for the system `ROWKEY` column in their queries. Unfortunately, the\n+implementation of the `WITH(KEY)` feature is incomplete and buggy. With the introduction of the\n+feature that allows the key column to have any name, the main benefit of the `WITH(KEY)` feature has\n+been removed, leaving only the confusion and errors. We propose it should be removed.\n+\n+## Motivation and background\n+\n+The `WITH(KEY)` syntax allows a user to provide an alias for the `ROWKEY` system column in ksqlDB:\n+\n+```sql\n+-- old skool syntax\n+CREATE TABLE INPUT (ID INT, NAME STRING) WITH ('KEY'='ID', 'KAFKA_TOPIC'='input', ...);\n+```\n+\n+The above statement defines a table with an implicit STRING primary key column called `ROWKEY` and\n+two other columns called `ID` and `NAME`.  The presence of the `WITH('KEY'='ID')` tells ksqlDB that\n+the `ID` column is essentially an aliases for `ROWKEY` as it contains the exact same data.\n+\n+### Aliasing\n+\n+Allowing users to provide an alias for the system column `ROWKEY` allowed users to provide a more\n+domain driven name, making queries more expressive:\n+\n+```sql\n+-- Given a stream of users where the key contained a region code:\n+\n+CREATE TABLE USERS_BY_REGION AS\n+   SELECT COUNT(*) FROM USERS GROUP BY ROWKEY;\n+\n+-- is less expressive than --\n+\n+CREATE TABLE USERS_BY_REGION AS\n+   SELECT REGION, COUNT(*) FROM USERS GROUP BY REGION;\n+```\n+\n+However, [a feature removing the restriction that key columns must be called `ROWKEY` is about to be\n+enabled](https://github.com/confluentinc/ksql/pull/5093). Once it is, the aliasing that `WITH(KEY)`\n+provides will be redundant, as the same can be achieved much more intuitively, and without the need\n+to duplicate the key data into a value field, using the new syntax. For example:\n+\n+```sql\n+-- old skool syntax:\n+CREATE TABLE USERS (ROWKEY BIGINT PRIMARY KEY, NAME STRING, ID BIGINT) WITH ('KEY'='ID', ...);\n+\n+-- new skool syntax:\n+CREATE TABLE USERS (ID BIGINT PRIMARY KEY, NAME STRING) WITH (...);\n+```\n+\n+### Optimisations\n+\n+This aliasing allows ksqlDB to optimize certain queries by avoiding unnecessary repartition steps,\n+should the 'key field' be used in a `PARTITION BY`, `GROUP BY` or `JOIN ON` clause. For example:\n+\n+```sql\n+-- given:\n+CREATE TABLE INPUT (ID INT, NAME STRING) WITH ('KEY'='ID', 'KAFKA_TOPIC'='input', ...);\n+\n+-- no repartition necessary as `ID` is equivalent to `ROWKEY`\n+SELECT ID, COUNT() FROM INPUT GROUP BY ID;\n+```\n+\n+KsqlDB can avoid an unnecessary repartition step in the above statement as `ID` is equivalent to\n+`ROWKEY`, and grouping by `ROWKEY` is already correctly partitioned.\n+\n+It's not just streams and tables created by `CREATE STREAM` and `CREATE TABLE` statements that can\n+track these `key-fields`. KsqDB also tries to keep track of the key field in derived sources\n+too, for example:\n+\n+```sql\n+CREATE TABLE FOO AS ID, COUNT() FROM BAR GROUP BY ID;\n+-- Foo has key-field 'ID'\n+```\n+\n+In the above, KsqlDB will detect that `FOO``s `ID` column is equivalent to `ROWKEY`. However, it can\n+only handle a single field. If there are multiple, only the first is tracked, for example:\n+\n+```sql\n+CREATE TABLE FOO AS ID AS ID1, ID AS ID2, COUNT() FROM BAR GROUP BY ID;\n+-- Foo has key-field 'ID1'\n+-- `ID2` is not a key field, even though its a duplicate of `ID1`", "originalCommit": "ba90da660e26abdaca3e480dfa7b64829427b36e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAzMDY5Mw==", "url": "https://github.com/confluentinc/ksql/pull/5117#discussion_r412030693", "bodyText": "Totally - it would be possible for KSQL to track the full set of 'columns that are just an alias of the key' for each source. This would allow us to avoid unnecessary repartitions.\nHowever, the ROI on such work may be limited in the short to mid term compared to other work. Especially considering that users will soon be able to name their key columns as they like, and hence could just join on those columns.  In the new model, how often will people be creating duplicates of the key column elsewhere? Hard to quantify, but probably not that much.  Also, once support for multiple key columns are added, the complexity of supporting this goes up, while the usefulness / ROI may well go down.\nOne could argue that removing the current partial / buggy implementation of this is a step backwards. However, I would argue that without the investment to fix the bugs and extend to a full implementation, the current implementation has a negative impact on functionality (and code), overall and is better removed.\nRegardless of what we do with the current impl, the syntax should definitely be removed as any internal tracking of key aliases should be just that: internal.", "author": "big-andy-coates", "createdAt": "2020-04-21T09:35:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxMTA3Ng==", "url": "https://github.com/confluentinc/ksql/pull/5117#discussion_r412611076", "bodyText": "Thanks for the details!", "author": "mjsax", "createdAt": "2020-04-22T01:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNTAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNTg3MQ==", "url": "https://github.com/confluentinc/ksql/pull/5117#discussion_r411725871", "bodyText": "Nit: The current WITH(key) feature\n(Sounds like \"the new feature is not intuitive\" atm.)", "author": "mjsax", "createdAt": "2020-04-20T22:10:15Z", "path": "design-proposals/klip-25-removal-of-with-key-syntax.md", "diffHunk": "@@ -0,0 +1,163 @@\n+# KLIP Number - Title\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBC\n+\n+**tl;dr:** The `WITH(KEY)` syntax is the cause of much confusion and errors as it requires users to\n+have an _exact_ copy of the Kafka record's key in a field in the value. It allows users to provide\n+a more meaningful alias for the system `ROWKEY` column in their queries. Unfortunately, the\n+implementation of the `WITH(KEY)` feature is incomplete and buggy. With the introduction of the\n+feature that allows the key column to have any name, the main benefit of the `WITH(KEY)` feature has\n+been removed, leaving only the confusion and errors. We propose it should be removed.\n+\n+## Motivation and background\n+\n+The `WITH(KEY)` syntax allows a user to provide an alias for the `ROWKEY` system column in ksqlDB:\n+\n+```sql\n+-- old skool syntax\n+CREATE TABLE INPUT (ID INT, NAME STRING) WITH ('KEY'='ID', 'KAFKA_TOPIC'='input', ...);\n+```\n+\n+The above statement defines a table with an implicit STRING primary key column called `ROWKEY` and\n+two other columns called `ID` and `NAME`.  The presence of the `WITH('KEY'='ID')` tells ksqlDB that\n+the `ID` column is essentially an aliases for `ROWKEY` as it contains the exact same data.\n+\n+### Aliasing\n+\n+Allowing users to provide an alias for the system column `ROWKEY` allowed users to provide a more\n+domain driven name, making queries more expressive:\n+\n+```sql\n+-- Given a stream of users where the key contained a region code:\n+\n+CREATE TABLE USERS_BY_REGION AS\n+   SELECT COUNT(*) FROM USERS GROUP BY ROWKEY;\n+\n+-- is less expressive than --\n+\n+CREATE TABLE USERS_BY_REGION AS\n+   SELECT REGION, COUNT(*) FROM USERS GROUP BY REGION;\n+```\n+\n+However, [a feature removing the restriction that key columns must be called `ROWKEY` is about to be\n+enabled](https://github.com/confluentinc/ksql/pull/5093). Once it is, the aliasing that `WITH(KEY)`\n+provides will be redundant, as the same can be achieved much more intuitively, and without the need\n+to duplicate the key data into a value field, using the new syntax. For example:\n+\n+```sql\n+-- old skool syntax:\n+CREATE TABLE USERS (ROWKEY BIGINT PRIMARY KEY, NAME STRING, ID BIGINT) WITH ('KEY'='ID', ...);\n+\n+-- new skool syntax:\n+CREATE TABLE USERS (ID BIGINT PRIMARY KEY, NAME STRING) WITH (...);\n+```\n+\n+### Optimisations\n+\n+This aliasing allows ksqlDB to optimize certain queries by avoiding unnecessary repartition steps,\n+should the 'key field' be used in a `PARTITION BY`, `GROUP BY` or `JOIN ON` clause. For example:\n+\n+```sql\n+-- given:\n+CREATE TABLE INPUT (ID INT, NAME STRING) WITH ('KEY'='ID', 'KAFKA_TOPIC'='input', ...);\n+\n+-- no repartition necessary as `ID` is equivalent to `ROWKEY`\n+SELECT ID, COUNT() FROM INPUT GROUP BY ID;\n+```\n+\n+KsqlDB can avoid an unnecessary repartition step in the above statement as `ID` is equivalent to\n+`ROWKEY`, and grouping by `ROWKEY` is already correctly partitioned.\n+\n+It's not just streams and tables created by `CREATE STREAM` and `CREATE TABLE` statements that can\n+track these `key-fields`. KsqDB also tries to keep track of the key field in derived sources\n+too, for example:\n+\n+```sql\n+CREATE TABLE FOO AS ID, COUNT() FROM BAR GROUP BY ID;\n+-- Foo has key-field 'ID'\n+```\n+\n+In the above, KsqlDB will detect that `FOO``s `ID` column is equivalent to `ROWKEY`. However, it can\n+only handle a single field. If there are multiple, only the first is tracked, for example:\n+\n+```sql\n+CREATE TABLE FOO AS ID AS ID1, ID AS ID2, COUNT() FROM BAR GROUP BY ID;\n+-- Foo has key-field 'ID1'\n+-- `ID2` is not a key field, even though its a duplicate of `ID1`\n+```\n+\n+Unfortunately, the implementation of the handling of these 'key fields' is very buggy, full of edge\n+cases and incomplete. The bugs and edgecases can mean that a repartition is done when not needed or,\n+worse, not done when needed. The incomplete implementation can result in confusing behaviour for\n+users.\n+\n+With the introduction of the 'any-key-name' feature, this optimization also becomes redundant, as\n+users can directly name their key columns as they need.\n+\n+## What is in scope\n+\n+- Removal of `WITH(KEY)` from ksqlDB syntax\n+- Removal of the code with ksqlDB that tracks the key-field.\n+\n+## What is not in scope\n+\n+- Future `WITH(KEYS)` style syntax that may be used to control which columns are persisted in the\n+  key of the Kafka record vs the value.  This is TBD and would be covered in a separate KLIP.\n+\n+## Value/Return\n+\n+The feature is not intuitive, it's the source of many a confused user and engineer and is often", "originalCommit": "ba90da660e26abdaca3e480dfa7b64829427b36e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1MzkxNQ==", "url": "https://github.com/confluentinc/ksql/pull/5117#discussion_r412153915", "bodyText": "nit: missing SELECT?", "author": "rmoff", "createdAt": "2020-04-21T12:48:06Z", "path": "design-proposals/klip-25-removal-of-with-key-syntax.md", "diffHunk": "@@ -0,0 +1,163 @@\n+# KLIP Number - Title\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBC\n+\n+**tl;dr:** The `WITH(KEY)` syntax is the cause of much confusion and errors as it requires users to\n+have an _exact_ copy of the Kafka record's key in a field in the value. It allows users to provide\n+a more meaningful alias for the system `ROWKEY` column in their queries. Unfortunately, the\n+implementation of the `WITH(KEY)` feature is incomplete and buggy. With the introduction of the\n+feature that allows the key column to have any name, the main benefit of the `WITH(KEY)` feature has\n+been removed, leaving only the confusion and errors. We propose it should be removed.\n+\n+## Motivation and background\n+\n+The `WITH(KEY)` syntax allows a user to provide an alias for the `ROWKEY` system column in ksqlDB:\n+\n+```sql\n+-- old skool syntax\n+CREATE TABLE INPUT (ID INT, NAME STRING) WITH ('KEY'='ID', 'KAFKA_TOPIC'='input', ...);\n+```\n+\n+The above statement defines a table with an implicit STRING primary key column called `ROWKEY` and\n+two other columns called `ID` and `NAME`.  The presence of the `WITH('KEY'='ID')` tells ksqlDB that\n+the `ID` column is essentially an aliases for `ROWKEY` as it contains the exact same data.\n+\n+### Aliasing\n+\n+Allowing users to provide an alias for the system column `ROWKEY` allowed users to provide a more\n+domain driven name, making queries more expressive:\n+\n+```sql\n+-- Given a stream of users where the key contained a region code:\n+\n+CREATE TABLE USERS_BY_REGION AS\n+   SELECT COUNT(*) FROM USERS GROUP BY ROWKEY;\n+\n+-- is less expressive than --\n+\n+CREATE TABLE USERS_BY_REGION AS\n+   SELECT REGION, COUNT(*) FROM USERS GROUP BY REGION;\n+```\n+\n+However, [a feature removing the restriction that key columns must be called `ROWKEY` is about to be\n+enabled](https://github.com/confluentinc/ksql/pull/5093). Once it is, the aliasing that `WITH(KEY)`\n+provides will be redundant, as the same can be achieved much more intuitively, and without the need\n+to duplicate the key data into a value field, using the new syntax. For example:\n+\n+```sql\n+-- old skool syntax:\n+CREATE TABLE USERS (ROWKEY BIGINT PRIMARY KEY, NAME STRING, ID BIGINT) WITH ('KEY'='ID', ...);\n+\n+-- new skool syntax:\n+CREATE TABLE USERS (ID BIGINT PRIMARY KEY, NAME STRING) WITH (...);\n+```\n+\n+### Optimisations\n+\n+This aliasing allows ksqlDB to optimize certain queries by avoiding unnecessary repartition steps,\n+should the 'key field' be used in a `PARTITION BY`, `GROUP BY` or `JOIN ON` clause. For example:\n+\n+```sql\n+-- given:\n+CREATE TABLE INPUT (ID INT, NAME STRING) WITH ('KEY'='ID', 'KAFKA_TOPIC'='input', ...);\n+\n+-- no repartition necessary as `ID` is equivalent to `ROWKEY`\n+SELECT ID, COUNT() FROM INPUT GROUP BY ID;\n+```\n+\n+KsqlDB can avoid an unnecessary repartition step in the above statement as `ID` is equivalent to\n+`ROWKEY`, and grouping by `ROWKEY` is already correctly partitioned.\n+\n+It's not just streams and tables created by `CREATE STREAM` and `CREATE TABLE` statements that can\n+track these `key-fields`. KsqDB also tries to keep track of the key field in derived sources\n+too, for example:\n+\n+```sql\n+CREATE TABLE FOO AS ID, COUNT() FROM BAR GROUP BY ID;", "originalCommit": "ba90da660e26abdaca3e480dfa7b64829427b36e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1NDEzOA==", "url": "https://github.com/confluentinc/ksql/pull/5117#discussion_r412154138", "bodyText": "nit: missing SELECT?", "author": "rmoff", "createdAt": "2020-04-21T12:48:24Z", "path": "design-proposals/klip-25-removal-of-with-key-syntax.md", "diffHunk": "@@ -0,0 +1,163 @@\n+# KLIP Number - Title\n+\n+**Author**: @big-andy-coates |\n+**Release Target**: TBD |\n+**Status**: In Discussion |\n+**Discussion**: TBC\n+\n+**tl;dr:** The `WITH(KEY)` syntax is the cause of much confusion and errors as it requires users to\n+have an _exact_ copy of the Kafka record's key in a field in the value. It allows users to provide\n+a more meaningful alias for the system `ROWKEY` column in their queries. Unfortunately, the\n+implementation of the `WITH(KEY)` feature is incomplete and buggy. With the introduction of the\n+feature that allows the key column to have any name, the main benefit of the `WITH(KEY)` feature has\n+been removed, leaving only the confusion and errors. We propose it should be removed.\n+\n+## Motivation and background\n+\n+The `WITH(KEY)` syntax allows a user to provide an alias for the `ROWKEY` system column in ksqlDB:\n+\n+```sql\n+-- old skool syntax\n+CREATE TABLE INPUT (ID INT, NAME STRING) WITH ('KEY'='ID', 'KAFKA_TOPIC'='input', ...);\n+```\n+\n+The above statement defines a table with an implicit STRING primary key column called `ROWKEY` and\n+two other columns called `ID` and `NAME`.  The presence of the `WITH('KEY'='ID')` tells ksqlDB that\n+the `ID` column is essentially an aliases for `ROWKEY` as it contains the exact same data.\n+\n+### Aliasing\n+\n+Allowing users to provide an alias for the system column `ROWKEY` allowed users to provide a more\n+domain driven name, making queries more expressive:\n+\n+```sql\n+-- Given a stream of users where the key contained a region code:\n+\n+CREATE TABLE USERS_BY_REGION AS\n+   SELECT COUNT(*) FROM USERS GROUP BY ROWKEY;\n+\n+-- is less expressive than --\n+\n+CREATE TABLE USERS_BY_REGION AS\n+   SELECT REGION, COUNT(*) FROM USERS GROUP BY REGION;\n+```\n+\n+However, [a feature removing the restriction that key columns must be called `ROWKEY` is about to be\n+enabled](https://github.com/confluentinc/ksql/pull/5093). Once it is, the aliasing that `WITH(KEY)`\n+provides will be redundant, as the same can be achieved much more intuitively, and without the need\n+to duplicate the key data into a value field, using the new syntax. For example:\n+\n+```sql\n+-- old skool syntax:\n+CREATE TABLE USERS (ROWKEY BIGINT PRIMARY KEY, NAME STRING, ID BIGINT) WITH ('KEY'='ID', ...);\n+\n+-- new skool syntax:\n+CREATE TABLE USERS (ID BIGINT PRIMARY KEY, NAME STRING) WITH (...);\n+```\n+\n+### Optimisations\n+\n+This aliasing allows ksqlDB to optimize certain queries by avoiding unnecessary repartition steps,\n+should the 'key field' be used in a `PARTITION BY`, `GROUP BY` or `JOIN ON` clause. For example:\n+\n+```sql\n+-- given:\n+CREATE TABLE INPUT (ID INT, NAME STRING) WITH ('KEY'='ID', 'KAFKA_TOPIC'='input', ...);\n+\n+-- no repartition necessary as `ID` is equivalent to `ROWKEY`\n+SELECT ID, COUNT() FROM INPUT GROUP BY ID;\n+```\n+\n+KsqlDB can avoid an unnecessary repartition step in the above statement as `ID` is equivalent to\n+`ROWKEY`, and grouping by `ROWKEY` is already correctly partitioned.\n+\n+It's not just streams and tables created by `CREATE STREAM` and `CREATE TABLE` statements that can\n+track these `key-fields`. KsqDB also tries to keep track of the key field in derived sources\n+too, for example:\n+\n+```sql\n+CREATE TABLE FOO AS ID, COUNT() FROM BAR GROUP BY ID;\n+-- Foo has key-field 'ID'\n+```\n+\n+In the above, KsqlDB will detect that `FOO``s `ID` column is equivalent to `ROWKEY`. However, it can\n+only handle a single field. If there are multiple, only the first is tracked, for example:\n+\n+```sql\n+CREATE TABLE FOO AS ID AS ID1, ID AS ID2, COUNT() FROM BAR GROUP BY ID;", "originalCommit": "ba90da660e26abdaca3e480dfa7b64829427b36e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0cf966269f1b00188ddd1a39d5063232f1ce16c9", "url": "https://github.com/confluentinc/ksql/commit/0cf966269f1b00188ddd1a39d5063232f1ce16c9", "message": "chore: Robin's requested changes", "committedDate": "2020-04-22T11:53:24Z", "type": "commit"}, {"oid": "02c20ade19d0b234729f8848b6dd4f0e4eec00c5", "url": "https://github.com/confluentinc/ksql/commit/02c20ade19d0b234729f8848b6dd4f0e4eec00c5", "message": "Update klip-25-removal-of-with-key-syntax.md", "committedDate": "2020-04-23T23:53:51Z", "type": "commit"}, {"oid": "e3859523b97eb09c65cf7cdfd59a1f62c99a367f", "url": "https://github.com/confluentinc/ksql/commit/e3859523b97eb09c65cf7cdfd59a1f62c99a367f", "message": "Update klip-25-removal-of-with-key-syntax.md", "committedDate": "2020-04-23T23:55:02Z", "type": "commit"}, {"oid": "0789def33b402022cdd44bdb97f2b6ccc7d8b143", "url": "https://github.com/confluentinc/ksql/commit/0789def33b402022cdd44bdb97f2b6ccc7d8b143", "message": "Update klip-25-removal-of-with-key-syntax.md", "committedDate": "2020-04-23T23:55:45Z", "type": "commit"}]}