{"pr_number": 5661, "pr_title": "docs: KLIP-30 - Lambda Functions", "pr_createdAt": "2020-06-19T21:06:21Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5661", "timeline": [{"oid": "8cb23eff1d42b3aaa5641aaad0656b68757e5229", "url": "https://github.com/confluentinc/ksql/commit/8cb23eff1d42b3aaa5641aaad0656b68757e5229", "message": "KLIP-30 - Lambda Functions", "committedDate": "2020-06-19T20:40:50Z", "type": "commit"}, {"oid": "2982bf48af52bbac003f975aed7c76fe9c63241e", "url": "https://github.com/confluentinc/ksql/commit/2982bf48af52bbac003f975aed7c76fe9c63241e", "message": "Add metadata", "committedDate": "2020-06-19T20:44:13Z", "type": "commit"}, {"oid": "6513e7370f4ba8f348c07cf91485d7f9d1cbec66", "url": "https://github.com/confluentinc/ksql/commit/6513e7370f4ba8f348c07cf91485d7f9d1cbec66", "message": "Add metadata", "committedDate": "2020-06-19T20:45:00Z", "type": "commit"}, {"oid": "48ffc6e3102cd283bb902f30ea1fb08ee5c5b2c3", "url": "https://github.com/confluentinc/ksql/commit/48ffc6e3102cd283bb902f30ea1fb08ee5c5b2c3", "message": "KLIP-30", "committedDate": "2020-06-19T20:45:41Z", "type": "commit"}, {"oid": "cc19d178448c4d4c53877fc8938d0fe1c094d7d2", "url": "https://github.com/confluentinc/ksql/commit/cc19d178448c4d4c53877fc8938d0fe1c094d7d2", "message": "Formatting", "committedDate": "2020-06-19T20:46:19Z", "type": "commit"}, {"oid": "6f18df722ab3a2e877b8eaf08f23676ecd869981", "url": "https://github.com/confluentinc/ksql/commit/6f18df722ab3a2e877b8eaf08f23676ecd869981", "message": "Minor edits", "committedDate": "2020-06-19T21:03:25Z", "type": "commit"}, {"oid": "ad3ac5a97f4f4cec9f694b415b62ffb30f8b524b", "url": "https://github.com/confluentinc/ksql/commit/ad3ac5a97f4f4cec9f694b415b62ffb30f8b524b", "message": "Link to discussion", "committedDate": "2020-06-19T21:12:03Z", "type": "commit"}, {"oid": "3bbe12595069c1e794fb2e5bf7b55d7530e5625f", "url": "https://github.com/confluentinc/ksql/commit/3bbe12595069c1e794fb2e5bf7b55d7530e5625f", "message": "Fix typo", "committedDate": "2020-06-19T21:13:33Z", "type": "commit"}, {"oid": "b84e6b585d12d6e7ca8fcf5c1675f821372dea15", "url": "https://github.com/confluentinc/ksql/commit/b84e6b585d12d6e7ca8fcf5c1675f821372dea15", "message": "Formatting", "committedDate": "2020-06-19T21:14:22Z", "type": "commit"}, {"oid": "0c678a6b5975ddae30997f8bd62f5a1f4fb24989", "url": "https://github.com/confluentinc/ksql/commit/0c678a6b5975ddae30997f8bd62f5a1f4fb24989", "message": "Fix typo", "committedDate": "2020-06-19T21:15:29Z", "type": "commit"}, {"oid": "5ab675cd93a5f2766919546d07e883920637182a", "url": "https://github.com/confluentinc/ksql/commit/5ab675cd93a5f2766919546d07e883920637182a", "message": "Link to discussion", "committedDate": "2020-06-19T21:22:10Z", "type": "commit"}, {"oid": "5c7e54e58f35a2af0ebd0a02e3817e71707a6574", "url": "https://github.com/confluentinc/ksql/commit/5c7e54e58f35a2af0ebd0a02e3817e71707a6574", "message": "Formatting", "committedDate": "2020-06-19T21:24:03Z", "type": "commit"}, {"oid": "03adda0a9b1c78e2fcb9e83018d248f06a11d32e", "url": "https://github.com/confluentinc/ksql/commit/03adda0a9b1c78e2fcb9e83018d248f06a11d32e", "message": "Formatting", "committedDate": "2020-06-19T21:25:34Z", "type": "commit"}, {"oid": "c1c5d550d2a5f8beb51f21fc5172ba01ca67ab2f", "url": "https://github.com/confluentinc/ksql/commit/c1c5d550d2a5f8beb51f21fc5172ba01ca67ab2f", "message": "Link to section", "committedDate": "2020-06-19T21:27:18Z", "type": "commit"}, {"oid": "9828aa8f36bb42a5a0260f2f82ebb67c920d8a63", "url": "https://github.com/confluentinc/ksql/commit/9828aa8f36bb42a5a0260f2f82ebb67c920d8a63", "message": "Clarify", "committedDate": "2020-06-19T21:47:24Z", "type": "commit"}, {"oid": "473551fad0b84f9fa8f85dc6ade5cec7cec4b7b2", "url": "https://github.com/confluentinc/ksql/commit/473551fad0b84f9fa8f85dc6ade5cec7cec4b7b2", "message": "Add open question", "committedDate": "2020-06-19T21:59:36Z", "type": "commit"}, {"oid": "ca19c1c1a8230cb5cad347e898eccc4dcef1214a", "url": "https://github.com/confluentinc/ksql/commit/ca19c1c1a8230cb5cad347e898eccc4dcef1214a", "message": "Add to description", "committedDate": "2020-06-19T23:15:10Z", "type": "commit"}, {"oid": "985af883bd4af67f58da20976bd56a9ff8d0b1a5", "url": "https://github.com/confluentinc/ksql/commit/985af883bd4af67f58da20976bd56a9ff8d0b1a5", "message": "Add to description", "committedDate": "2020-06-19T23:20:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NzA5Ng==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443077096", "bodyText": "This seems a little complex for something you could implement as reduce_array(arr, (x, y) => x + y).  How do you imagine this being used with reduce_* functions?  This seems like it would be a separate replacement  for functional reduce, with labmdas implemented a little differently.", "author": "AlanConfluent", "createdAt": "2020-06-19T23:30:42Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregates should not be allowed (please see *[Open questions](#open-questions)* section)\n+* `SELECT` subqueries should not be allowed\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_map(map, (k, v) => x, y)` - Applies the given lambda function to each key-value pair of the input `Map`, returning a new `Map` containing the transformed key-value pairs.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**\n+\n+- `agg_array(arr, x => sum(x))`", "originalCommit": "985af883bd4af67f58da20976bd56a9ff8d0b1a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA4MTI3Nw==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443081277", "bodyText": "sum is actually not the best example here. What about aggregates with non-scalar intermediate state, such as avg? And it wouldn't necessarily have to work with reduce_*. If we were going to do this I think we'd want to make a separate invocation function that applies an aggregation over the input collection.", "author": "derekjn", "createdAt": "2020-06-20T00:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NzA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE2MDQ0NA==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443160444", "bodyText": "The more I think about this, the more it feels like using a builtin aggregate expression within a lambda function doesn't really semantically make sense. I think we could theoretically do it but the example here isn't technically functional so it feels wrong. e.g there is nothing passed into the lambda that would tell each invocation where the last one left off.\nI think that if we wanted to support aggregations over collections, we'd want to do it with some kind of apply function:\nSELECT apply_array(arr, sum) ...\nSELECT apply_array(arr, avg) ...\nSubqueries would probably be more SQL-like:\nSELECT (SELECT sum(explode(arr))) ...\nI don't think either of these should be within the scope of this KLIP though. I think we can consider this question closed for the purposes of this KLIP.", "author": "derekjn", "createdAt": "2020-06-20T21:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NzA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjU2MQ==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443156561", "bodyText": "Above you state: Aggregates should not be allowed -- seems to be a contradiction?", "author": "mjsax", "createdAt": "2020-06-20T20:08:23Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregates should not be allowed (please see *[Open questions](#open-questions)* section)\n+* `SELECT` subqueries should not be allowed\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_map(map, (k, v) => x, y)` - Applies the given lambda function to each key-value pair of the input `Map`, returning a new `Map` containing the transformed key-value pairs.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.", "originalCommit": "985af883bd4af67f58da20976bd56a9ff8d0b1a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1OTQ1NQ==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443159455", "bodyText": "By aggregates I meant aggregate functions such as sum, count, avg etc. I will clarify since you are correct that reduce_* is a kind of aggregate.", "author": "derekjn", "createdAt": "2020-06-20T20:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzczMzMxOA==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443733318", "bodyText": "I clarified the restriction in question.", "author": "derekjn", "createdAt": "2020-06-22T17:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4ODAwOA==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r487188008", "bodyText": "Could you elaborate a bit why reduce would be allowed but other sum/count/avg etc would not? I think implementation wise they would be the same. And if we are concerned about inferring the return data type the other transform_map would already have this problem anyways.", "author": "guozhangwang", "createdAt": "2020-09-11T17:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjYwMQ==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443156601", "bodyText": "Are we sure, that allowing multiple return values does not cause problems?", "author": "mjsax", "createdAt": "2020-06-20T20:09:19Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregates should not be allowed (please see *[Open questions](#open-questions)* section)\n+* `SELECT` subqueries should not be allowed\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_map(map, (k, v) => x, y)` - Applies the given lambda function to each key-value pair of the input `Map`, returning a new `Map` containing the transformed key-value pairs.", "originalCommit": "985af883bd4af67f58da20976bd56a9ff8d0b1a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1OTcxMw==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443159713", "bodyText": "I'm not super familiar with the internals but I am guessing that this would require quite a bit of effort since we don't really return tuples anywhere that I know of. Perhaps it would be worth separating transform_map out into transform_keys and transform_values? You could easily combine those to effectively get what transform_map would give you anyways:\ntransform_keys(transform_values(m, v => expr(v)), k => expr(k))\n\nI think this approach might even be preferable, as in this case the lambda function is only applied to one \"thing\" at a time. It feels a little weird to apply a lambda function to a key and value simultaneously.", "author": "derekjn", "createdAt": "2020-06-20T21:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2NTQ3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443665472", "bodyText": "I updated the proposal to use transform_keys and transform_values instead of transform_map.", "author": "derekjn", "createdAt": "2020-06-22T16:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5NzE3Mw==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443797173", "bodyText": "I don't know the code details either. Would need input from an kslqDB engineer on this.", "author": "mjsax", "createdAt": "2020-06-22T20:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjgxNw==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443156817", "bodyText": "This might be a good idea.", "author": "mjsax", "createdAt": "2020-06-20T20:13:10Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregates should not be allowed (please see *[Open questions](#open-questions)* section)\n+* `SELECT` subqueries should not be allowed\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_map(map, (k, v) => x, y)` - Applies the given lambda function to each key-value pair of the input `Map`, returning a new `Map` containing the transformed key-value pairs.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**\n+\n+- `agg_array(arr, x => sum(x))`\n+\n+If this is feasible then it would likely be worth doing. Without support for aggregates, users will not be able to easily perform any aggregation over a collection using `reduce_*`.\n+\n+**2. Would allowing lambda functions to be applied to types other than `Array` or `Map` provide any value?**\n+\n+**3. Will the lambda function implementation require backward-incompatible changes to ksqlDB's internals?**\n+\n+**4. Should we extend ksqlDB's UDF interface to allow users to write their own lambda invocation functions?**", "originalCommit": "985af883bd4af67f58da20976bd56a9ff8d0b1a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1Njk2OA==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443156968", "bodyText": "I guess lambdas make sense for any \"collection\" data type. For scalar types, they seem useless because instead of writing (x,y) => x + y and apply it to two integers, one can just use the expression x + y of the lambda directly.", "author": "mjsax", "createdAt": "2020-06-20T20:15:59Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregates should not be allowed (please see *[Open questions](#open-questions)* section)\n+* `SELECT` subqueries should not be allowed\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_map(map, (k, v) => x, y)` - Applies the given lambda function to each key-value pair of the input `Map`, returning a new `Map` containing the transformed key-value pairs.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**\n+\n+- `agg_array(arr, x => sum(x))`\n+\n+If this is feasible then it would likely be worth doing. Without support for aggregates, users will not be able to easily perform any aggregation over a collection using `reduce_*`.\n+\n+**2. Would allowing lambda functions to be applied to types other than `Array` or `Map` provide any value?**", "originalCommit": "985af883bd4af67f58da20976bd56a9ff8d0b1a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE2MDA1MQ==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r443160051", "bodyText": "My thoughts exactly but I wasn\u2019t sure if I was missing something.", "author": "derekjn", "createdAt": "2020-06-20T21:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1Njk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDU5Ng==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r449650596", "bodyText": "I don't think it works for STRUCT given the disparate field types.  I don't think SQL can express how to handle the different types.", "author": "big-andy-coates", "createdAt": "2020-07-03T16:18:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1Njk2OA=="}], "type": "inlineReview"}, {"oid": "23f6262511f90de5345ead91fa1f8ebea6ff1289", "url": "https://github.com/confluentinc/ksql/commit/23f6262511f90de5345ead91fa1f8ebea6ff1289", "message": "Close open question (1)", "committedDate": "2020-06-20T21:20:18Z", "type": "commit"}, {"oid": "c4ecd6c81cec7e5e2f8548f2d408facf4e198b15", "url": "https://github.com/confluentinc/ksql/commit/c4ecd6c81cec7e5e2f8548f2d408facf4e198b15", "message": "Replace transform_map with transform_keys/transform_values", "committedDate": "2020-06-22T15:54:56Z", "type": "commit"}, {"oid": "ba4ced49d953632e1edaf65eabb1383bfabb853d", "url": "https://github.com/confluentinc/ksql/commit/ba4ced49d953632e1edaf65eabb1383bfabb853d", "message": "Clarify restriction around aggregate calls within lambda functions", "committedDate": "2020-06-22T17:58:17Z", "type": "commit"}, {"oid": "5f5f44e4d3da2d19574970598eff41352ceec6cd", "url": "https://github.com/confluentinc/ksql/commit/5f5f44e4d3da2d19574970598eff41352ceec6cd", "message": "Use v instead of k", "committedDate": "2020-06-22T19:22:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0OTY0MA==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444549640", "bodyText": "just some thoughts about the implementation - we'd need to be able to determine the output type (in this case, y) in order to know the type of the output. Given that y is just a SQL expression and that we know the input types, we should be able to infer this. I'm wondering if there's ever a time when it's not possible to infer but I don't think that'll be the case", "author": "agavra", "createdAt": "2020-06-23T22:47:27Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.", "originalCommit": "5f5f44e4d3da2d19574970598eff41352ceec6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NDQ2Mg==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r449644462", "bodyText": "There'll defo be cases where the sql type of the expression is unknown or ambiguous:\n\nAnything returning null would be unknown, e.g. a user wanting to create a copy of an array where all the elements are null:  transform_array(arry, x => null)\nAnything accepting a literal may be ambiguous(ish), e.g. INT vs BIGINT,\n\nThat said, requiring users to CAST nulls seems pretty acceptable, and the same goes for literals that don't auto-convert to the type the user wants e.g. CAST(20 AS BIGINT).\nSo I think all we need is test cases for the null cases to ensure the user gets a meaningful error and not something confusing or an NPE.", "author": "big-andy-coates", "createdAt": "2020-07-03T15:57:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0OTY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1MTc5MA==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444551790", "bodyText": "I think we're missing a section here on how these functions would be defined (likely as UDFs) in the ksql code base. Perhaps we'd be looking at something like:\n@UdfDescription(name=\"transform_array\", description=\"...\") \npublic class TransformArray {\n  \n  @Udf\n  public <S, T> List<T> transform(List<S> array, Function<S, T> valueTransform) {\n    ...\n  }\n}\nSince these lambda functions mostly make sense in the context of collections, we need to make sure that we support generics as above (I think we do)", "author": "agavra", "createdAt": "2020-06-23T22:53:57Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions", "originalCommit": "5f5f44e4d3da2d19574970598eff41352ceec6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU2MTg3Mw==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444561873", "bodyText": "Good idea. Would you mind committing a new section to the KLIP with signatures for each invocation function? I'm not too familiar with the UDF code...", "author": "derekjn", "createdAt": "2020-06-23T23:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1MTc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1MjgxOA==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444552818", "bodyText": "This doesn't really make sense to me from a functional programming perspective. A lambda is stateless, how can it have an aggregation inside of it? The canonical solution to aggregate a list in functional programming is to use reduce and I think diverging from that would just confuse things, not simplify.", "author": "agavra", "createdAt": "2020-06-23T22:57:10Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+~~**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**~~\n+\n+~~- `agg_array(arr, x => sum(x))`~~", "originalCommit": "5f5f44e4d3da2d19574970598eff41352ceec6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU2MDc5Mw==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444560793", "bodyText": "Agreed: #5661 (comment)\nI think we can consider this question closed.", "author": "derekjn", "createdAt": "2020-06-23T23:22:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1MjgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1Mzc2OQ==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444553769", "bodyText": "I think another valuable question is if we should support lambdas in UDAFs. For example we could have COUNTIF(col, x -> shouldKeep) (so essentially flipping this open question upside down \ud83d\ude02 )", "author": "agavra", "createdAt": "2020-06-23T22:59:57Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+~~**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**~~", "originalCommit": "5f5f44e4d3da2d19574970598eff41352ceec6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1OTkyNQ==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444559925", "bodyText": "COUNTIF(col, x -> shouldKeep)\n\nWould lambdas enable any new capabilities in this context? For example, what about this:\nSELECT COUNT(CASE WHEN shouldKeep THEN col ELSE null END) ...\n\nHaving lambdas here would definitely simplify things but I'm trying to understand if they'd give users anything net new.", "author": "derekjn", "createdAt": "2020-06-23T23:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1Mzc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU2MjM3OQ==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444562379", "bodyText": "I'd have to give it a think, I'm not sure I can come up with anything off the top of my head", "author": "agavra", "createdAt": "2020-06-23T23:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1Mzc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0OTUyMg==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r449649522", "bodyText": "Would it not be possible to allow users to build their own UDAFs from lambdas by just providing a few build-in UDAFs called udaf:\n-- Simple type:\n-- col0: the input to aggregate\n-- initial: initial agg value.\n-- (col0, agg) => agg: the lambda that takes the current value and aggregate and calcs a new agg.\nudaf(col0, initial, (col0, agg) => agg)\n\n-- Extended to support different intermediate schema:\n-- col0: the input to aggregate\n-- initial: initial agg value.\n-- (col0, m) => m: updates aggregate (with intermediate schema)\n-- m => f, converts intermediate schema to final schema.\nudaf(col0, initial, (col0, m) => m, m => f)\n\n-- Session windows need a merge function too, so we'd need a session variant:\n-- as above, plus:\n-- (f1, f2) => merged: merge two sessions together\nudaf(col0, initial, (col0, m) => m, (m1, m2) => merged, m => f)\n\nI think just these few udafs would allow users to build custom aggregators using CASE statements for flow control, and build-in functions and operators.\nWe can extend the above with multiple parameter variants:\nudaf(col0, initial, (col0, agg) => agg)\nudaf(col0, col1, initial, (col0, col1, agg) => agg)\nudaf(col0, col2, col3, initial, (col0, col1, col3, agg) => agg)\n... etc.\n\nOf course, to do this we'd first need to do this: https://github.com/confluentinc/ksql/projects/4 (which I'm trying to get prioritized, as its a blocker for a lot of UDAF improvements).", "author": "big-andy-coates", "createdAt": "2020-07-03T16:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1Mzc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDQ4Nw==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444554487", "bodyText": "it should be from my perspective!", "author": "agavra", "createdAt": "2020-06-23T23:02:10Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+~~**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**~~\n+\n+~~- `agg_array(arr, x => sum(x))`~~\n+\n+~~If this is feasible then it would likely be worth doing. Without support for aggregates, users will not be able to easily perform any aggregation over a collection using `reduce_*`.~~\n+\n+**2. Would allowing lambda functions to be applied to types other than `Array` or `Map` provide any value?**\n+\n+**3. Will the lambda function implementation require backward-incompatible changes to ksqlDB's internals?**", "originalCommit": "5f5f44e4d3da2d19574970598eff41352ceec6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU2MDIyNw==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444560227", "bodyText": "Are you saying that the implementation shouldn't introduce backward-incompatible changes to the internals?", "author": "derekjn", "createdAt": "2020-06-23T23:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDQ4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU2MjE1MA==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444562150", "bodyText": "yup, at least that's what I think...", "author": "agavra", "createdAt": "2020-06-23T23:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDQ4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MTk3MA==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r449651970", "bodyText": "What are you thinking @agavra?  Breaking changes to the UDF framework or engine internals?  Feels like this would only be a breaking change for the former.", "author": "big-andy-coates", "createdAt": "2020-07-03T16:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDQ4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM4MDEyNw==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r450380127", "bodyText": "why would this even be a breaking change for the former? EDIT: I just read my original comment, I had meant to say that i don't think we'd need any breaking changes.", "author": "agavra", "createdAt": "2020-07-06T17:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDY5NQ==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444554695", "bodyText": "ah, see my comment above - I was thinking that we'd implement this as a UDF ourselves \ud83d\ude02 kill two birds with one UDF", "author": "agavra", "createdAt": "2020-06-23T23:02:51Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+~~**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**~~\n+\n+~~- `agg_array(arr, x => sum(x))`~~\n+\n+~~If this is feasible then it would likely be worth doing. Without support for aggregates, users will not be able to easily perform any aggregation over a collection using `reduce_*`.~~\n+\n+**2. Would allowing lambda functions to be applied to types other than `Array` or `Map` provide any value?**\n+\n+**3. Will the lambda function implementation require backward-incompatible changes to ksqlDB's internals?**\n+\n+**4. Should we extend ksqlDB's UDF interface to allow users to write their own lambda invocation functions?**", "originalCommit": "5f5f44e4d3da2d19574970598eff41352ceec6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU2MDA1Nw==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444560057", "bodyText": "Sounds ideal to me!", "author": "derekjn", "createdAt": "2020-06-23T23:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU2MjE0Nw==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444562147", "bodyText": "I'm going to close this open question since it seems like adding this to the UDF infrastructure is the right way to go here.", "author": "derekjn", "createdAt": "2020-06-23T23:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDY5NQ=="}], "type": "inlineReview"}, {"oid": "ca03ac2f4c98e18dabcaa8a2fd2da8ec7653b749", "url": "https://github.com/confluentinc/ksql/commit/ca03ac2f4c98e18dabcaa8a2fd2da8ec7653b749", "message": "Close open question (4)", "committedDate": "2020-06-23T23:27:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk4OTA2OQ==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r444989069", "bodyText": "I don't think there'd be any issues reusing -> and if we encountered any during development we could switch to =>.\nIs there any other SQL systems that support lambda functions?  If so, what syntax do they use?\nI did a quick google search, and aside from the AWS lambda noise, the only think lambda + SQL that I managed to find was https://openproceedings.org/2019/conf/edbt/EDBT19_paper_3.pdf, which I've never heard of and uses a strange \u03bb(a, b) (a * b) syntax.\nAs you say, we use -> for field access, and I think this is pretty none-standard.  For example, Postgres uses a . to access a custom types field.  If this is a standard pattern for accessing fields in custom types, then we may want to consider switching anyway, following a period of supporting both -> and . for field access.\nI'm not strongly suggesting we do any of this - just highlighting it's an option.", "author": "big-andy-coates", "createdAt": "2020-06-24T15:40:01Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:", "originalCommit": "ca03ac2f4c98e18dabcaa8a2fd2da8ec7653b749", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ0NjI0OA==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r450446248", "bodyText": "IIRC, there was quite a discussion about . vs -> notation to access nested fields. Might be worth to dig out?\nEven if overloading -> might work, it could be hard to read, eg, transform_array(myArray, e->e->a) ? Using e=>e->a would easier to read. Or would we require parenthesis: e->(e->a) ?", "author": "mjsax", "createdAt": "2020-07-06T19:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk4OTA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTE1Nw==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r449645157", "bodyText": "What about a transform_map method that allows the user to convert both keys and values together, e.g.\ntransform_map(map, (k, v) => newKey, (k, v) => newValue)\nSo it takes two lambda, but each lambda only returns a single value (to keep things simple).  Definitely worth passing the both key and value to each lambda.", "author": "big-andy-coates", "createdAt": "2020-07-03T16:00:02Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+", "originalCommit": "ca03ac2f4c98e18dabcaa8a2fd2da8ec7653b749", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3NTI5MA==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r450375290", "bodyText": "This seems like a good idea. The original proposal included a transform_map invocation function that looked like this:\ntransform_map(m, (k, v) => x, y)\n\nBut adding support for returning multiple values would probably be a lot of work so I broke it into transform_keys and transform_values. I think it would make sense to support a variant that simply took two lambdas though. I'll add this to the proposal.", "author": "derekjn", "createdAt": "2020-07-06T17:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ0Njg4Ng==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r450446886", "bodyText": "Would setting a new key not potentially be \"undefined\", ie, if two entries map to the same new key?", "author": "mjsax", "createdAt": "2020-07-06T19:54:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM0MzM0OA==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r462343348", "bodyText": "Would setting a new key not potentially be \"undefined\", ie, if two entries map to the same new key?\n\nI think you're right.\nIf we define the order of iteration of the entries in a MAP, then we could support the processing of a later entry overwriting a previous output entry, or support ignoring any subsequent results that clash with an existing key.\nIf we wish the SQL MAP type to be an unordered collection, choosing to keep either the first or last entry of a collisions would introduce nondeterminism. So we either say the result is undefined or we throw an exception, i.e. log an error and populate the result with NULL.\nIMHO, we should keep the SQL MAP type an unordered collection, and of the two ways to handle key collisions when transforming an unordered MAP, the undefined result seems the lesser of two evils.", "author": "big-andy-coates", "createdAt": "2020-07-29T14:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MTUxMQ==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r449651511", "bodyText": "How about some flatMap style transforms?  Not sure what's the best SQLy name, but something where the lambda can return zero or more elements. For want of a better name 'flatmap_array(array, e => e[])`.\nThis is basically lambdas for table functions.\nThis could be used, for example, to convert ARRAY<ARRAY<INT>> into ARRAY<INT> with flatmap_array(array. e => e).\nUsers can then build more complex UDTFs using CASE for flow and our functions and operators.", "author": "big-andy-coates", "createdAt": "2020-07-03T16:22:31Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,123 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions", "originalCommit": "ca03ac2f4c98e18dabcaa8a2fd2da8ec7653b749", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b0afaea73f3204220c9e372369d956abb493a298", "url": "https://github.com/confluentinc/ksql/commit/b0afaea73f3204220c9e372369d956abb493a298", "message": "Add transform_map invocation function", "committedDate": "2020-07-06T17:35:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4NzM2MQ==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r487187361", "bodyText": "For functions that may result in ambiguous types of new_k, new_v e.g. such that KSQL cannot infer the new schema field types, would we require users to specify the return value types in their lambda function? If yes, how we would enforce this?", "author": "guozhangwang", "createdAt": "2020-09-11T17:28:26Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,125 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `transform_map(map, (k, v) => new_k, (k, v) => new_v)` - Applies the given lambda functions to the keys and values of the input `Map`, respectively. A new `Map` containing the transformed keys and values is returned.", "originalCommit": "b0afaea73f3204220c9e372369d956abb493a298", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4ODgyOA==", "url": "https://github.com/confluentinc/ksql/pull/5661#discussion_r487188828", "bodyText": "If we allow own lambda invocation functions, how that would impact our existing new query creation process? Would that require an extra step of loading user jars e.g.?", "author": "guozhangwang", "createdAt": "2020-09-11T17:31:19Z", "path": "design-proposals/klip-30-lambda-functions.md", "diffHunk": "@@ -0,0 +1,125 @@\n+# KLIP-30 - Lambda Expressions\n+\n+**Authors**: derekjn, blueedgenick |\n+**Release Target**: N/A |\n+**Status**: _In Discussion_ |\n+**Discussion**: [#5661](https://github.com/confluentinc/ksql/pull/5661)\n+\n+**tl;dr**: The introduction of lambda functions would bridge the gap somewhat between builtins and UDFs.\n+\n+## Motivation and background\n+\n+While ksqlDB\u2019s UDF interface makes it relatively easy for users to add their own functionality to invoke within their queries, the process of implementing and deploying a UDF is not particularly straightforward. Furthermore, the deployment of UDFs may not even be an option in some environments. Without UDFs, users are at the mercy of ksqlDB\u2019s builtins, which may not always provide enough functionality for them to solve their specific problems. This can be particularly problematic with collections (i.e. `Array` and `Map`), as it can be awkward to work with all of their individual values within a single query. However, we can mitigate this limitation somewhat by empowering users to express user-defined functionality in a way that doesn\u2019t require them to implement full-fledged UDFs.\n+\n+Introducing lambda functions would enable users to express simple inline functions that can be applied to input values in various ways. For example, lambda functions could be applied to each element of a collection, resulting in a transformed output collection. Lambda functions could also be used to filter the elements of a collection, or reduce a collection down to a single value.\n+\n+The remainder of this document will propose the addition of lambda functions into ksqlDB\u2019s grammar and execution engine.\n+\n+## Scope\n+\n+### What is in scope\n+\n+* Syntax for defining lambda functions will be proposed\n+* Lambda invocation functions will be proposed\n+\n+## What is not in scope\n+\n+* Implementation details will not be proposed\n+* Level of effort will not be estimated\n+\n+## Value/return\n+\n+The introduction of lambda functions will ultimately empower ksqDB users to solve more problems with less effort. Many of the UDFs we\u2019ve seen users write are designed to apply relatively simple functionality to the elements of `Arrays` and `Maps`. Lambda functions are well-suited to solve this class of problems in a very easy and intuitive way.\n+\n+Lambda functions will also enable some users to use ksqlDB in environments that do not allow for the deployment of UDFs.\n+\n+## Public APIs\n+\n+There are two aspects of the user-facing lambda function interface: syntax for describing the actual lambda functions, and a way to specify how to apply these functions to input values.\n+\n+## Design\n+\n+### Syntax\n+\n+It would probably be ideal to use Java-style lambda syntax, but we already use the `->` symbol to represent `Struct` field lookups. Giving `->` a double meaning (if that\u2019s even possible) would create ambiguity and complexity in the grammar/parser. We therefore propose using the `=>` symbol to signify a lambda function:\n+\n+```\n+arg => expr\n+```\n+\n+This expression represents the following:\n+\n+* `arg` is the argument passed into the scope of each invocation of the lambda function.\n+* `expr` is the \"body\" of the lambda function. Each invocation of the lambda function will evaluate this expression and return the result.\n+\n+Multiple arguments should also be allowed for lambda functions. When multiple arguments are used, they should be wrapped in parentheses:\n+\n+```\n+(x, y) => expr\n+```\n+\n+#### Allowed expressions\n+\n+The body of each lambda function should simply be **any expression that could be used in a `SELECT` expression list**, with some exceptions:\n+\n+* Aggregate function calls (e.g. `sum`, `count`, `avg`) should not be allowed (please see *[Open questions](#open-questions)* section). Note that simple aggregations are still possible with the `reduce_*` invocation functions.\n+* `SELECT` subqueries should not be allowed.\n+\n+#### Examples\n+\n+Given these restrictions, the following examples would be valid lambda functions:\n+\n+* `x => x + 1`\n+* `s => UCASE(s)`\n+* `(x, y) => x + y`\n+* `(x, y) => CASE WHEN x IS NULL THEN y ELSE x + y END`\n+* `(x, y) => x + COALESCE(y, 0)`\n+\n+### Invocation functions\n+\n+Lambda functions should require a specific **invocation function**, which tells ksqlDB how to apply the given lambda function to an input value, and what kind of result to return. The following invocation functions are proposed for the initial support for lambda functions:\n+\n+* `transform_array(arr, x => y)` - Applies the given lambda function to each element of the input `Array`, returning a new `Array` containing the transformed output.\n+\n+* `transform_keys(map, k => k)` - Applies the given lambda function to each key in the input `Map`, returning a new `Map` containing the transformed keys.\n+\n+* `transform_values(map, v => v)` - Applies the given lambda function to each value in the input `Map`, returning a new `Map` containing the transformed values.\n+\n+* `transform_map(map, (k, v) => new_k, (k, v) => new_v)` - Applies the given lambda functions to the keys and values of the input `Map`, respectively. A new `Map` containing the transformed keys and values is returned.\n+\n+* `filter_array(arr, x => bool)` - Filters the input `Array` using the given lambda function. A new `Array` is returned, containing only values for which the lambda function evaluated to `true`.\n+\n+* `filter_map(map, (k, v) => bool)` - Filters the input `Map` using the given lambda function. A new `Map` is returned, containing only the key-value pairs for which the lambda function evaluated to `true`.\n+\n+* `reduce_array(arr, s, (x, s) => s)` - Reduces the input `Array` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_array` will return the final value of `s`.\n+\n+* `reduce_map(map, s, (k, v, s) => s)` - Reduces the input `Map` down to a single value. `s` is the initial state and is passed into the scope of the lambda function. Each invocation returns a new value for `s`, which the next invocation will receive. `reduce_map` will return the final value of `s`.\n+\n+## Documentation updates\n+\n+We must document and provide examples for the two core aspects of lambda functions:\n+\n+1. Lambda function syntax\n+2. Invocation functions\n+\n+## Compatibility implications\n+\n+Lambda functions would be additive to ksqlDB's grammar and should therefore not introduce any incompatibilities into the grammar or public APIs. However, it is not currently known if a lambda function implementation would require backward-incompatible changes to ksqlDB's internals.\n+\n+## Security implications\n+\n+Since lambda functions would only allow SQL expressions that can already be used within queries, no new security implications should be introduced.\n+\n+## Open questions\n+\n+~~**1. Would it be possible to allow aggregates in lambdas within the context of a particular invocation function? For example,**~~\n+\n+~~- `agg_array(arr, x => sum(x))`~~\n+\n+~~If this is feasible then it would likely be worth doing. Without support for aggregates, users will not be able to easily perform any aggregation over a collection using `reduce_*`.~~\n+\n+**2. Would allowing lambda functions to be applied to types other than `Array` or `Map` provide any value?**\n+\n+**3. Will the lambda function implementation require backward-incompatible changes to ksqlDB's internals?**\n+\n+~~**4. Should we extend ksqlDB's UDF interface to allow users to write their own lambda invocation functions?**~~", "originalCommit": "b0afaea73f3204220c9e372369d956abb493a298", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1406e554cc313663619843996509ca4df52562ba", "url": "https://github.com/confluentinc/ksql/commit/1406e554cc313663619843996509ca4df52562ba", "message": "Use UDF interface", "committedDate": "2020-10-08T20:54:37Z", "type": "commit"}, {"oid": "c0764d53b46e337e1a92c3dc377d6161688423ea", "url": "https://github.com/confluentinc/ksql/commit/c0764d53b46e337e1a92c3dc377d6161688423ea", "message": "Merge master", "committedDate": "2020-10-08T20:58:19Z", "type": "commit"}]}