{"pr_number": 6085, "pr_title": "fix: properly handle restore on CREATE OR REPLACE", "pr_createdAt": "2020-08-24T18:15:49Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6085", "timeline": [{"oid": "1d14b4831dfce598dc44fb4c2fbed21d5c53f135", "url": "https://github.com/confluentinc/ksql/commit/1d14b4831dfce598dc44fb4c2fbed21d5c53f135", "message": "fix: properly handle restore on CREATE OR REPLACE", "committedDate": "2020-08-24T18:45:16Z", "type": "commit"}, {"oid": "1d14b4831dfce598dc44fb4c2fbed21d5c53f135", "url": "https://github.com/confluentinc/ksql/commit/1d14b4831dfce598dc44fb4c2fbed21d5c53f135", "message": "fix: properly handle restore on CREATE OR REPLACE", "committedDate": "2020-08-24T18:45:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyNDY0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6085#discussion_r475824649", "bodyText": "So, you create a compacted node even for the previous queries that have been replaced?", "author": "vpapavas", "createdAt": "2020-08-24T18:50:34Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java", "diffHunk": "@@ -50,73 +45,92 @@ private RestoreCommandsCompactor() {\n    * @return the compacted list of commands.\n    */\n   static List<QueuedCommand> compact(final List<QueuedCommand> restoreCommands) {\n-    final List<QueuedCommand> compacted = new LinkedList<>(restoreCommands);\n-\n-    final Set<QueuedCommand> terminatedQueries =\n-        findTerminatedQueriesAndRemoveTerminateCommands(compacted);\n+    final Map<QueryId, CompactedNode> latestNodeWithId = new HashMap<>();\n+    CompactedNode current = null;\n+\n+    for (final QueuedCommand cmd : restoreCommands) {\n+      // Whenever a new command is processed, we check if a previous command with\n+      // the same queryID exists - in which case, we mark that command as \"shouldSkip\"\n+      // and it will not be included in the output\n+      current = CompactedNode.of(current, cmd, latestNodeWithId);\n+    }\n \n-    removeQueryPlansOfTerminated(compacted, terminatedQueries);\n+    final List<QueuedCommand> compacted = new LinkedList<>();\n+    while (current != null) {\n+      // traverse backwards and add each next node to the start of the list\n+      compact(current).ifPresent(cmd -> compacted.add(0, cmd));\n+      current = current.prev;\n+    }\n \n     return compacted;\n   }\n \n-  private static Set<QueuedCommand> findTerminatedQueriesAndRemoveTerminateCommands(\n-      final List<QueuedCommand> commands\n-  ) {\n-    final Map<QueryId, QueuedCommand> queries = new HashMap<>();\n-    final Set<QueuedCommand> terminatedQueries = Collections.newSetFromMap(new IdentityHashMap<>());\n-\n-    final Iterator<QueuedCommand> it = commands.iterator();\n-    while (it.hasNext()) {\n-      final QueuedCommand cmd = it.next();\n-\n-      // Find known queries:\n-      final Command command =\n-          cmd.getAndDeserializeCommand(InternalTopicSerdes.deserializer(Command.class));\n-      if (command.getPlan().isPresent()\n-          && command.getPlan().get().getQueryPlan().isPresent()\n-      ) {\n-        final QueryId queryId =\n-            command.getPlan().get().getQueryPlan().get().getQueryId();\n-        queries.putIfAbsent(queryId, cmd);\n+  private static final class CompactedNode {\n+\n+    final CompactedNode prev;\n+    final QueuedCommand queued;\n+    final Command command;\n+\n+    boolean shouldSkip = false;\n+\n+    public static CompactedNode of(\n+        final CompactedNode prev,\n+        final QueuedCommand queued,\n+        final Map<QueryId, CompactedNode> latestNodeWithId\n+    ) {\n+      final Command command = queued.getAndDeserializeCommand(\n+          InternalTopicSerdes.deserializer(Command.class)\n+      );\n+\n+      final Optional<KsqlPlan> plan = command.getPlan();\n+      if (queued.getAndDeserializeCommandId().getType() == Type.TERMINATE) {\n+        final QueryId queryId = new QueryId(queued.getAndDeserializeCommandId().getEntity());\n+        markShouldSkip(queryId, latestNodeWithId);\n+\n+        // terminate commands don't get added to the list of commands to execute\n+        // because we \"execute\" them in this class by removing query plans from\n+        // terminated queries\n+        return prev;\n+      } else if (!plan.isPresent() || !plan.get().getQueryPlan().isPresent()) {\n+        // DDL\n+        return new CompactedNode(prev, queued, command);\n       }\n \n-      // Find TERMINATE's that match known queries:\n-      if (cmd.getAndDeserializeCommandId().getType() == Type.TERMINATE) {\n-        final QueryId queryId = new QueryId(cmd.getAndDeserializeCommandId().getEntity());\n-        final QueuedCommand terminated = queries.remove(queryId);\n-        if (terminated != null) {\n-          terminatedQueries.add(terminated);\n-          it.remove();\n-        }\n-      }\n-    }\n+      final QueryId queryId = plan.get().getQueryPlan().get().getQueryId();\n+      markShouldSkip(queryId, latestNodeWithId);\n+      final CompactedNode node = new CompactedNode(prev, queued, command);", "originalCommit": "1d14b4831dfce598dc44fb4c2fbed21d5c53f135", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyNTIxOA==", "url": "https://github.com/confluentinc/ksql/pull/6085#discussion_r475825218", "bodyText": "yes, we create the node when we hit the command because we don't know at the time whether or not it will be compacted. later, when we see another node with the same queryId, we mark the older one as compacted (shouldSkip)", "author": "agavra", "createdAt": "2020-08-24T18:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyNDY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyNTI2MA==", "url": "https://github.com/confluentinc/ksql/pull/6085#discussion_r475825260", "bodyText": "Ah, but every time you replace it when you find a new one. OK.", "author": "vpapavas", "createdAt": "2020-08-24T18:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyNDY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzMjgxNg==", "url": "https://github.com/confluentinc/ksql/pull/6085#discussion_r475832816", "bodyText": "nit: consider renaming to something like maybeAppend - I usually read of as constructing a new object", "author": "rodesai", "createdAt": "2020-08-24T19:06:01Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java", "diffHunk": "@@ -50,73 +45,92 @@ private RestoreCommandsCompactor() {\n    * @return the compacted list of commands.\n    */\n   static List<QueuedCommand> compact(final List<QueuedCommand> restoreCommands) {\n-    final List<QueuedCommand> compacted = new LinkedList<>(restoreCommands);\n-\n-    final Set<QueuedCommand> terminatedQueries =\n-        findTerminatedQueriesAndRemoveTerminateCommands(compacted);\n+    final Map<QueryId, CompactedNode> latestNodeWithId = new HashMap<>();\n+    CompactedNode current = null;\n+\n+    for (final QueuedCommand cmd : restoreCommands) {\n+      // Whenever a new command is processed, we check if a previous command with\n+      // the same queryID exists - in which case, we mark that command as \"shouldSkip\"\n+      // and it will not be included in the output\n+      current = CompactedNode.of(current, cmd, latestNodeWithId);\n+    }\n \n-    removeQueryPlansOfTerminated(compacted, terminatedQueries);\n+    final List<QueuedCommand> compacted = new LinkedList<>();\n+    while (current != null) {\n+      // traverse backwards and add each next node to the start of the list\n+      compact(current).ifPresent(cmd -> compacted.add(0, cmd));\n+      current = current.prev;\n+    }\n \n     return compacted;\n   }\n \n-  private static Set<QueuedCommand> findTerminatedQueriesAndRemoveTerminateCommands(\n-      final List<QueuedCommand> commands\n-  ) {\n-    final Map<QueryId, QueuedCommand> queries = new HashMap<>();\n-    final Set<QueuedCommand> terminatedQueries = Collections.newSetFromMap(new IdentityHashMap<>());\n-\n-    final Iterator<QueuedCommand> it = commands.iterator();\n-    while (it.hasNext()) {\n-      final QueuedCommand cmd = it.next();\n-\n-      // Find known queries:\n-      final Command command =\n-          cmd.getAndDeserializeCommand(InternalTopicSerdes.deserializer(Command.class));\n-      if (command.getPlan().isPresent()\n-          && command.getPlan().get().getQueryPlan().isPresent()\n-      ) {\n-        final QueryId queryId =\n-            command.getPlan().get().getQueryPlan().get().getQueryId();\n-        queries.putIfAbsent(queryId, cmd);\n+  private static final class CompactedNode {\n+\n+    final CompactedNode prev;\n+    final QueuedCommand queued;\n+    final Command command;\n+\n+    boolean shouldSkip = false;\n+\n+    public static CompactedNode of(", "originalCommit": "1d14b4831dfce598dc44fb4c2fbed21d5c53f135", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzNDI3MA==", "url": "https://github.com/confluentinc/ksql/pull/6085#discussion_r475834270", "bodyText": "consider asserting that if there is a previous stream/table with this ID, that it doesn't have a query associated with it?", "author": "rodesai", "createdAt": "2020-08-24T19:08:42Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java", "diffHunk": "@@ -50,73 +45,92 @@ private RestoreCommandsCompactor() {\n    * @return the compacted list of commands.\n    */\n   static List<QueuedCommand> compact(final List<QueuedCommand> restoreCommands) {\n-    final List<QueuedCommand> compacted = new LinkedList<>(restoreCommands);\n-\n-    final Set<QueuedCommand> terminatedQueries =\n-        findTerminatedQueriesAndRemoveTerminateCommands(compacted);\n+    final Map<QueryId, CompactedNode> latestNodeWithId = new HashMap<>();\n+    CompactedNode current = null;\n+\n+    for (final QueuedCommand cmd : restoreCommands) {\n+      // Whenever a new command is processed, we check if a previous command with\n+      // the same queryID exists - in which case, we mark that command as \"shouldSkip\"\n+      // and it will not be included in the output\n+      current = CompactedNode.of(current, cmd, latestNodeWithId);\n+    }\n \n-    removeQueryPlansOfTerminated(compacted, terminatedQueries);\n+    final List<QueuedCommand> compacted = new LinkedList<>();\n+    while (current != null) {\n+      // traverse backwards and add each next node to the start of the list\n+      compact(current).ifPresent(cmd -> compacted.add(0, cmd));\n+      current = current.prev;\n+    }\n \n     return compacted;\n   }\n \n-  private static Set<QueuedCommand> findTerminatedQueriesAndRemoveTerminateCommands(\n-      final List<QueuedCommand> commands\n-  ) {\n-    final Map<QueryId, QueuedCommand> queries = new HashMap<>();\n-    final Set<QueuedCommand> terminatedQueries = Collections.newSetFromMap(new IdentityHashMap<>());\n-\n-    final Iterator<QueuedCommand> it = commands.iterator();\n-    while (it.hasNext()) {\n-      final QueuedCommand cmd = it.next();\n-\n-      // Find known queries:\n-      final Command command =\n-          cmd.getAndDeserializeCommand(InternalTopicSerdes.deserializer(Command.class));\n-      if (command.getPlan().isPresent()\n-          && command.getPlan().get().getQueryPlan().isPresent()\n-      ) {\n-        final QueryId queryId =\n-            command.getPlan().get().getQueryPlan().get().getQueryId();\n-        queries.putIfAbsent(queryId, cmd);\n+  private static final class CompactedNode {\n+\n+    final CompactedNode prev;\n+    final QueuedCommand queued;\n+    final Command command;\n+\n+    boolean shouldSkip = false;\n+\n+    public static CompactedNode of(\n+        final CompactedNode prev,\n+        final QueuedCommand queued,\n+        final Map<QueryId, CompactedNode> latestNodeWithId\n+    ) {\n+      final Command command = queued.getAndDeserializeCommand(\n+          InternalTopicSerdes.deserializer(Command.class)\n+      );\n+\n+      final Optional<KsqlPlan> plan = command.getPlan();\n+      if (queued.getAndDeserializeCommandId().getType() == Type.TERMINATE) {\n+        final QueryId queryId = new QueryId(queued.getAndDeserializeCommandId().getEntity());\n+        markShouldSkip(queryId, latestNodeWithId);\n+\n+        // terminate commands don't get added to the list of commands to execute\n+        // because we \"execute\" them in this class by removing query plans from\n+        // terminated queries\n+        return prev;\n+      } else if (!plan.isPresent() || !plan.get().getQueryPlan().isPresent()) {\n+        // DDL", "originalCommit": "1d14b4831dfce598dc44fb4c2fbed21d5c53f135", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg1NjAzMA==", "url": "https://github.com/confluentinc/ksql/pull/6085#discussion_r475856030", "bodyText": "I don't know how that would be possible? DDL commands don't have any associated queryID, so even though there might be sources with the same name previously, they wouldn't be the same query", "author": "agavra", "createdAt": "2020-08-24T19:52:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzNDI3MA=="}], "type": "inlineReview"}, {"oid": "a15cbfc61ff58b1bd9bb6257017cd782af4bf948", "url": "https://github.com/confluentinc/ksql/commit/a15cbfc61ff58b1bd9bb6257017cd782af4bf948", "message": "chore: rename method", "committedDate": "2020-08-24T19:56:55Z", "type": "commit"}]}