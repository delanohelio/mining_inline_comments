{"pr_number": 1318, "pr_title": "GG-30206: Enabled CPP Cluster API", "pr_createdAt": "2020-07-21T22:27:08Z", "pr_url": "https://github.com/gridgain/gridgain/pull/1318", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY5MzM3OA==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458693378", "bodyText": "Can you please explain this loop logic? Our BinaryObject format does not require looping like this, looks confusing.", "author": "ptupitsyn", "createdAt": "2020-07-22T10:27:04Z", "path": "modules/platforms/cpp/binary/src/impl/binary/binary_object_impl.cpp", "diffHunk": "@@ -40,6 +40,20 @@ namespace ignite\n             {\n                 if (idRslvr)\n                     this->idRslvr = idRslvr->Clone();\n+\n+                while (true)", "originalCommit": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxMTA5NQ==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458711095", "bodyText": "You are right. Will remove", "author": "isapego", "createdAt": "2020-07-22T11:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY5MzM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY5NDk0NQ==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458694945", "bodyText": "OP_ prefix is not consistent", "author": "ptupitsyn", "createdAt": "2020-07-22T10:30:09Z", "path": "modules/platforms/cpp/core/include/ignite/impl/compute/compute_impl.h", "diffHunk": "@@ -48,11 +48,13 @@ namespace ignite\n                 {\n                     enum Type\n                     {\n-                        AFFINITY = 1,\n-\n                         BROADCAST = 2,\n \n                         UNICAST = 5,\n+\n+                        OP_AFFINITY_CALL = 13,", "originalCommit": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxMjUxMQ==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458712511", "bodyText": "Agree. Fixed", "author": "isapego", "createdAt": "2020-07-22T11:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY5NDk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwMzMyNQ==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458703325", "bodyText": "Combine with the condition below to make it if-else. The logic is confusing with the last error: is Job is not registred for handle even possible?", "author": "ptupitsyn", "createdAt": "2020-07-22T10:46:38Z", "path": "modules/platforms/cpp/core/src/impl/ignite_environment.cpp", "diffHunk": "@@ -659,18 +685,13 @@ namespace ignite\n             // Cancel flag\n             reader.ReadBool();\n \n-            SharedPointer<compute::ComputeJobHolder> job0 =\n-                StaticPointerCast<compute::ComputeJobHolder>(registry.Get(jobHandle));\n-\n-            compute::ComputeJobHolder* job = job0.Get();\n-\n             SharedPointer<compute::ComputeTaskHolder> task0 =\n                 StaticPointerCast<compute::ComputeTaskHolder>(registry.Get(taskHandle));\n \n             compute::ComputeTaskHolder* task = task0.Get();\n \n-            if (task && job)\n-                return task->JobResultRemote(*job, reader);\n+            if (task)", "originalCommit": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxNzAwNA==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458717004", "bodyText": "Agree, fixed. On normal conditions, it should not happen, I believe.", "author": "isapego", "createdAt": "2020-07-22T11:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwMzMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNDA3Mg==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458704072", "bodyText": "Should we reduce in case of error?", "author": "ptupitsyn", "createdAt": "2020-07-22T10:48:12Z", "path": "modules/platforms/cpp/core/src/impl/ignite_environment.cpp", "diffHunk": "@@ -789,6 +810,103 @@ namespace ignite\n             return res ? 1 : 0;\n         }\n \n+        int64_t IgniteEnvironment::OnFutureResult(int64_t handle, SharedPointer<InteropMemory>& mem)\n+        {\n+            InteropInputStream inStream(mem.Get());\n+            BinaryReaderImpl reader(&inStream);\n+\n+            SharedPointer<compute::ComputeTaskHolder> task0 =\n+                StaticPointerCast<compute::ComputeTaskHolder>(registry.Get(handle));\n+\n+            registry.Release(handle);\n+\n+            compute::ComputeTaskHolder* task = task0.Get();\n+\n+            task->JobResultSuccess(reader);\n+            task->Reduce();\n+\n+            return 1;\n+        }\n+\n+        int64_t IgniteEnvironment::OnFutureError(int64_t handle, SharedPointer<InteropMemory>& mem)\n+        {\n+            InteropInputStream inStream(mem.Get());\n+            BinaryReaderImpl reader(&inStream);\n+            BinaryRawReader rawReader(&reader);\n+\n+            rawReader.ReadString();\n+            rawReader.ReadString();\n+\n+            std::string errStr = rawReader.ReadString();\n+\n+            IgniteError err(IgniteError::IGNITE_ERR_GENERIC, errStr.c_str());\n+\n+            SharedPointer<compute::ComputeTaskHolder> task0 =\n+                StaticPointerCast<compute::ComputeTaskHolder>(registry.Get(handle));\n+\n+            registry.Release(handle);\n+\n+            compute::ComputeTaskHolder* task = task0.Get();\n+\n+            task->JobResultError(err);\n+            task->Reduce();", "originalCommit": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxNzk4Mg==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458717982", "bodyText": "Yeah, in this case reduce will only notify future that result is available, even if it's an error.", "author": "isapego", "createdAt": "2020-07-22T11:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNDA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNTM1MQ==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458705351", "bodyText": "splitted -> split", "author": "ptupitsyn", "createdAt": "2020-07-22T10:50:41Z", "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.", "originalCommit": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxODM3OQ==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458718379", "bodyText": "Good catch", "author": "isapego", "createdAt": "2020-07-22T11:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNTM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNTY0NA==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458705644", "bodyText": "\"Broadcast compute jobs\"", "author": "ptupitsyn", "createdAt": "2020-07-22T10:51:13Z", "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.\n+        ClusterGroup localGroup = client.GetCluster().AsClusterGroup();\n+        ClusterGroup group1 = localGroup.ForAttribute(\"DemoAttribute\", \"Value0\");\n+        ClusterGroup group2 = localGroup.ForAttribute(\"DemoAttribute\", \"Value1\");\n+\n+        // Making calls.", "originalCommit": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxOTE4Mg==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458719182", "bodyText": "\ud83d\udc4d", "author": "isapego", "createdAt": "2020-07-22T11:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNTY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNjAxNw==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458706017", "bodyText": "\"Waiting for the compute jobs to complete\".\nBy the way, this is not clear: C++ Compute API is synchronous, so we don't have to wait, as I understand.", "author": "ptupitsyn", "createdAt": "2020-07-22T10:52:02Z", "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.\n+        ClusterGroup localGroup = client.GetCluster().AsClusterGroup();\n+        ClusterGroup group1 = localGroup.ForAttribute(\"DemoAttribute\", \"Value0\");\n+        ClusterGroup group2 = localGroup.ForAttribute(\"DemoAttribute\", \"Value1\");\n+\n+        // Making calls.\n+        client.GetCompute(group1).Broadcast(PrintMsg(\"DemoAttribute=Value0\"));\n+        client.GetCompute(group2).Broadcast(PrintMsg(\"DemoAttribute=Value1\"));\n+\n+        // Waiting the compute jobs.", "originalCommit": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgzODc1Ng==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458838756", "bodyText": "This is not completely true. We do have sync and async Compute API in C++. But in this case sync version is used, so you are right, this is not necessary, but it helps to see result of the example for a user. I think, only a message should be fixed.", "author": "isapego", "createdAt": "2020-07-22T14:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNjAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNjEzNQ==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458706135", "bodyText": "Why stop client first?", "author": "ptupitsyn", "createdAt": "2020-07-22T10:52:17Z", "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.\n+        ClusterGroup localGroup = client.GetCluster().AsClusterGroup();\n+        ClusterGroup group1 = localGroup.ForAttribute(\"DemoAttribute\", \"Value0\");\n+        ClusterGroup group2 = localGroup.ForAttribute(\"DemoAttribute\", \"Value1\");\n+\n+        // Making calls.\n+        client.GetCompute(group1).Broadcast(PrintMsg(\"DemoAttribute=Value0\"));\n+        client.GetCompute(group2).Broadcast(PrintMsg(\"DemoAttribute=Value1\"));\n+\n+        // Waiting the compute jobs.\n+        std::cout << std::endl;\n+        std::cout << \">>> Waiting all compute jobs done, before shutting down the cluster, press 'Enter to continue ...\" << std::endl;\n+        std::cout << std::endl;\n+        std::cin.get();\n+\n+        // Stop client node first.", "originalCommit": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczMzQyMQ==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458733421", "bodyText": "Because client prints exception when loses connection to all server nodes in cluster. Just to make output more clear and less scary for a user.", "author": "isapego", "createdAt": "2020-07-22T11:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNjEzNQ=="}], "type": "inlineReview"}, {"oid": "3389cd00319c2d8de208917dcaf72dd77d6f81ef", "url": "https://github.com/gridgain/gridgain/commit/3389cd00319c2d8de208917dcaf72dd77d6f81ef", "message": "GG-30206: Enabled CPP Cluster API\n\nThis reverts commit 84a18f567fc5504b017f394eab50003fa1cea91f.", "committedDate": "2020-07-22T14:41:05Z", "type": "commit"}, {"oid": "3504fb835f0a8610c95cc36aa6b61fb939274432", "url": "https://github.com/gridgain/gridgain/commit/3504fb835f0a8610c95cc36aa6b61fb939274432", "message": "GG-30206: Fixed affinity calls/runs", "committedDate": "2020-07-22T14:41:05Z", "type": "commit"}, {"oid": "1fe067a2c47be6682514a0a32e21c0fef0968bda", "url": "https://github.com/gridgain/gridgain/commit/1fe067a2c47be6682514a0a32e21c0fef0968bda", "message": "GG-30206: Fixed flaky tests", "committedDate": "2020-07-22T14:41:05Z", "type": "commit"}, {"oid": "8808869a35799017e22028c7399b161fbdc0fecc", "url": "https://github.com/gridgain/gridgain/commit/8808869a35799017e22028c7399b161fbdc0fecc", "message": "GG-30206: Fixed memory leak", "committedDate": "2020-07-22T14:41:05Z", "type": "commit"}, {"oid": "5a47c80982763fd8edce705ed398d4c0a5ead91b", "url": "https://github.com/gridgain/gridgain/commit/5a47c80982763fd8edce705ed398d4c0a5ead91b", "message": "GG-30206: Review-related fixes", "committedDate": "2020-07-22T14:41:05Z", "type": "commit"}, {"oid": "15c0c869059aea0cfc6e5144cd566dab8fc99e3e", "url": "https://github.com/gridgain/gridgain/commit/15c0c869059aea0cfc6e5144cd566dab8fc99e3e", "message": "GG-30206: Minor fix", "committedDate": "2020-07-22T14:41:05Z", "type": "commit"}, {"oid": "15c0c869059aea0cfc6e5144cd566dab8fc99e3e", "url": "https://github.com/gridgain/gridgain/commit/15c0c869059aea0cfc6e5144cd566dab8fc99e3e", "message": "GG-30206: Minor fix", "committedDate": "2020-07-22T14:41:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MzY2Nw==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458953667", "bodyText": "What if this condition is false? Is it a valid case or should we throw an error?", "author": "ptupitsyn", "createdAt": "2020-07-22T17:15:26Z", "path": "modules/platforms/cpp/binary/src/impl/binary/binary_object_impl.cpp", "diffHunk": "@@ -36,10 +36,23 @@ namespace ignite\n                 mem(&mem),\n                 start(start),\n                 idRslvr(0),\n-                metaMgr(metaMgr)\n+                metaMgr(metaMgr),\n+                binary(false)\n             {\n                 if (idRslvr)\n                     this->idRslvr = idRslvr->Clone();\n+\n+                int8_t hdr = BinaryUtils::ReadInt8(mem, this->start);\n+\n+                if (hdr == IGNITE_TYPE_BINARY)", "originalCommit": "15c0c869059aea0cfc6e5144cd566dab8fc99e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxNzE4Mg==", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r459017182", "bodyText": "It's OK, the class works on normal objects (hdr = 103) too. Maybe we should throw in other cases though. It's only internal class for now, so no other cases are expected. Will add a check", "author": "isapego", "createdAt": "2020-07-22T19:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MzY2Nw=="}], "type": "inlineReview"}, {"oid": "d6e36ee5ba0cde6ade77e29e3b6b91b01022e370", "url": "https://github.com/gridgain/gridgain/commit/d6e36ee5ba0cde6ade77e29e3b6b91b01022e370", "message": "GG-30206: Added check for BinaryObjectImpl", "committedDate": "2020-07-22T19:17:53Z", "type": "commit"}, {"oid": "1aa23288aa4aa334dcc895053c42a93c1f65f4df", "url": "https://github.com/gridgain/gridgain/commit/1aa23288aa4aa334dcc895053c42a93c1f65f4df", "message": "GG-30206: Fixed container", "committedDate": "2020-07-22T21:36:00Z", "type": "commit"}]}