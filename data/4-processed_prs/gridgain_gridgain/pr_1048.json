{"pr_number": 1048, "pr_title": "GG-26430 Collect TOP of N long SQL queries", "pr_createdAt": "2020-04-09T13:48:36Z", "pr_url": "https://github.com/gridgain/gridgain/pull/1048", "timeline": [{"oid": "8ec791408e7002fe900c81cd0d2cbbf2f20d7345", "url": "https://github.com/gridgain/gridgain/commit/8ec791408e7002fe900c81cd0d2cbbf2f20d7345", "message": "remove stale distributed cfg changes", "committedDate": "2020-04-16T13:12:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAxNTYxOA==", "url": "https://github.com/gridgain/gridgain/pull/1048#discussion_r412015618", "bodyText": "qryFinishedListeners", "author": "mshonichev", "createdAt": "2020-04-21T09:14:20Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/RunningQueryManager.java", "diffHunk": "@@ -109,6 +119,12 @@\n      */\n     private final AtomicLongMetric oomQrsCnt;\n \n+    /** */\n+    private final List<Consumer<GridQueryStartedInfo>> qryStartedListeners = new CopyOnWriteArrayList<>();\n+\n+    /** */\n+    private final List<Consumer<GridQueryFinishedInfo>> qryFineshedListeners = new CopyOnWriteArrayList<>();", "originalCommit": "4b58be99de798fada53a0328ce515f4c6abf70f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMDkyMQ==", "url": "https://github.com/gridgain/gridgain/pull/1048#discussion_r413700921", "bodyText": "I don't quite understand, if we issue TextQuery over cache got from client node, why do we later check that startedInfo.nodeId() equals to server node id?", "author": "mshonichev", "createdAt": "2020-04-23T10:29:33Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/h2/IgniteSqlQueryStartFinishListenerTest.java", "diffHunk": "@@ -0,0 +1,495 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.query.h2;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.cache.QueryEntity;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cache.query.TextQuery;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.processors.cache.index.AbstractIndexingCommonTest;\n+import org.apache.ignite.internal.processors.cache.query.GridCacheQueryType;\n+import org.apache.ignite.internal.processors.query.GridQueryFinishedInfo;\n+import org.apache.ignite.internal.processors.query.GridQueryStartedInfo;\n+import org.apache.ignite.internal.processors.query.IgniteSQLException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.hamcrest.CustomMatcher;\n+import org.hamcrest.Matcher;\n+import org.junit.After;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.processors.query.QueryUtils.sysSchemaName;\n+import static org.hamcrest.core.Is.is;\n+import static org.hamcrest.core.IsEqual.equalTo;\n+import static org.hamcrest.core.IsNull.notNullValue;\n+import static org.junit.Assert.assertThat;\n+\n+/** Test for SQL query listeners. */\n+public class IgniteSqlQueryStartFinishListenerTest extends AbstractIndexingCommonTest {\n+    /** Client node name. */\n+    private static final String CLIENT_NODE_NAME = \"CLIENT_NODE\";\n+\n+    /** Client node name. */\n+    private static final String SERVER_NODE_NAME = \"SERVER_NODE\";\n+\n+    /** Listeners. */\n+    private final List<Object> lsnrs = new ArrayList<>();\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        super.beforeTestsStarted();\n+\n+        startGrid(SERVER_NODE_NAME);\n+        startClientGrid(CLIENT_NODE_NAME);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTestsStopped() throws Exception {\n+        super.afterTestsStopped();\n+\n+        stopAllGrids();\n+    }\n+\n+    /** */\n+    @After\n+    public void unregisterListeners() {\n+        lsnrs.forEach(indexing()::unregisterQueryFinishedListener);\n+        lsnrs.forEach(indexing()::unregisterQueryStartedListener);\n+\n+        lsnrs.clear();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n+        return super.getConfiguration(gridName)\n+            .setSqlSchemas(\"TEST1\")\n+            .setCacheConfiguration(\n+                new CacheConfiguration<String, String>(DEFAULT_CACHE_NAME)\n+                    .setQueryEntities(Collections.singleton(new QueryEntity(String.class, String.class)))\n+                    .setSqlFunctionClasses(GridTestUtils.SqlTestFunctions.class)\n+            );\n+    }\n+\n+    /**\n+     * Ensure you could register and unregister a listener for query start/finish events:\n+     *     - register listeners\n+     *     - execute a query\n+     *     - ensure both listeneres were notified\n+     *     - unregister the query start listener\n+     *     - run a query one more time\n+     *     - ensure only one listener was notified\n+     *     - unregister the query finish listener and register new one\n+     *     - run a query one more time\n+     *     - ensure only new listener was notified\n+     *\n+     * @throws Exception In case of error.\n+     */\n+    @Test\n+    public void testRegisterUnregisterQueryListeners() throws Exception {\n+        final AtomicInteger qryStarted = new AtomicInteger();\n+        final AtomicInteger qryFinished = new AtomicInteger();\n+\n+        final Consumer<GridQueryStartedInfo> qryStartedLsnr = registerQueryStartedListener(info -> qryStarted.incrementAndGet());\n+        final Consumer<GridQueryFinishedInfo> qryFinishedLsnr = registerQueryFinishedListener(info -> qryFinished.incrementAndGet());\n+\n+        {\n+            execSql(sysSchemaName(), \"select * from caches\");\n+\n+            assertWithTimeout(qryStarted::get, is(equalTo(1)), 1_000);\n+            assertWithTimeout(qryFinished::get, is(equalTo(1)), 1_000);\n+        }\n+\n+        {\n+            assertTrue(indexing().unregisterQueryStartedListener(qryStartedLsnr));\n+\n+            execSql(sysSchemaName(), \"select * from caches\");\n+\n+            assertWithTimeout(qryFinished::get, is(equalTo(2)), 1_000);\n+            assertWithTimeout(qryStarted::get, is(equalTo(1)), 1_000);\n+        }\n+\n+        {\n+            assertTrue(indexing().unregisterQueryFinishedListener(qryFinishedLsnr));\n+\n+            final CountDownLatch latch = new CountDownLatch(1);\n+\n+            registerQueryFinishedListener(info -> latch.countDown());\n+\n+            execSql(sysSchemaName(), \"select * from caches\");\n+\n+            latch.await(1, TimeUnit.SECONDS);\n+\n+            assertWithTimeout(qryFinished::get, is(equalTo(2)), 1_000);\n+            assertWithTimeout(qryStarted::get, is(equalTo(1)), 1_000);\n+        }\n+    }\n+\n+    /**\n+     * Ensure listeners are notified with an actual query info:\n+     *     - register listeners\n+     *     - execute different queries\n+     *     - verify query info passed to listeners\n+     */\n+    @Test\n+    @SuppressWarnings(\"ThrowableNotThrown\")\n+    public void testVerifyQueryInfoPassedToListeners() throws Exception {\n+        final AtomicReference<GridQueryStartedInfo> qryStarted = new AtomicReference<>();\n+        final AtomicReference<GridQueryFinishedInfo> qryFinished = new AtomicReference<>();\n+\n+        registerQueryStartedListener(qryStarted::set);\n+        registerQueryFinishedListener(qryFinished::set);\n+\n+        {\n+            final long delay = 100;\n+            final String qry = \"select * from caches where ? = \\\"default\\\".delay(?) limit 1\";\n+\n+            execSql(sysSchemaName(), qry, delay, delay);\n+\n+            assertWithTimeout(qryStarted::get, is(notNullValue()), 1_000);\n+\n+            GridQueryStartedInfo startedInfo = qryStarted.get();\n+            assertEquals(sysSchemaName(), startedInfo.schemaName());\n+            assertEquals(qry, startedInfo.query());\n+            assertEquals(grid(SERVER_NODE_NAME).localNode().id(), startedInfo.nodeId());\n+            assertEquals(false, startedInfo.local());\n+            assertEquals(GridCacheQueryType.SQL_FIELDS, startedInfo.queryType());\n+\n+            assertWithTimeout(qryFinished::get, is(notNullValue()), 1_000);\n+\n+            GridQueryFinishedInfo finishedInfo = qryFinished.get();\n+            assertEquals(sysSchemaName(), finishedInfo.schemaName());\n+            assertEquals(qry, finishedInfo.query());\n+            assertEquals(grid(SERVER_NODE_NAME).localNode().id(), startedInfo.nodeId());\n+            assertEquals(false, finishedInfo.local());\n+            assertEquals(GridCacheQueryType.SQL_FIELDS, finishedInfo.queryType());\n+            assertEquals(false, finishedInfo.failed());\n+            assertThat(finishedInfo.finishTime() - finishedInfo.startTime(), is(greaterOrEqualTo(delay)));\n+\n+            qryStarted.set(null);\n+            qryFinished.set(null);\n+        }\n+\n+        {\n+            final String schema = \"TEST1\";\n+            final String qry = \"select \\\"default\\\".can_fail() from \" + sysSchemaName() + \".caches where ? = ? limit 1\";\n+\n+            GridTestUtils.SqlTestFunctions.fail = true;\n+\n+            GridTestUtils.assertThrowsWithCause(() -> execSqlLocal(schema, qry, 1, 1), IgniteSQLException.class);\n+\n+            assertWithTimeout(qryStarted::get, is(notNullValue()), 1_000);\n+\n+            GridQueryStartedInfo startedInfo = qryStarted.get();\n+            assertEquals(schema, startedInfo.schemaName());\n+            assertEquals(qry, startedInfo.query());\n+            assertEquals(grid(SERVER_NODE_NAME).localNode().id(), startedInfo.nodeId());\n+            assertEquals(true, startedInfo.local());\n+            assertEquals(GridCacheQueryType.SQL_FIELDS, startedInfo.queryType());\n+\n+            assertWithTimeout(qryFinished::get, is(notNullValue()), 1_000);\n+\n+            GridQueryFinishedInfo finishedInfo = qryFinished.get();\n+            assertEquals(schema, finishedInfo.schemaName());\n+            assertEquals(qry, finishedInfo.query());\n+            assertEquals(grid(SERVER_NODE_NAME).localNode().id(), startedInfo.nodeId());\n+            assertEquals(true, finishedInfo.local());\n+            assertEquals(GridCacheQueryType.SQL_FIELDS, finishedInfo.queryType());\n+            assertEquals(true, finishedInfo.failed());\n+            assertThat(finishedInfo.finishTime(), is(greaterOrEqualTo(finishedInfo.startTime())));\n+\n+            qryStarted.set(null);\n+            qryFinished.set(null);\n+        }\n+\n+        {\n+            final String qry = \"text query\";\n+\n+            IgniteCache<String, Object> cache = grid(CLIENT_NODE_NAME).cache(DEFAULT_CACHE_NAME);\n+\n+            cache.query(new TextQuery<String, String>(String.class, \"text query\"));", "originalCommit": "4e777fd302623a457b8c4da9d7b90ec118ca46de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczNTMxMw==", "url": "https://github.com/gridgain/gridgain/pull/1048#discussion_r413735313", "bodyText": "it is because nodeId represents an id of the node which starts execute the query, not an id of the node which sends request. Semantic is the same as for running query info (for running queries view)", "author": "korlov42", "createdAt": "2020-04-23T11:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwMDkyMQ=="}], "type": "inlineReview"}, {"oid": "f8e23e51f718812563470df94e98ca2d6b05ac02", "url": "https://github.com/gridgain/gridgain/commit/f8e23e51f718812563470df94e98ca2d6b05ac02", "message": "review fixes", "committedDate": "2020-04-23T10:06:55Z", "type": "forcePushed"}, {"oid": "db48c3dde326db893d52bc4b888ec2abd6b19fa0", "url": "https://github.com/gridgain/gridgain/commit/db48c3dde326db893d52bc4b888ec2abd6b19fa0", "message": "GG-26430 Provide ability to register listeners for query start/finish events", "committedDate": "2020-04-27T11:03:36Z", "type": "commit"}, {"oid": "db48c3dde326db893d52bc4b888ec2abd6b19fa0", "url": "https://github.com/gridgain/gridgain/commit/db48c3dde326db893d52bc4b888ec2abd6b19fa0", "message": "GG-26430 Provide ability to register listeners for query start/finish events", "committedDate": "2020-04-27T11:03:36Z", "type": "forcePushed"}]}