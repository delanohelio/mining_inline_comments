{"pr_number": 1246, "pr_title": "GG-27999", "pr_createdAt": "2020-06-17T10:44:35Z", "pr_url": "https://github.com/gridgain/gridgain/pull/1246", "timeline": [{"oid": "c8288b39039e484aa14581f519f05bc203d7f320", "url": "https://github.com/gridgain/gridgain/commit/c8288b39039e484aa14581f519f05bc203d7f320", "message": "GG-27999 Handling primary node left for transaction with syncMode != FULL_SYNC", "committedDate": "2020-06-15T19:14:43Z", "type": "commit"}, {"oid": "353a2cc4630ee6aa84ec896aa9ff520ff0714b76", "url": "https://github.com/gridgain/gridgain/commit/353a2cc4630ee6aa84ec896aa9ff520ff0714b76", "message": "GG-27999 Added tests", "committedDate": "2020-06-17T09:46:36Z", "type": "commit"}, {"oid": "8d32ad5f99cb3ed9707771d522c3465b7269af61", "url": "https://github.com/gridgain/gridgain/commit/8d32ad5f99cb3ed9707771d522c3465b7269af61", "message": "GG-27999 fix after review", "committedDate": "2020-06-17T18:25:50Z", "type": "commit"}, {"oid": "4d15294342e3efec8ae0c8cbd2e9cc1248a450f5", "url": "https://github.com/gridgain/gridgain/commit/4d15294342e3efec8ae0c8cbd2e9cc1248a450f5", "message": "GG-27999 fix checkstyle and licenses", "committedDate": "2020-06-18T07:25:19Z", "type": "commit"}, {"oid": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "url": "https://github.com/gridgain/gridgain/commit/1a77d1943d949f9f00d2e114b5cfca30f12f5949", "message": "Merge branch 'master' into gg-27999", "committedDate": "2020-06-18T08:40:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3Mjc2Mw==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442672763", "bodyText": "What's the point in testing full sync mode with zero backups ?", "author": "ascherbakoff", "createdAt": "2020-06-19T07:16:52Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.managers.communication.GridIoMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteInClosure;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Spi for node0 */\n+    private SpecialSpi spi0;\n+\n+    /** Spi for node1 */\n+    private SpecialSpi spi1;\n+\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));\n+\n+        SpecialSpi spi = new SpecialSpi();\n+\n+        cfg.setCommunicationSpi(spi);\n+\n+        if (igniteInstanceName.contains(\"0\"))\n+            spi0 = spi;\n+\n+        if (igniteInstanceName.contains(\"1\"))\n+            spi1 = spi;\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#PRIMARY_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithPrimarySync() throws Exception {\n+        testNodeFail(PRIMARY_SYNC);\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#FULL_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithFullSync() throws Exception {\n+        testNodeFail(FULL_SYNC);", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg1Mjc5NA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r446852794", "bodyText": "Because it is possible to set FULL_SYNC with zero backups. The fix has code for this case.", "author": "sergeyuttsel", "createdAt": "2020-06-29T08:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3Mjc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MzAzMQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442673031", "bodyText": "Bad formatting.", "author": "ascherbakoff", "createdAt": "2020-06-19T07:17:30Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.managers.communication.GridIoMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteInClosure;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Spi for node0 */\n+    private SpecialSpi spi0;\n+\n+    /** Spi for node1 */\n+    private SpecialSpi spi1;\n+\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));\n+\n+        SpecialSpi spi = new SpecialSpi();\n+\n+        cfg.setCommunicationSpi(spi);\n+\n+        if (igniteInstanceName.contains(\"0\"))\n+            spi0 = spi;\n+\n+        if (igniteInstanceName.contains(\"1\"))\n+            spi1 = spi;\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#PRIMARY_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithPrimarySync() throws Exception {\n+        testNodeFail(PRIMARY_SYNC);\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#FULL_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithFullSync() throws Exception {\n+        testNodeFail(FULL_SYNC);\n+    }\n+\n+    /**\n+     * <ul>\n+     * <li>Start 2 nodes with transactional cache without backups\n+     * <li>Start transaction:\n+     *  <ul>\n+     *  <li>put a key to a partition on transaction coordinator\n+     *  <li>put a key to a partition on other node\n+     *  <li>try to commit the transaction\n+     *  </ul>\n+     * <li>Stop other node when it try to send GridNearTxFinishResponse\n+     * <li>Check that {@link Transaction#commit()} throw {@link TransactionHeuristicException}\n+     * </ul>\n+     *\n+     * @param testSyncMode\n+     * @throws Exception\n+     */\n+    private void testNodeFail(CacheWriteSynchronizationMode testSyncMode) throws Exception {\n+        syncMode = testSyncMode;\n+\n+        startGrids(2);\n+\n+        grid(0).cluster().active(true);\n+\n+        IgniteEx grid0 = grid(0);\n+        IgniteEx grid1 = grid(1);\n+\n+        int key0 = 0;\n+        int key1 = 0;\n+\n+        Affinity<Object> aff = grid1.affinity(\"cache\");\n+\n+        for (int i = 1; i < 1000; i++) {\n+            if (grid0.equals(grid(aff.mapKeyToNode(i)))) {\n+                key0 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        for (int i = key0; i < 1000; i++) {\n+            if (grid1.equals(grid(aff.mapKeyToNode(i))) && !aff.mapKeyToNode(key1).equals(aff.mapKeyToNode(i))) {\n+                key1 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        assert !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1));\n+\n+        try (Transaction tx = grid1.transactions().txStart()) {\n+            grid1.cache(\"cache\").put(key0, 100);\n+            grid1.cache(\"cache\").put(key1, 200);\n+\n+            GridTestUtils.assertThrows(null,\n+                tx::commit,\n+                TransactionHeuristicException.class,\n+                \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n+                    grid0.localNode().consistentId() + \"] has left the grid and there are no backup nodes\");\n+        }\n+    }\n+\n+    /**\n+     * SPI wich block communication messages and stop a node.\n+     */\n+    private static class SpecialSpi extends TestRecordingCommunicationSpi {\n+        /** {@inheritDoc} */\n+        @Override public void sendMessage(ClusterNode node, Message msg, IgniteInClosure<IgniteException> ackC)\n+            throws IgniteSpiException {\n+            if (msg instanceof GridIoMessage) {\n+                Message message = ((GridIoMessage)msg).message();\n+                if (message instanceof GridNearTxFinishResponse) {\n+                    blockMessages((node1, msg1) -> true);\n+                    new Thread(\n+                        new Runnable() {\n+                            @Override public void run() {\n+                                ignite.log().info(\"Stopping node: [\" + ignite.name() + \"]\");\n+\n+                                IgnitionEx.stop(ignite.name(), true, null, true);\n+                            }\n+                            },", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg1Mjk2MQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r446852961", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-06-29T08:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MzAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MzcxOA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442673718", "bodyText": "TestRecordingCommunicationSpi  is not used in clean way.\nCheck for usage examples of methods blockMessage and waitForBlocked in the code base.\nYou even don't need the SpecialSpi class.", "author": "ascherbakoff", "createdAt": "2020-06-19T07:19:08Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.managers.communication.GridIoMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteInClosure;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Spi for node0 */\n+    private SpecialSpi spi0;\n+\n+    /** Spi for node1 */\n+    private SpecialSpi spi1;\n+\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));\n+\n+        SpecialSpi spi = new SpecialSpi();\n+\n+        cfg.setCommunicationSpi(spi);\n+\n+        if (igniteInstanceName.contains(\"0\"))\n+            spi0 = spi;\n+\n+        if (igniteInstanceName.contains(\"1\"))\n+            spi1 = spi;\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#PRIMARY_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithPrimarySync() throws Exception {\n+        testNodeFail(PRIMARY_SYNC);\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#FULL_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithFullSync() throws Exception {\n+        testNodeFail(FULL_SYNC);\n+    }\n+\n+    /**\n+     * <ul>\n+     * <li>Start 2 nodes with transactional cache without backups\n+     * <li>Start transaction:\n+     *  <ul>\n+     *  <li>put a key to a partition on transaction coordinator\n+     *  <li>put a key to a partition on other node\n+     *  <li>try to commit the transaction\n+     *  </ul>\n+     * <li>Stop other node when it try to send GridNearTxFinishResponse\n+     * <li>Check that {@link Transaction#commit()} throw {@link TransactionHeuristicException}\n+     * </ul>\n+     *\n+     * @param testSyncMode\n+     * @throws Exception\n+     */\n+    private void testNodeFail(CacheWriteSynchronizationMode testSyncMode) throws Exception {\n+        syncMode = testSyncMode;\n+\n+        startGrids(2);\n+\n+        grid(0).cluster().active(true);\n+\n+        IgniteEx grid0 = grid(0);\n+        IgniteEx grid1 = grid(1);\n+\n+        int key0 = 0;\n+        int key1 = 0;\n+\n+        Affinity<Object> aff = grid1.affinity(\"cache\");\n+\n+        for (int i = 1; i < 1000; i++) {\n+            if (grid0.equals(grid(aff.mapKeyToNode(i)))) {\n+                key0 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        for (int i = key0; i < 1000; i++) {\n+            if (grid1.equals(grid(aff.mapKeyToNode(i))) && !aff.mapKeyToNode(key1).equals(aff.mapKeyToNode(i))) {\n+                key1 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        assert !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1));\n+\n+        try (Transaction tx = grid1.transactions().txStart()) {\n+            grid1.cache(\"cache\").put(key0, 100);\n+            grid1.cache(\"cache\").put(key1, 200);\n+\n+            GridTestUtils.assertThrows(null,\n+                tx::commit,\n+                TransactionHeuristicException.class,\n+                \"Primary node [nodeId=\" + grid0.localNode().id() + \", consistentId=\" +\n+                    grid0.localNode().consistentId() + \"] has left the grid and there are no backup nodes\");\n+        }\n+    }\n+\n+    /**\n+     * SPI wich block communication messages and stop a node.\n+     */\n+    private static class SpecialSpi extends TestRecordingCommunicationSpi {\n+        /** {@inheritDoc} */\n+        @Override public void sendMessage(ClusterNode node, Message msg, IgniteInClosure<IgniteException> ackC)\n+            throws IgniteSpiException {\n+            if (msg instanceof GridIoMessage) {\n+                Message message = ((GridIoMessage)msg).message();\n+                if (message instanceof GridNearTxFinishResponse) {", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg1MzE3Mw==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r446853173", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-06-29T08:21:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MzcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3NDA1OQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442674059", "bodyText": "These class fields look useless.\nBetter to fetch spi when it's needed using org.apache.ignite.internal.TestRecordingCommunicationSpi#spi(ignite)", "author": "ascherbakoff", "createdAt": "2020-06-19T07:19:58Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.managers.communication.GridIoMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteInClosure;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Spi for node0 */\n+    private SpecialSpi spi0;", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg1MzUyOA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r446853528", "bodyText": "Thanks. I removed this field.", "author": "sergeyuttsel", "createdAt": "2020-06-29T08:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3NDA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3NDE1NA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442674154", "bodyText": "Same as above.", "author": "ascherbakoff", "createdAt": "2020-06-19T07:20:08Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.managers.communication.GridIoMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.lang.IgniteInClosure;\n+import org.apache.ignite.plugin.extensions.communication.Message;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Spi for node0 */\n+    private SpecialSpi spi0;\n+\n+    /** Spi for node1 */\n+    private SpecialSpi spi1;", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg1MzYwMA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r446853600", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-06-29T08:22:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3NDE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3OTY3OQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442679679", "bodyText": "Doesn't look good to me. The transaction can still be in prepared state and recovering for other primaries.\nI think it's ok to trigger heuristic exception only if near tx is in commiting state and a primary node has failed. No need to check for backups therefore.", "author": "ascherbakoff", "createdAt": "2020-06-19T07:32:13Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java", "diffHunk": "@@ -1032,6 +1033,25 @@ public GridDistributedTxMapping mapping() {\n                                     mini.onDhtFinishResponse(backupId, true);\n                             }\n                         }\n+                        else {\n+                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n+                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n+\n+                            return true;", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg0OTM2Mg==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r446849362", "bodyText": "Test https://ggtc.gridgain.com/project.html?projectId=Tests_GridGainCeEeUe_Latest_CE&testNameId=1912185254194727833&tab=testDetails&branch_Tests_GridGainCeEeUe_Latest_CE=gg-27999 failed when I removed backups check. So I think return it.", "author": "sergeyuttsel", "createdAt": "2020-06-29T08:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3OTY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3OTc3NA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r442679774", "bodyText": "Same as above.", "author": "ascherbakoff", "createdAt": "2020-06-19T07:32:25Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java", "diffHunk": "@@ -1032,6 +1033,25 @@ public GridDistributedTxMapping mapping() {\n                                     mini.onDhtFinishResponse(backupId, true);\n                             }\n                         }\n+                        else {\n+                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n+                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n+\n+                            return true;\n+                        }\n+                    }\n+                }\n+                else {\n+                    Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n+                    if (txNodes != null) {\n+                        Collection<UUID> backups = txNodes.get(nodeId);\n+\n+                        if (F.isEmpty(backups) || backups.stream().allMatch(backupId -> cctx.discovery().node(backupId) == null)) {\n+                            onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +\n+                                m.primary().consistentId() + \"] has left the grid and there are no backup nodes\"));\n+\n+                            return true;\n+                        }", "originalCommit": "1a77d1943d949f9f00d2e114b5cfca30f12f5949", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "05b6aa0ffd90a6145aa4dd1e1855bd332b10e57c", "url": "https://github.com/gridgain/gridgain/commit/05b6aa0ffd90a6145aa4dd1e1855bd332b10e57c", "message": "GG-27999 fix after review", "committedDate": "2020-06-19T14:12:58Z", "type": "commit"}, {"oid": "6a32b7b33e83d43560866689850b71d233b33d03", "url": "https://github.com/gridgain/gridgain/commit/6a32b7b33e83d43560866689850b71d233b33d03", "message": "GG-27999 fix after review", "committedDate": "2020-06-19T14:30:16Z", "type": "commit"}, {"oid": "b6a5bd02bdaff9c086b21931d6b9e09d2af6220d", "url": "https://github.com/gridgain/gridgain/commit/b6a5bd02bdaff9c086b21931d6b9e09d2af6220d", "message": "GG-27999 fix after run all on teamcity", "committedDate": "2020-06-29T08:39:38Z", "type": "commit"}, {"oid": "3f3e383645e67c86078019c3b42d402e94399ba5", "url": "https://github.com/gridgain/gridgain/commit/3f3e383645e67c86078019c3b42d402e94399ba5", "message": "Merge remote-tracking branch 'gridgain-ce/master' into gg-27999", "committedDate": "2020-06-29T09:10:12Z", "type": "commit"}, {"oid": "99676c1e5d6ab202e9419ca128b43df003aa3268", "url": "https://github.com/gridgain/gridgain/commit/99676c1e5d6ab202e9419ca128b43df003aa3268", "message": "GG-27999 fix after review", "committedDate": "2020-06-30T12:30:19Z", "type": "commit"}, {"oid": "f8ca5ee89a9de8698afefc90ce5e59f8328f075a", "url": "https://github.com/gridgain/gridgain/commit/f8ca5ee89a9de8698afefc90ce5e59f8328f075a", "message": "GG-27999 get backups via tx", "committedDate": "2020-06-30T14:12:41Z", "type": "commit"}, {"oid": "8bf1de2b8717ceb8f5817ff9f88dcf81d13434f9", "url": "https://github.com/gridgain/gridgain/commit/8bf1de2b8717ceb8f5817ff9f88dcf81d13434f9", "message": "GG-27999 cleanup", "committedDate": "2020-07-01T20:27:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQzMjA1Ng==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r449432056", "bodyText": "You should print informative partition loss message here, like here:\norg.apache.ignite.internal.processors.cache.distributed.dht.GridDhtTopologyFutureAdapter#validateKey.\nnew CacheInvalidStateException(\"Failed to commit a transaction (all partition owners have left the grid, partition data has been lost) [cacheName=cache, partition=10, key=somekey]\")\nI think better to avoid heuristic exception and use CacheException instread.", "author": "ascherbakoff", "createdAt": "2020-07-03T07:50:22Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java", "diffHunk": "@@ -978,7 +982,27 @@ public GridDistributedTxMapping mapping() {\n \n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n+            if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n+                Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n+\n+                Collection<UUID> backups = txNodes.get(nodeId);\n+\n+                boolean hasBackups = false;\n+\n+                if (backups != null)\n+                    hasBackups = backups.stream().anyMatch(backupId -> cctx.discovery().node(backupId) != null);\n+\n+                if (cctx.discovery().node(m.primary().id()) == null && !hasBackups) {\n+                    onDone(new TransactionHeuristicException(\"Primary node [nodeId=\" + nodeId + \", consistentId=\" +", "originalCommit": "8bf1de2b8717ceb8f5817ff9f88dcf81d13434f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b8f4d8291e89496d9f7c69a587c043ea5465675a", "url": "https://github.com/gridgain/gridgain/commit/b8f4d8291e89496d9f7c69a587c043ea5465675a", "message": "GG-2799 fix after review", "committedDate": "2020-07-03T13:05:16Z", "type": "commit"}, {"oid": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "url": "https://github.com/gridgain/gridgain/commit/7be549368ac7e8930c9ed1d3abd339de4056ad66", "message": "GG-27999 fix after review", "committedDate": "2020-07-03T14:11:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NTkzNg==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450145936", "bodyText": "We don't need an empty line here", "author": "glukos", "createdAt": "2020-07-06T11:01:44Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java", "diffHunk": "@@ -978,7 +983,41 @@ public GridDistributedTxMapping mapping() {\n \n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n+            if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n+                Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n+\n+                Collection<UUID> backups = txNodes.get(nodeId);\n+\n+                boolean hasBackups = false;\n+\n+                if (backups != null)\n+                    hasBackups = backups.stream().anyMatch(backupId -> cctx.discovery().node(backupId) != null);\n+\n+                if (cctx.discovery().node(m.primary().id()) == null && !hasBackups) {\n+                    String strTxEntry = \"\";\n+\n+                    Iterator<IgniteTxEntry> entryIter = m.entries().iterator();\n+\n+                    if (entryIter.hasNext()) {\n+                        IgniteTxEntry firstTxEntry = entryIter.next();\n+\n+                        strTxEntry = \" [cacheName=\" + firstTxEntry.cached().context().name() +\n+                            \", partition=\" + firstTxEntry.key().partition() +\n+                            (S.includeSensitive() ? \", key=\" + firstTxEntry.key() : \"\") +\n+                            \"]\";\n+                    }\n+\n+                    onDone(new CacheInvalidStateException(\"Failed to commit a transaction \" +\n+                        \"(all partition owners have left the grid, partition data has been lost)\" +\n+                        strTxEntry)\n+                    );\n+\n+                    return true;\n+                }\n+            }\n+\n             if (nodeId.equals(m.primary().id())) {\n+", "originalCommit": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwNTI1OA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450205258", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-07-06T13:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NTkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NjQwOQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450146409", "bodyText": "We can use @RunWith(Parameterized.class) instead for testing with various values of this parameter.", "author": "glukos", "createdAt": "2020-07-06T11:02:46Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+import org.locationtech.jts.util.Assert;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;", "originalCommit": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwNTMwNA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450205304", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-07-06T13:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NjQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzMQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450147231", "bodyText": "It's better to preset DataRegionConfiguration#maxSize to reasonable value (e.g. 100 mb). By default, Ignite node allocates 20% of physical memory, which sometimes causes OOMs on TC.", "author": "glukos", "createdAt": "2020-07-06T11:04:31Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+import org.locationtech.jts.util.Assert;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));", "originalCommit": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwNTMzMg==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450205332", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-07-06T13:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0NzIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0Nzg2MQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450147861", "bodyText": "Please add description for parameter and exception class. IDEA highlights absence of a comment as a warning. Applicable to several more places in the test class.", "author": "glukos", "createdAt": "2020-07-06T11:05:49Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+import org.locationtech.jts.util.Assert;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));\n+\n+        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#PRIMARY_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithPrimarySync() throws Exception {\n+        testNodeFail(PRIMARY_SYNC);\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#FULL_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithFullSync() throws Exception {\n+        testNodeFail(FULL_SYNC);\n+    }\n+\n+    /**\n+     * <ul>\n+     * <li>Start 2 nodes with transactional cache without backups\n+     * <li>Start transaction:\n+     *  <ul>\n+     *  <li>put a key to a partition on transaction coordinator\n+     *  <li>put a key to a partition on other node\n+     *  <li>try to commit the transaction\n+     *  </ul>\n+     * <li>Stop other node when it try to send GridNearTxFinishResponse\n+     * <li>Check that {@link Transaction#commit()} throw {@link TransactionHeuristicException}\n+     * </ul>\n+     *\n+     * @param testSyncMode", "originalCommit": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0ODAwNg==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450148006", "bodyText": "", "author": "glukos", "createdAt": "2020-07-06T11:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0Nzg2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwNTM4Ng==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450205386", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-07-06T13:03:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0Nzg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0ODgzMA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450148830", "bodyText": "Let's use cleanPersistenceDir();\nAttempt to clean the whole work dir may fail locally (e.g. if I have a log file opened).", "author": "glukos", "createdAt": "2020-07-06T11:08:07Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+import org.locationtech.jts.util.Assert;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));\n+\n+        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));", "originalCommit": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwNTQ0MA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450205440", "bodyText": "fixed", "author": "sergeyuttsel", "createdAt": "2020-07-06T13:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0ODgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0OTM4Mg==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450149382", "bodyText": "If it's possible, extract message in TX code as a public static final constant use reuse it in this test. If someone has to change the message, this test will fail.", "author": "glukos", "createdAt": "2020-07-06T11:09:24Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.io.File;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+import org.locationtech.jts.util.Assert;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** syncMode */\n+    private static CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration()\n+                .setPersistenceEnabled(true));\n+\n+        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        FileUtils.deleteDirectory(new File(U.defaultWorkDirectory()));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#PRIMARY_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithPrimarySync() throws Exception {\n+        testNodeFail(PRIMARY_SYNC);\n+    }\n+\n+    /**\n+     * Test with {@link CacheWriteSynchronizationMode#FULL_SYNC}\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testNodeFailWithFullSync() throws Exception {\n+        testNodeFail(FULL_SYNC);\n+    }\n+\n+    /**\n+     * <ul>\n+     * <li>Start 2 nodes with transactional cache without backups\n+     * <li>Start transaction:\n+     *  <ul>\n+     *  <li>put a key to a partition on transaction coordinator\n+     *  <li>put a key to a partition on other node\n+     *  <li>try to commit the transaction\n+     *  </ul>\n+     * <li>Stop other node when it try to send GridNearTxFinishResponse\n+     * <li>Check that {@link Transaction#commit()} throw {@link TransactionHeuristicException}\n+     * </ul>\n+     *\n+     * @param testSyncMode\n+     * @throws Exception\n+     */\n+    private void testNodeFail(CacheWriteSynchronizationMode testSyncMode) throws Exception {\n+        syncMode = testSyncMode;\n+\n+        startGrids(2);\n+\n+        grid(0).cluster().active(true);\n+\n+        IgniteEx grid0 = grid(0);\n+        IgniteEx grid1 = grid(1);\n+\n+        int key0 = 0;\n+        int key1 = 0;\n+\n+        Affinity<Object> aff = grid1.affinity(\"cache\");\n+\n+        for (int i = 1; i < 1000; i++) {\n+            if (grid0.equals(grid(aff.mapKeyToNode(i)))) {\n+                key0 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        for (int i = key0; i < 1000; i++) {\n+            if (grid1.equals(grid(aff.mapKeyToNode(i))) && !aff.mapKeyToNode(key1).equals(aff.mapKeyToNode(i))) {\n+                key1 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        assert !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1));\n+\n+        try (Transaction tx = grid1.transactions().txStart()) {\n+            grid1.cache(\"cache\").put(key0, 100);\n+            grid1.cache(\"cache\").put(key1, 200);\n+\n+            spi(grid0).blockMessages((node, msg) -> {\n+                    if (msg instanceof GridNearTxFinishResponse) {\n+                        new Thread(\n+                            new Runnable() {\n+                                @Override public void run() {\n+                                    log().info(\"Stopping node: [\" + grid0.name() + \"]\");\n+\n+                                    IgnitionEx.stop(grid0.name(), true, null, true);\n+                                }\n+                            },\n+                            \"node-stopper\"\n+                        ).start();\n+\n+                        return true;\n+                    }\n+\n+                    return false;\n+                }\n+            );\n+\n+            try {\n+                tx.commit();\n+            }\n+            catch (Throwable e) {\n+                String msg = e.getMessage();\n+\n+                Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n+\n+                Pattern msgPattern = Pattern.compile(\"Failed to commit a transaction \\\\(all partition owners have left the grid, \" +", "originalCommit": "7be549368ac7e8930c9ed1d3abd339de4056ad66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIwNTQ4MQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450205481", "bodyText": "partly fixed", "author": "sergeyuttsel", "createdAt": "2020-07-06T13:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0OTM4Mg=="}], "type": "inlineReview"}, {"oid": "a7b455d946d866ead689fb078b3d07c56ee0489a", "url": "https://github.com/gridgain/gridgain/commit/a7b455d946d866ead689fb078b3d07c56ee0489a", "message": "GG-27999 fix after review", "committedDate": "2020-07-06T13:02:32Z", "type": "commit"}, {"oid": "5c6e1edad430c9c04ca6958f0a9324710ad0ee94", "url": "https://github.com/gridgain/gridgain/commit/5c6e1edad430c9c04ca6958f0a9324710ad0ee94", "message": "Merge remote-tracking branch 'gridgain-ce/master' into gg-27999", "committedDate": "2020-07-06T19:32:33Z", "type": "commit"}, {"oid": "f290ab81a6fca7969b2d61bbd3740d8804d899a6", "url": "https://github.com/gridgain/gridgain/commit/f290ab81a6fca7969b2d61bbd3740d8804d899a6", "message": "GG-27999 workaround for mvcc suite", "committedDate": "2020-07-07T12:59:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg3MTc3OQ==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r450871779", "bodyText": "Missing new line ?", "author": "ascherbakoff", "createdAt": "2020-07-07T13:39:47Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/near/IgniteTxExceptionNodeFailTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.distributed.near;\n+\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.affinity.Affinity;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.TestRecordingCommunicationSpi;\n+import org.apache.ignite.internal.processors.cache.CacheInvalidStateException;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.apache.ignite.transactions.Transaction;\n+import org.apache.ignite.transactions.TransactionHeuristicException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.locationtech.jts.util.Assert;\n+\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.FULL_SYNC;\n+import static org.apache.ignite.cache.CacheWriteSynchronizationMode.PRIMARY_SYNC;\n+import static org.apache.ignite.internal.TestRecordingCommunicationSpi.spi;\n+import static org.apache.ignite.internal.processors.cache.distributed.near.GridNearTxFinishFuture.ALL_PARTITION_OWNERS_LEFT_GRID_MSG;\n+import static org.apache.ignite.internal.processors.cache.mvcc.MvccUtils.mvccEnabled;\n+\n+/**\n+ * Tests check a result of commit when a node fail before\n+ * send {@link GridNearTxFinishResponse} to transaction coodinator\n+ */\n+@RunWith(Parameterized.class)\n+public class IgniteTxExceptionNodeFailTest extends GridCommonAbstractTest {\n+    /** Parameters. */\n+    @Parameterized.Parameters(name = \"syncMode={0}\")\n+    public static Iterable<CacheWriteSynchronizationMode> data() {\n+        return Arrays.asList(PRIMARY_SYNC, FULL_SYNC);\n+    }\n+\n+    /** syncMode */\n+    @Parameterized.Parameter()\n+    public CacheWriteSynchronizationMode syncMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        DataStorageConfiguration dsConfig = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(100L * 1024 * 1024)\n+                .setPersistenceEnabled(true));\n+\n+        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());\n+\n+        return cfg\n+            .setDataStorageConfiguration(dsConfig)\n+            .setCacheConfiguration(new CacheConfiguration(\"cache\")\n+                .setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL)\n+                .setWriteSynchronizationMode(syncMode).setBackups(0));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+\n+        cleanPersistenceDir();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * <ul>\n+     * <li>Start 2 nodes with transactional cache, without backups, with {@link IgniteTxExceptionNodeFailTest#syncMode}\n+     * <li>Start transaction:\n+     *  <ul>\n+     *  <li>put a key to a partition on transaction coordinator\n+     *  <li>put a key to a partition on other node\n+     *  <li>try to commit the transaction\n+     *  </ul>\n+     * <li>Stop other node when it try to send GridNearTxFinishResponse\n+     * <li>Check that {@link Transaction#commit()} throw {@link TransactionHeuristicException}\n+     * </ul>\n+     *\n+     * @throws Exception If failed\n+     */\n+    @Test\n+    public void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception {\n+        startGrids(2);\n+\n+        grid(0).cluster().active(true);\n+\n+        IgniteEx grid0 = grid(0);\n+        IgniteEx grid1 = grid(1);\n+\n+        int key0 = 0;\n+        int key1 = 0;\n+\n+        Affinity<Object> aff = grid1.affinity(\"cache\");\n+\n+        for (int i = 1; i < 1000; i++) {\n+            if (grid0.equals(grid(aff.mapKeyToNode(i)))) {\n+                key0 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        for (int i = key0; i < 1000; i++) {\n+            if (grid1.equals(grid(aff.mapKeyToNode(i))) && !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(i))) {\n+                key1 = i;\n+\n+                break;\n+            }\n+        }\n+\n+        assert !aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1));\n+\n+        try (Transaction tx = grid1.transactions().txStart()) {\n+            grid1.cache(\"cache\").put(key0, 100);\n+            grid1.cache(\"cache\").put(key1, 200);\n+\n+            spi(grid0).blockMessages((node, msg) -> {\n+                    if (msg instanceof GridNearTxFinishResponse) {\n+                        new Thread(\n+                            new Runnable() {\n+                                @Override public void run() {\n+                                    log().info(\"Stopping node: [\" + grid0.name() + \"]\");\n+\n+                                    IgnitionEx.stop(grid0.name(), true, null, true);\n+                                }\n+                            },\n+                            \"node-stopper\"\n+                        ).start();\n+\n+                        return true;\n+                    }\n+\n+                    return false;\n+                }\n+            );\n+\n+            boolean passed = false;\n+\n+            try {\n+                tx.commit();\n+            }\n+            catch (Throwable e) {\n+                String msg = e.getMessage();\n+\n+                Assert.isTrue(e.getCause() instanceof CacheInvalidStateException);\n+\n+                Assert.isTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG));\n+\n+                if (!mvccEnabled(grid1.context())) {\n+                    Pattern msgPtrn = Pattern.compile(\" \\\\[cacheName=cache, partition=\\\\d+, \" + \"key=KeyCacheObjectImpl \\\\[part=\\\\d+, val=\" + key0 +\n+                        \", hasValBytes=true\\\\]\\\\]\");\n+\n+                    Matcher matcher = msgPtrn.matcher(msg);\n+\n+                    Assert.isTrue(matcher.find());\n+                }\n+\n+                passed = true;\n+            }\n+\n+            Assert.isTrue(passed);\n+        }\n+    }\n+}", "originalCommit": "f290ab81a6fca7969b2d61bbd3740d8804d899a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "673d7ec5e64bcd7fa1c956df17e721b4bd3605c5", "url": "https://github.com/gridgain/gridgain/commit/673d7ec5e64bcd7fa1c956df17e721b4bd3605c5", "message": "GG-27999 fix", "committedDate": "2020-07-07T14:25:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTUxMTI4OA==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r451511288", "bodyText": "Too much of lines.\nThis can be simplified to something like:\nif (concat(of(m.primary().id()), m.backups().stream()).noneMatch(uuid -> cctx.discovery().alive(uuid))) {\n                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG +\n                        m.entries().stream().map(e -> \" [cacheName=\" + e.cached().context().name() +\n                            \", partition=\" + e.key().partition() +\n                            (S.includeSensitive() ? \", key=\" + e.key() : \"\") +\n                            \"]\").findFirst().orElse(\"\")));\n\n                    return true;\n}", "author": "ascherbakoff", "createdAt": "2020-07-08T12:37:34Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java", "diffHunk": "@@ -978,6 +987,36 @@ public GridDistributedTxMapping mapping() {\n \n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n+            if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n+                Map<UUID, Collection<UUID>> txNodes = tx.transactionNodes();\n+\n+                Collection<UUID> backups = txNodes.get(nodeId);\n+\n+                boolean hasBackups = false;\n+\n+                if (backups != null)\n+                    hasBackups = backups.stream().anyMatch(backupId -> cctx.discovery().node(backupId) != null);\n+\n+                if (cctx.discovery().node(m.primary().id()) == null && !hasBackups) {\n+                    String strTxEntry = \"\";\n+\n+                    Iterator<IgniteTxEntry> entryIter = m.entries().iterator();\n+\n+                    if (entryIter.hasNext()) {\n+                        IgniteTxEntry firstTxEntry = entryIter.next();\n+\n+                        strTxEntry = \" [cacheName=\" + firstTxEntry.cached().context().name() +\n+                            \", partition=\" + firstTxEntry.key().partition() +\n+                            (S.includeSensitive() ? \", key=\" + firstTxEntry.key() : \"\") +\n+                            \"]\";\n+                    }\n+\n+                    onDone(new CacheInvalidStateException(ALL_PARTITION_OWNERS_LEFT_GRID_MSG + strTxEntry));\n+\n+                    return true;\n+                }\n+            }", "originalCommit": "673d7ec5e64bcd7fa1c956df17e721b4bd3605c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "93460ec63751bfb067e5871c2e1ecea08df70d87", "url": "https://github.com/gridgain/gridgain/commit/93460ec63751bfb067e5871c2e1ecea08df70d87", "message": "GG-27999 fix after review", "committedDate": "2020-07-08T14:50:23Z", "type": "commit"}, {"oid": "1222baf7e4dc2472dcae6ada7484fcbb844977ad", "url": "https://github.com/gridgain/gridgain/commit/1222baf7e4dc2472dcae6ada7484fcbb844977ad", "message": "GG-27999 fix after review", "committedDate": "2020-07-08T16:19:40Z", "type": "commit"}, {"oid": "47b8762a9e01671bff202a7a7d17d35086bcf782", "url": "https://github.com/gridgain/gridgain/commit/47b8762a9e01671bff202a7a7d17d35086bcf782", "message": "GG-27999 fix after review", "committedDate": "2020-07-09T07:46:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY2NjQzMg==", "url": "https://github.com/gridgain/gridgain/pull/1246#discussion_r452666432", "bodyText": "Weird code, must be:\nOptional.of(tx.transactionNodes().getOrDefault(nodeId, Collections.emptySet())).orElse(Collections.emptySet()).stream()) -> tx.transactionNodes().getOrDefault(nodeId, emptySet()).stream()\nNever forget about static imports codestyle rule.", "author": "ascherbakoff", "createdAt": "2020-07-10T07:18:06Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/near/GridNearTxFinishFuture.java", "diffHunk": "@@ -978,6 +988,19 @@ public GridDistributedTxMapping mapping() {\n \n         /** {@inheritDoc} */\n         @Override boolean onNodeLeft(UUID nodeId, boolean discoThread) {\n+            if (tx.state() == COMMITTING || tx.state() == COMMITTED) {\n+                if (concat(of(m.primary().id()), Optional.of(tx.transactionNodes().getOrDefault(nodeId, Collections.emptySet())).orElse(Collections.emptySet()).stream())", "originalCommit": "47b8762a9e01671bff202a7a7d17d35086bcf782", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f360b83757f50974a04f78a17319e00aed2a8772", "url": "https://github.com/gridgain/gridgain/commit/f360b83757f50974a04f78a17319e00aed2a8772", "message": "GG-27999 fix after review", "committedDate": "2020-07-10T07:34:29Z", "type": "commit"}]}