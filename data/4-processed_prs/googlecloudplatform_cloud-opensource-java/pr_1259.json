{"pr_number": 1259, "pr_title": "Adding article about version resolution", "pr_createdAt": "2020-02-27T23:58:45Z", "pr_url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259", "timeline": [{"oid": "c1401503a93b2793e0b823dc62437e7480d4f361", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/commit/c1401503a93b2793e0b823dc62437e7480d4f361", "message": "Adding article about version resolution", "committedDate": "2020-02-27T23:57:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1OTQwMw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385659403", "bodyText": "usually called the dependency mediation algorithm, at least in Maven", "author": "elharo", "createdAt": "2020-02-28T12:03:36Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,108 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version selection algorithm is used to choose the versions of your", "originalCommit": "c1401503a93b2793e0b823dc62437e7480d4f361", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4NzIwNw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385787207", "bodyText": "In Gradle it is called \"version conflict resolution\": https://docs.gradle.org/current/userguide/dependency_resolution.html\nI will make a note of the two terms.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T16:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1OTQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1OTU3OQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385659579", "bodyText": "delete \"of the two\"", "author": "elharo", "createdAt": "2020-02-28T12:04:03Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,108 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version selection algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. No matter which\n+of the two you choose, you are likely to have direct or indirect dependencies", "originalCommit": "c1401503a93b2793e0b823dc62437e7480d4f361", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5MTMwMQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385791301", "bodyText": "will do.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T16:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1OTU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1OTY5Ng==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385659696", "bodyText": "delete \"they\"", "author": "elharo", "createdAt": "2020-02-28T12:04:22Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,108 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version selection algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. No matter which\n+of the two you choose, you are likely to have direct or indirect dependencies\n+that use the other one, so you need to understand how they both work when your", "originalCommit": "c1401503a93b2793e0b823dc62437e7480d4f361", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5MTM0MQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385791341", "bodyText": "will do.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T16:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1OTY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1OTkyMg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385659922", "bodyText": "delete \"when your dependency graph...conflicts\"", "author": "elharo", "createdAt": "2020-02-28T12:05:02Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,108 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version selection algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. No matter which\n+of the two you choose, you are likely to have direct or indirect dependencies\n+that use the other one, so you need to understand how they both work when your\n+dependency graph experiences conflicts.", "originalCommit": "c1401503a93b2793e0b823dc62437e7480d4f361", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5MTU1Ng==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385791556", "bodyText": "will do.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T16:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY1OTkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MDE1OA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385660158", "bodyText": "delete \"exactly\"", "author": "elharo", "createdAt": "2020-02-28T12:05:41Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,108 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version selection algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. No matter which\n+of the two you choose, you are likely to have direct or indirect dependencies\n+that use the other one, so you need to understand how they both work when your\n+dependency graph experiences conflicts.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies exactly as specified by each", "originalCommit": "c1401503a93b2793e0b823dc62437e7480d4f361", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5MTgyNw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385791827", "bodyText": "will do.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T16:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MDE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MDQ3NA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385660474", "bodyText": "I'm not sure it does, at least not Maven. It produces a linear classpath, not another graph.", "author": "elharo", "createdAt": "2020-02-28T12:06:34Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,108 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version selection algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. No matter which\n+of the two you choose, you are likely to have direct or indirect dependencies\n+that use the other one, so you need to understand how they both work when your\n+dependency graph experiences conflicts.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies exactly as specified by each\n+library in the graph, which we call an unresolved dependency graph. In such a\n+graph, there can be multiple versions of each library. The version resolution\n+process walks the unresolved dependency graph and produces a new graph where", "originalCommit": "c1401503a93b2793e0b823dc62437e7480d4f361", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5NTM4OA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385795388", "bodyText": "Ok, I will detach the actual output of Maven from the treatment of the output as a new graph.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T16:32:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MDQ3NA=="}], "type": "inlineReview"}, {"oid": "ca177720549e14b1654334fccb098275a307ba9f", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/commit/ca177720549e14b1654334fccb098275a307ba9f", "message": "PR feedback", "committedDate": "2020-02-28T16:33:23Z", "type": "commit"}, {"oid": "903abc3cf3ad2f21c69d820582674c24fdc78985", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/commit/903abc3cf3ad2f21c69d820582674c24fdc78985", "message": "Additional tweaks", "committedDate": "2020-02-28T16:35:10Z", "type": "commit"}, {"oid": "41b2fe5544afdda07fd9004f5fde8020c487f8e5", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/commit/41b2fe5544afdda07fd9004f5fde8020c487f8e5", "message": "Fixing links", "committedDate": "2020-02-28T16:37:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMzcxMw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385803713", "bodyText": "Not sure what to do about this, but there are other build systems that do something completely different. E.g Eclipse and Ant don't necessarily use the Maven repository system at all. SBT and Ant+Ivy do. This article is really about \"Version resolution in the Maven Respository System\" or some such.", "author": "elharo", "createdAt": "2020-02-28T16:46:52Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,117 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which", "originalCommit": "41b2fe5544afdda07fd9004f5fde8020c487f8e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxNDg3Mg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385814872", "bodyText": "Our entire set of best practices ignores the Eclipse/Ant world, right? The practices are all in terms of the Maven repository system. Anyway, I will add a note that Eclipse/Ant are out of scope.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T17:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMzcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgyMzQ3Nw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385823477", "bodyText": "no, not completely. JLBP-17, 18, 19, and 20 for instance apply equally well to ant. So does JLBP-1 and probably others.", "author": "elharo", "createdAt": "2020-02-28T17:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMzcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgyNjU0Nw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385826547", "bodyText": "They can apply incidentally, but our focus is on build systems using the Maven repository system.\nIf you want to increase our scope to Eclipse/Ant, we'd probably want to clarify throughout our best practices what the scope of each one is. For example, I have no idea if BOMs are useful (or possible) for Eclipse/ant.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T17:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMzcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NTQwOQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385895409", "bodyText": "I don't think you need to increase the scope here, but I do think this needs to be rephrased to put the Maven repo system up front. That's what this article discusses, not all of Java.", "author": "elharo", "createdAt": "2020-02-28T19:59:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMzcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwMzYxNQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385903615", "bodyText": "I have added a note about this.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T20:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwMzcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNDMxMQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385804311", "bodyText": "Version conflict resolution is fine after this note. It's less jargony than \"dependency mediation.\" but let's not introduce a thrid synonym.", "author": "elharo", "createdAt": "2020-02-28T16:48:02Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,117 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*. No matter which you choose, you are", "originalCommit": "41b2fe5544afdda07fd9004f5fde8020c487f8e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMjc0Mg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385812742", "bodyText": "There's a problem though - it overloads the \"conflict\" word. In our world (the JLBP project), we generally apply the word \"conflict\" to situations where something breaks, and we treat version resolution as a neutral process that doesn't have any \"conflicts\" if the result works. Using the word \"conflict\" for this part of the process in our documentation will muddy the waters.\nYou could also view this differently: \"version resolution\" is just a simplified version of the term \"version conflict resolution\", and isn't really a distinct term.\nI will add some additional verbiage about omitting the word \"conflict\".", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T17:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNDMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNDkxMg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385804912", "bodyText": "\"Whether or not the build tool produces a graph as an output\nof this resolution, it is useful to think of this output in terms of a new\ngraph. We call the graph representation of this output a resolved dependency\ngraph.\"\nI don't buy this. It's clearer to simply go straight to the linear classpath. The intermediate graph is an unnecessary step.", "author": "elharo", "createdAt": "2020-02-28T16:49:06Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,117 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*. No matter which you choose, you are\n+likely to have direct or indirect dependencies that use the other one, so you\n+need to understand how both work.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output", "originalCommit": "41b2fe5544afdda07fd9004f5fde8020c487f8e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMzAzMw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385813033", "bodyText": "How do you describe the output of mvn dependency:tree?", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T17:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNDkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgyMzgzNg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385823836", "bodyText": "debugging text printed on the console", "author": "elharo", "createdAt": "2020-02-28T17:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNDkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgyNzY2OQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385827669", "bodyText": "The text structure is in a tree format (or as best a tree can be represented in text).\nWhen is it used? When debugging dependency conflicts.\nThus, I would argue that thinking of the result of dependency resolution as a tree (or more correctly, a graph) already has precedent, and is the best format. A linear format is harder to take action on in order to fix dependency problems since the input is a tree, and the input is where problems need to be fixed.\n@suztomo do you have thoughts on this?", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T17:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNDkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE5OTkxMg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387199912", "bodyText": "ping @suztomo", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNDkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyMTA3OA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r389821078", "bodyText": "I need this paragraph. This input tree and output tree are the fundamental part of comparing Gradle and Maven's behavior.\nIn the two paths, which is easier to explain the different behaviors of Maven and Gradle?\n\nA: Graph  ->  Dependency Mediation  ->  Class Path\nB: 1st Graph  ->  Dependency Mediation  ->  2nd Graph  ->  Class Path\n\nI choose B, because mvn dependency:tree -Dverbose shows \"2nd Graph\" in B. The tool helps to explain Maven's behavior of picking up closest ones.", "author": "suztomo", "createdAt": "2020-03-09T16:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNDkxMg=="}], "type": "inlineReview"}, {"oid": "14b2872ab465584a2eb3a99b57dbefaa980e563e", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/commit/14b2872ab465584a2eb3a99b57dbefaa980e563e", "message": "Additional PR feedback", "committedDate": "2020-02-28T17:12:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NTczNw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385895737", "bodyText": "delete \" of Gradle in this circumstance\"", "author": "elharo", "createdAt": "2020-02-28T20:00:06Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite", "originalCommit": "14b2872ab465584a2eb3a99b57dbefaa980e563e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwNDE0MA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385904140", "bodyText": "Ok.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T20:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NTczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NTk1MQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385895951", "bodyText": "delete \"In this case, Maven also makes the opposite choice of Gradle.\"", "author": "elharo", "createdAt": "2020-02-28T20:00:36Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice of Gradle in this circumstance. Let's look at the second example, where\n+the root has both a direct and indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root", "originalCommit": "14b2872ab465584a2eb3a99b57dbefaa980e563e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwNDU2Nw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385904567", "bodyText": "Why? I want to call it out explicitly - it's not otherwise stated.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T20:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NTk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzOTU2MQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386339561", "bodyText": "Maven won't always make the opposite choice of Gradle. The sentence would work if Gradle chose the furthest an Gradle chose the nearest, or some such weird thing.", "author": "elharo", "createdAt": "2020-03-02T11:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NTk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwODUxNg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387208516", "bodyText": "I don't get your argument...\nI will add one more diagram to show Maven & Gradle doing the same thing. I hope that makes this sentence work better.", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NTk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NjE5Mw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385896193", "bodyText": "delete \"So where can the mixture of these two build systems cause a problem?\"", "author": "elharo", "createdAt": "2020-02-28T20:01:06Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice of Gradle in this circumstance. Let's look at the second example, where\n+the root has both a direct and indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+So where can the mixture of these two build systems cause a problem? The", "originalCommit": "14b2872ab465584a2eb3a99b57dbefaa980e563e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwNTczOA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385905738", "bodyText": "That leaves a jarring shift in topic. I'll make a header instead I suppose.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T20:24:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NjE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NzEzMQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385897131", "bodyText": "That's not quite right. There are two different resolved dependency graphs (or classpaths) here, not one. Perhaps rephrase around program behavior. E.g \"When the two build systems select different versions of a transitive dependency, a library that works with one might not work with the other.\"", "author": "elharo", "createdAt": "2020-02-28T20:03:21Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice of Gradle in this circumstance. Let's look at the second example, where\n+the root has both a direct and indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+So where can the mixture of these two build systems cause a problem? The\n+resolved dependency graph can experience conflicts when the two build systems", "originalCommit": "14b2872ab465584a2eb3a99b57dbefaa980e563e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNzE1Mw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385917153", "bodyText": "I decided to completely rewrite the paragraph - I hope the rewritten version conveys the idea better.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T20:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NzEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NzQyMg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385897422", "bodyText": "where's \"Gradle Example 2\"? Generally should the figures have captions?", "author": "elharo", "createdAt": "2020-02-28T20:03:54Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice of Gradle in this circumstance. Let's look at the second example, where\n+the root has both a direct and indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+So where can the mixture of these two build systems cause a problem? The\n+resolved dependency graph can experience conflicts when the two build systems\n+come to different decisions for a particular subgraph of a dependency graph.\n+\n+Let's look at an example, starting with Gradle example 2, where library D", "originalCommit": "14b2872ab465584a2eb3a99b57dbefaa980e563e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwNzE4MA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385907180", "bodyText": "It's above - ddc-resolution-05.png. Should the caption / image title be displayed differently?", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T20:28:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NzQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MTQxMQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386341411", "bodyText": "It should probably be text in the document somehow as that's much better for accessibility. This might require a little embedded HTML. https://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll has some suggestions", "author": "elharo", "createdAt": "2020-03-02T11:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NzQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxOTkwMA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387219900", "bodyText": "That makes sense... could I defer this until after the navigation PR is submitted? (We don't have an _includes/ directory yet, as suggested by one of the recommendations)", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NzQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5Nzg0Ng==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385897846", "bodyText": "\"Let's add a new library (let's call it library E)\" --> Suppose we add a new library E", "author": "elharo", "createdAt": "2020-02-28T20:04:57Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice of Gradle in this circumstance. Let's look at the second example, where\n+the root has both a direct and indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+So where can the mixture of these two build systems cause a problem? The\n+resolved dependency graph can experience conflicts when the two build systems\n+come to different decisions for a particular subgraph of a dependency graph.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,\n+this is fine, since Gradle chooses version 10.1.\n+\n+Let's add a new library (let's call it library E) which uses Maven as its build", "originalCommit": "14b2872ab465584a2eb3a99b57dbefaa980e563e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwNzM4OA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385907388", "bodyText": "Ok.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T20:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5Nzg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5Nzk3Mw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385897973", "bodyText": "will resolve --> resolves for consistent present tense", "author": "elharo", "createdAt": "2020-02-28T20:05:16Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice of Gradle in this circumstance. Let's look at the second example, where\n+the root has both a direct and indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+So where can the mixture of these two build systems cause a problem? The\n+resolved dependency graph can experience conflicts when the two build systems\n+come to different decisions for a particular subgraph of a dependency graph.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,\n+this is fine, since Gradle chooses version 10.1.\n+\n+Let's add a new library (let's call it library E) which uses Maven as its build\n+system, and which adds D as a dependency. When E is built, Maven will resolve", "originalCommit": "14b2872ab465584a2eb3a99b57dbefaa980e563e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwNzU0Mw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385907543", "bodyText": "oops I've been trying to avoid this, good catch", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T20:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5Nzk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5ODI3Nw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385898277", "bodyText": "delete \"because it seems to have a bug\"", "author": "elharo", "createdAt": "2020-02-28T20:05:55Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice of Gradle in this circumstance. Let's look at the second example, where\n+the root has both a direct and indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+So where can the mixture of these two build systems cause a problem? The\n+resolved dependency graph can experience conflicts when the two build systems\n+come to different decisions for a particular subgraph of a dependency graph.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,\n+this is fine, since Gradle chooses version 10.1.\n+\n+Let's add a new library (let's call it library E) which uses Maven as its build\n+system, and which adds D as a dependency. When E is built, Maven will resolve\n+the whole dependency graph, including D's subgraph, even though Gradle resolved\n+the subgraph of D for itself when D was originally built. When Maven performs\n+its version resolution, it chooses a different version of A (10.0) than Gradle\n+did (10.1), which breaks C. This happens even though D works perfectly fine\n+internally.\n+\n+<img src=\"assets/images/ddc-resolution-08.png\">\n+\n+As a consequence, the author of library E might file a bug against library D\n+because it seems to have a bug. The author of library D would argue that there", "originalCommit": "14b2872ab465584a2eb3a99b57dbefaa980e563e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwNzcyOA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385907728", "bodyText": "Ok.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T20:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5ODI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5ODQ3OA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385898478", "bodyText": "delete \"from their perspective\"", "author": "elharo", "createdAt": "2020-02-28T20:06:18Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice of Gradle in this circumstance. Let's look at the second example, where\n+the root has both a direct and indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+So where can the mixture of these two build systems cause a problem? The\n+resolved dependency graph can experience conflicts when the two build systems\n+come to different decisions for a particular subgraph of a dependency graph.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,\n+this is fine, since Gradle chooses version 10.1.\n+\n+Let's add a new library (let's call it library E) which uses Maven as its build\n+system, and which adds D as a dependency. When E is built, Maven will resolve\n+the whole dependency graph, including D's subgraph, even though Gradle resolved\n+the subgraph of D for itself when D was originally built. When Maven performs\n+its version resolution, it chooses a different version of A (10.0) than Gradle\n+did (10.1), which breaks C. This happens even though D works perfectly fine\n+internally.\n+\n+<img src=\"assets/images/ddc-resolution-08.png\">\n+\n+As a consequence, the author of library E might file a bug against library D\n+because it seems to have a bug. The author of library D would argue that there\n+is no bug from their perspective. From their narrow perspectives they are both", "originalCommit": "14b2872ab465584a2eb3a99b57dbefaa980e563e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwNzg3MA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385907870", "bodyText": "Ok.", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T20:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5ODQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5ODYxNw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385898617", "bodyText": "so that --> so", "author": "elharo", "createdAt": "2020-02-28T20:06:36Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice of Gradle in this circumstance. Let's look at the second example, where\n+the root has both a direct and indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+So where can the mixture of these two build systems cause a problem? The\n+resolved dependency graph can experience conflicts when the two build systems\n+come to different decisions for a particular subgraph of a dependency graph.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,\n+this is fine, since Gradle chooses version 10.1.\n+\n+Let's add a new library (let's call it library E) which uses Maven as its build\n+system, and which adds D as a dependency. When E is built, Maven will resolve\n+the whole dependency graph, including D's subgraph, even though Gradle resolved\n+the subgraph of D for itself when D was originally built. When Maven performs\n+its version resolution, it chooses a different version of A (10.0) than Gradle\n+did (10.1), which breaks C. This happens even though D works perfectly fine\n+internally.\n+\n+<img src=\"assets/images/ddc-resolution-08.png\">\n+\n+As a consequence, the author of library E might file a bug against library D\n+because it seems to have a bug. The author of library D would argue that there\n+is no bug from their perspective. From their narrow perspectives they are both\n+right. From the ecosystem perspective, the author of library D unfortunately\n+needs to adapt their dependencies so that they don't cause problems for Maven", "originalCommit": "14b2872ab465584a2eb3a99b57dbefaa980e563e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwNzkzOQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385907939", "bodyText": "Ok", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T20:29:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5ODYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5ODgyMw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385898823", "bodyText": "\"ake the same\nversion resolution decisions\" --> select the same versions", "author": "elharo", "createdAt": "2020-02-28T20:07:04Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice of Gradle in this circumstance. Let's look at the second example, where\n+the root has both a direct and indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+So where can the mixture of these two build systems cause a problem? The\n+resolved dependency graph can experience conflicts when the two build systems\n+come to different decisions for a particular subgraph of a dependency graph.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,\n+this is fine, since Gradle chooses version 10.1.\n+\n+Let's add a new library (let's call it library E) which uses Maven as its build\n+system, and which adds D as a dependency. When E is built, Maven will resolve\n+the whole dependency graph, including D's subgraph, even though Gradle resolved\n+the subgraph of D for itself when D was originally built. When Maven performs\n+its version resolution, it chooses a different version of A (10.0) than Gradle\n+did (10.1), which breaks C. This happens even though D works perfectly fine\n+internally.\n+\n+<img src=\"assets/images/ddc-resolution-08.png\">\n+\n+As a consequence, the author of library E might file a bug against library D\n+because it seems to have a bug. The author of library D would argue that there\n+is no bug from their perspective. From their narrow perspectives they are both\n+right. From the ecosystem perspective, the author of library D unfortunately\n+needs to adapt their dependencies so that they don't cause problems for Maven\n+consumers (even though they may have sworn off Maven and use Gradle\n+exclusively). In this case, they have an easy fix - they can upgrade the direct\n+dependency of D on A:10.0 to A:10.1, so that both build systems make the same", "originalCommit": "14b2872ab465584a2eb3a99b57dbefaa980e563e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwODA5OA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r385908098", "bodyText": "Ok", "author": "garrettjonesgoogle", "createdAt": "2020-02-28T20:30:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5ODgyMw=="}], "type": "inlineReview"}, {"oid": "c68f34510d608e58bfed850d81aa93bc693e7c09", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/commit/c68f34510d608e58bfed850d81aa93bc693e7c09", "message": "PR feedback, third round", "committedDate": "2020-02-28T20:54:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzMzE4NQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386333185", "bodyText": "delete \"in open source\" since these are used for closed source projects too", "author": "elharo", "createdAt": "2020-03-02T11:15:28Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE5MTA4Nw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387191087", "bodyText": "Ok.", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T17:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzMzE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzMzY2Ng==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386333666", "bodyText": "it --> is.\nand don't we call those \"dependency conflicts\" elsewhere? If so I'm not sure we need to change it here.", "author": "elharo", "createdAt": "2020-03-02T11:16:26Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE5MTI0Mg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387191242", "bodyText": "good catch!", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T17:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzMzY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzNDA4Mw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386334083", "bodyText": "Delete \"note:\"\nThis still feels to me like it belongs in the first paragraph rather than a note at the bottom. This is fundamental to what the article discusses.", "author": "elharo", "createdAt": "2020-03-02T11:17:31Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE5MTQ4OA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387191488", "bodyText": "I don't understand, this is the first paragraph...\nAnyway, I will split the paragraph into two paragraphs, and put this note in the first of the two split paragraphs, which hopefully will make it more prominent.", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T17:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzNDA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzNTQwNA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386335404", "bodyText": "But there is no version resolution process without Maven or Gradle. You can describe what exists in the repository, and you can describe what Maven and Gradle do with the information they find there. Nothing else exists.", "author": "elharo", "createdAt": "2020-03-02T11:20:37Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE5OTc5Ng==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387199796", "bodyText": "I will rework this to refer to \"the concepts of version resolution in general\" - there are logical steps that any build system needs to perform. Denying generalities is like denying that we can talk about circles since no object is a perfect circle.", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzNTQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzNjM2Mg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386336362", "bodyText": "Java's default class loader --> each class loader", "author": "elharo", "createdAt": "2020-03-02T11:22:47Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMDI3OQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387200279", "bodyText": "Ok", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzNjM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzNjUwNA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386336504", "bodyText": "So, if you try to put --> If you put\nwould not --> do not", "author": "elharo", "createdAt": "2020-03-02T11:23:08Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMDcyNg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387200726", "bodyText": "Ok", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzNjUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzNzMzMw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386337333", "bodyText": "Google tech writer style guide discourages \"Let's'\" and recommends second and third person as appropriate:\nhttps://developers.google.com/style/person", "author": "elharo", "createdAt": "2020-03-02T11:25:05Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzNzk4NA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386337984", "bodyText": "would pick -->picks\nPer style guide, avoid \"would\"\nhttps://developers.google.com/style/tense", "author": "elharo", "createdAt": "2020-03-02T11:26:31Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMTc2Mw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387201763", "bodyText": "Ok", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzNzk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzODE4OQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386338189", "bodyText": "delete \"let's\"", "author": "elharo", "createdAt": "2020-03-02T11:26:55Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMTkxNA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387201914", "bodyText": "Ok", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzODE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzODMyMw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386338323", "bodyText": ",and,", "author": "elharo", "createdAt": "2020-03-02T11:27:14Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMjI2Mg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387202262", "bodyText": "Removing \"then\"... not sure exactly what you were looking for though.", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzODMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzODUxMA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386338510", "bodyText": "\"following a\nbreadth-first traversal\" --> in breadth first order.", "author": "elharo", "createdAt": "2020-03-02T11:27:40Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMjQ3Ng==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387202476", "bodyText": "Ok", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:13:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzODUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzODYyNA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386338624", "bodyText": "delete \"first\"", "author": "elharo", "createdAt": "2020-03-02T11:27:55Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwMzUyNA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387203524", "bodyText": "Gradle examples 1 and 2 are different - I wanted to refer to 1. Rewording to try to make that clear.", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzODYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzODc5Mg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386338792", "bodyText": "\"if you compare\" --> by comparing", "author": "elharo", "createdAt": "2020-03-02T11:28:17Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwNDA1OA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387204058", "bodyText": "Ok", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:16:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzODc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzODk1Nw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386338957", "bodyText": "let's look at --> Now consider", "author": "elharo", "createdAt": "2020-03-02T11:28:39Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwNDI3Mw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387204273", "bodyText": "Ok", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzODk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzOTk5MA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386339990", "bodyText": "Every time --> When\nits build system --> the build system\n(some libraries are built with different systems; e.g. blaze)", "author": "elharo", "createdAt": "2020-03-02T11:31:03Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+## Interaction between Maven and Gradle\n+\n+Every time a library is built, its build system performs version resolution for", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwOTE0MQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387209141", "bodyText": "\"the build system\" also implies there is only one... I don't feel like it clarifies anything. Going into the nuances of multiple build systems per library seems like it would muddy the picture too much and make the article less useful. In the end, only 1 build system is used to build the artifacts that are pushed to Maven, even if a second build system is available to use.", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzOTk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MDMxMg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386340312", "bodyText": "libraries don't perform version resolution. Only build systems do.", "author": "elharo", "createdAt": "2020-03-02T11:31:43Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+## Interaction between Maven and Gradle\n+\n+Every time a library is built, its build system performs version resolution for\n+its entire dependency graph. Since the libraries in that dependency graph also\n+perform their own version resolution, the versions selected can be different,", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNDc4NA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387214784", "bodyText": "Adding \"the build systems of ...\"", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MDMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MDY3Ng==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386340676", "bodyText": "\"selected by the dependency when the dependency is built by itself\" --> \"expected by the dependency\"", "author": "elharo", "createdAt": "2020-03-02T11:32:33Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+## Interaction between Maven and Gradle\n+\n+Every time a library is built, its build system performs version resolution for\n+its entire dependency graph. Since the libraries in that dependency graph also\n+perform their own version resolution, the versions selected can be different,\n+especially when a consumer uses a different build system than its dependencies.\n+Sometimes, the version selected by the consumer can be incompatible with the\n+version selected by the dependency when the dependency is built by itself.", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIxNzMxNw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387217317", "bodyText": "I can understand the motivation to simplify this, but I feel that there is value in being explicit about the separate build processes in the dependency vs the consumer. Just saying \"expected by\" is somewhat inert.", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MDY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MDc2MQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386340761", "bodyText": "Let's", "author": "elharo", "createdAt": "2020-03-02T11:32:48Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+## Interaction between Maven and Gradle\n+\n+Every time a library is built, its build system performs version resolution for\n+its entire dependency graph. Since the libraries in that dependency graph also\n+perform their own version resolution, the versions selected can be different,\n+especially when a consumer uses a different build system than its dependencies.\n+Sometimes, the version selected by the consumer can be incompatible with the\n+version selected by the dependency when the dependency is built by itself.\n+\n+Let's look at an example, starting with Gradle example 2, where library D", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIyMTU3NA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387221574", "bodyText": "Taken care of", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MDc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MTYyOA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386341628", "bodyText": "\" as the\nresolved version\" is redundant with selected and can be deleted", "author": "elharo", "createdAt": "2020-03-02T11:34:51Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+## Interaction between Maven and Gradle\n+\n+Every time a library is built, its build system performs version resolution for\n+its entire dependency graph. Since the libraries in that dependency graph also\n+perform their own version resolution, the versions selected can be different,\n+especially when a consumer uses a different build system than its dependencies.\n+Sometimes, the version selected by the consumer can be incompatible with the\n+version selected by the dependency when the dependency is built by itself.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIyMTg3MA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387221870", "bodyText": "Done", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MTYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MTc0Mw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386341743", "bodyText": "will fail --> fails\nhttps://developers.google.com/style/tense", "author": "elharo", "createdAt": "2020-03-02T11:35:09Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+## Interaction between Maven and Gradle\n+\n+Every time a library is built, its build system performs version resolution for\n+its entire dependency graph. Since the libraries in that dependency graph also\n+perform their own version resolution, the versions selected can be different,\n+especially when a consumer uses a different build system than its dependencies.\n+Sometimes, the version selected by the consumer can be incompatible with the\n+version selected by the dependency when the dependency is built by itself.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIyMjI0OQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387222249", "bodyText": "yep yep, deeply ingrained habits die hard...", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MTc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MTgwOA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386341808", "bodyText": "no first person", "author": "elharo", "createdAt": "2020-03-02T11:35:22Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+## Interaction between Maven and Gradle\n+\n+Every time a library is built, its build system performs version resolution for\n+its entire dependency graph. Since the libraries in that dependency graph also\n+perform their own version resolution, the versions selected can be different,\n+especially when a consumer uses a different build system than its dependencies.\n+Sometimes, the version selected by the consumer can be incompatible with the\n+version selected by the dependency when the dependency is built by itself.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,\n+this is fine, since Gradle chooses version 10.1.\n+\n+Suppose we add a new library E which uses Maven as its build system, and which", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIyMzY1MQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387223651", "bodyText": "Ugh, all of my articles use this extensively. Do you really want to force a full rewrite before this article is submitted?", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MTgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0ODI1OQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387248259", "bodyText": "It's not used that much, and the change is pretty straightforward. E.g. here \"Suppose a new library E uses Maven as its build system and has a dependency on D.\"", "author": "elharo", "createdAt": "2020-03-03T19:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MTgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI1MzM0MQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387253341", "bodyText": "Ok I rewrote this sentence as suggested.", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T19:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MTgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MjA3Nw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386342077", "bodyText": "\"itself\" is unclear here. Does this refer to Gradle or D?", "author": "elharo", "createdAt": "2020-03-02T11:35:59Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+## Interaction between Maven and Gradle\n+\n+Every time a library is built, its build system performs version resolution for\n+its entire dependency graph. Since the libraries in that dependency graph also\n+perform their own version resolution, the versions selected can be different,\n+especially when a consumer uses a different build system than its dependencies.\n+Sometimes, the version selected by the consumer can be incompatible with the\n+version selected by the dependency when the dependency is built by itself.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,\n+this is fine, since Gradle chooses version 10.1.\n+\n+Suppose we add a new library E which uses Maven as its build system, and which\n+adds D as a dependency. When E is built, Maven resolves the whole dependency\n+graph, including D's subgraph, even though Gradle resolved the subgraph of D for\n+itself when D was originally built. When Maven performs its version resolution,", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIyNDE1MA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387224150", "bodyText": "Removing \"itself\", it's not necessary", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MjA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MjUyMA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386342520", "bodyText": "Images need alt text for accessibility\nhttps://developers.google.com/style/images#alt-text", "author": "elharo", "createdAt": "2020-03-02T11:37:02Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+## Interaction between Maven and Gradle\n+\n+Every time a library is built, its build system performs version resolution for\n+its entire dependency graph. Since the libraries in that dependency graph also\n+perform their own version resolution, the versions selected can be different,\n+especially when a consumer uses a different build system than its dependencies.\n+Sometimes, the version selected by the consumer can be incompatible with the\n+version selected by the dependency when the dependency is built by itself.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,\n+this is fine, since Gradle chooses version 10.1.\n+\n+Suppose we add a new library E which uses Maven as its build system, and which\n+adds D as a dependency. When E is built, Maven resolves the whole dependency\n+graph, including D's subgraph, even though Gradle resolved the subgraph of D for\n+itself when D was originally built. When Maven performs its version resolution,\n+it chooses a different version of A (10.0) than Gradle did (10.1), which breaks\n+C. This happens even though D works perfectly fine internally.\n+\n+<img src=\"assets/images/ddc-resolution-08.png\">", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIyNTk2MA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387225960", "bodyText": "Ok, adding alt text", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:56:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MjUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0Mjc4MQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386342781", "bodyText": "narrow --> individual\ncomma after perspectives", "author": "elharo", "createdAt": "2020-03-02T11:37:42Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+## Interaction between Maven and Gradle\n+\n+Every time a library is built, its build system performs version resolution for\n+its entire dependency graph. Since the libraries in that dependency graph also\n+perform their own version resolution, the versions selected can be different,\n+especially when a consumer uses a different build system than its dependencies.\n+Sometimes, the version selected by the consumer can be incompatible with the\n+version selected by the dependency when the dependency is built by itself.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,\n+this is fine, since Gradle chooses version 10.1.\n+\n+Suppose we add a new library E which uses Maven as its build system, and which\n+adds D as a dependency. When E is built, Maven resolves the whole dependency\n+graph, including D's subgraph, even though Gradle resolved the subgraph of D for\n+itself when D was originally built. When Maven performs its version resolution,\n+it chooses a different version of A (10.0) than Gradle did (10.1), which breaks\n+C. This happens even though D works perfectly fine internally.\n+\n+<img src=\"assets/images/ddc-resolution-08.png\">\n+\n+As a consequence, the author of library E might file a bug against library\n+D. The author of library D would argue that there is no bug. From their narrow", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIyNjI2OA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387226268", "bodyText": "Ok", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0Mjc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0Mjg3MA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386342870", "bodyText": "they are both right --> both are right", "author": "elharo", "createdAt": "2020-03-02T11:37:58Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+## Interaction between Maven and Gradle\n+\n+Every time a library is built, its build system performs version resolution for\n+its entire dependency graph. Since the libraries in that dependency graph also\n+perform their own version resolution, the versions selected can be different,\n+especially when a consumer uses a different build system than its dependencies.\n+Sometimes, the version selected by the consumer can be incompatible with the\n+version selected by the dependency when the dependency is built by itself.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,\n+this is fine, since Gradle chooses version 10.1.\n+\n+Suppose we add a new library E which uses Maven as its build system, and which\n+adds D as a dependency. When E is built, Maven resolves the whole dependency\n+graph, including D's subgraph, even though Gradle resolved the subgraph of D for\n+itself when D was originally built. When Maven performs its version resolution,\n+it chooses a different version of A (10.0) than Gradle did (10.1), which breaks\n+C. This happens even though D works perfectly fine internally.\n+\n+<img src=\"assets/images/ddc-resolution-08.png\">\n+\n+As a consequence, the author of library E might file a bug against library\n+D. The author of library D would argue that there is no bug. From their narrow\n+perspectives they are both right. From the ecosystem perspective, the author of", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIyNjM2Nw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387226367", "bodyText": "Ok", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0Mjg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MzAwNg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386343006", "bodyText": "their --> its", "author": "elharo", "createdAt": "2020-03-02T11:38:18Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+## Interaction between Maven and Gradle\n+\n+Every time a library is built, its build system performs version resolution for\n+its entire dependency graph. Since the libraries in that dependency graph also\n+perform their own version resolution, the versions selected can be different,\n+especially when a consumer uses a different build system than its dependencies.\n+Sometimes, the version selected by the consumer can be incompatible with the\n+version selected by the dependency when the dependency is built by itself.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,\n+this is fine, since Gradle chooses version 10.1.\n+\n+Suppose we add a new library E which uses Maven as its build system, and which\n+adds D as a dependency. When E is built, Maven resolves the whole dependency\n+graph, including D's subgraph, even though Gradle resolved the subgraph of D for\n+itself when D was originally built. When Maven performs its version resolution,\n+it chooses a different version of A (10.0) than Gradle did (10.1), which breaks\n+C. This happens even though D works perfectly fine internally.\n+\n+<img src=\"assets/images/ddc-resolution-08.png\">\n+\n+As a consequence, the author of library E might file a bug against library\n+D. The author of library D would argue that there is no bug. From their narrow\n+perspectives they are both right. From the ecosystem perspective, the author of\n+library D unfortunately needs to adapt their dependencies so they don't cause", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIyNjU5NA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387226594", "bodyText": "Ok", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MzAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MzM1NQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r386343355", "bodyText": "versions --> version\ncan be --> is", "author": "elharo", "createdAt": "2020-03-02T11:39:09Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,124 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems in open source\n+(Maven and Gradle) use different version resolution algorithms. They also use\n+different names for the concept: Maven calls the process *dependency mediation*,\n+while Gradle calls the process *version conflict resolution*. In this article,\n+we will use the term *version resolution*, omitting the word \"conflict\" so that\n+the process it not confused with program-breaking conflicts that we discuss\n+elsewhere. No matter which build system you choose, you are likely to have\n+direct or indirect dependencies that use the other one, so you need to\n+understand how both work. Note: Our focus is on build systems based on the Maven\n+repository system, so we ignore other build environments like Eclipse and Ant\n+that work differently.\n+\n+Before we look at Maven and Gradle specifically, we need to understand what\n+happens in the version resolution process. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph, there\n+can be multiple versions of each library. The version resolution process walks\n+the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\">\n+\n+So why do we need to pick a single version? The reason is that Java's default\n+class loader only loads one version of each fully-qualified class name at\n+runtime. So, if you try to put multiple versions on the classpath, you would not\n+get both versions at runtime. Java build systems handle this issue upfront by\n+picking a single version for each library before the classpath is even\n+constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle would pick A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\">\n+\n+Next let's consider Maven. Maven chooses the version that is closest to the root\n+of the dependency graph, and if there is a tie, then it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph following a\n+breadth-first traversal. Looking at the same example we used first for Gradle:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\">\n+\n+As you can see if you compare the resolved graphs, Maven makes the opposite\n+choice. Let's look at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+## Interaction between Maven and Gradle\n+\n+Every time a library is built, its build system performs version resolution for\n+its entire dependency graph. Since the libraries in that dependency graph also\n+perform their own version resolution, the versions selected can be different,\n+especially when a consumer uses a different build system than its dependencies.\n+Sometimes, the version selected by the consumer can be incompatible with the\n+version selected by the dependency when the dependency is built by itself.\n+\n+Let's look at an example, starting with Gradle example 2, where library D\n+depends on A:10.0 and C:30.0 (and thus indirectly A:10.1). Let's also say that C\n+depends on a feature added into 10.1. This means that if 10.0 is selected as the\n+resolved version, then C will fail at runtime. From library D's perspective,\n+this is fine, since Gradle chooses version 10.1.\n+\n+Suppose we add a new library E which uses Maven as its build system, and which\n+adds D as a dependency. When E is built, Maven resolves the whole dependency\n+graph, including D's subgraph, even though Gradle resolved the subgraph of D for\n+itself when D was originally built. When Maven performs its version resolution,\n+it chooses a different version of A (10.0) than Gradle did (10.1), which breaks\n+C. This happens even though D works perfectly fine internally.\n+\n+<img src=\"assets/images/ddc-resolution-08.png\">\n+\n+As a consequence, the author of library E might file a bug against library\n+D. The author of library D would argue that there is no bug. From their narrow\n+perspectives they are both right. From the ecosystem perspective, the author of\n+library D unfortunately needs to adapt their dependencies so they don't cause\n+problems for Maven consumers (even though they may have sworn off Maven and use\n+Gradle exclusively). In this case, they have an easy fix - they can upgrade the\n+direct dependency of D on A:10.0 to A:10.1, so that both build systems select\n+the same versions, and everyone can be happy.", "originalCommit": "c68f34510d608e58bfed850d81aa93bc693e7c09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIyNjgwMg==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387226802", "bodyText": "Ok", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T18:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MzM1NQ=="}], "type": "inlineReview"}, {"oid": "62d2bbafd706a74f32d01ea100e53c09f74b2e2b", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/commit/62d2bbafd706a74f32d01ea100e53c09f74b2e2b", "message": "PR feedback, fourth round", "committedDate": "2020-03-03T19:00:00Z", "type": "commit"}, {"oid": "a380480fb10b32a143d8580fcc5d5a97e9e547bd", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/commit/a380480fb10b32a143d8580fcc5d5a97e9e547bd", "message": "tweak", "committedDate": "2020-03-03T19:05:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0ODM3Nw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387248377", "bodyText": "Maven", "author": "elharo", "createdAt": "2020-03-03T19:37:39Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,132 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems (Maven and\n+Gradle) use different version resolution algorithms. This article explains how\n+the algorithms of these two build systems work and how they interact with each\n+other. No matter which build system you choose, you are likely to have direct or\n+indirect dependencies that use the other one, so you need to understand how both\n+work. To limit the scope, we ignore other build environments like Eclipse and\n+Ant that are not based on the Maven repository system.\n+\n+Maven and Gradle use different names for the process of selecting dependency\n+versions: Maven calls the process *dependency mediation*, while Gradle calls the\n+process *version conflict resolution*. In this article, we use the term *version\n+resolution*, omitting the word \"conflict\" so that the process is not confused\n+with program-breaking conflicts that we discuss elsewhere. \n+\n+Before looking at Maven and Gradle specifically, it's important to understand\n+the concepts of version resolution in general. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph,\n+there can be multiple versions of each library. The version resolution process\n+walks the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\" alt=\"version resolution process\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\" alt=\"unresolved graph\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\" alt=\"resolved graph, A:10.0 chosen\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\" alt=\"resolved graph, A:10.1 chosen\">\n+\n+So why do we need to pick a single version? The reason is that each class loader\n+only loads one version of each fully-qualified class name at runtime. So, if you\n+put multiple versions on the classpath, you do not get both versions at\n+runtime. Java build systems handle this issue upfront by picking a single\n+version for each library before the classpath is even constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle picks A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\" alt=\"Gradle example 1\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\" alt=\"Gradle example 2\">\n+\n+Next consider Maven. Maven chooses the version that is closest to the root of\n+the dependency graph, and if there is a tie, it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph in\n+breadth-first order. Looking at the same unresolved dependency graph we used\n+in Gradle example 1:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\" alt=\"Maven example 1\">\n+\n+As you can see by comparing the resolved graphs, Maven makes the opposite\n+choice. Now consider at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\" alt=\"Maven example 2\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+It should be noted that Maven and Gradle don't always make the opposite choice.\n+In the following example, the highest version is also the closest to the root,\n+so Maven and Gradle both choose A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-07b.png\" alt=\"Maven and Gradle example\">\n+\n+## Interaction between Maven and Gradle\n+\n+When a library is built, its build system performs version resolution for its\n+entire dependency graph. Since the build systems of the libraries in that\n+dependency graph also perform their own version resolution, the versions\n+selected can be different, especially when a consumer uses a different build\n+system than its dependencies. Sometimes, the version selected by the consumer\n+can be incompatible with the version selected by the dependency when the\n+dependency is built by itself.\n+\n+Consider an example using Gradle example 2 as its basis, where library D depends\n+on A:10.0 and C:30.0 (and thus indirectly A:10.1). Assume C depends on a feature\n+added into 10.1. This means that if 10.0 is selected, C fails at runtime. From\n+library D's perspective, this is fine, since Gradle chooses version 10.1.\n+\n+Suppose we add a new library E which uses Maven as its build system, and which\n+adds D as a dependency. When E is built, Maven resolves the whole dependency\n+graph, including D's subgraph, even though Gradle resolved the subgraph of D for\n+when D was originally built. When Maven performs its version resolution,\n+it chooses a different version of A (10.0) than Gradle did (10.1), which breaks\n+C. This happens even though D works perfectly fine internally.\n+\n+<img src=\"assets/images/ddc-resolution-08.png\" alt=\"Gradle and maven disagreement\">", "originalCommit": "a380480fb10b32a143d8580fcc5d5a97e9e547bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0ODY3MQ==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387248671", "bodyText": "nit: hyphen to em dash, or make this two sentences.", "author": "elharo", "createdAt": "2020-03-03T19:38:12Z", "path": "docs/how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,132 @@\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems (Maven and\n+Gradle) use different version resolution algorithms. This article explains how\n+the algorithms of these two build systems work and how they interact with each\n+other. No matter which build system you choose, you are likely to have direct or\n+indirect dependencies that use the other one, so you need to understand how both\n+work. To limit the scope, we ignore other build environments like Eclipse and\n+Ant that are not based on the Maven repository system.\n+\n+Maven and Gradle use different names for the process of selecting dependency\n+versions: Maven calls the process *dependency mediation*, while Gradle calls the\n+process *version conflict resolution*. In this article, we use the term *version\n+resolution*, omitting the word \"conflict\" so that the process is not confused\n+with program-breaking conflicts that we discuss elsewhere. \n+\n+Before looking at Maven and Gradle specifically, it's important to understand\n+the concepts of version resolution in general. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph,\n+there can be multiple versions of each library. The version resolution process\n+walks the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\" alt=\"version resolution process\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\" alt=\"unresolved graph\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\" alt=\"resolved graph, A:10.0 chosen\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\" alt=\"resolved graph, A:10.1 chosen\">\n+\n+So why do we need to pick a single version? The reason is that each class loader\n+only loads one version of each fully-qualified class name at runtime. So, if you\n+put multiple versions on the classpath, you do not get both versions at\n+runtime. Java build systems handle this issue upfront by picking a single\n+version for each library before the classpath is even constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle picks A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\" alt=\"Gradle example 1\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\" alt=\"Gradle example 2\">\n+\n+Next consider Maven. Maven chooses the version that is closest to the root of\n+the dependency graph, and if there is a tie, it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph in\n+breadth-first order. Looking at the same unresolved dependency graph we used\n+in Gradle example 1:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\" alt=\"Maven example 1\">\n+\n+As you can see by comparing the resolved graphs, Maven makes the opposite\n+choice. Now consider at the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\" alt=\"Maven example 2\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+It should be noted that Maven and Gradle don't always make the opposite choice.\n+In the following example, the highest version is also the closest to the root,\n+so Maven and Gradle both choose A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-07b.png\" alt=\"Maven and Gradle example\">\n+\n+## Interaction between Maven and Gradle\n+\n+When a library is built, its build system performs version resolution for its\n+entire dependency graph. Since the build systems of the libraries in that\n+dependency graph also perform their own version resolution, the versions\n+selected can be different, especially when a consumer uses a different build\n+system than its dependencies. Sometimes, the version selected by the consumer\n+can be incompatible with the version selected by the dependency when the\n+dependency is built by itself.\n+\n+Consider an example using Gradle example 2 as its basis, where library D depends\n+on A:10.0 and C:30.0 (and thus indirectly A:10.1). Assume C depends on a feature\n+added into 10.1. This means that if 10.0 is selected, C fails at runtime. From\n+library D's perspective, this is fine, since Gradle chooses version 10.1.\n+\n+Suppose we add a new library E which uses Maven as its build system, and which\n+adds D as a dependency. When E is built, Maven resolves the whole dependency\n+graph, including D's subgraph, even though Gradle resolved the subgraph of D for\n+when D was originally built. When Maven performs its version resolution,\n+it chooses a different version of A (10.0) than Gradle did (10.1), which breaks\n+C. This happens even though D works perfectly fine internally.\n+\n+<img src=\"assets/images/ddc-resolution-08.png\" alt=\"Gradle and maven disagreement\">\n+\n+As a consequence, the author of library E might file a bug against library\n+D. The author of library D would argue that there is no bug. From their individual\n+perspectives, are both right. From the ecosystem perspective, the author of\n+library D unfortunately needs to adapt its dependencies so they don't cause\n+problems for Maven consumers (even though they may have sworn off Maven and use\n+Gradle exclusively). In this case, they have an easy fix - they can upgrade the", "originalCommit": "a380480fb10b32a143d8580fcc5d5a97e9e547bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI1MzU3OA==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r387253578", "bodyText": "Done.", "author": "garrettjonesgoogle", "createdAt": "2020-03-03T19:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0ODY3MQ=="}], "type": "inlineReview"}, {"oid": "2592f3acda3fc2085e057ac32a3e080377297efe", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/commit/2592f3acda3fc2085e057ac32a3e080377297efe", "message": "PR feedback, fifth round", "committedDate": "2020-03-03T19:46:08Z", "type": "commit"}, {"oid": "fc99012273796ce08823c402594b922962fc9573", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/commit/fc99012273796ce08823c402594b922962fc9573", "message": "Merge branch 'master' of https://github.com/GoogleCloudPlatform/cloud-opensource-java", "committedDate": "2020-03-04T23:51:52Z", "type": "commit"}, {"oid": "fefc3622fe4f99678201678a18178efdb8dc7b79", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/commit/fefc3622fe4f99678201678a18178efdb8dc7b79", "message": "Fixing link", "committedDate": "2020-03-04T23:56:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYyOTczNw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r389629737", "bodyText": "alt text should be a description of the content of the image in words sufficient for a non-sighted user. These images are core parts of the article, not simple decorations, so it's worth writing this out in some detail. E.g.\nD: 40.0 is the root.\nIt depends on B:20.0 and C:30.0.\nB:20.0 and C:30.0  both depend on A:10.1.\nNothing depends on A:10.0.", "author": "elharo", "createdAt": "2020-03-09T12:30:30Z", "path": "docs/0003-how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+concepts: true\n+permalink: /how-does-version-resolution-work-in-maven-and-gradle\n+---\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems (Maven and\n+Gradle) use different version resolution algorithms. This article explains how\n+the algorithms of these two build systems work and how they interact with each\n+other. No matter which build system you choose, you are likely to have direct or\n+indirect dependencies that use the other one, so you need to understand how both\n+work. To limit the scope, we ignore other build environments like Eclipse and\n+Ant that are not based on the Maven repository system.\n+\n+Maven and Gradle use different names for the process of selecting dependency\n+versions: Maven calls the process *dependency mediation*, while Gradle calls the\n+process *version conflict resolution*. In this article, we use the term *version\n+resolution*, omitting the word \"conflict\" so that the process is not confused\n+with program-breaking conflicts that we discuss elsewhere. \n+\n+Before looking at Maven and Gradle specifically, it's important to understand\n+the concepts of version resolution in general. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph,\n+there can be multiple versions of each library. The version resolution process\n+walks the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\" alt=\"version resolution process\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\" alt=\"unresolved graph\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\" alt=\"resolved graph, A:10.0 chosen\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\" alt=\"resolved graph, A:10.1 chosen\">\n+\n+So why do we need to pick a single version? The reason is that each class loader\n+only loads one version of each fully-qualified class name at runtime. So, if you\n+put multiple versions on the classpath, you do not get both versions at\n+runtime. Java build systems handle this issue upfront by picking a single\n+version for each library before the classpath is even constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle picks A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\" alt=\"Gradle example 1\">", "originalCommit": "fefc3622fe4f99678201678a18178efdb8dc7b79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgyNTAyNw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r389825027", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            graph. We call the graph representation of this output a *resolved dependency\n          \n          \n            \n            graph. In this document, we call the graph representation of this output a *resolved dependency\n          \n      \n    \n    \n  \n\nI don't remember using the term, but useful to have one to describe graphs in this document.", "author": "suztomo", "createdAt": "2020-03-09T16:56:28Z", "path": "docs/0003-how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+concepts: true\n+permalink: /how-does-version-resolution-work-in-maven-and-gradle\n+---\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems (Maven and\n+Gradle) use different version resolution algorithms. This article explains how\n+the algorithms of these two build systems work and how they interact with each\n+other. No matter which build system you choose, you are likely to have direct or\n+indirect dependencies that use the other one, so you need to understand how both\n+work. To limit the scope, we ignore other build environments like Eclipse and\n+Ant that are not based on the Maven repository system.\n+\n+Maven and Gradle use different names for the process of selecting dependency\n+versions: Maven calls the process *dependency mediation*, while Gradle calls the\n+process *version conflict resolution*. In this article, we use the term *version\n+resolution*, omitting the word \"conflict\" so that the process is not confused\n+with program-breaking conflicts that we discuss elsewhere. \n+\n+Before looking at Maven and Gradle specifically, it's important to understand\n+the concepts of version resolution in general. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph,\n+there can be multiple versions of each library. The version resolution process\n+walks the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency", "originalCommit": "fefc3622fe4f99678201678a18178efdb8dc7b79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg2NDU2Nw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r389864567", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - **Maven**: [Introduction to the Dependency Mechanism](http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html)\n          \n          \n            \n            - **Maven**: [Introduction to the Dependency Mechanism](https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html)", "author": "suztomo", "createdAt": "2020-03-09T17:59:22Z", "path": "docs/0003-how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+concepts: true\n+permalink: /how-does-version-resolution-work-in-maven-and-gradle\n+---\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems (Maven and\n+Gradle) use different version resolution algorithms. This article explains how\n+the algorithms of these two build systems work and how they interact with each\n+other. No matter which build system you choose, you are likely to have direct or\n+indirect dependencies that use the other one, so you need to understand how both\n+work. To limit the scope, we ignore other build environments like Eclipse and\n+Ant that are not based on the Maven repository system.\n+\n+Maven and Gradle use different names for the process of selecting dependency\n+versions: Maven calls the process *dependency mediation*, while Gradle calls the\n+process *version conflict resolution*. In this article, we use the term *version\n+resolution*, omitting the word \"conflict\" so that the process is not confused\n+with program-breaking conflicts that we discuss elsewhere. \n+\n+Before looking at Maven and Gradle specifically, it's important to understand\n+the concepts of version resolution in general. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph,\n+there can be multiple versions of each library. The version resolution process\n+walks the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\" alt=\"version resolution process\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\" alt=\"unresolved graph\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\" alt=\"resolved graph, A:10.0 chosen\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\" alt=\"resolved graph, A:10.1 chosen\">\n+\n+So why do we need to pick a single version? The reason is that each class loader\n+only loads one version of each fully-qualified class name at runtime. So, if you\n+put multiple versions on the classpath, you do not get both versions at\n+runtime. Java build systems handle this issue upfront by picking a single\n+version for each library before the classpath is even constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle picks A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\" alt=\"Gradle example 1\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\" alt=\"Gradle example 2\">\n+\n+Next consider Maven. Maven chooses the version that is closest to the root of\n+the dependency graph, and if there is a tie, it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph in\n+breadth-first order. Looking at the same unresolved dependency graph we used\n+in Gradle example 1:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\" alt=\"Maven example 1\">\n+\n+As you can see by comparing the resolved graphs, Maven makes the opposite\n+choice. Now consider the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\" alt=\"Maven example 2\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+It should be noted that Maven and Gradle don't always make the opposite choice.\n+In the following example, the highest version is also the closest to the root,\n+so Maven and Gradle both choose A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-07b.png\" alt=\"Maven and Gradle example\">\n+\n+## Interaction between Maven and Gradle\n+\n+When a library is built, its build system performs version resolution for its\n+entire dependency graph. Since the build systems of the libraries in that\n+dependency graph also perform their own version resolution, the versions\n+selected can be different, especially when a consumer uses a different build\n+system than its dependencies. Sometimes, the version selected by the consumer\n+can be incompatible with the version selected by the dependency when the\n+dependency is built by itself.\n+\n+Consider an example using Gradle example 2 as its basis, where library D depends\n+on A:10.0 and C:30.0 (and thus indirectly A:10.1). Assume C depends on a feature\n+added into 10.1. This means that if 10.0 is selected, C fails at runtime. From\n+library D's perspective, this is fine, since Gradle chooses version 10.1.\n+\n+Suppose a new library E uses Maven as its build system and has a dependency on\n+D. When E is built, Maven resolves the whole dependency graph, including D's\n+subgraph, even though Gradle resolved the subgraph of D for when D was\n+originally built. When Maven performs its version resolution, it chooses a\n+different version of A (10.0) than Gradle did (10.1), which breaks C. This\n+happens even though D works perfectly fine internally.\n+\n+<img src=\"assets/images/ddc-resolution-08.png\" alt=\"Gradle and Maven disagreement\">\n+\n+As a consequence, the author of library E might file a bug against library\n+D. The author of library D would argue that there is no bug. From their individual\n+perspectives, are both right. From the ecosystem perspective, the author of\n+library D unfortunately needs to adapt its dependencies so they don't cause\n+problems for Maven consumers (even though they may have sworn off Maven and use\n+Gradle exclusively). In this case, they have an easy fix \u2013 they can upgrade the\n+direct dependency of D on A:10.0 to A:10.1, so that both build systems select\n+the same version, and everyone is happy.\n+\n+<img src=\"assets/images/ddc-resolution-09.png\" alt=\"Gradle and Maven agreement\">\n+\n+There are many more possible scenarios which require more complicated\n+fixes. Solving those problems will be the topic of another article.\n+\n+For more details on each build system, see their respective documentation:\n+\n+- **Maven**: [Introduction to the Dependency Mechanism](http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html)", "originalCommit": "fefc3622fe4f99678201678a18178efdb8dc7b79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg2NjU4Nw==", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/pull/1259#discussion_r389866587", "bodyText": "I would add the assumption that library D is now published to a Maven repository (potentially local) through Gradle's maven-publish plugin. That makes the two worlds work together.", "author": "suztomo", "createdAt": "2020-03-09T18:02:58Z", "path": "docs/0003-how-does-version-resolution-work-in-maven-and-gradle.md", "diffHunk": "@@ -0,0 +1,136 @@\n+---\n+concepts: true\n+permalink: /how-does-version-resolution-work-in-maven-and-gradle\n+---\n+# How does version resolution work in Maven and Gradle?\n+\n+The build system that you choose for building your Java code determines which\n+version resolution algorithm is used to choose the versions of your\n+dependencies. Unfortunately, the two most popular build systems (Maven and\n+Gradle) use different version resolution algorithms. This article explains how\n+the algorithms of these two build systems work and how they interact with each\n+other. No matter which build system you choose, you are likely to have direct or\n+indirect dependencies that use the other one, so you need to understand how both\n+work. To limit the scope, we ignore other build environments like Eclipse and\n+Ant that are not based on the Maven repository system.\n+\n+Maven and Gradle use different names for the process of selecting dependency\n+versions: Maven calls the process *dependency mediation*, while Gradle calls the\n+process *version conflict resolution*. In this article, we use the term *version\n+resolution*, omitting the word \"conflict\" so that the process is not confused\n+with program-breaking conflicts that we discuss elsewhere. \n+\n+Before looking at Maven and Gradle specifically, it's important to understand\n+the concepts of version resolution in general. The input of this process is a\n+dependency graph which reflects the dependencies as specified by each library in\n+the graph, which we call an *unresolved dependency graph*. In such a graph,\n+there can be multiple versions of each library. The version resolution process\n+walks the unresolved dependency graph and decides which version to use for every\n+library encountered. Whether or not the build tool produces a graph as an output\n+of this resolution, it is useful to think of this output in terms of a new\n+graph. We call the graph representation of this output a *resolved dependency\n+graph*. Here is a visual representation of the process:\n+\n+<img src=\"assets/images/ddc-resolution-00.png\" alt=\"version resolution process\">\n+\n+For example, we could have an unresolved graph that looks like this:\n+\n+<img src=\"assets/images/ddc-resolution-01.png\" alt=\"unresolved graph\">\n+\n+In this graph, there are two versions of A (10.0 and 10.1). The version\n+resolution process picks a single version for A, which could be either version\n+depending on the algorithm. If A:10.0 is picked, the resolved dependency graph\n+looks like the following. In this graph, C's dependency on A:10.1 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-02.png\" alt=\"resolved graph, A:10.0 chosen\">\n+\n+If A:10.1 is picked, the resolved dependency graph looks like the following. In\n+this graph, B's dependency on A:10.0 is overridden.\n+\n+<img src=\"assets/images/ddc-resolution-03.png\" alt=\"resolved graph, A:10.1 chosen\">\n+\n+So why do we need to pick a single version? The reason is that each class loader\n+only loads one version of each fully-qualified class name at runtime. So, if you\n+put multiple versions on the classpath, you do not get both versions at\n+runtime. Java build systems handle this issue upfront by picking a single\n+version for each library before the classpath is even constructed.\n+\n+Now let's look at the version resolution algorithms used by Gradle and\n+Maven. Let's consider Gradle first because it is the simpler one to\n+describe. Simply put, Gradle chooses the highest version encountered in your\n+dependency graph. For the example above, Gradle picks A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-04.png\" alt=\"Gradle example 1\">\n+\n+Gradle applies the higher-version rule even if it overrides one of your own\n+direct dependency declarations:\n+\n+<img src=\"assets/images/ddc-resolution-05.png\" alt=\"Gradle example 2\">\n+\n+Next consider Maven. Maven chooses the version that is closest to the root of\n+the dependency graph, and if there is a tie, it chooses the version it\n+encounters first. Another way to describe the algorithm is that Maven chooses\n+the first version encountered when traversing the dependency graph in\n+breadth-first order. Looking at the same unresolved dependency graph we used\n+in Gradle example 1:\n+\n+<img src=\"assets/images/ddc-resolution-06.png\" alt=\"Maven example 1\">\n+\n+As you can see by comparing the resolved graphs, Maven makes the opposite\n+choice. Now consider the second example, where the root has both a direct and\n+indirect dependency on the same library:\n+\n+<img src=\"assets/images/ddc-resolution-07.png\" alt=\"Maven example 2\">\n+\n+In this case, Maven chooses A:10.0 because it is only 1 hop away from the root\n+instead of 2 hops (A:10.1). In this case, Maven also makes the opposite choice\n+of Gradle.\n+\n+It should be noted that Maven and Gradle don't always make the opposite choice.\n+In the following example, the highest version is also the closest to the root,\n+so Maven and Gradle both choose A:10.1.\n+\n+<img src=\"assets/images/ddc-resolution-07b.png\" alt=\"Maven and Gradle example\">\n+\n+## Interaction between Maven and Gradle\n+\n+When a library is built, its build system performs version resolution for its\n+entire dependency graph. Since the build systems of the libraries in that\n+dependency graph also perform their own version resolution, the versions\n+selected can be different, especially when a consumer uses a different build\n+system than its dependencies. Sometimes, the version selected by the consumer\n+can be incompatible with the version selected by the dependency when the\n+dependency is built by itself.\n+\n+Consider an example using Gradle example 2 as its basis, where library D depends\n+on A:10.0 and C:30.0 (and thus indirectly A:10.1). Assume C depends on a feature\n+added into 10.1. This means that if 10.0 is selected, C fails at runtime. From\n+library D's perspective, this is fine, since Gradle chooses version 10.1.\n+\n+Suppose a new library E uses Maven as its build system and has a dependency on", "originalCommit": "fefc3622fe4f99678201678a18178efdb8dc7b79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "917b9ad1bbc733fd315bd70d6985bdca10ba9c2b", "url": "https://github.com/GoogleCloudPlatform/cloud-opensource-java/commit/917b9ad1bbc733fd315bd70d6985bdca10ba9c2b", "message": "Merge branch 'master' into alt", "committedDate": "2020-08-10T11:23:50Z", "type": "commit"}]}