{"pr_number": 1013, "pr_title": "Pubstack analytics module", "pr_createdAt": "2020-11-17T09:57:03Z", "pr_url": "https://github.com/prebid/prebid-server-java/pull/1013", "timeline": [{"oid": "a9ca2113fbccff8f7b836f08b9db1e202c4dc013", "url": "https://github.com/prebid/prebid-server-java/commit/a9ca2113fbccff8f7b836f08b9db1e202c4dc013", "message": "Pubstack analytics module implemented", "committedDate": "2020-11-17T09:30:37Z", "type": "commit"}, {"oid": "a3269efce9432448655b31e58562dee6371ab606", "url": "https://github.com/prebid/prebid-server-java/commit/a3269efce9432448655b31e58562dee6371ab606", "message": "Merge branch 'master' into pubstack-analytics-module\n\n# Conflicts:\n#\tsrc/test/java/org/prebid/server/vertx/http/CircuitBreakerSecuredHttpClientTest.java", "committedDate": "2020-11-17T09:55:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE0NjY4OA==", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r526146688", "bodyText": "Wouldn't JacksonMapper#decodeValue() work in this case? It wraps deserialization exceptions into proper DecodeException.", "author": "schernysh", "createdAt": "2020-11-18T14:50:35Z", "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackAnalyticsReporter.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package org.prebid.server.analytics.pubstack;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.logging.Logger;\n+import io.vertx.core.logging.LoggerFactory;\n+import org.apache.commons.collections4.MapUtils;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.prebid.server.analytics.AnalyticsReporter;\n+import org.prebid.server.analytics.model.AmpEvent;\n+import org.prebid.server.analytics.model.AuctionEvent;\n+import org.prebid.server.analytics.model.CookieSyncEvent;\n+import org.prebid.server.analytics.model.SetuidEvent;\n+import org.prebid.server.analytics.model.VideoEvent;\n+import org.prebid.server.analytics.pubstack.model.EventType;\n+import org.prebid.server.analytics.pubstack.model.PubstackAnalyticsProperties;\n+import org.prebid.server.analytics.pubstack.model.PubstackConfig;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.util.HttpUtil;\n+import org.prebid.server.vertx.Initializable;\n+import org.prebid.server.vertx.http.HttpClient;\n+import org.prebid.server.vertx.http.model.HttpClientResponse;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class PubstackAnalyticsReporter implements AnalyticsReporter, Initializable {\n+\n+    private static final String EVENT_REPORT_ENDPOINT_PATH = \"/intake\";\n+    private static final Logger logger = LoggerFactory.getLogger(PubstackAnalyticsReporter.class);\n+    private static final Map<String, EventType> CLASS_TO_EVENT_TYPE;\n+\n+    static {\n+        CLASS_TO_EVENT_TYPE = new HashMap<>();\n+        CLASS_TO_EVENT_TYPE.put(AuctionEvent.class.getName(), EventType.auction);\n+        CLASS_TO_EVENT_TYPE.put(AmpEvent.class.getName(), EventType.amp);\n+        CLASS_TO_EVENT_TYPE.put(VideoEvent.class.getName(), EventType.video);\n+        CLASS_TO_EVENT_TYPE.put(SetuidEvent.class.getName(), EventType.setuid);\n+        CLASS_TO_EVENT_TYPE.put(CookieSyncEvent.class.getName(), EventType.cookiesync);\n+    }\n+\n+    private static final String CONFIG_URL_SUFFIX = \"/bootstrap?scopeId=\";\n+\n+    private final long configurationRefreshDelay;\n+    private final long timeout;\n+    private final Map<EventType, PubstackEventHandler> eventHandlers;\n+    private final HttpClient httpClient;\n+    private final JacksonMapper jacksonMapper;\n+    private final Vertx vertx;\n+    private PubstackConfig pubstackConfig;\n+\n+    public PubstackAnalyticsReporter(PubstackAnalyticsProperties pubstackAnalyticsProperties,\n+                                     Map<EventType, PubstackEventHandler> eventHandlers,\n+                                     HttpClient httpClient,\n+                                     JacksonMapper jacksonMapper,\n+                                     Vertx vertx) {\n+        this.configurationRefreshDelay =\n+                Objects.requireNonNull(pubstackAnalyticsProperties.getConfigurationRefreshDelayMs());\n+        this.timeout = Objects.requireNonNull(pubstackAnalyticsProperties.getTimeoutMs());\n+        this.eventHandlers = Objects.requireNonNull(eventHandlers);\n+        this.httpClient = Objects.requireNonNull(httpClient);\n+        this.jacksonMapper = Objects.requireNonNull(jacksonMapper);\n+        this.vertx = Objects.requireNonNull(vertx);\n+\n+        this.pubstackConfig = PubstackConfig.of(pubstackAnalyticsProperties.getScopeId(),\n+                pubstackAnalyticsProperties.getEndpoint(), Collections.emptyMap());\n+\n+    }\n+\n+    public <T> void processEvent(T event) {\n+        final EventType eventType = CLASS_TO_EVENT_TYPE.get(event.getClass().getName());\n+        if (eventType != null) {\n+            eventHandlers.get(eventType).handle(event);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        vertx.setPeriodic(configurationRefreshDelay, id -> fetchRemoteConfig());\n+        fetchRemoteConfig();\n+    }\n+\n+    public void shutdown() {\n+        eventHandlers.values().forEach(PubstackEventHandler::reportEvents);\n+    }\n+\n+    private void fetchRemoteConfig() {\n+        logger.info(\"[pubstack] Updating config: {0}\", pubstackConfig);\n+        httpClient.get(makeEventEndpointUrl(pubstackConfig.getEndpoint(), pubstackConfig.getScopeId()), timeout)\n+                .map(this::processRemoteConfigurationResponse)\n+                .setHandler(this::updateConfigsOnChange);\n+    }\n+\n+    private PubstackConfig processRemoteConfigurationResponse(HttpClientResponse response) {\n+        final int statusCode = response.getStatusCode();\n+        if (statusCode != 200) {\n+            throw new PreBidException(String.format(\"[pubstack] Failed to fetch config, reason: HTTP status code %d\",\n+                    statusCode));\n+        }\n+        final String body = response.getBody();\n+        try {\n+            return jacksonMapper.mapper().readValue(body, PubstackConfig.class);", "originalCommit": "a3269efce9432448655b31e58562dee6371ab606", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5MzA0Nw==", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r526193047", "bodyText": "I suggest that we stick with io.netty.handler.codec.http.HttpResponseStatus because we already use it throughout our codebase.", "author": "schernysh", "createdAt": "2020-11-18T15:47:52Z", "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackEventHandler.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package org.prebid.server.analytics.pubstack;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.logging.Logger;\n+import io.vertx.core.logging.LoggerFactory;\n+import org.apache.http.HttpStatus;", "originalCommit": "a3269efce9432448655b31e58562dee6371ab606", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE5NTk1OA==", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r526195958", "bodyText": "This initialization looks like a good candidate to move inside PubstackAnalyticsReporter. Are there solid reasons not to do this?", "author": "schernysh", "createdAt": "2020-11-18T15:51:27Z", "path": "src/main/java/org/prebid/server/spring/config/AnalyticsConfiguration.java", "diffHunk": "@@ -28,4 +42,98 @@ CompositeAnalyticsReporter compositeAnalyticsReporter(\n     LogAnalyticsReporter logAnalyticsReporter(JacksonMapper mapper) {\n         return new LogAnalyticsReporter(mapper);\n     }\n+\n+    @Configuration\n+    @ConditionalOnProperty(prefix = \"analytics.pubstack\", name = \"enabled\", havingValue = \"true\")\n+    public static class PubstackAnalyticsConfiguration {\n+\n+        private static final String EVENT_REPORT_ENDPOINT_PATH = \"/intake\";\n+\n+        @Bean\n+        PubstackAnalyticsReporter pubstackAnalyticsReporter(PubstackAnalyticsProperties pubstackAnalyticsProperties,\n+                                                            HttpClient httpClient,\n+                                                            JacksonMapper jacksonMapper,\n+                                                            Vertx vertx) {\n+            final org.prebid.server.analytics.pubstack.model.PubstackAnalyticsProperties properties =\n+                    pubstackAnalyticsProperties.toComponentProperties();\n+            final Map<EventType, PubstackEventHandler> eventHandlers = Arrays.stream(EventType.values())", "originalCommit": "a3269efce9432448655b31e58562dee6371ab606", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6563f9b2280b2c043b94e1a29e9743915f5f98fe", "url": "https://github.com/prebid/prebid-server-java/commit/6563f9b2280b2c043b94e1a29e9743915f5f98fe", "message": "Merge branch 'master' into pubstack-analytics-module", "committedDate": "2020-12-07T13:00:03Z", "type": "commit"}, {"oid": "10228529c4f05807f0145737c9fa27e6ac18213d", "url": "https://github.com/prebid/prebid-server-java/commit/10228529c4f05807f0145737c9fa27e6ac18213d", "message": "- use netty HttpStatus\n- initiate Pubstack handlers inside reporter\n- use jackson.decode() method", "committedDate": "2020-12-07T14:25:49Z", "type": "commit"}, {"oid": "9685db5ee770d28766895cf9dc687aa4191f7d89", "url": "https://github.com/prebid/prebid-server-java/commit/9685db5ee770d28766895cf9dc687aa4191f7d89", "message": "Merge branch 'master' into pubstack-analytics-module\n\n# Conflicts:\n#\tsrc/main/java/org/prebid/server/spring/config/AnalyticsConfiguration.java\n#\tsrc/test/java/org/prebid/server/bidder/HttpAdapterConnectorTest.java", "committedDate": "2021-02-15T13:55:46Z", "type": "commit"}, {"oid": "813a526bd036119ab980e81459f9e24f882950c6", "url": "https://github.com/prebid/prebid-server-java/commit/813a526bd036119ab980e81459f9e24f882950c6", "message": "Merge branch 'master' into pubstack-analytics-module", "committedDate": "2021-03-12T12:59:08Z", "type": "commit"}, {"oid": "390928e863e8985c4f6e2d316110d1e91cf41721", "url": "https://github.com/prebid/prebid-server-java/commit/390928e863e8985c4f6e2d316110d1e91cf41721", "message": "Update tests after merge from master", "committedDate": "2021-03-12T13:04:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTg3NjYzNQ==", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r611876635", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Queue<String> copyToSend = events.get();\n          \n          \n            \n                    final Queue<String> copyToSend = events.getAndSet(new ConcurrentLinkedQueue<>());\n          \n      \n    \n    \n  \n\nOtherwise this is not an atomic swap", "author": "muuki88", "createdAt": "2021-04-12T18:55:01Z", "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackEventHandler.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package org.prebid.server.analytics.pubstack;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.logging.Logger;\n+import io.vertx.core.logging.LoggerFactory;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.prebid.server.analytics.pubstack.model.PubstackAnalyticsProperties;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.util.HttpUtil;\n+import org.prebid.server.vertx.http.HttpClient;\n+import org.prebid.server.vertx.http.model.HttpClientResponse;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Predicate;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class PubstackEventHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PubstackEventHandler.class);\n+    private static final String SCOPE_FIELD_NAME = \"scope\";\n+    private static final String APPLICATION_OCTET_STREAM = \"application/octet-stream\";\n+    private static final String GZIP = \"gzip\";\n+    private static final String NEW_LINE = \"\\n\";\n+\n+    private volatile boolean enabled;\n+    private volatile String endpoint;\n+    private volatile String scopeId;\n+    private final long maxByteSize;\n+    private final long maxEventCount;\n+    private final long reportTtlMillis;\n+    private final long timeoutMs;\n+    private final Vertx vertx;\n+    private final JacksonMapper jacksonMapper;\n+    private final HttpClient httpClient;\n+\n+    private final ReentrantLock lockOnSend;\n+    private final AtomicReference<Queue<String>> events;\n+    private final MultiMap headers;\n+    private final AtomicLong byteSize;\n+    private volatile long reportTimerId;\n+\n+    public PubstackEventHandler(PubstackAnalyticsProperties pubstackAnalyticsProperties,\n+                                boolean enabled,\n+                                String endpoint,\n+                                JacksonMapper jacksonMapper,\n+                                HttpClient httpClient,\n+                                Vertx vertx) {\n+        this.enabled = enabled;\n+        this.endpoint = HttpUtil.validateUrl(endpoint);\n+        this.scopeId = pubstackAnalyticsProperties.getScopeId();\n+        this.maxByteSize = pubstackAnalyticsProperties.getSizeBytes();\n+        this.maxEventCount = pubstackAnalyticsProperties.getCount();\n+        this.reportTtlMillis = pubstackAnalyticsProperties.getReportTtlMs();\n+        this.timeoutMs = pubstackAnalyticsProperties.getTimeoutMs();\n+        this.jacksonMapper = Objects.requireNonNull(jacksonMapper);\n+        this.httpClient = Objects.requireNonNull(httpClient);\n+        this.vertx = Objects.requireNonNull(vertx);\n+\n+        this.lockOnSend = new ReentrantLock();\n+        this.events = new AtomicReference<>(new ConcurrentLinkedQueue<>());\n+        this.headers = makeHeaders();\n+        this.byteSize = new AtomicLong();\n+        if (enabled) {\n+            this.reportTimerId = setReportTtlTimer();\n+        }\n+    }\n+\n+    public <T> void handle(T event) {\n+        if (enabled) {\n+            buffer(event);\n+            reportEventsOnCondition(byteSize -> byteSize.get() > maxByteSize, byteSize);\n+            reportEventsOnCondition(eventsReference -> eventsReference.get().size() > maxEventCount, events);\n+        }\n+    }\n+\n+    public void reportEvents() {\n+        if (enabled) {\n+            reportEventsOnCondition(events -> events.get().size() > 0, events);\n+        }\n+    }\n+\n+    public void updateConfig(boolean enabled, String endpoint, String scopeId) {\n+        updateTimerOnEnabling(enabled);\n+        this.enabled = enabled;\n+        this.endpoint = endpoint;\n+        this.scopeId = scopeId;\n+    }\n+\n+    private <T> void buffer(T event) {\n+        final ObjectNode eventNode = jacksonMapper.mapper().valueToTree(event);\n+        eventNode.put(SCOPE_FIELD_NAME, scopeId);\n+        final String jsonEvent = jacksonMapper.encode(eventNode);\n+        events.get().add(jsonEvent);\n+        byteSize.getAndAdd(jsonEvent.getBytes().length);\n+    }\n+\n+    private <T> boolean reportEventsOnCondition(Predicate<T> conditionToSend, T conditionValue) {\n+        boolean requestWasSent = false;\n+        if (conditionToSend.test(conditionValue)) {\n+            lockOnSend.lock();\n+            try {\n+                if (conditionToSend.test(conditionValue)) {\n+                    requestWasSent = true;\n+                    sendEvents(events);\n+                }\n+            } catch (Exception exception) {\n+                logger.error(\"[pubstack] Failed to send analytics report to endpoint {0} with a reason {1}\",\n+                        endpoint, exception.getMessage());\n+            } finally {\n+                lockOnSend.unlock();\n+            }\n+        }\n+        return requestWasSent;\n+    }\n+\n+    private void sendEvents(AtomicReference<Queue<String>> events) {\n+        final Queue<String> copyToSend = events.get();", "originalCommit": "390928e863e8985c4f6e2d316110d1e91cf41721", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTg3Njg2Mg==", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r611876862", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    events.set(new ConcurrentLinkedQueue<>());\n          \n      \n    \n    \n  \n\nShould be set above with getAndSet()", "author": "muuki88", "createdAt": "2021-04-12T18:55:23Z", "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackEventHandler.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package org.prebid.server.analytics.pubstack;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.logging.Logger;\n+import io.vertx.core.logging.LoggerFactory;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.prebid.server.analytics.pubstack.model.PubstackAnalyticsProperties;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.util.HttpUtil;\n+import org.prebid.server.vertx.http.HttpClient;\n+import org.prebid.server.vertx.http.model.HttpClientResponse;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Predicate;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class PubstackEventHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PubstackEventHandler.class);\n+    private static final String SCOPE_FIELD_NAME = \"scope\";\n+    private static final String APPLICATION_OCTET_STREAM = \"application/octet-stream\";\n+    private static final String GZIP = \"gzip\";\n+    private static final String NEW_LINE = \"\\n\";\n+\n+    private volatile boolean enabled;\n+    private volatile String endpoint;\n+    private volatile String scopeId;\n+    private final long maxByteSize;\n+    private final long maxEventCount;\n+    private final long reportTtlMillis;\n+    private final long timeoutMs;\n+    private final Vertx vertx;\n+    private final JacksonMapper jacksonMapper;\n+    private final HttpClient httpClient;\n+\n+    private final ReentrantLock lockOnSend;\n+    private final AtomicReference<Queue<String>> events;\n+    private final MultiMap headers;\n+    private final AtomicLong byteSize;\n+    private volatile long reportTimerId;\n+\n+    public PubstackEventHandler(PubstackAnalyticsProperties pubstackAnalyticsProperties,\n+                                boolean enabled,\n+                                String endpoint,\n+                                JacksonMapper jacksonMapper,\n+                                HttpClient httpClient,\n+                                Vertx vertx) {\n+        this.enabled = enabled;\n+        this.endpoint = HttpUtil.validateUrl(endpoint);\n+        this.scopeId = pubstackAnalyticsProperties.getScopeId();\n+        this.maxByteSize = pubstackAnalyticsProperties.getSizeBytes();\n+        this.maxEventCount = pubstackAnalyticsProperties.getCount();\n+        this.reportTtlMillis = pubstackAnalyticsProperties.getReportTtlMs();\n+        this.timeoutMs = pubstackAnalyticsProperties.getTimeoutMs();\n+        this.jacksonMapper = Objects.requireNonNull(jacksonMapper);\n+        this.httpClient = Objects.requireNonNull(httpClient);\n+        this.vertx = Objects.requireNonNull(vertx);\n+\n+        this.lockOnSend = new ReentrantLock();\n+        this.events = new AtomicReference<>(new ConcurrentLinkedQueue<>());\n+        this.headers = makeHeaders();\n+        this.byteSize = new AtomicLong();\n+        if (enabled) {\n+            this.reportTimerId = setReportTtlTimer();\n+        }\n+    }\n+\n+    public <T> void handle(T event) {\n+        if (enabled) {\n+            buffer(event);\n+            reportEventsOnCondition(byteSize -> byteSize.get() > maxByteSize, byteSize);\n+            reportEventsOnCondition(eventsReference -> eventsReference.get().size() > maxEventCount, events);\n+        }\n+    }\n+\n+    public void reportEvents() {\n+        if (enabled) {\n+            reportEventsOnCondition(events -> events.get().size() > 0, events);\n+        }\n+    }\n+\n+    public void updateConfig(boolean enabled, String endpoint, String scopeId) {\n+        updateTimerOnEnabling(enabled);\n+        this.enabled = enabled;\n+        this.endpoint = endpoint;\n+        this.scopeId = scopeId;\n+    }\n+\n+    private <T> void buffer(T event) {\n+        final ObjectNode eventNode = jacksonMapper.mapper().valueToTree(event);\n+        eventNode.put(SCOPE_FIELD_NAME, scopeId);\n+        final String jsonEvent = jacksonMapper.encode(eventNode);\n+        events.get().add(jsonEvent);\n+        byteSize.getAndAdd(jsonEvent.getBytes().length);\n+    }\n+\n+    private <T> boolean reportEventsOnCondition(Predicate<T> conditionToSend, T conditionValue) {\n+        boolean requestWasSent = false;\n+        if (conditionToSend.test(conditionValue)) {\n+            lockOnSend.lock();\n+            try {\n+                if (conditionToSend.test(conditionValue)) {\n+                    requestWasSent = true;\n+                    sendEvents(events);\n+                }\n+            } catch (Exception exception) {\n+                logger.error(\"[pubstack] Failed to send analytics report to endpoint {0} with a reason {1}\",\n+                        endpoint, exception.getMessage());\n+            } finally {\n+                lockOnSend.unlock();\n+            }\n+        }\n+        return requestWasSent;\n+    }\n+\n+    private void sendEvents(AtomicReference<Queue<String>> events) {\n+        final Queue<String> copyToSend = events.get();\n+        resetReportEventsConditions(events);\n+        httpClient.request(HttpMethod.POST, HttpUtil.validateUrl(endpoint), headers, toGzippedBytes(copyToSend),\n+                timeoutMs)\n+                .setHandler(this::handleReportResponse);\n+    }\n+\n+    private void resetReportEventsConditions(AtomicReference<Queue<String>> events) {\n+        events.set(new ConcurrentLinkedQueue<>());", "originalCommit": "390928e863e8985c4f6e2d316110d1e91cf41721", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTg3Nzc3MQ==", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r611877771", "bodyText": "Not sure if these are thread safe. The rest of the code seems to be implemented in a thread safe way, so this should probably be too.\nMaybe calculating the byteSize with the copied queue is a better way than having two states that can separately be set.", "author": "muuki88", "createdAt": "2021-04-12T18:56:46Z", "path": "src/main/java/org/prebid/server/analytics/pubstack/PubstackEventHandler.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package org.prebid.server.analytics.pubstack;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.logging.Logger;\n+import io.vertx.core.logging.LoggerFactory;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.prebid.server.analytics.pubstack.model.PubstackAnalyticsProperties;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.util.HttpUtil;\n+import org.prebid.server.vertx.http.HttpClient;\n+import org.prebid.server.vertx.http.model.HttpClientResponse;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Predicate;\n+import java.util.zip.GZIPOutputStream;\n+\n+public class PubstackEventHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PubstackEventHandler.class);\n+    private static final String SCOPE_FIELD_NAME = \"scope\";\n+    private static final String APPLICATION_OCTET_STREAM = \"application/octet-stream\";\n+    private static final String GZIP = \"gzip\";\n+    private static final String NEW_LINE = \"\\n\";\n+\n+    private volatile boolean enabled;\n+    private volatile String endpoint;\n+    private volatile String scopeId;\n+    private final long maxByteSize;\n+    private final long maxEventCount;\n+    private final long reportTtlMillis;\n+    private final long timeoutMs;\n+    private final Vertx vertx;\n+    private final JacksonMapper jacksonMapper;\n+    private final HttpClient httpClient;\n+\n+    private final ReentrantLock lockOnSend;\n+    private final AtomicReference<Queue<String>> events;\n+    private final MultiMap headers;\n+    private final AtomicLong byteSize;\n+    private volatile long reportTimerId;\n+\n+    public PubstackEventHandler(PubstackAnalyticsProperties pubstackAnalyticsProperties,\n+                                boolean enabled,\n+                                String endpoint,\n+                                JacksonMapper jacksonMapper,\n+                                HttpClient httpClient,\n+                                Vertx vertx) {\n+        this.enabled = enabled;\n+        this.endpoint = HttpUtil.validateUrl(endpoint);\n+        this.scopeId = pubstackAnalyticsProperties.getScopeId();\n+        this.maxByteSize = pubstackAnalyticsProperties.getSizeBytes();\n+        this.maxEventCount = pubstackAnalyticsProperties.getCount();\n+        this.reportTtlMillis = pubstackAnalyticsProperties.getReportTtlMs();\n+        this.timeoutMs = pubstackAnalyticsProperties.getTimeoutMs();\n+        this.jacksonMapper = Objects.requireNonNull(jacksonMapper);\n+        this.httpClient = Objects.requireNonNull(httpClient);\n+        this.vertx = Objects.requireNonNull(vertx);\n+\n+        this.lockOnSend = new ReentrantLock();\n+        this.events = new AtomicReference<>(new ConcurrentLinkedQueue<>());\n+        this.headers = makeHeaders();\n+        this.byteSize = new AtomicLong();\n+        if (enabled) {\n+            this.reportTimerId = setReportTtlTimer();\n+        }\n+    }\n+\n+    public <T> void handle(T event) {\n+        if (enabled) {\n+            buffer(event);\n+            reportEventsOnCondition(byteSize -> byteSize.get() > maxByteSize, byteSize);\n+            reportEventsOnCondition(eventsReference -> eventsReference.get().size() > maxEventCount, events);\n+        }\n+    }\n+\n+    public void reportEvents() {\n+        if (enabled) {\n+            reportEventsOnCondition(events -> events.get().size() > 0, events);\n+        }\n+    }\n+\n+    public void updateConfig(boolean enabled, String endpoint, String scopeId) {\n+        updateTimerOnEnabling(enabled);\n+        this.enabled = enabled;\n+        this.endpoint = endpoint;\n+        this.scopeId = scopeId;\n+    }\n+\n+    private <T> void buffer(T event) {\n+        final ObjectNode eventNode = jacksonMapper.mapper().valueToTree(event);\n+        eventNode.put(SCOPE_FIELD_NAME, scopeId);\n+        final String jsonEvent = jacksonMapper.encode(eventNode);\n+        events.get().add(jsonEvent);\n+        byteSize.getAndAdd(jsonEvent.getBytes().length);\n+    }\n+\n+    private <T> boolean reportEventsOnCondition(Predicate<T> conditionToSend, T conditionValue) {\n+        boolean requestWasSent = false;\n+        if (conditionToSend.test(conditionValue)) {\n+            lockOnSend.lock();\n+            try {\n+                if (conditionToSend.test(conditionValue)) {\n+                    requestWasSent = true;\n+                    sendEvents(events);\n+                }\n+            } catch (Exception exception) {\n+                logger.error(\"[pubstack] Failed to send analytics report to endpoint {0} with a reason {1}\",\n+                        endpoint, exception.getMessage());\n+            } finally {\n+                lockOnSend.unlock();\n+            }\n+        }\n+        return requestWasSent;\n+    }\n+\n+    private void sendEvents(AtomicReference<Queue<String>> events) {\n+        final Queue<String> copyToSend = events.get();\n+        resetReportEventsConditions(events);\n+        httpClient.request(HttpMethod.POST, HttpUtil.validateUrl(endpoint), headers, toGzippedBytes(copyToSend),\n+                timeoutMs)\n+                .setHandler(this::handleReportResponse);\n+    }\n+\n+    private void resetReportEventsConditions(AtomicReference<Queue<String>> events) {\n+        events.set(new ConcurrentLinkedQueue<>());\n+        byteSize.set(0);\n+        vertx.cancelTimer(reportTimerId);\n+        reportTimerId = setReportTtlTimer();", "originalCommit": "390928e863e8985c4f6e2d316110d1e91cf41721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MTQ2MTE0Ng==", "url": "https://github.com/prebid/prebid-server-java/pull/1013#discussion_r641461146", "bodyText": "Since ReentrantLock is used while sending the events, imho it is quite safe to use those in such way.", "author": "rpanchyk", "createdAt": "2021-05-28T10:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTg3Nzc3MQ=="}], "type": "inlineReview"}, {"oid": "77d287ec034187510ef26c58e9de5c6a342324cb", "url": "https://github.com/prebid/prebid-server-java/commit/77d287ec034187510ef26c58e9de5c6a342324cb", "message": "Merge branch 'master' into pubstack-analytics-module\n\n# Conflicts:\n#\tsrc/main/java/org/prebid/server/spring/config/AnalyticsConfiguration.java", "committedDate": "2021-05-28T09:22:23Z", "type": "commit"}, {"oid": "f593d10c5c6ba3484b7204b960258a42a9bd65d7", "url": "https://github.com/prebid/prebid-server-java/commit/f593d10c5c6ba3484b7204b960258a42a9bd65d7", "message": "Fixes after review", "committedDate": "2021-05-28T10:47:30Z", "type": "commit"}, {"oid": "79880f292d70833328a590318503f77e406925f5", "url": "https://github.com/prebid/prebid-server-java/commit/79880f292d70833328a590318503f77e406925f5", "message": "Merge branch 'master' into pubstack-analytics-module", "committedDate": "2021-06-01T10:58:29Z", "type": "commit"}]}