{"pr_number": 728, "pr_title": "Implement flexible resolving of additional targeting keywords", "pr_createdAt": "2020-05-21T13:45:05Z", "pr_url": "https://github.com/prebid/prebid-server-java/pull/728", "timeline": [{"oid": "c4b1d87fc589928c2ae5fc09a0f095f1264f4eed", "url": "https://github.com/prebid/prebid-server-java/commit/c4b1d87fc589928c2ae5fc09a0f095f1264f4eed", "message": "Fill in bidrequest.ext.prebid.amp.data with all AMP query parameters", "committedDate": "2020-05-21T11:20:41Z", "type": "commit"}, {"oid": "8cbd17a3e3b9ce878fb5d68824790152694d9f03", "url": "https://github.com/prebid/prebid-server-java/commit/8cbd17a3e3b9ce878fb5d68824790152694d9f03", "message": "Introduce TargetingKeywordsExtractor to allow publisher add dynamic targeting keywords", "committedDate": "2020-05-21T11:20:41Z", "type": "commit"}, {"oid": "a4038d7121e7ca09eb715eadb1c9b41a28a140ff", "url": "https://github.com/prebid/prebid-server-java/commit/a4038d7121e7ca09eb715eadb1c9b41a28a140ff", "message": "Implement static and request keywords lookup", "committedDate": "2020-05-21T11:20:41Z", "type": "commit"}, {"oid": "67ca0a944db3331fb08b7030b8261931535d29a2", "url": "https://github.com/prebid/prebid-server-java/commit/67ca0a944db3331fb08b7030b8261931535d29a2", "message": "Implement imp request keywords lookup", "committedDate": "2020-05-21T11:20:41Z", "type": "commit"}, {"oid": "e5a0b1e747a0e5c79609a939c5cf6444de8e5940", "url": "https://github.com/prebid/prebid-server-java/commit/e5a0b1e747a0e5c79609a939c5cf6444de8e5940", "message": "Implement response bid keywords lookup", "committedDate": "2020-05-21T11:20:41Z", "type": "commit"}, {"oid": "25eb3f34cd29ede68ab6d48c6189658fbf61925b", "url": "https://github.com/prebid/prebid-server-java/commit/25eb3f34cd29ede68ab6d48c6189658fbf61925b", "message": "Wire up TargetingKeywordsResolver with BidResponseCreator", "committedDate": "2020-05-21T11:20:41Z", "type": "commit"}, {"oid": "84e9d1b4d47b26e3cf0cc59abe27154484d4f9c8", "url": "https://github.com/prebid/prebid-server-java/commit/84e9d1b4d47b26e3cf0cc59abe27154484d4f9c8", "message": "Make cacheHost and cachePath fields of TargetingKeywordsCreator since they don't change between invocations", "committedDate": "2020-05-21T11:20:41Z", "type": "commit"}, {"oid": "312cd43fa4008992222ee7ebce6e7b79aeabff36", "url": "https://github.com/prebid/prebid-server-java/commit/312cd43fa4008992222ee7ebce6e7b79aeabff36", "message": "Fix test", "committedDate": "2020-05-21T11:32:37Z", "type": "commit"}, {"oid": "bfc9cb9a15e0033e3cd630c632770ee5b2e319ef", "url": "https://github.com/prebid/prebid-server-java/commit/bfc9cb9a15e0033e3cd630c632770ee5b2e319ef", "message": "Move targeting resolving testing to amp it", "committedDate": "2020-05-21T11:43:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ1MTg4MA==", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464451880", "bodyText": "Would it be better if we hide getting amp & ampData in updateAmpData(..) method?\nSeems they are not used in local fun-n.", "author": "rpanchyk", "createdAt": "2020-08-03T14:31:45Z", "path": "src/main/java/org/prebid/server/auction/AmpRequestFactory.java", "diffHunk": "@@ -175,12 +182,23 @@ private BidRequest fillExplicitParameters(BidRequest bidRequest, RoutingContext\n                 ? debugQueryParam\n                 : null;\n \n+        final ExtRequestPrebidAmp amp = prebid != null ? prebid.getAmp() : null;", "originalCommit": "bfc9cb9a15e0033e3cd630c632770ee5b2e319ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2MTc4NA==", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464461784", "bodyText": "Minor. Pls adhere the order of method calls, so place this method declaration before extBidRequestNode(..).", "author": "rpanchyk", "createdAt": "2020-08-03T14:46:59Z", "path": "src/main/java/org/prebid/server/auction/AmpRequestFactory.java", "diffHunk": "@@ -541,4 +567,20 @@ private ExtRequestTargeting createTargetingWithDefaults(ExtRequestPrebid prebid)\n                 .includebidderkeys(includeBidderKeys)\n                 .build();\n     }\n+\n+    private static Map<String, String> updateAmpData(Map<String, String> existingAmpData, HttpServerRequest request) {", "originalCommit": "bfc9cb9a15e0033e3cd630c632770ee5b2e319ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Mjk5Nw==", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464462997", "bodyText": "Should we check ampQueryData for empty before composing result?\nSeems we don't need to update if no AMP-related params.", "author": "rpanchyk", "createdAt": "2020-08-03T14:48:55Z", "path": "src/main/java/org/prebid/server/auction/AmpRequestFactory.java", "diffHunk": "@@ -541,4 +567,20 @@ private ExtRequestTargeting createTargetingWithDefaults(ExtRequestPrebid prebid)\n                 .includebidderkeys(includeBidderKeys)\n                 .build();\n     }\n+\n+    private static Map<String, String> updateAmpData(Map<String, String> existingAmpData, HttpServerRequest request) {\n+        final MultiMap queryParams = request.params();\n+        if (queryParams.isEmpty()) {\n+            return null;\n+        }\n+\n+        final Map<String, String> ampQueryData = queryParams.entries().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (value1, value2) -> value1));\n+\n+        final Map<String, String> updatedAmpData =", "originalCommit": "bfc9cb9a15e0033e3cd630c632770ee5b2e319ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk2NjgxNA==", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464966814", "bodyText": "Do you think that queryParams.isEmpty() check a few lines above isn't enough to cover this case?", "author": "schernysh", "createdAt": "2020-08-04T10:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Mjk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk5MDgzNQ==", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464990835", "bodyText": "you're right, thanks!", "author": "rpanchyk", "createdAt": "2020-08-04T11:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Mjk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2NjczNA==", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464466734", "bodyText": "i'd rather suggest to rename extractor to resolver to in same style.", "author": "rpanchyk", "createdAt": "2020-08-03T14:54:55Z", "path": "src/main/java/org/prebid/server/auction/TargetingKeywordsCreator.java", "diffHunk": "@@ -92,31 +92,64 @@\n     private final boolean includeWinners;\n     private final boolean includeBidderKeys;\n     private final boolean isApp;\n+    private final String cacheHost;\n+    private final String cachePath;\n+    private final TargetingKeywordsResolver resolver;\n+\n+    private TargetingKeywordsCreator(PriceGranularity priceGranularity,\n+                                     boolean includeWinners,\n+                                     boolean includeBidderKeys,\n+                                     boolean isApp,\n+                                     String cacheHost,\n+                                     String cachePath,\n+                                     TargetingKeywordsResolver resolver) {\n \n-    private TargetingKeywordsCreator(PriceGranularity priceGranularity, boolean includeWinners,\n-                                     boolean includeBidderKeys, boolean isApp) {\n         this.priceGranularity = priceGranularity;\n         this.includeWinners = includeWinners;\n         this.includeBidderKeys = includeBidderKeys;\n         this.isApp = isApp;\n+        this.cacheHost = cacheHost;\n+        this.cachePath = cachePath;\n+        this.resolver = resolver;\n     }\n \n     /**\n      * Creates {@link TargetingKeywordsCreator} for the given params.\n      */\n-    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity, boolean includeWinners,\n-                                                  boolean includeBidderKeys, boolean isApp) {\n-        return new TargetingKeywordsCreator(PriceGranularity.createFromExtPriceGranularity(extPriceGranularity),\n-                includeWinners, includeBidderKeys, isApp);\n+    public static TargetingKeywordsCreator create(ExtPriceGranularity extPriceGranularity,\n+                                                  boolean includeWinners,\n+                                                  boolean includeBidderKeys,\n+                                                  boolean isApp,\n+                                                  String cacheHost,\n+                                                  String cachePath,\n+                                                  TargetingKeywordsResolver extractor) {", "originalCommit": "bfc9cb9a15e0033e3cd630c632770ee5b2e319ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3MDQ3OA==", "url": "https://github.com/prebid/prebid-server-java/pull/728#discussion_r464470478", "bodyText": "This can be inlined since there is only one usage.", "author": "rpanchyk", "createdAt": "2020-08-03T15:00:41Z", "path": "src/main/java/org/prebid/server/auction/TargetingKeywordsResolver.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.prebid.server.auction;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.response.Bid;\n+import io.vertx.core.logging.Logger;\n+import io.vertx.core.logging.LoggerFactory;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.proto.openrtb.ext.request.ExtBidRequest;\n+import org.prebid.server.proto.openrtb.ext.request.ExtRequestPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.ExtRequestPrebidAdservertargetingRule;\n+import org.prebid.server.proto.openrtb.ext.request.ExtRequestPrebidAdservertargetingRule.Source;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+public class TargetingKeywordsResolver {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TargetingKeywordsResolver.class);\n+\n+    public static final String IMP_PREFIX = \"imp.\";\n+    public static final String SEATBID_BID_PREFIX = \"seatbid.bid.\";\n+    public static final String BIDDER_MACRO = \"{{BIDDER}}\";\n+\n+    private final BidRequest bidRequest;\n+    private final JacksonMapper mapper;\n+\n+    private final Map<String, String> staticAndRequestKeywords;\n+    private final List<ExtRequestPrebidAdservertargetingRule> impRequestRules;\n+    private final List<ExtRequestPrebidAdservertargetingRule> responseRules;\n+\n+    private TargetingKeywordsResolver(BidRequest bidRequest, JacksonMapper mapper) {\n+        this.bidRequest = Objects.requireNonNull(bidRequest);\n+        this.mapper = Objects.requireNonNull(mapper);\n+\n+        final Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource = rulesBySource();\n+\n+        this.impRequestRules = impRequestRules(rulesBySource);\n+        this.responseRules = responseRules(rulesBySource);\n+        this.staticAndRequestKeywords = resolveStaticAndRequestKeywords(rulesBySource);\n+    }\n+\n+    public static TargetingKeywordsResolver create(BidRequest bidRequest, JacksonMapper mapper) {\n+        return new TargetingKeywordsResolver(bidRequest, mapper);\n+    }\n+\n+    public Map<String, String> resolve(Bid bid, String bidder) {\n+        final Map<String, String> result = new HashMap<>(staticAndRequestKeywords);\n+        result.putAll(resolveImpRequestKeywords(bid));\n+        result.putAll(resolveResponseKeywords(bid, bidder));\n+\n+        return result;\n+    }\n+\n+    private Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource() {\n+        final ExtBidRequest extRequest = parseExt(bidRequest.getExt());\n+        final List<ExtRequestPrebidAdservertargetingRule> rules =\n+                get(get(extRequest, ExtBidRequest::getPrebid), ExtRequestPrebid::getAdservertargeting);\n+\n+        return ObjectUtils.<List<ExtRequestPrebidAdservertargetingRule>>defaultIfNull(rules, Collections.emptyList())\n+                .stream()\n+                .filter(TargetingKeywordsResolver::isValid)\n+                .collect(Collectors.groupingBy(ExtRequestPrebidAdservertargetingRule::getSource));\n+    }\n+\n+    private static List<ExtRequestPrebidAdservertargetingRule> impRequestRules(\n+            Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource) {\n+\n+        return rulesBySource.getOrDefault(Source.bidrequest, Collections.emptyList()).stream()\n+                .filter(TargetingKeywordsResolver::hasImpPath)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static List<ExtRequestPrebidAdservertargetingRule> responseRules(\n+            Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource) {\n+\n+        return rulesBySource.getOrDefault(Source.bidresponse, Collections.emptyList()).stream()\n+                .filter(TargetingKeywordsResolver::hasSeatbidBidPath)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Map<String, String> resolveStaticAndRequestKeywords(\n+            Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource) {\n+\n+        final Map<String, String> result = new HashMap<>(resolveStaticKeywords(rulesBySource));\n+        result.putAll(resolveRequestKeywords(rulesBySource));\n+\n+        return result;\n+    }\n+\n+    private static Map<String, String> resolveStaticKeywords(\n+            Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource) {\n+\n+        return rulesBySource.getOrDefault(Source.xStatic, Collections.emptyList()).stream()\n+                .collect(Collectors.toMap(\n+                        ExtRequestPrebidAdservertargetingRule::getKey,\n+                        ExtRequestPrebidAdservertargetingRule::getValue,\n+                        (value1, value2) -> value2));\n+    }\n+\n+    private Map<String, String> resolveRequestKeywords(\n+            Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource) {\n+\n+        final List<ExtRequestPrebidAdservertargetingRule> requestRules = requestRules(rulesBySource);\n+\n+        if (!requestRules.isEmpty()) {\n+            return lookupValues(\n+                    mapper.mapper().valueToTree(bidRequest),\n+                    requestRules,\n+                    Function.identity(),\n+                    Function.identity());\n+        }\n+\n+        return Collections.emptyMap();\n+    }\n+\n+    private static List<ExtRequestPrebidAdservertargetingRule> requestRules(\n+            Map<Source, List<ExtRequestPrebidAdservertargetingRule>> rulesBySource) {\n+\n+        return rulesBySource.getOrDefault(Source.bidrequest, Collections.emptyList()).stream()\n+                .filter(rule -> !hasImpPath(rule))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Map<String, String> resolveImpRequestKeywords(Bid bid) {\n+        if (!impRequestRules.isEmpty()) {\n+            final JsonNode impNode = locateImp(bid);\n+\n+            if (impNode != null) {\n+                return lookupValues(\n+                        impNode,\n+                        impRequestRules,\n+                        value -> StringUtils.substringAfter(value, IMP_PREFIX),\n+                        Function.identity());\n+            }\n+        }\n+\n+        return Collections.emptyMap();\n+    }\n+\n+    private JsonNode locateImp(Bid bid) {\n+        final String impid = bid.getImpid();\n+        if (StringUtils.isBlank(impid)) {\n+            return null;\n+        }\n+\n+        return bidRequest.getImp().stream()\n+                .filter(imp -> Objects.equals(imp.getId(), impid))\n+                .findFirst()\n+                .<JsonNode>map(imp -> mapper.mapper().valueToTree(imp))\n+                .orElse(null);\n+    }\n+\n+    private Map<String, String> resolveResponseKeywords(Bid bid, String bidder) {\n+        if (!responseRules.isEmpty()) {\n+            final JsonNode bidNode = mapper.mapper().valueToTree(bid);", "originalCommit": "bfc9cb9a15e0033e3cd630c632770ee5b2e319ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "be3e25aad933cc6396241f50d4eda17ca3b6105c", "url": "https://github.com/prebid/prebid-server-java/commit/be3e25aad933cc6396241f50d4eda17ca3b6105c", "message": "Merge branch 'master' into amp-targeting-parsing", "committedDate": "2020-08-04T10:44:13Z", "type": "commit"}, {"oid": "6b7d1dac3d6f3017911c67c64b4d007ca4714112", "url": "https://github.com/prebid/prebid-server-java/commit/6b7d1dac3d6f3017911c67c64b4d007ca4714112", "message": "Address PR review comments", "committedDate": "2020-08-04T10:58:31Z", "type": "commit"}]}