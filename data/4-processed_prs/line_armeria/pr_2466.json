{"pr_number": 2466, "pr_title": "Fix a bug where `pendingResponses` meter is not updated", "pr_createdAt": "2020-02-06T19:55:01Z", "pr_url": "https://github.com/line/armeria/pull/2466", "timeline": [{"oid": "e6fe08c2d5887cca821e2033d4be70aee0bf72df", "url": "https://github.com/line/armeria/commit/e6fe08c2d5887cca821e2033d4be70aee0bf72df", "message": "Fix a bug where `pendingResponses` meter is not updated\n\n... when graceful shutdown is disabled.\n\nMotivation:\n\nWhen graceful shutdown is disabled, `pendingResponses` meter stays at\n`0`, because `DisabledGracefulShutdownSupport.pendingResponses()` always\nreturns `0`.\n\nModifications:\n\n- Use `LongAdder` to keep track of the number of pending responses.\n- Minor optimizations:\n  - Do not add unnecessary callbacks when handling a request.\n  - Remove the `boolean` flags at the cost of losing 1-nanosecond\n    precision, which is OK because we check if quiet period is over\n    every 100 ms.\n\nResult:\n\n- `pendingResponses` meter yields a correct value even when graceful\n  shutdown is disabled.\n- Potentially less contention under load, thanks to `LongAdder`.\n- Tad bit less garbage due to less number of callbacks.", "committedDate": "2020-02-06T19:54:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIwNTM4MA==", "url": "https://github.com/line/armeria/pull/2466#discussion_r376205380", "bodyText": "Nice idea. \ud83d\udc4d\ud83d\udc4d\ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-02-07T04:02:22Z", "path": "core/src/main/java/com/linecorp/armeria/server/GracefulShutdownSupport.java", "diffHunk": "@@ -100,65 +97,54 @@ boolean completedQuietPeriod() {\n         private final Executor blockingTaskExecutor;\n \n         /**\n-         * NOTE: {@link #updatedLastResTimeNanos} and {@link #lastResTimeNanos} are declared as non-volatile\n-         *       while using this field as a memory barrier.\n+         * Declared as non-volatile because using {@link #pendingResponses} as a memory barrier.\n          */\n-        private final AtomicInteger pendingResponses = new AtomicInteger();\n-        private boolean updatedLastResTimeNanos;\n         private long lastResTimeNanos;\n-        private boolean setShutdownStartTimeNanos;\n-        private long shutdownStartTimeNanos;\n+        private volatile long shutdownStartTimeNanos;\n \n         DefaultGracefulShutdownSupport(Duration quietPeriod, Executor blockingTaskExecutor, Ticker ticker) {\n             quietPeriodNanos = quietPeriod.toNanos();\n             this.blockingTaskExecutor = blockingTaskExecutor;\n             this.ticker = ticker;\n         }\n \n-        @Override\n-        void inc() {\n-            pendingResponses.incrementAndGet();\n-        }\n-\n         @Override\n         void dec() {\n-            lastResTimeNanos = ticker.read();\n-            updatedLastResTimeNanos = true;\n-            pendingResponses.decrementAndGet();\n-        }\n-\n-        @Override\n-        int pendingResponses() {\n-            return pendingResponses.get();\n+            lastResTimeNanos = readTicker();\n+            super.dec();\n         }\n \n         @Override\n         boolean isShuttingDown() {\n-            return setShutdownStartTimeNanos;\n+            return shutdownStartTimeNanos != 0;\n         }\n \n         @Override\n         boolean completedQuietPeriod() {\n-            if (!setShutdownStartTimeNanos) {\n-                shutdownStartTimeNanos = ticker.read();\n-                setShutdownStartTimeNanos = true;\n+            if (shutdownStartTimeNanos == 0) {\n+                shutdownStartTimeNanos = readTicker();\n             }\n \n-            if (pendingResponses.get() != 0 || !completedBlockingTasks()) {\n+            if (pendingResponses() != 0 || !completedBlockingTasks()) {\n                 return false;\n             }\n \n             final long shutdownStartTimeNanos = this.shutdownStartTimeNanos;\n             final long currentTimeNanos = ticker.read();\n-            final long duration;\n-            if (updatedLastResTimeNanos) {\n-                duration = Math.min(currentTimeNanos - shutdownStartTimeNanos,\n-                                    currentTimeNanos - lastResTimeNanos);\n+            final long durationNanos;\n+            if (lastResTimeNanos != 0) {\n+                durationNanos = Math.min(currentTimeNanos - shutdownStartTimeNanos,\n+                                         currentTimeNanos - lastResTimeNanos);\n             } else {\n-                duration = currentTimeNanos - shutdownStartTimeNanos;\n+                durationNanos = currentTimeNanos - shutdownStartTimeNanos;\n             }\n \n-            return duration >= quietPeriodNanos;\n+            return durationNanos >= quietPeriodNanos;\n+        }\n+\n+        private long readTicker() {\n+            // '| 1' makes sure this method never returns 0.\n+            return ticker.read() | 1;", "originalCommit": "e6fe08c2d5887cca821e2033d4be70aee0bf72df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}