{"pr_number": 2726, "pr_title": "Provide a way to build CircuitBreakerRule", "pr_createdAt": "2020-05-18T15:59:41Z", "pr_url": "https://github.com/line/armeria/pull/2726", "timeline": [{"oid": "27958cc7219b9c132ba5efab6154fdf09644671b", "url": "https://github.com/line/armeria/commit/27958cc7219b9c132ba5efab6154fdf09644671b", "message": "Provide a way to build CircuitBreakerRule\n\nMotivation:\n\nSince `CircuitBreakerStrategy` has a few factory methods,\nusers should implement `CircuitBreakerStrategy` to customize it.\nRecently, RetryRuleBuilder is added to Armeria 0.99.5 #2661\nIn the same way, This PR provides `CircuitBreakerRule` and `CircuitBreakerRuleWithContent`.\n\nModifications:\n\n- Add `CircuitBreakerRule{WithContent}` and its builder.\n- Add `AbstractRuleWithContentBuilder` for deduplicating common code.\n- Deprecate `CircuitBreakerStrategy` and `CircuitBreakerStrategWithContent`.\n- Update documentation.\n- Fix a bug where a response fails to duplicate when a single rule subsciribes a response multiple times.\n- Breaking\n  - Builder and factory methods of `CircuitBreakerClient` need an explicit type parameter for\n    `CircuitBreakerStrategy` when creating it with a lambda expression.\n\nResult:\nYou can now build complex CircuitBreakerRule conveniently.", "committedDate": "2020-05-18T15:58:55Z", "type": "commit"}, {"oid": "e9f5267ce6a021c49df09f15735911410b6e697f", "url": "https://github.com/line/armeria/commit/e9f5267ce6a021c49df09f15735911410b6e697f", "message": "Fix broken tests", "committedDate": "2020-05-19T02:09:10Z", "type": "commit"}, {"oid": "1b71ce3cd78e535172c325805175867083205c70", "url": "https://github.com/line/armeria/commit/1b71ce3cd78e535172c325805175867083205c70", "message": "Clean up", "committedDate": "2020-05-19T02:31:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTMxNA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r426999314", "bodyText": "Can't we make this as enum?", "author": "minwoox", "createdAt": "2020-05-19T02:48:18Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerDecision.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import com.linecorp.armeria.common.Response;\n+\n+/**\n+ * A {@link CircuitBreakerDecision} that determines whether a {@link CircuitBreakerRule} reports a response as\n+ * a {@link #success()}, {@link #failure()}, {@link #ignore()}s it.\n+ * {@link #next()} skips a {@link CircuitBreakerRule} and will lookup next {@link CircuitBreakerRule}s.\n+ */\n+public final class CircuitBreakerDecision {", "originalCommit": "1b71ce3cd78e535172c325805175867083205c70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMDU3OA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427020578", "bodyText": "Yeah, I intended to provide an API design similar to RetryDecision.\nHowever, enum is a good choice too.", "author": "ikhoon", "createdAt": "2020-05-19T04:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMzE4Nw==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427023187", "bodyText": "I think RetryDecision is not enum because of this:\nhttps://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/client/retry/RetryDecision.java#L35\nWhich is that a user might create a new instance with a different Backoff.\nBut for CircuitBreakerDecision, we don't have such use cases.", "author": "minwoox", "createdAt": "2020-05-19T04:28:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0NDM5MQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427144391", "bodyText": "I thought users might not be interested in this is enum or not.\nThe important thing is how to use those APIs. Some API should use next() and others are not.\nRetryDecision.next() \n// vs\nCircuitBreakerDecision.NEXT\n// vs\nCircuitBreakerDecision.next()\nBy the way, I'm not strong here. Let me migrate this to enum.", "author": "ikhoon", "createdAt": "2020-05-19T09:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE1MTQxMg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427151412", "bodyText": "I'm not strong on this neither. \ud83d\ude06 If you think, the current implementation is better in terms of providing a similar API with RetryDecision then it's good as it is.", "author": "minwoox", "createdAt": "2020-05-19T09:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwMDY1OQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427700659", "bodyText": "Then let me keep the current implementation.\ud83d\ude09", "author": "ikhoon", "createdAt": "2020-05-20T02:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTgyMw==", "url": "https://github.com/line/armeria/pull/2726#discussion_r426999823", "bodyText": "Let's check null for the circuitBreaker", "author": "minwoox", "createdAt": "2020-05-19T02:50:27Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerClient.java", "diffHunk": "@@ -32,16 +37,44 @@\n public class CircuitBreakerClient extends AbstractCircuitBreakerClient<HttpRequest, HttpResponse>\n         implements HttpClient {\n \n+    /**\n+     * Creates a new decorator using the specified {@link CircuitBreaker} instance and\n+     * {@link CircuitBreakerRule}.\n+     *\n+     * <p>Since {@link CircuitBreaker} is a unit of failure detection, don't reuse the same instance for\n+     * unrelated services.\n+     */\n+    public static Function<? super HttpClient, CircuitBreakerClient>\n+    newDecorator(CircuitBreaker circuitBreaker, CircuitBreakerRule rule) {\n+        return newDecorator((ctx, req) -> circuitBreaker, rule);", "originalCommit": "1b71ce3cd78e535172c325805175867083205c70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5OTk2Mw==", "url": "https://github.com/line/armeria/pull/2726#discussion_r426999963", "bodyText": "I think we should check null out of lambda.", "author": "minwoox", "createdAt": "2020-05-19T02:50:58Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerClient.java", "diffHunk": "@@ -32,16 +37,44 @@\n public class CircuitBreakerClient extends AbstractCircuitBreakerClient<HttpRequest, HttpResponse>\n         implements HttpClient {\n \n+    /**\n+     * Creates a new decorator using the specified {@link CircuitBreaker} instance and\n+     * {@link CircuitBreakerRule}.\n+     *\n+     * <p>Since {@link CircuitBreaker} is a unit of failure detection, don't reuse the same instance for\n+     * unrelated services.\n+     */\n+    public static Function<? super HttpClient, CircuitBreakerClient>\n+    newDecorator(CircuitBreaker circuitBreaker, CircuitBreakerRule rule) {\n+        return newDecorator((ctx, req) -> circuitBreaker, rule);\n+    }\n+\n     /**\n      * Creates a new decorator using the specified {@link CircuitBreaker} instance and\n      * {@link CircuitBreakerStrategy}.\n      *\n      * <p>Since {@link CircuitBreaker} is a unit of failure detection, don't reuse the same instance for\n      * unrelated services.\n+     *\n+     * @deprecated Use {@link #newDecorator(CircuitBreaker, CircuitBreakerRule)}.\n      */\n+    @Deprecated\n     public static Function<? super HttpClient, CircuitBreakerClient>\n     newDecorator(CircuitBreaker circuitBreaker, CircuitBreakerStrategy strategy) {\n-        return newDecorator((ctx, req) -> circuitBreaker, strategy);\n+        requireNonNull(strategy, \"strategy\");\n+        return newDecorator(circuitBreaker, fromCircuitBreakerStrategy(strategy));\n+    }\n+\n+    /**\n+     * Creates a new decorator with the specified {@link CircuitBreakerMapping} and\n+     * {@link CircuitBreakerRule}.\n+     *\n+     * <p>Since {@link CircuitBreaker} is a unit of failure detection, don't reuse the same instance for\n+     * unrelated services.\n+     */\n+    public static Function<? super HttpClient, CircuitBreakerClient>\n+    newDecorator(CircuitBreakerMapping mapping, CircuitBreakerRule rule) {\n+        return delegate -> new CircuitBreakerClient(delegate, mapping, rule);", "originalCommit": "1b71ce3cd78e535172c325805175867083205c70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwMDgxOA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427000818", "bodyText": "I guess passing HttpResponse.ofFailure(cause) instead of null is for the backward compatibility with the strategy. Should we pass null after the strategy is gone?", "author": "minwoox", "createdAt": "2020-05-19T02:54:23Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerClient.java", "diffHunk": "@@ -145,29 +257,31 @@ protected HttpResponse doExecute(ClientRequestContext ctx, HttpRequest req, Circ\n         try {\n             response = delegate().execute(ctx, req);\n         } catch (Throwable cause) {\n-            if (needsContentInStrategy) {\n-                reportSuccessOrFailure(circuitBreaker, strategyWithContent().shouldReportAsSuccess(\n-                        ctx, HttpResponse.ofFailure(cause)));\n+            if (needsContentInRule) {\n+                reportSuccessOrFailure(circuitBreaker, ruleWithContent().shouldReportAsSuccess(\n+                        ctx, HttpResponse.ofFailure(cause), cause));", "originalCommit": "1b71ce3cd78e535172c325805175867083205c70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjMwMQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427026301", "bodyText": "Yes. the content should not be null yet. If a user set CircuitBreakerStrategyWithContent, the content is passed to it via CircuitBreakerRuleWithContent\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRuleUtil.java\n    \n    \n         Line 68\n      in\n      27958cc\n    \n    \n    \n    \n\n        \n          \n           return (ctx, content, cause) -> strategy.shouldReportAsSuccess(ctx, content).thenApply(result -> {", "author": "ikhoon", "createdAt": "2020-05-19T04:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwMDgxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NjExOA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427046118", "bodyText": "By the way, I realized null content is passed to RetryStrategyWithContent. \ud83d\ude31\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/client/retry/RetryingClient.java\n    \n    \n        Lines 329 to 336\n      in\n      ac3440b\n    \n    \n    \n    \n\n        \n          \n           if (needsContentInRule) { \n        \n\n        \n          \n               retryRule = fromRetryRuleWithContent(); \n        \n\n        \n          \n           } else { \n        \n\n        \n          \n               retryRule = retryRule(); \n        \n\n        \n          \n           } \n        \n\n        \n          \n           final Runnable originalResClosingTask = \n        \n\n        \n          \n                   responseCause == null ? response::abort : () -> response.abort(responseCause); \n        \n\n        \n          \n           retryRule.shouldRetry(derivedCtx, responseCause)", "author": "ikhoon", "createdAt": "2020-05-19T05:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwMDgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwMTMxNg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427001316", "bodyText": "Don't we need to check if the cause is null or not? so that we can just call\nshouldReportAsSuccess(ctx, null, cause) in that case?", "author": "minwoox", "createdAt": "2020-05-19T02:56:22Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerClient.java", "diffHunk": "@@ -145,29 +257,31 @@ protected HttpResponse doExecute(ClientRequestContext ctx, HttpRequest req, Circ\n         try {\n             response = delegate().execute(ctx, req);\n         } catch (Throwable cause) {\n-            if (needsContentInStrategy) {\n-                reportSuccessOrFailure(circuitBreaker, strategyWithContent().shouldReportAsSuccess(\n-                        ctx, HttpResponse.ofFailure(cause)));\n+            if (needsContentInRule) {\n+                reportSuccessOrFailure(circuitBreaker, ruleWithContent().shouldReportAsSuccess(\n+                        ctx, HttpResponse.ofFailure(cause), cause));\n             } else {\n-                reportSuccessOrFailure(circuitBreaker, strategy().shouldReportAsSuccess(ctx, cause));\n+                reportSuccessOrFailure(circuitBreaker, rule().shouldReportAsSuccess(ctx, cause));\n             }\n             throw cause;\n         }\n \n-        if (needsContentInStrategy) {\n-            try (HttpResponseDuplicator duplicator =\n-                         response.toDuplicator(ctx.eventLoop(), ctx.maxResponseLength())) {\n-                reportSuccessOrFailure(circuitBreaker, strategyWithContent().shouldReportAsSuccess(\n-                        ctx, duplicator.duplicate()));\n-                return duplicator.duplicate();\n-            }\n-        }\n-\n-        ctx.log().whenAvailable(RequestLogProperty.RESPONSE_HEADERS).thenAccept(log -> {\n-            final Throwable cause =\n-                    log.isAvailable(RequestLogProperty.RESPONSE_CAUSE) ? log.responseCause() : null;\n-            reportSuccessOrFailure(circuitBreaker, strategy().shouldReportAsSuccess(ctx, cause));\n-        });\n-        return response;\n+        final CompletableFuture<HttpResponse> responseFuture =\n+                ctx.log().whenAvailable(RequestLogProperty.RESPONSE_HEADERS).thenApply(log -> {\n+                    if (needsContentInRule) {", "originalCommit": "1b71ce3cd78e535172c325805175867083205c70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjY4Mg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427026682", "bodyText": "Good point. But cannot pass null yet(#2726 (comment))\nLet me pass shouldReportAsSuccess(ctx, response, cause) without duplicator.", "author": "ikhoon", "createdAt": "2020-05-19T04:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwMTMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwMTY0MQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427001641", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-19T02:57:42Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRpcClient.java", "diffHunk": "@@ -32,6 +33,20 @@\n public final class CircuitBreakerRpcClient extends AbstractCircuitBreakerClient<RpcRequest, RpcResponse>\n         implements RpcClient {\n \n+    /**\n+     * Creates a new decorator using the specified {@link CircuitBreaker} instance and\n+     * {@link CircuitBreakerRule}.\n+     *\n+     * <p>Since {@link CircuitBreaker} is a unit of failure detection, don't reuse the same instance for\n+     * unrelated services.\n+     *\n+     * @param circuitBreaker The {@link CircuitBreaker} instance to be used\n+     */\n+    public static Function<? super RpcClient, CircuitBreakerRpcClient>\n+    newDecorator(CircuitBreaker circuitBreaker, CircuitBreakerRuleWithContent<RpcResponse> rule) {\n+        return newDecorator((ctx, req) -> circuitBreaker, rule);", "originalCommit": "1b71ce3cd78e535172c325805175867083205c70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwMTc5OQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427001799", "bodyText": "ditto we should check null before making the lambda expression.", "author": "minwoox", "createdAt": "2020-05-19T02:58:18Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRpcClient.java", "diffHunk": "@@ -40,10 +55,26 @@\n      * unrelated services.\n      *\n      * @param circuitBreaker The {@link CircuitBreaker} instance to be used\n+     *\n+     * @deprecated Use {@link #newDecorator(CircuitBreaker, CircuitBreakerRuleWithContent)}.\n      */\n+    @Deprecated\n     public static Function<? super RpcClient, CircuitBreakerRpcClient>\n     newDecorator(CircuitBreaker circuitBreaker, CircuitBreakerStrategyWithContent<RpcResponse> strategy) {\n-        return newDecorator((ctx, req) -> circuitBreaker, strategy);\n+        requireNonNull(strategy, \"strategy\");\n+        return newDecorator(circuitBreaker, fromCircuitBreakerStrategyWithContent(strategy));\n+    }\n+\n+    /**\n+     * Creates a new decorator with the specified {@link CircuitBreakerMapping} and\n+     * {@link CircuitBreakerRule}.\n+     *\n+     * <p>Since {@link CircuitBreaker} is a unit of failure detection, don't reuse the same instance for\n+     * unrelated services.\n+     */\n+    public static Function<? super RpcClient, CircuitBreakerRpcClient>\n+    newDecorator(CircuitBreakerMapping mapping, CircuitBreakerRuleWithContent<RpcResponse> rule) {\n+        return delegate -> new CircuitBreakerRpcClient(delegate, mapping, rule);", "originalCommit": "1b71ce3cd78e535172c325805175867083205c70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNDE0MA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427004140", "bodyText": "I think the default should be thenIgnore for onUnprocessed.", "author": "minwoox", "createdAt": "2020-05-19T03:08:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRule.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.Streams;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * Determines whether a {@link Response} should be reported as a success or a failure to a\n+ * {@link CircuitBreaker}. If you need to determine whether the request was successful by looking into the\n+ * {@link Response} content, use {@link CircuitBreakerRuleWithContent}.\n+ *\n+ * <p>Note that the last {@link CircuitBreakerRule} completes with {@link CircuitBreakerDecision#next()} or\n+ * a {@link Response} is not matched with {@link CircuitBreakerRule}s, the {@link Response} will be reported as\n+ * a success.\n+ *\n+ * <p>For example:\n+ * <pre>{@code\n+ * // If a response status is 500(Interval Server Error), the response will be reported as a failure.\n+ * // Otherwise, the response will be reported as a success.\n+ * CircuitBreakerRule.onStatus(HttpStatus.INTERNAL_SERVER_ERROR);\n+ *\n+ * // A response will be reported as a success if no exception is raised.\n+ * CircuitBreakerRule.onException();\n+ *\n+ * // A CircuitBreakerRule that reports a response as a failure except that a response status code is 2xx.\n+ * CircuitBreakerRule.of(\n+ *                       // Report as a success if the class of a response status is 2xx\n+ *                       CircuitBreakerRule.builder()\n+ *                                         .onStatusClass(HttpStatusClass.SUCCESS)\n+ *                                         .thenSuccess(),\n+ *                       // Everything else is reported as a failure\n+ *                       ClientBreakerRule.builder().thenFailure());\n+ * }\n+ * </pre>\n+ */\n+@FunctionalInterface\n+public interface CircuitBreakerRule {\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    static CircuitBreakerRule onStatusClass(HttpStatusClass statusClass) {\n+        return builder().onStatusClass(statusClass).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    static CircuitBreakerRule onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        return builder().onStatusClass(statusClasses).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    static CircuitBreakerRule onServerErrorStatus() {\n+        return builder().onServerErrorStatus().thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    static CircuitBreakerRule onStatus(HttpStatus... statuses) {\n+        return builder().onStatus(statuses).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    static CircuitBreakerRule onStatus(Iterable<HttpStatus> statuses) {\n+        return builder().onStatus(statuses).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the specified {@code statusFilter} returns {@code true}.\n+     */\n+    static CircuitBreakerRule onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        return builder().onStatus(statusFilter).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if an {@link Exception} is raised and that is instance of the specified {@code exception}.\n+     */\n+    static CircuitBreakerRule onException(Class<? extends Throwable> exception) {\n+        return builder().onException(exception).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if an {@link Exception} is raised and the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    static CircuitBreakerRule onException(Predicate<? super Throwable> exceptionFilter) {\n+        return builder().onException(exceptionFilter).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if an {@link Exception} is raised.\n+     */\n+    static CircuitBreakerRule onException() {\n+        return builder().onException().thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if an {@link UnprocessedRequestException} which means that the request has not been processed by\n+     * the server is raised.\n+     */\n+    static CircuitBreakerRule onUnprocessed() {\n+        return builder().onUnprocessed().thenFailure();", "originalCommit": "1b71ce3cd78e535172c325805175867083205c70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMzI1Ng==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427023256", "bodyText": "Ignoring on unprocessed seems default behavior.\nHowever, other factory methods build a rule with thenFailure().\nProbably better to remove this factory to reduce confusion?", "author": "ikhoon", "createdAt": "2020-05-19T04:29:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNDE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNDM5NA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427024394", "bodyText": "+1 for removing. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-19T04:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNDE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNTA4NQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427005085", "bodyText": "Let's remove <p>", "author": "minwoox", "createdAt": "2020-05-19T03:12:26Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRule.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.Streams;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * Determines whether a {@link Response} should be reported as a success or a failure to a\n+ * {@link CircuitBreaker}. If you need to determine whether the request was successful by looking into the\n+ * {@link Response} content, use {@link CircuitBreakerRuleWithContent}.\n+ *\n+ * <p>Note that the last {@link CircuitBreakerRule} completes with {@link CircuitBreakerDecision#next()} or\n+ * a {@link Response} is not matched with {@link CircuitBreakerRule}s, the {@link Response} will be reported as\n+ * a success.\n+ *\n+ * <p>For example:\n+ * <pre>{@code\n+ * // If a response status is 500(Interval Server Error), the response will be reported as a failure.\n+ * // Otherwise, the response will be reported as a success.\n+ * CircuitBreakerRule.onStatus(HttpStatus.INTERNAL_SERVER_ERROR);\n+ *\n+ * // A response will be reported as a success if no exception is raised.\n+ * CircuitBreakerRule.onException();\n+ *\n+ * // A CircuitBreakerRule that reports a response as a failure except that a response status code is 2xx.\n+ * CircuitBreakerRule.of(\n+ *                       // Report as a success if the class of a response status is 2xx\n+ *                       CircuitBreakerRule.builder()\n+ *                                         .onStatusClass(HttpStatusClass.SUCCESS)\n+ *                                         .thenSuccess(),\n+ *                       // Everything else is reported as a failure\n+ *                       ClientBreakerRule.builder().thenFailure());\n+ * }\n+ * </pre>\n+ */\n+@FunctionalInterface\n+public interface CircuitBreakerRule {\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    static CircuitBreakerRule onStatusClass(HttpStatusClass statusClass) {\n+        return builder().onStatusClass(statusClass).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    static CircuitBreakerRule onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        return builder().onStatusClass(statusClasses).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    static CircuitBreakerRule onServerErrorStatus() {\n+        return builder().onServerErrorStatus().thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    static CircuitBreakerRule onStatus(HttpStatus... statuses) {\n+        return builder().onStatus(statuses).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    static CircuitBreakerRule onStatus(Iterable<HttpStatus> statuses) {\n+        return builder().onStatus(statuses).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the specified {@code statusFilter} returns {@code true}.\n+     */\n+    static CircuitBreakerRule onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        return builder().onStatus(statusFilter).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if an {@link Exception} is raised and that is instance of the specified {@code exception}.\n+     */\n+    static CircuitBreakerRule onException(Class<? extends Throwable> exception) {\n+        return builder().onException(exception).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if an {@link Exception} is raised and the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    static CircuitBreakerRule onException(Predicate<? super Throwable> exceptionFilter) {\n+        return builder().onException(exceptionFilter).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if an {@link Exception} is raised.\n+     */\n+    static CircuitBreakerRule onException() {\n+        return builder().onException().thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if an {@link UnprocessedRequestException} which means that the request has not been processed by\n+     * the server is raised.\n+     */\n+    static CircuitBreakerRule onUnprocessed() {\n+        return builder().onUnprocessed().thenFailure();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleBuilder}.\n+     */\n+    static CircuitBreakerRuleBuilder builder() {\n+        return builder(HttpMethod.knownMethods());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleBuilder} with the specified {@link HttpMethod}s.\n+     */\n+    static CircuitBreakerRuleBuilder builder(HttpMethod... methods) {\n+        requireNonNull(methods, \"methods\");\n+        return builder(ImmutableSet.copyOf(methods));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleBuilder} with the specified {@link HttpMethod}s.\n+     */\n+    static CircuitBreakerRuleBuilder builder(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"method can't be empty.\");\n+        final ImmutableSet<HttpMethod> httpMethods = Sets.immutableEnumSet(methods);\n+        return builder(headers -> httpMethods.contains(headers.method()));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleBuilder} with the specified\n+     * {@code requestHeadersFilter}.\n+     */\n+    static CircuitBreakerRuleBuilder builder(Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        return new CircuitBreakerRuleBuilder(requireNonNull(requestHeadersFilter, \"requestHeadersFilter\"));\n+    }\n+\n+    /**\n+     * Returns a {@link CircuitBreakerRule} that combines the specified {@code circuitBreakerRules}.\n+     */\n+    static CircuitBreakerRule of(CircuitBreakerRule... circuitBreakerRules) {\n+        requireNonNull(circuitBreakerRules, \"circuitBreakerRules\");\n+        checkArgument(circuitBreakerRules.length > 0, \"circuitBreakerRules can't be empty.\");\n+        if (circuitBreakerRules.length == 1) {\n+            return circuitBreakerRules[0];\n+        }\n+        return of(ImmutableList.copyOf(circuitBreakerRules));\n+    }\n+\n+    /**\n+     * Returns a {@link CircuitBreakerRule} that combines all the {@link CircuitBreakerRule} of\n+     * the {@code circuitBreakerRules}.\n+     */\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+    static CircuitBreakerRule of(Iterable<? extends CircuitBreakerRule> circuitBreakerRules) {\n+        requireNonNull(circuitBreakerRules, \"circuitBreakerRules\");\n+        checkArgument(!Iterables.isEmpty(circuitBreakerRules), \"circuitBreakerRules can't be empty.\");\n+        if (Iterables.size(circuitBreakerRules) == 1) {\n+            return Iterables.get(circuitBreakerRules, 0);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        final Iterable<CircuitBreakerRule> cast = (Iterable<CircuitBreakerRule>) circuitBreakerRules;\n+        return Streams.stream(cast).reduce(CircuitBreakerRule::orElse).get();\n+    }\n+\n+    /**\n+     * Returns a composed {@link CircuitBreakerRule} that represents a logical OR of\n+     * this {@link CircuitBreakerRule} and another. If this {@link CircuitBreakerRule} completes with\n+     * {@link CircuitBreakerDecision#next()}, then other {@link CircuitBreakerRule} is evaluated.\n+     */\n+    default CircuitBreakerRule orElse(CircuitBreakerRule other) {\n+        return CircuitBreakerRuleUtil.orElse(this, requireNonNull(other, \"other\"));\n+    }\n+\n+    /**\n+     * Returns a {@link CompletionStage} that contains {@link CircuitBreakerDecision} which indicates\n+     * a {@link Response} is successful or not. If {@link CircuitBreakerDecision#success()} is returned,\n+     * {@link CircuitBreaker#onSuccess()} is called so that the {@link CircuitBreaker} increases its success\n+     * count and uses it to make a decision to close or open the circuit.\n+     * If {@link CircuitBreakerDecision#failure()} is returned, it works\n+     * the other way around. If {@link CircuitBreakerDecision#ignore()} is returned, the {@link CircuitBreaker}\n+     * ignores it. If {@link CircuitBreakerDecision#next()} is returned, a next {@link CircuitBreakerRule} will\n+     * be evaluated.\n+     *\n+     * <p>Note that the last {@link CircuitBreakerRule} completes with {@link CircuitBreakerDecision#next()} or\n+     * a {@link Response} is not matched with the given {@link CircuitBreakerRule}s, the {@link Response} will\n+     * be reported as a success.\n+     *\n+     * <p>To retrieve the {@link ResponseHeaders}, you can use the specified {@link ClientRequestContext}:\n+     *\n+     * <p><pre>{@code", "originalCommit": "1b71ce3cd78e535172c325805175867083205c70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTE0MA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427009140", "bodyText": "This class is not just for RetryRule anymore.", "author": "minwoox", "createdAt": "2020-05-19T03:29:08Z", "path": "core/src/main/java/com/linecorp/armeria/internal/client/AbstractRuleBuilder.java", "diffHunk": "@@ -52,16 +51,19 @@\n     @Nullable\n     private Predicate<Throwable> exceptionFilter;\n \n+    /**\n+     * Creates a new instance with the specified {@code requestHeadersFilter}.\n+     */\n     @SuppressWarnings(\"unchecked\")\n-    AbstractRetryRuleBuilder(Predicate<? super RequestHeaders> requestHeadersFilter) {\n+    protected AbstractRuleBuilder(Predicate<? super RequestHeaders> requestHeadersFilter) {\n         this.requestHeadersFilter = (Predicate<RequestHeaders>) requestHeadersFilter;\n     }\n \n     /**\n      * Adds the specified {@code responseHeadersFilter} for a {@link RetryRule} which will retry", "originalCommit": "1b71ce3cd78e535172c325805175867083205c70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMzQyNg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427023426", "bodyText": "Yeap, I cleaned up Javadoc.", "author": "ikhoon", "createdAt": "2020-05-19T04:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTgxOA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427009818", "bodyText": "requestHeadersFilter != null?", "author": "minwoox", "createdAt": "2020-05-19T03:31:38Z", "path": "core/src/main/java/com/linecorp/armeria/internal/client/AbstractRuleBuilderUtil.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.client;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+public final class AbstractRuleBuilderUtil {\n+\n+    /**\n+     * Merges the filters of {@link AbstractRuleBuilder} into one that returns whether\n+     * if the rules of the specified {@link AbstractRuleBuilder} is matched with\n+     * the given {@link ClientRequestContext} and {@link Throwable}.\n+     */\n+    public static BiFunction<? super ClientRequestContext, ? super Throwable, Boolean>\n+    buildFilter(AbstractRuleBuilder builder) {\n+        final Predicate<RequestHeaders> requestHeadersFilter = builder.requestHeadersFilter();\n+        final Predicate<ResponseHeaders> responseHeadersFilter = builder.responseHeadersFilter();\n+        final Predicate<Throwable> exceptionFilter = builder.exceptionFilter();\n+        return (ctx, cause) -> {\n+            if (ctx.log().isAvailable(RequestLogProperty.REQUEST_HEADERS)) {\n+                final RequestHeaders requestHeaders = ctx.log().partial().requestHeaders();\n+                if (!requestHeadersFilter.test(requestHeaders)) {", "originalCommit": "1b71ce3cd78e535172c325805175867083205c70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxOTA1NA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427019054", "bodyText": "requestHeadersFilter is not null  because it always contains HTTP methods filter.", "author": "ikhoon", "createdAt": "2020-05-19T04:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTgxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxOTY3Ng==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427019676", "bodyText": "Then we can remove the line 48, right?", "author": "minwoox", "createdAt": "2020-05-19T04:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTgxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE0OTI2MA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427149260", "bodyText": "It is a fast path. The bug was fixed. #2726 (comment)", "author": "ikhoon", "createdAt": "2020-05-19T09:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxMDA2Mg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427010062", "bodyText": "Or are these always non null?", "author": "minwoox", "createdAt": "2020-05-19T03:32:29Z", "path": "core/src/main/java/com/linecorp/armeria/internal/client/AbstractRuleBuilderUtil.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.client;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+public final class AbstractRuleBuilderUtil {\n+\n+    /**\n+     * Merges the filters of {@link AbstractRuleBuilder} into one that returns whether\n+     * if the rules of the specified {@link AbstractRuleBuilder} is matched with\n+     * the given {@link ClientRequestContext} and {@link Throwable}.\n+     */\n+    public static BiFunction<? super ClientRequestContext, ? super Throwable, Boolean>\n+    buildFilter(AbstractRuleBuilder builder) {\n+        final Predicate<RequestHeaders> requestHeadersFilter = builder.requestHeadersFilter();\n+        final Predicate<ResponseHeaders> responseHeadersFilter = builder.responseHeadersFilter();\n+        final Predicate<Throwable> exceptionFilter = builder.exceptionFilter();\n+        return (ctx, cause) -> {\n+            if (ctx.log().isAvailable(RequestLogProperty.REQUEST_HEADERS)) {\n+                final RequestHeaders requestHeaders = ctx.log().partial().requestHeaders();\n+                if (!requestHeadersFilter.test(requestHeaders)) {\n+                    return false;\n+                }\n+            }\n+\n+            if (requestHeadersFilter == null && responseHeadersFilter == null) {", "originalCommit": "1b71ce3cd78e535172c325805175867083205c70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNDE0MQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427024141", "bodyText": "Oops... It is a bug. It should be:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (requestHeadersFilter == null && responseHeadersFilter == null) {\n          \n          \n            \n                        if (exceptionFilter == null && responseHeadersFilter == null) {", "author": "ikhoon", "createdAt": "2020-05-19T04:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxMDA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxMDE3Ng==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427010176", "bodyText": "a -> an", "author": "minwoox", "createdAt": "2020-05-19T03:32:50Z", "path": "core/src/main/java/com/linecorp/armeria/internal/client/AbstractRuleWithContentBuilder.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.client;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleWithContent;\n+import com.linecorp.armeria.client.retry.RetryRuleWithContent;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseDuplicator;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+\n+/**\n+ * A skeletal builder implementation for {@link RetryRuleWithContent} and {@link CircuitBreakerRuleWithContent}.\n+ * @param <T> the response type\n+ */\n+public abstract class AbstractRuleWithContentBuilder<T extends Response> extends AbstractRuleBuilder {\n+\n+    @Nullable\n+    private Function<? super T, ? extends CompletionStage<Boolean>> responseFilter;\n+\n+    protected AbstractRuleWithContentBuilder(\n+            Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        super(requestHeadersFilter);\n+    }\n+\n+    /**\n+     * Adds the specified {@code responseFilter} for a {@link AbstractRuleWithContentBuilder}.", "originalCommit": "1b71ce3cd78e535172c325805175867083205c70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2cc0b04f12cdb9805ec64436c760f3881dac867e", "url": "https://github.com/line/armeria/commit/2cc0b04f12cdb9805ec64436c760f3881dac867e", "message": "Fix Javadoc lint", "committedDate": "2020-05-19T04:10:52Z", "type": "commit"}, {"oid": "720d8bf372cd6ae68d3e9a06dea114008f0720f7", "url": "https://github.com/line/armeria/commit/720d8bf372cd6ae68d3e9a06dea114008f0720f7", "message": "Remove RetryStrategy and CircuitBreakerStrategy", "committedDate": "2020-05-19T08:30:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMjE1Mg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427112152", "bodyText": "How about just removing for a ... or ...?", "author": "trustin", "createdAt": "2020-05-19T08:13:24Z", "path": "core/src/main/java/com/linecorp/armeria/client/AbstractRuleBuilder.java", "diffHunk": "@@ -52,16 +52,18 @@\n     @Nullable\n     private Predicate<Throwable> exceptionFilter;\n \n+    /**\n+     * Creates a new instance with the specified {@code requestHeadersFilter}.\n+     */\n     @SuppressWarnings(\"unchecked\")\n-    AbstractRetryRuleBuilder(Predicate<? super RequestHeaders> requestHeadersFilter) {\n+    protected AbstractRuleBuilder(Predicate<? super RequestHeaders> requestHeadersFilter) {\n         this.requestHeadersFilter = (Predicate<RequestHeaders>) requestHeadersFilter;\n     }\n \n     /**\n-     * Adds the specified {@code responseHeadersFilter} for a {@link RetryRule} which will retry\n-     * if the {@code responseHeadersFilter} returns {@code true}.\n+     * Adds the specified {@code responseHeadersFilter} for a {@link RetryRule} or {@link CircuitBreakerRule}.", "originalCommit": "2cc0b04f12cdb9805ec64436c760f3881dac867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMzE3MQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427113171", "bodyText": "A skeletal builder implementation for ... and ...? (like AbstractRuleWithContentBuilder)", "author": "trustin", "createdAt": "2020-05-19T08:15:02Z", "path": "core/src/main/java/com/linecorp/armeria/client/AbstractRuleBuilder.java", "diffHunk": "@@ -29,21 +28,22 @@\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Sets;\n \n-import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRule;\n+import com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleWithContent;\n+import com.linecorp.armeria.client.retry.RetryRule;\n+import com.linecorp.armeria.client.retry.RetryRuleWithContent;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.HttpStatusClass;\n import com.linecorp.armeria.common.RequestHeaders;\n import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.util.UnstableApi;\n \n /**\n- * An abstract builder class which creates a {@link RetryRule} or a {@link RetryRuleWithContent}.\n+ * An abstract builder class which creates a {@link RetryRule}, a {@link RetryRuleWithContent},", "originalCommit": "2cc0b04f12cdb9805ec64436c760f3881dac867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMzQ4MA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427113480", "bodyText": "Ditto - Could remove for ...", "author": "trustin", "createdAt": "2020-05-19T08:15:29Z", "path": "core/src/main/java/com/linecorp/armeria/client/AbstractRuleWithContentBuilder.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleWithContent;\n+import com.linecorp.armeria.client.retry.RetryRuleWithContent;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseDuplicator;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+/**\n+ * A skeletal builder implementation for {@link RetryRuleWithContent} and {@link CircuitBreakerRuleWithContent}.\n+ * @param <T> the response type\n+ */\n+@UnstableApi\n+public abstract class AbstractRuleWithContentBuilder<T extends Response> extends AbstractRuleBuilder {\n+\n+    @Nullable\n+    private Function<? super T, ? extends CompletionStage<Boolean>> responseFilter;\n+\n+    protected AbstractRuleWithContentBuilder(\n+            Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        super(requestHeadersFilter);\n+    }\n+\n+    /**\n+     * Adds the specified {@code responseFilter} for a {@link AbstractRuleWithContentBuilder}.", "originalCommit": "2cc0b04f12cdb9805ec64436c760f3881dac867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNjQ3OA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427116478", "bodyText": ".. and close <p> here", "author": "trustin", "createdAt": "2020-05-19T08:20:26Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRule.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.Streams;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * Determines whether a {@link Response} should be reported as a success or a failure to a\n+ * {@link CircuitBreaker}. If you need to determine whether the request was successful by looking into the\n+ * {@link Response} content, use {@link CircuitBreakerRuleWithContent}.\n+ *\n+ * <p>Note that the last {@link CircuitBreakerRule} completes with {@link CircuitBreakerDecision#next()} or\n+ * a {@link Response} is not matched with {@link CircuitBreakerRule}s, the {@link Response} will be reported as\n+ * a success.\n+ *\n+ * <p>For example:\n+ * <pre>{@code\n+ * // If a response status is 500(Interval Server Error), the response will be reported as a failure.\n+ * // Otherwise, the response will be reported as a success.\n+ * CircuitBreakerRule.onStatus(HttpStatus.INTERNAL_SERVER_ERROR);\n+ *\n+ * // A response will be reported as a success if no exception is raised.\n+ * CircuitBreakerRule.onException();\n+ *\n+ * // A CircuitBreakerRule that reports a response as a failure except that a response status code is 2xx.\n+ * CircuitBreakerRule.of(\n+ *                       // Report as a success if the class of a response status is 2xx\n+ *                       CircuitBreakerRule.builder()\n+ *                                         .onStatusClass(HttpStatusClass.SUCCESS)\n+ *                                         .thenSuccess(),\n+ *                       // Everything else is reported as a failure\n+ *                       ClientBreakerRule.builder().thenFailure());\n+ * }\n+ * </pre>\n+ */\n+@FunctionalInterface\n+public interface CircuitBreakerRule {\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    static CircuitBreakerRule onStatusClass(HttpStatusClass statusClass) {\n+        return builder().onStatusClass(statusClass).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    static CircuitBreakerRule onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        return builder().onStatusClass(statusClasses).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    static CircuitBreakerRule onServerErrorStatus() {\n+        return builder().onServerErrorStatus().thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    static CircuitBreakerRule onStatus(HttpStatus... statuses) {\n+        return builder().onStatus(statuses).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    static CircuitBreakerRule onStatus(Iterable<HttpStatus> statuses) {\n+        return builder().onStatus(statuses).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if the specified {@code statusFilter} returns {@code true}.\n+     */\n+    static CircuitBreakerRule onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        return builder().onStatus(statusFilter).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if an {@link Exception} is raised and that is instance of the specified {@code exception}.\n+     */\n+    static CircuitBreakerRule onException(Class<? extends Throwable> exception) {\n+        return builder().onException(exception).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if an {@link Exception} is raised and the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    static CircuitBreakerRule onException(Predicate<? super Throwable> exceptionFilter) {\n+        return builder().onException(exceptionFilter).thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if an {@link Exception} is raised.\n+     */\n+    static CircuitBreakerRule onException() {\n+        return builder().onException().thenFailure();\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that will report a {@link Response} as a failure,\n+     * if an {@link UnprocessedRequestException} which means that the request has not been processed by\n+     * the server is raised.\n+     */\n+    static CircuitBreakerRule onUnprocessed() {\n+        return builder().onUnprocessed().thenFailure();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleBuilder}.\n+     */\n+    static CircuitBreakerRuleBuilder builder() {\n+        return builder(HttpMethod.knownMethods());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleBuilder} with the specified {@link HttpMethod}s.\n+     */\n+    static CircuitBreakerRuleBuilder builder(HttpMethod... methods) {\n+        requireNonNull(methods, \"methods\");\n+        return builder(ImmutableSet.copyOf(methods));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleBuilder} with the specified {@link HttpMethod}s.\n+     */\n+    static CircuitBreakerRuleBuilder builder(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"method can't be empty.\");\n+        final ImmutableSet<HttpMethod> httpMethods = Sets.immutableEnumSet(methods);\n+        return builder(headers -> httpMethods.contains(headers.method()));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleBuilder} with the specified\n+     * {@code requestHeadersFilter}.\n+     */\n+    static CircuitBreakerRuleBuilder builder(Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        return new CircuitBreakerRuleBuilder(requireNonNull(requestHeadersFilter, \"requestHeadersFilter\"));\n+    }\n+\n+    /**\n+     * Returns a {@link CircuitBreakerRule} that combines the specified {@code circuitBreakerRules}.\n+     */\n+    static CircuitBreakerRule of(CircuitBreakerRule... circuitBreakerRules) {\n+        requireNonNull(circuitBreakerRules, \"circuitBreakerRules\");\n+        checkArgument(circuitBreakerRules.length > 0, \"circuitBreakerRules can't be empty.\");\n+        if (circuitBreakerRules.length == 1) {\n+            return circuitBreakerRules[0];\n+        }\n+        return of(ImmutableList.copyOf(circuitBreakerRules));\n+    }\n+\n+    /**\n+     * Returns a {@link CircuitBreakerRule} that combines all the {@link CircuitBreakerRule} of\n+     * the {@code circuitBreakerRules}.\n+     */\n+    @SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+    static CircuitBreakerRule of(Iterable<? extends CircuitBreakerRule> circuitBreakerRules) {\n+        requireNonNull(circuitBreakerRules, \"circuitBreakerRules\");\n+        checkArgument(!Iterables.isEmpty(circuitBreakerRules), \"circuitBreakerRules can't be empty.\");\n+        if (Iterables.size(circuitBreakerRules) == 1) {\n+            return Iterables.get(circuitBreakerRules, 0);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        final Iterable<CircuitBreakerRule> cast = (Iterable<CircuitBreakerRule>) circuitBreakerRules;\n+        return Streams.stream(cast).reduce(CircuitBreakerRule::orElse).get();\n+    }\n+\n+    /**\n+     * Returns a composed {@link CircuitBreakerRule} that represents a logical OR of\n+     * this {@link CircuitBreakerRule} and another. If this {@link CircuitBreakerRule} completes with\n+     * {@link CircuitBreakerDecision#next()}, then other {@link CircuitBreakerRule} is evaluated.\n+     */\n+    default CircuitBreakerRule orElse(CircuitBreakerRule other) {\n+        return CircuitBreakerRuleUtil.orElse(this, requireNonNull(other, \"other\"));\n+    }\n+\n+    /**\n+     * Returns a {@link CompletionStage} that contains {@link CircuitBreakerDecision} which indicates\n+     * a {@link Response} is successful or not. If {@link CircuitBreakerDecision#success()} is returned,\n+     * {@link CircuitBreaker#onSuccess()} is called so that the {@link CircuitBreaker} increases its success\n+     * count and uses it to make a decision to close or open the circuit.\n+     * If {@link CircuitBreakerDecision#failure()} is returned, it works\n+     * the other way around. If {@link CircuitBreakerDecision#ignore()} is returned, the {@link CircuitBreaker}\n+     * ignores it. If {@link CircuitBreakerDecision#next()} is returned, a next {@link CircuitBreakerRule} will\n+     * be evaluated.\n+     *\n+     * <p>Note that the last {@link CircuitBreakerRule} completes with {@link CircuitBreakerDecision#next()} or\n+     * a {@link Response} is not matched with the given {@link CircuitBreakerRule}s, the {@link Response} will\n+     * be reported as a success.\n+     *\n+     * <p>To retrieve the {@link ResponseHeaders}, you can use the specified {@link ClientRequestContext}:\n+     *\n+     * <p><pre>{@code\n+     * > CompletionStage<CircuitBreakerDecision> shouldReportAsSuccess(ClientRequestContext ctx,\n+     * >                                                               @Nullable Throwable cause) {\n+     * >     if (cause != null) {\n+     * >         return CompletableFuture.completedFuture(CircuitBreakerDecision.failure());\n+     * >     }\n+     *\n+     * >     ResponseHeaders responseHeaders = ctx.log().responseHeaders();\n+     * >     if (responseHeaders.status().codeClass() == HttpStatusClass.SERVER_ERROR) {\n+     * >         return CompletableFuture.completedFuture(CircuitBreakerDecision.failure());\n+     * >     }\n+     * >     ...\n+     * >     return CompletableFuture.completedFuture(CircuitBreakerDecision.success())\n+     * > }\n+     * }</pre>", "originalCommit": "2cc0b04f12cdb9805ec64436c760f3881dac867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNzUyMg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427117522", "bodyText": "Could you rephrase as .... part? Not correct grammar.", "author": "trustin", "createdAt": "2020-05-19T08:22:07Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRuleBuilder.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import static com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleUtil.FAILURE_DECISION;\n+import static com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleUtil.IGNORE_DECISION;\n+import static com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleUtil.NEXT_DECISION;\n+import static com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleUtil.SUCCESS_DECISION;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+import com.linecorp.armeria.client.AbstractRuleBuilder;\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.internal.client.AbstractRuleBuilderUtil;\n+\n+/**\n+ * A builder class that creates {@link CircuitBreakerRule}.\n+ */\n+public final class CircuitBreakerRuleBuilder extends AbstractRuleBuilder {\n+\n+    CircuitBreakerRuleBuilder(Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        super(requestHeadersFilter);\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that determines whether a {@link Response} should be\n+     * reported as a success.\n+     */\n+    public CircuitBreakerRule thenSuccess() {\n+        return build(CircuitBreakerDecision.success());\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that determines whether a {@link Response} should be\n+     * reported as a failure.\n+     */\n+    public CircuitBreakerRule thenFailure() {\n+        return build(CircuitBreakerDecision.failure());\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that determines whether a {@link Response} should be\n+     * reported as a failure.\n+     */\n+    public CircuitBreakerRule thenIgnore() {\n+        return build(CircuitBreakerDecision.ignore());\n+    }\n+\n+    private CircuitBreakerRule build(CircuitBreakerDecision decision) {\n+        return build(this, decision);\n+    }\n+\n+    static CircuitBreakerRule build(AbstractRuleBuilder builder, CircuitBreakerDecision decision) {\n+        final BiFunction<? super ClientRequestContext, ? super Throwable, Boolean> filter =\n+                AbstractRuleBuilderUtil.buildFilter(builder);\n+\n+        final CompletableFuture<CircuitBreakerDecision> decisionFuture;\n+        if (decision == CircuitBreakerDecision.success()) {\n+            decisionFuture = SUCCESS_DECISION;\n+        } else if (decision == CircuitBreakerDecision.failure()) {\n+            decisionFuture = FAILURE_DECISION;\n+        } else if (decision == CircuitBreakerDecision.ignore()) {\n+            decisionFuture = IGNORE_DECISION;\n+        } else {\n+            decisionFuture = NEXT_DECISION;\n+        }\n+\n+        return filter.andThen(matched -> matched ? decisionFuture : NEXT_DECISION)::apply;\n+    }\n+\n+    // Override the return type and Javadoc of chaining methods in superclass.\n+\n+    /**\n+     * Adds the specified {@code responseHeadersFilter} for a {@link CircuitBreakerRule} which will\n+     * report a {@link Response} as a success, failure or ignore it according tothe build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the specified\n+     * {@code responseHeadersFilter} completes with {@code true}.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onResponseHeaders(\n+            Predicate<? super ResponseHeaders> responseHeadersFilter) {\n+        return (CircuitBreakerRuleBuilder) super.onResponseHeaders(responseHeadersFilter);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link CircuitBreakerRuleWithContent} which will\n+     * report a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the class of the response\n+     * status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onStatusClass(HttpStatusClass... statusClasses) {\n+        return (CircuitBreakerRuleBuilder) super.onStatusClass(statusClasses);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link CircuitBreakerRuleWithContent} which will\n+     * report a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the class of the response\n+     * status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        return (CircuitBreakerRuleBuilder) super.onStatusClass(statusClasses);\n+    }\n+\n+    /**\n+     * Adds the {@link HttpStatusClass#SERVER_ERROR} for a {@link CircuitBreakerRuleWithContent} which will\n+     * report a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the class of the response\n+     * status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onServerErrorStatus() {\n+        return (CircuitBreakerRuleBuilder) super.onServerErrorStatus();\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link CircuitBreakerRuleWithContent} which will report\n+     * a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the response status is\n+     * one of the specified {@link HttpStatus}es.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onStatus(HttpStatus... statuses) {\n+        return (CircuitBreakerRuleBuilder) super.onStatus(statuses);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link CircuitBreakerRuleWithContent} which will report\n+     * a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the response status is\n+     * one of the specified {@link HttpStatus}es.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onStatus(Iterable<HttpStatus> statuses) {\n+        return (CircuitBreakerRuleBuilder) super.onStatus(statuses);\n+    }\n+\n+    /**\n+     * Adds the specified {@code statusFilter} for a {@link CircuitBreakerRule} which will report\n+     * a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the response status matches\n+     * the specified {@code statusFilter}.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        return (CircuitBreakerRuleBuilder) super.onStatus(statusFilter);\n+    }\n+\n+    /**\n+     * Adds the specified exception type for a {@link CircuitBreakerRule} which will report a {@link Response}\n+     * as a success, failure or ignore it according to the build methods - {@link #thenSuccess()},\n+     * {@link #thenFailure()} and {@link #thenIgnore()}, if an {@link Exception} is\n+     * raised and that is instance of the specified {@code exception}.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onException(Class<? extends Throwable> exception) {\n+        return (CircuitBreakerRuleBuilder) super.onException(exception);\n+    }\n+\n+    /**\n+     * Adds the specified {@code exceptionFilter} for a {@link CircuitBreakerRule} which will report\n+     * a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if an {@link Exception} is\n+     * raised and the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onException(Predicate<? super Throwable> exceptionFilter) {\n+        return (CircuitBreakerRuleBuilder) super.onException(exceptionFilter);\n+    }\n+\n+    /**\n+     * Makes a {@link CircuitBreakerRuleWithContent} report a {@link Response} as a success, failure or\n+     * ignore it according to the build methods - {@link #thenSuccess()}, {@link #thenFailure()} and\n+     * {@link #thenIgnore()} if an {@link Exception} is raised.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onException() {\n+        return (CircuitBreakerRuleBuilder) super.onException();\n+    }\n+\n+    /**\n+     * Makes a {@link CircuitBreakerRule} report a {@link Response} as a success, failure or ignore it\n+     * according to the build methods - {@link #thenSuccess()}, {@link #thenFailure()} and", "originalCommit": "2cc0b04f12cdb9805ec64436c760f3881dac867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODE1MA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427118150", "bodyText": "Insert a comma before which and is for readability.", "author": "trustin", "createdAt": "2020-05-19T08:22:58Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRuleBuilder.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import static com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleUtil.FAILURE_DECISION;\n+import static com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleUtil.IGNORE_DECISION;\n+import static com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleUtil.NEXT_DECISION;\n+import static com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleUtil.SUCCESS_DECISION;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+import com.linecorp.armeria.client.AbstractRuleBuilder;\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.internal.client.AbstractRuleBuilderUtil;\n+\n+/**\n+ * A builder class that creates {@link CircuitBreakerRule}.\n+ */\n+public final class CircuitBreakerRuleBuilder extends AbstractRuleBuilder {\n+\n+    CircuitBreakerRuleBuilder(Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        super(requestHeadersFilter);\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that determines whether a {@link Response} should be\n+     * reported as a success.\n+     */\n+    public CircuitBreakerRule thenSuccess() {\n+        return build(CircuitBreakerDecision.success());\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that determines whether a {@link Response} should be\n+     * reported as a failure.\n+     */\n+    public CircuitBreakerRule thenFailure() {\n+        return build(CircuitBreakerDecision.failure());\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRule} that determines whether a {@link Response} should be\n+     * reported as a failure.\n+     */\n+    public CircuitBreakerRule thenIgnore() {\n+        return build(CircuitBreakerDecision.ignore());\n+    }\n+\n+    private CircuitBreakerRule build(CircuitBreakerDecision decision) {\n+        return build(this, decision);\n+    }\n+\n+    static CircuitBreakerRule build(AbstractRuleBuilder builder, CircuitBreakerDecision decision) {\n+        final BiFunction<? super ClientRequestContext, ? super Throwable, Boolean> filter =\n+                AbstractRuleBuilderUtil.buildFilter(builder);\n+\n+        final CompletableFuture<CircuitBreakerDecision> decisionFuture;\n+        if (decision == CircuitBreakerDecision.success()) {\n+            decisionFuture = SUCCESS_DECISION;\n+        } else if (decision == CircuitBreakerDecision.failure()) {\n+            decisionFuture = FAILURE_DECISION;\n+        } else if (decision == CircuitBreakerDecision.ignore()) {\n+            decisionFuture = IGNORE_DECISION;\n+        } else {\n+            decisionFuture = NEXT_DECISION;\n+        }\n+\n+        return filter.andThen(matched -> matched ? decisionFuture : NEXT_DECISION)::apply;\n+    }\n+\n+    // Override the return type and Javadoc of chaining methods in superclass.\n+\n+    /**\n+     * Adds the specified {@code responseHeadersFilter} for a {@link CircuitBreakerRule} which will\n+     * report a {@link Response} as a success, failure or ignore it according tothe build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the specified\n+     * {@code responseHeadersFilter} completes with {@code true}.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onResponseHeaders(\n+            Predicate<? super ResponseHeaders> responseHeadersFilter) {\n+        return (CircuitBreakerRuleBuilder) super.onResponseHeaders(responseHeadersFilter);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link CircuitBreakerRuleWithContent} which will\n+     * report a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the class of the response\n+     * status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onStatusClass(HttpStatusClass... statusClasses) {\n+        return (CircuitBreakerRuleBuilder) super.onStatusClass(statusClasses);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link CircuitBreakerRuleWithContent} which will\n+     * report a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the class of the response\n+     * status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        return (CircuitBreakerRuleBuilder) super.onStatusClass(statusClasses);\n+    }\n+\n+    /**\n+     * Adds the {@link HttpStatusClass#SERVER_ERROR} for a {@link CircuitBreakerRuleWithContent} which will\n+     * report a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the class of the response\n+     * status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onServerErrorStatus() {\n+        return (CircuitBreakerRuleBuilder) super.onServerErrorStatus();\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link CircuitBreakerRuleWithContent} which will report\n+     * a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the response status is\n+     * one of the specified {@link HttpStatus}es.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onStatus(HttpStatus... statuses) {\n+        return (CircuitBreakerRuleBuilder) super.onStatus(statuses);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link CircuitBreakerRuleWithContent} which will report\n+     * a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the response status is\n+     * one of the specified {@link HttpStatus}es.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onStatus(Iterable<HttpStatus> statuses) {\n+        return (CircuitBreakerRuleBuilder) super.onStatus(statuses);\n+    }\n+\n+    /**\n+     * Adds the specified {@code statusFilter} for a {@link CircuitBreakerRule} which will report\n+     * a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if the response status matches\n+     * the specified {@code statusFilter}.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        return (CircuitBreakerRuleBuilder) super.onStatus(statusFilter);\n+    }\n+\n+    /**\n+     * Adds the specified exception type for a {@link CircuitBreakerRule} which will report a {@link Response}\n+     * as a success, failure or ignore it according to the build methods - {@link #thenSuccess()},\n+     * {@link #thenFailure()} and {@link #thenIgnore()}, if an {@link Exception} is\n+     * raised and that is instance of the specified {@code exception}.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onException(Class<? extends Throwable> exception) {\n+        return (CircuitBreakerRuleBuilder) super.onException(exception);\n+    }\n+\n+    /**\n+     * Adds the specified {@code exceptionFilter} for a {@link CircuitBreakerRule} which will report\n+     * a {@link Response} as a success, failure or ignore it according to the build methods -\n+     * {@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}, if an {@link Exception} is\n+     * raised and the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onException(Predicate<? super Throwable> exceptionFilter) {\n+        return (CircuitBreakerRuleBuilder) super.onException(exceptionFilter);\n+    }\n+\n+    /**\n+     * Makes a {@link CircuitBreakerRuleWithContent} report a {@link Response} as a success, failure or\n+     * ignore it according to the build methods - {@link #thenSuccess()}, {@link #thenFailure()} and\n+     * {@link #thenIgnore()} if an {@link Exception} is raised.\n+     */\n+    @Override\n+    public CircuitBreakerRuleBuilder onException() {\n+        return (CircuitBreakerRuleBuilder) super.onException();\n+    }\n+\n+    /**\n+     * Makes a {@link CircuitBreakerRule} report a {@link Response} as a success, failure or ignore it\n+     * according to the build methods - {@link #thenSuccess()}, {@link #thenFailure()} and\n+     * {@link #thenIgnore()}, if an {@link UnprocessedRequestException} which means that the request has not\n+     * been processed by the server is raised.", "originalCommit": "2cc0b04f12cdb9805ec64436c760f3881dac867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU1NQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427118555", "bodyText": "public could be removed?", "author": "trustin", "createdAt": "2020-05-19T08:23:36Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRuleUtil.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseDuplicator;\n+import com.linecorp.armeria.common.Response;\n+\n+final class CircuitBreakerRuleUtil {\n+\n+    public static final CompletableFuture<CircuitBreakerDecision> SUCCESS_DECISION =\n+            CompletableFuture.completedFuture(CircuitBreakerDecision.success());\n+    public static final CompletableFuture<CircuitBreakerDecision> FAILURE_DECISION =\n+            CompletableFuture.completedFuture(CircuitBreakerDecision.failure());\n+    public static final CompletableFuture<CircuitBreakerDecision> IGNORE_DECISION =\n+            CompletableFuture.completedFuture(CircuitBreakerDecision.ignore());\n+    public static final CompletableFuture<CircuitBreakerDecision> NEXT_DECISION =\n+            CompletableFuture.completedFuture(CircuitBreakerDecision.next());", "originalCommit": "2cc0b04f12cdb9805ec64436c760f3881dac867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEyMDI5NQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427120295", "bodyText": "combines the specified {@link CircuitBreakerRuleWithContent}s?", "author": "trustin", "createdAt": "2020-05-19T08:26:13Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRuleWithContent.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.Streams;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+\n+/**\n+ * Determines whether a {@link Response} should be reported as a success or a failure to a\n+ * {@link CircuitBreaker} using the content of a {@link Response}. If you just need the HTTP headers\n+ * to make a decision, use {@link CircuitBreakerRule} for efficiency.\n+ *\n+ * @param <T> the response type\n+ */\n+@FunctionalInterface\n+public interface CircuitBreakerRuleWithContent<T extends Response> {\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleWithContent} that will report a {@link Response} as\n+     * a failure if the specified {@code responseFilter} completes with {@code true}.\n+     */\n+    static <T extends Response> CircuitBreakerRuleWithContent<T> onResponse(\n+            Function<? super T, ? extends CompletionStage<Boolean>> responseFilter) {\n+        return CircuitBreakerRuleWithContent.<T>builder().onResponse(responseFilter).thenFailure();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleWithContentBuilder}.\n+     */\n+    static <T extends Response> CircuitBreakerRuleWithContentBuilder<T> builder() {\n+        return builder(HttpMethod.knownMethods());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleWithContentBuilder} with the specified\n+     * {@link HttpMethod}s.\n+     */\n+    static <T extends Response> CircuitBreakerRuleWithContentBuilder<T> builder(HttpMethod... methods) {\n+        return builder(ImmutableSet.copyOf(requireNonNull(methods, \"methods\")));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleWithContentBuilder} with the specified\n+     * {@link HttpMethod}s.\n+     */\n+    static <T extends Response> CircuitBreakerRuleWithContentBuilder<T> builder(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"methods can't be empty.\");\n+        final ImmutableSet<HttpMethod> httpMethods = Sets.immutableEnumSet(methods);\n+        return builder(headers -> httpMethods.contains(headers.method()));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleWithContentBuilder} with the specified\n+     * {@code requestHeadersFilter}.\n+     */\n+    static <T extends Response> CircuitBreakerRuleWithContentBuilder<T> builder(\n+            Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        requireNonNull(requestHeadersFilter, \"requestHeadersFilter\");\n+        return new CircuitBreakerRuleWithContentBuilder<>(requestHeadersFilter);\n+    }\n+\n+    /**\n+     * Returns a {@link CircuitBreakerRuleWithContent} that combines the specified {@code circuitBreakerRules}.\n+     */\n+    @SafeVarargs\n+    static <T extends Response> CircuitBreakerRuleWithContent<T> of(\n+            CircuitBreakerRuleWithContent<T>... circuitBreakerRules) {\n+        requireNonNull(circuitBreakerRules, \"circuitBreakerRules\");\n+        checkArgument(circuitBreakerRules.length > 0, \"circuitBreakerRules can't be empty.\");\n+        if (circuitBreakerRules.length == 1) {\n+            return circuitBreakerRules[0];\n+        }\n+        return of(ImmutableList.copyOf(circuitBreakerRules));\n+    }\n+\n+    /**\n+     * Returns a {@link CircuitBreakerRuleWithContent} that combines all the\n+     * {@link CircuitBreakerRuleWithContent} of the {@code circuitBreakerRules}.", "originalCommit": "2cc0b04f12cdb9805ec64436c760f3881dac867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEyMDMzOA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427120338", "bodyText": "combines the specified {@link CircuitBreakerRuleWithContent}s?", "author": "trustin", "createdAt": "2020-05-19T08:26:17Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRuleWithContent.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.Streams;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+\n+/**\n+ * Determines whether a {@link Response} should be reported as a success or a failure to a\n+ * {@link CircuitBreaker} using the content of a {@link Response}. If you just need the HTTP headers\n+ * to make a decision, use {@link CircuitBreakerRule} for efficiency.\n+ *\n+ * @param <T> the response type\n+ */\n+@FunctionalInterface\n+public interface CircuitBreakerRuleWithContent<T extends Response> {\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleWithContent} that will report a {@link Response} as\n+     * a failure if the specified {@code responseFilter} completes with {@code true}.\n+     */\n+    static <T extends Response> CircuitBreakerRuleWithContent<T> onResponse(\n+            Function<? super T, ? extends CompletionStage<Boolean>> responseFilter) {\n+        return CircuitBreakerRuleWithContent.<T>builder().onResponse(responseFilter).thenFailure();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleWithContentBuilder}.\n+     */\n+    static <T extends Response> CircuitBreakerRuleWithContentBuilder<T> builder() {\n+        return builder(HttpMethod.knownMethods());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleWithContentBuilder} with the specified\n+     * {@link HttpMethod}s.\n+     */\n+    static <T extends Response> CircuitBreakerRuleWithContentBuilder<T> builder(HttpMethod... methods) {\n+        return builder(ImmutableSet.copyOf(requireNonNull(methods, \"methods\")));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleWithContentBuilder} with the specified\n+     * {@link HttpMethod}s.\n+     */\n+    static <T extends Response> CircuitBreakerRuleWithContentBuilder<T> builder(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"methods can't be empty.\");\n+        final ImmutableSet<HttpMethod> httpMethods = Sets.immutableEnumSet(methods);\n+        return builder(headers -> httpMethods.contains(headers.method()));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleWithContentBuilder} with the specified\n+     * {@code requestHeadersFilter}.\n+     */\n+    static <T extends Response> CircuitBreakerRuleWithContentBuilder<T> builder(\n+            Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        requireNonNull(requestHeadersFilter, \"requestHeadersFilter\");\n+        return new CircuitBreakerRuleWithContentBuilder<>(requestHeadersFilter);\n+    }\n+\n+    /**\n+     * Returns a {@link CircuitBreakerRuleWithContent} that combines the specified {@code circuitBreakerRules}.", "originalCommit": "2cc0b04f12cdb9805ec64436c760f3881dac867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEyMDkxOA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427120918", "bodyText": "creates a", "author": "trustin", "createdAt": "2020-05-19T08:27:09Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRuleWithContentBuilder.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import static com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleUtil.NEXT_DECISION;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.linecorp.armeria.client.AbstractRuleWithContentBuilder;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * A builder that creates {@link CircuitBreakerRuleWithContent}.", "originalCommit": "2cc0b04f12cdb9805ec64436c760f3881dac867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEyMTExNw==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427121117", "bodyText": "Many missing a/an", "author": "trustin", "createdAt": "2020-05-19T08:27:28Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRuleWithContentBuilder.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import static com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleUtil.NEXT_DECISION;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.linecorp.armeria.client.AbstractRuleWithContentBuilder;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * A builder that creates {@link CircuitBreakerRuleWithContent}.\n+ * @param <T> the response type\n+ */\n+public class CircuitBreakerRuleWithContentBuilder<T extends Response>\n+        extends AbstractRuleWithContentBuilder<T> {\n+\n+    CircuitBreakerRuleWithContentBuilder(Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        super(requestHeadersFilter);\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRuleWithContent} that determines whether a {@link Response}", "originalCommit": "2cc0b04f12cdb9805ec64436c760f3881dac867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEyMTg4Mg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r427121882", "bodyText": "determines a {@link Response} as a success when the rule matches.", "author": "trustin", "createdAt": "2020-05-19T08:28:38Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRuleWithContentBuilder.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import static com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleUtil.NEXT_DECISION;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.linecorp.armeria.client.AbstractRuleWithContentBuilder;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * A builder that creates {@link CircuitBreakerRuleWithContent}.\n+ * @param <T> the response type\n+ */\n+public class CircuitBreakerRuleWithContentBuilder<T extends Response>\n+        extends AbstractRuleWithContentBuilder<T> {\n+\n+    CircuitBreakerRuleWithContentBuilder(Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        super(requestHeadersFilter);\n+    }\n+\n+    /**\n+     * Returns newly created {@link CircuitBreakerRuleWithContent} that determines whether a {@link Response}\n+     * should be reported as a success.", "originalCommit": "2cc0b04f12cdb9805ec64436c760f3881dac867e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4f64b93d74ab037d38a9abe5e842391e4ab94bde", "url": "https://github.com/line/armeria/commit/4f64b93d74ab037d38a9abe5e842391e4ab94bde", "message": "Update Javadoc", "committedDate": "2020-05-19T14:38:20Z", "type": "commit"}, {"oid": "8ed193161ea8fc1022369e0ce9962dc5a7fa4084", "url": "https://github.com/line/armeria/commit/8ed193161ea8fc1022369e0ce9962dc5a7fa4084", "message": "Fix test", "committedDate": "2020-05-19T15:45:15Z", "type": "commit"}, {"oid": "19dafbda8c277e0d288f518c540bb6d86e82f7fe", "url": "https://github.com/line/armeria/commit/19dafbda8c277e0d288f518c540bb6d86e82f7fe", "message": "Clean upe", "committedDate": "2020-05-20T02:14:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQwOTc0Ng==", "url": "https://github.com/line/armeria/pull/2726#discussion_r428409746", "bodyText": "I realized this class can be used for building CircuitBreakerRule(WithContent).", "author": "trustin", "createdAt": "2020-05-21T02:22:07Z", "path": "core/src/main/java/com/linecorp/armeria/client/AbstractRuleBuilder.java", "diffHunk": "@@ -29,21 +28,19 @@\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Sets;\n \n-import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.client.retry.RetryRule;\n+import com.linecorp.armeria.client.retry.RetryRuleWithContent;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.HttpStatusClass;\n import com.linecorp.armeria.common.RequestHeaders;\n import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.util.UnstableApi;\n \n /**\n- * An abstract builder class which creates a {@link RetryRule} or a {@link RetryRuleWithContent}.\n+ * A skeletal builder implementation for {@link RetryRule} and {@link RetryRuleWithContent}.", "originalCommit": "19dafbda8c277e0d288f518c540bb6d86e82f7fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMDg3OQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r428410879", "bodyText": "Grammar?", "author": "trustin", "createdAt": "2020-05-21T02:27:04Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRule.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.Streams;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * Determines whether a {@link Response} should be reported as a success or failure to a\n+ * {@link CircuitBreaker}. If you need to determine whether the request was successful by looking into the\n+ * {@link Response} content, use {@link CircuitBreakerRuleWithContent}.\n+ *\n+ * <p>Note that the last {@link CircuitBreakerRule} completes with {@link CircuitBreakerDecision#next()} or\n+ * a {@link Response} is not matched with the {@link CircuitBreakerRule}s, the {@link Response} will be\n+ * reported as a success.", "originalCommit": "19dafbda8c277e0d288f518c540bb6d86e82f7fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMTUzNg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r428411536", "bodyText": "and that is -> and it is an", "author": "trustin", "createdAt": "2020-05-21T02:29:57Z", "path": "core/src/main/java/com/linecorp/armeria/client/circuitbreaker/CircuitBreakerRuleWithContentBuilder.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.circuitbreaker;\n+\n+import static com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleUtil.NEXT_DECISION;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.linecorp.armeria.client.AbstractRuleWithContentBuilder;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * A builder for creating a new {@link CircuitBreakerRuleWithContent}.\n+ * @param <T> the response type\n+ */\n+public class CircuitBreakerRuleWithContentBuilder<T extends Response>\n+        extends AbstractRuleWithContentBuilder<T> {\n+\n+    CircuitBreakerRuleWithContentBuilder(Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        super(requestHeadersFilter);\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleWithContent} that determines a {@link Response} as\n+     * a success when the rule matches.\n+     */\n+    public CircuitBreakerRuleWithContent<T> thenSuccess() {\n+        return build(CircuitBreakerDecision.success());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleWithContent} that determines a {@link Response} as\n+     * a failure when the rule matches.\n+     */\n+    public CircuitBreakerRuleWithContent<T> thenFailure() {\n+        return build(CircuitBreakerDecision.failure());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link CircuitBreakerRuleWithContent} that ignores a {@link Response} when\n+     * the rule matches.\n+     */\n+    public CircuitBreakerRuleWithContent<T> thenIgnore() {\n+        return build(CircuitBreakerDecision.ignore());\n+    }\n+\n+    private CircuitBreakerRuleWithContent<T> build(CircuitBreakerDecision decision) {\n+        final Function<? super T, ? extends CompletionStage<Boolean>> responseFilter = responseFilter();\n+        final boolean hasResponseFilter = responseFilter != null;\n+        final CircuitBreakerRule first = CircuitBreakerRuleBuilder.build(this, decision, hasResponseFilter);\n+        if (!hasResponseFilter) {\n+            return CircuitBreakerRuleUtil.fromCircuitBreakerRule(first);\n+        }\n+\n+        final CircuitBreakerRuleWithContent<T> second = (ctx, content, cause) -> {\n+            if (content == null) {\n+                return NEXT_DECISION;\n+            }\n+            return responseFilter.apply(content)\n+                                 .handle((matched, cause0) -> {\n+                                     if (cause0 != null) {\n+                                         return CircuitBreakerDecision.next();\n+                                     }\n+                                     return matched ? decision : CircuitBreakerDecision.next();\n+                                 });\n+        };\n+        return CircuitBreakerRuleUtil.orElse(first, second);\n+    }\n+\n+    // Override the return type and Javadoc of chaining methods in superclass.\n+\n+    /**\n+     * Adds the specified {@code responseFilter} for a {@link CircuitBreakerRuleWithContent}.\n+     * If the specified {@code responseFilter} completes with {@code true},\n+     * depending on the build methods({@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}),\n+     * a {@link Response} is reported as a success or failure to a {@link CircuitBreaker} or ignored.\n+     */\n+    @Override\n+    public CircuitBreakerRuleWithContentBuilder<T> onResponse(\n+            Function<? super T, ? extends CompletionStage<Boolean>> responseFilter) {\n+        return (CircuitBreakerRuleWithContentBuilder<T>) super.onResponse(responseFilter);\n+    }\n+\n+    /**\n+     * Adds the specified {@code responseHeadersFilter} for a {@link CircuitBreakerRuleWithContent}.\n+     * If the specified {@code responseHeadersFilter} returns {@code true},\n+     * depending on the build methods({@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}),\n+     * a {@link Response} is reported as a success or failure to a {@link CircuitBreaker} or ignored.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public CircuitBreakerRuleWithContentBuilder<T> onResponseHeaders(\n+            Predicate<? super ResponseHeaders> responseHeadersFilter) {\n+        return (CircuitBreakerRuleWithContentBuilder<T>) super.onResponseHeaders(responseHeadersFilter);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link CircuitBreakerRuleWithContent}.\n+     * If the class of the response status is one of the specified {@link HttpStatusClass}es,\n+     * depending on the build methods({@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}),\n+     * a {@link Response} is reported as a success or failure to a {@link CircuitBreaker} or ignored.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public CircuitBreakerRuleWithContentBuilder<T> onStatusClass(HttpStatusClass... statusClasses) {\n+        return (CircuitBreakerRuleWithContentBuilder<T>) super.onStatusClass(statusClasses);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link CircuitBreakerRuleWithContent}.\n+     * If the class of the response status is one of the specified {@link HttpStatusClass}es,\n+     * depending on the build methods({@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}),\n+     * a {@link Response} is reported as a success or failure to a {@link CircuitBreaker} or ignored.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public CircuitBreakerRuleWithContentBuilder<T> onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        return (CircuitBreakerRuleWithContentBuilder<T>) super.onStatusClass(statusClasses);\n+    }\n+\n+    /**\n+     * Adds the {@link HttpStatusClass#SERVER_ERROR} for a {@link CircuitBreakerRuleWithContent}.\n+     * If the class of the response status is {@link HttpStatusClass#SERVER_ERROR},\n+     * depending on the build methods({@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}),\n+     * a {@link Response} is reported as a success or failure to a {@link CircuitBreaker} or ignored.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public CircuitBreakerRuleWithContentBuilder<T> onServerErrorStatus() {\n+        return (CircuitBreakerRuleWithContentBuilder<T>) super.onServerErrorStatus();\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link CircuitBreakerRuleWithContent}.\n+     * If the response status is one of the specified {@link HttpStatus}es,\n+     * depending on the build methods({@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}),\n+     * a {@link Response} is reported as a success or failure to a {@link CircuitBreaker} or ignored.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public CircuitBreakerRuleWithContentBuilder<T> onStatus(HttpStatus... statuses) {\n+        return (CircuitBreakerRuleWithContentBuilder<T>) super.onStatus(statuses);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link CircuitBreakerRuleWithContent}.\n+     * If the response status is one of the specified {@link HttpStatus}es,\n+     * depending on the build methods({@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}),\n+     * a {@link Response} is reported as a success or failure to a {@link CircuitBreaker} or ignored.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public CircuitBreakerRuleWithContentBuilder<T> onStatus(Iterable<HttpStatus> statuses) {\n+        return (CircuitBreakerRuleWithContentBuilder<T>) super.onStatus(statuses);\n+    }\n+\n+    /**\n+     * Adds the specified {@code statusFilter} for a {@link CircuitBreakerRuleWithContent}.\n+     * If the response status matches the specified {@code statusFilter},\n+     * depending on the build methods({@link #thenSuccess()}, {@link #thenFailure()} and {@link #thenIgnore()}),\n+     * a {@link Response} is reported as a success or failure to a {@link CircuitBreaker} or ignored.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public CircuitBreakerRuleWithContentBuilder<T> onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        return (CircuitBreakerRuleWithContentBuilder<T>) super.onStatus(statusFilter);\n+    }\n+\n+    /**\n+     * Adds the specified exception type for a {@link CircuitBreakerRuleWithContent}.\n+     * If an {@link Exception} is raised and that is instance of the specified {@code exception},", "originalCommit": "19dafbda8c277e0d288f518c540bb6d86e82f7fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMzc3Mg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r428413772", "bodyText": "protected?", "author": "trustin", "createdAt": "2020-05-21T02:39:09Z", "path": "core/src/main/java/com/linecorp/armeria/client/AbstractRuleBuilder.java", "diffHunk": "@@ -160,32 +151,39 @@ public AbstractRetryRuleBuilder onException(Predicate<? super Throwable> excepti\n     }\n \n     /**\n-     * Makes a {@link RetryRule} retry on any {@link Exception}.\n+     * Adds any {@link Exception}.\n      */\n-    public AbstractRetryRuleBuilder onException() {\n+    public AbstractRuleBuilder onException() {\n         return onException(unused -> true);\n     }\n \n     /**\n-     * Makes a {@link RetryRule} retry on an {@link UnprocessedRequestException} which means that the request\n-     * has not been processed by the server. Therefore, you can safely retry the request without worrying about\n-     * the idempotency of the request.\n+     * Adds an {@link UnprocessedRequestException}.\n      */\n-    public AbstractRetryRuleBuilder onUnprocessed() {\n+    public AbstractRuleBuilder onUnprocessed() {\n         return onException(UnprocessedRequestException.class);\n     }\n \n-    Predicate<RequestHeaders> requestHeadersFilter() {\n+    /**\n+     * Returns the {@link Predicate} of a {@link RequestHeaders}.\n+     */\n+    public final Predicate<RequestHeaders> requestHeadersFilter() {", "originalCommit": "19dafbda8c277e0d288f518c540bb6d86e82f7fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNzQ3OQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r428417479", "bodyText": "These getters are used in internal.client.AbstractRuleBuilderUtil. \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-05-21T02:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxNzgzNg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r428417836", "bodyText": "Let me refactor it.", "author": "ikhoon", "createdAt": "2020-05-21T02:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMzc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMzgxNw==", "url": "https://github.com/line/armeria/pull/2726#discussion_r428413817", "bodyText": "protected?", "author": "trustin", "createdAt": "2020-05-21T02:39:23Z", "path": "core/src/main/java/com/linecorp/armeria/client/AbstractRuleBuilder.java", "diffHunk": "@@ -160,32 +151,39 @@ public AbstractRetryRuleBuilder onException(Predicate<? super Throwable> excepti\n     }\n \n     /**\n-     * Makes a {@link RetryRule} retry on any {@link Exception}.\n+     * Adds any {@link Exception}.\n      */\n-    public AbstractRetryRuleBuilder onException() {\n+    public AbstractRuleBuilder onException() {\n         return onException(unused -> true);\n     }\n \n     /**\n-     * Makes a {@link RetryRule} retry on an {@link UnprocessedRequestException} which means that the request\n-     * has not been processed by the server. Therefore, you can safely retry the request without worrying about\n-     * the idempotency of the request.\n+     * Adds an {@link UnprocessedRequestException}.\n      */\n-    public AbstractRetryRuleBuilder onUnprocessed() {\n+    public AbstractRuleBuilder onUnprocessed() {\n         return onException(UnprocessedRequestException.class);\n     }\n \n-    Predicate<RequestHeaders> requestHeadersFilter() {\n+    /**\n+     * Returns the {@link Predicate} of a {@link RequestHeaders}.\n+     */\n+    public final Predicate<RequestHeaders> requestHeadersFilter() {\n         return requestHeadersFilter;\n     }\n \n+    /**\n+     * Returns the {@link Predicate} of a {@link ResponseHeaders}.\n+     */\n     @Nullable\n-    Predicate<ResponseHeaders> responseHeadersFilter() {\n+    public final Predicate<ResponseHeaders> responseHeadersFilter() {", "originalCommit": "19dafbda8c277e0d288f518c540bb6d86e82f7fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMzg0OA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r428413848", "bodyText": "protected?", "author": "trustin", "createdAt": "2020-05-21T02:39:28Z", "path": "core/src/main/java/com/linecorp/armeria/client/AbstractRuleBuilder.java", "diffHunk": "@@ -160,32 +151,39 @@ public AbstractRetryRuleBuilder onException(Predicate<? super Throwable> excepti\n     }\n \n     /**\n-     * Makes a {@link RetryRule} retry on any {@link Exception}.\n+     * Adds any {@link Exception}.\n      */\n-    public AbstractRetryRuleBuilder onException() {\n+    public AbstractRuleBuilder onException() {\n         return onException(unused -> true);\n     }\n \n     /**\n-     * Makes a {@link RetryRule} retry on an {@link UnprocessedRequestException} which means that the request\n-     * has not been processed by the server. Therefore, you can safely retry the request without worrying about\n-     * the idempotency of the request.\n+     * Adds an {@link UnprocessedRequestException}.\n      */\n-    public AbstractRetryRuleBuilder onUnprocessed() {\n+    public AbstractRuleBuilder onUnprocessed() {\n         return onException(UnprocessedRequestException.class);\n     }\n \n-    Predicate<RequestHeaders> requestHeadersFilter() {\n+    /**\n+     * Returns the {@link Predicate} of a {@link RequestHeaders}.\n+     */\n+    public final Predicate<RequestHeaders> requestHeadersFilter() {\n         return requestHeadersFilter;\n     }\n \n+    /**\n+     * Returns the {@link Predicate} of a {@link ResponseHeaders}.\n+     */\n     @Nullable\n-    Predicate<ResponseHeaders> responseHeadersFilter() {\n+    public final Predicate<ResponseHeaders> responseHeadersFilter() {\n         return responseHeadersFilter;\n     }\n \n+    /**\n+     * Returns the {@link Predicate} of an {@link Exception}.\n+     */\n     @Nullable\n-    Predicate<Throwable> exceptionFilter() {\n+    public final Predicate<Throwable> exceptionFilter() {", "originalCommit": "19dafbda8c277e0d288f518c540bb6d86e82f7fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQxMzk0NQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r428413945", "bodyText": "protected?", "author": "trustin", "createdAt": "2020-05-21T02:39:48Z", "path": "core/src/main/java/com/linecorp/armeria/client/AbstractRuleWithContentBuilder.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import com.linecorp.armeria.client.circuitbreaker.CircuitBreakerRuleWithContent;\n+import com.linecorp.armeria.client.retry.RetryRuleWithContent;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseDuplicator;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.util.UnstableApi;\n+\n+/**\n+ * A skeletal builder implementation for {@link RetryRuleWithContent} and {@link CircuitBreakerRuleWithContent}.\n+ * @param <T> the response type\n+ */\n+@UnstableApi\n+public abstract class AbstractRuleWithContentBuilder<T extends Response> extends AbstractRuleBuilder {\n+\n+    @Nullable\n+    private Function<? super T, ? extends CompletionStage<Boolean>> responseFilter;\n+\n+    /**\n+     * Creates a new instance with the specified {@code requestHeadersFilter}.\n+     */\n+    protected AbstractRuleWithContentBuilder(Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        super(requestHeadersFilter);\n+    }\n+\n+    /**\n+     * Adds the specified {@code responseFilter}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public AbstractRuleWithContentBuilder<T> onResponse(\n+            Function<? super T, ? extends CompletionStage<Boolean>> responseFilter) {\n+        requireNonNull(responseFilter, \"responseFilter\");\n+\n+        if (this.responseFilter == null) {\n+            this.responseFilter = responseFilter;\n+        } else {\n+            final Function<? super T, ? extends CompletionStage<Boolean>> first = this.responseFilter;\n+            this.responseFilter = content -> {\n+                if (content instanceof HttpResponse) {\n+                    final HttpResponseDuplicator duplicator = ((HttpResponse) content).toDuplicator();\n+                    final CompletionStage<Boolean> result = first.apply((T) duplicator.duplicate());\n+\n+                    return result.thenCompose(matched -> {\n+                        if (matched) {\n+                            return result;\n+                        } else {\n+                            return responseFilter.apply((T) duplicator.duplicate());\n+                        }\n+                    }).whenComplete((unused1, unused2) -> duplicator.close());\n+                } else {\n+                    final CompletionStage<Boolean> result = first.apply(content);\n+                    return result.thenCompose(matched -> {\n+                        if (matched) {\n+                            return result;\n+                        } else {\n+                            return responseFilter.apply(content);\n+                        }\n+                    });\n+                }\n+            };\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the {@code responseFilter}.\n+     */\n+    @Nullable\n+    protected final Function<? super T, ? extends CompletionStage<Boolean>> responseFilter() {", "originalCommit": "19dafbda8c277e0d288f518c540bb6d86e82f7fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bef17296c683031aeb4c133cf18d494f6e140a1a", "url": "https://github.com/line/armeria/commit/bef17296c683031aeb4c133cf18d494f6e140a1a", "message": "Address comments by @trustin", "committedDate": "2020-05-21T03:21:03Z", "type": "commit"}, {"oid": "891e5ff5f995188f85d1c7592838043520bd7fae", "url": "https://github.com/line/armeria/commit/891e5ff5f995188f85d1c7592838043520bd7fae", "message": "--wip-- [skip ci]", "committedDate": "2020-05-21T05:20:07Z", "type": "commit"}, {"oid": "2d39e4f2b6c1f8d46643270e8051138cfc037b8f", "url": "https://github.com/line/armeria/commit/2d39e4f2b6c1f8d46643270e8051138cfc037b8f", "message": "Add `builder(*RuleWithConent, maxContentLength)`", "committedDate": "2020-05-21T06:26:30Z", "type": "commit"}, {"oid": "b2ea22d4854eaff80a37e1ab3899ad0295712660", "url": "https://github.com/line/armeria/commit/b2ea22d4854eaff80a37e1ab3899ad0295712660", "message": "Fix checkstyle", "committedDate": "2020-05-21T06:33:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA0NzM1OA==", "url": "https://github.com/line/armeria/pull/2726#discussion_r429047358", "bodyText": "I think we should guide to use builder(...) not the deprecated one.", "author": "minwoox", "createdAt": "2020-05-22T05:19:33Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryingClientBuilder.java", "diffHunk": "@@ -75,35 +86,54 @@ public RetryingClientBuilder useRetryAfter(boolean useRetryAfter) {\n      * Sets the length of content required to determine whether to retry or not. If the total length of content\n      * exceeds this length and there's no retry condition matched, it will hand over the stream to the client.\n      * Note that this property is useful only if you specified {@link RetryRuleWithContent} when calling\n-     * this builder's constructor. The default value of this property is\n-     * {@value #DEFAULT_CONTENT_PREVIEW_LENGTH}.\n+     * this builder's constructor. The default value of this property is {@value #DEFAULT_MAX_CONTENT_LENGTH}.\n      *\n-     * @param contentPreviewLength the content length to preview. {@code 0} does not disable the length limit.\n+     * @throws IllegalStateException if this builder is created with a {@link RetryRule} rather than\n+     *                               {@link RetryRuleWithContent}\n+     * @throws IllegalArgumentException if the specified {@code maxContentLength} is equal to or\n+     *                                  less than {@code 0}\n      *\n-     * @return {@link RetryingClientBuilder} to support method chaining\n+     * @deprecated Use {@link RetryingClient#builder(RetryRuleWithContent, int)}.\n+     */\n+    @Deprecated\n+    public RetryingClientBuilder maxContentLength(int maxContentLength) {\n+        checkState(!isMaxContentLengthSet, \"maxContentLength is already set by \" +\n+                                           \"RetryingClient.builder(RetryRuleWithContent, maxContentLength)\");\n+        checkState(needsContentInRule, \"cannot set maxContentLength when RetryRule is used; \" +\n+                                       \"Use RetryRuleWithContent to enable this feature.\");\n+        checkArgument(maxContentLength > 0,\n+                      \"maxContentLength: %s (expected: > 0)\", maxContentLength);\n+        this.maxContentLength = maxContentLength;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the length of content required to determine whether to retry or not. If the total length of content\n+     * exceeds this length and there's no retry condition matched, it will hand over the stream to the client.\n+     * Note that this property is useful only if you specified {@link RetryRuleWithContent} when calling\n+     * this builder's constructor. The default value of this property is {@value #DEFAULT_MAX_CONTENT_LENGTH}.\n+     *\n+     * @param contentPreviewLength the content length to preview. {@code 0} does not disable the length limit.\n      *\n      * @throws IllegalStateException if this builder is created with a {@link RetryRule} rather than\n      *                               {@link RetryRuleWithContent}\n-     * @throws IllegalArgumentException if the specified {@code contentPreviewLength} is equal to or\n+     * @throws IllegalArgumentException if the specified {@code maxContentLength} is equal to or\n      *                                  less than {@code 0}\n+     *\n+     * @deprecated Use {@link #maxContentLength(int)}.", "originalCommit": "b2ea22d4854eaff80a37e1ab3899ad0295712660", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA3MzYzMg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r429073632", "bodyText": "Oops, I should remove maxContentLength(int) method.\n// Will use default max content length value\nRetryClient.builder(RetryRuleWithContent);\n// Will use the specified value\nRetryClient.builder(RetryRuleWithContent, maxContentLength); \n\n// Deprecated\nRetryClient.builder(RetryRuleWithContent).contentPreviewLength(maxContentLength);", "author": "ikhoon", "createdAt": "2020-05-22T06:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA0NzM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA0NzM5NQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r429047395", "bodyText": "Then, we can remove this.", "author": "minwoox", "createdAt": "2020-05-22T05:19:45Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryingClientBuilder.java", "diffHunk": "@@ -75,35 +86,54 @@ public RetryingClientBuilder useRetryAfter(boolean useRetryAfter) {\n      * Sets the length of content required to determine whether to retry or not. If the total length of content\n      * exceeds this length and there's no retry condition matched, it will hand over the stream to the client.\n      * Note that this property is useful only if you specified {@link RetryRuleWithContent} when calling\n-     * this builder's constructor. The default value of this property is\n-     * {@value #DEFAULT_CONTENT_PREVIEW_LENGTH}.\n+     * this builder's constructor. The default value of this property is {@value #DEFAULT_MAX_CONTENT_LENGTH}.\n      *\n-     * @param contentPreviewLength the content length to preview. {@code 0} does not disable the length limit.\n+     * @throws IllegalStateException if this builder is created with a {@link RetryRule} rather than\n+     *                               {@link RetryRuleWithContent}\n+     * @throws IllegalArgumentException if the specified {@code maxContentLength} is equal to or\n+     *                                  less than {@code 0}\n      *\n-     * @return {@link RetryingClientBuilder} to support method chaining\n+     * @deprecated Use {@link RetryingClient#builder(RetryRuleWithContent, int)}.\n+     */\n+    @Deprecated\n+    public RetryingClientBuilder maxContentLength(int maxContentLength) {", "originalCommit": "b2ea22d4854eaff80a37e1ab3899ad0295712660", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA0ODQyNg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r429048426", "bodyText": "We can just check !hasResponseFilter or add @Nullable to parmaters.", "author": "minwoox", "createdAt": "2020-05-22T05:24:15Z", "path": "core/src/main/java/com/linecorp/armeria/internal/client/AbstractRuleBuilderUtil.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.client;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+import com.linecorp.armeria.client.AbstractRuleBuilder;\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+public final class AbstractRuleBuilderUtil {\n+\n+    /**\n+     * Merges the filters of {@link AbstractRuleBuilder} that returns {@code true}\n+     * if all rules in the {@link AbstractRuleBuilder} match\n+     * a given {@link ClientRequestContext} and {@link Throwable}.\n+     */\n+    public static BiFunction<? super ClientRequestContext, ? super Throwable, Boolean>\n+    buildFilter(Predicate<RequestHeaders> requestHeadersFilter,\n+                Predicate<ResponseHeaders> responseHeadersFilter,\n+                Predicate<Throwable> exceptionFilter, boolean hasResponseFilter) {\n+        return (ctx, cause) -> {\n+            if (ctx.log().isAvailable(RequestLogProperty.REQUEST_HEADERS)) {\n+                final RequestHeaders requestHeaders = ctx.log().partial().requestHeaders();\n+                if (!requestHeadersFilter.test(requestHeaders)) {\n+                    return false;\n+                }\n+            }\n+\n+            // Safe to return true since no filters are set\n+            if (exceptionFilter == null && responseHeadersFilter == null && !hasResponseFilter) {", "originalCommit": "b2ea22d4854eaff80a37e1ab3899ad0295712660", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA0ODQ2NQ==", "url": "https://github.com/line/armeria/pull/2726#discussion_r429048465", "bodyText": "ditto for exceptionFilter", "author": "minwoox", "createdAt": "2020-05-22T05:24:28Z", "path": "core/src/main/java/com/linecorp/armeria/internal/client/AbstractRuleBuilderUtil.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.client;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+import com.linecorp.armeria.client.AbstractRuleBuilder;\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+public final class AbstractRuleBuilderUtil {\n+\n+    /**\n+     * Merges the filters of {@link AbstractRuleBuilder} that returns {@code true}\n+     * if all rules in the {@link AbstractRuleBuilder} match\n+     * a given {@link ClientRequestContext} and {@link Throwable}.\n+     */\n+    public static BiFunction<? super ClientRequestContext, ? super Throwable, Boolean>\n+    buildFilter(Predicate<RequestHeaders> requestHeadersFilter,\n+                Predicate<ResponseHeaders> responseHeadersFilter,\n+                Predicate<Throwable> exceptionFilter, boolean hasResponseFilter) {\n+        return (ctx, cause) -> {\n+            if (ctx.log().isAvailable(RequestLogProperty.REQUEST_HEADERS)) {\n+                final RequestHeaders requestHeaders = ctx.log().partial().requestHeaders();\n+                if (!requestHeadersFilter.test(requestHeaders)) {\n+                    return false;\n+                }\n+            }\n+\n+            // Safe to return true since no filters are set\n+            if (exceptionFilter == null && responseHeadersFilter == null && !hasResponseFilter) {\n+                return true;\n+            }\n+\n+            if (cause != null && exceptionFilter != null && exceptionFilter.test(Exceptions.peel(cause))) {", "originalCommit": "b2ea22d4854eaff80a37e1ab3899ad0295712660", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA0ODUzMg==", "url": "https://github.com/line/armeria/pull/2726#discussion_r429048532", "bodyText": "ditto for responseHeadersFilter", "author": "minwoox", "createdAt": "2020-05-22T05:24:44Z", "path": "core/src/main/java/com/linecorp/armeria/internal/client/AbstractRuleBuilderUtil.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.client;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+import com.linecorp.armeria.client.AbstractRuleBuilder;\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+public final class AbstractRuleBuilderUtil {\n+\n+    /**\n+     * Merges the filters of {@link AbstractRuleBuilder} that returns {@code true}\n+     * if all rules in the {@link AbstractRuleBuilder} match\n+     * a given {@link ClientRequestContext} and {@link Throwable}.\n+     */\n+    public static BiFunction<? super ClientRequestContext, ? super Throwable, Boolean>\n+    buildFilter(Predicate<RequestHeaders> requestHeadersFilter,\n+                Predicate<ResponseHeaders> responseHeadersFilter,\n+                Predicate<Throwable> exceptionFilter, boolean hasResponseFilter) {\n+        return (ctx, cause) -> {\n+            if (ctx.log().isAvailable(RequestLogProperty.REQUEST_HEADERS)) {\n+                final RequestHeaders requestHeaders = ctx.log().partial().requestHeaders();\n+                if (!requestHeadersFilter.test(requestHeaders)) {\n+                    return false;\n+                }\n+            }\n+\n+            // Safe to return true since no filters are set\n+            if (exceptionFilter == null && responseHeadersFilter == null && !hasResponseFilter) {\n+                return true;\n+            }\n+\n+            if (cause != null && exceptionFilter != null && exceptionFilter.test(Exceptions.peel(cause))) {\n+                return true;\n+            }\n+\n+            if (ctx.log().isAvailable(RequestLogProperty.RESPONSE_HEADERS)) {\n+                final ResponseHeaders responseHeaders = ctx.log().partial().responseHeaders();\n+                if (responseHeadersFilter != null && responseHeadersFilter.test(responseHeaders)) {", "originalCommit": "b2ea22d4854eaff80a37e1ab3899ad0295712660", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e64d375e5c615006b4f2c2d55d96b9ca17677b0a", "url": "https://github.com/line/armeria/commit/e64d375e5c615006b4f2c2d55d96b9ca17677b0a", "message": "Call subscriber.onComplete() when a content overflows", "committedDate": "2020-05-22T06:32:51Z", "type": "commit"}, {"oid": "53026b645944a3ee2d913346cc77d51c1dda9256", "url": "https://github.com/line/armeria/commit/53026b645944a3ee2d913346cc77d51c1dda9256", "message": "Clear contentList after all items is set to null", "committedDate": "2020-05-22T06:36:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA2OTgyNw==", "url": "https://github.com/line/armeria/pull/2726#discussion_r429069827", "bodyText": "If onComplete() is called multiple times, this method throws a null pointer exception at 92 line.\n// All items in contentList was set to null in the previous `onComplete()` call\nfinal HttpData data = contentList.set(i, null); \n// data is null\nfinal int dataLength = data.length();", "author": "ikhoon", "createdAt": "2020-05-22T06:42:09Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpMessageAggregator.java", "diffHunk": "@@ -62,6 +62,10 @@ public final void onError(Throwable t) {\n \n     @Override\n     public final void onComplete() {\n+        if (future.isDone()) {", "originalCommit": "53026b645944a3ee2d913346cc77d51c1dda9256", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1baf464f85ecf093ac2b3d57be5d3592ab380a07", "url": "https://github.com/line/armeria/commit/1baf464f85ecf093ac2b3d57be5d3592ab380a07", "message": "Address comments by @minwoox", "committedDate": "2020-05-22T06:57:14Z", "type": "commit"}]}