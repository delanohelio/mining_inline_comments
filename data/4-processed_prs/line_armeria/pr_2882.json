{"pr_number": 2882, "pr_title": "Revert the `Pooled*` API", "pr_createdAt": "2020-07-07T16:28:13Z", "pr_url": "https://github.com/line/armeria/pull/2882", "timeline": [{"oid": "715e88c769ac5ed30e6af8fd976de94611a61483", "url": "https://github.com/line/armeria/commit/715e88c769ac5ed30e6af8fd976de94611a61483", "message": "Revert the `Pooled*` API\n\nRelated: #2859 #2862 #2863 #2448 #1938 #1936\n\nMotivation:\n\nThe new pooled API introduced in #2448 helped us to hide the API related\nwith pooled Netty `ByteBuf`s so that an advanced user has an access to\nthem only when the user really meant to.\n\nHowever, it introduced a few drawbacks at the same time:\n\n- There's an overhead where a non-pooled `HttpData` must be converted\n  into a `PooledHttpData` when consuming via the pooled API. The current\n  implementation also wraps an existing `StreamMessage` with a\n  `FilteredStreamMessage`, making an extra level of indirection for\n  every element emitted.\n- It is not simple enough to implement `subscribeWithPooledObjects()` or\n  `aggregateWithPooledObjects()` operation optimized for a specific\n  `StreamMessage` implementation.\n\nThe overhead may be reduced to some extent by some optimizations\nmentioned in the previous discussions, but it would take non-trivial\neffort with increased complexity in type hierarchy and implementation.\nI'm not sure we're taking the right balance between user experience and\ndeveloper experience and it sometimes may be confusing even to users.\n\nAlso, given that the advanced users usually look into this feature for\nhigher throughput and less footprint, I'm not sure if it's a good idea\nto introduce extra overhead just for API isolation.\n\nIn hindsight, I should have been more cautious about the potential\noverhead and complexity of the new API before getting excited about it.\nI'm sorry about what's happening in this changeset.\n\nModifications:\n\n- Revert the new pooled API introduced in #2448 except the following:\n  - `PooledHttpData` will not be removed.\n  - The `InputStream` returned by `ByteBufHttpData.toInputStream()` will\n    still not increase the reference count of the underlying buffer.\n- Additional changes:\n  - `ByteBufHttpData`\n    - Not public anymore\n    - Overall clean-up and improvements with a test case\n  - Fixed a bug where `HttpMessageAggregator` generates `HttpData`\n    sometimes with and sometimes without EoS flag.\n  - Workaround for `address already in use` bind errors during ZooKeeper\n    tests\n\nResult:\n\n- Performance is now better, even on a simple unary gRPC benchmark. I\n  expect the improvements will be greater when handling streams without\n  manipulation, e.g. proxy servers.\n  - Before revert (b5289544cc6ef07e35c1349d320d420e27fa726c):\n\n        Benchmark                         (clientType)   Mode  Cnt    Score   Error  Units\n        DownstreamSimpleBenchmark.simple        NORMAL  thrpt  100  950.792 \u00b1 3.792  ops/s\n\n  - After revert (this commit):\n\n        Benchmark                         (clientType)   Mode  Cnt    Score   Error  Units\n        DownstreamSimpleBenchmark.simple        NORMAL  thrpt  100  968.421 \u00b1 3.792  ops/s", "committedDate": "2020-07-07T16:26:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI1OTAxNw==", "url": "https://github.com/line/armeria/pull/2882#discussion_r451259017", "bodyText": "I don't think a user can be guaranteed to have a PooledHttpData even when aggregating with pooled objects if downstream doesn't pool (wrapping into pooled was one of the features of the new API so users don't have to always use instanceof for safety). Are you going to make DefaultHttpData implement PooledHttpData too as a no-op? Otherwise, I think we can remove SafeCloseable and potentially PooledHttpData, it doesn't add anything over ByteBufHolder", "author": "anuraaga", "createdAt": "2020-07-08T03:19:59Z", "path": "core/src/main/java/com/linecorp/armeria/common/unsafe/PooledHttpData.java", "diffHunk": "@@ -38,24 +47,30 @@\n  * you should only use this class in performance-sensitive situations and after being ready to deal with these\n  * very hard-to-debug issues.\n  *\n- * <p>You may interact with {@link PooledHttpData} when using objects that return pooled objects, such as\n- * {@link PooledWebClient}. If you don't use such objects, you will never see a {@link PooledHttpData} and don't\n- * need to read further.\n+ * <p>You may interact with {@link PooledHttpData} when using operations that return pooled objects, such as:\n+ * <ul>\n+ *   <li>{@link StreamMessage#subscribe(Subscriber, SubscriptionOption...)} with\n+ *       {@link SubscriptionOption#WITH_POOLED_OBJECTS}</li>\n+ *   <li>{@link HttpRequest#aggregateWithPooledObjects(ByteBufAllocator)}</li>\n+ *   <li>{@link HttpResponse#aggregateWithPooledObjects(ByteBufAllocator)}</li>\n+ *   <li>{@link HttpFile#aggregateWithPooledObjects(Executor, ByteBufAllocator)}</li>\n+ * </ul>\n+ * If you don't use such operations, you will never see a {@link PooledHttpData} and don't need to read further.\n  *\n  * <h3>Impact of pooled buffers</h3>\n  *\n- * <p>Any time you receive a {@link PooledHttpData} it will have a single reference that must be released -\n- * failure to release the reference will result in a memory leak and poor performance. You must make sure to do\n- * this by calling {@link PooledHttpData#close()}, usually in a try-with-resources structure to avoid side\n- * effects.\n+ * <p>Any time you receive a {@link PooledHttpData} it will have a single reference of {@link ByteBuf} that\n+ * must be released - failure to release the {@link ByteBuf} will result in a memory leak and poor performance.\n+ * You must make sure to do this by calling {@link PooledHttpData#close()}, usually in a try-with-resources\n+ * structure to avoid side effects.\n  *\n  * <p>For example, <pre>{@code\n- * PooledHttpResponse res = PooledHttpResponse.of(client.get(\"/\"));\n+ * HttpResponse res = client.get(\"/\");\n  * res.aggregateWithPooledObjects(ctx.alloc(), ctx.executor())\n  *    .thenApply(aggResp -> {\n  *        // try-with-resources here ensures the content is released\n  *        // if it is a ByteBufHttpData, or otherwise is a no-op if it is not.\n- *        try (PooledHttpData content = aggResp.content()) {\n+ *        try (PooledHttpData content = (PooledHttpData) aggResp.content()) {", "originalCommit": "715e88c769ac5ed30e6af8fd976de94611a61483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk5MzQ1MA==", "url": "https://github.com/line/armeria/pull/2882#discussion_r451993450", "bodyText": "Let me handle this in a follow-up PR I'm working on now.", "author": "trustin", "createdAt": "2020-07-09T06:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI1OTAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI1OTcyMQ==", "url": "https://github.com/line/armeria/pull/2882#discussion_r451259721", "bodyText": "This is the pattern which is annoying currently unless we guarantee msg is always a ByteBufHolder or PooledHttpData, possibly by having non-pooled also implement the interface using no-op / wrapping", "author": "anuraaga", "createdAt": "2020-07-08T03:23:00Z", "path": "grpc-protocol/src/main/java/com/linecorp/armeria/client/grpc/protocol/UnaryGrpcClient.java", "diffHunk": "@@ -127,31 +127,33 @@ private static void checkGrpcStatus(@Nullable String grpcStatus, HttpHeaders hea\n         }\n     }\n \n-    private static final class GrpcFramingDecorator extends SimplePooledDecoratingHttpClient {\n+    private static final class GrpcFramingDecorator extends SimpleDecoratingHttpClient {\n \n         private GrpcFramingDecorator(HttpClient delegate) {\n             super(delegate);\n         }\n \n         @Override\n-        public HttpResponse execute(\n-                PooledHttpClient client, ClientRequestContext ctx, PooledHttpRequest req) {\n+        public HttpResponse execute(ClientRequestContext ctx, HttpRequest req) {\n             return HttpResponse.from(\n                     req.aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc())\n                        .thenCompose(\n                                msg -> {\n-                                   final ByteBuf buf = msg.content().content();\n-                                   final PooledHttpData framed;\n+                                   final ByteBuf buf;\n+                                   if (msg.content() instanceof ByteBufHolder) {", "originalCommit": "715e88c769ac5ed30e6af8fd976de94611a61483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyMzE3Mw==", "url": "https://github.com/line/armeria/pull/2882#discussion_r451423173", "bodyText": "Let me think about this and send a follow up pull request if I find something. Thanks for suggestion.", "author": "trustin", "createdAt": "2020-07-08T09:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI1OTcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzNTU4OQ==", "url": "https://github.com/line/armeria/pull/2882#discussion_r451935589", "bodyText": "How about just using isOne()?", "author": "minwoox", "createdAt": "2020-07-09T02:56:55Z", "path": "core/src/test/java/com/linecorp/armeria/common/unsafe/ByteBufHttpDataTest.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.unsafe;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.common.io.ByteStreams;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+\n+class ByteBufHttpDataTest {\n+\n+    @Test\n+    void empty() {\n+        final ByteBufHttpData data = ByteBufHttpData.EMPTY;\n+        assertThat(data.array()).isEmpty();\n+        assertThat(data.content()).isSameAs(Unpooled.EMPTY_BUFFER);\n+        assertThat(data.isEmpty()).isTrue();\n+        assertThat(data.isEndOfStream()).isFalse();\n+        assertThat(data.withEndOfStream()).isSameAs(ByteBufHttpData.EMPTY_EOS);\n+        assertThat(data.withEndOfStream(false)).isSameAs(data);\n+\n+        for (int i = 0; i < 2; i++) {\n+            // close() should not release anything.\n+            data.close();\n+            assertThat(data.content().refCnt()).isGreaterThan(0);", "originalCommit": "715e88c769ac5ed30e6af8fd976de94611a61483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk5MzY4Nw==", "url": "https://github.com/line/armeria/pull/2882#discussion_r451993687", "bodyText": "Let me handle this in a follow-up PR as well, to avoid a conflict with my working copy. \ud83d\ude09", "author": "trustin", "createdAt": "2020-07-09T06:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzNTU4OQ=="}], "type": "inlineReview"}, {"oid": "ef729d576dfccdac949d29518326f5f434fa6f7f", "url": "https://github.com/line/armeria/commit/ef729d576dfccdac949d29518326f5f434fa6f7f", "message": "Merge branch 'master' into revert_pooled_variants", "committedDate": "2020-07-09T04:34:13Z", "type": "commit"}]}