{"pr_number": 2517, "pr_title": "Do not propagate the first child's `requestCause()` for nested logs", "pr_createdAt": "2020-02-20T11:53:26Z", "pr_url": "https://github.com/line/armeria/pull/2517", "timeline": [{"oid": "cb30fdbe2c7d76c2b0b3ed26f1ec1c5e0a06adae", "url": "https://github.com/line/armeria/commit/cb30fdbe2c7d76c2b0b3ed26f1ec1c5e0a06adae", "message": "Use the last child `RequestLog`'s properties mostly\n\nMotivation:\n\nWith `RetryingClient` involved, a `RequestLog` can have child\n`RequestLog`s. Currently, the parent `RequestLog`'s request-side\nproperties are fetched from the first child, and response-side\nproperties from the last child. See: https://line.github.io/armeria/advanced-structured-logging.html#nested-log\n\nHowever, if the first child request fails with an\n`UnprocessedRequestException` (e.g. due to a connection refused error),\nthe first child's `requestCause()`, which is non-null, is propagated to\nthe parent log. As a result, even if the request eventually succeeded\nthanks to retries, the parent log's `requestCause()` will be non-null,\nmaking `MetricCollectingClient` consider the request as a failure.\n\nModifications:\n\n- Always use `null` as a parent `requestCause()`.\n- Miscellaneous:\n  - Fixed a bug where `DefaultRequestLog.endRequest()` does not set\n    `requestHeaders` properly.\n\nResult:\n\n- `MetricCollectingClient` correctly records the metrics of the request\n  which succeeded after a retry due to a 'connection refused' error.\n- `RequestLog.requestHeaders()` has some headers set even for the\n  requests that failed early, i.e. without writing anything.", "committedDate": "2020-02-20T11:47:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5ODk2Nw==", "url": "https://github.com/line/armeria/pull/2517#discussion_r382398967", "bodyText": "nit: Maybe succeed with 200?", "author": "ikhoon", "createdAt": "2020-02-21T05:03:19Z", "path": "core/src/test/java/com/linecorp/armeria/client/retry/RetryingClientWithMetricsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2017 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.client.metric.MetricCollectingClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.metric.MeterIdPrefixFunction;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.server.AbstractHttpService;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.testing.junit.server.ServerExtension;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.simple.SimpleMeterRegistry;\n+\n+class RetryingClientWithMetricsTest {\n+\n+    private static final MeterIdPrefixFunction meterIdPrefixFunction = MeterIdPrefixFunction.ofDefault(\"foo\");\n+\n+    @RegisterExtension\n+    final ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected boolean runForEachTest() {\n+            return true;\n+        }\n+\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.service(\"/ok\", (ctx, req) -> HttpResponse.of(200));\n+            sb.service(\"/hello\", new AbstractHttpService() {\n+                final AtomicInteger reqCount = new AtomicInteger();\n+\n+                @Override\n+                protected HttpResponse doGet(ServiceRequestContext ctx, HttpRequest req)\n+                        throws Exception {\n+                    ctx.addAdditionalResponseTrailer(HttpHeaderNames.of(\"foo\"), \"bar\");\n+                    if (reqCount.getAndIncrement() < 2) {\n+                        return HttpResponse.of(HttpStatus.INTERNAL_SERVER_ERROR);\n+                    } else {\n+                        return HttpResponse.of(HttpStatus.OK, MediaType.PLAIN_TEXT_UTF_8, \"hello\");\n+                    }\n+                }\n+            });\n+        }\n+    };\n+\n+    private ClientFactory clientFactory;\n+    private MeterRegistry meterRegistry;\n+\n+    @BeforeEach\n+    public void init() {\n+        meterRegistry = new SimpleMeterRegistry();\n+        clientFactory = ClientFactory.builder()\n+                                     .meterRegistry(meterRegistry)\n+                                     .build();\n+    }\n+\n+    @AfterEach\n+    public void destroy() {\n+        if (clientFactory != null) {\n+            clientFactory.closeAsync();\n+        }\n+    }\n+\n+    // WebClient -> RetryingClient -> MetricCollectingClient -> HttpClientDelegate\n+    // In this case, all of the requests and responses are recorded.\n+    @Test\n+    void retryingThenMetricCollecting() throws Exception {\n+        final RetryStrategyWithContent<HttpResponse> retryStrategy =\n+                (ctx, response) -> response.aggregate().handle((msg, cause) -> {\n+                    if (\"hello\".equals(msg.contentUtf8())) {\n+                        return null;\n+                    }\n+                    return Backoff.ofDefault();\n+                });\n+        final WebClient client = WebClient.builder(server.httpUri())\n+                                          .factory(clientFactory)\n+                                          .decorator(MetricCollectingClient.newDecorator(meterIdPrefixFunction))\n+                                          .decorator(RetryingClient.builder(retryStrategy).newDecorator())\n+                                          .build();\n+        assertThat(client.get(\"/hello\").aggregate().join().contentUtf8()).isEqualTo(\"hello\");\n+\n+        // wait until 3 calls are recorded.\n+        await().untilAsserted(() -> {\n+            assertThat(MoreMeters.measureAll(meterRegistry))\n+                    .containsEntry(\"foo.requests#count{http.status=200,method=GET,result=success}\", 1.0)\n+                    .containsEntry(\"foo.requests#count{http.status=200,method=GET,result=failure}\", 0.0)\n+                    .containsEntry(\"foo.requests#count{http.status=500,method=GET,result=success}\", 0.0)\n+                    .containsEntry(\"foo.requests#count{http.status=500,method=GET,result=failure}\", 2.0);\n+        });\n+    }\n+\n+    @Test\n+    void retryingThenMetricCollectingWithConnectionRefused() throws Exception {\n+        // The first request will fail with an UnprocessedException and\n+        // the second request will succeed with 404.", "originalCommit": "cb30fdbe2c7d76c2b0b3ed26f1ec1c5e0a06adae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMTAxNA==", "url": "https://github.com/line/armeria/pull/2517#discussion_r382401014", "bodyText": "Oops! \ud83d\ude05", "author": "trustin", "createdAt": "2020-02-21T05:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5ODk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5OTE0Nw==", "url": "https://github.com/line/armeria/pull/2517#discussion_r382399147", "bodyText": "nit: Maybe succeed with 200?", "author": "ikhoon", "createdAt": "2020-02-21T05:04:04Z", "path": "core/src/test/java/com/linecorp/armeria/client/retry/RetryingClientWithMetricsTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2017 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.client.metric.MetricCollectingClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.metric.MeterIdPrefixFunction;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.server.AbstractHttpService;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.testing.junit.server.ServerExtension;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.simple.SimpleMeterRegistry;\n+\n+class RetryingClientWithMetricsTest {\n+\n+    private static final MeterIdPrefixFunction meterIdPrefixFunction = MeterIdPrefixFunction.ofDefault(\"foo\");\n+\n+    @RegisterExtension\n+    final ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected boolean runForEachTest() {\n+            return true;\n+        }\n+\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.service(\"/ok\", (ctx, req) -> HttpResponse.of(200));\n+            sb.service(\"/hello\", new AbstractHttpService() {\n+                final AtomicInteger reqCount = new AtomicInteger();\n+\n+                @Override\n+                protected HttpResponse doGet(ServiceRequestContext ctx, HttpRequest req)\n+                        throws Exception {\n+                    ctx.addAdditionalResponseTrailer(HttpHeaderNames.of(\"foo\"), \"bar\");\n+                    if (reqCount.getAndIncrement() < 2) {\n+                        return HttpResponse.of(HttpStatus.INTERNAL_SERVER_ERROR);\n+                    } else {\n+                        return HttpResponse.of(HttpStatus.OK, MediaType.PLAIN_TEXT_UTF_8, \"hello\");\n+                    }\n+                }\n+            });\n+        }\n+    };\n+\n+    private ClientFactory clientFactory;\n+    private MeterRegistry meterRegistry;\n+\n+    @BeforeEach\n+    public void init() {\n+        meterRegistry = new SimpleMeterRegistry();\n+        clientFactory = ClientFactory.builder()\n+                                     .meterRegistry(meterRegistry)\n+                                     .build();\n+    }\n+\n+    @AfterEach\n+    public void destroy() {\n+        if (clientFactory != null) {\n+            clientFactory.closeAsync();\n+        }\n+    }\n+\n+    // WebClient -> RetryingClient -> MetricCollectingClient -> HttpClientDelegate\n+    // In this case, all of the requests and responses are recorded.\n+    @Test\n+    void retryingThenMetricCollecting() throws Exception {\n+        final RetryStrategyWithContent<HttpResponse> retryStrategy =\n+                (ctx, response) -> response.aggregate().handle((msg, cause) -> {\n+                    if (\"hello\".equals(msg.contentUtf8())) {\n+                        return null;\n+                    }\n+                    return Backoff.ofDefault();\n+                });\n+        final WebClient client = WebClient.builder(server.httpUri())\n+                                          .factory(clientFactory)\n+                                          .decorator(MetricCollectingClient.newDecorator(meterIdPrefixFunction))\n+                                          .decorator(RetryingClient.builder(retryStrategy).newDecorator())\n+                                          .build();\n+        assertThat(client.get(\"/hello\").aggregate().join().contentUtf8()).isEqualTo(\"hello\");\n+\n+        // wait until 3 calls are recorded.\n+        await().untilAsserted(() -> {\n+            assertThat(MoreMeters.measureAll(meterRegistry))\n+                    .containsEntry(\"foo.requests#count{http.status=200,method=GET,result=success}\", 1.0)\n+                    .containsEntry(\"foo.requests#count{http.status=200,method=GET,result=failure}\", 0.0)\n+                    .containsEntry(\"foo.requests#count{http.status=500,method=GET,result=success}\", 0.0)\n+                    .containsEntry(\"foo.requests#count{http.status=500,method=GET,result=failure}\", 2.0);\n+        });\n+    }\n+\n+    @Test\n+    void retryingThenMetricCollectingWithConnectionRefused() throws Exception {\n+        // The first request will fail with an UnprocessedException and\n+        // the second request will succeed with 404.\n+        final EndpointGroup group = EndpointGroup.of(Endpoint.of(\"127.0.0.1\", 1),\n+                                                     server.httpEndpoint());\n+        final WebClient client = WebClient.builder(SessionProtocol.HTTP, group)\n+                                          .factory(clientFactory)\n+                                          .decorator(MetricCollectingClient.newDecorator(meterIdPrefixFunction))\n+                                          .decorator(RetryingClient.newDecorator(RetryStrategy.onUnprocessed()))\n+                                          .build();\n+        assertThat(client.get(\"/ok\").aggregate().join().status()).isEqualTo(HttpStatus.OK);\n+\n+        // wait until 2 calls are recorded.\n+        await().untilAsserted(() -> {\n+            assertThat(MoreMeters.measureAll(meterRegistry))\n+                    .containsEntry(\"foo.requests#count{http.status=200,method=GET,result=success}\", 1.0)\n+                    .containsEntry(\"foo.requests#count{http.status=200,method=GET,result=failure}\", 0.0)\n+                    .containsEntry(\"foo.requests#count{http.status=0,method=GET,result=success}\", 0.0)\n+                    .containsEntry(\"foo.requests#count{http.status=0,method=GET,result=failure}\", 1.0);\n+        });\n+    }\n+\n+    // WebClient -> MetricCollectingClient -> RetryingClient -> HttpClientDelegate\n+    // In this case, only the first request and the last response are recorded.\n+    @Test\n+    public void metricCollectingThenRetrying() throws Exception {\n+        final WebClient client = WebClient.builder(server.httpUri())\n+                                          .factory(clientFactory)\n+                                          .decorator(RetryingClient.newDecorator(\n+                                                  RetryStrategy.onServerErrorStatus()))\n+                                          .decorator(MetricCollectingClient.newDecorator(meterIdPrefixFunction))\n+                                          .build();\n+        assertThat(client.get(\"/hello\").aggregate().join().contentUtf8()).isEqualTo(\"hello\");\n+\n+        // wait until 1 call is recorded.\n+        await().untilAsserted(() -> {\n+            assertThat(MoreMeters.measureAll(meterRegistry))\n+                    .containsEntry(\"foo.requests#count{http.status=200,method=GET,result=success}\", 1.0)\n+                    .containsEntry(\"foo.requests#count{http.status=200,method=GET,result=failure}\", 0.0);\n+        });\n+    }\n+\n+    @Test\n+    public void metricCollectingThenRetryingWithConnectionRefused() throws Exception {\n+        // The first request will fail with an UnprocessedException and\n+        // the second request will succeed with 404.", "originalCommit": "cb30fdbe2c7d76c2b0b3ed26f1ec1c5e0a06adae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b6888bc2aaf7609a0e93b767c3117b63631b8fe5", "url": "https://github.com/line/armeria/commit/b6888bc2aaf7609a0e93b767c3117b63631b8fe5", "message": "Update RetryingClientWithMetricsTest.java", "committedDate": "2020-02-21T05:14:36Z", "type": "commit"}]}