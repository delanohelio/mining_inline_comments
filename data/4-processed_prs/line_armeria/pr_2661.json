{"pr_number": 2661, "pr_title": "Provide a way to build `RetryRule` and `RetryRuleWithContent`", "pr_createdAt": "2020-04-14T09:09:53Z", "pr_url": "https://github.com/line/armeria/pull/2661", "timeline": [{"oid": "2dd6aac0b7ba909a6af17e961d0cdcf6ebcac816", "url": "https://github.com/line/armeria/commit/2dd6aac0b7ba909a6af17e961d0cdcf6ebcac816", "message": "Provide a way to build `RetryStrategy`\n\nMotivation:\n\nCurrently `RetryStrategy` supports factory methods.\nIf a user wants to make a complex `RetryStrategy`, he/she should implement their own `RetryStrategy`\nBy offering `RetryStrategyBuilder`, users can easily build `RetryStrategy`.\n\nFor example:\n\n```java\nBackoff backoffOn503 = ...;\nBackoff backoffOn500 = ...;\n\n// Before:\nRetryStrategy retryStrategy = RetryStrategy.onStatus((status, unused) -> {\n    if (status == HttpStatus.SERVICE_UNAVAILABLE) {\n        return backoffOn503;\n    }\n    if (status == HttpStatus.INTERNAL_SERVER_ERROR) {\n        return backoffOn500;\n    }\n    return null;\n});\n\n// After:\nRetryStrategy retryStrategy =\n        RetryStrategy.builder()\n                     .onStatus(HttpStatus.SERVICE_UNAVAILABLE, backoffOn503)\n                     .onStatus(HttpStatus.INTERNAL_SERVER_ERROR, backoffOn500)\n                     .build();\n```\n\nOr build a more complex strategy\n```java\nRetryStrategy strategy =\n        RetryStrategy.builder()\n                     .onUnProcessed(unProcessBackOff)\n                     .onException()\n                     .onServerErrorStatus(statusErrorBackOff)\n                     .onStatus(HttpStatus.TOO_MANY_REQUESTS, statusBackOff)\n                     .addRetryStrategy((ctx, cause) -> {\n                         if (ctx.log().isAvailable(RequestLogProperty.RESPONSE_HEADERS)) {\n                             final HttpStatus responseStatus =\n                                     ctx.log().partial().responseHeaders().status();\n                             if (responseStatus.isClientError()) {\n                                 return CompletableFuture.completedFuture(clientErrorBackOff);\n                             }\n                         }\n                         return CompletableFuture.completedFuture(null);\n                     })\n                     .build();\n```\n\nModifications:\n\n- Add `RetryStrategyBuilder` for building `RetrySratategy`.\n- Add `RetryStrategyBindingBuilder` for building `RetryStrategy` fluently.\n- Breaking\n  - `RetryStrategy.onServerErrorStatus()` does not retry anymore when an exception is raised.\n     Use `RetryStrategyBuilder.onServerErrorStatus()` with `RetryStrategyBuilder.onException(...)`\n- Deprecation\n  - `RetryStrategy.onStatus(backoffFunction)` has been deprecated in favor of\n    `RetryStrategyBuilder.onStatus(...)` and `RetryStrategyBuilder.onException(...)`.\n  - `RetryStrategy.onException(backoffFunction)` has been deprecated in favor of\n    `RetryStrategyBuilder.onException(...)`.\n\nResult:\n\n- Fixes #1634\n- You can now easily build `RetryStrategy` using its builder.", "committedDate": "2020-04-14T09:07:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk4NzI0MQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r407987241", "bodyText": "It's not part of the public API no you can just delete it when it becomes unused.", "author": "trustin", "createdAt": "2020-04-14T09:15:43Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/HttpStatusBasedRetryStrategy.java", "diffHunk": "@@ -32,7 +32,10 @@\n /**\n  * Provides a {@link RetryStrategy} that decides to retry the request based on the {@link HttpStatus} of\n  * its response or the {@link Exception} raised while processing the {@link HttpResponse}.\n+ *\n+ * @deprecated Use {@link RetryStrategy#builder()}\n  */\n+@Deprecated", "originalCommit": "2dd6aac0b7ba909a6af17e961d0cdcf6ebcac816", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk4Nzc2Mw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r407987763", "bodyText": "How about:\n\nretaining the old behavior\nand deprecating\n\n..?", "author": "trustin", "createdAt": "2020-04-14T09:16:32Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryStrategy.java", "diffHunk": "@@ -87,35 +98,33 @@ static RetryStrategy onException(Function<? super Throwable, ? extends Backoff>\n \n     /**\n      * Returns a {@link RetryStrategy} that retries with the {@link Backoff#ofDefault()}\n-     * when the response status is 5xx (server error) or an {@link Exception} is raised.\n+     * when the response status is 5xx (server error).\n      */\n     static RetryStrategy onServerErrorStatus() {\n         return onServerErrorStatus(Backoff.ofDefault());\n     }\n \n     /**\n      * Returns the {@link RetryStrategy} that retries the request with the specified {@code backoff}\n-     * when the response status is 5xx (server error) or an {@link Exception} is raised.\n+     * when the response status is 5xx (server error).\n      */\n     static RetryStrategy onServerErrorStatus(Backoff backoff) {", "originalCommit": "2dd6aac0b7ba909a6af17e961d0cdcf6ebcac816", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk4OTE4Mw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r407989183", "bodyText": "How about also adding a variant that accepts Predicate<? super HttpStatus>?", "author": "trustin", "createdAt": "2020-04-14T09:18:42Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryStrategyBindingBuilder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.client.retry.RetryStrategyBuilder.NULL_BACKOFF;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+\n+/**\n+ * A builder class for binding a {@link RetryStrategy} fluently.\n+ */\n+public class RetryStrategyBindingBuilder {\n+\n+    private static final Set<HttpMethod> IDEMPOTENT_METHODS =\n+            ImmutableSet.of(HttpMethod.GET, HttpMethod.HEAD, HttpMethod.PUT, HttpMethod.DELETE);\n+\n+    private final RetryStrategyBuilder retryStrategyBuilder;\n+    private final ImmutableSet.Builder<HttpStatusClass> statusClassesBuilder = ImmutableSet.builder();\n+    private final ImmutableSet.Builder<HttpStatus> statusesBuilder = ImmutableSet.builder();\n+\n+    private Set<HttpMethod> methods = HttpMethod.knownMethods();\n+    private boolean isMethodsSet;\n+\n+    @Nullable\n+    private Predicate<Throwable> exceptionFilter;\n+\n+    RetryStrategyBindingBuilder(RetryStrategyBuilder retryStrategyBuilder) {\n+        this.retryStrategyBuilder = retryStrategyBuilder;\n+    }\n+\n+    /**\n+     * Adds the idempotent HTTP methods for a {@link RetryStrategy} which will retry\n+     * if the request HTTP method is idempotent.\n+     */\n+    public RetryStrategyBindingBuilder idempotentMethods() {\n+        return methods(IDEMPOTENT_METHODS);\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryStrategy} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryStrategyBindingBuilder methods(HttpMethod... methods) {\n+        return methods(ImmutableSet.copyOf(requireNonNull(methods, \"methods\")));\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryStrategy} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryStrategyBindingBuilder methods(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"methods can't be empty\");\n+\n+        if (isMethodsSet) {\n+            Iterables.addAll(this.methods, methods);\n+        } else {\n+            this.methods = Sets.newEnumSet(methods, HttpMethod.class);\n+            isMethodsSet = true;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryStrategy} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryStrategyBindingBuilder onStatusClass(HttpStatusClass... statusClasses) {\n+        return onStatusClass(ImmutableSet.copyOf(requireNonNull(statusClasses, \"statusClasses\")));\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryStrategy} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryStrategyBindingBuilder onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        requireNonNull(statusClasses, \"statusClasses\");\n+        checkArgument(!Iterables.isEmpty(statusClasses), \"statusClasses can't be empty\");\n+\n+        statusClassesBuilder.addAll(statusClasses);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryStrategy} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public RetryStrategyBindingBuilder onStatus(HttpStatus... statuses) {\n+        return onStatus(ImmutableSet.copyOf(requireNonNull(statuses, \"statuses\")));\n+    }", "originalCommit": "2dd6aac0b7ba909a6af17e961d0cdcf6ebcac816", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5NDU2Nw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r407994567", "bodyText": "I think a user will want to specify different backoff for different situation, rather than using a single Backoff.\nHow about using a fluent API like this: (Just a draft)\nRetryStrategy.builder()\n             .on().idempotentMethod()\n                    .then(someBackoff)\n             .on()....then(otherBackoff)\n             .on()....thenStop()\n             .on()....thenImmediately()\n             .build();\nIf no conditions match, could skip retrying.", "author": "trustin", "createdAt": "2020-04-14T09:26:55Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryStrategyBindingBuilder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.linecorp.armeria.client.retry.RetryStrategyBuilder.NULL_BACKOFF;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+\n+/**\n+ * A builder class for binding a {@link RetryStrategy} fluently.\n+ */\n+public class RetryStrategyBindingBuilder {\n+\n+    private static final Set<HttpMethod> IDEMPOTENT_METHODS =\n+            ImmutableSet.of(HttpMethod.GET, HttpMethod.HEAD, HttpMethod.PUT, HttpMethod.DELETE);\n+\n+    private final RetryStrategyBuilder retryStrategyBuilder;\n+    private final ImmutableSet.Builder<HttpStatusClass> statusClassesBuilder = ImmutableSet.builder();\n+    private final ImmutableSet.Builder<HttpStatus> statusesBuilder = ImmutableSet.builder();\n+\n+    private Set<HttpMethod> methods = HttpMethod.knownMethods();\n+    private boolean isMethodsSet;\n+\n+    @Nullable\n+    private Predicate<Throwable> exceptionFilter;\n+\n+    RetryStrategyBindingBuilder(RetryStrategyBuilder retryStrategyBuilder) {\n+        this.retryStrategyBuilder = retryStrategyBuilder;\n+    }\n+\n+    /**\n+     * Adds the idempotent HTTP methods for a {@link RetryStrategy} which will retry\n+     * if the request HTTP method is idempotent.\n+     */\n+    public RetryStrategyBindingBuilder idempotentMethods() {\n+        return methods(IDEMPOTENT_METHODS);\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryStrategy} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryStrategyBindingBuilder methods(HttpMethod... methods) {\n+        return methods(ImmutableSet.copyOf(requireNonNull(methods, \"methods\")));\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryStrategy} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryStrategyBindingBuilder methods(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"methods can't be empty\");\n+\n+        if (isMethodsSet) {\n+            Iterables.addAll(this.methods, methods);\n+        } else {\n+            this.methods = Sets.newEnumSet(methods, HttpMethod.class);\n+            isMethodsSet = true;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryStrategy} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryStrategyBindingBuilder onStatusClass(HttpStatusClass... statusClasses) {\n+        return onStatusClass(ImmutableSet.copyOf(requireNonNull(statusClasses, \"statusClasses\")));\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryStrategy} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryStrategyBindingBuilder onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        requireNonNull(statusClasses, \"statusClasses\");\n+        checkArgument(!Iterables.isEmpty(statusClasses), \"statusClasses can't be empty\");\n+\n+        statusClassesBuilder.addAll(statusClasses);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryStrategy} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public RetryStrategyBindingBuilder onStatus(HttpStatus... statuses) {\n+        return onStatus(ImmutableSet.copyOf(requireNonNull(statuses, \"statuses\")));\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryStrategy} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public RetryStrategyBindingBuilder onStatus(Iterable<HttpStatus> statuses) {\n+        requireNonNull(statuses, \"statuses\");\n+        checkArgument(!Iterables.isEmpty(statuses), \"statuses can't be empty\");\n+\n+        statusesBuilder.addAll(statuses);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified exception type for a {@link RetryStrategy} which will retry\n+     * if an {@link Exception} is raised and that is instance of the specified {@code exception}.\n+     */\n+    public RetryStrategyBindingBuilder onException(Class<? extends Throwable> exception) {\n+        requireNonNull(exception, \"exception\");\n+        return onException(exception::isInstance);\n+    }\n+\n+    /**\n+     * Adds the specified {@code exceptionFilter} for a {@link RetryStrategy} which will retry\n+     * if an {@link Exception} is raised and the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    public RetryStrategyBindingBuilder onException(Predicate<? super Throwable> exceptionFilter) {\n+        requireNonNull(exceptionFilter, \"exceptionFilter\");\n+        if (this.exceptionFilter != null) {\n+            this.exceptionFilter = this.exceptionFilter.or(exceptionFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<Throwable> cast = (Predicate<Throwable>) exceptionFilter;\n+            this.exceptionFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link Backoff} and returns the {@link RetryStrategyBuilder} that this\n+     * {@link RetryStrategyBindingBuilder} was created from.\n+     *\n+     * @throws IllegalStateException if none of {@link HttpStatus}, {@link HttpStatusClass} or\n+     *                               an expected {@code exception} type is specified\n+     */\n+    public RetryStrategyBuilder build(Backoff backoff) {", "originalCommit": "2dd6aac0b7ba909a6af17e961d0cdcf6ebcac816", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU2MTU4NA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r408561584", "bodyText": "I think a user will want to specify different backoff for different situation\n\nOh. That sounds good. Let me improve the API \ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-04-15T03:37:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5NDU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwNTA5MQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r408605091", "bodyText": "Or could accept a customizer?\nRetryStrategy.builder()\n             .on(retryOnError ->\n                 retryOnError.idempotentMethods()\n                             .exception(ResponseTimeoutException.class)\n                             .then(Backoff))\n             .on(noRetry -> \n                 noRetry.status(HttpStatus.BAD_REQUEST)\n                        .thenStop())\n             .on(retryOnStatus ->\n                 retryOnStatus.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                              .exception(ex -> ex instanceof ClosedSessionException)\n                              .method(HttpMethod.GET)\n                              .thenNoDelay())\n             .build()", "author": "ikhoon", "createdAt": "2020-04-15T06:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5NDU2Nw=="}], "type": "inlineReview"}, {"oid": "e900f963538b76d1092e995b59c105861fdcf16d", "url": "https://github.com/line/armeria/commit/e900f963538b76d1092e995b59c105861fdcf16d", "message": "Address comments by @trustin / Redesign fluent builder", "committedDate": "2020-04-21T01:39:45Z", "type": "commit"}, {"oid": "fc62befb0ac652301bb78cf6b32747d46ba379c5", "url": "https://github.com/line/armeria/commit/fc62befb0ac652301bb78cf6b32747d46ba379c5", "message": "Add onState with filter to RetryStrategyBuilder", "committedDate": "2020-04-21T02:15:22Z", "type": "commit"}, {"oid": "3e7d0ea0270d9023212ef5d02a0b2a2642446cc0", "url": "https://github.com/line/armeria/commit/3e7d0ea0270d9023212ef5d02a0b2a2642446cc0", "message": "Address comments by @trustin, @anuraaga / Add RetryRule", "committedDate": "2020-04-22T11:01:55Z", "type": "commit"}, {"oid": "ed5046cbcea379b8ab5c2950e695ff1243aff05f", "url": "https://github.com/line/armeria/commit/ed5046cbcea379b8ab5c2950e695ff1243aff05f", "message": "Update Javadoc", "committedDate": "2020-04-22T11:33:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2NTYyOQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414265629", "bodyText": "unProcessed -> unprocessed everywhere", "author": "trustin", "createdAt": "2020-04-24T03:30:05Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+\n+/**\n+ * A rule for {@link RetryStrategy}.\n+ */\n+public final class RetryRule {\n+\n+    /**\n+     * Adds the idempotent HTTP methods for a {@link RetryStrategy} which will retry\n+     * if the request HTTP method is idempotent.\n+     */\n+    public static RetryRuleBuilder onIdempotentMethods() {\n+        return newRuleBuilder().onIdempotentMethods();\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryStrategy} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public static RetryRuleBuilder onMethods(HttpMethod... methods) {\n+        return newRuleBuilder().onMethods(methods);\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryStrategy} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public static RetryRuleBuilder onMethods(Iterable<HttpMethod> methods) {\n+        return newRuleBuilder().onMethods(methods);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryStrategy} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public static RetryRuleBuilder onStatusClass(HttpStatusClass... statusClasses) {\n+        return newRuleBuilder().onStatusClass(statusClasses);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryStrategy} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public static RetryRuleBuilder onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        return newRuleBuilder().onStatusClass(statusClasses);\n+    }\n+\n+    /**\n+     * Adds the {@link HttpStatusClass#SERVER_ERROR} for a {@link RetryStrategy} which will retry\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    public static RetryRuleBuilder onServerErrorStatus() {\n+        return newRuleBuilder().onServerErrorStatus();\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryStrategy} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public static RetryRuleBuilder onStatus(HttpStatus... statuses) {\n+        return newRuleBuilder().onStatus(statuses);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryStrategy} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public static RetryRuleBuilder onStatus(Iterable<HttpStatus> statuses) {\n+        return newRuleBuilder().onStatus(statuses);\n+    }\n+\n+    /**\n+     * Adds the specified {@code statusFilter} for a {@link RetryStrategy} which will retry\n+     * if the response status matches the specified {@code statusFilter}.\n+     */\n+    public static RetryRuleBuilder onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        return newRuleBuilder().onStatus(statusFilter);\n+    }\n+\n+    /**\n+     * Adds the specified exception type for a {@link RetryStrategy} which will retry\n+     * if an {@link Exception} is raised and that is instance of the specified {@code exception}.\n+     */\n+    public static RetryRuleBuilder onException(Class<? extends Throwable> exception) {\n+        return newRuleBuilder().onException(exception);\n+    }\n+\n+    /**\n+     * Adds the specified {@code exceptionFilter} for a {@link RetryStrategy} which will retry\n+     * if an {@link Exception} is raised and the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    public static RetryRuleBuilder onException(Predicate<? super Throwable> exceptionFilter) {\n+        return newRuleBuilder().onException(exceptionFilter);\n+    }\n+\n+    /**\n+     * Makes a {@link RetryStrategy} retry on any {@link Exception}.\n+     */\n+    public static RetryRuleBuilder onException() {\n+        return newRuleBuilder().onException();\n+    }\n+\n+    /**\n+     * Makes a {@link RetryStrategy} retry on an {@link UnprocessedRequestException}.\n+     */\n+    public static RetryRuleBuilder onUnProcessed() {", "originalCommit": "ed5046cbcea379b8ab5c2950e695ff1243aff05f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3MDAyMw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414270023", "bodyText": "Oops... \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-04-24T03:44:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2NTYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2NTgxNQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414265815", "bodyText": "Could you add a test case that ensures the static methods in this class and member methods in RetryRuleBuilder are same, using reflection?", "author": "trustin", "createdAt": "2020-04-24T03:30:43Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+\n+/**\n+ * A rule for {@link RetryStrategy}.\n+ */\n+public final class RetryRule {", "originalCommit": "ed5046cbcea379b8ab5c2950e695ff1243aff05f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2OTg2MA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414269860", "bodyText": "Oh, nice idea. \ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-04-24T03:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2NTgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2NjIwMA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414266200", "bodyText": "How about just thenBackoff()?", "author": "trustin", "createdAt": "2020-04-24T03:31:44Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleBuilder.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+\n+/**\n+ * A builder which creates a {@link RetryRule} used for building {@link RetryStrategy}.\n+ *\n+ * @see RetryStrategyBuilder#on(RetryRule)\n+ */\n+public final class RetryRuleBuilder extends AbstractRetryStrategyBindingBuilder {\n+\n+    private static final Backoff NO_RETRY = numAttemptsSoFar -> -1;\n+\n+    private static final Set<HttpMethod> IDEMPOTENT_METHODS =\n+            ImmutableSet.of(HttpMethod.GET, HttpMethod.HEAD, HttpMethod.PUT, HttpMethod.DELETE);\n+\n+    private final ImmutableSet.Builder<HttpStatusClass> statusClassesBuilder = ImmutableSet.builder();\n+    private final ImmutableSet.Builder<HttpStatus> statusesBuilder = ImmutableSet.builder();\n+\n+    private Set<HttpMethod> methods = HttpMethod.knownMethods();\n+    private boolean isMethodsSet;\n+\n+    @Nullable\n+    private Predicate<HttpStatus> statusFilter;\n+    @Nullable\n+    private Predicate<Throwable> exceptionFilter;\n+\n+    @Override\n+    public RetryRuleBuilder onIdempotentMethods() {\n+        return onMethods(IDEMPOTENT_METHODS);\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onMethods(HttpMethod... methods) {\n+        return onMethods(ImmutableSet.copyOf(requireNonNull(methods, \"methods\")));\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onMethods(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"methods can't be empty\");\n+\n+        if (isMethodsSet) {\n+            Iterables.addAll(this.methods, methods);\n+        } else {\n+            this.methods = Sets.newEnumSet(methods, HttpMethod.class);\n+            isMethodsSet = true;\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onStatusClass(HttpStatusClass... statusClasses) {\n+        return onStatusClass(ImmutableSet.copyOf(requireNonNull(statusClasses, \"statusClasses\")));\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        requireNonNull(statusClasses, \"statusClasses\");\n+        checkArgument(!Iterables.isEmpty(statusClasses), \"statusClasses can't be empty\");\n+\n+        statusClassesBuilder.addAll(statusClasses);\n+        return this;\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onServerErrorStatus() {\n+        return onStatusClass(HttpStatusClass.SERVER_ERROR);\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onStatus(HttpStatus... statuses) {\n+        return onStatus(ImmutableSet.copyOf(requireNonNull(statuses, \"statuses\")));\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onStatus(Iterable<HttpStatus> statuses) {\n+        requireNonNull(statuses, \"statuses\");\n+        checkArgument(!Iterables.isEmpty(statuses), \"statuses can't be empty\");\n+\n+        statusesBuilder.addAll(statuses);\n+        return this;\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        requireNonNull(statusFilter, \"statuses\");\n+        if (this.statusFilter != null) {\n+            this.statusFilter = this.statusFilter.or(statusFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<HttpStatus> cast = (Predicate<HttpStatus>) statusFilter;\n+            this.statusFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onException(Class<? extends Throwable> exception) {\n+        requireNonNull(exception, \"exception\");\n+        return onException(exception::isInstance);\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onException(Predicate<? super Throwable> exceptionFilter) {\n+        requireNonNull(exceptionFilter, \"exceptionFilter\");\n+        if (this.exceptionFilter != null) {\n+            this.exceptionFilter = this.exceptionFilter.or(exceptionFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<Throwable> cast = (Predicate<Throwable>) exceptionFilter;\n+            this.exceptionFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onException() {\n+        return onException(unused -> true);\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onUnProcessed() {\n+        return onException(UnprocessedRequestException.class);\n+    }\n+\n+    /**\n+     * Sets the {@linkplain Backoff#ofDefault() default backoff} and returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenDefaultBackoff() {", "originalCommit": "ed5046cbcea379b8ab5c2950e695ff1243aff05f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2NjQzNg==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414266436", "bodyText": "toString()?", "author": "trustin", "createdAt": "2020-04-24T03:32:37Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleBuilder.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+\n+/**\n+ * A builder which creates a {@link RetryRule} used for building {@link RetryStrategy}.\n+ *\n+ * @see RetryStrategyBuilder#on(RetryRule)\n+ */\n+public final class RetryRuleBuilder extends AbstractRetryStrategyBindingBuilder {\n+\n+    private static final Backoff NO_RETRY = numAttemptsSoFar -> -1;\n+\n+    private static final Set<HttpMethod> IDEMPOTENT_METHODS =\n+            ImmutableSet.of(HttpMethod.GET, HttpMethod.HEAD, HttpMethod.PUT, HttpMethod.DELETE);\n+\n+    private final ImmutableSet.Builder<HttpStatusClass> statusClassesBuilder = ImmutableSet.builder();\n+    private final ImmutableSet.Builder<HttpStatus> statusesBuilder = ImmutableSet.builder();\n+\n+    private Set<HttpMethod> methods = HttpMethod.knownMethods();\n+    private boolean isMethodsSet;\n+\n+    @Nullable\n+    private Predicate<HttpStatus> statusFilter;\n+    @Nullable\n+    private Predicate<Throwable> exceptionFilter;\n+\n+    @Override\n+    public RetryRuleBuilder onIdempotentMethods() {\n+        return onMethods(IDEMPOTENT_METHODS);\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onMethods(HttpMethod... methods) {\n+        return onMethods(ImmutableSet.copyOf(requireNonNull(methods, \"methods\")));\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onMethods(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"methods can't be empty\");\n+\n+        if (isMethodsSet) {\n+            Iterables.addAll(this.methods, methods);\n+        } else {\n+            this.methods = Sets.newEnumSet(methods, HttpMethod.class);\n+            isMethodsSet = true;\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onStatusClass(HttpStatusClass... statusClasses) {\n+        return onStatusClass(ImmutableSet.copyOf(requireNonNull(statusClasses, \"statusClasses\")));\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        requireNonNull(statusClasses, \"statusClasses\");\n+        checkArgument(!Iterables.isEmpty(statusClasses), \"statusClasses can't be empty\");\n+\n+        statusClassesBuilder.addAll(statusClasses);\n+        return this;\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onServerErrorStatus() {\n+        return onStatusClass(HttpStatusClass.SERVER_ERROR);\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onStatus(HttpStatus... statuses) {\n+        return onStatus(ImmutableSet.copyOf(requireNonNull(statuses, \"statuses\")));\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onStatus(Iterable<HttpStatus> statuses) {\n+        requireNonNull(statuses, \"statuses\");\n+        checkArgument(!Iterables.isEmpty(statuses), \"statuses can't be empty\");\n+\n+        statusesBuilder.addAll(statuses);\n+        return this;\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        requireNonNull(statusFilter, \"statuses\");\n+        if (this.statusFilter != null) {\n+            this.statusFilter = this.statusFilter.or(statusFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<HttpStatus> cast = (Predicate<HttpStatus>) statusFilter;\n+            this.statusFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onException(Class<? extends Throwable> exception) {\n+        requireNonNull(exception, \"exception\");\n+        return onException(exception::isInstance);\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onException(Predicate<? super Throwable> exceptionFilter) {\n+        requireNonNull(exceptionFilter, \"exceptionFilter\");\n+        if (this.exceptionFilter != null) {\n+            this.exceptionFilter = this.exceptionFilter.or(exceptionFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<Throwable> cast = (Predicate<Throwable>) exceptionFilter;\n+            this.exceptionFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onException() {\n+        return onException(unused -> true);\n+    }\n+\n+    @Override\n+    public RetryRuleBuilder onUnProcessed() {\n+        return onException(UnprocessedRequestException.class);\n+    }\n+\n+    /**\n+     * Sets the {@linkplain Backoff#ofDefault() default backoff} and returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenDefaultBackoff() {\n+        return thenBackoff(Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Sets the specified {@link Backoff} and returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenBackoff(Backoff backoff) {\n+        requireNonNull(backoff, \"backoff\");\n+        return build(backoff);\n+    }\n+\n+    /**\n+     * Sets a {@link Backoff} which limits the number of attempts up to the specified value and\n+     * never waits between attempts. Returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenImmediately(int maxAttempts) {\n+        checkArgument(maxAttempts > 0, \"maxAttempts: %s (expected: > 0)\", maxAttempts);\n+        final Backoff backOff = Backoff.withoutDelay().withMaxAttempts(maxAttempts);\n+        return build(backOff);\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that never retries.\n+     */\n+    public RetryRule thenStop() {\n+        return build(NO_RETRY);\n+    }\n+\n+    private RetryRule build(Backoff backoff) {\n+        final Set<HttpMethod> methods = Sets.immutableEnumSet(this.methods);\n+        final Set<HttpStatusClass> statusClasses = Sets.immutableEnumSet(statusClassesBuilder.build());\n+        final Set<HttpStatus> statuses = statusesBuilder.build();\n+        final Predicate<HttpStatus> statusFilter = this.statusFilter;\n+        final Predicate<Throwable> exceptionFilter = this.exceptionFilter;\n+\n+        if (backoff != NO_RETRY && exceptionFilter == null && statusFilter == null &&\n+            statuses.isEmpty() && statusClasses.isEmpty()) {\n+            throw new IllegalStateException(\n+                    \"Should set at least one of status, status class and an expected exception type \" +\n+                    \"if a backoff was set.\");\n+        }\n+\n+        return new RetryRule(methods, statusClasses, statuses, backoff, statusFilter, exceptionFilter);\n+    }\n+}", "originalCommit": "ed5046cbcea379b8ab5c2950e695ff1243aff05f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2NzM1Mg==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414267352", "bodyText": "For simplicity, how about:\n\nRemoving the on*() methods in this class\n\nWe will be able to merge AbstractRetryStretegyBindingBuilder into RetryRuleBuilder.\n\n\nRenaming this method to something like rule()\n\n..?", "author": "trustin", "createdAt": "2020-04-24T03:35:37Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * A builder which creates a {@link RetryStrategy}.\n+ */\n+public final class RetryStrategyBuilder extends AbstractRetryStrategyBindingBuilder {\n+\n+    private static final CompletableFuture<Backoff> NULL_BACKOFF = CompletableFuture.completedFuture(null);\n+    private static final RetryStrategy[] EMPTY_RETRY_STRATEGIES = new RetryStrategy[0];\n+\n+    private final ImmutableList.Builder<RetryStrategy> retryStrategiesBuilder = ImmutableList.builder();\n+\n+    RetryStrategyBuilder() {}\n+\n+    @Override\n+    public RetryStrategyBindingBuilder onIdempotentMethods() {\n+        return newBindingBuilder().onIdempotentMethods();\n+    }\n+\n+    @Override\n+    public RetryStrategyBindingBuilder onMethods(HttpMethod... methods) {\n+        return newBindingBuilder().onMethods(methods);\n+    }\n+\n+    @Override\n+    public RetryStrategyBindingBuilder onMethods(Iterable<HttpMethod> methods) {\n+        return newBindingBuilder().onMethods(methods);\n+    }\n+\n+    @Override\n+    public RetryStrategyBindingBuilder onStatusClass(HttpStatusClass... statusClasses) {\n+        return newBindingBuilder().onStatusClass(statusClasses);\n+    }\n+\n+    @Override\n+    public RetryStrategyBindingBuilder onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        return newBindingBuilder().onStatusClass(statusClasses);\n+    }\n+\n+    @Override\n+    public RetryStrategyBindingBuilder onServerErrorStatus() {\n+        return newBindingBuilder().onServerErrorStatus();\n+    }\n+\n+    @Override\n+    public RetryStrategyBindingBuilder onStatus(HttpStatus... statuses) {\n+        return newBindingBuilder().onStatus(statuses);\n+    }\n+\n+    @Override\n+    public RetryStrategyBindingBuilder onStatus(Iterable<HttpStatus> statuses) {\n+        return newBindingBuilder().onStatus(statuses);\n+    }\n+\n+    @Override\n+    public RetryStrategyBindingBuilder onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        return newBindingBuilder().onStatus(statusFilter);\n+    }\n+\n+    @Override\n+    public RetryStrategyBindingBuilder onException(Class<? extends Throwable> exception) {\n+        return newBindingBuilder().onException(exception);\n+    }\n+\n+    @Override\n+    public RetryStrategyBindingBuilder onException(Predicate<? super Throwable> exceptionFilter) {\n+        return newBindingBuilder().onException(exceptionFilter);\n+    }\n+\n+    @Override\n+    public RetryStrategyBindingBuilder onException() {\n+        return newBindingBuilder().onException();\n+    }\n+\n+    @Override\n+    public RetryStrategyBindingBuilder onUnProcessed() {\n+        return newBindingBuilder().onUnProcessed();\n+    }\n+\n+    /**\n+     * Adds a {@link RetryStrategy}.\n+     */\n+    public RetryStrategyBuilder add(RetryStrategy retryStrategy) {\n+        retryStrategiesBuilder.add(requireNonNull(retryStrategy, \"retryStrategy\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a {@link RetryRule}.\n+     *\n+     * <p><pre>{@code\n+     * RetryStrategy.builder()\n+     *              .on(RetryRule.onStatus(HttpStatus.SERVICE_UNAVAILABLE)\n+     *                           .onException(ex -> ex instanceof ClosedSessionException)\n+     *                           .onMethod(HttpMethod.GET)\n+     *                           .thenBackOff(myBackoff))\n+     *              .build();\n+     * }</pre>\n+     */\n+    RetryStrategyBuilder on(RetryRule retryRule) {\n+        return add(build(requireNonNull(retryRule, \"retryRule\")));\n+    }", "originalCommit": "ed5046cbcea379b8ab5c2950e695ff1243aff05f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM3NTQyOA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414375428", "bodyText": "That's good. I removed and simplified a lot.", "author": "ikhoon", "createdAt": "2020-04-24T07:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2NzM1Mg=="}], "type": "inlineReview"}, {"oid": "464af3c6f7c8ede7b3e1dfdf12f54a7f2d09dd0b", "url": "https://github.com/line/armeria/commit/464af3c6f7c8ede7b3e1dfdf12f54a7f2d09dd0b", "message": "Address comments by @trustin / Remove AbstractRetryStrategyBindingBuilder and RetryStrategyBindingBuilder", "committedDate": "2020-04-24T07:36:11Z", "type": "commit"}, {"oid": "54c844b45280fde31947a080daa10a1ce963e20c", "url": "https://github.com/line/armeria/commit/54c844b45280fde31947a080daa10a1ce963e20c", "message": "Update documentation", "committedDate": "2020-04-24T07:50:57Z", "type": "commit"}, {"oid": "f01618fc01d318fdba40e155deade9e32f3f32ec", "url": "https://github.com/line/armeria/commit/f01618fc01d318fdba40e155deade9e32f3f32ec", "message": "Address comments by @minwoox", "committedDate": "2020-04-24T08:14:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5OTA4NQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414399085", "bodyText": "Two code blocks \ud83d\ude04", "author": "minwoox", "createdAt": "2020-04-24T08:38:12Z", "path": "site/src/sphinx/client-retry.rst", "diffHunk": "@@ -46,15 +46,30 @@ an exception is raised.\n ``RetryStrategy``\n -----------------\n \n-You can customize the ``strategy`` by implementing :api:`RetryStrategy`.\n+You can fluently build your own :api:`RetryStrategy`.\n+\n+.. code-block:: java\n \n .. code-block:: java", "originalCommit": "f01618fc01d318fdba40e155deade9e32f3f32ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI4OTI2OA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416289268", "bodyText": "Oops \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-04-28T02:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5OTA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMTg1NA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414401854", "bodyText": "How about changing ClosedSessionException to UnprocessedRequestException because a user could use this example imprudently, and come across the idempotent issue?", "author": "minwoox", "createdAt": "2020-04-24T08:42:19Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryStrategy.java", "diffHunk": "@@ -59,22 +67,33 @@ static RetryStrategy onUnprocessed() {\n      */\n     static RetryStrategy onUnprocessed(Backoff backoff) {\n         requireNonNull(backoff, \"backoff\");\n-        return onException(cause -> cause instanceof UnprocessedRequestException ? backoff : null);\n+        return builder().rule(RetryRule.onUnprocessed().thenBackoff(backoff)).build();\n     }\n \n     /**\n      * Returns a {@link RetryStrategy} that retries with {@link Backoff#ofDefault()} on any {@link Exception}.\n      */\n     static RetryStrategy onException() {\n-        return onException(cause -> Backoff.ofDefault());\n+        return builder().rule(RetryRule.onException().thenBackoff()).build();\n     }\n \n     /**\n      * Returns a {@link RetryStrategy} that decides to retry using the specified {@code backoffFunction}.\n      *\n      * @param backoffFunction A {@link Function} that returns the {@link Backoff} or {@code null} (no retry)\n      *                        according to the given {@link Throwable}\n+     *\n+     * @deprecated Use {@link #builder()} with {@link RetryStrategyBuilder#rule(RetryRule)}\n+     *             and {@link RetryRuleBuilder#onException(Predicate)}}.\n+     *             For example:\n+     *             <pre>{@code\n+     *             RetryStrategy.builder()\n+     *                          .rule(RetryRule.onException(ex -> ex instanceof ClosedSessionException)", "originalCommit": "f01618fc01d318fdba40e155deade9e32f3f32ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMjg2MQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414402861", "bodyText": "It's not related to this PR but how about adding a warning to the Javadoc about idempotent with the link?", "author": "minwoox", "createdAt": "2020-04-24T08:43:49Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryStrategy.java", "diffHunk": "@@ -59,22 +67,33 @@ static RetryStrategy onUnprocessed() {\n      */\n     static RetryStrategy onUnprocessed(Backoff backoff) {\n         requireNonNull(backoff, \"backoff\");\n-        return onException(cause -> cause instanceof UnprocessedRequestException ? backoff : null);\n+        return builder().rule(RetryRule.onUnprocessed().thenBackoff(backoff)).build();\n     }\n \n     /**\n      * Returns a {@link RetryStrategy} that retries with {@link Backoff#ofDefault()} on any {@link Exception}.\n      */\n     static RetryStrategy onException() {", "originalCommit": "f01618fc01d318fdba40e155deade9e32f3f32ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI4MzA0NQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416283045", "bodyText": "Now, this interface is deprecated. Let me add the idempotent link to RetryRule.\ud83d\ude00", "author": "ikhoon", "createdAt": "2020-04-28T02:36:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMjg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQxNjc5OA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414416798", "bodyText": "I think this will not work because:\n\nthe customized strategy cannot return NULL_BACKOFF\nthe second strategy might return valid backoff meanwhile the first strategy completes the future with null\nHow about using allOf?\n\nfinal List<RetryStrategy> retryStrategies = retryStrategiesBuilder.build();\ncheckState(!retryStrategies.isEmpty(), \"at least one retry strategy should be set\");\n\nif (retryStrategies.size() == 1) {\n    return retryStrategies.get(0);\n}\n\nreturn (ctx, cause) -> {\n    final List<CompletionStage<Backoff>> futures = new ArrayList<>(retryStrategies.size());\n    final CompletableFuture<Void> allOfFuture = CompletableFuture.allOf(\n            retryStrategies.stream()\n                           .map(retryStrategy -> {\n                               final CompletionStage<Backoff> future =\n                                       retryStrategy.shouldRetry(ctx, cause);\n                               futures.add(future);\n                               return future;\n                           })\n                           .toArray(CompletableFuture[]::new));\n    return allOfFuture.handle((unused, unused1) -> {\n        for (CompletionStage<Backoff> future : futures) {\n            // Perhaps is it time to change the return type of shouldRetry to CompletableFuture?\n            final Backoff backoff = future.toCompletableFuture().join();\n            if (backoff != null) {\n                return backoff;\n            }\n        }\n        return null;\n    });\n};", "author": "minwoox", "createdAt": "2020-04-24T09:05:13Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * A builder which creates a {@link RetryStrategy}.\n+ */\n+public final class RetryStrategyBuilder {\n+\n+    private static final CompletableFuture<Backoff> NULL_BACKOFF = CompletableFuture.completedFuture(null);\n+    private static final RetryStrategy[] EMPTY_RETRY_STRATEGIES = new RetryStrategy[0];\n+\n+    private final ImmutableList.Builder<RetryStrategy> retryStrategiesBuilder = ImmutableList.builder();\n+\n+    RetryStrategyBuilder() {}\n+\n+    /**\n+     * Adds a {@link RetryStrategy}.\n+     */\n+    public RetryStrategyBuilder add(RetryStrategy retryStrategy) {\n+        retryStrategiesBuilder.add(requireNonNull(retryStrategy, \"retryStrategy\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a {@link RetryRule}.\n+     *\n+     * <p><pre>{@code\n+     * RetryStrategy.builder()\n+     *              .rule(RetryRule.onStatus(HttpStatus.SERVICE_UNAVAILABLE)\n+     *                             .onException(ex -> ex instanceof ClosedSessionException)\n+     *                             .onMethod(HttpMethod.GET)\n+     *                             .thenBackOff(myBackoff))\n+     *              .build();\n+     * }</pre>\n+     */\n+    public RetryStrategyBuilder rule(RetryRule retryRule) {\n+        return add(build(requireNonNull(retryRule, \"retryRule\")));\n+    }\n+\n+    /**\n+     * Returns a newly-created {@link RetryStrategy} based on the strategies set so far.\n+     */\n+    public RetryStrategy build() {\n+        final RetryStrategy[] retryStrategies = retryStrategiesBuilder.build().toArray(EMPTY_RETRY_STRATEGIES);\n+        checkState(retryStrategies.length > 0, \"at least one retry strategy should be set\");\n+\n+        if (retryStrategies.length == 1) {\n+            return retryStrategies[0];\n+        }\n+\n+        return (ctx, cause) -> {\n+            for (RetryStrategy retryStrategy : retryStrategies) {\n+                final CompletionStage<Backoff> backoff = retryStrategy.shouldRetry(ctx, cause);", "originalCommit": "f01618fc01d318fdba40e155deade9e32f3f32ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQyMTI2Mg==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414421262", "bodyText": "Or perhaps we can implement anyOfNonNull(futures...).", "author": "minwoox", "createdAt": "2020-04-24T09:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQxNjc5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ1NzA2MQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r414457061", "bodyText": "the customized strategy cannot return NULL_BACKOFF\n\nOops... thank!\n\nHow about using allOf?\n\nI don't think we can use allOf here. Since it invokes all shouldRetry. If a user adds some side effect such as retry metric, allOf will cause a problem.\nLet me get backoffs lazily.", "author": "ikhoon", "createdAt": "2020-04-24T10:08:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQxNjc5OA=="}], "type": "inlineReview"}, {"oid": "44b1f1b2f9ecf875ea2856bbde6800811b2f63b5", "url": "https://github.com/line/armeria/commit/44b1f1b2f9ecf875ea2856bbde6800811b2f63b5", "message": "Introduce RetryRule, Deprecate RetryStrategy", "committedDate": "2020-04-27T13:45:35Z", "type": "commit"}, {"oid": "0721116f393edacb9dd236c89dd68ba987a78d3b", "url": "https://github.com/line/armeria/commit/0721116f393edacb9dd236c89dd68ba987a78d3b", "message": "--wip-- [skip ci]", "committedDate": "2020-04-28T03:37:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3NDM5Ng==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416374396", "bodyText": "I think we usually return a complete object from a factory, or just have one method for builder(). Should these all be returning RetryRule instead of builder? Anyways, would probably recommend two methods to keep the API simple, default() that returns idempotent().onServerError().onException().withBackoff(default) and builder().", "author": "anuraaga", "createdAt": "2020-04-28T06:57:54Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * A rule for {@link RetryStrategy}.\n+ */\n+@FunctionalInterface\n+public interface RetryRule {\n+\n+    /**\n+     * Adds the idempotent HTTP methods for a {@link RetryStrategy} which will retry\n+     * if the request HTTP method is idempotent.\n+     */\n+    static RetryRuleBuilder onIdempotentMethods() {", "originalCommit": "44b1f1b2f9ecf875ea2856bbde6800811b2f63b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjk0Ng==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416402946", "bodyText": "default() that returns idempotent().onServerError().onException().withBackoff(default)\n\nI agree with adding default() method.\nI'd like to make the default more conservative and safer to avoid unexpected retry and traffic.\nHow about retrying only with UnprocessedRequestException?\nstatic RetryRule ofDefault() {\n  return onUnprocessed().thenBackoff(default);\n}", "author": "ikhoon", "createdAt": "2020-04-28T07:48:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3NDM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwNjkyNg==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416406926", "bodyText": "Yeah that seems like a good default too.", "author": "anuraaga", "createdAt": "2020-04-28T07:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3NDM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwNzMwNA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416407304", "bodyText": "Let's add .onServerError() as well. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-04-28T07:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3NDM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQxMDAxNQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416410015", "bodyText": "For me, this one is the most sensible default:\nstatic RetryRule ofDefault() {\n  return onIdempotentMethods().thenBackoff(default).or(RetryRule.onServerError().onUnprocessed().thenBackoff(default));\n}", "author": "minwoox", "createdAt": "2020-04-28T07:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3NDM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUyODc2MA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416528760", "bodyText": "Had chat internally on the default() method, we could not decide which rule is good for default. And there are other issues as well.\n\nA RetryRule could not be overridden by other rules. We can combine RetryRule using OR operation. That means there is no way to override the default behavior, unlike other defaults.\nWhich is a safe default rule for users? It will depend on the situation. It makes sense that they create an empty rule and add safe rules by their requirements.\n\nSo how about just adding a builder() method with an empty rule?", "author": "ikhoon", "createdAt": "2020-04-28T11:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3NDM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzNzE1Mg==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416537152", "bodyText": "I personally liked having a one-liner like the previous onServerErrorStatus for generic clients, maybe default is a bad word but a simple (for lack of better word) retry rule that works for many cases and avoids having to go through a huge API seems useful.\nBy the way, are you planning on keeping all these factories?", "author": "anuraaga", "createdAt": "2020-04-28T11:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3NDM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0NjI4OA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416546288", "bodyText": "a simple (for lack of better word) retry rule that works for many cases and avoids having to go through a huge API seems useful.\n\nOops, I misrepresented the talk. \ud83d\ude05 Our internal users also want to add a rule that is safe and easy to use, but not default. Let me think about what is good name for it.  \ud83e\udd14\n\nBy the way, are you planning on keeping all these factories?\n\nYes. as you commented, I am changing the return type of the factory methods to RetryRule.\nFor example:\nRetryRule rule = RetryRule.onServerErrorStatus();", "author": "ikhoon", "createdAt": "2020-04-28T11:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3NDM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0OTE1Ng==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416549156", "bodyText": "Cool - if the factories return rules that's also helpful for finding a simple one :)", "author": "anuraaga", "createdAt": "2020-04-28T11:49:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3NDM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA0ODE1Mg==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417048152", "bodyText": "The sensible default method named failsafe() is added. :-)", "author": "ikhoon", "createdAt": "2020-04-29T03:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3NDM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3NjY0Ng==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416376646", "bodyText": "Instead of stop, noRetry?", "author": "anuraaga", "createdAt": "2020-04-28T07:02:05Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleDecision.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link RetryRuleDecision} that determines whether a {@link RetryRule} is applied or not.\n+ */\n+public final class RetryRuleDecision {\n+\n+    private static final RetryRuleDecision STOP = new RetryRuleDecision(null);\n+    private static final RetryRuleDecision NEXT = new RetryRuleDecision(null);\n+\n+    /**\n+     * Returns a {@link RetryRuleDecision} that retries with the specified {@link Backoff}.\n+     */\n+    public static RetryRuleDecision retry(Backoff backoff) {\n+        return new RetryRuleDecision(backoff);\n+    }\n+\n+    /**\n+     * Returns a {@link RetryRuleDecision} that never retries.\n+     */\n+    public static RetryRuleDecision stop() {", "originalCommit": "44b1f1b2f9ecf875ea2856bbde6800811b2f63b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAyOTEwMw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417029103", "bodyText": "noRetry seems more explicit and stop can keep consistency because other decision factory methods consist of a single word.\nAnyway, I prefer an obvious method name.", "author": "ikhoon", "createdAt": "2020-04-29T02:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3NjY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM4NjI1Mg==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416386252", "bodyText": "I think most of the builder factories aren't so useful, but having an equivalent factory in the new class that returns a very common RetryRule will be great.", "author": "anuraaga", "createdAt": "2020-04-28T07:20:40Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryStrategy.java", "diffHunk": "@@ -88,15 +102,35 @@ static RetryStrategy onException(Function<? super Throwable, ? extends Backoff>\n     /**\n      * Returns a {@link RetryStrategy} that retries with the {@link Backoff#ofDefault()}\n      * when the response status is 5xx (server error) or an {@link Exception} is raised.\n+     *\n+     * @deprecated Use {@link RetryRuleBuilder#onServerErrorStatus()}}, {@link RetryRuleBuilder#onException()}\n+     *             and {@link RetryRuleBuilder#thenBackoff()}.\n+     *             For example:\n+     *             <pre>{@code\n+     *             RetryRule.onServerErrorStatus()\n+     *                      .onException()\n+     *                      .thenBackoff();\n+     *             }</pre>\n      */\n+    @Deprecated\n     static RetryStrategy onServerErrorStatus() {", "originalCommit": "44b1f1b2f9ecf875ea2856bbde6800811b2f63b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM4OTcwOA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416389708", "bodyText": "If RetryStrategy is deprecated, I don't think we need to mention toRetryRule() in the deprecation message", "author": "anuraaga", "createdAt": "2020-04-28T07:26:32Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryStrategy.java", "diffHunk": "@@ -34,7 +35,11 @@\n /**\n  * Determines whether a failed request should be retried.\n  * If you need to determine by looking into the {@link Response}, use {@link RetryStrategyWithContent}.\n+ *\n+ * @deprecated Use {@link RetryRule} directly or convert the existing {@link RetryStrategy} to {@link RetryRule}", "originalCommit": "44b1f1b2f9ecf875ea2856bbde6800811b2f63b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwNjkwOA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416406908", "bodyText": "Yeap, let me move toRetryRule() to internal.", "author": "ikhoon", "createdAt": "2020-04-28T07:55:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM4OTcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MDE1NA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r416390154", "bodyText": "Instead of adding this to a deprecated type, just convert with an internal helper in RetryingClientBuilder", "author": "anuraaga", "createdAt": "2020-04-28T07:27:17Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryStrategy.java", "diffHunk": "@@ -112,13 +146,30 @@ static RetryStrategy onServerErrorStatus(Backoff backoff) {\n      *\n      * @param backoffFunction A {@link BiFunction} that returns the {@link Backoff} or {@code null} (no retry)\n      *                        according to the given {@link HttpStatus} and {@link Throwable}\n+     *\n+     * @deprecated Use {@link RetryRuleBuilder#onStatus(Predicate)},\n+     *             {@link RetryRuleBuilder#onException(Predicate)} and\n+     *             {@link RetryRuleBuilder#thenBackoff(Backoff)}.\n+     *             For example:\n+     *             <pre>{@code\n+     *             RetryRule.onStatus(HttpStatus.TOO_MANY_REQUESTS)\n+     *                      .onException(ex -> ex instanceof ClosedStreamException)\n+     *                      .thenBackoff(myBackoff);\n+     *             }</pre>\n      */\n+    @Deprecated\n     static RetryStrategy onStatus(\n             BiFunction<? super HttpStatus, ? super Throwable, ? extends Backoff> backoffFunction) {\n-        // TODO(trustin): Apply a different backoff for UnprocessedRequestException.\n         return new HttpStatusBasedRetryStrategy(backoffFunction);\n     }\n \n+    /**\n+     * Converts a {@link RetryStrategy} to a {@link RetryRule}.\n+     */\n+    default RetryRule toRetryRule() {", "originalCommit": "44b1f1b2f9ecf875ea2856bbde6800811b2f63b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "30980776043906b07699c635cdf059472d2b3a11", "url": "https://github.com/line/armeria/commit/30980776043906b07699c635cdf059472d2b3a11", "message": "Make fatory methods of RetryRule create RetryRule", "committedDate": "2020-04-28T12:58:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAzNzk2MA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417037960", "bodyText": "default backoff", "author": "anuraaga", "createdAt": "2020-04-29T02:46:46Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * Determines whether a failed request should be retried.\n+ * If you need to determine by looking into the {@link Response}, use {@link RetryRuleWithContent}.\n+ */\n+@FunctionalInterface\n+public interface RetryRule {\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleBuilder}.\n+     */\n+    static RetryRuleBuilder builder() {\n+        return new RetryRuleBuilder();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the specified {@link Backoff}", "originalCommit": "30980776043906b07699c635cdf059472d2b3a11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA0MDUwMw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417040503", "bodyText": "Few of those throughout. Maybe the javadoc copy-paste errors are an indication of too many factories? :) Would consider not having the ones that take backoff, using the builder hardly adds many characters but makes the API much easier to read through on a javadoc for example.", "author": "anuraaga", "createdAt": "2020-04-29T02:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAzNzk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA1MzU0OQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417053549", "bodyText": "Yeah, RetryRule has too many factories. Let me remove factories that take backoff.", "author": "ikhoon", "createdAt": "2020-04-29T03:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAzNzk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAzOTY3Mw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417039673", "bodyText": "Instead of stop trying further something like to not retry. noRetry is the opposite of retry, not next so the wording should be similar to that one", "author": "anuraaga", "createdAt": "2020-04-29T02:54:30Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * Determines whether a failed request should be retried.\n+ * If you need to determine by looking into the {@link Response}, use {@link RetryRuleWithContent}.\n+ */\n+@FunctionalInterface\n+public interface RetryRule {\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleBuilder}.\n+     */\n+    static RetryRuleBuilder builder() {\n+        return new RetryRuleBuilder();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the specified {@link Backoff}\n+     * if the class of the response status is the specified {@link HttpStatusClass}.\n+     */\n+    static RetryRule onStatusClass(HttpStatusClass statusClass) {\n+        return onStatusClass(statusClass, Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the specified {@link Backoff}\n+     * if the class of the response status is the specified {@link HttpStatusClass}.\n+     */\n+    static RetryRule onStatusClass(HttpStatusClass statusClass, Backoff backoff) {\n+        return builder().onStatusClass(statusClass).thenBackoff(backoff);\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the specified {@link Backoff}\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    static RetryRule onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        return onStatusClass(statusClasses, Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the specified {@link Backoff}\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    static RetryRule onStatusClass(Iterable<HttpStatusClass> statusClasses, Backoff backoff) {\n+        return builder().onStatusClass(statusClasses).thenBackoff(backoff);\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff}\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    static RetryRule onServerErrorStatus() {\n+        return onServerErrorStatus(Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the specified {@link Backoff}\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    static RetryRule onServerErrorStatus(Backoff backoff) {\n+        return builder().onServerErrorStatus().thenBackoff(backoff);\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@link Backoff#ofDefault() default backoff} if an {@link Exception} is raised and\n+     * the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     *\n+     * <p>This method is shortcut for:\n+     * <pre>{@code\n+     * RetryRule.builder()\n+     *          .onServerErrorStatus()\n+     *          .onException()\n+     *          .thenBackoff();\n+     * }</pre>\n+     */\n+    static RetryRule onServerError() {\n+        return onServerError(Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the specified {@link Backoff}\n+     * if an {@link Exception} is raised and the class of the response status is\n+     * {@link HttpStatusClass#SERVER_ERROR}.\n+     *\n+     * <p>This method is shortcut for:\n+     * <pre>{@code\n+     * Backoff myBackoff = ...;\n+     * RetryRule.builder()\n+     *          .onServerErrorStatus()\n+     *          .onException()\n+     *          .thenBackoff(myBackoff);\n+     * }</pre>\n+     */\n+    static RetryRule onServerError(Backoff backoff) {\n+        return builder().onServerErrorStatus().onException().thenBackoff(backoff);\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if the response status is\n+     * the specified {@link HttpStatus}.\n+     */\n+    static RetryRule onStatus(HttpStatus status) {\n+        return onStatus(status, Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the specified {@link Backoff}\n+     * if the response status is the specified {@link HttpStatus}.\n+     */\n+    static RetryRule onStatus(HttpStatus status, Backoff backoff) {\n+        return builder().onStatus(status).thenBackoff(backoff);\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if the response status is one of\n+     * the specified {@link HttpStatus}es.\n+     */\n+    static RetryRule onStatus(Iterable<HttpStatus> statuses) {\n+        return onStatus(statuses, Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the specified {@link Backoff}\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    static RetryRule onStatus(Iterable<HttpStatus> statuses, Backoff backoff) {\n+        return builder().onStatus(statuses).thenBackoff(backoff);\n+    }\n+\n+    /**\n+     * Returns a newly created a {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if the response status matches\n+     * the specified {@code statusFilter}.\n+     */\n+    static RetryRule onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        return onStatus(statusFilter, Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Returns a newly created a {@link RetryRule} that will retry with the specified {@link Backoff}\n+     * if the response status matches the specified {@code statusFilter}.\n+     */\n+    static RetryRule onStatus(Predicate<? super HttpStatus> statusFilter, Backoff backoff) {\n+        return builder().onStatus(statusFilter).thenBackoff(backoff);\n+    }\n+\n+    /**\n+     * Returns a newly created a {@link RetryRule} that will retry with\n+     * the {@linkplain Backoff#ofDefault() default backoff} if an {@link Exception} is raised and\n+     * that is instance of the specified {@code exception}.\n+     */\n+    static RetryRule onException(Class<? extends Throwable> exception) {\n+        return onException(exception, Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the specified {@link Backoff}\n+     * if an {@link Exception} is raised and that is instance of the specified {@code exception}.\n+     */\n+    static RetryRule onException(Class<? extends Throwable> exception, Backoff backoff) {\n+        return builder().onException(exception).thenBackoff(backoff);\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry if an {@link Exception} is raised and\n+     * the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    static RetryRule onException(Predicate<? super Throwable> exceptionFilter) {\n+        return onException(exceptionFilter, Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry if an {@link Exception} is raised and\n+     * the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    static RetryRule onException(Predicate<? super Throwable> exceptionFilter, Backoff backoff) {\n+        return builder().onException(exceptionFilter).thenBackoff(backoff);\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that retries on any {@link Exception}.\n+     */\n+    static RetryRule onException() {\n+        return onException(Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Returns a newly-created {@link RetryRule} that retries with the specified {@link Backoff} on any {@link Exception}.\n+     */\n+    static RetryRule onException(Backoff backoff) {\n+        return builder().onException().thenBackoff(backoff);\n+    }\n+\n+    /**\n+     * Returns a {@link RetryRule} that retries on an {@link UnprocessedRequestException} which means that\n+     * the request has not been processed by the server. Therefore, you can safely retry the request without\n+     * worrying about the idempotency of the request.\n+     */\n+    static RetryRule onUnprocessed() {\n+        return builder().onUnprocessed().thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a {@link RetryRule} that retries with the specified {@link Backoff} on\n+     * an {@link UnprocessedRequestException} which means that the request has not been processed by the server.\n+     * Therefore, you can safely retry the request without worrying about the idempotency of the request.\n+     */\n+    static RetryRule onUnprocessed(Backoff backoff) {\n+        return builder().onUnprocessed().thenBackoff(backoff);\n+    }\n+\n+    /**\n+     * Returns composed {@link RetryRule} that represents a logical OR of this {@link RetryRule} and another.\n+     * If this {@link RetryRule} completes with {@link RetryRuleDecision#retry(Backoff)} or\n+     * {@link RetryRuleDecision#noRetry()}, then other {@link RetryRule} is not evaluated.\n+     */\n+    default RetryRule or(RetryRule other) {\n+        return (ctx, cause) -> {\n+            final CompletionStage<RetryRuleDecision> decisionFuture = shouldRetry(ctx, cause);\n+            return decisionFuture.thenCompose(decision -> {\n+                if (decision != RetryRuleDecision.next()) {\n+                    return decisionFuture;\n+                } else {\n+                    return other.shouldRetry(ctx, cause);\n+                }\n+            });\n+        };\n+    }\n+\n+    /**\n+     * Tells whether the request sent with the specified {@link ClientRequestContext} requires a retry or not.\n+     * Implement this method to return a {@link CompletionStage} and to complete it with a desired\n+     * {@link RetryRuleDecision#retry(Backoff)}.\n+     * To stop trying further, complete it with {@link RetryRuleDecision#noRetry()}.", "originalCommit": "30980776043906b07699c635cdf059472d2b3a11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "932586560dad1dcad19ef2f16e6e094b12e044a9", "url": "https://github.com/line/armeria/commit/932586560dad1dcad19ef2f16e6e094b12e044a9", "message": "Add failsafe() factory method to RetryRule", "committedDate": "2020-04-29T03:13:55Z", "type": "commit"}, {"oid": "458741a92fcaced9a8abed7837c84027742c0733", "url": "https://github.com/line/armeria/commit/458741a92fcaced9a8abed7837c84027742c0733", "message": "Add note message", "committedDate": "2020-04-29T03:29:11Z", "type": "commit"}, {"oid": "fbe305f15310445337ce42e7bf6ad40ffb3219c1", "url": "https://github.com/line/armeria/commit/fbe305f15310445337ce42e7bf6ad40ffb3219c1", "message": "Address comments by @anuraaga / Remove factory methods taking a backoff", "committedDate": "2020-04-29T06:30:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NDc2MA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417094760", "bodyText": "I think @minwoox's suggestion of using or between unprocessed and idempotent.serverErrorStatus makes sense. For this rule, is it even possible to retry? I guess an unprocessed request should never have a server error status since it didn't make it to the server?", "author": "anuraaga", "createdAt": "2020-04-29T06:36:17Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * Determines whether a failed request should be retried.\n+ * If you need to determine by looking into the {@link Response}, use {@link RetryRuleWithContent}.\n+ */\n+@FunctionalInterface\n+public interface RetryRule {\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@link Backoff#ofDefault() default backoff} if the request HTTP method is\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n+     * and an {@link UnprocessedRequestException} is raised or the class of the response status is\n+     * {@link HttpStatusClass#SERVER_ERROR}.\n+     *\n+     * <p>Note that a client can safely retry a failed request with this rule if an endpoint service produces\n+     * the same result (no side effects) on idempotent HTTP methods.\n+     *\n+     * <p>This method is shortcut for:\n+     * <pre>{@code\n+     * RetryRule.builder()\n+     *          .onIdempotentMethods()\n+     *          .onServerErrorStatus()\n+     *          .onUnprocessed()\n+     *          .thenBackoff();\n+     * }</pre>\n+     */\n+    static RetryRule failsafe() {\n+        return builder().onIdempotentMethods().onServerErrorStatus().onUnprocessed().thenBackoff();", "originalCommit": "fbe305f15310445337ce42e7bf6ad40ffb3219c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NTYyMA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417095620", "bodyText": "Wondering maybe we can just remove onUnprocessed and have RetryingClient always retry on unprocessed regardless of rule. Is there any conceivable case not to retry on unprocessed (from what I understand unprocessed means not sent to the server, but the only reason clients exist in the first place is solely to send something to the server and should always want to IMO). Putting it this way, I wonder if we even should require RetryingClient to retry unprocessed or just do it natively.", "author": "anuraaga", "createdAt": "2020-04-29T06:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NDc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzExNzMzNA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417117334", "bodyText": "I guess an unprocessed request should never have a server error status since it didn't make it to the server?\n\non* methods in RetryRuleBuilder is OR expression except on*Methods.\nbuilder().onIdempotentMethods().onServerErrorStatus().onUnprocessed().thenBackoff() means\nrule = request method is idempotent && \n       (response status is 5xx || cause is UnprocessedRequestException)\n\nDoes this make you confused? Hmm...\nThe main reason why I add or() method is to allow a user configuring different backoff for different errors.\n\nWondering maybe we can just remove onUnprocessed and have RetryingClient always retry on unprocessed regardless of rule.\n\nThat makes sense, but we maybe need a discussion for this topic. Let me file an issue soon.", "author": "ikhoon", "createdAt": "2020-04-29T07:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NDc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyMTM3MA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417121370", "bodyText": "Hmm - yeah same type of methods having different or / and behavior seems confusing, you really need to know this API to be able to reason about such code. I'm reviewing the PR and didn't realize ;) Can't come up with a good idea, which is the main reason for the suggestion of just always retrying unprocessed.", "author": "anuraaga", "createdAt": "2020-04-29T07:36:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NDc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1NDUyMA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417154520", "bodyText": "I don't think AND operation in builder makes sense for a response status or an exception.\nHow about changing onIdempotentMethods() to ifIdempotentMethods()?\nRetryRule.builder()\n         .ifIdempotentMethods()\n         .onServerErrorStatus()\n         .onUnprocessed()\n         .thenBackoff()\n         .or(RetryRule.onStatus(HttpStatus.TOO_MANY_REQUESTS));\nor just give up changing on* methods and\nWe can change the return type builder methods to select only one on* methods.\nclass RetryRuleBuilder {\n    public RetryRuleBuilder onIdempotentMethods() {\n        ...\n        return this;\n    }\n    public RetryBackoffBuilder onServerErrorStatus() { \n        return new RetryBackoffBuilder(this); \n    }\n}\nclass RetryBackoffBuilder {\n\n   public RetryRule thenBackoff(Backoff backoff) { \n       ...\n   } \n}", "author": "ikhoon", "createdAt": "2020-04-29T08:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NDc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MjU5Ng==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417242596", "bodyText": "If is a little better, but if some user code is on, if, on, it looks a bit weird.\nMaybe we can make methods a constructor parameter / factory parameter for the builder? Then it's clearer they're special", "author": "anuraaga", "createdAt": "2020-04-29T11:24:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NDc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1NzcwNw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417257707", "bodyText": "It sounds good mostly but can't offer special method set such as idempotentMethods().\nThen probably need a special builder method?\nRetryRule.builder()\n         .onServerErrorStatus()...\n\nRetryRule.builder(HttpMethod.GET)\n         .onServerErrorStatus()...\n\nRetryRule.builderWithIdempotentMethods()\n         .onServerErrorStatus()...", "author": "ikhoon", "createdAt": "2020-04-29T11:54:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NDc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI2MDM0Ng==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417260346", "bodyText": "Yeah that's what I was thinking", "author": "anuraaga", "createdAt": "2020-04-29T11:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NDc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwOTM3OQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r420509379", "bodyText": "How about RetryRule.builder(HttpMethod.idempotentMethods())?", "author": "trustin", "createdAt": "2020-05-06T02:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NDc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NjU3Mw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417096573", "bodyText": "Having a retrying client without backoff is such a bad practice in almost every situation that recommend not having a shortcut, if someone really wants this bad behavior they can pass spend the couple of lines of code to pass Backoff to thenBackoff", "author": "anuraaga", "createdAt": "2020-04-29T06:41:05Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleBuilder.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * A builder which creates a {@link RetryRule}.\n+ */\n+public final class RetryRuleBuilder {\n+\n+    private static final CompletableFuture<RetryRuleDecision> NEXT =\n+            CompletableFuture.completedFuture(RetryRuleDecision.next());\n+\n+    private static final Set<HttpMethod> IDEMPOTENT_METHODS =\n+            ImmutableSet.of(HttpMethod.GET, HttpMethod.HEAD, HttpMethod.PUT, HttpMethod.DELETE);\n+\n+    private final ImmutableSet.Builder<HttpStatusClass> statusClassesBuilder = ImmutableSet.builder();\n+    private final ImmutableSet.Builder<HttpStatus> statusesBuilder = ImmutableSet.builder();\n+\n+    private Set<HttpMethod> methods = HttpMethod.knownMethods();\n+    private boolean isMethodsSet;\n+\n+    @Nullable\n+    private Predicate<HttpStatus> statusFilter;\n+    @Nullable\n+    private Predicate<Throwable> exceptionFilter;\n+\n+    RetryRuleBuilder() {}\n+\n+    /**\n+     * Adds the <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n+     * HTTP methods, which should not have any side-effects (except for keeping statistics),\n+     * for a {@link RetryRule} which will retry if the request HTTP method is idempotent.\n+     */\n+    public RetryRuleBuilder onIdempotentMethods() {\n+        return onMethods(IDEMPOTENT_METHODS);\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryRule} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryRuleBuilder onMethods(HttpMethod... methods) {\n+        return onMethods(ImmutableSet.copyOf(requireNonNull(methods, \"methods\")));\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryRule} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryRuleBuilder onMethods(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"methods can't be empty\");\n+\n+        if (isMethodsSet) {\n+            Iterables.addAll(this.methods, methods);\n+        } else {\n+            this.methods = Sets.newEnumSet(methods, HttpMethod.class);\n+            isMethodsSet = true;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryRule} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryRuleBuilder onStatusClass(HttpStatusClass... statusClasses) {\n+        return onStatusClass(ImmutableSet.copyOf(requireNonNull(statusClasses, \"statusClasses\")));\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryRule} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryRuleBuilder onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        requireNonNull(statusClasses, \"statusClasses\");\n+        checkArgument(!Iterables.isEmpty(statusClasses), \"statusClasses can't be empty\");\n+\n+        statusClassesBuilder.addAll(statusClasses);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the {@link HttpStatusClass#SERVER_ERROR} for a {@link RetryRule} which will retry\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    public RetryRuleBuilder onServerErrorStatus() {\n+        return onStatusClass(HttpStatusClass.SERVER_ERROR);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryRule} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public RetryRuleBuilder onStatus(HttpStatus... statuses) {\n+        return onStatus(ImmutableSet.copyOf(requireNonNull(statuses, \"statuses\")));\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryRule} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public RetryRuleBuilder onStatus(Iterable<HttpStatus> statuses) {\n+        requireNonNull(statuses, \"statuses\");\n+        checkArgument(!Iterables.isEmpty(statuses), \"statuses can't be empty\");\n+\n+        statusesBuilder.addAll(statuses);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@code statusFilter} for a {@link RetryRule} which will retry\n+     * if the response status matches the specified {@code statusFilter}.\n+     */\n+    public RetryRuleBuilder onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        requireNonNull(statusFilter, \"statusFilter\");\n+        if (this.statusFilter != null) {\n+            this.statusFilter = this.statusFilter.or(statusFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<HttpStatus> cast = (Predicate<HttpStatus>) statusFilter;\n+            this.statusFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified exception type for a {@link RetryRule} which will retry\n+     * if an {@link Exception} is raised and that is instance of the specified {@code exception}.\n+     */\n+    public RetryRuleBuilder onException(Class<? extends Throwable> exception) {\n+        requireNonNull(exception, \"exception\");\n+        return onException(exception::isInstance);\n+    }\n+\n+    /**\n+     * Adds the specified {@code exceptionFilter} for a {@link RetryRule} which will retry\n+     * if an {@link Exception} is raised and the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    public RetryRuleBuilder onException(Predicate<? super Throwable> exceptionFilter) {\n+        requireNonNull(exceptionFilter, \"exceptionFilter\");\n+        if (this.exceptionFilter != null) {\n+            this.exceptionFilter = this.exceptionFilter.or(exceptionFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<Throwable> cast = (Predicate<Throwable>) exceptionFilter;\n+            this.exceptionFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Makes a {@link RetryRule} retry on any {@link Exception}.\n+     */\n+    public RetryRuleBuilder onException() {\n+        return onException(unused -> true);\n+    }\n+\n+    /**\n+     * Makes a {@link RetryRule} retry on an {@link UnprocessedRequestException} which means that the request\n+     * has not been processed by the server. Therefore, you can safely retry the request without worrying about\n+     * the idempotency of the request.\n+     */\n+    public RetryRuleBuilder onUnprocessed() {\n+        return onException(UnprocessedRequestException.class);\n+    }\n+\n+    /**\n+     * Sets the {@linkplain Backoff#ofDefault() default backoff} and returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenBackoff() {\n+        return thenBackoff(Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Sets the specified {@link Backoff} and returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenBackoff(Backoff backoff) {\n+        requireNonNull(backoff, \"backoff\");\n+        return build(RetryRuleDecision.retry(backoff));\n+    }\n+\n+    /**\n+     * Sets a {@link Backoff} which limits the number of attempts up to the specified value and\n+     * never waits between attempts. Returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenImmediately(int maxAttempts) {", "originalCommit": "fbe305f15310445337ce42e7bf6ad40ffb3219c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyODU2Nw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417128567", "bodyText": "This method is dangerous in most cases. Let's remove this shortcut. \ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-04-29T07:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NjU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NzEzMA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417097130", "bodyText": "Lets document what happens when they are all next", "author": "anuraaga", "createdAt": "2020-04-29T06:42:34Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * Determines whether a failed request should be retried.\n+ * If you need to determine by looking into the {@link Response}, use {@link RetryRuleWithContent}.\n+ */\n+@FunctionalInterface\n+public interface RetryRule {\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@link Backoff#ofDefault() default backoff} if the request HTTP method is\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n+     * and an {@link UnprocessedRequestException} is raised or the class of the response status is\n+     * {@link HttpStatusClass#SERVER_ERROR}.\n+     *\n+     * <p>Note that a client can safely retry a failed request with this rule if an endpoint service produces\n+     * the same result (no side effects) on idempotent HTTP methods.\n+     *\n+     * <p>This method is shortcut for:\n+     * <pre>{@code\n+     * RetryRule.builder()\n+     *          .onIdempotentMethods()\n+     *          .onServerErrorStatus()\n+     *          .onUnprocessed()\n+     *          .thenBackoff();\n+     * }</pre>\n+     */\n+    static RetryRule failsafe() {\n+        return builder().onIdempotentMethods().onServerErrorStatus().onUnprocessed().thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with\n+     * the {@linkplain Backoff#ofDefault() default backoff} if the class of the response status is\n+     * the specified {@link HttpStatusClass}.\n+     */\n+    static RetryRule onStatusClass(HttpStatusClass statusClass) {\n+        return builder().onStatusClass(statusClass).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with\n+     * the {@linkplain Backoff#ofDefault() defalut backoff} if the class of the response status is\n+     * one of the specified {@link HttpStatusClass}es.\n+     */\n+    static RetryRule onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        return builder().onStatusClass(statusClasses).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff}\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    static RetryRule onServerErrorStatus() {\n+        return builder().onServerErrorStatus().thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if the response status is one of\n+     * the specified {@link HttpStatus}es.\n+     */\n+    static RetryRule onStatus(HttpStatus... statuses) {\n+        return builder().onStatus(statuses).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if the response status is one of\n+     * the specified {@link HttpStatus}es.\n+     */\n+    static RetryRule onStatus(Iterable<HttpStatus> statuses) {\n+        return builder().onStatus(statuses).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created a {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if the response status matches\n+     * the specified {@code statusFilter}.\n+     */\n+    static RetryRule onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        return builder().onStatus(statusFilter).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created a {@link RetryRule} that will retry with\n+     * the {@linkplain Backoff#ofDefault() default backoff} if an {@link Exception} is raised and\n+     * that is instance of the specified {@code exception}.\n+     */\n+    static RetryRule onException(Class<? extends Throwable> exception) {\n+        return builder().onException(exception).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if an {@link Exception} is raised and\n+     * the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    static RetryRule onException(Predicate<? super Throwable> exceptionFilter) {\n+        return builder().onException(exceptionFilter).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that retries with\n+     * {@linkplain Backoff#ofDefault() default backoff} on any {@link Exception}.\n+     * Note that this rule should be used carefully because it reties regardless of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotency</a>.\n+     */\n+    static RetryRule onException() {\n+        return builder().onException().thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a {@link RetryRule} that retries with the {@linkplain Backoff#ofDefault() default backoff}\n+     * on an {@link UnprocessedRequestException} which means that the request has not been processed by\n+     * the server. Therefore, you can safely retry the request without worrying about the idempotency of\n+     * the request.\n+     */\n+    static RetryRule onUnprocessed() {\n+        return builder().onUnprocessed().thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleBuilder}.\n+     */\n+    static RetryRuleBuilder builder() {\n+        return new RetryRuleBuilder();\n+    }\n+\n+    /**\n+     * Returns a composed {@link RetryRule} that represents a logical OR of this {@link RetryRule} and another.\n+     * If this {@link RetryRule} completes with {@link RetryRuleDecision#next()}, then other {@link RetryRule}\n+     * is evaluated.\n+     */\n+    default RetryRule or(RetryRule other) {\n+        return (ctx, cause) -> {\n+            final CompletionStage<RetryRuleDecision> decisionFuture = shouldRetry(ctx, cause);\n+            return decisionFuture.thenCompose(decision -> {\n+                if (decision != RetryRuleDecision.next()) {\n+                    return decisionFuture;\n+                } else {\n+                    return other.shouldRetry(ctx, cause);\n+                }\n+            });\n+        };\n+    }\n+\n+    /**\n+     * Tells whether the request sent with the specified {@link ClientRequestContext} requires a retry or not.\n+     * Implement this method to return a {@link CompletionStage} and to complete it with a desired\n+     * {@link RetryRuleDecision#retry(Backoff)}.\n+     * To not retry, complete it with {@link RetryRuleDecision#noRetry()}.\n+     * To skip this {@link RetryRule} and find other {@link RetryRule}, complete it with", "originalCommit": "fbe305f15310445337ce42e7bf6ad40ffb3219c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5OTQ3Nw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417099477", "bodyText": "Think you can move this out of the lambda instead of creating every time, similar to how NEXT is cached. Could also consider having a completed future created in the RetryRuleDecision constructor itself.", "author": "anuraaga", "createdAt": "2020-04-29T06:48:48Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleBuilder.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * A builder which creates a {@link RetryRule}.\n+ */\n+public final class RetryRuleBuilder {\n+\n+    private static final CompletableFuture<RetryRuleDecision> NEXT =\n+            CompletableFuture.completedFuture(RetryRuleDecision.next());\n+\n+    private static final Set<HttpMethod> IDEMPOTENT_METHODS =\n+            ImmutableSet.of(HttpMethod.GET, HttpMethod.HEAD, HttpMethod.PUT, HttpMethod.DELETE);\n+\n+    private final ImmutableSet.Builder<HttpStatusClass> statusClassesBuilder = ImmutableSet.builder();\n+    private final ImmutableSet.Builder<HttpStatus> statusesBuilder = ImmutableSet.builder();\n+\n+    private Set<HttpMethod> methods = HttpMethod.knownMethods();\n+    private boolean isMethodsSet;\n+\n+    @Nullable\n+    private Predicate<HttpStatus> statusFilter;\n+    @Nullable\n+    private Predicate<Throwable> exceptionFilter;\n+\n+    RetryRuleBuilder() {}\n+\n+    /**\n+     * Adds the <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n+     * HTTP methods, which should not have any side-effects (except for keeping statistics),\n+     * for a {@link RetryRule} which will retry if the request HTTP method is idempotent.\n+     */\n+    public RetryRuleBuilder onIdempotentMethods() {\n+        return onMethods(IDEMPOTENT_METHODS);\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryRule} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryRuleBuilder onMethods(HttpMethod... methods) {\n+        return onMethods(ImmutableSet.copyOf(requireNonNull(methods, \"methods\")));\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryRule} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryRuleBuilder onMethods(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"methods can't be empty\");\n+\n+        if (isMethodsSet) {\n+            Iterables.addAll(this.methods, methods);\n+        } else {\n+            this.methods = Sets.newEnumSet(methods, HttpMethod.class);\n+            isMethodsSet = true;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryRule} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryRuleBuilder onStatusClass(HttpStatusClass... statusClasses) {\n+        return onStatusClass(ImmutableSet.copyOf(requireNonNull(statusClasses, \"statusClasses\")));\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryRule} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryRuleBuilder onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        requireNonNull(statusClasses, \"statusClasses\");\n+        checkArgument(!Iterables.isEmpty(statusClasses), \"statusClasses can't be empty\");\n+\n+        statusClassesBuilder.addAll(statusClasses);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the {@link HttpStatusClass#SERVER_ERROR} for a {@link RetryRule} which will retry\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    public RetryRuleBuilder onServerErrorStatus() {\n+        return onStatusClass(HttpStatusClass.SERVER_ERROR);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryRule} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public RetryRuleBuilder onStatus(HttpStatus... statuses) {\n+        return onStatus(ImmutableSet.copyOf(requireNonNull(statuses, \"statuses\")));\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryRule} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public RetryRuleBuilder onStatus(Iterable<HttpStatus> statuses) {\n+        requireNonNull(statuses, \"statuses\");\n+        checkArgument(!Iterables.isEmpty(statuses), \"statuses can't be empty\");\n+\n+        statusesBuilder.addAll(statuses);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@code statusFilter} for a {@link RetryRule} which will retry\n+     * if the response status matches the specified {@code statusFilter}.\n+     */\n+    public RetryRuleBuilder onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        requireNonNull(statusFilter, \"statusFilter\");\n+        if (this.statusFilter != null) {\n+            this.statusFilter = this.statusFilter.or(statusFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<HttpStatus> cast = (Predicate<HttpStatus>) statusFilter;\n+            this.statusFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified exception type for a {@link RetryRule} which will retry\n+     * if an {@link Exception} is raised and that is instance of the specified {@code exception}.\n+     */\n+    public RetryRuleBuilder onException(Class<? extends Throwable> exception) {\n+        requireNonNull(exception, \"exception\");\n+        return onException(exception::isInstance);\n+    }\n+\n+    /**\n+     * Adds the specified {@code exceptionFilter} for a {@link RetryRule} which will retry\n+     * if an {@link Exception} is raised and the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    public RetryRuleBuilder onException(Predicate<? super Throwable> exceptionFilter) {\n+        requireNonNull(exceptionFilter, \"exceptionFilter\");\n+        if (this.exceptionFilter != null) {\n+            this.exceptionFilter = this.exceptionFilter.or(exceptionFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<Throwable> cast = (Predicate<Throwable>) exceptionFilter;\n+            this.exceptionFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Makes a {@link RetryRule} retry on any {@link Exception}.\n+     */\n+    public RetryRuleBuilder onException() {\n+        return onException(unused -> true);\n+    }\n+\n+    /**\n+     * Makes a {@link RetryRule} retry on an {@link UnprocessedRequestException} which means that the request\n+     * has not been processed by the server. Therefore, you can safely retry the request without worrying about\n+     * the idempotency of the request.\n+     */\n+    public RetryRuleBuilder onUnprocessed() {\n+        return onException(UnprocessedRequestException.class);\n+    }\n+\n+    /**\n+     * Sets the {@linkplain Backoff#ofDefault() default backoff} and returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenBackoff() {\n+        return thenBackoff(Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Sets the specified {@link Backoff} and returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenBackoff(Backoff backoff) {\n+        requireNonNull(backoff, \"backoff\");\n+        return build(RetryRuleDecision.retry(backoff));\n+    }\n+\n+    /**\n+     * Sets a {@link Backoff} which limits the number of attempts up to the specified value and\n+     * never waits between attempts. Returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenImmediately(int maxAttempts) {\n+        checkArgument(maxAttempts > 0, \"maxAttempts: %s (expected: > 0)\", maxAttempts);\n+        final Backoff backOff = Backoff.withoutDelay().withMaxAttempts(maxAttempts);\n+        return build(RetryRuleDecision.retry(backOff));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that never retries.\n+     */\n+    public RetryRule thenNoRetry() {\n+        return build(RetryRuleDecision.noRetry());\n+    }\n+\n+    private RetryRule build(RetryRuleDecision decision) {\n+        final Set<HttpMethod> methods = Sets.immutableEnumSet(this.methods);\n+        final Set<HttpStatusClass> statusClasses = Sets.immutableEnumSet(statusClassesBuilder.build());\n+        final Set<HttpStatus> statuses = statusesBuilder.build();\n+        final Predicate<HttpStatus> statusFilter = this.statusFilter;\n+        final Predicate<Throwable> exceptionFilter = this.exceptionFilter;\n+\n+        if (decision != RetryRuleDecision.noRetry() && exceptionFilter == null && statusFilter == null &&\n+            statuses.isEmpty() && statusClasses.isEmpty()) {\n+            throw new IllegalStateException(\n+                    \"Should set at least one of status, status class and an expected exception type \" +\n+                    \"if a backoff was set.\");\n+        }\n+\n+        return (ctx, cause) -> {\n+            if (!methods.contains(ctx.request().method())) {\n+                return NEXT;\n+            }\n+\n+            if (cause != null && exceptionFilter != null && exceptionFilter.test(Exceptions.peel(cause))) {\n+                return CompletableFuture.completedFuture(decision);\n+            }\n+\n+            if (ctx.log().isAvailable(RequestLogProperty.RESPONSE_HEADERS)) {\n+                final HttpStatus responseStatus = ctx.log().partial().responseHeaders().status();\n+                if (statusClasses != null && statusClasses.contains(responseStatus.codeClass())) {\n+                    return CompletableFuture.completedFuture(decision);", "originalCommit": "fbe305f15310445337ce42e7bf6ad40ffb3219c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyMjY1OQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417122659", "bodyText": "Think you can move this out of the lambda instead of creating every time\n\nGood idea.\n\nCould also consider having a completed future created in the RetryRuleDecision constructor itself.\n\nI couldn't follow this review for a custom RetryRule. A user might want to lazily complete the decision to decide a rule.", "author": "ikhoon", "createdAt": "2020-04-29T07:39:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5OTQ3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzMTQyNg==", "url": "https://github.com/line/armeria/pull/2661#discussion_r417131426", "bodyText": "On seconds thought, I can add singleton CompletableFuture<RetryRuleDecision> for the default backoff.", "author": "ikhoon", "createdAt": "2020-04-29T07:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5OTQ3Nw=="}], "type": "inlineReview"}, {"oid": "c6de57c9ba86a57d90d5ffa399b4abac483a6188", "url": "https://github.com/line/armeria/commit/c6de57c9ba86a57d90d5ffa399b4abac483a6188", "message": "Address comments by @anuraaga / Add singlton decision, remove thenImmediately()", "committedDate": "2020-04-29T08:06:53Z", "type": "commit"}, {"oid": "20dcdbfcd30f5cded1dad1681047afb33b93a7a5", "url": "https://github.com/line/armeria/commit/20dcdbfcd30f5cded1dad1681047afb33b93a7a5", "message": "Fix checkstyle", "committedDate": "2020-05-04T01:47:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxNjc2OA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r419316768", "bodyText": "strategy.shouldRetry(ctx, req) could return null, so I think we should handle that.", "author": "minwoox", "createdAt": "2020-05-04T09:35:35Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleUtil.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+final class RetryRuleUtil {\n+\n+    static RetryStrategy toRetryStrategy(RetryRule rule) {\n+        return (ctx, cause) -> rule.shouldRetry(ctx, cause).thenApply(RetryRuleDecision::backoff);\n+    }\n+\n+    static RetryRule fromRetryStrategy(RetryStrategy strategy) {\n+        return (ctx, req) -> strategy.shouldRetry(ctx, req).thenApply(RetryRuleDecision::retry);", "originalCommit": "20dcdbfcd30f5cded1dad1681047afb33b93a7a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1NjMyNg==", "url": "https://github.com/line/armeria/pull/2661#discussion_r419356326", "bodyText": "RetryClient does not check null of the return value. So I thought RetryStrategy.shouldRetry(...) must not return null value.\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/client/retry/RetryingClient.java\n    \n    \n        Lines 214 to 215\n      in\n      a9544c2\n    \n    \n    \n    \n\n        \n          \n           retryStrategyWithContent().shouldRetry(derivedCtx, contentPreviewResponse) \n        \n\n        \n          \n                                     .handle(handleBackoff(ctx, derivedCtx, rootReqDuplicator, \n        \n    \n  \n\n\nDo I need to update RetryClient too? \ud83e\udd14", "author": "ikhoon", "createdAt": "2020-05-04T10:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxNjc2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNjAzMA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r420506030", "bodyText": "What I meant was when the backoff is null: \n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/client/retry/RetryingClient.java\n    \n    \n         Line 255\n      in\n      a9544c2\n    \n    \n    \n    \n\n        \n          \n           if (backoff != null) { \n        \n    \n  \n\n\nIf it's null, then NPE is raised here: https://github.com/line/armeria/pull/2661/files#diff-b84a9cb0a39bd7bd59e96e1a4e2b5c83R39\nRight?", "author": "minwoox", "createdAt": "2020-05-06T01:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxNjc2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyODMxNw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r420528317", "bodyText": "I see. \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-05-06T03:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxNjc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxNzA4OA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r419317088", "bodyText": "We usually add .omitNullValues() right after toStringHelper(this).", "author": "minwoox", "createdAt": "2020-05-04T09:36:09Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleBuilder.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * A builder which creates a {@link RetryRule}.\n+ */\n+public final class RetryRuleBuilder {\n+\n+    private static final CompletableFuture<RetryRuleDecision> NEXT =\n+            CompletableFuture.completedFuture(RetryRuleDecision.next());\n+    private static final CompletableFuture<RetryRuleDecision> DEFAULT_DECISION =\n+           CompletableFuture.completedFuture(RetryRuleDecision.DEFAULT);\n+\n+    private static final Set<HttpMethod> IDEMPOTENT_METHODS =\n+            ImmutableSet.of(HttpMethod.GET, HttpMethod.HEAD, HttpMethod.PUT, HttpMethod.DELETE);\n+\n+    private final ImmutableSet.Builder<HttpStatusClass> statusClassesBuilder = ImmutableSet.builder();\n+    private final ImmutableSet.Builder<HttpStatus> statusesBuilder = ImmutableSet.builder();\n+\n+    private Set<HttpMethod> methods = HttpMethod.knownMethods();\n+    private boolean isMethodsSet;\n+\n+    @Nullable\n+    private Predicate<HttpStatus> statusFilter;\n+    @Nullable\n+    private Predicate<Throwable> exceptionFilter;\n+\n+    RetryRuleBuilder() {}\n+\n+    /**\n+     * Adds the <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n+     * HTTP methods, which should not have any side-effects (except for keeping statistics),\n+     * for a {@link RetryRule} which will retry if the request HTTP method is idempotent.\n+     */\n+    public RetryRuleBuilder onIdempotentMethods() {\n+        return onMethods(IDEMPOTENT_METHODS);\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryRule} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryRuleBuilder onMethods(HttpMethod... methods) {\n+        return onMethods(ImmutableSet.copyOf(requireNonNull(methods, \"methods\")));\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryRule} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryRuleBuilder onMethods(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"methods can't be empty\");\n+\n+        if (isMethodsSet) {\n+            Iterables.addAll(this.methods, methods);\n+        } else {\n+            this.methods = Sets.newEnumSet(methods, HttpMethod.class);\n+            isMethodsSet = true;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryRule} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryRuleBuilder onStatusClass(HttpStatusClass... statusClasses) {\n+        return onStatusClass(ImmutableSet.copyOf(requireNonNull(statusClasses, \"statusClasses\")));\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryRule} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryRuleBuilder onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        requireNonNull(statusClasses, \"statusClasses\");\n+        checkArgument(!Iterables.isEmpty(statusClasses), \"statusClasses can't be empty\");\n+\n+        statusClassesBuilder.addAll(statusClasses);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the {@link HttpStatusClass#SERVER_ERROR} for a {@link RetryRule} which will retry\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    public RetryRuleBuilder onServerErrorStatus() {\n+        return onStatusClass(HttpStatusClass.SERVER_ERROR);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryRule} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public RetryRuleBuilder onStatus(HttpStatus... statuses) {\n+        return onStatus(ImmutableSet.copyOf(requireNonNull(statuses, \"statuses\")));\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryRule} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public RetryRuleBuilder onStatus(Iterable<HttpStatus> statuses) {\n+        requireNonNull(statuses, \"statuses\");\n+        checkArgument(!Iterables.isEmpty(statuses), \"statuses can't be empty\");\n+\n+        statusesBuilder.addAll(statuses);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@code statusFilter} for a {@link RetryRule} which will retry\n+     * if the response status matches the specified {@code statusFilter}.\n+     */\n+    public RetryRuleBuilder onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        requireNonNull(statusFilter, \"statusFilter\");\n+        if (this.statusFilter != null) {\n+            this.statusFilter = this.statusFilter.or(statusFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<HttpStatus> cast = (Predicate<HttpStatus>) statusFilter;\n+            this.statusFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified exception type for a {@link RetryRule} which will retry\n+     * if an {@link Exception} is raised and that is instance of the specified {@code exception}.\n+     */\n+    public RetryRuleBuilder onException(Class<? extends Throwable> exception) {\n+        requireNonNull(exception, \"exception\");\n+        return onException(exception::isInstance);\n+    }\n+\n+    /**\n+     * Adds the specified {@code exceptionFilter} for a {@link RetryRule} which will retry\n+     * if an {@link Exception} is raised and the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    public RetryRuleBuilder onException(Predicate<? super Throwable> exceptionFilter) {\n+        requireNonNull(exceptionFilter, \"exceptionFilter\");\n+        if (this.exceptionFilter != null) {\n+            this.exceptionFilter = this.exceptionFilter.or(exceptionFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<Throwable> cast = (Predicate<Throwable>) exceptionFilter;\n+            this.exceptionFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Makes a {@link RetryRule} retry on any {@link Exception}.\n+     */\n+    public RetryRuleBuilder onException() {\n+        return onException(unused -> true);\n+    }\n+\n+    /**\n+     * Makes a {@link RetryRule} retry on an {@link UnprocessedRequestException} which means that the request\n+     * has not been processed by the server. Therefore, you can safely retry the request without worrying about\n+     * the idempotency of the request.\n+     */\n+    public RetryRuleBuilder onUnprocessed() {\n+        return onException(UnprocessedRequestException.class);\n+    }\n+\n+    /**\n+     * Sets the {@linkplain Backoff#ofDefault() default backoff} and returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenBackoff() {\n+        return thenBackoff(Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Sets the specified {@link Backoff} and returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenBackoff(Backoff backoff) {\n+        requireNonNull(backoff, \"backoff\");\n+        return build(RetryRuleDecision.retry(backoff));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that never retries.\n+     */\n+    public RetryRule thenNoRetry() {\n+        return build(RetryRuleDecision.noRetry());\n+    }\n+\n+    private RetryRule build(RetryRuleDecision decision) {\n+        final Set<HttpMethod> methods = Sets.immutableEnumSet(this.methods);\n+        final Set<HttpStatusClass> statusClasses = Sets.immutableEnumSet(statusClassesBuilder.build());\n+        final Set<HttpStatus> statuses = statusesBuilder.build();\n+        final Predicate<HttpStatus> statusFilter = this.statusFilter;\n+        final Predicate<Throwable> exceptionFilter = this.exceptionFilter;\n+\n+        if (decision != RetryRuleDecision.noRetry() && exceptionFilter == null && statusFilter == null &&\n+            statuses.isEmpty() && statusClasses.isEmpty()) {\n+            throw new IllegalStateException(\n+                    \"Should set at least one of status, status class and an expected exception type \" +\n+                    \"if a backoff was set.\");\n+        }\n+        final CompletableFuture<RetryRuleDecision> decisionFuture;\n+        if (decision == RetryRuleDecision.DEFAULT) {\n+           decisionFuture = DEFAULT_DECISION;\n+        } else {\n+            decisionFuture = CompletableFuture.completedFuture(decision);\n+        }\n+        return (ctx, cause) -> {\n+            if (!methods.contains(ctx.request().method())) {\n+                return NEXT;\n+            }\n+\n+            if (cause != null && exceptionFilter != null && exceptionFilter.test(Exceptions.peel(cause))) {\n+                return decisionFuture;\n+            }\n+\n+            if (ctx.log().isAvailable(RequestLogProperty.RESPONSE_HEADERS)) {\n+                final HttpStatus responseStatus = ctx.log().partial().responseHeaders().status();\n+                if (statusClasses != null && statusClasses.contains(responseStatus.codeClass())) {\n+                    return decisionFuture;\n+                }\n+\n+                if ((statuses != null && statuses.contains(responseStatus)) ||\n+                    (statusFilter != null && statusFilter.test(responseStatus))) {\n+                    return decisionFuture;\n+                }\n+            }\n+\n+            return NEXT;\n+        };\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return MoreObjects.toStringHelper(this)\n+                .add(\"statusClasses\", statusClassesBuilder.build())\n+                .add(\"statuses\", statusesBuilder.build())\n+                .add(\"methods\", methods)\n+                .add(\"statusFilter\", statusFilter)\n+                .add(\"exceptionFilter\", exceptionFilter)\n+                .omitNullValues()", "originalCommit": "20dcdbfcd30f5cded1dad1681047afb33b93a7a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxNzEzMw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r419317133", "bodyText": "nit: indentation?", "author": "minwoox", "createdAt": "2020-05-04T09:36:16Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleBuilder.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * A builder which creates a {@link RetryRule}.\n+ */\n+public final class RetryRuleBuilder {\n+\n+    private static final CompletableFuture<RetryRuleDecision> NEXT =\n+            CompletableFuture.completedFuture(RetryRuleDecision.next());\n+    private static final CompletableFuture<RetryRuleDecision> DEFAULT_DECISION =\n+           CompletableFuture.completedFuture(RetryRuleDecision.DEFAULT);\n+\n+    private static final Set<HttpMethod> IDEMPOTENT_METHODS =\n+            ImmutableSet.of(HttpMethod.GET, HttpMethod.HEAD, HttpMethod.PUT, HttpMethod.DELETE);\n+\n+    private final ImmutableSet.Builder<HttpStatusClass> statusClassesBuilder = ImmutableSet.builder();\n+    private final ImmutableSet.Builder<HttpStatus> statusesBuilder = ImmutableSet.builder();\n+\n+    private Set<HttpMethod> methods = HttpMethod.knownMethods();\n+    private boolean isMethodsSet;\n+\n+    @Nullable\n+    private Predicate<HttpStatus> statusFilter;\n+    @Nullable\n+    private Predicate<Throwable> exceptionFilter;\n+\n+    RetryRuleBuilder() {}\n+\n+    /**\n+     * Adds the <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n+     * HTTP methods, which should not have any side-effects (except for keeping statistics),\n+     * for a {@link RetryRule} which will retry if the request HTTP method is idempotent.\n+     */\n+    public RetryRuleBuilder onIdempotentMethods() {\n+        return onMethods(IDEMPOTENT_METHODS);\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryRule} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryRuleBuilder onMethods(HttpMethod... methods) {\n+        return onMethods(ImmutableSet.copyOf(requireNonNull(methods, \"methods\")));\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryRule} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryRuleBuilder onMethods(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"methods can't be empty\");\n+\n+        if (isMethodsSet) {\n+            Iterables.addAll(this.methods, methods);\n+        } else {\n+            this.methods = Sets.newEnumSet(methods, HttpMethod.class);\n+            isMethodsSet = true;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryRule} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryRuleBuilder onStatusClass(HttpStatusClass... statusClasses) {\n+        return onStatusClass(ImmutableSet.copyOf(requireNonNull(statusClasses, \"statusClasses\")));\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryRule} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryRuleBuilder onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        requireNonNull(statusClasses, \"statusClasses\");\n+        checkArgument(!Iterables.isEmpty(statusClasses), \"statusClasses can't be empty\");\n+\n+        statusClassesBuilder.addAll(statusClasses);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the {@link HttpStatusClass#SERVER_ERROR} for a {@link RetryRule} which will retry\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    public RetryRuleBuilder onServerErrorStatus() {\n+        return onStatusClass(HttpStatusClass.SERVER_ERROR);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryRule} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public RetryRuleBuilder onStatus(HttpStatus... statuses) {\n+        return onStatus(ImmutableSet.copyOf(requireNonNull(statuses, \"statuses\")));\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryRule} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public RetryRuleBuilder onStatus(Iterable<HttpStatus> statuses) {\n+        requireNonNull(statuses, \"statuses\");\n+        checkArgument(!Iterables.isEmpty(statuses), \"statuses can't be empty\");\n+\n+        statusesBuilder.addAll(statuses);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@code statusFilter} for a {@link RetryRule} which will retry\n+     * if the response status matches the specified {@code statusFilter}.\n+     */\n+    public RetryRuleBuilder onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        requireNonNull(statusFilter, \"statusFilter\");\n+        if (this.statusFilter != null) {\n+            this.statusFilter = this.statusFilter.or(statusFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<HttpStatus> cast = (Predicate<HttpStatus>) statusFilter;\n+            this.statusFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified exception type for a {@link RetryRule} which will retry\n+     * if an {@link Exception} is raised and that is instance of the specified {@code exception}.\n+     */\n+    public RetryRuleBuilder onException(Class<? extends Throwable> exception) {\n+        requireNonNull(exception, \"exception\");\n+        return onException(exception::isInstance);\n+    }\n+\n+    /**\n+     * Adds the specified {@code exceptionFilter} for a {@link RetryRule} which will retry\n+     * if an {@link Exception} is raised and the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    public RetryRuleBuilder onException(Predicate<? super Throwable> exceptionFilter) {\n+        requireNonNull(exceptionFilter, \"exceptionFilter\");\n+        if (this.exceptionFilter != null) {\n+            this.exceptionFilter = this.exceptionFilter.or(exceptionFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<Throwable> cast = (Predicate<Throwable>) exceptionFilter;\n+            this.exceptionFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Makes a {@link RetryRule} retry on any {@link Exception}.\n+     */\n+    public RetryRuleBuilder onException() {\n+        return onException(unused -> true);\n+    }\n+\n+    /**\n+     * Makes a {@link RetryRule} retry on an {@link UnprocessedRequestException} which means that the request\n+     * has not been processed by the server. Therefore, you can safely retry the request without worrying about\n+     * the idempotency of the request.\n+     */\n+    public RetryRuleBuilder onUnprocessed() {\n+        return onException(UnprocessedRequestException.class);\n+    }\n+\n+    /**\n+     * Sets the {@linkplain Backoff#ofDefault() default backoff} and returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenBackoff() {\n+        return thenBackoff(Backoff.ofDefault());\n+    }\n+\n+    /**\n+     * Sets the specified {@link Backoff} and returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenBackoff(Backoff backoff) {\n+        requireNonNull(backoff, \"backoff\");\n+        return build(RetryRuleDecision.retry(backoff));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that never retries.\n+     */\n+    public RetryRule thenNoRetry() {\n+        return build(RetryRuleDecision.noRetry());\n+    }\n+\n+    private RetryRule build(RetryRuleDecision decision) {\n+        final Set<HttpMethod> methods = Sets.immutableEnumSet(this.methods);\n+        final Set<HttpStatusClass> statusClasses = Sets.immutableEnumSet(statusClassesBuilder.build());\n+        final Set<HttpStatus> statuses = statusesBuilder.build();\n+        final Predicate<HttpStatus> statusFilter = this.statusFilter;\n+        final Predicate<Throwable> exceptionFilter = this.exceptionFilter;\n+\n+        if (decision != RetryRuleDecision.noRetry() && exceptionFilter == null && statusFilter == null &&\n+            statuses.isEmpty() && statusClasses.isEmpty()) {\n+            throw new IllegalStateException(\n+                    \"Should set at least one of status, status class and an expected exception type \" +\n+                    \"if a backoff was set.\");\n+        }\n+        final CompletableFuture<RetryRuleDecision> decisionFuture;\n+        if (decision == RetryRuleDecision.DEFAULT) {\n+           decisionFuture = DEFAULT_DECISION;\n+        } else {\n+            decisionFuture = CompletableFuture.completedFuture(decision);\n+        }\n+        return (ctx, cause) -> {\n+            if (!methods.contains(ctx.request().method())) {\n+                return NEXT;\n+            }\n+\n+            if (cause != null && exceptionFilter != null && exceptionFilter.test(Exceptions.peel(cause))) {\n+                return decisionFuture;\n+            }\n+\n+            if (ctx.log().isAvailable(RequestLogProperty.RESPONSE_HEADERS)) {\n+                final HttpStatus responseStatus = ctx.log().partial().responseHeaders().status();\n+                if (statusClasses != null && statusClasses.contains(responseStatus.codeClass())) {\n+                    return decisionFuture;\n+                }\n+\n+                if ((statuses != null && statuses.contains(responseStatus)) ||\n+                    (statusFilter != null && statusFilter.test(responseStatus))) {\n+                    return decisionFuture;\n+                }\n+            }\n+\n+            return NEXT;\n+        };\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return MoreObjects.toStringHelper(this)\n+                .add(\"statusClasses\", statusClassesBuilder.build())", "originalCommit": "20dcdbfcd30f5cded1dad1681047afb33b93a7a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwNDU0NQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r420504545", "bodyText": "Fixed. Chaining methods are not aligned vertically in IntelliJ IDEA 2020.1. \ud83d\ude2d", "author": "ikhoon", "createdAt": "2020-05-06T01:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxNzEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxODM2Mg==", "url": "https://github.com/line/armeria/pull/2661#discussion_r419318362", "bodyText": "Perhaps thenDefaultBackoff?", "author": "minwoox", "createdAt": "2020-05-04T09:38:31Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleBuilder.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.logging.RequestLogProperty;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+/**\n+ * A builder which creates a {@link RetryRule}.\n+ */\n+public final class RetryRuleBuilder {\n+\n+    private static final CompletableFuture<RetryRuleDecision> NEXT =\n+            CompletableFuture.completedFuture(RetryRuleDecision.next());\n+    private static final CompletableFuture<RetryRuleDecision> DEFAULT_DECISION =\n+           CompletableFuture.completedFuture(RetryRuleDecision.DEFAULT);\n+\n+    private static final Set<HttpMethod> IDEMPOTENT_METHODS =\n+            ImmutableSet.of(HttpMethod.GET, HttpMethod.HEAD, HttpMethod.PUT, HttpMethod.DELETE);\n+\n+    private final ImmutableSet.Builder<HttpStatusClass> statusClassesBuilder = ImmutableSet.builder();\n+    private final ImmutableSet.Builder<HttpStatus> statusesBuilder = ImmutableSet.builder();\n+\n+    private Set<HttpMethod> methods = HttpMethod.knownMethods();\n+    private boolean isMethodsSet;\n+\n+    @Nullable\n+    private Predicate<HttpStatus> statusFilter;\n+    @Nullable\n+    private Predicate<Throwable> exceptionFilter;\n+\n+    RetryRuleBuilder() {}\n+\n+    /**\n+     * Adds the <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n+     * HTTP methods, which should not have any side-effects (except for keeping statistics),\n+     * for a {@link RetryRule} which will retry if the request HTTP method is idempotent.\n+     */\n+    public RetryRuleBuilder onIdempotentMethods() {\n+        return onMethods(IDEMPOTENT_METHODS);\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryRule} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryRuleBuilder onMethods(HttpMethod... methods) {\n+        return onMethods(ImmutableSet.copyOf(requireNonNull(methods, \"methods\")));\n+    }\n+\n+    /**\n+     * Adds the specified HTTP methods for a {@link RetryRule} which will retry\n+     * if the request HTTP method is one of the specified HTTP methods.\n+     */\n+    public RetryRuleBuilder onMethods(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"methods can't be empty\");\n+\n+        if (isMethodsSet) {\n+            Iterables.addAll(this.methods, methods);\n+        } else {\n+            this.methods = Sets.newEnumSet(methods, HttpMethod.class);\n+            isMethodsSet = true;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryRule} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryRuleBuilder onStatusClass(HttpStatusClass... statusClasses) {\n+        return onStatusClass(ImmutableSet.copyOf(requireNonNull(statusClasses, \"statusClasses\")));\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatusClass}es for a {@link RetryRule} which will retry\n+     * if the class of the response status is one of the specified {@link HttpStatusClass}es.\n+     */\n+    public RetryRuleBuilder onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        requireNonNull(statusClasses, \"statusClasses\");\n+        checkArgument(!Iterables.isEmpty(statusClasses), \"statusClasses can't be empty\");\n+\n+        statusClassesBuilder.addAll(statusClasses);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the {@link HttpStatusClass#SERVER_ERROR} for a {@link RetryRule} which will retry\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    public RetryRuleBuilder onServerErrorStatus() {\n+        return onStatusClass(HttpStatusClass.SERVER_ERROR);\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryRule} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public RetryRuleBuilder onStatus(HttpStatus... statuses) {\n+        return onStatus(ImmutableSet.copyOf(requireNonNull(statuses, \"statuses\")));\n+    }\n+\n+    /**\n+     * Adds the specified {@link HttpStatus}es for a {@link RetryRule} which will retry\n+     * if the response status is one of the specified {@link HttpStatus}es.\n+     */\n+    public RetryRuleBuilder onStatus(Iterable<HttpStatus> statuses) {\n+        requireNonNull(statuses, \"statuses\");\n+        checkArgument(!Iterables.isEmpty(statuses), \"statuses can't be empty\");\n+\n+        statusesBuilder.addAll(statuses);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@code statusFilter} for a {@link RetryRule} which will retry\n+     * if the response status matches the specified {@code statusFilter}.\n+     */\n+    public RetryRuleBuilder onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        requireNonNull(statusFilter, \"statusFilter\");\n+        if (this.statusFilter != null) {\n+            this.statusFilter = this.statusFilter.or(statusFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<HttpStatus> cast = (Predicate<HttpStatus>) statusFilter;\n+            this.statusFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified exception type for a {@link RetryRule} which will retry\n+     * if an {@link Exception} is raised and that is instance of the specified {@code exception}.\n+     */\n+    public RetryRuleBuilder onException(Class<? extends Throwable> exception) {\n+        requireNonNull(exception, \"exception\");\n+        return onException(exception::isInstance);\n+    }\n+\n+    /**\n+     * Adds the specified {@code exceptionFilter} for a {@link RetryRule} which will retry\n+     * if an {@link Exception} is raised and the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    public RetryRuleBuilder onException(Predicate<? super Throwable> exceptionFilter) {\n+        requireNonNull(exceptionFilter, \"exceptionFilter\");\n+        if (this.exceptionFilter != null) {\n+            this.exceptionFilter = this.exceptionFilter.or(exceptionFilter);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            final Predicate<Throwable> cast = (Predicate<Throwable>) exceptionFilter;\n+            this.exceptionFilter = cast;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Makes a {@link RetryRule} retry on any {@link Exception}.\n+     */\n+    public RetryRuleBuilder onException() {\n+        return onException(unused -> true);\n+    }\n+\n+    /**\n+     * Makes a {@link RetryRule} retry on an {@link UnprocessedRequestException} which means that the request\n+     * has not been processed by the server. Therefore, you can safely retry the request without worrying about\n+     * the idempotency of the request.\n+     */\n+    public RetryRuleBuilder onUnprocessed() {\n+        return onException(UnprocessedRequestException.class);\n+    }\n+\n+    /**\n+     * Sets the {@linkplain Backoff#ofDefault() default backoff} and returns a newly created {@link RetryRule}.\n+     */\n+    public RetryRule thenBackoff() {", "originalCommit": "20dcdbfcd30f5cded1dad1681047afb33b93a7a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzMDkzMA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r419330930", "bodyText": "It was thenDefaultBackoff() originally. but changed here #2661 (comment)", "author": "ikhoon", "createdAt": "2020-05-04T10:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxODM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzMjc3NA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r419332774", "bodyText": "Oh I missed that. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-05-04T10:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxODM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyMDU5MQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r419320591", "bodyText": "nit: requireNonNull(other, \"other\");", "author": "minwoox", "createdAt": "2020-05-04T09:42:54Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * Determines whether a failed request should be retried.\n+ * If you need to determine by looking into the {@link Response}, use {@link RetryRuleWithContent}.\n+ */\n+@FunctionalInterface\n+public interface RetryRule {\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@link Backoff#ofDefault() default backoff} if the request HTTP method is\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n+     * and an {@link UnprocessedRequestException} is raised or the class of the response status is\n+     * {@link HttpStatusClass#SERVER_ERROR}.\n+     *\n+     * <p>Note that a client can safely retry a failed request with this rule if an endpoint service produces\n+     * the same result (no side effects) on idempotent HTTP methods.\n+     *\n+     * <p>This method is shortcut for:\n+     * <pre>{@code\n+     * RetryRule.builder()\n+     *          .onIdempotentMethods()\n+     *          .onServerErrorStatus()\n+     *          .onUnprocessed()\n+     *          .thenBackoff();\n+     * }</pre>\n+     */\n+    static RetryRule failsafe() {\n+        return builder().onIdempotentMethods().onServerErrorStatus().onUnprocessed().thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with\n+     * the {@linkplain Backoff#ofDefault() default backoff} if the class of the response status is\n+     * the specified {@link HttpStatusClass}.\n+     */\n+    static RetryRule onStatusClass(HttpStatusClass statusClass) {\n+        return builder().onStatusClass(statusClass).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with\n+     * the {@linkplain Backoff#ofDefault() defalut backoff} if the class of the response status is\n+     * one of the specified {@link HttpStatusClass}es.\n+     */\n+    static RetryRule onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        return builder().onStatusClass(statusClasses).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff}\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    static RetryRule onServerErrorStatus() {\n+        return builder().onServerErrorStatus().thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if the response status is one of\n+     * the specified {@link HttpStatus}es.\n+     */\n+    static RetryRule onStatus(HttpStatus... statuses) {\n+        return builder().onStatus(statuses).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if the response status is one of\n+     * the specified {@link HttpStatus}es.\n+     */\n+    static RetryRule onStatus(Iterable<HttpStatus> statuses) {\n+        return builder().onStatus(statuses).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created a {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if the response status matches\n+     * the specified {@code statusFilter}.\n+     */\n+    static RetryRule onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        return builder().onStatus(statusFilter).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created a {@link RetryRule} that will retry with\n+     * the {@linkplain Backoff#ofDefault() default backoff} if an {@link Exception} is raised and\n+     * that is instance of the specified {@code exception}.\n+     */\n+    static RetryRule onException(Class<? extends Throwable> exception) {\n+        return builder().onException(exception).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if an {@link Exception} is raised and\n+     * the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    static RetryRule onException(Predicate<? super Throwable> exceptionFilter) {\n+        return builder().onException(exceptionFilter).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that retries with\n+     * {@linkplain Backoff#ofDefault() default backoff} on any {@link Exception}.\n+     * Note that this rule should be used carefully because it reties regardless of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotency</a>.\n+     */\n+    static RetryRule onException() {\n+        return builder().onException().thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a {@link RetryRule} that retries with the {@linkplain Backoff#ofDefault() default backoff}\n+     * on an {@link UnprocessedRequestException} which means that the request has not been processed by\n+     * the server. Therefore, you can safely retry the request without worrying about the idempotency of\n+     * the request.\n+     */\n+    static RetryRule onUnprocessed() {\n+        return builder().onUnprocessed().thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleBuilder}.\n+     */\n+    static RetryRuleBuilder builder() {\n+        return new RetryRuleBuilder();\n+    }\n+\n+    /**\n+     * Returns a composed {@link RetryRule} that represents a logical OR of this {@link RetryRule} and another.\n+     * If this {@link RetryRule} completes with {@link RetryRuleDecision#next()}, then other {@link RetryRule}\n+     * is evaluated.\n+     */\n+    default RetryRule or(RetryRule other) {\n+        return (ctx, cause) -> {", "originalCommit": "20dcdbfcd30f5cded1dad1681047afb33b93a7a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c18efb1cd40b54167ded2ac08e4328fdac412c5", "url": "https://github.com/line/armeria/commit/5c18efb1cd40b54167ded2ac08e4328fdac412c5", "message": "Address comments by @trustin", "committedDate": "2020-05-04T11:03:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwOTc2NQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r420509765", "bodyText": "Could we also add static RetryRule of(RetryRule...) and static RetryRule of(Iterable<? extneds RetryRule>), which yield prettier indentation?", "author": "trustin", "createdAt": "2020-05-06T02:12:35Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * Determines whether a failed request should be retried.\n+ * If you need to determine by looking into the {@link Response}, use {@link RetryRuleWithContent}.\n+ */\n+@FunctionalInterface\n+public interface RetryRule {\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@link Backoff#ofDefault() default backoff} if the request HTTP method is\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n+     * and an {@link UnprocessedRequestException} is raised or the class of the response status is\n+     * {@link HttpStatusClass#SERVER_ERROR}.\n+     *\n+     * <p>Note that a client can safely retry a failed request with this rule if an endpoint service produces\n+     * the same result (no side effects) on idempotent HTTP methods.\n+     *\n+     * <p>This method is shortcut for:\n+     * <pre>{@code\n+     * RetryRule.builder()\n+     *          .onIdempotentMethods()\n+     *          .onServerErrorStatus()\n+     *          .onUnprocessed()\n+     *          .thenBackoff();\n+     * }</pre>\n+     */\n+    static RetryRule failsafe() {\n+        return builder().onIdempotentMethods().onServerErrorStatus().onUnprocessed().thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with\n+     * the {@linkplain Backoff#ofDefault() default backoff} if the class of the response status is\n+     * the specified {@link HttpStatusClass}.\n+     */\n+    static RetryRule onStatusClass(HttpStatusClass statusClass) {\n+        return builder().onStatusClass(statusClass).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with\n+     * the {@linkplain Backoff#ofDefault() defalut backoff} if the class of the response status is\n+     * one of the specified {@link HttpStatusClass}es.\n+     */\n+    static RetryRule onStatusClass(Iterable<HttpStatusClass> statusClasses) {\n+        return builder().onStatusClass(statusClasses).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff}\n+     * if the class of the response status is {@link HttpStatusClass#SERVER_ERROR}.\n+     */\n+    static RetryRule onServerErrorStatus() {\n+        return builder().onServerErrorStatus().thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if the response status is one of\n+     * the specified {@link HttpStatus}es.\n+     */\n+    static RetryRule onStatus(HttpStatus... statuses) {\n+        return builder().onStatus(statuses).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if the response status is one of\n+     * the specified {@link HttpStatus}es.\n+     */\n+    static RetryRule onStatus(Iterable<HttpStatus> statuses) {\n+        return builder().onStatus(statuses).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created a {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if the response status matches\n+     * the specified {@code statusFilter}.\n+     */\n+    static RetryRule onStatus(Predicate<? super HttpStatus> statusFilter) {\n+        return builder().onStatus(statusFilter).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created a {@link RetryRule} that will retry with\n+     * the {@linkplain Backoff#ofDefault() default backoff} if an {@link Exception} is raised and\n+     * that is instance of the specified {@code exception}.\n+     */\n+    static RetryRule onException(Class<? extends Throwable> exception) {\n+        return builder().onException(exception).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@linkplain Backoff#ofDefault() default backoff} if an {@link Exception} is raised and\n+     * the specified {@code exceptionFilter} returns {@code true}.\n+     */\n+    static RetryRule onException(Predicate<? super Throwable> exceptionFilter) {\n+        return builder().onException(exceptionFilter).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that retries with\n+     * {@linkplain Backoff#ofDefault() default backoff} on any {@link Exception}.\n+     * Note that this rule should be used carefully because it reties regardless of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotency</a>.\n+     */\n+    static RetryRule onException() {\n+        return builder().onException().thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a {@link RetryRule} that retries with the {@linkplain Backoff#ofDefault() default backoff}\n+     * on an {@link UnprocessedRequestException} which means that the request has not been processed by\n+     * the server. Therefore, you can safely retry the request without worrying about the idempotency of\n+     * the request.\n+     */\n+    static RetryRule onUnprocessed() {\n+        return builder().onUnprocessed().thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleBuilder}.\n+     */\n+    static RetryRuleBuilder builder() {\n+        return new RetryRuleBuilder();\n+    }\n+\n+    /**\n+     * Returns a composed {@link RetryRule} that represents a logical OR of this {@link RetryRule} and another.\n+     * If this {@link RetryRule} completes with {@link RetryRuleDecision#next()}, then other {@link RetryRule}\n+     * is evaluated.\n+     */\n+    default RetryRule or(RetryRule other) {", "originalCommit": "5c18efb1cd40b54167ded2ac08e4328fdac412c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyOTM1NQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r420529355", "bodyText": "SGTM!", "author": "ikhoon", "createdAt": "2020-05-06T03:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwOTc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDMwMQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r420510301", "bodyText": "(NO_RETRY)?", "author": "trustin", "createdAt": "2020-05-06T02:14:48Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleDecision.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link RetryRuleDecision} that determines whether a {@link RetryRule} retries with a {@link Backoff},\n+ * skips the current {@link RetryRule} or no retries.\n+ */\n+public final class RetryRuleDecision {\n+\n+    private static final RetryRuleDecision NO_RETRY = new RetryRuleDecision(null);\n+    private static final RetryRuleDecision NEXT = new RetryRuleDecision(null);\n+    static final RetryRuleDecision DEFAULT = new RetryRuleDecision(Backoff.ofDefault());\n+\n+    /**\n+     * Returns a {@link RetryRuleDecision} that retries with the specified {@link Backoff}.\n+     */\n+    public static RetryRuleDecision retry(Backoff backoff) {\n+        if (backoff == Backoff.ofDefault()) {\n+            return DEFAULT;\n+        }\n+        return new RetryRuleDecision(requireNonNull(backoff, \"backoff\"));\n+    }\n+\n+    /**\n+     * Returns a {@link RetryRuleDecision} that never retries.\n+     */\n+    public static RetryRuleDecision noRetry() {\n+        return NO_RETRY;\n+    }\n+\n+    /**\n+     * Returns a {@link RetryRuleDecision} that skips the current {@link RetryRule} and\n+     * tries to retry with the next {@link RetryRule}.\n+     */\n+    public static RetryRuleDecision next() {\n+        return NEXT;\n+    }\n+\n+    @Nullable\n+    private final Backoff backoff;\n+\n+    private RetryRuleDecision(@Nullable Backoff backoff) {\n+        this.backoff = backoff;\n+    }\n+\n+    @Nullable\n+    Backoff backoff() {\n+        return backoff;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (this == NO_RETRY) {\n+            return \"RetryRuleDecision(STOP)\";", "originalCommit": "5c18efb1cd40b54167ded2ac08e4328fdac412c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyODA3MQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r420528071", "bodyText": "Oops...", "author": "ikhoon", "createdAt": "2020-05-06T03:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDc1Mg==", "url": "https://github.com/line/armeria/pull/2661#discussion_r420510752", "bodyText": "Question - Should we add RetryRule.never()?", "author": "trustin", "createdAt": "2020-05-06T02:16:50Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientUnwrapTest.java", "diffHunk": "@@ -32,7 +32,7 @@ void test() {\n         final WebClient client =\n                 WebClient.builder()\n                          .decorator(LoggingClient.newDecorator())\n-                         .decorator(RetryingClient.newDecorator(RetryStrategy.never()))\n+                         .decorator(RetryingClient.newDecorator(RetryRule.builder().thenNoRetry()))", "originalCommit": "5c18efb1cd40b54167ded2ac08e4328fdac412c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUzMTI4Nw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r420531287", "bodyText": "RetryRule.never() seems not to be used often, so removed it from factories.\nI thought that if a user doesn't want to retry failed requests, he/she can just remove RetryClient from decorators.", "author": "ikhoon", "createdAt": "2020-05-06T03:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxMDc1Mg=="}], "type": "inlineReview"}, {"oid": "431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "url": "https://github.com/line/armeria/commit/431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "message": "Add RetryRuleWithContentBuilder", "committedDate": "2020-05-08T07:22:03Z", "type": "commit"}, {"oid": "7e1313b85cce0238ae3180c25ac0f49a1bcd9ce9", "url": "https://github.com/line/armeria/commit/7e1313b85cce0238ae3180c25ac0f49a1bcd9ce9", "message": "Clean up", "committedDate": "2020-05-08T07:58:03Z", "type": "commit"}, {"oid": "a1226a33bdc60f456c943cbb3b16ecc2a734fc78", "url": "https://github.com/line/armeria/commit/a1226a33bdc60f456c943cbb3b16ecc2a734fc78", "message": "Fix broken test", "committedDate": "2020-05-11T01:57:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NzcxOA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423487718", "bodyText": "nit: a shortcut", "author": "trustin", "createdAt": "2020-05-12T06:22:16Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -41,23 +50,28 @@\n      * Returns a newly created {@link RetryRule} that will retry with the\n      * {@link Backoff#ofDefault() default backoff} if the request HTTP method is\n      * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n-     * and an {@link UnprocessedRequestException} is raised or the class of the response status is\n+     * and an {@link Exception} is raised or the class of the response status is\n      * {@link HttpStatusClass#SERVER_ERROR}.\n+     * Or an {@link UnprocessedRequestException} is raised regardless of the request HTTP method.\n      *\n      * <p>Note that a client can safely retry a failed request with this rule if an endpoint service produces\n-     * the same result (no side effects) on idempotent HTTP methods.\n+     * the same result (no side effects) on idempotent HTTP methods or {@link UnprocessedRequestException}.\n      *\n      * <p>This method is shortcut for:", "originalCommit": "431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NzgwMA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423487800", "bodyText": "Otherwise, an ..", "author": "trustin", "createdAt": "2020-05-12T06:22:30Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -41,23 +50,28 @@\n      * Returns a newly created {@link RetryRule} that will retry with the\n      * {@link Backoff#ofDefault() default backoff} if the request HTTP method is\n      * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n-     * and an {@link UnprocessedRequestException} is raised or the class of the response status is\n+     * and an {@link Exception} is raised or the class of the response status is\n      * {@link HttpStatusClass#SERVER_ERROR}.\n+     * Or an {@link UnprocessedRequestException} is raised regardless of the request HTTP method.", "originalCommit": "431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4ODQ1Nw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423488457", "bodyText": "Probably better rejecting when methods is empty?", "author": "trustin", "createdAt": "2020-05-12T06:24:00Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -156,26 +170,74 @@ static RetryRule onUnprocessed() {\n      * Returns a newly created {@link RetryRuleBuilder}.\n      */\n     static RetryRuleBuilder builder() {\n-        return new RetryRuleBuilder();\n+        return builder(HttpMethod.knownMethods());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleBuilder} with the specified {@link HttpMethod}s.\n+     */\n+    static RetryRuleBuilder builder(HttpMethod... methods) {\n+        requireNonNull(methods, \"methods\");\n+        return builder(ImmutableSet.copyOf(methods));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleBuilder} with the specified {@link HttpMethod}s.\n+     */\n+    static RetryRuleBuilder builder(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        final ImmutableSet<HttpMethod> httpMethods = Sets.immutableEnumSet(methods);\n+        return builder(headers -> httpMethods.contains(headers.method()));", "originalCommit": "431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4ODk0OA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423488948", "bodyText": "Curious if it's better using a single varargs parameter, because we do so in other places. Could raise an exception on empty rules instead?", "author": "trustin", "createdAt": "2020-05-12T06:25:13Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -156,26 +170,74 @@ static RetryRule onUnprocessed() {\n      * Returns a newly created {@link RetryRuleBuilder}.\n      */\n     static RetryRuleBuilder builder() {\n-        return new RetryRuleBuilder();\n+        return builder(HttpMethod.knownMethods());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleBuilder} with the specified {@link HttpMethod}s.\n+     */\n+    static RetryRuleBuilder builder(HttpMethod... methods) {\n+        requireNonNull(methods, \"methods\");\n+        return builder(ImmutableSet.copyOf(methods));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleBuilder} with the specified {@link HttpMethod}s.\n+     */\n+    static RetryRuleBuilder builder(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        final ImmutableSet<HttpMethod> httpMethods = Sets.immutableEnumSet(methods);\n+        return builder(headers -> httpMethods.contains(headers.method()));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleBuilder} with the specified {@code requestHeadersFilter}.\n+     */\n+    static RetryRuleBuilder builder(Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        return new RetryRuleBuilder(requireNonNull(requestHeadersFilter, \"requestHeadersFilter\"));\n+    }\n+\n+    /**\n+     * Returns a {@link RetryRule} that combines the specified {@code retryRule} and {@code otherRules}.\n+     */\n+    static RetryRule of(RetryRule retryRule, RetryRule... otherRules) {\n+        requireNonNull(retryRule, \"retryRule\");", "originalCommit": "431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NjU4NA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423496584", "bodyText": "Yeah, I was considering it too. Let keep consistency.", "author": "ikhoon", "createdAt": "2020-05-12T06:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4ODk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4OTMyNA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423489324", "bodyText": "Revert?", "author": "trustin", "createdAt": "2020-05-12T06:26:08Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleBuilder.java", "diffHunk": "@@ -218,65 +55,120 @@ public RetryRule thenBackoff(Backoff backoff) {\n     }\n \n     /**\n-     * Returns a newly created {@link RetryRule} that never retries.\n+     * Returns a newly created retry rule that never retries.", "originalCommit": "431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4OTgxMA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423489810", "bodyText": "I'd prefer orElse if there's a conflict.", "author": "trustin", "createdAt": "2020-05-12T06:27:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleUtil.java", "diffHunk": "@@ -16,14 +16,154 @@\n \n package com.linecorp.armeria.client.retry;\n \n+import static com.linecorp.armeria.client.retry.AbstractRetryRuleBuilder.DEFAULT_DECISION;\n+import static com.linecorp.armeria.client.retry.AbstractRetryRuleBuilder.NEXT_DECISION;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.BiFunction;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseDuplicator;\n+import com.linecorp.armeria.common.Response;\n+\n final class RetryRuleUtil {\n \n     static RetryStrategy toRetryStrategy(RetryRule rule) {\n         return (ctx, cause) -> rule.shouldRetry(ctx, cause).thenApply(RetryRuleDecision::backoff);\n     }\n \n     static RetryRule fromRetryStrategy(RetryStrategy strategy) {\n-        return (ctx, req) -> strategy.shouldRetry(ctx, req).thenApply(RetryRuleDecision::retry);\n+        return (ctx, cause) -> strategy.shouldRetry(ctx, cause).thenApply(backoff -> {\n+            if (backoff == null) {\n+                return RetryRuleDecision.noRetry();\n+            } else {\n+                return RetryRuleDecision.retry(backoff);\n+            }\n+        });\n+    }\n+\n+    static <T extends Response> RetryStrategyWithContent<T> toRetryStrategyWithContent(\n+            RetryRuleWithContent<T> rule) {\n+        return (ctx, content) -> rule.shouldRetry(ctx, content).thenApply(RetryRuleDecision::backoff);\n+    }\n+\n+    static <T extends Response> RetryRuleWithContent<T> fromRetryStrategyWithContent(\n+            RetryStrategyWithContent<T> strategy) {\n+        return (ctx, content) -> strategy.shouldRetry(ctx, content).thenApply(backoff -> {\n+            if (backoff == null) {\n+                return RetryRuleDecision.noRetry();\n+            } else {\n+                return RetryRuleDecision.retry(backoff);\n+            }\n+        });\n+    }\n+\n+    static <T extends Response> RetryRuleWithContent<T> fromRetryRule(RetryRule retryRule) {\n+        return (ctx, content) -> {\n+            final CompletableFuture<?> completionFuture = content.whenComplete();\n+            if (completionFuture.isCompletedExceptionally()) {\n+                final CompletableFuture<RetryRuleDecision> decisionFuture = new CompletableFuture<>();\n+                completionFuture.exceptionally(cause -> {\n+                    retryRule.shouldRetry(ctx, cause).thenAccept(decisionFuture::complete);\n+                    return null;\n+                });\n+                return decisionFuture;\n+            }\n+            return retryRule.shouldRetry(ctx, null);\n+        };\n+    }\n+\n+    static RetryRule orElse(RetryRule first, RetryRule second) {\n+        return (ctx, cause) -> orElse0(ctx, cause, first::shouldRetry, second::shouldRetry);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T extends Response> RetryRuleWithContent<T> orElse(RetryRule first,\n+                                                               RetryRuleWithContent<T> second) {\n+        return (ctx, response) -> {\n+            if (response instanceof HttpResponse) {\n+                try (HttpResponseDuplicator duplicator = ((HttpResponse) response).toDuplicator()) {\n+                    final RetryRuleWithContent<T> duplicatedSecond =\n+                            (RetryRuleWithContent<T>) withDuplicator(\n+                                    (RetryRuleWithContent<HttpResponse>) second, duplicator);\n+                    return orElse(ctx, response, fromRetryRule(first), duplicatedSecond);\n+                }\n+            } else {\n+                return orElse(ctx, response, fromRetryRule(first), second);\n+            }\n+        };\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T extends Response> RetryRuleWithContent<T> orElse(RetryRuleWithContent<T> first,\n+                                                               RetryRule second) {\n+        return (ctx, response) -> {\n+            if (response instanceof HttpResponse) {\n+                try (HttpResponseDuplicator duplicator = ((HttpResponse) response).toDuplicator()) {\n+                    final RetryRuleWithContent<T> duplicatedFirst =\n+                            (RetryRuleWithContent<T>) withDuplicator(\n+                                    (RetryRuleWithContent<HttpResponse>) first, duplicator);\n+                    return orElse(ctx, response, duplicatedFirst, fromRetryRule(second));\n+                }\n+            } else {\n+                return orElse(ctx, response, first, fromRetryRule(second));\n+            }\n+        };\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T extends Response> RetryRuleWithContent<T> orElse(RetryRuleWithContent<T> first,\n+                                                               RetryRuleWithContent<T> second) {\n+        return (ctx, response) -> {\n+            if (response instanceof HttpResponse) {\n+                try (HttpResponseDuplicator duplicator = ((HttpResponse) response).toDuplicator()) {\n+                    final RetryRuleWithContent<T> duplicatedFirst =\n+                            (RetryRuleWithContent<T>) withDuplicator(\n+                                    (RetryRuleWithContent<HttpResponse>) first, duplicator);\n+                    final RetryRuleWithContent<T> duplicatedSecond =\n+                            (RetryRuleWithContent<T>) withDuplicator(\n+                                    (RetryRuleWithContent<HttpResponse>) second, duplicator);\n+                    return orElse(ctx, response, duplicatedFirst, duplicatedSecond);\n+                }\n+            } else {\n+                return orElse(ctx, response, first, second);\n+            }\n+        };\n+    }\n+\n+    private static <T extends Response> CompletionStage<RetryRuleDecision> orElse(\n+            ClientRequestContext ctx, T response,\n+            RetryRuleWithContent<T> first, RetryRuleWithContent<T> second) {\n+        return orElse0(ctx, response, first::shouldRetry, second::shouldRetry);\n+    }\n+\n+    private static <T> CompletionStage<RetryRuleDecision> orElse0(", "originalCommit": "431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNzc2NA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423507764", "bodyText": "There is an ambiguous method call if change orElse0 to orElse. Let me leave it as is.", "author": "ikhoon", "createdAt": "2020-05-12T07:06:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4OTgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5MDA2NA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423490064", "bodyText": "Ditto", "author": "trustin", "createdAt": "2020-05-12T06:27:57Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleWithContent.java", "diffHunk": "@@ -30,6 +43,109 @@\n @FunctionalInterface\n public interface RetryRuleWithContent<T extends Response> {\n \n+    /**\n+     * Returns a newly created {@link RetryRuleWithContent} that will retry with\n+     * the {@linkplain Backoff#ofDefault() default backoff} if the specified {@code retryFunction} completes\n+     * with {@code true}.\n+     */\n+    static <T extends Response> RetryRuleWithContent<T> onResponse(\n+            Function<? super T, ? extends CompletionStage<Boolean>> retryFunction) {\n+        return RetryRuleWithContent.<T>builder().onResponse(retryFunction).thenBackoff();\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleWithContentBuilder}.\n+     */\n+    static <T extends Response> RetryRuleWithContentBuilder<T> builder() {\n+        return builder(HttpMethod.knownMethods());\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleWithContentBuilder} with the specified {@link HttpMethod}s.\n+     */\n+    static <T extends Response> RetryRuleWithContentBuilder<T> builder(HttpMethod... methods) {\n+        return builder(ImmutableSet.copyOf(requireNonNull(methods, \"methods\")));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleWithContentBuilder} with the specified {@link HttpMethod}s.\n+     */\n+    static <T extends Response> RetryRuleWithContentBuilder<T> builder(Iterable<HttpMethod> methods) {\n+        requireNonNull(methods, \"methods\");\n+        final ImmutableSet<HttpMethod> httpMethods = Sets.immutableEnumSet(methods);\n+        return builder(headers -> httpMethods.contains(headers.method()));\n+    }\n+\n+    /**\n+     * Returns a newly created {@link RetryRuleWithContentBuilder} with the specified\n+     * {@code requestHeadersFilter}.\n+     */\n+    static <T extends Response> RetryRuleWithContentBuilder<T> builder(\n+            Predicate<? super RequestHeaders> requestHeadersFilter) {\n+        requireNonNull(requestHeadersFilter, \"requestHeadersFilter\");\n+        return new RetryRuleWithContentBuilder<>(requestHeadersFilter);\n+    }\n+\n+    /**\n+     * Returns a {@link RetryRuleWithContent} that combines the specified {@code retryRule} and\n+     * {@code otherRules}.\n+     */\n+    @SafeVarargs\n+    static <T extends Response> RetryRuleWithContent<T> of(RetryRuleWithContent<T> retryRule,\n+                                                           RetryRuleWithContent<T>... otherRules) {", "originalCommit": "431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5MTIwNQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423491205", "bodyText": "Revert?", "author": "trustin", "createdAt": "2020-05-12T06:30:47Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryingClientBuilder.java", "diffHunk": "@@ -51,8 +51,8 @@\n     /**\n      * Creates a new builder with the specified {@link RetryRuleWithContent}.\n      */\n-    RetryingClientBuilder(RetryRuleWithContent<HttpResponse> retryRuleWithContent) {\n-        super(retryRuleWithContent);\n+    RetryingClientBuilder(RetryRuleWithContent<HttpResponse> retryRuleWithHttpContent) {\n+        super(retryRuleWithHttpContent);", "originalCommit": "431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTg3Ng==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423501876", "bodyText": "Oops..", "author": "ikhoon", "createdAt": "2020-05-12T06:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5MTIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5MTM1NA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423491354", "bodyText": "Ditto", "author": "trustin", "createdAt": "2020-05-12T06:31:05Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryingRpcClient.java", "diffHunk": "@@ -38,23 +39,57 @@\n      * Creates a new {@link RpcClient} decorator that handles failures of an invocation and retries\n      * RPC requests.\n      *\n-     * @param retryRuleWithContent the retry rule\n+     * @param retryRuleWithRpcResponse the retry rule\n      */\n     public static Function<? super RpcClient, RetryingRpcClient>\n-    newDecorator(RetryRuleWithContent<RpcResponse> retryRuleWithContent) {\n-        return builder(retryRuleWithContent).newDecorator();\n+    newDecorator(RetryRuleWithContent<RpcResponse> retryRuleWithRpcResponse) {\n+        return builder(retryRuleWithRpcResponse).newDecorator();", "originalCommit": "431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5MTYyOQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423491629", "bodyText": "Revert?", "author": "trustin", "createdAt": "2020-05-12T06:31:41Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryingRpcClient.java", "diffHunk": "@@ -38,23 +39,57 @@\n      * Creates a new {@link RpcClient} decorator that handles failures of an invocation and retries\n      * RPC requests.\n      *\n-     * @param retryRuleWithContent the retry rule\n+     * @param retryRuleWithRpcResponse the retry rule\n      */\n     public static Function<? super RpcClient, RetryingRpcClient>\n-    newDecorator(RetryRuleWithContent<RpcResponse> retryRuleWithContent) {\n-        return builder(retryRuleWithContent).newDecorator();\n+    newDecorator(RetryRuleWithContent<RpcResponse> retryRuleWithRpcResponse) {\n+        return builder(retryRuleWithRpcResponse).newDecorator();\n     }\n \n     /**\n      * Creates a new {@link RpcClient} decorator that handles failures of an invocation and retries\n      * RPC requests.\n      *\n-     * @param retryRuleWithContent the retry rule\n+     * @param retryStrategyWithContent the retry strategy\n+     *\n+     * @deprecated Use {@link #newDecorator(RetryRuleWithContent)}.\n+     */\n+    @Deprecated\n+    public static Function<? super RpcClient, RetryingRpcClient>\n+    newDecorator(RetryStrategyWithContent<RpcResponse> retryStrategyWithContent) {\n+        requireNonNull(retryStrategyWithContent, \"retryStrategyWithContent\");\n+        return newDecorator((RetryRuleWithContent) RetryRuleUtil\n+                .fromRetryStrategyWithContent(retryStrategyWithContent));\n+    }\n+\n+    /**\n+     * Creates a new {@link RpcClient} decorator that handles failures of an invocation and retries\n+     * RPC requests.\n+     *\n+     * @param retryRuleWithRpcResponse the retry rule\n      * @param maxTotalAttempts the maximum number of total attempts\n      */\n     public static Function<? super RpcClient, RetryingRpcClient>\n-    newDecorator(RetryRuleWithContent<RpcResponse> retryRuleWithContent, int maxTotalAttempts) {\n-        return builder(retryRuleWithContent).maxTotalAttempts(maxTotalAttempts).newDecorator();\n+    newDecorator(RetryRuleWithContent<RpcResponse> retryRuleWithRpcResponse, int maxTotalAttempts) {", "originalCommit": "431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5Mjc4Nw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423492787", "bodyText": "HTTP methods - {@link #GET}, {@link #HEAD}, {@link #PUT} and {@link #DELETE}. ?", "author": "trustin", "createdAt": "2020-05-12T06:34:24Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpMethod.java", "diffHunk": "@@ -139,6 +140,14 @@ public static boolean isSupported(String value) {\n         return false;\n     }\n \n+    /**\n+     * Returns the <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n+     * HTTP methods.", "originalCommit": "431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5MzE3Nw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423493177", "bodyText": "Could be package-local?", "author": "trustin", "createdAt": "2020-05-12T06:35:16Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/AbstractRetryRuleBuilder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * An abstract builder class which creates a {@link RetryRule} or a {@link RetryRuleWithContent}.\n+ */\n+public abstract class AbstractRetryRuleBuilder {", "originalCommit": "431f0ed38dfaa5c9ca364b6e5b462aee710e557f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c14382f6deb058be885ecc7abeecc03570c5889e", "url": "https://github.com/line/armeria/commit/c14382f6deb058be885ecc7abeecc03570c5889e", "message": "Address comments by @trustin", "committedDate": "2020-05-12T07:09:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyMzQzOQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423523439", "bodyText": "Missing period in an exception message", "author": "trustin", "createdAt": "2020-05-12T07:36:08Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -200,18 +201,13 @@ static RetryRuleBuilder builder(Predicate<? super RequestHeaders> requestHeaders\n     /**\n      * Returns a {@link RetryRule} that combines the specified {@code retryRule} and {@code otherRules}.\n      */\n-    static RetryRule of(RetryRule retryRule, RetryRule... otherRules) {\n-        requireNonNull(retryRule, \"retryRule\");\n-        requireNonNull(otherRules, \"otherRules\");\n-        if (otherRules.length == 0) {\n-            return retryRule;\n+    static RetryRule of(RetryRule... retryRules) {\n+        requireNonNull(retryRules, \"retryRules\");\n+        checkArgument(retryRules.length > 0, \"retryRules can't be empty\");", "originalCommit": "c14382f6deb058be885ecc7abeecc03570c5889e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyMzQ3OQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423523479", "bodyText": "Missing period in an exception message", "author": "trustin", "createdAt": "2020-05-12T07:36:14Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -221,7 +217,7 @@ static RetryRule of(RetryRule retryRule, RetryRule... otherRules) {\n     @SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n     static RetryRule of(Iterable<? extends RetryRule> retryRules) {\n         requireNonNull(retryRules, \"retryRules\");\n-        checkArgument(!Iterables.isEmpty(retryRules), \"retryRules should not be empty\");\n+        checkArgument(!Iterables.isEmpty(retryRules), \"retryRules can't be empty\");", "originalCommit": "c14382f6deb058be885ecc7abeecc03570c5889e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyMzUwNA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423523504", "bodyText": "Missing period in an exception message", "author": "trustin", "createdAt": "2020-05-12T07:36:17Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleWithContent.java", "diffHunk": "@@ -72,6 +72,7 @@\n      */\n     static <T extends Response> RetryRuleWithContentBuilder<T> builder(Iterable<HttpMethod> methods) {\n         requireNonNull(methods, \"methods\");\n+        checkArgument(!Iterables.isEmpty(methods), \"methods can't be empty\");", "originalCommit": "c14382f6deb058be885ecc7abeecc03570c5889e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyMzUzOA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423523538", "bodyText": "Missing period in an exception message", "author": "trustin", "createdAt": "2020-05-12T07:36:22Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleWithContent.java", "diffHunk": "@@ -91,19 +92,13 @@\n      * {@code otherRules}.\n      */\n     @SafeVarargs\n-    static <T extends Response> RetryRuleWithContent<T> of(RetryRuleWithContent<T> retryRule,\n-                                                           RetryRuleWithContent<T>... otherRules) {\n-        requireNonNull(retryRule, \"retryRule\");\n-        requireNonNull(otherRules, \"otherRules\");\n-        if (otherRules.length == 0) {\n-            return retryRule;\n+    static <T extends Response> RetryRuleWithContent<T> of(RetryRuleWithContent<T>... retryRules) {\n+        requireNonNull(retryRules, \"retryRules\");\n+        checkArgument(retryRules.length > 0, \"retryRules can't be empty\");", "originalCommit": "c14382f6deb058be885ecc7abeecc03570c5889e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fbdce5cce366282974ef9cd173ba51c31c76766d", "url": "https://github.com/line/armeria/commit/fbdce5cce366282974ef9cd173ba51c31c76766d", "message": "Clean up Javadoc", "committedDate": "2020-05-12T07:42:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNDI5OQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423524299", "bodyText": "Could these constructors be package-local?", "author": "trustin", "createdAt": "2020-05-12T07:37:51Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/AbstractRetryingClientBuilder.java", "diffHunk": "@@ -39,46 +39,66 @@\n public abstract class AbstractRetryingClientBuilder<O extends Response> {\n \n     @Nullable\n-    private final RetryStrategy retryStrategy;\n+    private final RetryRule retryRule;\n \n     @Nullable\n-    private final RetryStrategyWithContent<O> retryStrategyWithContent;\n+    private final RetryRuleWithContent<O> retryRuleWithContent;\n \n     private int maxTotalAttempts = Flags.defaultMaxTotalAttempts();\n     private long responseTimeoutMillisForEachAttempt = Flags.defaultResponseTimeoutMillis();\n \n+    /**\n+     * Creates a new builder with the specified {@link RetryRule}.\n+     */\n+    protected AbstractRetryingClientBuilder(RetryRule retryRule) {\n+        this(requireNonNull(retryRule, \"retryRule\"), null);\n+    }\n+\n     /**\n      * Creates a new builder with the specified {@link RetryStrategy}.\n+     *\n+     * @deprecated Use {@link #AbstractRetryingClientBuilder(RetryRule)}.\n      */\n+    @Deprecated\n     protected AbstractRetryingClientBuilder(RetryStrategy retryStrategy) {\n-        this(requireNonNull(retryStrategy, \"retryStrategy\"), null);\n+        this(RetryRuleUtil.fromRetryStrategy(requireNonNull(retryStrategy, \"retryStrategy\")), null);\n+    }\n+\n+    /**\n+     * Creates a new builder with the specified {@link RetryRuleWithContent}.\n+     */\n+    protected AbstractRetryingClientBuilder(RetryRuleWithContent<O> retryRuleWithContent) {", "originalCommit": "c14382f6deb058be885ecc7abeecc03570c5889e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNDY5Nw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423524697", "bodyText": "A comma would be nice right after Otherwise", "author": "trustin", "createdAt": "2020-05-12T07:38:34Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.Streams;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * Determines whether a failed request should be retried.\n+ * If you need to determine by looking into the {@link Response}, use {@link RetryRuleWithContent}.\n+ */\n+@FunctionalInterface\n+public interface RetryRule {\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@link Backoff#ofDefault() default backoff} if the request HTTP method is\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n+     * and an {@link Exception} is raised or the class of the response status is\n+     * {@link HttpStatusClass#SERVER_ERROR}.\n+     * Otherwise an {@link UnprocessedRequestException} is raised regardless of the request HTTP method.", "originalCommit": "c14382f6deb058be885ecc7abeecc03570c5889e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNTM3MA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423525370", "bodyText": "How about renaming to RetryDecision for brevity?", "author": "trustin", "createdAt": "2020-05-12T07:39:50Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRuleDecision.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link RetryRuleDecision} that determines whether a {@link RetryRule} retries with a {@link Backoff},\n+ * skips the current {@link RetryRule} or no retries.\n+ */\n+public final class RetryRuleDecision {", "originalCommit": "c14382f6deb058be885ecc7abeecc03570c5889e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0MTA2OQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423541069", "bodyText": "The name is good to me. \ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-05-12T08:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNTM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNjg3Mg==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423526872", "bodyText": "Could be package-local?", "author": "trustin", "createdAt": "2020-05-12T07:42:29Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/AbstractRetryingClient.java", "diffHunk": "@@ -70,42 +70,68 @@\n             AttributeKey.valueOf(AbstractRetryingClient.class, \"STATE\");\n \n     @Nullable\n-    private final RetryStrategy retryStrategy;\n+    private final RetryRule retryRule;\n \n     @Nullable\n-    private final RetryStrategyWithContent<O> retryStrategyWithContent;\n+    private final RetryRuleWithContent<O> retryRuleWithContent;\n \n     private final int maxTotalAttempts;\n     private final long responseTimeoutMillisForEachAttempt;\n \n     /**\n      * Creates a new instance that decorates the specified {@link Client}.\n      */\n+    protected AbstractRetryingClient(Client<I, O> delegate, RetryRule retryRule,", "originalCommit": "c14382f6deb058be885ecc7abeecc03570c5889e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzMTIzNw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423531237", "bodyText": "OK, then will guide the deprecated constructor to use the builder of RetryingClient or RetryRpcClient?", "author": "ikhoon", "createdAt": "2020-05-12T07:50:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNjg3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNjgwNQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423536805", "bodyText": "Yes!", "author": "trustin", "createdAt": "2020-05-12T07:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNjg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNzIxOA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423527218", "bodyText": "Could be final?", "author": "trustin", "createdAt": "2020-05-12T07:43:06Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/AbstractRetryingClient.java", "diffHunk": "@@ -137,24 +163,46 @@ protected static void onRetryingComplete(ClientRequestContext ctx) {\n         ctx.logBuilder().endResponseWithLastChild();\n     }\n \n+    /**\n+     * Returns the {@link RetryRule}.\n+     *\n+     * @throws IllegalStateException if the {@link RetryRule} is not set\n+     */\n+    protected RetryRule retryRule() {\n+        checkState(retryRule != null, \"retryRule is not set.\");\n+        return retryRule;\n+    }\n+\n     /**\n      * Returns the {@link RetryStrategy}.\n      *\n      * @throws IllegalStateException if the {@link RetryStrategy} is not set\n+     * @deprecated Use {@link #retryRule()}.\n      */\n+    @Deprecated\n     protected RetryStrategy retryStrategy() {\n-        checkState(retryStrategy != null, \"retryStrategy is not set.\");\n-        return retryStrategy;\n+        return RetryRuleUtil.toRetryStrategy(retryRule());\n+    }\n+\n+    /**\n+     * Returns the {@link RetryRuleWithContent}.\n+     *\n+     * @throws IllegalStateException if the {@link RetryRuleWithContent} is not set\n+     */\n+    protected RetryRuleWithContent<O> retryRuleWithContent() {", "originalCommit": "c14382f6deb058be885ecc7abeecc03570c5889e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNzI1Mw==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423527253", "bodyText": "Could be final?", "author": "trustin", "createdAt": "2020-05-12T07:43:10Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/AbstractRetryingClient.java", "diffHunk": "@@ -137,24 +163,46 @@ protected static void onRetryingComplete(ClientRequestContext ctx) {\n         ctx.logBuilder().endResponseWithLastChild();\n     }\n \n+    /**\n+     * Returns the {@link RetryRule}.\n+     *\n+     * @throws IllegalStateException if the {@link RetryRule} is not set\n+     */\n+    protected RetryRule retryRule() {", "originalCommit": "c14382f6deb058be885ecc7abeecc03570c5889e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cd5a5e599465f156f33ed0b2236de8a5b03e1d16", "url": "https://github.com/line/armeria/commit/cd5a5e599465f156f33ed0b2236de8a5b03e1d16", "message": "Address comments by @trustin / Add missing period, Rename RetryRuleDecision to RetryDecision", "committedDate": "2020-05-12T08:21:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2ODAzMQ==", "url": "https://github.com/line/armeria/pull/2661#discussion_r423568031", "bodyText": "Thanks, @ikhoon \ud83d\ude47", "author": "trustin", "createdAt": "2020-05-12T08:48:07Z", "path": "zookeeper/src/main/java/com/linecorp/armeria/server/zookeeper/ZooKeeperUpdatingListenerBuilder.java", "diffHunk": "@@ -85,7 +85,7 @@\n     ZooKeeperUpdatingListenerBuilder(String zkConnectionStr, String zNodePath) {\n         super(zkConnectionStr);\n         this.zNodePath = zNodePath;\n-        checkArgument(!this.zNodePath.isEmpty(), \"zNodePath can't be empty\");\n+        checkArgument(!this.zNodePath.isEmpty(), \"zNodePath can't be empty.\");", "originalCommit": "cd5a5e599465f156f33ed0b2236de8a5b03e1d16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d0af943278dfdeb15b409e9a8398eab17674c82f", "url": "https://github.com/line/armeria/commit/d0af943278dfdeb15b409e9a8398eab17674c82f", "message": "Merge branch 'master' into retry-strategy-builder", "committedDate": "2020-05-12T08:56:15Z", "type": "commit"}, {"oid": "60782c52cf0ca56b77e06c5a4d3a085d2a33f9da", "url": "https://github.com/line/armeria/commit/60782c52cf0ca56b77e06c5a4d3a085d2a33f9da", "message": "Make constructors in AbstractRetryingClientBuilder package-private", "committedDate": "2020-05-12T09:03:55Z", "type": "commit"}, {"oid": "f11b0f828cd0de167bcabae06a2bff446d7bc692", "url": "https://github.com/line/armeria/commit/f11b0f828cd0de167bcabae06a2bff446d7bc692", "message": "Update copyright year to 2020 \ud83d\ude05", "committedDate": "2020-05-12T09:37:29Z", "type": "commit"}, {"oid": "f18d5dfd33170485d84332eff8cb33f40a662c5a", "url": "https://github.com/line/armeria/commit/f18d5dfd33170485d84332eff8cb33f40a662c5a", "message": "Fix broken test", "committedDate": "2020-05-13T01:45:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0MjEwMA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r424142100", "bodyText": "Remove", "author": "anuraaga", "createdAt": "2020-05-13T02:44:23Z", "path": "core/src/main/java/com/linecorp/armeria/client/retry/RetryRule.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.retry;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.Streams;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.UnprocessedRequestException;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.HttpStatusClass;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.Response;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+\n+/**\n+ * Determines whether a failed request should be retried.\n+ * If you need to determine by looking into the {@link Response}, use {@link RetryRuleWithContent}.\n+ */\n+@FunctionalInterface\n+public interface RetryRule {\n+\n+    /**\n+     * Returns a newly created {@link RetryRule} that will retry with the\n+     * {@link Backoff#ofDefault() default backoff} if the request HTTP method is\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Idempotent\">idempotent</a>\n+     * and an {@link Exception} is raised or the class of the response status is\n+     * {@link HttpStatusClass#SERVER_ERROR}.\n+     * Otherwise, an {@link UnprocessedRequestException} is raised regardless of the request HTTP method.\n+     *\n+     * <p>Note that a client can safely retry a failed request with this rule if an endpoint service produces\n+     * the same result (no side effects) on idempotent HTTP methods or {@link UnprocessedRequestException}.\n+     *\n+     * <p>This method is a shortcut for:\n+     * <pre>{@code\n+     * RetryRule.of(RetryRule.builder(HttpMethods.idempotentMethods())\n+     *                       .onIdempotentMethods()", "originalCommit": "f18d5dfd33170485d84332eff8cb33f40a662c5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NDU1OA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r424144558", "bodyText": "Oops... \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-05-13T02:54:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0MjEwMA=="}], "type": "inlineReview"}, {"oid": "375bc6963830bd4d47111d98d3f03cfd3fc00aa1", "url": "https://github.com/line/armeria/commit/375bc6963830bd4d47111d98d3f03cfd3fc00aa1", "message": "Address comments by @anuraaga", "committedDate": "2020-05-13T02:56:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwMjA1MA==", "url": "https://github.com/line/armeria/pull/2661#discussion_r424202050", "bodyText": "nit: an -> a", "author": "minwoox", "createdAt": "2020-05-13T06:33:52Z", "path": "site/src/sphinx/client-retry.rst", "diffHunk": "@@ -106,70 +117,38 @@ You can return a different :api:`Backoff` according to the response status.\n \n     import com.linecorp.armeria.common.HttpStatusClass;\n \n-    new RetryStrategy() {\n-        Backoff backoffOnServerErrorOrTimeout = Backoff.ofDefault();\n-        Backoff backoffOnConflict = Backoff.fixed(100);\n-\n-        @Override\n-        public CompletionStage<Backoff> shouldRetry(ClientRequestContext ctx,\n-                                                    @Nullable Throwable cause) {\n-            if (cause != null) {\n-                if (cause instanceof ResponseTimeoutException ||\n-                    cause instanceof UnprocessedRequestException) {\n-                    // The response timed out or the request has not been handled\n-                    // by the server.\n-                    return CompletableFuture.completedFuture(backoffOnServerErrorOrTimeout);\n-                }\n-            }\n-\n-            HttpStatus status = ctx.log().responseHeaders().status();\n-            if (status.codeClass() == HttpStatusClass.SERVER_ERROR) {\n-                return CompletableFuture.completedFuture(backoffOnServerErrorOrTimeout);\n-            } else if (status == HttpStatus.CONFLICT) {\n-                return CompletableFuture.completedFuture(backoffOnConflict);\n-            }\n-\n-            // Return null to stop retrying.\n-            return CompletableFuture.completedFuture(null);\n-        }\n-    };\n-\n-If you need to determine whether you need to retry by looking into the response content, you should implement\n-:api:`RetryStrategyWithContent` and specify it when you create an :api:`WebClient`\n+    Backoff backoffOnServerErrorOrTimeout = Backoff.ofDefault();\n+    Backoff backoffOnConflict = Backoff.fixed(100);\n+    RetryRule.onException(ex -> ex instanceof ResponseTimeoutException ||\n+                                ex instanceof UnprocessedRequestException)\n+             .thenBackoff(backoffOnServerErrorOrTimeout)\n+             .orElse(RetryRule.onStatusClass(HttpStatusClass.SERVER_ERROR)\n+                              .thenBackoff(backoffOnServerErrorOrTimeout))\n+             .orElse(RetryRule.onStatus(HttpStatus.CONFLICT).thenBackoff(backoffOnConflict));\n+\n+If you need to determine whether you need to retry by looking into the response content, you can build\n+:api:`RetryRuleWithContent` and specify it when you create an :api:`WebClient`", "originalCommit": "375bc6963830bd4d47111d98d3f03cfd3fc00aa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "62b044c412de29066bf6459f4767627474a1278d", "url": "https://github.com/line/armeria/commit/62b044c412de29066bf6459f4767627474a1278d", "message": "Address comments by @minwoox", "committedDate": "2020-05-13T06:42:44Z", "type": "commit"}]}