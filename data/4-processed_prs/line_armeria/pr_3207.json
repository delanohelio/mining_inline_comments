{"pr_number": 3207, "pr_title": "Add release note for 1.3.0", "pr_createdAt": "2020-11-30T07:40:51Z", "pr_url": "https://github.com/line/armeria/pull/3207", "timeline": [{"oid": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "url": "https://github.com/line/armeria/commit/ef7ce97643949b780c75ca33319ff29376cf9f0e", "message": "Add release note for 1.3.0", "committedDate": "2020-11-30T07:40:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5NzAyNw==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532397027", "bodyText": "Netty's `io_uring` transport is currently experimental, so you should be careful using this feature.", "author": "trustin", "createdAt": "2020-11-30T07:43:28Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5NzI5NQ==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532397295", "bodyText": "now not collected by default -> not collected anymore by default", "author": "trustin", "createdAt": "2020-11-30T07:44:03Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5Nzc1Mw==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532397753", "bodyText": "This is not a real example. Use a real service.\nCould we list the services that implement TransientService for users' convenience.", "author": "trustin", "createdAt": "2020-11-30T07:45:11Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5NzkxMQ==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532397911", "bodyText": "Hyperlink ScalaPB", "author": "trustin", "createdAt": "2020-11-30T07:45:31Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5ODA0OQ==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532398049", "bodyText": "an annotated service or annotated services\ncomma could be removed", "author": "trustin", "createdAt": "2020-11-30T07:45:54Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5ODM1OA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532398358", "bodyText": "HttpDeframer.of(...)", "author": "trustin", "createdAt": "2020-11-30T07:46:45Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5ODg3OA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532398878", "bodyText": "Example?", "author": "trustin", "createdAt": "2020-11-30T07:48:01Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQzOTgzNQ==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532439835", "bodyText": "How about? (I'm not 100% sure that this is a good example. \ud83d\ude05)\nHttpResponse response = ...\nSplitHttpResponse splitHttpResponse = response.split();\nCompletableFuture<ResponseHeaders> headersFuture = splitHttpResponse.headers();\nStreamMessage<HttpData> bodyStream = splitHttpResponse.body();\nheadersFuture.thenApply(headers -> {\n    if (headers.contentType() == MediaType.JSON_SEQ) {\n        // Subscribe to a stream of HttpData to JSON\n        Flux.from(bodyStream)\n            .map(httpData -> {\n                // Convert HttpData to your domain object\n            })\n            ...\n    } else {\n        // Aggregate a response body and use it.\n        Flux.from(splitHttpResponse.body())\n            .collectList()\n            ...\n    }\n});\nOr, remove the else part? Because the example is long a bit.\nHttpResponse response = ...\nSplitHttpResponse splitHttpResponse = response.split();\nCompletableFuture<ResponseHeaders> headersFuture = splitHttpResponse.headers();\nStreamMessage<HttpData> bodyStream = splitHttpResponse.body();\n\nheadersFuture.thenApply(headers -> {\n    if (headers.contentType() == MediaType.JSON_SEQ) {\n        // Subscribe to a stream of HttpData to JSON\n        Flux.from(bodyStream)\n            .map(httpData -> {\n                // Convert HttpData to your domain object\n            })\n            ...\n    }\n});", "author": "ikhoon", "createdAt": "2020-11-30T09:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5ODg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ3MTkwOA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532471908", "bodyText": "Thanks let me use that. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-11-30T09:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5ODg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5OTE0Mw==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532399143", "bodyText": "resolver -> resolver cache", "author": "trustin", "createdAt": "2020-11-30T07:48:40Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5OTIwOQ==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532399209", "bodyText": "fo -> for", "author": "trustin", "createdAt": "2020-11-30T07:48:50Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5OTM3Nw==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532399377", "bodyText": "A real example please", "author": "trustin", "createdAt": "2020-11-30T07:49:11Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ3Nzc4OA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532477788", "bodyText": "Copied from the documentation. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-11-30T10:06:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5OTM3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5MTkwOQ==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532491909", "bodyText": "Oops! Then could we update the documentation as well? \ud83d\ude05", "author": "trustin", "createdAt": "2020-11-30T10:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5OTM3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUyNDUxNw==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532524517", "bodyText": "Oops, I should've left the comment after I pushed the change. Sorry. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-11-30T11:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5OTM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5OTU4MQ==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532399581", "bodyText": "Global comment - No comma", "author": "trustin", "createdAt": "2020-11-30T07:49:41Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5OTg1MA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532399850", "bodyText": "build and execute", "author": "trustin", "createdAt": "2020-11-30T07:50:21Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5OTk5Nw==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532399997", "bodyText": "Example", "author": "trustin", "createdAt": "2020-11-30T07:50:37Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637, #3118", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMDM0NA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532400344", "bodyText": "List a few example meter IDs please", "author": "trustin", "createdAt": "2020-11-30T07:51:21Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637, #3118\n+- You can now use the custom Thrift protocol by using <type://ThriftProtocolFactoryProvider> and SPI. #3183\n+  ```java\n+  public class TTupleFactoryProvider extends ThriftProtocolFactoryProvider {\n+      @Override\n+      public Set<ThriftProtocolFactoryProvider.Entry> entries() {\n+          return ImmutableSet.of(new ThriftProtocolFactoryProvider.Entry(\n+                  SerializationFormat.of(\"ttuple\"), new TTupleProtocol.Factory()));\n+      }\n+  }\n+  ```\n+- You can now collect more detailed DNS metrics such as success or failure, query type, etc. #1887, #2935", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMDUyMQ==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532400521", "bodyText": "<type://DocService> ?", "author": "trustin", "createdAt": "2020-11-30T07:51:43Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637, #3118\n+- You can now use the custom Thrift protocol by using <type://ThriftProtocolFactoryProvider> and SPI. #3183\n+  ```java\n+  public class TTupleFactoryProvider extends ThriftProtocolFactoryProvider {\n+      @Override\n+      public Set<ThriftProtocolFactoryProvider.Entry> entries() {\n+          return ImmutableSet.of(new ThriftProtocolFactoryProvider.Entry(\n+                  SerializationFormat.of(\"ttuple\"), new TTupleProtocol.Factory()));\n+      }\n+  }\n+  ```\n+- You can now collect more detailed DNS metrics such as success or failure, query type, etc. #1887, #2935\n+- You can now customize the <type://HealthCheckService> when using Spring integration. #3144\n+  ```java\n+  @Bean\n+  public HealthCheckServiceConfigurator healthCheckServiceConfigurator() {\n+      return builder -> builder.updatable(true);\n+  }\n+  ```\n+- You can now use <type://RequestHeaders#acceptLanguage()> to choose language. #3177, #3179\n+## \ud83d\udcc8 Improvements\n+\n+- Various improvements for Doc service. #3149, #3150, #3167, #3188", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMTAzMQ==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532401031", "bodyText": "completable\nThis is shaded, so you don't have to list it here.", "author": "trustin", "createdAt": "2020-11-30T07:52:54Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637, #3118\n+- You can now use the custom Thrift protocol by using <type://ThriftProtocolFactoryProvider> and SPI. #3183\n+  ```java\n+  public class TTupleFactoryProvider extends ThriftProtocolFactoryProvider {\n+      @Override\n+      public Set<ThriftProtocolFactoryProvider.Entry> entries() {\n+          return ImmutableSet.of(new ThriftProtocolFactoryProvider.Entry(\n+                  SerializationFormat.of(\"ttuple\"), new TTupleProtocol.Factory()));\n+      }\n+  }\n+  ```\n+- You can now collect more detailed DNS metrics such as success or failure, query type, etc. #1887, #2935\n+- You can now customize the <type://HealthCheckService> when using Spring integration. #3144\n+  ```java\n+  @Bean\n+  public HealthCheckServiceConfigurator healthCheckServiceConfigurator() {\n+      return builder -> builder.updatable(true);\n+  }\n+  ```\n+- You can now use <type://RequestHeaders#acceptLanguage()> to choose language. #3177, #3179\n+## \ud83d\udcc8 Improvements\n+\n+- Various improvements for Doc service. #3149, #3150, #3167, #3188\n+\n+## \ud83d\udee0\ufe0f Bug fixes\n+- <type://HealthCheckedEndpointGroup#endpoints()> now returns healthy endpoints properly even when\n+  <type://EndpointGroup#orElse(EndpointGroup)> is used. #3181\n+- `ServletRequest.getProtocol()` now returns the proper value when using <type://TomcatService> and\n+  <type://JettyService>. #3194\n+- The route decorators are now evaluated in the reverse order they applied. #3160, #3166\n+- You now get the FORBIDDEN status if your service does not handle preflight requests regardless of\n+  route decorators. #3152\n+- A gRPC `ServerCall` is now closed exactly only once. #3153\n+- You no longer see `AnnotatedConnectException` when the <type://Endpoint> is created with an\n+  IPv6 scope ID. #3158, #3178\n+- Armeria server does not reject the request path whose first segment includes a colon anymore. #3154\n+\n+## \ud83c\udfda\ufe0f Deprecations\n+- <type://CircuitBreakerClient#newPerHostAndMethodDecorator(BiFunction,CircuitBreakerRule)> is now deprecated.\n+  #31356\n+  - Use <type://CircuitBreakerClient#newDecorator(CircuitBreakerMapping,CircuitBreakerRule)> with the customized\n+    <type://CircuitBreakerMapping> using <type://CircuitBreakerMapping#builder()>.\n+- The response timeout and max total attempts setters in <type://RetryingClientBuilder> is now deprecated.\n+  #3128 #3145\n+  - The static factory methods that take those parameters in <type://RetryingClient> are now deprecated as well.\n+  - Use <type://RetryConfigMapping> and <type://RetryConfig>.\n+- <type://Route#apply(RoutingContext)?full> is deprecated. #3152\n+  - Use <type://Route#apply(RoutingContext,boolean)?full>.\n+- The constructor of <type://PrometheusExpositionService> is now deprecated. #3081\n+  - Use <type://PrometheusExpositionService#of(CollectorRegistry)>.\n+\n+## \u2622\ufe0f Breaking changes\n+\n+- N/A\n+\n+## \u26d3 Dependencies\n+\n+- completalbe-futures 0.3.3 \u2192 0.3.4", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMTE3Mg==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532401172", "bodyText": "Dropwizard", "author": "trustin", "createdAt": "2020-11-30T07:53:13Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637, #3118\n+- You can now use the custom Thrift protocol by using <type://ThriftProtocolFactoryProvider> and SPI. #3183\n+  ```java\n+  public class TTupleFactoryProvider extends ThriftProtocolFactoryProvider {\n+      @Override\n+      public Set<ThriftProtocolFactoryProvider.Entry> entries() {\n+          return ImmutableSet.of(new ThriftProtocolFactoryProvider.Entry(\n+                  SerializationFormat.of(\"ttuple\"), new TTupleProtocol.Factory()));\n+      }\n+  }\n+  ```\n+- You can now collect more detailed DNS metrics such as success or failure, query type, etc. #1887, #2935\n+- You can now customize the <type://HealthCheckService> when using Spring integration. #3144\n+  ```java\n+  @Bean\n+  public HealthCheckServiceConfigurator healthCheckServiceConfigurator() {\n+      return builder -> builder.updatable(true);\n+  }\n+  ```\n+- You can now use <type://RequestHeaders#acceptLanguage()> to choose language. #3177, #3179\n+## \ud83d\udcc8 Improvements\n+\n+- Various improvements for Doc service. #3149, #3150, #3167, #3188\n+\n+## \ud83d\udee0\ufe0f Bug fixes\n+- <type://HealthCheckedEndpointGroup#endpoints()> now returns healthy endpoints properly even when\n+  <type://EndpointGroup#orElse(EndpointGroup)> is used. #3181\n+- `ServletRequest.getProtocol()` now returns the proper value when using <type://TomcatService> and\n+  <type://JettyService>. #3194\n+- The route decorators are now evaluated in the reverse order they applied. #3160, #3166\n+- You now get the FORBIDDEN status if your service does not handle preflight requests regardless of\n+  route decorators. #3152\n+- A gRPC `ServerCall` is now closed exactly only once. #3153\n+- You no longer see `AnnotatedConnectException` when the <type://Endpoint> is created with an\n+  IPv6 scope ID. #3158, #3178\n+- Armeria server does not reject the request path whose first segment includes a colon anymore. #3154\n+\n+## \ud83c\udfda\ufe0f Deprecations\n+- <type://CircuitBreakerClient#newPerHostAndMethodDecorator(BiFunction,CircuitBreakerRule)> is now deprecated.\n+  #31356\n+  - Use <type://CircuitBreakerClient#newDecorator(CircuitBreakerMapping,CircuitBreakerRule)> with the customized\n+    <type://CircuitBreakerMapping> using <type://CircuitBreakerMapping#builder()>.\n+- The response timeout and max total attempts setters in <type://RetryingClientBuilder> is now deprecated.\n+  #3128 #3145\n+  - The static factory methods that take those parameters in <type://RetryingClient> are now deprecated as well.\n+  - Use <type://RetryConfigMapping> and <type://RetryConfig>.\n+- <type://Route#apply(RoutingContext)?full> is deprecated. #3152\n+  - Use <type://Route#apply(RoutingContext,boolean)?full>.\n+- The constructor of <type://PrometheusExpositionService> is now deprecated. #3081\n+  - Use <type://PrometheusExpositionService#of(CollectorRegistry)>.\n+\n+## \u2622\ufe0f Breaking changes\n+\n+- N/A\n+\n+## \u26d3 Dependencies\n+\n+- completalbe-futures 0.3.3 \u2192 0.3.4\n+- dropwizard-core 2.0.13 \u2192 2.0.16", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMTI3Nw==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532401277", "bodyText": "Dropwizard Metrics", "author": "trustin", "createdAt": "2020-11-30T07:53:29Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637, #3118\n+- You can now use the custom Thrift protocol by using <type://ThriftProtocolFactoryProvider> and SPI. #3183\n+  ```java\n+  public class TTupleFactoryProvider extends ThriftProtocolFactoryProvider {\n+      @Override\n+      public Set<ThriftProtocolFactoryProvider.Entry> entries() {\n+          return ImmutableSet.of(new ThriftProtocolFactoryProvider.Entry(\n+                  SerializationFormat.of(\"ttuple\"), new TTupleProtocol.Factory()));\n+      }\n+  }\n+  ```\n+- You can now collect more detailed DNS metrics such as success or failure, query type, etc. #1887, #2935\n+- You can now customize the <type://HealthCheckService> when using Spring integration. #3144\n+  ```java\n+  @Bean\n+  public HealthCheckServiceConfigurator healthCheckServiceConfigurator() {\n+      return builder -> builder.updatable(true);\n+  }\n+  ```\n+- You can now use <type://RequestHeaders#acceptLanguage()> to choose language. #3177, #3179\n+## \ud83d\udcc8 Improvements\n+\n+- Various improvements for Doc service. #3149, #3150, #3167, #3188\n+\n+## \ud83d\udee0\ufe0f Bug fixes\n+- <type://HealthCheckedEndpointGroup#endpoints()> now returns healthy endpoints properly even when\n+  <type://EndpointGroup#orElse(EndpointGroup)> is used. #3181\n+- `ServletRequest.getProtocol()` now returns the proper value when using <type://TomcatService> and\n+  <type://JettyService>. #3194\n+- The route decorators are now evaluated in the reverse order they applied. #3160, #3166\n+- You now get the FORBIDDEN status if your service does not handle preflight requests regardless of\n+  route decorators. #3152\n+- A gRPC `ServerCall` is now closed exactly only once. #3153\n+- You no longer see `AnnotatedConnectException` when the <type://Endpoint> is created with an\n+  IPv6 scope ID. #3158, #3178\n+- Armeria server does not reject the request path whose first segment includes a colon anymore. #3154\n+\n+## \ud83c\udfda\ufe0f Deprecations\n+- <type://CircuitBreakerClient#newPerHostAndMethodDecorator(BiFunction,CircuitBreakerRule)> is now deprecated.\n+  #31356\n+  - Use <type://CircuitBreakerClient#newDecorator(CircuitBreakerMapping,CircuitBreakerRule)> with the customized\n+    <type://CircuitBreakerMapping> using <type://CircuitBreakerMapping#builder()>.\n+- The response timeout and max total attempts setters in <type://RetryingClientBuilder> is now deprecated.\n+  #3128 #3145\n+  - The static factory methods that take those parameters in <type://RetryingClient> are now deprecated as well.\n+  - Use <type://RetryConfigMapping> and <type://RetryConfig>.\n+- <type://Route#apply(RoutingContext)?full> is deprecated. #3152\n+  - Use <type://Route#apply(RoutingContext,boolean)?full>.\n+- The constructor of <type://PrometheusExpositionService> is now deprecated. #3081\n+  - Use <type://PrometheusExpositionService#of(CollectorRegistry)>.\n+\n+## \u2622\ufe0f Breaking changes\n+\n+- N/A\n+\n+## \u26d3 Dependencies\n+\n+- completalbe-futures 0.3.3 \u2192 0.3.4\n+- dropwizard-core 2.0.13 \u2192 2.0.16\n+- Fastutil 8.4.2 \u2192 8.4.3\n+- gRPC 1.33.0 \u2192 1.33.1\n+- grpc-kotlin-stub 0.2.0 \u2192 0.2.1\n+- io.dropwizard.metrics 4.1.13 \u2192 4.1.15", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMTMzNA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532401334", "bodyText": "JCTools", "author": "trustin", "createdAt": "2020-11-30T07:53:36Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637, #3118\n+- You can now use the custom Thrift protocol by using <type://ThriftProtocolFactoryProvider> and SPI. #3183\n+  ```java\n+  public class TTupleFactoryProvider extends ThriftProtocolFactoryProvider {\n+      @Override\n+      public Set<ThriftProtocolFactoryProvider.Entry> entries() {\n+          return ImmutableSet.of(new ThriftProtocolFactoryProvider.Entry(\n+                  SerializationFormat.of(\"ttuple\"), new TTupleProtocol.Factory()));\n+      }\n+  }\n+  ```\n+- You can now collect more detailed DNS metrics such as success or failure, query type, etc. #1887, #2935\n+- You can now customize the <type://HealthCheckService> when using Spring integration. #3144\n+  ```java\n+  @Bean\n+  public HealthCheckServiceConfigurator healthCheckServiceConfigurator() {\n+      return builder -> builder.updatable(true);\n+  }\n+  ```\n+- You can now use <type://RequestHeaders#acceptLanguage()> to choose language. #3177, #3179\n+## \ud83d\udcc8 Improvements\n+\n+- Various improvements for Doc service. #3149, #3150, #3167, #3188\n+\n+## \ud83d\udee0\ufe0f Bug fixes\n+- <type://HealthCheckedEndpointGroup#endpoints()> now returns healthy endpoints properly even when\n+  <type://EndpointGroup#orElse(EndpointGroup)> is used. #3181\n+- `ServletRequest.getProtocol()` now returns the proper value when using <type://TomcatService> and\n+  <type://JettyService>. #3194\n+- The route decorators are now evaluated in the reverse order they applied. #3160, #3166\n+- You now get the FORBIDDEN status if your service does not handle preflight requests regardless of\n+  route decorators. #3152\n+- A gRPC `ServerCall` is now closed exactly only once. #3153\n+- You no longer see `AnnotatedConnectException` when the <type://Endpoint> is created with an\n+  IPv6 scope ID. #3158, #3178\n+- Armeria server does not reject the request path whose first segment includes a colon anymore. #3154\n+\n+## \ud83c\udfda\ufe0f Deprecations\n+- <type://CircuitBreakerClient#newPerHostAndMethodDecorator(BiFunction,CircuitBreakerRule)> is now deprecated.\n+  #31356\n+  - Use <type://CircuitBreakerClient#newDecorator(CircuitBreakerMapping,CircuitBreakerRule)> with the customized\n+    <type://CircuitBreakerMapping> using <type://CircuitBreakerMapping#builder()>.\n+- The response timeout and max total attempts setters in <type://RetryingClientBuilder> is now deprecated.\n+  #3128 #3145\n+  - The static factory methods that take those parameters in <type://RetryingClient> are now deprecated as well.\n+  - Use <type://RetryConfigMapping> and <type://RetryConfig>.\n+- <type://Route#apply(RoutingContext)?full> is deprecated. #3152\n+  - Use <type://Route#apply(RoutingContext,boolean)?full>.\n+- The constructor of <type://PrometheusExpositionService> is now deprecated. #3081\n+  - Use <type://PrometheusExpositionService#of(CollectorRegistry)>.\n+\n+## \u2622\ufe0f Breaking changes\n+\n+- N/A\n+\n+## \u26d3 Dependencies\n+\n+- completalbe-futures 0.3.3 \u2192 0.3.4\n+- dropwizard-core 2.0.13 \u2192 2.0.16\n+- Fastutil 8.4.2 \u2192 8.4.3\n+- gRPC 1.33.0 \u2192 1.33.1\n+- grpc-kotlin-stub 0.2.0 \u2192 0.2.1\n+- io.dropwizard.metrics 4.1.13 \u2192 4.1.15\n+- Jackson 2.11.2 \u2192 2.12.0\n+- Jctools 3.1.0 \u2192 3.2.0", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMTU5NA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532401594", "bodyText": "Could you add some details about this? We moved from jakartaee to javax.", "author": "trustin", "createdAt": "2020-11-30T07:54:12Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637, #3118\n+- You can now use the custom Thrift protocol by using <type://ThriftProtocolFactoryProvider> and SPI. #3183\n+  ```java\n+  public class TTupleFactoryProvider extends ThriftProtocolFactoryProvider {\n+      @Override\n+      public Set<ThriftProtocolFactoryProvider.Entry> entries() {\n+          return ImmutableSet.of(new ThriftProtocolFactoryProvider.Entry(\n+                  SerializationFormat.of(\"ttuple\"), new TTupleProtocol.Factory()));\n+      }\n+  }\n+  ```\n+- You can now collect more detailed DNS metrics such as success or failure, query type, etc. #1887, #2935\n+- You can now customize the <type://HealthCheckService> when using Spring integration. #3144\n+  ```java\n+  @Bean\n+  public HealthCheckServiceConfigurator healthCheckServiceConfigurator() {\n+      return builder -> builder.updatable(true);\n+  }\n+  ```\n+- You can now use <type://RequestHeaders#acceptLanguage()> to choose language. #3177, #3179\n+## \ud83d\udcc8 Improvements\n+\n+- Various improvements for Doc service. #3149, #3150, #3167, #3188\n+\n+## \ud83d\udee0\ufe0f Bug fixes\n+- <type://HealthCheckedEndpointGroup#endpoints()> now returns healthy endpoints properly even when\n+  <type://EndpointGroup#orElse(EndpointGroup)> is used. #3181\n+- `ServletRequest.getProtocol()` now returns the proper value when using <type://TomcatService> and\n+  <type://JettyService>. #3194\n+- The route decorators are now evaluated in the reverse order they applied. #3160, #3166\n+- You now get the FORBIDDEN status if your service does not handle preflight requests regardless of\n+  route decorators. #3152\n+- A gRPC `ServerCall` is now closed exactly only once. #3153\n+- You no longer see `AnnotatedConnectException` when the <type://Endpoint> is created with an\n+  IPv6 scope ID. #3158, #3178\n+- Armeria server does not reject the request path whose first segment includes a colon anymore. #3154\n+\n+## \ud83c\udfda\ufe0f Deprecations\n+- <type://CircuitBreakerClient#newPerHostAndMethodDecorator(BiFunction,CircuitBreakerRule)> is now deprecated.\n+  #31356\n+  - Use <type://CircuitBreakerClient#newDecorator(CircuitBreakerMapping,CircuitBreakerRule)> with the customized\n+    <type://CircuitBreakerMapping> using <type://CircuitBreakerMapping#builder()>.\n+- The response timeout and max total attempts setters in <type://RetryingClientBuilder> is now deprecated.\n+  #3128 #3145\n+  - The static factory methods that take those parameters in <type://RetryingClient> are now deprecated as well.\n+  - Use <type://RetryConfigMapping> and <type://RetryConfig>.\n+- <type://Route#apply(RoutingContext)?full> is deprecated. #3152\n+  - Use <type://Route#apply(RoutingContext,boolean)?full>.\n+- The constructor of <type://PrometheusExpositionService> is now deprecated. #3081\n+  - Use <type://PrometheusExpositionService#of(CollectorRegistry)>.\n+\n+## \u2622\ufe0f Breaking changes\n+\n+- N/A\n+\n+## \u26d3 Dependencies\n+\n+- completalbe-futures 0.3.3 \u2192 0.3.4\n+- dropwizard-core 2.0.13 \u2192 2.0.16\n+- Fastutil 8.4.2 \u2192 8.4.3\n+- gRPC 1.33.0 \u2192 1.33.1\n+- grpc-kotlin-stub 0.2.0 \u2192 0.2.1\n+- io.dropwizard.metrics 4.1.13 \u2192 4.1.15\n+- Jackson 2.11.2 \u2192 2.12.0\n+- Jctools 3.1.0 \u2192 3.2.0\n+- javax.annotation-api 1.3.2", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMTc2Ng==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532401766", "bodyText": "BouncyCastle", "author": "trustin", "createdAt": "2020-11-30T07:54:33Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637, #3118\n+- You can now use the custom Thrift protocol by using <type://ThriftProtocolFactoryProvider> and SPI. #3183\n+  ```java\n+  public class TTupleFactoryProvider extends ThriftProtocolFactoryProvider {\n+      @Override\n+      public Set<ThriftProtocolFactoryProvider.Entry> entries() {\n+          return ImmutableSet.of(new ThriftProtocolFactoryProvider.Entry(\n+                  SerializationFormat.of(\"ttuple\"), new TTupleProtocol.Factory()));\n+      }\n+  }\n+  ```\n+- You can now collect more detailed DNS metrics such as success or failure, query type, etc. #1887, #2935\n+- You can now customize the <type://HealthCheckService> when using Spring integration. #3144\n+  ```java\n+  @Bean\n+  public HealthCheckServiceConfigurator healthCheckServiceConfigurator() {\n+      return builder -> builder.updatable(true);\n+  }\n+  ```\n+- You can now use <type://RequestHeaders#acceptLanguage()> to choose language. #3177, #3179\n+## \ud83d\udcc8 Improvements\n+\n+- Various improvements for Doc service. #3149, #3150, #3167, #3188\n+\n+## \ud83d\udee0\ufe0f Bug fixes\n+- <type://HealthCheckedEndpointGroup#endpoints()> now returns healthy endpoints properly even when\n+  <type://EndpointGroup#orElse(EndpointGroup)> is used. #3181\n+- `ServletRequest.getProtocol()` now returns the proper value when using <type://TomcatService> and\n+  <type://JettyService>. #3194\n+- The route decorators are now evaluated in the reverse order they applied. #3160, #3166\n+- You now get the FORBIDDEN status if your service does not handle preflight requests regardless of\n+  route decorators. #3152\n+- A gRPC `ServerCall` is now closed exactly only once. #3153\n+- You no longer see `AnnotatedConnectException` when the <type://Endpoint> is created with an\n+  IPv6 scope ID. #3158, #3178\n+- Armeria server does not reject the request path whose first segment includes a colon anymore. #3154\n+\n+## \ud83c\udfda\ufe0f Deprecations\n+- <type://CircuitBreakerClient#newPerHostAndMethodDecorator(BiFunction,CircuitBreakerRule)> is now deprecated.\n+  #31356\n+  - Use <type://CircuitBreakerClient#newDecorator(CircuitBreakerMapping,CircuitBreakerRule)> with the customized\n+    <type://CircuitBreakerMapping> using <type://CircuitBreakerMapping#builder()>.\n+- The response timeout and max total attempts setters in <type://RetryingClientBuilder> is now deprecated.\n+  #3128 #3145\n+  - The static factory methods that take those parameters in <type://RetryingClient> are now deprecated as well.\n+  - Use <type://RetryConfigMapping> and <type://RetryConfig>.\n+- <type://Route#apply(RoutingContext)?full> is deprecated. #3152\n+  - Use <type://Route#apply(RoutingContext,boolean)?full>.\n+- The constructor of <type://PrometheusExpositionService> is now deprecated. #3081\n+  - Use <type://PrometheusExpositionService#of(CollectorRegistry)>.\n+\n+## \u2622\ufe0f Breaking changes\n+\n+- N/A\n+\n+## \u26d3 Dependencies\n+\n+- completalbe-futures 0.3.3 \u2192 0.3.4\n+- dropwizard-core 2.0.13 \u2192 2.0.16\n+- Fastutil 8.4.2 \u2192 8.4.3\n+- gRPC 1.33.0 \u2192 1.33.1\n+- grpc-kotlin-stub 0.2.0 \u2192 0.2.1\n+- io.dropwizard.metrics 4.1.13 \u2192 4.1.15\n+- Jackson 2.11.2 \u2192 2.12.0\n+- Jctools 3.1.0 \u2192 3.2.0\n+- javax.annotation-api 1.3.2\n+- Micrometer 1.5.5 \u2192 1.6.1\n+- Netty 4.1.53.Final \u2192 4.1.54.Final\n+- org.bouncycastle 1.66 \u2192 1.67", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjIwNA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532402204", "bodyText": "You want to add RELEASE or not? How about removing them from both sides for consistency?", "author": "trustin", "createdAt": "2020-11-30T07:55:26Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637, #3118\n+- You can now use the custom Thrift protocol by using <type://ThriftProtocolFactoryProvider> and SPI. #3183\n+  ```java\n+  public class TTupleFactoryProvider extends ThriftProtocolFactoryProvider {\n+      @Override\n+      public Set<ThriftProtocolFactoryProvider.Entry> entries() {\n+          return ImmutableSet.of(new ThriftProtocolFactoryProvider.Entry(\n+                  SerializationFormat.of(\"ttuple\"), new TTupleProtocol.Factory()));\n+      }\n+  }\n+  ```\n+- You can now collect more detailed DNS metrics such as success or failure, query type, etc. #1887, #2935\n+- You can now customize the <type://HealthCheckService> when using Spring integration. #3144\n+  ```java\n+  @Bean\n+  public HealthCheckServiceConfigurator healthCheckServiceConfigurator() {\n+      return builder -> builder.updatable(true);\n+  }\n+  ```\n+- You can now use <type://RequestHeaders#acceptLanguage()> to choose language. #3177, #3179\n+## \ud83d\udcc8 Improvements\n+\n+- Various improvements for Doc service. #3149, #3150, #3167, #3188\n+\n+## \ud83d\udee0\ufe0f Bug fixes\n+- <type://HealthCheckedEndpointGroup#endpoints()> now returns healthy endpoints properly even when\n+  <type://EndpointGroup#orElse(EndpointGroup)> is used. #3181\n+- `ServletRequest.getProtocol()` now returns the proper value when using <type://TomcatService> and\n+  <type://JettyService>. #3194\n+- The route decorators are now evaluated in the reverse order they applied. #3160, #3166\n+- You now get the FORBIDDEN status if your service does not handle preflight requests regardless of\n+  route decorators. #3152\n+- A gRPC `ServerCall` is now closed exactly only once. #3153\n+- You no longer see `AnnotatedConnectException` when the <type://Endpoint> is created with an\n+  IPv6 scope ID. #3158, #3178\n+- Armeria server does not reject the request path whose first segment includes a colon anymore. #3154\n+\n+## \ud83c\udfda\ufe0f Deprecations\n+- <type://CircuitBreakerClient#newPerHostAndMethodDecorator(BiFunction,CircuitBreakerRule)> is now deprecated.\n+  #31356\n+  - Use <type://CircuitBreakerClient#newDecorator(CircuitBreakerMapping,CircuitBreakerRule)> with the customized\n+    <type://CircuitBreakerMapping> using <type://CircuitBreakerMapping#builder()>.\n+- The response timeout and max total attempts setters in <type://RetryingClientBuilder> is now deprecated.\n+  #3128 #3145\n+  - The static factory methods that take those parameters in <type://RetryingClient> are now deprecated as well.\n+  - Use <type://RetryConfigMapping> and <type://RetryConfig>.\n+- <type://Route#apply(RoutingContext)?full> is deprecated. #3152\n+  - Use <type://Route#apply(RoutingContext,boolean)?full>.\n+- The constructor of <type://PrometheusExpositionService> is now deprecated. #3081\n+  - Use <type://PrometheusExpositionService#of(CollectorRegistry)>.\n+\n+## \u2622\ufe0f Breaking changes\n+\n+- N/A\n+\n+## \u26d3 Dependencies\n+\n+- completalbe-futures 0.3.3 \u2192 0.3.4\n+- dropwizard-core 2.0.13 \u2192 2.0.16\n+- Fastutil 8.4.2 \u2192 8.4.3\n+- gRPC 1.33.0 \u2192 1.33.1\n+- grpc-kotlin-stub 0.2.0 \u2192 0.2.1\n+- io.dropwizard.metrics 4.1.13 \u2192 4.1.15\n+- Jackson 2.11.2 \u2192 2.12.0\n+- Jctools 3.1.0 \u2192 3.2.0\n+- javax.annotation-api 1.3.2\n+- Micrometer 1.5.5 \u2192 1.6.1\n+- Netty 4.1.53.Final \u2192 4.1.54.Final\n+- org.bouncycastle 1.66 \u2192 1.67\n+- Reactor 3.3.10.RELEASE \u2192 3.4.0\n+- Spring Boot 2.3.4.RELEASE \u2192 2.4.0\n+- Spring 5.2.9.RELEASE \u2192 5.3.1", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwNTkxMg==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532405912", "bodyText": "Spring Boot removed RELEASE from the artifact name since 2.4.0.\nhttps://search.maven.org/artifact/org.springframework.boot/spring-boot-starter-jdbc\nI agree that we don't need to write the detail.", "author": "ikhoon", "createdAt": "2020-11-30T08:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwNzIyMg==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532407222", "bodyText": "By the way, we specified the Netty version from the artifact version.", "author": "ikhoon", "createdAt": "2020-11-30T08:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ2ODc1NA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532468754", "bodyText": "Can't we just use what they are using?", "author": "minwoox", "createdAt": "2020-11-30T09:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5MjI2MQ==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532492261", "bodyText": "I'm fine with either.", "author": "trustin", "createdAt": "2020-11-30T10:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjI1MA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532402250", "bodyText": "Tomcat", "author": "trustin", "createdAt": "2020-11-30T07:55:33Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637, #3118\n+- You can now use the custom Thrift protocol by using <type://ThriftProtocolFactoryProvider> and SPI. #3183\n+  ```java\n+  public class TTupleFactoryProvider extends ThriftProtocolFactoryProvider {\n+      @Override\n+      public Set<ThriftProtocolFactoryProvider.Entry> entries() {\n+          return ImmutableSet.of(new ThriftProtocolFactoryProvider.Entry(\n+                  SerializationFormat.of(\"ttuple\"), new TTupleProtocol.Factory()));\n+      }\n+  }\n+  ```\n+- You can now collect more detailed DNS metrics such as success or failure, query type, etc. #1887, #2935\n+- You can now customize the <type://HealthCheckService> when using Spring integration. #3144\n+  ```java\n+  @Bean\n+  public HealthCheckServiceConfigurator healthCheckServiceConfigurator() {\n+      return builder -> builder.updatable(true);\n+  }\n+  ```\n+- You can now use <type://RequestHeaders#acceptLanguage()> to choose language. #3177, #3179\n+## \ud83d\udcc8 Improvements\n+\n+- Various improvements for Doc service. #3149, #3150, #3167, #3188\n+\n+## \ud83d\udee0\ufe0f Bug fixes\n+- <type://HealthCheckedEndpointGroup#endpoints()> now returns healthy endpoints properly even when\n+  <type://EndpointGroup#orElse(EndpointGroup)> is used. #3181\n+- `ServletRequest.getProtocol()` now returns the proper value when using <type://TomcatService> and\n+  <type://JettyService>. #3194\n+- The route decorators are now evaluated in the reverse order they applied. #3160, #3166\n+- You now get the FORBIDDEN status if your service does not handle preflight requests regardless of\n+  route decorators. #3152\n+- A gRPC `ServerCall` is now closed exactly only once. #3153\n+- You no longer see `AnnotatedConnectException` when the <type://Endpoint> is created with an\n+  IPv6 scope ID. #3158, #3178\n+- Armeria server does not reject the request path whose first segment includes a colon anymore. #3154\n+\n+## \ud83c\udfda\ufe0f Deprecations\n+- <type://CircuitBreakerClient#newPerHostAndMethodDecorator(BiFunction,CircuitBreakerRule)> is now deprecated.\n+  #31356\n+  - Use <type://CircuitBreakerClient#newDecorator(CircuitBreakerMapping,CircuitBreakerRule)> with the customized\n+    <type://CircuitBreakerMapping> using <type://CircuitBreakerMapping#builder()>.\n+- The response timeout and max total attempts setters in <type://RetryingClientBuilder> is now deprecated.\n+  #3128 #3145\n+  - The static factory methods that take those parameters in <type://RetryingClient> are now deprecated as well.\n+  - Use <type://RetryConfigMapping> and <type://RetryConfig>.\n+- <type://Route#apply(RoutingContext)?full> is deprecated. #3152\n+  - Use <type://Route#apply(RoutingContext,boolean)?full>.\n+- The constructor of <type://PrometheusExpositionService> is now deprecated. #3081\n+  - Use <type://PrometheusExpositionService#of(CollectorRegistry)>.\n+\n+## \u2622\ufe0f Breaking changes\n+\n+- N/A\n+\n+## \u26d3 Dependencies\n+\n+- completalbe-futures 0.3.3 \u2192 0.3.4\n+- dropwizard-core 2.0.13 \u2192 2.0.16\n+- Fastutil 8.4.2 \u2192 8.4.3\n+- gRPC 1.33.0 \u2192 1.33.1\n+- grpc-kotlin-stub 0.2.0 \u2192 0.2.1\n+- io.dropwizard.metrics 4.1.13 \u2192 4.1.15\n+- Jackson 2.11.2 \u2192 2.12.0\n+- Jctools 3.1.0 \u2192 3.2.0\n+- javax.annotation-api 1.3.2\n+- Micrometer 1.5.5 \u2192 1.6.1\n+- Netty 4.1.53.Final \u2192 4.1.54.Final\n+- org.bouncycastle 1.66 \u2192 1.67\n+- Reactor 3.3.10.RELEASE \u2192 3.4.0\n+- Spring Boot 2.3.4.RELEASE \u2192 2.4.0\n+- Spring 5.2.9.RELEASE \u2192 5.3.1\n+- tomcat-embed-core 9.0.39 \u2192 9.0.40", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM5ODU4Nw==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532398587", "bodyText": "?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Spring 5.2.9.RELEASE \u2192 5.3.1\n          \n          \n            \n            - Spring 5.2.9.RELEASE \u2192 5.3.1.RELEASE", "author": "ikhoon", "createdAt": "2020-11-30T07:47:15Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637, #3118\n+- You can now use the custom Thrift protocol by using <type://ThriftProtocolFactoryProvider> and SPI. #3183\n+  ```java\n+  public class TTupleFactoryProvider extends ThriftProtocolFactoryProvider {\n+      @Override\n+      public Set<ThriftProtocolFactoryProvider.Entry> entries() {\n+          return ImmutableSet.of(new ThriftProtocolFactoryProvider.Entry(\n+                  SerializationFormat.of(\"ttuple\"), new TTupleProtocol.Factory()));\n+      }\n+  }\n+  ```\n+- You can now collect more detailed DNS metrics such as success or failure, query type, etc. #1887, #2935\n+- You can now customize the <type://HealthCheckService> when using Spring integration. #3144\n+  ```java\n+  @Bean\n+  public HealthCheckServiceConfigurator healthCheckServiceConfigurator() {\n+      return builder -> builder.updatable(true);\n+  }\n+  ```\n+- You can now use <type://RequestHeaders#acceptLanguage()> to choose language. #3177, #3179\n+## \ud83d\udcc8 Improvements\n+\n+- Various improvements for Doc service. #3149, #3150, #3167, #3188\n+\n+## \ud83d\udee0\ufe0f Bug fixes\n+- <type://HealthCheckedEndpointGroup#endpoints()> now returns healthy endpoints properly even when\n+  <type://EndpointGroup#orElse(EndpointGroup)> is used. #3181\n+- `ServletRequest.getProtocol()` now returns the proper value when using <type://TomcatService> and\n+  <type://JettyService>. #3194\n+- The route decorators are now evaluated in the reverse order they applied. #3160, #3166\n+- You now get the FORBIDDEN status if your service does not handle preflight requests regardless of\n+  route decorators. #3152\n+- A gRPC `ServerCall` is now closed exactly only once. #3153\n+- You no longer see `AnnotatedConnectException` when the <type://Endpoint> is created with an\n+  IPv6 scope ID. #3158, #3178\n+- Armeria server does not reject the request path whose first segment includes a colon anymore. #3154\n+\n+## \ud83c\udfda\ufe0f Deprecations\n+- <type://CircuitBreakerClient#newPerHostAndMethodDecorator(BiFunction,CircuitBreakerRule)> is now deprecated.\n+  #31356\n+  - Use <type://CircuitBreakerClient#newDecorator(CircuitBreakerMapping,CircuitBreakerRule)> with the customized\n+    <type://CircuitBreakerMapping> using <type://CircuitBreakerMapping#builder()>.\n+- The response timeout and max total attempts setters in <type://RetryingClientBuilder> is now deprecated.\n+  #3128 #3145\n+  - The static factory methods that take those parameters in <type://RetryingClient> are now deprecated as well.\n+  - Use <type://RetryConfigMapping> and <type://RetryConfig>.\n+- <type://Route#apply(RoutingContext)?full> is deprecated. #3152\n+  - Use <type://Route#apply(RoutingContext,boolean)?full>.\n+- The constructor of <type://PrometheusExpositionService> is now deprecated. #3081\n+  - Use <type://PrometheusExpositionService#of(CollectorRegistry)>.\n+\n+## \u2622\ufe0f Breaking changes\n+\n+- N/A\n+\n+## \u26d3 Dependencies\n+\n+- completalbe-futures 0.3.3 \u2192 0.3.4\n+- dropwizard-core 2.0.13 \u2192 2.0.16\n+- Fastutil 8.4.2 \u2192 8.4.3\n+- gRPC 1.33.0 \u2192 1.33.1\n+- grpc-kotlin-stub 0.2.0 \u2192 0.2.1\n+- io.dropwizard.metrics 4.1.13 \u2192 4.1.15\n+- Jackson 2.11.2 \u2192 2.12.0\n+- Jctools 3.1.0 \u2192 3.2.0\n+- javax.annotation-api 1.3.2\n+- Micrometer 1.5.5 \u2192 1.6.1\n+- Netty 4.1.53.Final \u2192 4.1.54.Final\n+- org.bouncycastle 1.66 \u2192 1.67\n+- Reactor 3.3.10.RELEASE \u2192 3.4.0\n+- Spring Boot 2.3.4.RELEASE \u2192 2.4.0\n+- Spring 5.2.9.RELEASE \u2192 5.3.1", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjAyMw==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532402023", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                                   .build(factory)\n          \n          \n            \n                                                                   .build(factory);", "author": "ikhoon", "createdAt": "2020-11-30T07:55:02Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMjU5MA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532402590", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n          \n          \n            \n            - You can now specify a prefix for MDC keys using the `<prefix>` element. #3086, #3112", "author": "ikhoon", "createdAt": "2020-11-30T07:56:15Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMzA0OQ==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532403049", "bodyText": "Isn't it better to write a realistic example?", "author": "ikhoon", "createdAt": "2020-11-30T07:57:11Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQwMzk5Mw==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532403993", "bodyText": "Add a blank line?", "author": "ikhoon", "createdAt": "2020-11-30T07:59:19Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path\n+                                                       .perHost()\n+                                                       .build(factory)\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+- You can now specify the Caffeine spec for the DNS resolver. #2970, #3007\n+- You can now specify a prefix fo MDC keys using the `<prefix>` element. #3086, #3112\n+  ```xml\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157, #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574, #3143, #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637, #3118\n+- You can now use the custom Thrift protocol by using <type://ThriftProtocolFactoryProvider> and SPI. #3183\n+  ```java\n+  public class TTupleFactoryProvider extends ThriftProtocolFactoryProvider {\n+      @Override\n+      public Set<ThriftProtocolFactoryProvider.Entry> entries() {\n+          return ImmutableSet.of(new ThriftProtocolFactoryProvider.Entry(\n+                  SerializationFormat.of(\"ttuple\"), new TTupleProtocol.Factory()));\n+      }\n+  }\n+  ```\n+- You can now collect more detailed DNS metrics such as success or failure, query type, etc. #1887, #2935\n+- You can now customize the <type://HealthCheckService> when using Spring integration. #3144\n+  ```java\n+  @Bean\n+  public HealthCheckServiceConfigurator healthCheckServiceConfigurator() {\n+      return builder -> builder.updatable(true);\n+  }\n+  ```\n+- You can now use <type://RequestHeaders#acceptLanguage()> to choose language. #3177, #3179\n+## \ud83d\udcc8 Improvements", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQxNjc2MA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532416760", "bodyText": "nit: The right comment seems to make a horizontal scroll", "author": "ikhoon", "createdAt": "2020-11-30T08:25:14Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,231 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - This is the early stage of development so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are now not collected by default. #3061, #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    TransientServiceBuilder.transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                                    TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                                    TransientServiceOption.WITH_ACCESS_LOGGING)\n+    ```\n+- You can now use Protobuf's `Message` and ScalaPB's `GeneratedMessage` as a request/response object in\n+  annotated service. #3088 #3124, #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = new HttpDeframer<>(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath() // per the combination of host and path", "originalCommit": "ef7ce97643949b780c75ca33319ff29376cf9f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d5268aeb05581adcd14d6d403704bafa1d2b65f2", "url": "https://github.com/line/armeria/commit/d5268aeb05581adcd14d6d403704bafa1d2b65f2", "message": "Address comments by @trustin and @ikhoon", "committedDate": "2020-11-30T11:26:38Z", "type": "commit"}, {"oid": "f23c4d74603bc03b6880cbc02629e1192ee87b19", "url": "https://github.com/line/armeria/commit/f23c4d74603bc03b6880cbc02629e1192ee87b19", "message": "fix typos", "committedDate": "2020-11-30T11:39:52Z", "type": "commit"}, {"oid": "82c6c364cee70f1dc485cba842aaf290792105ef", "url": "https://github.com/line/armeria/commit/82c6c364cee70f1dc485cba842aaf290792105ef", "message": "Add an", "committedDate": "2020-11-30T11:43:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU0Mjk5Mg==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532542992", "bodyText": "nit: Markdown syntax? []() \ud83d\ude09", "author": "ikhoon", "createdAt": "2020-11-30T11:55:42Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,295 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - Netty's `io_uring` transport is currently experimental, so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are not collected anymore by default. #3061 #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    HealthCheckService.builder()\n+                      .transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                               TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                               TransientServiceOption.WITH_ACCESS_LOGGING)\n+                      .build();\n+    ```\n+  - Currently, <type://HealthCheckService> and <type://PrometheusExpositionService> are\n+    <typeplural://TransientService>.\n+- You can now use Protobuf's `Message` and <a href=\"https://github.com/scalapb/ScalaPB\">ScalaPB's</a>", "originalCommit": "82c6c364cee70f1dc485cba842aaf290792105ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU0NDUxMQ==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532544511", "bodyText": "Oops... Remove to JSON? \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-11-30T11:58:33Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,295 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - Netty's `io_uring` transport is currently experimental, so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are not collected anymore by default. #3061 #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    HealthCheckService.builder()\n+                      .transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                               TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                               TransientServiceOption.WITH_ACCESS_LOGGING)\n+                      .build();\n+    ```\n+  - Currently, <type://HealthCheckService> and <type://PrometheusExpositionService> are\n+    <typeplural://TransientService>.\n+- You can now use Protobuf's `Message` and <a href=\"https://github.com/scalapb/ScalaPB\">ScalaPB's</a>\n+  `GeneratedMessage` as a request/response object in an annotated service. #3088 #3124 #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in an annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = HttpDeframer.of(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  - See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  // CircuitBreaker is applied per the combination of host and path.\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath()\n+                                                       .perHost()\n+                                                       .build(factory);\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+  ```java\n+  HttpResponse response = ...\n+  SplitHttpResponse splitHttpResponse = response.split();\n+  CompletableFuture<ResponseHeaders> headersFuture = splitHttpResponse.headers();\n+  StreamMessage<HttpData> bodyStream = splitHttpResponse.body();\n+\n+  headersFuture.thenApply(headers -> {\n+      if (headers.contentType() == MediaType.JSON_SEQ) {\n+          // Subscribe to a stream of HttpData to JSON", "originalCommit": "82c6c364cee70f1dc485cba842aaf290792105ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU0NTMyMA==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532545320", "bodyText": "Now we can remove this?", "author": "ikhoon", "createdAt": "2020-11-30T11:59:56Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,295 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - Netty's `io_uring` transport is currently experimental, so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are not collected anymore by default. #3061 #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    HealthCheckService.builder()\n+                      .transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                               TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                               TransientServiceOption.WITH_ACCESS_LOGGING)\n+                      .build();\n+    ```\n+  - Currently, <type://HealthCheckService> and <type://PrometheusExpositionService> are\n+    <typeplural://TransientService>.\n+- You can now use Protobuf's `Message` and <a href=\"https://github.com/scalapb/ScalaPB\">ScalaPB's</a>\n+  `GeneratedMessage` as a request/response object in an annotated service. #3088 #3124 #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in an annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = HttpDeframer.of(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  - See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  // CircuitBreaker is applied per the combination of host and path.\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath()\n+                                                       .perHost()\n+                                                       .build(factory);\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+  ```java\n+  HttpResponse response = ...\n+  SplitHttpResponse splitHttpResponse = response.split();\n+  CompletableFuture<ResponseHeaders> headersFuture = splitHttpResponse.headers();\n+  StreamMessage<HttpData> bodyStream = splitHttpResponse.body();\n+\n+  headersFuture.thenApply(headers -> {\n+      if (headers.contentType() == MediaType.JSON_SEQ) {\n+          // Subscribe to a stream of HttpData to JSON\n+          Flux.from(bodyStream)\n+              .map(httpData -> {\n+                  // Convert HttpData to your domain object\n+              });\n+              ...\n+      }\n+  });\n+  ```\n+- You can now specify the Caffeine spec for the DNS resolver cache. #2970 #3007\n+- You can now specify a prefix for MDC keys using the `<prefix>` element. #3086 #3112\n+  ```xml\n+  <configuration>\n+    ...\n+    <appender name=\"RCEA\" class=\"com.linecorp.armeria.common.logback.RequestContextExportingAppender\">\n+      ...\n+      <!-- set the prefix of exports which is not wrapped with the <exportGroup> element -->\n+      <prefix>armeria.</prefix>\n+      <export>remote.id</export>\n+      <export>req.headers.user-agent</export>\n+      ...\n+      <exportGroup>\n+        <!-- set the prefix of exports in this <exportGroup> -->\n+        <prefix>some_prefix.</prefix>\n+        <export>some_value=attr:com.example.AttrKeys#SOME_KEY</export>\n+        ...\n+      </exportGroup>\n+      <exportGroup>\n+        <!-- if <prefix> is not defined, no prefix is added to exports -->\n+        <export>tracking_id=attr:com.example.AttrKeys#TRACKING_ID_KEY</export>\n+        ...\n+      </exportGroup>\n+    </appender>\n+    ...\n+  </configuration>\n+\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>", "originalCommit": "82c6c364cee70f1dc485cba842aaf290792105ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU1NjgzNg==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532556836", "bodyText": "\ud83d\ude31", "author": "minwoox", "createdAt": "2020-11-30T12:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU0NTMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU0Nzg1Nw==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532547857", "bodyText": "nit: use Markdown syntax?", "author": "ikhoon", "createdAt": "2020-11-30T12:04:33Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,295 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O", "originalCommit": "82c6c364cee70f1dc485cba842aaf290792105ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU1NDEwNg==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532554106", "bodyText": "is -> are", "author": "KarboniteKream", "createdAt": "2020-11-30T12:15:49Z", "path": "site/src/pages/release-notes/1.3.0.mdx", "diffHunk": "@@ -0,0 +1,295 @@\n+---\n+date: 2020-11-30\n+---\n+\n+## \ud83c\udf1f New features\n+\n+- You can now use <a href=\"https://unixism.net/loti/what_is_io_uring.html\">io_uring</a> for efficient I/O\n+  processing in Linux. #3182\n+  - Specify the `-Dcom.linecorp.armeria.transportType=io_uring` JVM option to enable it.\n+  - Netty's `io_uring` transport is currently experimental, so you should be careful using the feature.\n+- The metrics of requests to a <type://TransientService> are not collected anymore by default. #3061 #3081\n+  - Access logs and service logs are not recorded as well.\n+  - You should use <type://TransientServiceOption> to enable them.\n+    ```java\n+    HealthCheckService.builder()\n+                      .transientServiceOptions(TransientServiceOption.WITH_METRIC_COLLECTION,\n+                                               TransientServiceOption.WITH_SERVICE_LOGGING,\n+                                               TransientServiceOption.WITH_ACCESS_LOGGING)\n+                      .build();\n+    ```\n+  - Currently, <type://HealthCheckService> and <type://PrometheusExpositionService> are\n+    <typeplural://TransientService>.\n+- You can now use Protobuf's `Message` and <a href=\"https://github.com/scalapb/ScalaPB\">ScalaPB's</a>\n+  `GeneratedMessage` as a request/response object in an annotated service. #3088 #3124 #3192\n+  - Use `armeria-protobuf`, `armeria-scalapb_2.12` or `armeria-scalapb_2.13` dependencies.\n+  - See [Supporting ScalaPB in annotated services](/docs/advanced-scalapb#supporting-scalapb-in-annotated-services)\n+    for more information.\n+- You can now use Scala `Future` in an annotated service. #3189\n+  ```scala\n+  @Get(\"/items/{id}\")\n+  def items(@Param id: Int)(implicit ec: ExecutionContext): Future[String] = {\n+    Future {\n+      // Perform asynchronous task using Armeria's event loop.\n+      ...\n+    }\n+  }\n+  ```\n+- You can now use <type://HttpDeframer> to conveniently decode a stream of <typeplural://HttpObject>\n+  to N objects. #2981\n+  ```java\n+  HttpDeframerHandler<String> decoder = ...\n+  HttpDeframer<String> deframer = HttpDeframer.of(decoder, ByteBufAllocator.DEFAULT);\n+  HttpRequest request = ...;\n+  request.subscribe(deframer);\n+  ```\n+  - See <type://HttpDeframer> for more information.\n+- You can now apply <type://CircuitBreaker> per request path. #3134, #3135\n+  ```java\n+  CircuitBreakerFactory factory = ...\n+  // CircuitBreaker is applied per the combination of host and path.\n+  CircuitBreakerMapping mapping = CircuitBreakerMapping.builder()\n+                                                       .perPath()\n+                                                       .perHost()\n+                                                       .build(factory);\n+  CircuitBreakerRule rule = ...\n+  CircuitBreakerClient.newDecorator(mapping, rule);\n+  ```\n+- You can now apply the different `maxTotalAttempts` and `responseTimeout` for <type://RetryingClient>\n+  using <type://RetryConfig>. #3145\n+  ```java\n+  BiFunction<ClientRequestContext, Request, String> keyFactory =\n+      (ctx, req) -> ctx.endpoint().host();\n+  BiFunction<ClientRequestContext, Request, RetryConfig<HttpResponse>> configFactory = (ctx, req) -> {\n+      String host = ctx.endpoint().host();\n+      RetryConfigBuilder builder = RetryConfig.<HttpResponse>builder(RetryRule.onException());\n+      if (host.equals(\"host1\")) {\n+          builder.maxTotalAttempts(2);\n+      } else if (host.equals(\"host2\")) {\n+          builder.maxTotalAttempts(4);\n+      } else {\n+          builder.maxTotalAttempts(1);\n+      }\n+      return builder.build();\n+  };\n+  RetryConfigMapping mapping = RetryConfigMapping.of(keyFactory, configFactory);\n+  RetryingClient.newDecoratorWithMapping(mapping);\n+  ```\n+- You can now split the <type://ResponseHeaders> and bodies using <type://HttpResponse#split()>. #3038\n+  ```java\n+  HttpResponse response = ...\n+  SplitHttpResponse splitHttpResponse = response.split();\n+  CompletableFuture<ResponseHeaders> headersFuture = splitHttpResponse.headers();\n+  StreamMessage<HttpData> bodyStream = splitHttpResponse.body();\n+\n+  headersFuture.thenApply(headers -> {\n+      if (headers.contentType() == MediaType.JSON_SEQ) {\n+          // Subscribe to a stream of HttpData to JSON\n+          Flux.from(bodyStream)\n+              .map(httpData -> {\n+                  // Convert HttpData to your domain object\n+              });\n+              ...\n+      }\n+  });\n+  ```\n+- You can now specify the Caffeine spec for the DNS resolver cache. #2970 #3007\n+- You can now specify a prefix for MDC keys using the `<prefix>` element. #3086 #3112\n+  ```xml\n+  <configuration>\n+    ...\n+    <appender name=\"RCEA\" class=\"com.linecorp.armeria.common.logback.RequestContextExportingAppender\">\n+      ...\n+      <!-- set the prefix of exports which is not wrapped with the <exportGroup> element -->\n+      <prefix>armeria.</prefix>\n+      <export>remote.id</export>\n+      <export>req.headers.user-agent</export>\n+      ...\n+      <exportGroup>\n+        <!-- set the prefix of exports in this <exportGroup> -->\n+        <prefix>some_prefix.</prefix>\n+        <export>some_value=attr:com.example.AttrKeys#SOME_KEY</export>\n+        ...\n+      </exportGroup>\n+      <exportGroup>\n+        <!-- if <prefix> is not defined, no prefix is added to exports -->\n+        <export>tracking_id=attr:com.example.AttrKeys#TRACKING_ID_KEY</export>\n+        ...\n+      </exportGroup>\n+    </appender>\n+    ...\n+  </configuration>\n+\n+  <prefix>...</prefix> <!-- The default prefix -->\n+  <export>...</export>\n+  <exports>...</exports>\n+\n+  <exportGroup>\n+    <prefix>...</prefix> <!-- The prefix for the export group. -->\n+    <export>...</export>\n+    <exports>...</exports>\n+  </exportGroup>\n+  ```\n+- You can now use the unsafe TLS cipher using <type://ClientFactoryBuilder#tlsAllowUnsafeCiphers(boolean)>.\n+  #3157 #3172\n+- You can now specify an arbitrary type for <type://@Header> and <type://@Param> if the\n+  type has one of following static methods or the constructor. #2574 #3143 #3164\n+  - `public static T of(String) { ... }`\n+  - `public static T valueOf(String) { ... }`\n+  - `public static T fromString(String) { ... }`\n+  - `public T(String) { ... } // constructor`\n+  ```java\n+  public class UserService {\n+\n+      @Get(\"/api\")\n+      public HttpResponse get(@Param User user) {\n+          ...\n+      }\n+\n+      private static class User {\n+          User(String userId) { ... } // This constructor is used to create User.\n+          ...\n+      }\n+  }\n+  ```\n+- You can now build and execute an <type://HttpRequest> fluently. #3110\n+  ```java\n+  // Creates a POST HttpRequest whose URI is \"/foo?q=bar\"\n+  // with headers \"cookie: name=value\" and \"authorization: value\" and a JSON body.\n+  HttpRequest.builder()\n+             .post(\"/{resource}\")\n+             .pathParam(\"resource\", \"foo\")\n+             .queryParam(\"q\", \"bar\")\n+             .cookie(Cookie.of(\"name\", \"value\"))\n+             .header(\"authorization\", \"value\")\n+             .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\"));\n+  // You can also use WebClient.prepare().\n+  WebClient client = ...\n+  client.prepare()\n+        .post(\"/{resource}\")\n+        .pathParam(\"resource\", \"foo\")\n+        .queryParam(\"q\", \"bar\")\n+        .cookie(Cookie.of(\"name\", \"value\"))\n+        .header(\"authorization\", \"value\")\n+        .content(MediaType.JSON, \"{\\\"foo\\\":\\\"bar\\\"}\")\n+        .execute();\n+  ```\n+- You can now easily handle cookies by applying <type://CookieClient#newDecorator()>. #2637 #3118\n+  ```java\n+  WebClient client = WebClient.builder()\n+                              .factory(factory)\n+                              .decorator(CookieClient.newDecorator())\n+                              .build();\n+  client.get(...); // The cookies that are received from the origin server\n+                   // are added to the request headers.\n+  ```\n+- You can now use the custom Thrift protocol by using <type://ThriftProtocolFactoryProvider> and SPI. #3183\n+  ```java\n+  public class TTupleFactoryProvider extends ThriftProtocolFactoryProvider {\n+      @Override\n+      public Set<ThriftProtocolFactoryProvider.Entry> entries() {\n+          return ImmutableSet.of(new ThriftProtocolFactoryProvider.Entry(\n+                  SerializationFormat.of(\"ttuple\"), new TTupleProtocol.Factory()));\n+      }\n+  }\n+  ```\n+- You can now collect more detailed DNS metrics. #1887 #2935\n+  - `armeria.client.dns.queries#count{...,result=success}`\n+  - `armeria.client.dns.queries#count{...,result=failure}`\n+  - `armeria.client.dns.queries.written#count{...}`\n+  - `armeria.client.dns.queries.cancelled#count{...}`\n+  - `armeria.client.dns.queries.redirected#count{...}`\n+  - `armeria.client.dns.queries.cnamed#count{...}`\n+  - `armeria.client.dns.queries.noanswer#count{...}`\n+- You can now customize the <type://HealthCheckService> when using Spring integration. #3144\n+  ```java\n+  @Bean\n+  public HealthCheckServiceConfigurator healthCheckServiceConfigurator() {\n+      return builder -> builder.updatable(true);\n+  }\n+  ```\n+- You can now use <type://RequestHeaders#acceptLanguage()> to choose language. #3177 #3179\n+\n+## \ud83d\udcc8 Improvements\n+\n+- Various improvements for <type://DocService>. #3149 #3150 #3167 #3188\n+\n+## \ud83d\udee0\ufe0f Bug fixes\n+\n+- <type://HealthCheckedEndpointGroup#endpoints()> now returns healthy endpoints properly even when\n+  <type://EndpointGroup#orElse(EndpointGroup)> is used. #3181\n+- `ServletRequest.getProtocol()` now returns the proper value when using <type://TomcatService> and\n+  <type://JettyService>. #3194\n+- The route decorators are now evaluated in the reverse order they applied. #3160 #3166\n+- You now get the FORBIDDEN status if your service does not handle preflight requests regardless of\n+  route decorators. #3152\n+- A gRPC `ServerCall` is now closed exactly only once. #3153\n+- You no longer see `AnnotatedConnectException` when the <type://Endpoint> is created with an\n+  IPv6 scope ID. #3158 #3178\n+- Armeria server does not reject the request path whose first segment includes a colon anymore. #3154\n+\n+## \ud83c\udfda\ufe0f Deprecations\n+\n+- <type://CircuitBreakerClient#newPerHostAndMethodDecorator(BiFunction,CircuitBreakerRule)> is now deprecated.\n+  #31356\n+  - Use <type://CircuitBreakerClient#newDecorator(CircuitBreakerMapping,CircuitBreakerRule)> with the customized\n+    <type://CircuitBreakerMapping> using <type://CircuitBreakerMapping#builder()>.\n+- The response timeout and max total attempts setters in <type://RetryingClientBuilder> is now deprecated.", "originalCommit": "82c6c364cee70f1dc485cba842aaf290792105ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU1NzMzNw==", "url": "https://github.com/line/armeria/pull/3207#discussion_r532557337", "bodyText": "Thanks, fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-11-30T12:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU1NDEwNg=="}], "type": "inlineReview"}, {"oid": "904de2badfc3d85a833817e0ea6b84a8f744a56a", "url": "https://github.com/line/armeria/commit/904de2badfc3d85a833817e0ea6b84a8f744a56a", "message": "Address comments by @ikhoon and @KarboniteKream", "committedDate": "2020-11-30T12:22:42Z", "type": "commit"}, {"oid": "4aade24d6765b3ae00f8f8a88685bcd8ecc27d73", "url": "https://github.com/line/armeria/commit/4aade24d6765b3ae00f8f8a88685bcd8ecc27d73", "message": "Add gRPC status mapping", "committedDate": "2020-11-30T12:38:31Z", "type": "commit"}]}