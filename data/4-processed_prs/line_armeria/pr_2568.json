{"pr_number": 2568, "pr_title": "Add documentation for the order of client decoration", "pr_createdAt": "2020-03-10T08:29:48Z", "pr_url": "https://github.com/line/armeria/pull/2568", "timeline": [{"oid": "5f47279d18e6528db41e097b4a17e7ea0ba3d530", "url": "https://github.com/line/armeria/commit/5f47279d18e6528db41e097b4a17e7ea0ba3d530", "message": "Add documentation for the order of client decoration\nRelated: #1117\n\nTo-do:\nAdd documentation for server side", "committedDate": "2020-03-10T08:29:11Z", "type": "commit"}, {"oid": "76420e4b21cd367e3d5d3c8419a51afdbde989d0", "url": "https://github.com/line/armeria/commit/76420e4b21cd367e3d5d3c8419a51afdbde989d0", "message": "Add Ascii art", "committedDate": "2020-03-10T08:59:30Z", "type": "commit"}, {"oid": "2a35045037e07453516def42a7007153cd13bc48", "url": "https://github.com/line/armeria/commit/2a35045037e07453516def42a7007153cd13bc48", "message": "Fix", "committedDate": "2020-03-10T09:39:26Z", "type": "commit"}, {"oid": "bc1d85bb80a9be0837ff8a40f4589d0217b0cea6", "url": "https://github.com/line/armeria/commit/bc1d85bb80a9be0837ff8a40f4589d0217b0cea6", "message": "Add more Ascii art", "committedDate": "2020-03-10T10:14:55Z", "type": "commit"}, {"oid": "3c25f82d7facc0430b6358d0598ea4146eb4a8e0", "url": "https://github.com/line/armeria/commit/3c25f82d7facc0430b6358d0598ea4146eb4a8e0", "message": "Fix 2", "committedDate": "2020-03-10T10:24:10Z", "type": "commit"}, {"oid": "f50046bf2a67a6c538458bab3ec15f260b754f2c", "url": "https://github.com/line/armeria/commit/f50046bf2a67a6c538458bab3ec15f260b754f2c", "message": "Fix 3", "committedDate": "2020-03-10T11:00:58Z", "type": "commit"}, {"oid": "42311d2d3f1129033dd4fedf1c4aef0c68e1d2cf", "url": "https://github.com/line/armeria/commit/42311d2d3f1129033dd4fedf1c4aef0c68e1d2cf", "message": "Fix 4", "committedDate": "2020-03-10T11:03:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1NzYxMw==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390257613", "bodyText": "Why don't we show the right example over the wrong one? Because many users might want to copy and paste.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Don't do this. ContentPreviewingClient should be inserted after DecodingClient.\n          \n          \n            \n                cb.decorator(ContentPreviewingClient.newDecorator(1000));\n          \n          \n            \n                cb.decorator(DecodingClient.newDecorator());\n          \n          \n            \n                cb.decorator(DecodingClient.newDecorator());\n          \n          \n            \n                // ContentPreviewingClient should be inserted after DecodingClient.\n          \n          \n            \n                cb.decorator(ContentPreviewingClient.newDecorator(1000));", "author": "ikhoon", "createdAt": "2020-03-10T11:44:47Z", "path": "site/src/sphinx/client-decorator.rst", "diffHunk": "@@ -67,6 +67,113 @@ If your decorator is expected to be reusable, it is recommended to define a new\n     // Using a lambda expression:\n     cb.decorator(delegate -> new AuditClient(delegate));\n \n+The order of decoration\n+-----------------------\n+\n+The decorators are executed in reverse order of the insertion. The following example shows which order\n+the decorators are executed by printing the messages.\n+\n+.. code-block:: java\n+\n+    import com.linecorp.armeria.client.WebClient;\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 decorator\n+    cb.decorator((delegate, ctx, req) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 decorator.\n+    // No matter decorator() or option() is used, decorators are executed in reverse order of the insertion.\n+    cb.option(ClientOption.DECORATION, ClientDecoration.of((delegate, ctx, req) -> {\n+        System.err.println(\"Firstly, executed\");\n+        ...\n+    });\n+\n+    WebClient myClient = cb.build(WebClient.class);\n+\n+The following diagram describes how an HTTP request and HTTP response are gone through decorators:\n+\n+.. uml::\n+\n+    @startditaa\n+    +-----------+  req  +-----------+  req  +-----------+  req  +------------------+    req    +--------------+\n+    |           |------>|           |------>|           |------>|                  |---------->|              |\n+    | WebClient |       | #1        |       | #2        |       | Armeria          |           |    Server    |\n+    |           |  res  | decorator |  res  | decorator |  res  | Netwokring Layer |    res    |              |\n+    |           |<------|           |<------|           |<------|                  |<----------|              |\n+    +-----------+       +-----------+       +-----------+       +------------------+           +--------------+\n+    @endditaa\n+\n+If the client is a Thrift client and RPC decorators are inserted, HTTP decorators and RPC decorators are\n+separately grouped and executed in reverse order of the insertion:\n+\n+.. code-block:: java\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 HTTP decorator.\n+    cb.decorator((delegate, ctx, httpReq) -> {\n+        System.err.println(\"Fourthly, executed.\");\n+        ...\n+    });\n+\n+    // #2 RPC decorator.\n+    cb.rpcDecorator((delegate, ctx, rpcReq) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 HTTP decorator.\n+    cb.decorator((delegate, ctx, httpReq) -> {\n+        System.err.println(\"Thirdly, executed.\");\n+        ...\n+    });\n+\n+    // #1 RPC decorator.\n+    cb.rpcDecorator((delegate, ctx, rpcReq) -> {\n+        System.err.println(\"Firstly, executed.\");\n+        ...\n+    });\n+\n+An RPC request is converted into an HTTP request before it's sent to a server.\n+So RPC decorators are inserted before the RPC request is converted and HTTP decorators are inserted after the\n+request is converted into the HTTP request. The following diagram describes it:\n+\n+.. uml::\n+\n+    @startditaa\n+    +--------+ req +-----------+ req +-----------+                     +-----------+ req +-----------+\n+    |        |---->|           |---->|           |---> RPC to HTTP --->|           |---->|           |----=->\n+    | Thrift |     | #1 RPC    |     | #2 RPC    |                     | #1 HTTP   |     | #2 HTTP   |\n+    | Client | res | decorator | res | decorator |                     | decorator | res | decorator |\n+    |        |<----|           |<----|           |<--- HTTP to RPC <---|           |<----|           |<-=----\n+    +--------+     +-----------+     +-----------+                     +-----------+     +-----------+\n+    @endditaa\n+\n+If the decorator modifies the response (e.g. :api:`DecodingClient`) or spawns more requests\n+(e.g. :api:`RetryingClient`), the consequence is different depending on the order of the decorators.\n+Let's look at the following example that :api:`DecodingClient` and :api:`ContentPreviewingClient`\n+are used together:\n+\n+.. code-block:: java\n+\n+    import com.linecorp.armeria.client.encoding.DecodingClient;\n+    import com.linecorp.armeria.client.logging.ContentPreviewingClient;\n+\n+    ClientBuilder cb = Clients.builder(...);\n+    // Don't do this. ContentPreviewingClient should be inserted after DecodingClient.\n+    cb.decorator(ContentPreviewingClient.newDecorator(1000));\n+    cb.decorator(DecodingClient.newDecorator());", "originalCommit": "42311d2d3f1129033dd4fedf1c4aef0c68e1d2cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI2MzQ4NQ==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390263485", "bodyText": "Fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-03-10T11:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1NzYxMw=="}], "type": "inlineReview"}, {"oid": "bdb8754a6ae92b6048f1ff584a5a69426b57bd7c", "url": "https://github.com/line/armeria/commit/bdb8754a6ae92b6048f1ff584a5a69426b57bd7c", "message": "Address the comment by @ikhoon", "committedDate": "2020-03-10T11:57:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NzUyMw==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390287523", "bodyText": "Networking", "author": "jrhee17", "createdAt": "2020-03-10T12:47:16Z", "path": "site/src/sphinx/client-decorator.rst", "diffHunk": "@@ -67,6 +67,113 @@ If your decorator is expected to be reusable, it is recommended to define a new\n     // Using a lambda expression:\n     cb.decorator(delegate -> new AuditClient(delegate));\n \n+The order of decoration\n+-----------------------\n+\n+The decorators are executed in reverse order of the insertion. The following example shows which order\n+the decorators are executed by printing the messages.\n+\n+.. code-block:: java\n+\n+    import com.linecorp.armeria.client.WebClient;\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 decorator\n+    cb.decorator((delegate, ctx, req) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 decorator.\n+    // No matter decorator() or option() is used, decorators are executed in reverse order of the insertion.\n+    cb.option(ClientOption.DECORATION, ClientDecoration.of((delegate, ctx, req) -> {\n+        System.err.println(\"Firstly, executed\");\n+        ...\n+    });\n+\n+    WebClient myClient = cb.build(WebClient.class);\n+\n+The following diagram describes how an HTTP request and HTTP response are gone through decorators:\n+\n+.. uml::\n+\n+    @startditaa\n+    +-----------+  req  +-----------+  req  +-----------+  req  +------------------+    req    +--------------+\n+    |           |------>|           |------>|           |------>|                  |---------->|              |\n+    | WebClient |       | #1        |       | #2        |       | Armeria          |           |    Server    |\n+    |           |  res  | decorator |  res  | decorator |  res  | Netwokring Layer |    res    |              |", "originalCommit": "bdb8754a6ae92b6048f1ff584a5a69426b57bd7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4ODE2NQ==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390288165", "bodyText": "\ud83d\ude31 \ud83d\ude05", "author": "minwoox", "createdAt": "2020-03-10T12:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NzUyMw=="}], "type": "inlineReview"}, {"oid": "2246b76fa87c307c66c04d8e6b0096a4a1824dc1", "url": "https://github.com/line/armeria/commit/2246b76fa87c307c66c04d8e6b0096a4a1824dc1", "message": "Fix typo", "committedDate": "2020-03-10T12:52:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMwOTY3NQ==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390309675", "bodyText": "So -> Therefore,", "author": "trustin", "createdAt": "2020-03-10T13:25:44Z", "path": "site/src/sphinx/client-decorator.rst", "diffHunk": "@@ -67,6 +67,113 @@ If your decorator is expected to be reusable, it is recommended to define a new\n     // Using a lambda expression:\n     cb.decorator(delegate -> new AuditClient(delegate));\n \n+The order of decoration\n+-----------------------\n+\n+The decorators are executed in reverse order of the insertion. The following example shows which order\n+the decorators are executed by printing the messages.\n+\n+.. code-block:: java\n+\n+    import com.linecorp.armeria.client.WebClient;\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 decorator\n+    cb.decorator((delegate, ctx, req) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 decorator.\n+    // No matter decorator() or option() is used, decorators are executed in reverse order of the insertion.\n+    cb.option(ClientOption.DECORATION, ClientDecoration.of((delegate, ctx, req) -> {\n+        System.err.println(\"Firstly, executed\");\n+        ...\n+    });\n+\n+    WebClient myClient = cb.build(WebClient.class);\n+\n+The following diagram describes how an HTTP request and HTTP response are gone through decorators:\n+\n+.. uml::\n+\n+    @startditaa\n+    +-----------+  req  +-----------+  req  +-----------+  req  +------------------+    req    +--------------+\n+    |           |------>|           |------>|           |------>|                  |---------->|              |\n+    | WebClient |       | #1        |       | #2        |       | Armeria          |           |    Server    |\n+    |           |  res  | decorator |  res  | decorator |  res  | Networking Layer |    res    |              |\n+    |           |<------|           |<------|           |<------|                  |<----------|              |\n+    +-----------+       +-----------+       +-----------+       +------------------+           +--------------+\n+    @endditaa\n+\n+If the client is a Thrift client and RPC decorators are inserted, HTTP decorators and RPC decorators are\n+separately grouped and executed in reverse order of the insertion:\n+\n+.. code-block:: java\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 HTTP decorator.\n+    cb.decorator((delegate, ctx, httpReq) -> {\n+        System.err.println(\"Fourthly, executed.\");\n+        ...\n+    });\n+\n+    // #2 RPC decorator.\n+    cb.rpcDecorator((delegate, ctx, rpcReq) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 HTTP decorator.\n+    cb.decorator((delegate, ctx, httpReq) -> {\n+        System.err.println(\"Thirdly, executed.\");\n+        ...\n+    });\n+\n+    // #1 RPC decorator.\n+    cb.rpcDecorator((delegate, ctx, rpcReq) -> {\n+        System.err.println(\"Firstly, executed.\");\n+        ...\n+    });\n+\n+An RPC request is converted into an HTTP request before it's sent to a server.\n+So RPC decorators are inserted before the RPC request is converted and HTTP decorators are inserted after the", "originalCommit": "2246b76fa87c307c66c04d8e6b0096a4a1824dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxOTE3MA==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390319170", "bodyText": "Fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-03-10T13:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMwOTY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMwOTkwMw==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390309903", "bodyText": "..., as described in the following diagram:", "author": "trustin", "createdAt": "2020-03-10T13:26:05Z", "path": "site/src/sphinx/client-decorator.rst", "diffHunk": "@@ -67,6 +67,113 @@ If your decorator is expected to be reusable, it is recommended to define a new\n     // Using a lambda expression:\n     cb.decorator(delegate -> new AuditClient(delegate));\n \n+The order of decoration\n+-----------------------\n+\n+The decorators are executed in reverse order of the insertion. The following example shows which order\n+the decorators are executed by printing the messages.\n+\n+.. code-block:: java\n+\n+    import com.linecorp.armeria.client.WebClient;\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 decorator\n+    cb.decorator((delegate, ctx, req) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 decorator.\n+    // No matter decorator() or option() is used, decorators are executed in reverse order of the insertion.\n+    cb.option(ClientOption.DECORATION, ClientDecoration.of((delegate, ctx, req) -> {\n+        System.err.println(\"Firstly, executed\");\n+        ...\n+    });\n+\n+    WebClient myClient = cb.build(WebClient.class);\n+\n+The following diagram describes how an HTTP request and HTTP response are gone through decorators:\n+\n+.. uml::\n+\n+    @startditaa\n+    +-----------+  req  +-----------+  req  +-----------+  req  +------------------+    req    +--------------+\n+    |           |------>|           |------>|           |------>|                  |---------->|              |\n+    | WebClient |       | #1        |       | #2        |       | Armeria          |           |    Server    |\n+    |           |  res  | decorator |  res  | decorator |  res  | Networking Layer |    res    |              |\n+    |           |<------|           |<------|           |<------|                  |<----------|              |\n+    +-----------+       +-----------+       +-----------+       +------------------+           +--------------+\n+    @endditaa\n+\n+If the client is a Thrift client and RPC decorators are inserted, HTTP decorators and RPC decorators are\n+separately grouped and executed in reverse order of the insertion:\n+\n+.. code-block:: java\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 HTTP decorator.\n+    cb.decorator((delegate, ctx, httpReq) -> {\n+        System.err.println(\"Fourthly, executed.\");\n+        ...\n+    });\n+\n+    // #2 RPC decorator.\n+    cb.rpcDecorator((delegate, ctx, rpcReq) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 HTTP decorator.\n+    cb.decorator((delegate, ctx, httpReq) -> {\n+        System.err.println(\"Thirdly, executed.\");\n+        ...\n+    });\n+\n+    // #1 RPC decorator.\n+    cb.rpcDecorator((delegate, ctx, rpcReq) -> {\n+        System.err.println(\"Firstly, executed.\");\n+        ...\n+    });\n+\n+An RPC request is converted into an HTTP request before it's sent to a server.\n+So RPC decorators are inserted before the RPC request is converted and HTTP decorators are inserted after the\n+request is converted into the HTTP request. The following diagram describes it:", "originalCommit": "2246b76fa87c307c66c04d8e6b0096a4a1824dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxOTI5OA==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390319298", "bodyText": "Fixed.", "author": "minwoox", "createdAt": "2020-03-10T13:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMwOTkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxMDM4OA==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390310388", "bodyText": "the consequence is ... -> the outcome may be ?", "author": "trustin", "createdAt": "2020-03-10T13:26:54Z", "path": "site/src/sphinx/client-decorator.rst", "diffHunk": "@@ -67,6 +67,113 @@ If your decorator is expected to be reusable, it is recommended to define a new\n     // Using a lambda expression:\n     cb.decorator(delegate -> new AuditClient(delegate));\n \n+The order of decoration\n+-----------------------\n+\n+The decorators are executed in reverse order of the insertion. The following example shows which order\n+the decorators are executed by printing the messages.\n+\n+.. code-block:: java\n+\n+    import com.linecorp.armeria.client.WebClient;\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 decorator\n+    cb.decorator((delegate, ctx, req) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 decorator.\n+    // No matter decorator() or option() is used, decorators are executed in reverse order of the insertion.\n+    cb.option(ClientOption.DECORATION, ClientDecoration.of((delegate, ctx, req) -> {\n+        System.err.println(\"Firstly, executed\");\n+        ...\n+    });\n+\n+    WebClient myClient = cb.build(WebClient.class);\n+\n+The following diagram describes how an HTTP request and HTTP response are gone through decorators:\n+\n+.. uml::\n+\n+    @startditaa\n+    +-----------+  req  +-----------+  req  +-----------+  req  +------------------+    req    +--------------+\n+    |           |------>|           |------>|           |------>|                  |---------->|              |\n+    | WebClient |       | #1        |       | #2        |       | Armeria          |           |    Server    |\n+    |           |  res  | decorator |  res  | decorator |  res  | Networking Layer |    res    |              |\n+    |           |<------|           |<------|           |<------|                  |<----------|              |\n+    +-----------+       +-----------+       +-----------+       +------------------+           +--------------+\n+    @endditaa\n+\n+If the client is a Thrift client and RPC decorators are inserted, HTTP decorators and RPC decorators are\n+separately grouped and executed in reverse order of the insertion:\n+\n+.. code-block:: java\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 HTTP decorator.\n+    cb.decorator((delegate, ctx, httpReq) -> {\n+        System.err.println(\"Fourthly, executed.\");\n+        ...\n+    });\n+\n+    // #2 RPC decorator.\n+    cb.rpcDecorator((delegate, ctx, rpcReq) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 HTTP decorator.\n+    cb.decorator((delegate, ctx, httpReq) -> {\n+        System.err.println(\"Thirdly, executed.\");\n+        ...\n+    });\n+\n+    // #1 RPC decorator.\n+    cb.rpcDecorator((delegate, ctx, rpcReq) -> {\n+        System.err.println(\"Firstly, executed.\");\n+        ...\n+    });\n+\n+An RPC request is converted into an HTTP request before it's sent to a server.\n+So RPC decorators are inserted before the RPC request is converted and HTTP decorators are inserted after the\n+request is converted into the HTTP request. The following diagram describes it:\n+\n+.. uml::\n+\n+    @startditaa\n+    +--------+ req +-----------+ req +-----------+                     +-----------+ req +-----------+\n+    |        |---->|           |---->|           |---> RPC to HTTP --->|           |---->|           |----=->\n+    | Thrift |     | #1 RPC    |     | #2 RPC    |                     | #1 HTTP   |     | #2 HTTP   |\n+    | Client | res | decorator | res | decorator |                     | decorator | res | decorator |\n+    |        |<----|           |<----|           |<--- HTTP to RPC <---|           |<----|           |<-=----\n+    +--------+     +-----------+     +-----------+                     +-----------+     +-----------+\n+    @endditaa\n+\n+If the decorator modifies the response (e.g. :api:`DecodingClient`) or spawns more requests\n+(e.g. :api:`RetryingClient`), the consequence is different depending on the order of the decorators.", "originalCommit": "2246b76fa87c307c66c04d8e6b0096a4a1824dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxOTMzMw==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390319333", "bodyText": "Fixed.", "author": "minwoox", "createdAt": "2020-03-10T13:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxMDM4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxMTgyOA==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390311828", "bodyText": "How about adding the opposite case?\nIf the two decorators are added in the opposite order, you will get the decoded preview because :api:`DecodingClient` is evaluated first.", "author": "trustin", "createdAt": "2020-03-10T13:29:17Z", "path": "site/src/sphinx/client-decorator.rst", "diffHunk": "@@ -67,6 +67,113 @@ If your decorator is expected to be reusable, it is recommended to define a new\n     // Using a lambda expression:\n     cb.decorator(delegate -> new AuditClient(delegate));\n \n+The order of decoration\n+-----------------------\n+\n+The decorators are executed in reverse order of the insertion. The following example shows which order\n+the decorators are executed by printing the messages.\n+\n+.. code-block:: java\n+\n+    import com.linecorp.armeria.client.WebClient;\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 decorator\n+    cb.decorator((delegate, ctx, req) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 decorator.\n+    // No matter decorator() or option() is used, decorators are executed in reverse order of the insertion.\n+    cb.option(ClientOption.DECORATION, ClientDecoration.of((delegate, ctx, req) -> {\n+        System.err.println(\"Firstly, executed\");\n+        ...\n+    });\n+\n+    WebClient myClient = cb.build(WebClient.class);\n+\n+The following diagram describes how an HTTP request and HTTP response are gone through decorators:\n+\n+.. uml::\n+\n+    @startditaa\n+    +-----------+  req  +-----------+  req  +-----------+  req  +------------------+    req    +--------------+\n+    |           |------>|           |------>|           |------>|                  |---------->|              |\n+    | WebClient |       | #1        |       | #2        |       | Armeria          |           |    Server    |\n+    |           |  res  | decorator |  res  | decorator |  res  | Networking Layer |    res    |              |\n+    |           |<------|           |<------|           |<------|                  |<----------|              |\n+    +-----------+       +-----------+       +-----------+       +------------------+           +--------------+\n+    @endditaa\n+\n+If the client is a Thrift client and RPC decorators are inserted, HTTP decorators and RPC decorators are\n+separately grouped and executed in reverse order of the insertion:\n+\n+.. code-block:: java\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 HTTP decorator.\n+    cb.decorator((delegate, ctx, httpReq) -> {\n+        System.err.println(\"Fourthly, executed.\");\n+        ...\n+    });\n+\n+    // #2 RPC decorator.\n+    cb.rpcDecorator((delegate, ctx, rpcReq) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 HTTP decorator.\n+    cb.decorator((delegate, ctx, httpReq) -> {\n+        System.err.println(\"Thirdly, executed.\");\n+        ...\n+    });\n+\n+    // #1 RPC decorator.\n+    cb.rpcDecorator((delegate, ctx, rpcReq) -> {\n+        System.err.println(\"Firstly, executed.\");\n+        ...\n+    });\n+\n+An RPC request is converted into an HTTP request before it's sent to a server.\n+So RPC decorators are inserted before the RPC request is converted and HTTP decorators are inserted after the\n+request is converted into the HTTP request. The following diagram describes it:\n+\n+.. uml::\n+\n+    @startditaa\n+    +--------+ req +-----------+ req +-----------+                     +-----------+ req +-----------+\n+    |        |---->|           |---->|           |---> RPC to HTTP --->|           |---->|           |----=->\n+    | Thrift |     | #1 RPC    |     | #2 RPC    |                     | #1 HTTP   |     | #2 HTTP   |\n+    | Client | res | decorator | res | decorator |                     | decorator | res | decorator |\n+    |        |<----|           |<----|           |<--- HTTP to RPC <---|           |<----|           |<-=----\n+    +--------+     +-----------+     +-----------+                     +-----------+     +-----------+\n+    @endditaa\n+\n+If the decorator modifies the response (e.g. :api:`DecodingClient`) or spawns more requests\n+(e.g. :api:`RetryingClient`), the consequence is different depending on the order of the decorators.\n+Let's look at the following example that :api:`DecodingClient` and :api:`ContentPreviewingClient`\n+are used together:\n+\n+.. code-block:: java\n+\n+    import com.linecorp.armeria.client.encoding.DecodingClient;\n+    import com.linecorp.armeria.client.logging.ContentPreviewingClient;\n+\n+    ClientBuilder cb = Clients.builder(...);\n+    cb.decorator(ContentPreviewingClient.newDecorator(1000));\n+    // ContentPreviewingClient should be inserted after DecodingClient.\n+    cb.decorator(DecodingClient.newDecorator());\n+\n+:api:`DecodingClient` decodes the content of HTTP responses.\n+:api:`ContentPreviewingClient` is :ref:`content-previewing` of the HTTP response by setting it to the\n+:api:`RequestLog`. Because it's inserted after :api:`DecodingClient`, which means that the response content\n+is set before it's decoded, you will see the encoded response content preview.", "originalCommit": "2246b76fa87c307c66c04d8e6b0096a4a1824dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxOTY2Ng==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390319666", "bodyText": "Fixed. I rephrased a little bit because I changed the order of decoration. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-03-10T13:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxMTgyOA=="}], "type": "inlineReview"}, {"oid": "31d5a3c26bce6b6394f78d4c399eafc852b4adbc", "url": "https://github.com/line/armeria/commit/31d5a3c26bce6b6394f78d4c399eafc852b4adbc", "message": "Address the comment by @trustin", "committedDate": "2020-03-10T13:40:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5NjA3Mg==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390396072", "bodyText": "I haven't really used RPC decorators before since don't use thrift. I'm surprised by this behavior, and understand it but it's not very intuitive to have implicit grouping.\nWould it be worth changing the API a little to make the grouping explicit?\ncb.decorators().add()...\n\ncb.rpcDecorators().add()...", "author": "anuraaga", "createdAt": "2020-03-10T15:21:48Z", "path": "site/src/sphinx/client-decorator.rst", "diffHunk": "@@ -67,6 +67,116 @@ If your decorator is expected to be reusable, it is recommended to define a new\n     // Using a lambda expression:\n     cb.decorator(delegate -> new AuditClient(delegate));\n \n+The order of decoration\n+-----------------------\n+\n+The decorators are executed in reverse order of the insertion. The following example shows which order\n+the decorators are executed by printing the messages.\n+\n+.. code-block:: java\n+\n+    import com.linecorp.armeria.client.WebClient;\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 decorator\n+    cb.decorator((delegate, ctx, req) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 decorator.\n+    // No matter decorator() or option() is used, decorators are executed in reverse order of the insertion.\n+    cb.option(ClientOption.DECORATION, ClientDecoration.of((delegate, ctx, req) -> {\n+        System.err.println(\"Firstly, executed\");\n+        ...\n+    });\n+\n+    WebClient myClient = cb.build(WebClient.class);\n+\n+The following diagram describes how an HTTP request and HTTP response are gone through decorators:\n+\n+.. uml::\n+\n+    @startditaa\n+    +-----------+  req  +-----------+  req  +-----------+  req  +------------------+    req    +--------------+\n+    |           |------>|           |------>|           |------>|                  |---------->|              |\n+    | WebClient |       | #1        |       | #2        |       | Armeria          |           |    Server    |\n+    |           |  res  | decorator |  res  | decorator |  res  | Networking Layer |    res    |              |\n+    |           |<------|           |<------|           |<------|                  |<----------|              |\n+    +-----------+       +-----------+       +-----------+       +------------------+           +--------------+\n+    @endditaa\n+\n+If the client is a Thrift client and RPC decorators are inserted, HTTP decorators and RPC decorators are", "originalCommit": "31d5a3c26bce6b6394f78d4c399eafc852b4adbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwMjU5OQ==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390702599", "bodyText": "That's a good suggestion.\nThe example code that I picked up was really ugly and I think there's a still chance that a user does it in the same way:\ncb.decorators().add(d1);\ncb.rpcDecorators().add(d2);\ncb.decorators().add(d3);\nAnd mostly, a user would have separate methods to set decorators if it gets complicated, so I'm not sure it's worth changing. \ud83e\udd14 (But it looks good to me.)", "author": "minwoox", "createdAt": "2020-03-11T01:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5NjA3Mg=="}], "type": "inlineReview"}, {"oid": "4815713e5dfac14e467552636f77f7fcda22bd1c", "url": "https://github.com/line/armeria/commit/4815713e5dfac14e467552636f77f7fcda22bd1c", "message": "Fix description", "committedDate": "2020-03-11T01:51:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxODQwOA==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390718408", "bodyText": "I found ClientDecoration.of(...) does not accept DecoratingHttpClientFunction.\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/client/ClientDecoration.java\n    \n    \n         Line 43\n      in\n      6f21290\n    \n    \n    \n    \n\n        \n          \n           public static ClientDecoration of(Function<? super HttpClient, ? extends HttpClient> decorator) {", "author": "ikhoon", "createdAt": "2020-03-11T02:46:45Z", "path": "site/src/sphinx/client-decorator.rst", "diffHunk": "@@ -67,6 +67,116 @@ If your decorator is expected to be reusable, it is recommended to define a new\n     // Using a lambda expression:\n     cb.decorator(delegate -> new AuditClient(delegate));\n \n+The order of decoration\n+-----------------------\n+\n+The decorators are executed in reverse order of the insertion. The following example shows which order\n+the decorators are executed by printing the messages.\n+\n+.. code-block:: java\n+\n+    import com.linecorp.armeria.client.WebClient;\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 decorator\n+    cb.decorator((delegate, ctx, req) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 decorator.\n+    // No matter decorator() or option() is used, decorators are executed in reverse order of the insertion.\n+    cb.option(ClientOption.DECORATION, ClientDecoration.of((delegate, ctx, req) -> {", "originalCommit": "4815713e5dfac14e467552636f77f7fcda22bd1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxOTczNQ==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390719735", "bodyText": "And how about making the method body complete for the detail example?\n// #2 decorator\ncb.decorator((delegate, ctx, req) -> {\n    System.err.println(\"Secondly, executed.\");\n    final HttpResponse res = delegate.execute(ctx, req);\n    System.err.println(\"Thirdly, executed.\");\n    return res;\n});\n\n// #2 decorator\ncb.option(ClientOption.DECORATION, ClientDecoration.of(delegate -> (ctx, req) -> {\n    System.err.println(\"Firstly, executed\");\n    final HttpResponse res = delegate.execute(ctx, req);\n    System.err.println(\"Fourthly, executed.\");\n    return res;\n}));", "author": "ikhoon", "createdAt": "2020-03-11T02:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxODQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyNTIxNQ==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390725215", "bodyText": "I found ClientDecoration.of(...) does not accept DecoratingHttpClientFunction.\n\nOops, you've already added it to this PR \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-03-11T03:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxODQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyNzEzOQ==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390727139", "bodyText": "Had chat with @minwoox, we are going to focus on the exeution orders.\nIf any questions or requests on this feature, we will improve our documentation. :-)", "author": "ikhoon", "createdAt": "2020-03-11T03:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxODQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyODU2NA==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390728564", "bodyText": "How about using apply instead of insert\nFor example:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Therefore, RPC decorators are inserted before the RPC request is converted and HTTP decorators are inserted\n          \n          \n            \n            Therefore, RPC decorators are applied before the RPC request is converted and HTTP decorators are applied", "author": "ikhoon", "createdAt": "2020-03-11T03:32:47Z", "path": "site/src/sphinx/client-decorator.rst", "diffHunk": "@@ -67,6 +67,116 @@ If your decorator is expected to be reusable, it is recommended to define a new\n     // Using a lambda expression:\n     cb.decorator(delegate -> new AuditClient(delegate));\n \n+The order of decoration\n+-----------------------\n+\n+The decorators are executed in reverse order of the insertion. The following example shows which order\n+the decorators are executed by printing the messages.\n+\n+.. code-block:: java\n+\n+    import com.linecorp.armeria.client.WebClient;\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 decorator\n+    cb.decorator((delegate, ctx, req) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 decorator.\n+    // No matter decorator() or option() is used, decorators are executed in reverse order of the insertion.\n+    cb.option(ClientOption.DECORATION, ClientDecoration.of((delegate, ctx, req) -> {\n+        System.err.println(\"Firstly, executed\");\n+        ...\n+    });\n+\n+    WebClient myClient = cb.build(WebClient.class);\n+\n+The following diagram describes how an HTTP request and HTTP response are gone through decorators:\n+\n+.. uml::\n+\n+    @startditaa\n+    +-----------+  req  +-----------+  req  +-----------+  req  +------------------+    req    +--------------+\n+    |           |------>|           |------>|           |------>|                  |---------->|              |\n+    | WebClient |       | #1        |       | #2        |       | Armeria          |           |    Server    |\n+    |           |  res  | decorator |  res  | decorator |  res  | Networking Layer |    res    |              |\n+    |           |<------|           |<------|           |<------|                  |<----------|              |\n+    +-----------+       +-----------+       +-----------+       +------------------+           +--------------+\n+    @endditaa\n+\n+If the client is a Thrift client and RPC decorators are inserted, HTTP decorators and RPC decorators are\n+separately grouped and executed in reverse order of the insertion:\n+\n+.. code-block:: java\n+\n+    ClientBuilder cb = Clients.builder(...);\n+\n+    // #2 HTTP decorator.\n+    cb.decorator((delegate, ctx, httpReq) -> {\n+        System.err.println(\"Fourthly, executed.\");\n+        ...\n+    });\n+\n+    // #2 RPC decorator.\n+    cb.rpcDecorator((delegate, ctx, rpcReq) -> {\n+        System.err.println(\"Secondly, executed.\");\n+        ...\n+    });\n+\n+    // #1 HTTP decorator.\n+    cb.decorator((delegate, ctx, httpReq) -> {\n+        System.err.println(\"Thirdly, executed.\");\n+        ...\n+    });\n+\n+    // #1 RPC decorator.\n+    cb.rpcDecorator((delegate, ctx, rpcReq) -> {\n+        System.err.println(\"Firstly, executed.\");\n+        ...\n+    });\n+\n+An RPC request is converted into an HTTP request before it's sent to a server.\n+Therefore, RPC decorators are inserted before the RPC request is converted and HTTP decorators are inserted", "originalCommit": "4815713e5dfac14e467552636f77f7fcda22bd1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyOTg2Mg==", "url": "https://github.com/line/armeria/pull/2568#discussion_r390729862", "bodyText": "That's a good suggestion. Fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-03-11T03:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyODU2NA=="}], "type": "inlineReview"}, {"oid": "4da6e5041eb7ac54a964e133ab968a5ea638161b", "url": "https://github.com/line/armeria/commit/4da6e5041eb7ac54a964e133ab968a5ea638161b", "message": "Address the comment by @ikhoon", "committedDate": "2020-03-11T03:38:27Z", "type": "commit"}]}