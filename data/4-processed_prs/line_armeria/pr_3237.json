{"pr_number": 3237, "pr_title": "HttpResponse.of(ResponseHeaders,Publisher<HttpObject>)", "pr_createdAt": "2020-12-18T11:27:31Z", "pr_url": "https://github.com/line/armeria/pull/3237", "timeline": [{"oid": "aa07137110b6427dc3ec6c0f2d3a1db511cf55a9", "url": "https://github.com/line/armeria/commit/aa07137110b6427dc3ec6c0f2d3a1db511cf55a9", "message": "Build response from headers and HttpData publisher", "committedDate": "2020-12-18T11:19:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQzNjc5Ng==", "url": "https://github.com/line/armeria/pull/3237#discussion_r548436796", "bodyText": "<HttpData> -> <? extends HttpData> ?", "author": "trustin", "createdAt": "2020-12-24T07:57:29Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpResponse.java", "diffHunk": "@@ -392,6 +392,16 @@ static HttpResponse of(Publisher<? extends HttpObject> publisher) {\n         }\n     }\n \n+    /**\n+     * Creates a new HTTP response of the specified headers whose content is produced from an existing\n+     * {@link Publisher}.\n+     */\n+    static HttpResponse of(ResponseHeaders headers, Publisher<HttpData> contentPublisher) {", "originalCommit": "aa07137110b6427dc3ec6c0f2d3a1db511cf55a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQzNjkwMg==", "url": "https://github.com/line/armeria/pull/3237#discussion_r548436902", "bodyText": "Ditto <HttpData> -> <? extends HttpData>", "author": "trustin", "createdAt": "2020-12-24T07:57:50Z", "path": "core/src/main/java/com/linecorp/armeria/common/PublisherBasedHttpResponse.java", "diffHunk": "@@ -25,4 +30,76 @@\n     PublisherBasedHttpResponse(Publisher<? extends HttpObject> publisher) {\n         super(publisher);\n     }\n+\n+    static PublisherBasedHttpResponse from(ResponseHeaders headers, Publisher<HttpData> contentPublisher) {", "originalCommit": "aa07137110b6427dc3ec6c0f2d3a1db511cf55a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "73ae26836b21045463a5b2a953e4f1bd40305c86", "url": "https://github.com/line/armeria/commit/73ae26836b21045463a5b2a953e4f1bd40305c86", "message": "Address reviews", "committedDate": "2020-12-26T09:13:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTMzODkwOQ==", "url": "https://github.com/line/armeria/pull/3237#discussion_r549338909", "bodyText": "This doesn't work:\nfinal HttpResponse res = HttpResponse.of(ResponseHeaders.of(200), Mono.empty());\nres.aggregate().join();\nHow about subscribing to contentPublisher after PublisherBasedHttpResponse.subscribe(...) is called?", "author": "minwoox", "createdAt": "2020-12-28T12:57:52Z", "path": "core/src/main/java/com/linecorp/armeria/common/PublisherBasedHttpResponse.java", "diffHunk": "@@ -25,4 +30,77 @@\n     PublisherBasedHttpResponse(Publisher<? extends HttpObject> publisher) {\n         super(publisher);\n     }\n+\n+    static PublisherBasedHttpResponse from(ResponseHeaders headers,\n+                                           Publisher<? extends HttpData> contentPublisher) {\n+        return new PublisherBasedHttpResponse(new HeadersAndContentProcessor(headers, contentPublisher));\n+    }\n+\n+    static final class HeadersAndContentProcessor implements Processor<HttpData, HttpObject> {\n+\n+        private final ResponseHeaders headers;\n+        @Nullable\n+        private Subscriber<? super HttpObject> subscriber;\n+        @Nullable\n+        private Subscription contentSubscription;\n+\n+        HeadersAndContentProcessor(ResponseHeaders headers, Publisher<? extends HttpData> contentPublisher) {\n+            this.headers = headers;\n+            contentPublisher.subscribe(this);", "originalCommit": "73ae26836b21045463a5b2a953e4f1bd40305c86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI1MjQ2MA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r550252460", "bodyText": "If we contentPublisher.subscribe after PublisherBasedHttpResponse.subscribe the subscriber starts requesting before we get contentSubscription. I figured the problem was for Mono.empty, onComplete is called immediately after subscribing, hence subscriber is null. I handled this case in the latest commit \ud83d\ude04", "author": "tumile", "createdAt": "2020-12-30T16:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTMzODkwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM2ODg2NA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r550368864", "bodyText": "Subscriber.onError(t) can also be called before this processor is subscribed. https://github.com/reactive-streams/reactive-streams-jvm#2.10\nAlso we should use volatile for contentCompleted because more than one thread might access the field. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-12-31T01:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTMzODkwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM3NjEwOQ==", "url": "https://github.com/line/armeria/pull/3237#discussion_r550376109", "bodyText": "I figured the problem was for Mono.empty, onComplete is called immediately after subscribing, hence subscriber is null\n\nThis bug was made by my previous work.\nI added a fix to https://github.com/line/armeria/pull/3254/files#diff-d397601b7ec794ee0cac14520792616a29132a6118e337975c86ad5d896b032cR141-R144", "author": "ikhoon", "createdAt": "2020-12-31T02:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTMzODkwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM4MDkwNQ==", "url": "https://github.com/line/armeria/pull/3237#discussion_r550380905", "bodyText": "I think it's not related to the bug. \ud83d\ude04\nonError() and onComplete() can be called without preceding subscription.request().\nhttps://github.com/reactive-streams/reactive-streams-jvm#2.10\nSo we shouldn't do assert subscriber != null in those methods.", "author": "minwoox", "createdAt": "2020-12-31T02:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTMzODkwOQ=="}], "type": "inlineReview"}, {"oid": "c5ce1953e1a5a97d32def7e343a5eb57d8ecd4a1", "url": "https://github.com/line/armeria/commit/c5ce1953e1a5a97d32def7e343a5eb57d8ecd4a1", "message": "Fix onComplete called before subscribed", "committedDate": "2020-12-30T16:05:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM3OTY1OA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r550379658", "bodyText": "How about generalizing this class such as PrependingPublisher? (could be in internal.common.stream)\nclass PrependingPublisher<T> implements Publisher<T> {\n\n    PrependingPublisher(T first, Publisher<? extends T> publisher) {\n        ...\n    }\n}\n\n\nIt would be better to replace Processor with Publisher if we generalize it.\n\n\nThe Subscriber interface could move to HeadersAndContentSubscription (perhaps we need a better name)\n\nBy moving Subscriber to SubscriptionImpl, we don't need to care if subscriber is null\nclass SubscriptionImpl implements Subscriber<T>, Subscription {\n\n    // This is non-null always.\n    private final Subscriber<T> subscriber;\n\n    SubscriptionImpl (Subscriber<T> subscriber) {\n    \n   }\n}\n\n\n\n\nLet's add Reactive Streams TCK for the PrependingPublisher.", "author": "ikhoon", "createdAt": "2020-12-31T02:31:43Z", "path": "core/src/main/java/com/linecorp/armeria/common/PublisherBasedHttpResponse.java", "diffHunk": "@@ -25,4 +30,86 @@\n     PublisherBasedHttpResponse(Publisher<? extends HttpObject> publisher) {\n         super(publisher);\n     }\n+\n+    static PublisherBasedHttpResponse from(ResponseHeaders headers,\n+                                           Publisher<? extends HttpData> contentPublisher) {\n+        return new PublisherBasedHttpResponse(new HeadersAndContentProcessor(headers, contentPublisher));\n+    }\n+\n+    static final class HeadersAndContentProcessor implements Processor<HttpData, HttpObject> {", "originalCommit": "c5ce1953e1a5a97d32def7e343a5eb57d8ecd4a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM5OTU0NQ==", "url": "https://github.com/line/armeria/pull/3237#discussion_r550399545", "bodyText": "Ah yes it is indeed cleaner. Here's what I've put together. Let me know what you think.\nCode\nstatic class PrependingPublisher<T> implements Publisher<T> {\n\n    private final T first;\n    private final Publisher<? extends T> rest;\n\n    PrependingPublisher(T first, Publisher<? extends T> rest) {\n        this.first = first;\n        this.rest = rest;\n    }\n\n    @Override\n    public void subscribe(Subscriber<? super T> subscriber) {\n        final RestSubscriber restSubscriber = new RestSubscriber(subscriber);\n        rest.subscribe(restSubscriber);\n    }\n\n    class RestSubscriber implements Subscriber<T>, Subscription {\n\n        private final Subscriber<? super T> subscriber;\n        @Nullable\n        private volatile Subscription subscription;\n        @Nullable\n        private volatile Throwable error;\n        private volatile boolean completed;\n        private volatile boolean firstSent;\n\n        RestSubscriber(Subscriber<? super T> subscriber) {\n            this.subscriber = subscriber;\n        }\n\n        @Override\n        public void onSubscribe(Subscription subscription) {\n            this.subscription = subscription;\n            subscriber.onSubscribe(this);\n        }\n\n        @Override\n        public void onNext(T t) {\n            subscriber.onNext(t);\n        }\n\n        @Override\n        public void onError(Throwable t) {\n            // delay onError until the first piece is sent\n            if (!firstSent) {\n                error = t;\n            } else {\n                subscriber.onError(t);\n            }\n        }\n\n        @Override\n        public void onComplete() {\n            // delay onComplete until the first piece is sent\n            if (!firstSent) {\n                completed = true;\n            } else {\n                subscriber.onComplete();\n            }\n        }\n\n        @Override\n        public void request(long n) {\n            if (!firstSent) {\n                subscriber.onNext(first);\n                n--;\n                firstSent = true;\n            }\n            if (n > 0) {\n                if (error != null) {\n                    subscriber.onError(error);\n                } else if (completed) {\n                    subscriber.onComplete();\n                } else {\n                    subscription.request(n);\n                }\n            }\n        }\n\n        @Override\n        public void cancel() {\n            subscription.cancel();\n        }\n    }\n}", "author": "tumile", "createdAt": "2020-12-31T05:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM3OTY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQwMzk5NA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r550403994", "bodyText": "Yeah. It looks nice to me. \ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-12-31T05:56:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM3OTY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQzOTg1Mg==", "url": "https://github.com/line/armeria/pull/3237#discussion_r550439852", "bodyText": "I'll look into the TCK. Seems like many things are failing now \ud83e\udd23 Is it the goal to pass all TCK cases?", "author": "tumile", "createdAt": "2020-12-31T09:30:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM3OTY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM0ODkwNQ==", "url": "https://github.com/line/armeria/pull/3237#discussion_r552348905", "bodyText": "I've added the TCK tests. There were exceptions for rules 1.4 and 1.9 which I had to override some code (I've put comments there). Please take a look!\n\n  \n    \n      armeria/core/src/test/java/com/linecorp/armeria/internal/common/stream/PrependingPublisherTckTest.java\n    \n    \n         Line 47\n      in\n      afd7938\n    \n    \n    \n    \n\n        \n          \n           /**", "author": "tumile", "createdAt": "2021-01-06T03:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM3OTY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4MjkwNA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r552382904", "bodyText": "Is it the goal to pass all TCK cases?\n\nYes. If it is possible. \ud83d\ude09 However, we can ignore it in certain cases.", "author": "ikhoon", "createdAt": "2021-01-06T05:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM3OTY1OA=="}], "type": "inlineReview"}, {"oid": "3838c27b95ac9925b98eb4ca4eb56a252c3e4df8", "url": "https://github.com/line/armeria/commit/3838c27b95ac9925b98eb4ca4eb56a252c3e4df8", "message": "Add PrependingPublisher", "committedDate": "2020-12-31T09:27:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTA5MTE3NA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r551091174", "bodyText": "A non-positive request is illegal. Should send IllegalArgumentException to the subscriber via onError https://github.com/reactive-streams/reactive-streams-jvm#3.9", "author": "ikhoon", "createdAt": "2021-01-04T02:24:59Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        final RestSubscriber restSubscriber = new RestSubscriber(subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    final class RestSubscriber implements Subscriber<T>, Subscription {\n+\n+        private final Subscriber<? super T> subscriber;\n+        @Nullable\n+        private volatile Subscription subscription;\n+        @Nullable\n+        private volatile Throwable cause;\n+        private volatile boolean completed;\n+        private volatile boolean firstSent;\n+\n+        RestSubscriber(Subscriber<? super T> subscriber) {\n+            this.subscriber = subscriber;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscriber.onSubscribe(this);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {\n+            subscriber.onNext(t);\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            // delay onError until the first piece is sent\n+            if (!firstSent) {\n+                cause = t;\n+            } else {\n+                subscriber.onError(t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // delay onComplete until the first piece is sent\n+            if (!firstSent) {\n+                completed = true;\n+            } else {\n+                subscriber.onComplete();\n+            }\n+        }\n+\n+        @Override\n+        public void request(long n) {", "originalCommit": "3838c27b95ac9925b98eb4ca4eb56a252c3e4df8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTA5MTQxNQ==", "url": "https://github.com/line/armeria/pull/3237#discussion_r551091415", "bodyText": "We should not decrease the n value if it is Long.MAX_VALUE", "author": "ikhoon", "createdAt": "2021-01-04T02:26:13Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        final RestSubscriber restSubscriber = new RestSubscriber(subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    final class RestSubscriber implements Subscriber<T>, Subscription {\n+\n+        private final Subscriber<? super T> subscriber;\n+        @Nullable\n+        private volatile Subscription subscription;\n+        @Nullable\n+        private volatile Throwable cause;\n+        private volatile boolean completed;\n+        private volatile boolean firstSent;\n+\n+        RestSubscriber(Subscriber<? super T> subscriber) {\n+            this.subscriber = subscriber;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscriber.onSubscribe(this);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {\n+            subscriber.onNext(t);\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            // delay onError until the first piece is sent\n+            if (!firstSent) {\n+                cause = t;\n+            } else {\n+                subscriber.onError(t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // delay onComplete until the first piece is sent\n+            if (!firstSent) {\n+                completed = true;\n+            } else {\n+                subscriber.onComplete();\n+            }\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (!firstSent) {\n+                subscriber.onNext(first);\n+                n--;", "originalCommit": "3838c27b95ac9925b98eb4ca4eb56a252c3e4df8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTA5MTg1MQ==", "url": "https://github.com/line/armeria/pull/3237#discussion_r551091851", "bodyText": "If cancel() is called, this publisher should drop the subscriber reference to be garbage-collected. https://github.com/reactive-streams/reactive-streams-jvm#3.13", "author": "ikhoon", "createdAt": "2021-01-04T02:28:42Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        final RestSubscriber restSubscriber = new RestSubscriber(subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    final class RestSubscriber implements Subscriber<T>, Subscription {\n+\n+        private final Subscriber<? super T> subscriber;\n+        @Nullable\n+        private volatile Subscription subscription;\n+        @Nullable\n+        private volatile Throwable cause;\n+        private volatile boolean completed;\n+        private volatile boolean firstSent;\n+\n+        RestSubscriber(Subscriber<? super T> subscriber) {\n+            this.subscriber = subscriber;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subscription = subscription;\n+            subscriber.onSubscribe(this);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {\n+            subscriber.onNext(t);\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            // delay onError until the first piece is sent\n+            if (!firstSent) {\n+                cause = t;\n+            } else {\n+                subscriber.onError(t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // delay onComplete until the first piece is sent\n+            if (!firstSent) {\n+                completed = true;\n+            } else {\n+                subscriber.onComplete();\n+            }\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (!firstSent) {\n+                subscriber.onNext(first);\n+                n--;\n+                firstSent = true;\n+            }\n+            if (n > 0) {\n+                if (cause != null) {\n+                    subscriber.onError(cause);\n+                } else if (completed) {\n+                    subscriber.onComplete();\n+                } else {\n+                    subscription.request(n);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            subscription.cancel();", "originalCommit": "3838c27b95ac9925b98eb4ca4eb56a252c3e4df8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "afd7938b14681af8941a1cd450d25b9904372d56", "url": "https://github.com/line/armeria/commit/afd7938b14681af8941a1cd450d25b9904372d56", "message": "Add PrependingPublisherTckTest", "committedDate": "2021-01-05T17:16:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4MzU0NA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r552383544", "bodyText": "This publisher only manages first internally. Can we specially handle first and remove demand?", "author": "ikhoon", "createdAt": "2021-01-06T05:52:43Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber restSubscriber = new RestSubscriber(subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    final class RestSubscriber implements Subscriber<T>, Subscription {\n+\n+        private Subscriber<? super T> downstream;\n+        private final AtomicLong demand = new AtomicLong();", "originalCommit": "afd7938b14681af8941a1cd450d25b9904372d56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI5NTI4NA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r554295284", "bodyText": "Sorry for the late response \ud83d\ude04 To clarify, (maybe you know this already, but just to be sure we're on the same page) demand is used to satisfy rule 3.3, to avoid overflow in such case request->onNext->request->... . If demand.getAndAdd(n) > 0, i.e we already have an ongoing request, we should stop. It doesn't really concern first.", "author": "tumile", "createdAt": "2021-01-09T05:39:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4MzU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDM3MTgxOQ==", "url": "https://github.com/line/armeria/pull/3237#discussion_r554371819", "bodyText": "Ah. I got it. \ud83d\udc4d How about using AtomicLongFieldUpdater with a volatile variable to reduce memory footprint?", "author": "ikhoon", "createdAt": "2021-01-09T10:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4MzU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NTQzOQ==", "url": "https://github.com/line/armeria/pull/3237#discussion_r552385439", "bodyText": "Replace with NoopSubscriber.get()?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        downstream = null;\n          \n          \n            \n                        downstream = NoopSubscriber.get();", "author": "ikhoon", "createdAt": "2021-01-06T05:59:32Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber restSubscriber = new RestSubscriber(subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    final class RestSubscriber implements Subscriber<T>, Subscription {\n+\n+        private Subscriber<? super T> downstream;\n+        private final AtomicLong demand = new AtomicLong();\n+        @Nullable\n+        private volatile Subscription upstream;\n+        @Nullable\n+        private volatile Throwable upstreamCause;\n+        private volatile boolean upstreamCompleted;\n+        private volatile boolean completed;\n+        private volatile boolean firstSent;\n+\n+        RestSubscriber(Subscriber<? super T> downstream) {\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.upstream = subscription;\n+            downstream.onSubscribe(this);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {\n+            demand.decrementAndGet();\n+            downstream.onNext(t);\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            // delay onError until the first piece is sent\n+            if (!firstSent) {\n+                upstreamCause = t;\n+            } else {\n+                downstream.onError(t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // delay onComplete until the first piece is sent\n+            if (!firstSent) {\n+                upstreamCompleted = true;\n+            } else {\n+                downstream.onComplete();\n+            }\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                downstream.onError(new IllegalArgumentException(\"non-positive request signals are illegal\"));\n+                return;\n+            }\n+            if (completed) {\n+                return;\n+            }\n+            if (demand.getAndAdd(n) > 0) {\n+                return;\n+            }\n+            if (!firstSent) {\n+                firstSent = true;\n+                downstream.onNext(first);\n+                if (n < Long.MAX_VALUE) {\n+                    demand.decrementAndGet();\n+                }\n+            }\n+            if (demand.get() > 0) {\n+                if (upstreamCause != null) {\n+                    downstream.onError(upstreamCause);\n+                } else if (upstreamCompleted) {\n+                    completed = true;\n+                    downstream.onComplete();\n+                } else {\n+                    upstream.request(demand.get());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            if (completed) {\n+                return;\n+            }\n+            completed = true;\n+            downstream = null;", "originalCommit": "afd7938b14681af8941a1cd450d25b9904372d56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NTgwOA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r552385808", "bodyText": "requireNonNull?\nhttps://github.com/reactive-streams/reactive-streams-jvm#2.13", "author": "ikhoon", "createdAt": "2021-01-06T06:00:50Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber restSubscriber = new RestSubscriber(subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    final class RestSubscriber implements Subscriber<T>, Subscription {\n+\n+        private Subscriber<? super T> downstream;\n+        private final AtomicLong demand = new AtomicLong();\n+        @Nullable\n+        private volatile Subscription upstream;\n+        @Nullable\n+        private volatile Throwable upstreamCause;\n+        private volatile boolean upstreamCompleted;\n+        private volatile boolean completed;\n+        private volatile boolean firstSent;\n+\n+        RestSubscriber(Subscriber<? super T> downstream) {\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.upstream = subscription;\n+            downstream.onSubscribe(this);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {", "originalCommit": "afd7938b14681af8941a1cd450d25b9904372d56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NTgyOQ==", "url": "https://github.com/line/armeria/pull/3237#discussion_r552385829", "bodyText": "requireNonNull?\nhttps://github.com/reactive-streams/reactive-streams-jvm#2.13", "author": "ikhoon", "createdAt": "2021-01-06T06:00:58Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber restSubscriber = new RestSubscriber(subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    final class RestSubscriber implements Subscriber<T>, Subscription {\n+\n+        private Subscriber<? super T> downstream;\n+        private final AtomicLong demand = new AtomicLong();\n+        @Nullable\n+        private volatile Subscription upstream;\n+        @Nullable\n+        private volatile Throwable upstreamCause;\n+        private volatile boolean upstreamCompleted;\n+        private volatile boolean completed;\n+        private volatile boolean firstSent;\n+\n+        RestSubscriber(Subscriber<? super T> downstream) {\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.upstream = subscription;\n+            downstream.onSubscribe(this);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {\n+            demand.decrementAndGet();\n+            downstream.onNext(t);\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {", "originalCommit": "afd7938b14681af8941a1cd450d25b9904372d56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NjkyNA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r552386924", "bodyText": "How about introducing a local variable for upstreamCause to avoid accessing the volatile variable twice?", "author": "ikhoon", "createdAt": "2021-01-06T06:05:09Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber restSubscriber = new RestSubscriber(subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    final class RestSubscriber implements Subscriber<T>, Subscription {\n+\n+        private Subscriber<? super T> downstream;\n+        private final AtomicLong demand = new AtomicLong();\n+        @Nullable\n+        private volatile Subscription upstream;\n+        @Nullable\n+        private volatile Throwable upstreamCause;\n+        private volatile boolean upstreamCompleted;\n+        private volatile boolean completed;\n+        private volatile boolean firstSent;\n+\n+        RestSubscriber(Subscriber<? super T> downstream) {\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.upstream = subscription;\n+            downstream.onSubscribe(this);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {\n+            demand.decrementAndGet();\n+            downstream.onNext(t);\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            // delay onError until the first piece is sent\n+            if (!firstSent) {\n+                upstreamCause = t;\n+            } else {\n+                downstream.onError(t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // delay onComplete until the first piece is sent\n+            if (!firstSent) {\n+                upstreamCompleted = true;\n+            } else {\n+                downstream.onComplete();\n+            }\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                downstream.onError(new IllegalArgumentException(\"non-positive request signals are illegal\"));\n+                return;\n+            }\n+            if (completed) {\n+                return;\n+            }\n+            if (demand.getAndAdd(n) > 0) {\n+                return;\n+            }\n+            if (!firstSent) {\n+                firstSent = true;\n+                downstream.onNext(first);\n+                if (n < Long.MAX_VALUE) {\n+                    demand.decrementAndGet();\n+                }\n+            }\n+            if (demand.get() > 0) {\n+                if (upstreamCause != null) {\n+                    downstream.onError(upstreamCause);", "originalCommit": "afd7938b14681af8941a1cd450d25b9904372d56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4ODA3Mw==", "url": "https://github.com/line/armeria/pull/3237#discussion_r552388073", "bodyText": "Don't we need to pass the request signal to upstream if the previous demand is 0?", "author": "ikhoon", "createdAt": "2021-01-06T06:09:08Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber restSubscriber = new RestSubscriber(subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    final class RestSubscriber implements Subscriber<T>, Subscription {\n+\n+        private Subscriber<? super T> downstream;\n+        private final AtomicLong demand = new AtomicLong();\n+        @Nullable\n+        private volatile Subscription upstream;\n+        @Nullable\n+        private volatile Throwable upstreamCause;\n+        private volatile boolean upstreamCompleted;\n+        private volatile boolean completed;\n+        private volatile boolean firstSent;\n+\n+        RestSubscriber(Subscriber<? super T> downstream) {\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.upstream = subscription;\n+            downstream.onSubscribe(this);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {\n+            demand.decrementAndGet();\n+            downstream.onNext(t);\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            // delay onError until the first piece is sent\n+            if (!firstSent) {\n+                upstreamCause = t;\n+            } else {\n+                downstream.onError(t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // delay onComplete until the first piece is sent\n+            if (!firstSent) {\n+                upstreamCompleted = true;\n+            } else {\n+                downstream.onComplete();\n+            }\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                downstream.onError(new IllegalArgumentException(\"non-positive request signals are illegal\"));\n+                return;\n+            }\n+            if (completed) {\n+                return;\n+            }\n+            if (demand.getAndAdd(n) > 0) {\n+                return;\n+            }", "originalCommit": "afd7938b14681af8941a1cd450d25b9904372d56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI5NTcwMA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r554295700", "bodyText": "If previous demand is 0 then after getAndAdd, this should be able to execute \n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java\n    \n    \n         Line 113\n      in\n      afd7938\n    \n    \n    \n    \n\n        \n          \n           if (demand.get() > 0) { \n        \n    \n  \n\n\nI'm not sure I follow you here \ud83d\ude05", "author": "tumile", "createdAt": "2021-01-09T05:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4ODA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4ODE5NA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r552388194", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.upstream = subscription;\n          \n          \n            \n                        upstream = subscription;", "author": "ikhoon", "createdAt": "2021-01-06T06:09:41Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber restSubscriber = new RestSubscriber(subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    final class RestSubscriber implements Subscriber<T>, Subscription {\n+\n+        private Subscriber<? super T> downstream;\n+        private final AtomicLong demand = new AtomicLong();\n+        @Nullable\n+        private volatile Subscription upstream;\n+        @Nullable\n+        private volatile Throwable upstreamCause;\n+        private volatile boolean upstreamCompleted;\n+        private volatile boolean completed;\n+        private volatile boolean firstSent;\n+\n+        RestSubscriber(Subscriber<? super T> downstream) {\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.upstream = subscription;", "originalCommit": "afd7938b14681af8941a1cd450d25b9904372d56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MTczNw==", "url": "https://github.com/line/armeria/pull/3237#discussion_r552391737", "bodyText": "How about adding an assertion for always receiving the first element from the failed publisher?", "author": "ikhoon", "createdAt": "2021-01-06T06:22:38Z", "path": "core/src/test/java/com/linecorp/armeria/internal/common/stream/PrependingPublisherTckTest.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import java.util.stream.LongStream;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscription;\n+import org.reactivestreams.tck.PublisherVerification;\n+import org.reactivestreams.tck.TestEnvironment;\n+import org.reactivestreams.tck.flow.support.PublisherVerificationRules;\n+import org.testng.SkipException;\n+import org.testng.annotations.Test;\n+\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+@SuppressWarnings(\"checkstyle:LineLength\")\n+public class PrependingPublisherTckTest extends PublisherVerification<Object> {\n+\n+    public PrependingPublisherTckTest() {\n+        super(new TestEnvironment(200));\n+    }\n+\n+    @Override\n+    public Publisher<Object> createPublisher(long elements) {\n+        if (elements == 0) {\n+            return Mono.empty();\n+        }\n+        return new PrependingPublisher<>(\"Hello\", Flux.fromStream(LongStream.range(0, elements - 1).boxed()));\n+    }\n+\n+    /**\n+     * Rule 1.4 and 1.9 ensure a Publisher's ability to signal error to the Subscriber, however the\n+     * implementation expects such error to occur immediately after subscribing, i.e. {@code onError()} is\n+     * called after {@code onSubscribe()}. The {@link PrependingPublisher} however always serves at least one\n+     * element before failing, therefore for the error to be signaled, we must make requests first.\n+     *\n+     * {@link PublisherVerificationRules#optional_spec104_mustSignalOnErrorWhenFails()} and\n+     * {@link PublisherVerificationRules#required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe()}\n+     * are overridden below to call {@link Subscription#request(long)} after subscribing.\n+     */\n+    @Override\n+    public Publisher<Object> createFailedPublisher() {\n+        return new PrependingPublisher<>(\"Hello\", Mono.error(new RuntimeException()));\n+    }\n+\n+    @Test\n+    @Override\n+    public void optional_spec104_mustSignalOnErrorWhenFails() {\n+        try {\n+            final TestEnvironment env = new TestEnvironment(200);\n+            whenHasErrorPublisherTest(pub -> {\n+                final TestEnvironment.Latch onErrorLatch = new TestEnvironment.Latch(env);\n+                final TestEnvironment.Latch onSubscribeLatch = new TestEnvironment.Latch(env);\n+                pub.subscribe(new TestEnvironment.TestSubscriber<Object>(env) {\n+                    @Override\n+                    public void onSubscribe(Subscription subs) {\n+                        onSubscribeLatch.assertOpen(\"Only one onSubscribe call expected\");\n+                        onSubscribeLatch.close();\n+                        subs.request(Long.MAX_VALUE);\n+                    }\n+\n+                    @Override\n+                    public void onNext(Object element) {", "originalCommit": "afd7938b14681af8941a1cd450d25b9904372d56", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bddfd66c903f7a705ebe60db315db65c61d3cb81", "url": "https://github.com/line/armeria/commit/bddfd66c903f7a705ebe60db315db65c61d3cb81", "message": "Address reviews by @ikhoon", "committedDate": "2021-01-15T06:23:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI0OTAzMA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r558249030", "bodyText": "nit: Please declare static fields before member fields.\nhttps://armeria.dev/community/developer-guide#organize", "author": "ikhoon", "createdAt": "2021-01-15T11:33:45Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber<T> restSubscriber = new RestSubscriber<>(first, subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    static final class RestSubscriber<T> implements Subscriber<T>, Subscription {\n+\n+        private final T first;\n+        private volatile boolean firstSent;\n+\n+        private Subscriber<? super T> downstream;\n+        private volatile long demand;\n+        private static final AtomicLongFieldUpdater<RestSubscriber> demandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(RestSubscriber.class, \"demand\");", "originalCommit": "bddfd66c903f7a705ebe60db315db65c61d3cb81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1NDQwNA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r558254404", "bodyText": "Don't we need to accept a trailer here?\nWhich is better:\n// May produce a `trailers` at the end of streams\n// We need to check whether an HttpObject is an instance of HttpData before receiving a `trailers` at runtime. \nHttpResponse of(ResponseHeaders headers, Publisher<? extends HttpObject> contentPublisher) {\n}\n\n// Or separately take `tailers`?\n// This is type-safe but the signature is a bit verbose.\nHttpResponse of(ResponseHeaders headers, Publisher<? extends HttpData> contentPublisher, CompletableFuture<HttpHeaders> trailers) {\n}", "author": "ikhoon", "createdAt": "2021-01-15T11:45:11Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpResponse.java", "diffHunk": "@@ -392,6 +392,16 @@ static HttpResponse of(Publisher<? extends HttpObject> publisher) {\n         }\n     }\n \n+    /**\n+     * Creates a new HTTP response of the specified headers whose content is produced from an existing\n+     * {@link Publisher}.\n+     */\n+    static HttpResponse of(ResponseHeaders headers, Publisher<? extends HttpData> contentPublisher) {", "originalCommit": "bddfd66c903f7a705ebe60db315db65c61d3cb81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMzNzczNw==", "url": "https://github.com/line/armeria/pull/3237#discussion_r558337737", "bodyText": "Because we already have HttpResponse.of(Publisher<? extends HttpObject>), I'd say HttpResponse.of(ResponseHeaders, Publisher<? extends HttpObject>) seems better, it's like syntactic sugar for the former (which I think is the purpose of this addition). For the order of data/trailers, isn't it handled in HttpResponseSubscriber?", "author": "tumile", "createdAt": "2021-01-15T14:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1NDQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI4ODYzOA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r559288638", "bodyText": "I'd say HttpResponse.of(ResponseHeaders, Publisher<? extends HttpObject>) seems better\n\n+1. Let's go with Publisher<? extends HttpObject>.\n\nFor the order of data/trailers, isn't it handled in HttpResponseSubscriber?\n\nYes. It is already checked by HttpResponseSubscriber. PrependingPublisher does not need to handle it.", "author": "ikhoon", "createdAt": "2021-01-18T02:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1NDQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUzNTM4NA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r559535384", "bodyText": "+1 for Publisher<? extends HttpObject>\nAlso, we should rename the contentPublisher to just publisher because it might contain trailers.", "author": "minwoox", "createdAt": "2021-01-18T12:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI1NDQwNA=="}], "type": "inlineReview"}, {"oid": "15f571191972e787b6046399039df0fb01092d55", "url": "https://github.com/line/armeria/commit/15f571191972e787b6046399039df0fb01092d55", "message": "Address reviews", "committedDate": "2021-01-19T13:57:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUzNzE2Ng==", "url": "https://github.com/line/armeria/pull/3237#discussion_r559537166", "bodyText": "Could you move this static factory method on to the constructor?", "author": "minwoox", "createdAt": "2021-01-18T12:36:58Z", "path": "core/src/main/java/com/linecorp/armeria/common/PublisherBasedHttpResponse.java", "diffHunk": "@@ -19,10 +19,16 @@\n import org.reactivestreams.Publisher;\n \n import com.linecorp.armeria.common.stream.PublisherBasedStreamMessage;\n+import com.linecorp.armeria.internal.common.stream.PrependingPublisher;\n \n final class PublisherBasedHttpResponse extends PublisherBasedStreamMessage<HttpObject> implements HttpResponse {\n \n     PublisherBasedHttpResponse(Publisher<? extends HttpObject> publisher) {\n         super(publisher);\n     }\n+\n+    static PublisherBasedHttpResponse from(ResponseHeaders headers,", "originalCommit": "bddfd66c903f7a705ebe60db315db65c61d3cb81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDY0MDYxNw==", "url": "https://github.com/line/armeria/pull/3237#discussion_r560640617", "bodyText": "I think we have to handle the overflow case such as calling with 2 and Long.MAX_VALUE subsequently.\nWe can use for loop and you might want to refer https://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/common/stream/DefaultStreamMessage.java#L243", "author": "minwoox", "createdAt": "2021-01-20T02:55:04Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber<T> restSubscriber = new RestSubscriber<>(first, subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    static final class RestSubscriber<T> implements Subscriber<T>, Subscription {\n+\n+        private static final AtomicLongFieldUpdater<RestSubscriber> demandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(RestSubscriber.class, \"demand\");\n+        private final T first;\n+        private volatile boolean firstSent;\n+        private Subscriber<? super T> downstream;\n+        private volatile long demand;\n+        @Nullable\n+        private volatile Subscription upstream;\n+        @Nullable\n+        private volatile Throwable upstreamCause;\n+        private volatile boolean upstreamCompleted;\n+        private volatile boolean completed;\n+\n+        RestSubscriber(T first, Subscriber<? super T> downstream) {\n+            this.first = first;\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            upstream = subscription;\n+            downstream.onSubscribe(this);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {\n+            requireNonNull(t, \"element\");\n+            demandUpdater.decrementAndGet(this);\n+            downstream.onNext(t);\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            requireNonNull(t, \"throwable\");\n+            // delay onError until the first piece is sent\n+            if (!firstSent) {\n+                upstreamCause = t;\n+            } else {\n+                downstream.onError(t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // delay onComplete until the first piece is sent\n+            if (!firstSent) {\n+                upstreamCompleted = true;\n+            } else {\n+                downstream.onComplete();\n+            }\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                downstream.onError(new IllegalArgumentException(\"non-positive request signals are illegal\"));\n+                return;\n+            }\n+            if (completed) {\n+                return;\n+            }\n+            if (demandUpdater.getAndAdd(this, n) > 0) {", "originalCommit": "15f571191972e787b6046399039df0fb01092d55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDY0MjQzOQ==", "url": "https://github.com/line/armeria/pull/3237#discussion_r560642439", "bodyText": "We don't decrement when the demand is Long.MAX_VALUE.", "author": "minwoox", "createdAt": "2021-01-20T03:00:20Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber<T> restSubscriber = new RestSubscriber<>(first, subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    static final class RestSubscriber<T> implements Subscriber<T>, Subscription {\n+\n+        private static final AtomicLongFieldUpdater<RestSubscriber> demandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(RestSubscriber.class, \"demand\");\n+        private final T first;\n+        private volatile boolean firstSent;\n+        private Subscriber<? super T> downstream;\n+        private volatile long demand;\n+        @Nullable\n+        private volatile Subscription upstream;\n+        @Nullable\n+        private volatile Throwable upstreamCause;\n+        private volatile boolean upstreamCompleted;\n+        private volatile boolean completed;\n+\n+        RestSubscriber(T first, Subscriber<? super T> downstream) {\n+            this.first = first;\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            upstream = subscription;\n+            downstream.onSubscribe(this);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {\n+            requireNonNull(t, \"element\");\n+            demandUpdater.decrementAndGet(this);", "originalCommit": "15f571191972e787b6046399039df0fb01092d55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDY0MjczNg==", "url": "https://github.com/line/armeria/pull/3237#discussion_r560642736", "bodyText": "I think this is not thread-safe.\nLet's say thread A executes line 85 and just before executing line 86.\nAnd thread B executes 115~130. Then we are going to miss this onError event.\nTo solve this simply, I think we can just call downstream.onNext(first) in onNext() or onComplete() of RestSubscriber. (in onError() I think we don't pass the first)\nThe request(...) method will just handle adding up the demand.\nI realized that it's not working. \ud83d\ude05 Let me get back to this later.", "author": "minwoox", "createdAt": "2021-01-20T03:01:26Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber<T> restSubscriber = new RestSubscriber<>(first, subscriber);\n+        rest.subscribe(restSubscriber);\n+    }\n+\n+    static final class RestSubscriber<T> implements Subscriber<T>, Subscription {\n+\n+        private static final AtomicLongFieldUpdater<RestSubscriber> demandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(RestSubscriber.class, \"demand\");\n+        private final T first;\n+        private volatile boolean firstSent;\n+        private Subscriber<? super T> downstream;\n+        private volatile long demand;\n+        @Nullable\n+        private volatile Subscription upstream;\n+        @Nullable\n+        private volatile Throwable upstreamCause;\n+        private volatile boolean upstreamCompleted;\n+        private volatile boolean completed;\n+\n+        RestSubscriber(T first, Subscriber<? super T> downstream) {\n+            this.first = first;\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            upstream = subscription;\n+            downstream.onSubscribe(this);\n+        }\n+\n+        @Override\n+        public void onNext(T t) {\n+            requireNonNull(t, \"element\");\n+            demandUpdater.decrementAndGet(this);\n+            downstream.onNext(t);\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            requireNonNull(t, \"throwable\");\n+            // delay onError until the first piece is sent\n+            if (!firstSent) {\n+                upstreamCause = t;", "originalCommit": "15f571191972e787b6046399039df0fb01092d55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQ1OTY2OQ==", "url": "https://github.com/line/armeria/pull/3237#discussion_r561459669", "bodyText": "I found out that it's a bit trickier to implement this because:\n\nThere's a chance that Subscriber.onComplete() and Subscription.request() is called at the same time.\n\nIn that case, onNext(first) should always be called before onComplete().\n\n\n\nTo solve this, I think we need to\n\nUse a queue that stores the elements in order.\nOr, subscribe to the rest after the first element is passed.\nEither way, it's fine for me. So it's your choice. \ud83d\ude04\nI tried the second approach though.\nhttps://gist.github.com/minwoox/8ceb11c72846b9f5eff791b399972a91\n(I didn't clean up the code. \ud83d\ude05 )", "author": "minwoox", "createdAt": "2021-01-21T01:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDY0MjczNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjMyNDQxMA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r562324410", "bodyText": "Or, subscribe to the rest after the first element is passed.\n\n\ud83d\udc4d", "author": "ikhoon", "createdAt": "2021-01-22T02:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDY0MjczNg=="}], "type": "inlineReview"}, {"oid": "c64f69803bf84b4a3cb2850adf3060fc09b37b1b", "url": "https://github.com/line/armeria/commit/c64f69803bf84b4a3cb2850adf3060fc09b37b1b", "message": "Address reviews by @minwoox", "committedDate": "2021-01-24T16:16:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ0ODIyNQ==", "url": "https://github.com/line/armeria/pull/3237#discussion_r563448225", "bodyText": "nit: Use LongMath.saturatedAdd(demand, n)?", "author": "ikhoon", "createdAt": "2021-01-25T03:45:45Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber<T> restSubscriber = new RestSubscriber<>(first, rest, subscriber);\n+        subscriber.onSubscribe(restSubscriber);\n+    }\n+\n+    static final class RestSubscriber<T> implements Subscriber<T>, Subscription {\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<RestSubscriber> demandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(RestSubscriber.class, \"demand\");\n+\n+        private final T first;\n+        private final Publisher<? extends T> rest;\n+        private Subscriber<? super T> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+        private volatile long demand;\n+        private volatile boolean firstSent;\n+        private volatile boolean subscribed;\n+        private volatile boolean cancelled;\n+\n+        RestSubscriber(T first, Publisher<? extends T> rest, Subscriber<? super T> downstream) {\n+            this.first = first;\n+            this.rest = rest;\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                downstream.onError(new IllegalArgumentException(\"non-positive request signals are illegal\"));\n+                return;\n+            }\n+            if (cancelled) {\n+                return;\n+            }\n+            for (;;) {\n+                final long demand = this.demand;\n+                final long newDemand = demand >= Long.MAX_VALUE - n ? Long.MAX_VALUE : demand + n;", "originalCommit": "c64f69803bf84b4a3cb2850adf3060fc09b37b1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ0OTg4Mw==", "url": "https://github.com/line/armeria/pull/3237#discussion_r563449883", "bodyText": "I think we don't have to check cancelled here because the subscriber will not call request after it calls cancel().\nPlease forget about this comment. \ud83d\ude05\n#3299 (comment)", "author": "minwoox", "createdAt": "2021-01-25T03:54:16Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber<T> restSubscriber = new RestSubscriber<>(first, rest, subscriber);\n+        subscriber.onSubscribe(restSubscriber);\n+    }\n+\n+    static final class RestSubscriber<T> implements Subscriber<T>, Subscription {\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<RestSubscriber> demandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(RestSubscriber.class, \"demand\");\n+\n+        private final T first;\n+        private final Publisher<? extends T> rest;\n+        private Subscriber<? super T> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+        private volatile long demand;\n+        private volatile boolean firstSent;\n+        private volatile boolean subscribed;\n+        private volatile boolean cancelled;\n+\n+        RestSubscriber(T first, Publisher<? extends T> rest, Subscriber<? super T> downstream) {\n+            this.first = first;\n+            this.rest = rest;\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                downstream.onError(new IllegalArgumentException(\"non-positive request signals are illegal\"));\n+                return;\n+            }\n+            if (cancelled) {", "originalCommit": "c64f69803bf84b4a3cb2850adf3060fc09b37b1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ1MDA0Mg==", "url": "https://github.com/line/armeria/pull/3237#discussion_r563450042", "bodyText": "I think we can remove volatile from firstSent and subscribed because there are accessed only by the subscriber thread.", "author": "minwoox", "createdAt": "2021-01-25T03:55:05Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber<T> restSubscriber = new RestSubscriber<>(first, rest, subscriber);\n+        subscriber.onSubscribe(restSubscriber);\n+    }\n+\n+    static final class RestSubscriber<T> implements Subscriber<T>, Subscription {\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<RestSubscriber> demandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(RestSubscriber.class, \"demand\");\n+\n+        private final T first;\n+        private final Publisher<? extends T> rest;\n+        private Subscriber<? super T> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+        private volatile long demand;\n+        private volatile boolean firstSent;\n+        private volatile boolean subscribed;", "originalCommit": "c64f69803bf84b4a3cb2850adf3060fc09b37b1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ1MDQwOA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r563450408", "bodyText": "Shouldn't we just remove this condition?", "author": "minwoox", "createdAt": "2021-01-25T03:56:50Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber<T> restSubscriber = new RestSubscriber<>(first, rest, subscriber);\n+        subscriber.onSubscribe(restSubscriber);\n+    }\n+\n+    static final class RestSubscriber<T> implements Subscriber<T>, Subscription {\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<RestSubscriber> demandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(RestSubscriber.class, \"demand\");\n+\n+        private final T first;\n+        private final Publisher<? extends T> rest;\n+        private Subscriber<? super T> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+        private volatile long demand;\n+        private volatile boolean firstSent;\n+        private volatile boolean subscribed;\n+        private volatile boolean cancelled;\n+\n+        RestSubscriber(T first, Publisher<? extends T> rest, Subscriber<? super T> downstream) {\n+            this.first = first;\n+            this.rest = rest;\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                downstream.onError(new IllegalArgumentException(\"non-positive request signals are illegal\"));\n+                return;\n+            }\n+            if (cancelled) {\n+                return;\n+            }\n+            for (;;) {\n+                final long demand = this.demand;\n+                final long newDemand = demand >= Long.MAX_VALUE - n ? Long.MAX_VALUE : demand + n;\n+                if (demandUpdater.compareAndSet(this, demand, newDemand)) {\n+                    if (demand > 0) {", "originalCommit": "c64f69803bf84b4a3cb2850adf3060fc09b37b1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzc3NTI2Mg==", "url": "https://github.com/line/armeria/pull/3237#discussion_r563775262", "bodyText": "We check this because if the previous demand is non-zero then there is already an ongoing request and we stop, otherwise it could lead to unbounded recursion request -> onNext -> request ->.... If I remove this rule 3.3 will fail \ud83d\ude04 .", "author": "tumile", "createdAt": "2021-01-25T14:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ1MDQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjA1Nzg2NA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r566057864", "bodyText": "Oops could you elaborate more on request -> onNext -> request ->..., please?\nIf we just return here, there's a chance the upstream.request(...) is not called.\nLet's say that thread A calls Subscription.request(2) twice.\nWhen the second Subscription.request(2) is called and if it's at line 84.\nMeanwhile, thread B is trying demandUpdater.compareAndSet(this, demand, 0) at line 138.\nIf the thread B fails to compareAndSet, then thread A might set the demand as 3 and there's no more upstream.request(demand); call", "author": "minwoox", "createdAt": "2021-01-28T12:30:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ1MDQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjEwMDcyNg==", "url": "https://github.com/line/armeria/pull/3237#discussion_r566100726", "bodyText": "Could the race condition be solved by adding a for loop in onSubscribe()?\n// Keep retrying to send a request signal until demain is zero\nfor (;;) {\n    final long demand = this.demand;\n    if (demand == 0) {\n        break;\n    }\n    if (demandUpdater.compareAndSet(this, demand, 0)) {\n        subscription.request(demand);\n    }\n}", "author": "ikhoon", "createdAt": "2021-01-28T13:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ1MDQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjcxOTk1NA==", "url": "https://github.com/line/armeria/pull/3237#discussion_r566719954", "bodyText": "@minwoox thanks for the detailed example. There's indeed a race condition. I think @ikhoon's solution should resolve that. Yet if (demand > 0) is for guarding stack overflow, so it should still be here? \ud83d\ude04", "author": "tumile", "createdAt": "2021-01-29T10:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ1MDQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzQxNTQzNw==", "url": "https://github.com/line/armeria/pull/3237#discussion_r567415437", "bodyText": "I probably might get this wrong, \ud83d\ude04  but if's it's for guarding a stack overflow,\nwhat happens when the thread calls upstream.request(demand) here?https://github.com/line/armeria/pull/3237/files#diff-a8dfc683de291a0ccbc6e0ab3c2bae463e462050ac18beca18b3adf6c14c1b5fR110\nIsn't it the same?", "author": "minwoox", "createdAt": "2021-01-31T12:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ1MDQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzU0NzIyMg==", "url": "https://github.com/line/armeria/pull/3237#discussion_r567547222", "bodyText": "Right, I get what you say \ud83d\ude04 . The condition is there to satisfy the TCK, which assumes the calls are on the same thread. In fact rule 3.3 just \"recommended\" the stack depth to be 1. I don't think in practice we would overflow by any means, especially in Armeria.", "author": "tumile", "createdAt": "2021-02-01T03:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ1MDQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ1MDY0Ng==", "url": "https://github.com/line/armeria/pull/3237#discussion_r563450646", "bodyText": "If the oldDemand is Long.MAX_VALUE, we don't have to call this method.", "author": "minwoox", "createdAt": "2021-01-25T03:57:49Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber<T> restSubscriber = new RestSubscriber<>(first, rest, subscriber);\n+        subscriber.onSubscribe(restSubscriber);\n+    }\n+\n+    static final class RestSubscriber<T> implements Subscriber<T>, Subscription {\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<RestSubscriber> demandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(RestSubscriber.class, \"demand\");\n+\n+        private final T first;\n+        private final Publisher<? extends T> rest;\n+        private Subscriber<? super T> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+        private volatile long demand;\n+        private volatile boolean firstSent;\n+        private volatile boolean subscribed;\n+        private volatile boolean cancelled;\n+\n+        RestSubscriber(T first, Publisher<? extends T> rest, Subscriber<? super T> downstream) {\n+            this.first = first;\n+            this.rest = rest;\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                downstream.onError(new IllegalArgumentException(\"non-positive request signals are illegal\"));\n+                return;\n+            }\n+            if (cancelled) {\n+                return;\n+            }\n+            for (;;) {\n+                final long demand = this.demand;\n+                final long newDemand = demand >= Long.MAX_VALUE - n ? Long.MAX_VALUE : demand + n;\n+                if (demandUpdater.compareAndSet(this, demand, newDemand)) {\n+                    if (demand > 0) {\n+                        return;\n+                    }\n+                    break;\n+                }\n+            }\n+            if (!firstSent) {\n+                firstSent = true;\n+                downstream.onNext(first);\n+                demandUpdater.getAndUpdate(this, oldDemand -> oldDemand == Long.MAX_VALUE ?", "originalCommit": "c64f69803bf84b4a3cb2850adf3060fc09b37b1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ1MDg5Mw==", "url": "https://github.com/line/armeria/pull/3237#discussion_r563450893", "bodyText": "how about returning early?\nif (!subscribed) {\n    subscribed = true;\n    rest.subscribe(this);\n}\nif (demand == 0) {\n    return;\n}\n...\nAlso we should subscribe no matter the demand is 0 or not.", "author": "minwoox", "createdAt": "2021-01-25T03:58:57Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/stream/PrependingPublisher.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common.stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+\n+public final class PrependingPublisher<T> implements Publisher<T> {\n+\n+    private final T first;\n+    private final Publisher<? extends T> rest;\n+\n+    public PrependingPublisher(T first, Publisher<? extends T> rest) {\n+        this.first = first;\n+        this.rest = rest;\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super T> subscriber) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        final RestSubscriber<T> restSubscriber = new RestSubscriber<>(first, rest, subscriber);\n+        subscriber.onSubscribe(restSubscriber);\n+    }\n+\n+    static final class RestSubscriber<T> implements Subscriber<T>, Subscription {\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<RestSubscriber> demandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(RestSubscriber.class, \"demand\");\n+\n+        private final T first;\n+        private final Publisher<? extends T> rest;\n+        private Subscriber<? super T> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+        private volatile long demand;\n+        private volatile boolean firstSent;\n+        private volatile boolean subscribed;\n+        private volatile boolean cancelled;\n+\n+        RestSubscriber(T first, Publisher<? extends T> rest, Subscriber<? super T> downstream) {\n+            this.first = first;\n+            this.rest = rest;\n+            this.downstream = downstream;\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                downstream.onError(new IllegalArgumentException(\"non-positive request signals are illegal\"));\n+                return;\n+            }\n+            if (cancelled) {\n+                return;\n+            }\n+            for (;;) {\n+                final long demand = this.demand;\n+                final long newDemand = demand >= Long.MAX_VALUE - n ? Long.MAX_VALUE : demand + n;\n+                if (demandUpdater.compareAndSet(this, demand, newDemand)) {\n+                    if (demand > 0) {\n+                        return;\n+                    }\n+                    break;\n+                }\n+            }\n+            if (!firstSent) {\n+                firstSent = true;\n+                downstream.onNext(first);\n+                demandUpdater.getAndUpdate(this, oldDemand -> oldDemand == Long.MAX_VALUE ?\n+                                                              oldDemand : oldDemand - 1);\n+            }\n+            if (demand > 0) {", "originalCommit": "c64f69803bf84b4a3cb2850adf3060fc09b37b1b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f458106e8b84a73a1b9a3266e3fda06ad62cf23e", "url": "https://github.com/line/armeria/commit/f458106e8b84a73a1b9a3266e3fda06ad62cf23e", "message": "Finishing up", "committedDate": "2021-01-25T14:56:23Z", "type": "commit"}, {"oid": "39302b849362e2f0f04b7e1ebc52b2ea1da372a5", "url": "https://github.com/line/armeria/commit/39302b849362e2f0f04b7e1ebc52b2ea1da372a5", "message": "Fix", "committedDate": "2021-01-29T10:39:42Z", "type": "commit"}]}