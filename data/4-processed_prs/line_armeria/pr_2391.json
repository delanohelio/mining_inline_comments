{"pr_number": 2391, "pr_title": "Clean up TimeoutController implementation", "pr_createdAt": "2020-01-10T10:03:17Z", "pr_url": "https://github.com/line/armeria/pull/2391", "timeline": [{"oid": "8ea9af5646b89abb9e29f4838f3dcbe897b7f710", "url": "https://github.com/line/armeria/commit/8ea9af5646b89abb9e29f4838f3dcbe897b7f710", "message": "Trigger request or response timeout when past time is set to\n\nMotivation:\nWhen a past time is passed to `ctx.set{Response,Request}TimeoutAt()`\nit throws `IllegalArgumentException`.\nI think it would be more natural to trigger timeout immediately.\n\nModifications:\n* Add `timeoutNow()` to `TimeoutController` for invoking timeout\n  directly\n* Invoke `timeoutNow()` when the given time is before now\n\nResult:\nA user can trigger timeout immediately by setting past time", "committedDate": "2020-01-10T10:02:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE1OTAxNQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r365159015", "bodyText": "Does it need a guard here? \ud83e\udd14\nif (cancelTimeout()) {\n    timeoutTask.run();\n}", "author": "ikhoon", "createdAt": "2020-01-10T10:06:18Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -149,6 +149,13 @@ public void resetTimeout(long newTimeoutMillis) {\n         }\n     }\n \n+    @Override\n+    public void timeoutNow() {\n+        ensureInitialized();\n+        cancelTimeout();\n+        timeoutTask.run();", "originalCommit": "8ea9af5646b89abb9e29f4838f3dcbe897b7f710", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2MzcyMA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r365163720", "bodyText": "I guess yes, unless there's anything that must be done even after cancellation.", "author": "trustin", "createdAt": "2020-01-10T10:17:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE1OTAxNQ=="}], "type": "inlineReview"}, {"oid": "7e6cf6119c5747753b34742bdd48a9b2d3cbf13f", "url": "https://github.com/line/armeria/commit/7e6cf6119c5747753b34742bdd48a9b2d3cbf13f", "message": "Change Instant.now() to System.currentTimeMillis()", "committedDate": "2020-01-10T10:11:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2NDIwOA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r365164208", "bodyText": "How about: the request will be timed out immediately", "author": "trustin", "createdAt": "2020-01-10T10:18:17Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServiceRequestContext.java", "diffHunk": "@@ -497,6 +498,7 @@ default MediaType negotiatedProduceType() {\n     /**\n      * Schedules the request timeout that is triggered at the specified time represented\n      * as the number since the epoch ({@code 1970-01-01T00:00:00Z}).\n+     * Note that the request timeout is triggered immediately if the specified time is before now.", "originalCommit": "7e6cf6119c5747753b34742bdd48a9b2d3cbf13f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "934d89f41debea4892773cee4c212a2330dcaa52", "url": "https://github.com/line/armeria/commit/934d89f41debea4892773cee4c212a2330dcaa52", "message": "Address comments by @trustin", "committedDate": "2020-01-10T10:32:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEyMDU4Ng==", "url": "https://github.com/line/armeria/pull/2391#discussion_r366120586", "bodyText": "Don't we need to add pendingTimeoutTask here?", "author": "minwoox", "createdAt": "2020-01-14T01:59:27Z", "path": "core/src/main/java/com/linecorp/armeria/server/DefaultServiceRequestContext.java", "diffHunk": "@@ -456,12 +456,20 @@ public void setRequestTimeoutAfter(Duration requestTimeout) {\n     public void setRequestTimeoutAtMillis(long requestTimeoutAtMillis) {\n         checkArgument(requestTimeoutAtMillis >= 0,\n                       \"requestTimeoutAtMillis: \" + requestTimeoutAtMillis + \" (expected: >= 0)\");\n-        final long nowMillis = Instant.now().toEpochMilli();\n-        final long requestTimeoutAfter = requestTimeoutAtMillis - nowMillis;\n-        checkArgument(requestTimeoutAfter > 0,\n-                      \"requestTimeoutAtMillis: %s (expected: > 'now=%s')\", requestTimeoutAtMillis, nowMillis);\n-\n-        setRequestTimeoutAfterMillis(requestTimeoutAfter);\n+        final long requestTimeoutAfter = requestTimeoutAtMillis - System.currentTimeMillis();\n+\n+        if (requestTimeoutAfter <= 0) {\n+            final TimeoutController requestTimeoutController = this.requestTimeoutController;\n+            if (requestTimeoutController != null) {\n+                if (eventLoop().inEventLoop()) {\n+                    requestTimeoutController.timeoutNow();\n+                } else {\n+                    eventLoop().execute(requestTimeoutController::timeoutNow);\n+                }\n+            }", "originalCommit": "8a490d47b12478bfe08b6ed054df61d45f759611", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE2NzcxNQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r366167715", "bodyText": "Indeed! Updated. \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-01-14T06:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEyMDU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEyMTA1Ng==", "url": "https://github.com/line/armeria/pull/2391#discussion_r366121056", "bodyText": "Initializes -> Sets?\nDo you have a reason that you changed the name? I think I'd like initTimeout. \ud83e\udd14", "author": "minwoox", "createdAt": "2020-01-14T02:01:36Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -26,7 +26,7 @@\n     /**\n      * Initializes the timeout scheduler with the specified {@code timeoutMillis}.", "originalCommit": "8a490d47b12478bfe08b6ed054df61d45f759611", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEyMTM5MQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r366121391", "bodyText": "I didn\u2019t update Javadoc yet. I\u2019ll let you know when ready to review. \ud83d\ude47\u200d\u2642\ufe0f", "author": "ikhoon", "createdAt": "2020-01-14T02:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEyMTA1Ng=="}], "type": "inlineReview"}, {"oid": "32f45dd6b3587f1087c090dcd1280ba8a55bc424", "url": "https://github.com/line/armeria/commit/32f45dd6b3587f1087c090dcd1280ba8a55bc424", "message": "Address comments by @minwoox\n\n- Update Javadoc\n- Capture timeout changes when the responseTimeoutController is not set yet\n- Run the pending task when responseTimeoutController is set to the context\n- Rename `initTimeout` to `scheduleTimeout`\n- Lax DefaultTimeoutController API validation\n  - Can call `resetTimeout` or `exendTimeout` before `scheduleTimeout` is called.", "committedDate": "2020-01-14T03:49:53Z", "type": "commit"}, {"oid": "32f45dd6b3587f1087c090dcd1280ba8a55bc424", "url": "https://github.com/line/armeria/commit/32f45dd6b3587f1087c090dcd1280ba8a55bc424", "message": "Address comments by @minwoox\n\n- Update Javadoc\n- Capture timeout changes when the responseTimeoutController is not set yet\n- Run the pending task when responseTimeoutController is set to the context\n- Rename `initTimeout` to `scheduleTimeout`\n- Lax DefaultTimeoutController API validation\n  - Can call `resetTimeout` or `exendTimeout` before `scheduleTimeout` is called.", "committedDate": "2020-01-14T03:49:53Z", "type": "forcePushed"}, {"oid": "6cad8d180a7b43633de11510a5472fa858688633", "url": "https://github.com/line/armeria/commit/6cad8d180a7b43633de11510a5472fa858688633", "message": "Merge branch 'master' into past-timeout", "committedDate": "2020-01-14T04:01:06Z", "type": "commit"}, {"oid": "e971d6cd23da99c59409f5d1279327288a05f88a", "url": "https://github.com/line/armeria/commit/e971d6cd23da99c59409f5d1279327288a05f88a", "message": "Add server-side pendingTimeoutTask", "committedDate": "2020-01-14T05:40:49Z", "type": "commit"}, {"oid": "1c997709866ea6b28d1c1a0769654d5c96b6978e", "url": "https://github.com/line/armeria/commit/1c997709866ea6b28d1c1a0769654d5c96b6978e", "message": "Fix checkstyle", "committedDate": "2020-01-14T06:26:48Z", "type": "commit"}, {"oid": "8ba0e6fd3b015ed5f35dbb0ad6fca792a4f7bdbe", "url": "https://github.com/line/armeria/commit/8ba0e6fd3b015ed5f35dbb0ad6fca792a4f7bdbe", "message": "Update scheduleTimeout() - work only if no timeout was scheduled", "committedDate": "2020-01-14T08:02:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIxMzE1MQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r366213151", "bodyText": "It seems like there's not much chance that a new TimeoutTask it set.\nHow about removing the setter and setting it in the constructor?\n// In HttpResponseDecoder\nHttpResponseWrapper(...) {\n    super(eventLoop, newTimeoutTask(delegate, ctx));\n    this.delegate = delegate;\n    this.ctx = ctx;\n    this.maxContentLength = maxContentLength;\n    this.responseTimeoutMillis = responseTimeoutMillis;\n}\n\n// In HttpResponseSubscriber\nHttpResponseSubscriber(ChannelHandlerContext ctx, HttpObjectEncoder responseEncoder,\n                       DefaultServiceRequestContext reqCtx, DecodedHttpRequest req,\n                       boolean enableServerHeader, boolean enableDateHeader) {\n    super(ctx.channel().eventLoop(), newTimeoutTask(reqCtx));\n    this.ctx = ctx;\n    this.responseEncoder = responseEncoder;\n    this.req = req;\n    this.reqCtx = reqCtx;\n    this.enableServerHeader = enableServerHeader;\n    this.enableDateHeader = enableDateHeader;\n}", "author": "minwoox", "createdAt": "2020-01-14T08:51:40Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -78,74 +79,98 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        // Do nothing if the timeout was scheduled already\n+        if (timeoutFuture != null) {\n+            return false;\n+        }\n+\n+        cancelTimeout();\n+        if (!timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+        timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or", "originalCommit": "8ba0e6fd3b015ed5f35dbb0ad6fca792a4f7bdbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI3MDA0Mw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r366270043", "bodyText": "That is a nice suggestion. I tried to make TimeoutTask immutable in DefaultTimeoutController initially. We have to make newTimeoutTask static to call newTimeoutTask in super. But it is difficult because it refers to the state that is non-static field.\nOr there is something I missed, let me know :-)", "author": "ikhoon", "createdAt": "2020-01-14T10:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIxMzE1MQ=="}], "type": "inlineReview"}, {"oid": "d540cdacc10670806c4464bfe9ecc37c31545668", "url": "https://github.com/line/armeria/commit/d540cdacc10670806c4464bfe9ecc37c31545668", "message": "Add 'TODO' for future work", "committedDate": "2020-01-15T05:22:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcxMjk3Mg==", "url": "https://github.com/line/armeria/pull/2391#discussion_r366712972", "bodyText": "Question, does it makes sense to make this method return a boolean value?", "author": "trustin", "createdAt": "2020-01-15T06:30:39Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -24,27 +24,38 @@\n public interface TimeoutController {\n \n     /**\n-     * Initializes the timeout scheduler with the specified {@code timeoutMillis}.\n+     * Schedules a new timeout with the specified {@code timeoutMillis}.\n+     * If a timeout is scheduled already, this method will not start a new timeout.\n+     * @return {@code true} if the timeout is scheduled.\n      */\n-    void initTimeout(long timeoutMillis);\n+    boolean scheduleTimeout(long timeoutMillis);\n \n     /**\n      * Extends the current timeout by the specified {@code adjustmentMillis}.\n+     * This method does nothing if no timeout was scheduled previously.\n      * Note that a negative {@code adjustmentMillis} reduces the current timeout.\n      *\n      * @param adjustmentMillis the adjustment of time amount value in milliseconds.\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n      */\n-    void extendTimeout(long adjustmentMillis);\n+    boolean extendTimeout(long adjustmentMillis);\n \n     /**\n      * Sets the amount of time that is after the specified {@code newTimeoutMillis} from now.\n      *\n      * @param newTimeoutMillis the new timeout value in milliseconds. {@code 0} if disabled.\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n      */\n-    void resetTimeout(long newTimeoutMillis);\n+    boolean resetTimeout(long newTimeoutMillis);\n+\n+    /**\n+     * Trigger the current timeout immediately.\n+     */\n+    void timeoutNow();", "originalCommit": "d540cdacc10670806c4464bfe9ecc37c31545668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcxNTA4NQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r366715085", "bodyText": "That sounds good!", "author": "ikhoon", "createdAt": "2020-01-15T06:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcxMjk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcxMzA5Nw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r366713097", "bodyText": "Could you also document when false is returned, e.g. {@code false} if the timeout could not be scheduled because .... or .... (Please fix all methods.)", "author": "trustin", "createdAt": "2020-01-15T06:31:10Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -24,27 +24,38 @@\n public interface TimeoutController {\n \n     /**\n-     * Initializes the timeout scheduler with the specified {@code timeoutMillis}.\n+     * Schedules a new timeout with the specified {@code timeoutMillis}.\n+     * If a timeout is scheduled already, this method will not start a new timeout.\n+     * @return {@code true} if the timeout is scheduled.", "originalCommit": "d540cdacc10670806c4464bfe9ecc37c31545668", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcxMzM4NQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r366713385", "bodyText": "Could return whether the timeout task was run or not?", "author": "trustin", "createdAt": "2020-01-15T06:32:20Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -78,74 +79,98 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        // Do nothing if the timeout was scheduled already\n+        if (timeoutFuture != null) {\n+            return false;\n+        }\n+\n+        cancelTimeout();\n+        if (!timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+        timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n-        if (adjustmentMillis == 0) {\n-            return;\n+        if (adjustmentMillis == 0 || timeoutFuture == null) {\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n+        if (!timeoutTask.canSchedule()) {\n+            return false;\n+        }\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+        if (newTimeoutMillis > 0) {\n+            timeoutFuture = eventLoop.schedule(\n+                    timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        } else {\n+            // We went past the dead line set by the new timeout already.\n+            timeoutTask.run();\n         }\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     */\n     @Override\n-    public void resetTimeout(long newTimeoutMillis) {\n+    public boolean resetTimeout(long newTimeoutMillis) {\n         ensureInitialized();\n         if (newTimeoutMillis <= 0) {\n             timeoutMillis = newTimeoutMillis;\n             cancelTimeout();\n-            return;\n+            return true;\n         }\n \n-        if (timeoutTask.canSchedule()) {\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            final long remainingTimeoutMillis = LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis);\n-            lastStartTimeNanos = currentNanoTime;\n-            if (remainingTimeoutMillis == newTimeoutMillis) {\n-                return;\n-            }\n+        if (!timeoutTask.canSchedule()) {\n+            return false;\n+        }\n \n-            // Cancel the previously scheduled timeout, if exists.\n-            cancelTimeout();\n-            timeoutMillis = newTimeoutMillis;\n-            timeoutFuture = eventLoop.schedule(timeoutTask, newTimeoutMillis,\n-                                               TimeUnit.MILLISECONDS);\n+        // Cancel the previously scheduled timeout, if exists.\n+        cancelTimeout();\n+        timeoutMillis = newTimeoutMillis;\n+        timeoutFuture = eventLoop.schedule(timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n+    }\n+\n+    @Override\n+    public void timeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"setTimeoutTask(timeoutTask) is not called yet.\");\n+        if (cancelTimeout()) {\n+            timeoutTask.run();\n         }", "originalCommit": "d540cdacc10670806c4464bfe9ecc37c31545668", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "368a9383d810f5e8f630b3bcff9bc6e40581711f", "url": "https://github.com/line/armeria/commit/368a9383d810f5e8f630b3bcff9bc6e40581711f", "message": "Address comments by @trustin / Update Javdoc", "committedDate": "2020-01-15T07:51:21Z", "type": "commit"}, {"oid": "14e7d1a5b0d0aa01e145a7b7baae31fb8553b4cd", "url": "https://github.com/line/armeria/commit/14e7d1a5b0d0aa01e145a7b7baae31fb8553b4cd", "message": "Update Javadoc @param", "committedDate": "2020-01-15T08:12:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwOTI3MQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367209271", "bodyText": "What are the 'some constraints'?", "author": "trustin", "createdAt": "2020-01-16T02:56:03Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -37,6 +39,8 @@\n      *\n      * @param adjustmentMillis the adjustment of time amount value in milliseconds.\n      * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if the current timeout could not be extended\n+     *         because of some constraints in the class that implements this interface.", "originalCommit": "368a9383d810f5e8f630b3bcff9bc6e40581711f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwOTM3OQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367209379", "bodyText": ".. if the timeout has been scheduled already?", "author": "trustin", "createdAt": "2020-01-16T02:56:37Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -27,6 +27,8 @@\n      * Schedules a new timeout with the specified {@code timeoutMillis}.\n      * If a timeout is scheduled already, this method will not start a new timeout.\n      * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout could not be scheduled because the timeout is currently being\n+     *         scheduled.", "originalCommit": "368a9383d810f5e8f630b3bcff9bc6e40581711f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwOTQ3Nw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367209477", "bodyText": "What are the 'some constraints'?", "author": "trustin", "createdAt": "2020-01-16T02:57:08Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -45,17 +49,24 @@\n      *\n      * @param newTimeoutMillis the new timeout value in milliseconds. {@code 0} if disabled.\n      * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the current timeout could not be reset\n+     *         because of some constraints in the class that implements this interface.", "originalCommit": "368a9383d810f5e8f630b3bcff9bc6e40581711f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIxMjQwMQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367212401", "bodyText": "The resetTimeout is failed when TimeoutTask can not schedule.\nI've tried to explain the exact cause... but TimeoutTask is only used in DefaultTimeoutController.\nIn this case, do I need to remove this sentence and simplify with:\n{@code false} if the current timeout failed to reset\n\nor remove the ambiguous {@code false} ... sentence?", "author": "ikhoon", "createdAt": "2020-01-16T03:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwOTQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwOTYxOA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367209618", "bodyText": ".. if the timeout has been triggered already?", "author": "trustin", "createdAt": "2020-01-16T02:57:48Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -45,17 +49,24 @@\n      *\n      * @param newTimeoutMillis the new timeout value in milliseconds. {@code 0} if disabled.\n      * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the current timeout could not be reset\n+     *         because of some constraints in the class that implements this interface.\n      */\n     boolean resetTimeout(long newTimeoutMillis);\n \n     /**\n      * Trigger the current timeout immediately.\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if the current timeout could not be triggered now because\n+     *         the timeout schedule has already completed normally.", "originalCommit": "368a9383d810f5e8f630b3bcff9bc6e40581711f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwOTgyNw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367209827", "bodyText": ".. if the timeout has been triggered already?\nWhat happens if no timeout was scheduled previously? What happens if a user calls this method and then scheduled a new timeout?", "author": "trustin", "createdAt": "2020-01-16T02:58:44Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -45,17 +49,24 @@\n      *\n      * @param newTimeoutMillis the new timeout value in milliseconds. {@code 0} if disabled.\n      * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the current timeout could not be reset\n+     *         because of some constraints in the class that implements this interface.\n      */\n     boolean resetTimeout(long newTimeoutMillis);\n \n     /**\n      * Trigger the current timeout immediately.\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if the current timeout could not be triggered now because\n+     *         the timeout schedule has already completed normally.\n      */\n-    void timeoutNow();\n+    boolean timeoutNow();\n \n     /**\n      * Cancels the current timeout scheduled.\n-     * @return {@code true} if the current timeout is canceled.\n+     * @return {@code true} if the current timeout is canceled or no timeout is being scheduled.\n+     *         {@code false} if the current timeout could not be cancelled typically because\n+     *         the timeout schedule has already completed normally.", "originalCommit": "368a9383d810f5e8f630b3bcff9bc6e40581711f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIxNDA1NQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367214055", "bodyText": "What happens if no timeout was scheduled previously?\n\nIt should return true. Let me rewrite the no timeout is being scheduled to no timeout was scheduled previously.\n\nWhat happens if a user calls this method and then scheduled a new timeout?\n\nA user can schedule a new timeout. I missed that point. Will update it to the Javadoc.", "author": "ikhoon", "createdAt": "2020-01-16T03:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwOTgyNw=="}], "type": "inlineReview"}, {"oid": "b0c03af8b844183dcc70d665a7d03feb4ad77533", "url": "https://github.com/line/armeria/commit/b0c03af8b844183dcc70d665a7d03feb4ad77533", "message": "Address comments by @trustin\n\n- Add State to DefalutTimeoutController\n- Update Javadoc\n- Add test case for checking State transition", "committedDate": "2020-01-16T07:39:58Z", "type": "commit"}, {"oid": "a29181bcf77cf9840fbc4b92884545a31b214817", "url": "https://github.com/line/armeria/commit/a29181bcf77cf9840fbc4b92884545a31b214817", "message": "Fix checkstyle", "committedDate": "2020-01-16T07:46:24Z", "type": "commit"}, {"oid": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd", "url": "https://github.com/line/armeria/commit/62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd", "message": "Fix test name", "committedDate": "2020-01-16T07:49:48Z", "type": "commit"}, {"oid": "4a463b933ca2d03f626e7c5f44109cf58196dc1d", "url": "https://github.com/line/armeria/commit/4a463b933ca2d03f626e7c5f44109cf58196dc1d", "message": "Fix typo", "committedDate": "2020-01-16T08:27:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4MTM2MA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367281360", "bodyText": "has been scheduled or triggered already", "author": "trustin", "createdAt": "2020-01-16T08:17:28Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -24,27 +24,47 @@\n public interface TimeoutController {\n \n     /**\n-     * Initializes the timeout scheduler with the specified {@code timeoutMillis}.\n+     * Schedules a new timeout with the specified {@code timeoutMillis}.\n+     * If a timeout is scheduled already, this method will not start a new timeout.\n+     *\n+     * @param timeoutMillis a positive time amount value in milliseconds.\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled or the timeout has been triggered already.", "originalCommit": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4MTk0Nw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367281947", "bodyText": "Perhaps we can remove this, because it's already in the super class Javadoc?", "author": "trustin", "createdAt": "2020-01-16T08:18:59Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.", "originalCommit": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMjY3Ng==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367302676", "bodyText": "The TimeoutTask is only used for DefaultTimeoutController.\nI will add a more general expression to describe why it could return false. \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-01-16T09:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4MTk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4MjM0Nw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367282347", "bodyText": "Ditto - already in the super class Javadoc", "author": "trustin", "createdAt": "2020-01-16T08:20:04Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.", "originalCommit": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4Mjc3MA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367282770", "bodyText": "Ditto", "author": "trustin", "createdAt": "2020-01-16T08:21:15Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            state = State.TIMED_OUT;\n+            return false;\n         }\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already or\n+     *         the {@link TimeoutTask} could not be scheduled now.", "originalCommit": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4Mjk2MA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367282960", "bodyText": "Global comment - state != ... or state == ... for readability", "author": "trustin", "createdAt": "2020-01-16T08:21:49Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            state = State.TIMED_OUT;\n+            return false;\n         }\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already or\n+     *         the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void resetTimeout(long newTimeoutMillis) {\n+    public boolean resetTimeout(long newTimeoutMillis) {\n         ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n         if (newTimeoutMillis <= 0) {\n             timeoutMillis = newTimeoutMillis;\n             cancelTimeout();\n-            return;\n+            return true;\n         }\n \n-        if (timeoutTask.canSchedule()) {\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            final long remainingTimeoutMillis = LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis);\n-            lastStartTimeNanos = currentNanoTime;\n-            if (remainingTimeoutMillis == newTimeoutMillis) {\n-                return;\n-            }\n+        // Cancel the previously scheduled timeout, if exists.\n+        cancelTimeout();\n+        timeoutMillis = newTimeoutMillis;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n+    }\n \n-            // Cancel the previously scheduled timeout, if exists.\n-            cancelTimeout();\n-            timeoutMillis = newTimeoutMillis;\n-            timeoutFuture = eventLoop.schedule(timeoutTask, newTimeoutMillis,\n-                                               TimeUnit.MILLISECONDS);\n+    /**\n+     * Trigger the current timeout immediately.\n+     *\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n+    @Override\n+    public boolean timeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"setTimeoutTask(timeoutTask) is not called yet.\");\n+\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {", "originalCommit": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI5MjYxMQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367292611", "bodyText": "Sure! \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-01-16T08:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4Mjk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4MzI1NA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367283254", "bodyText": "Could set in finally block, just in case run() throws an exception", "author": "trustin", "createdAt": "2020-01-16T08:22:42Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            state = State.TIMED_OUT;\n+            return false;\n         }\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already or\n+     *         the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void resetTimeout(long newTimeoutMillis) {\n+    public boolean resetTimeout(long newTimeoutMillis) {\n         ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n         if (newTimeoutMillis <= 0) {\n             timeoutMillis = newTimeoutMillis;\n             cancelTimeout();\n-            return;\n+            return true;\n         }\n \n-        if (timeoutTask.canSchedule()) {\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            final long remainingTimeoutMillis = LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis);\n-            lastStartTimeNanos = currentNanoTime;\n-            if (remainingTimeoutMillis == newTimeoutMillis) {\n-                return;\n-            }\n+        // Cancel the previously scheduled timeout, if exists.\n+        cancelTimeout();\n+        timeoutMillis = newTimeoutMillis;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n+    }\n \n-            // Cancel the previously scheduled timeout, if exists.\n-            cancelTimeout();\n-            timeoutMillis = newTimeoutMillis;\n-            timeoutFuture = eventLoop.schedule(timeoutTask, newTimeoutMillis,\n-                                               TimeUnit.MILLISECONDS);\n+    /**\n+     * Trigger the current timeout immediately.\n+     *\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n+    @Override\n+    public boolean timeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"setTimeoutTask(timeoutTask) is not called yet.\");\n+\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n+\n+        if (cancelTimeout()) {\n+            invokeTimeoutTask();\n+            return true;\n+        }\n+\n+        return false;\n     }\n \n     @Override\n     public boolean cancelTimeout() {\n-        final ScheduledFuture<?> timeoutFuture = this.timeoutFuture;\n-        if (timeoutFuture == null) {\n+        if (State.TIMED_OUT == state) {\n+            return false;\n+        }\n+        if (State.DISABLED == state) {\n             return true;\n         }\n \n+        final ScheduledFuture<?> timeoutFuture = this.timeoutFuture;\n+        assert timeoutFuture != null;\n+\n         this.timeoutFuture = null;\n-        return timeoutFuture.cancel(false);\n+        final boolean canceled = timeoutFuture.cancel(false);\n+        state = State.DISABLED;\n+        return canceled;\n     }\n \n     private void ensureInitialized() {\n         checkState(timeoutTask != null,\n                    \"setTimeoutTask(timeoutTask) is not called yet.\");\n-        checkState(firstStartTimeNanos > 0,\n-                   \"initTimeout(timeoutMillis) is not called yet.\");\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = lastExecutionTimeNanos = System.nanoTime();\n+        }\n+    }\n+\n+    @Nullable\n+    private void invokeTimeoutTask() {\n+        if (timeoutTask != null) {\n+            timeoutTask.run();\n+            state = State.TIMED_OUT;", "originalCommit": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI5Mjc5Mw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367292793", "bodyText": "Nice tip, thanks!", "author": "ikhoon", "createdAt": "2020-01-16T08:45:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4MzI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4MzU2NA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367283564", "bodyText": "This is redundant because invokeTimeoutTask updates state.", "author": "trustin", "createdAt": "2020-01-16T08:23:30Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            state = State.TIMED_OUT;", "originalCommit": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4Mzg2Ng==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367283866", "bodyText": "nit: Could use switch-case?", "author": "trustin", "createdAt": "2020-01-16T08:24:15Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +84,166 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        final long nanoTime = System.nanoTime();\n+        if (firstExecutionTimeNanos == 0) {\n+            firstExecutionTimeNanos = nanoTime;\n         }\n+        lastExecutionTimeNanos = nanoTime;\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            state = State.TIMED_OUT;\n+            return false;\n         }\n+\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already or\n+     *         the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void resetTimeout(long newTimeoutMillis) {\n+    public boolean resetTimeout(long newTimeoutMillis) {\n         ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n         if (newTimeoutMillis <= 0) {\n             timeoutMillis = newTimeoutMillis;\n             cancelTimeout();\n-            return;\n+            return true;\n         }\n \n-        if (timeoutTask.canSchedule()) {\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            final long remainingTimeoutMillis = LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis);\n-            lastStartTimeNanos = currentNanoTime;\n-            if (remainingTimeoutMillis == newTimeoutMillis) {\n-                return;\n-            }\n+        // Cancel the previously scheduled timeout, if exists.\n+        cancelTimeout();\n+        timeoutMillis = newTimeoutMillis;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        state = State.SCHEDULED;\n+        return true;\n+    }\n \n-            // Cancel the previously scheduled timeout, if exists.\n-            cancelTimeout();\n-            timeoutMillis = newTimeoutMillis;\n-            timeoutFuture = eventLoop.schedule(timeoutTask, newTimeoutMillis,\n-                                               TimeUnit.MILLISECONDS);\n+    /**\n+     * Trigger the current timeout immediately.\n+     *\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n+    @Override\n+    public boolean timeoutNow() {\n+        checkState(timeoutTask != null,\n+                   \"setTimeoutTask(timeoutTask) is not called yet.\");\n+\n+        if (State.SCHEDULED != state || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n+\n+        if (cancelTimeout()) {\n+            invokeTimeoutTask();\n+            return true;\n+        }\n+\n+        return false;\n     }\n \n     @Override\n     public boolean cancelTimeout() {\n-        final ScheduledFuture<?> timeoutFuture = this.timeoutFuture;\n-        if (timeoutFuture == null) {\n+        if (State.TIMED_OUT == state) {\n+            return false;\n+        }\n+        if (State.DISABLED == state) {\n             return true;\n         }", "originalCommit": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4NTIwMQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367285201", "bodyText": "0 has a meaning in nano time. Need to introduce a boolean?", "author": "trustin", "createdAt": "2020-01-16T08:27:08Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -35,16 +36,23 @@\n  */\n public class DefaultTimeoutController implements TimeoutController {\n \n+    enum State {\n+        DISABLED,\n+        SCHEDULED,\n+        TIMED_OUT,\n+    }\n+\n     @Nullable\n     private TimeoutTask timeoutTask;\n     private final EventLoop eventLoop;\n \n     private long timeoutMillis;\n-    private long firstStartTimeNanos;\n-    private long lastStartTimeNanos;\n+    private long firstExecutionTimeNanos;\n+    private long lastExecutionTimeNanos;", "originalCommit": "62338eac6ffea6eaacf8f3f9660ed35a49ce4bfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMDM2NQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367300365", "bodyText": "Ahh... I forget it. \ud83d\ude31", "author": "ikhoon", "createdAt": "2020-01-16T09:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4NTIwMQ=="}], "type": "inlineReview"}, {"oid": "750caad3a01f8b55ce87fd09cdceb848de9979b6", "url": "https://github.com/line/armeria/commit/750caad3a01f8b55ce87fd09cdceb848de9979b6", "message": "Address comments by @trustin\n\n- Update Javadoc in TimeoutController\n- Add finnaly in invokeTimeoutTask\n- Flip if condition\n- Add a flag to indicate the timeout task is scheduled at least once", "committedDate": "2020-01-16T09:12:15Z", "type": "commit"}, {"oid": "742f7b4247d841c48bc8c8a84a75e229f65dbc73", "url": "https://github.com/line/armeria/commit/742f7b4247d841c48bc8c8a84a75e229f65dbc73", "message": "Make `startTimeNanos` return null when no timeout was scheduled before", "committedDate": "2020-01-16T09:58:37Z", "type": "commit"}, {"oid": "67eef3419ec1a728df4a977f431309833b41bff2", "url": "https://github.com/line/armeria/commit/67eef3419ec1a728df4a977f431309833b41bff2", "message": "Revamp cancelTimeout return value\n\n- Add getters for TimeoutController state\n- Fix broken test", "committedDate": "2020-01-17T09:21:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzOTI0Nw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367839247", "bodyText": "The cancelTimeout returns true if the timeout is being scheduled now.", "author": "ikhoon", "createdAt": "2020-01-17T09:26:44Z", "path": "core/src/main/java/com/linecorp/armeria/server/HttpResponseSubscriber.java", "diffHunk": "@@ -258,11 +261,13 @@ public void onError(Throwable cause) {\n \n     @Override\n     public void onComplete() {\n-        if (!cancelTimeout() && reqCtx.requestTimeoutHandler() == null) {\n+        if (isTimedOut() && reqCtx.requestTimeoutHandler() == null) {", "originalCommit": "67eef3419ec1a728df4a977f431309833b41bff2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzOTY5NA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367839694", "bodyText": "I changed due to the changed cancelTimeout return value.", "author": "ikhoon", "createdAt": "2020-01-17T09:27:49Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpResponseDecoder.java", "diffHunk": "@@ -294,14 +294,19 @@ private void cancelAction(@Nullable Throwable cause) {\n         }\n \n         private void cancelTimeoutOrLog(@Nullable Throwable cause,\n-                                        Consumer<Throwable> actionOnTimeoutCancelled) {\n+                                        Consumer<Throwable> actionOnNotTimedOut) {\n \n-            if (cancelTimeout()) {\n+            if (!isTimedOut()) {\n+                cancelTimeout();\n                 // There's no timeout or the response has not been timed out.\n-                actionOnTimeoutCancelled.accept(cause);\n+                actionOnNotTimedOut.accept(cause);\n                 return;\n             }\n \n+            if (delegate.isOpen()) {\n+                closeAction(cause);\n+            }", "originalCommit": "67eef3419ec1a728df4a977f431309833b41bff2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0MTIwNA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367841204", "bodyText": "How about scheduledAtLeastOnce?", "author": "trustin", "createdAt": "2020-01-17T09:31:00Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -93,14 +94,15 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n     public boolean scheduleTimeout(long timeoutMillis) {\n         checkArgument(timeoutMillis > 0,\n                       \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n-        if (State.DISABLED != state || !timeoutTask.canSchedule()) {\n+        if (state != State.DISABLED || !timeoutTask.canSchedule()) {\n             return false;\n         }\n \n         cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n         final long nanoTime = System.nanoTime();\n-        if (firstExecutionTimeNanos == 0) {\n+        if (!isExecutedAtLeastOnce) {\n+            isExecutedAtLeastOnce = true;", "originalCommit": "750caad3a01f8b55ce87fd09cdceb848de9979b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0ODQ4Mw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367848483", "bodyText": "That is a good name. \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-01-17T09:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0MTIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0MzMxNQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367843315", "bodyText": "case SCHEDULED:\n    ...\n\ndefault:\n    throw new Error();", "author": "trustin", "createdAt": "2020-01-17T09:35:33Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -196,36 +190,60 @@ public boolean timeoutNow() {\n         checkState(timeoutTask != null,\n                    \"setTimeoutTask(timeoutTask) is not called yet.\");\n \n-        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+        if (!timeoutTask.canSchedule()) {\n             return false;\n         }\n \n-        if (cancelTimeout()) {\n-            invokeTimeoutTask();\n-            return true;\n+        switch (state) {\n+            case TIMED_OUT:\n+                return false;\n+            case DISABLED:\n+                invokeTimeoutTask();\n+                return true;\n+            default: // state == State.SCHEDULED", "originalCommit": "67eef3419ec1a728df4a977f431309833b41bff2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NDM5OA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367844398", "bodyText": "It seems like this method is not used anywhere? Maybe OK to remove?", "author": "trustin", "createdAt": "2020-01-17T09:37:58Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -69,11 +69,32 @@\n     /**\n      * Cancels the current timeout scheduled. You can schedule a new timeout with\n      * {@link #scheduleTimeout(long)} if the current timeout is canceled successfully.\n-     * @return {@code true} if the current timeout is canceled or no timeout was scheduled previously.\n-     *         {@code false} if the timeout has been triggered already.\n+     * @return {@code true} if the current timeout is canceled.\n+     *         {@code false} if the timeout has been triggered already or no timeout was scheduled previously.\n      */\n     boolean cancelTimeout();\n \n+    /**\n+     * Returns whether the timeout is scheduled or not.\n+     *\n+     * @return {@code true} the timeout is scheduled now.\n+     *         {@code false} if the timeout has been triggered already or no timeout was scheduled previously.\n+     */\n+    boolean isScheduled();", "originalCommit": "67eef3419ec1a728df4a977f431309833b41bff2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0ODIxNw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367848217", "bodyText": "Yes, it don't use anywhere. I was considering to add this or not. I've already added other boolean getters for TIMED_OUT and DISABLED.\nSo I thought it would be more natural for adding boolean getters for SCHEDULED.\nBut it seems overkill. Let me remove the unused code. \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-01-17T09:46:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NDM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NTQxMw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367845413", "bodyText": "Is there a chance a user calls timeout methods multiple times? Probably better chaining with andThen()", "author": "trustin", "createdAt": "2020-01-17T09:40:27Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -95,6 +95,8 @@\n     private Runnable responseTimeoutHandler;\n     @Nullable\n     private TimeoutController responseTimeoutController;\n+    @Nullable\n+    private Consumer<TimeoutController> pendingTimeoutTask;", "originalCommit": "67eef3419ec1a728df4a977f431309833b41bff2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NzU2Ng==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367847566", "bodyText": "Seems like this is only used for testing.\nI'm not sure, but if (startTimeNanos() is null if and only if state is DISABLED), then we could:\n\nRemove isDisabled() and use startTimeNanos() == null in the tests\nReplace isExecutedAtLeastOnce with state != DISABLED\n\nWe could set firstExecutionTime when the current state is DISABLED.", "author": "trustin", "createdAt": "2020-01-17T09:45:01Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -24,32 +26,79 @@\n public interface TimeoutController {\n \n     /**\n-     * Initializes the timeout scheduler with the specified {@code timeoutMillis}.\n+     * Schedules a new timeout with the specified {@code timeoutMillis}.\n+     * If a timeout is scheduled already, this method will not start a new timeout.\n+     *\n+     * @param timeoutMillis a positive time amount value in milliseconds.\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n      */\n-    void initTimeout(long timeoutMillis);\n+    boolean scheduleTimeout(long timeoutMillis);\n \n     /**\n      * Extends the current timeout by the specified {@code adjustmentMillis}.\n      * Note that a negative {@code adjustmentMillis} reduces the current timeout.\n      *\n      * @param adjustmentMillis the adjustment of time amount value in milliseconds.\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n      */\n-    void extendTimeout(long adjustmentMillis);\n+    boolean extendTimeout(long adjustmentMillis);\n \n     /**\n      * Sets the amount of time that is after the specified {@code newTimeoutMillis} from now.\n      *\n      * @param newTimeoutMillis the new timeout value in milliseconds. {@code 0} if disabled.\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n      */\n-    void resetTimeout(long newTimeoutMillis);\n+    boolean resetTimeout(long newTimeoutMillis);\n \n     /**\n-     * Cancels the current timeout scheduled.\n+     * Trigger the current timeout immediately.\n+     *\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n+     */\n+    boolean timeoutNow();\n+\n+    /**\n+     * Cancels the current timeout scheduled. You can schedule a new timeout with\n+     * {@link #scheduleTimeout(long)} if the current timeout is canceled successfully.\n+     * @return {@code true} if the current timeout is canceled.\n+     *         {@code false} if the timeout has been triggered already or no timeout was scheduled previously.\n      */\n     boolean cancelTimeout();\n \n     /**\n-     * Returns the start time of the initial timeout in nanoseconds.\n+     * Returns whether the timeout is scheduled or not.\n+     *\n+     * @return {@code true} the timeout is scheduled now.\n+     *         {@code false} if the timeout has been triggered already or no timeout was scheduled previously.\n+     */\n+    boolean isScheduled();\n+\n+    /**\n+     * Returns whether the timeout has been triggered or not.\n+     *\n+     * @return {@code true} if the timeout has been triggered already.\n+     *         {@code false} if the timeout is scheduled now or no timeout was scheduled previously.\n+     */\n+    boolean isTimedOut();\n+\n+    /**\n+     * Returns {@code true} if no timeout was scheduled previously.\n+     */\n+    boolean isDisabled();", "originalCommit": "67eef3419ec1a728df4a977f431309833b41bff2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg1NDc1Mw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367854753", "bodyText": "The DISABLED state can be reached even if isExecutedAtLeastOnce = true by calling cancelTimeout()\nTimeoutContoller tc = new DefaultTimeoutController() // isExecutedAtLeastOnce == false, DISABLED\ntc.scheduleTimeout(1000) // isExecutedAtLeastOnce == true, SCHEDULED\n// cancel timeout before the deadline.\ntc.cancelTimeout() // isExecutedAtLeastOnce == true, DISABLED\nBy the way, I think we can make startTimeNanos() == null after calling cancelTimeout().\nIt is a nicer approach.", "author": "ikhoon", "createdAt": "2020-01-17T10:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NzU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg5MTYxNA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r367891614", "bodyText": "The responseTimeoutMillis in DefaultClientContext is used to represent the amount of time since the start time of receiving the response.\nctx.setResponseTimeoutMillis(1000)\n// 1 seconds after\nctx.setResponseTimeoutAfterMillis(1000) \n// We need startTimeNanos() to get new 'responseTimeoutMillis' \nassert ctx.responseTimeoutMillis == System.nanoTime() - statTimeNanos() + responseTimeoutAfterMillis\nI think we still need isExecutedAtLeastOnce() or add a new state like WAITING to express never scheduled before?", "author": "ikhoon", "createdAt": "2020-01-17T11:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NzU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMzgzNg==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368203836", "bodyText": "+1 for adding another state. Probably INIT?", "author": "trustin", "createdAt": "2020-01-18T03:51:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NzU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMzk0OQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368203949", "bodyText": "Good, thought INIT too. \ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-01-18T03:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NzU2Ng=="}], "type": "inlineReview"}, {"oid": "58c45948770817092b945acef0cb4f0ed5310f0e", "url": "https://github.com/line/armeria/commit/58c45948770817092b945acef0cb4f0ed5310f0e", "message": "Add  State.INIT to DefaultTimeoutController", "committedDate": "2020-01-19T14:41:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MTk0MQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368391941", "bodyText": "set -> add?", "author": "trustin", "createdAt": "2020-01-20T06:57:35Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultClientRequestContext.java", "diffHunk": "@@ -593,6 +593,14 @@ public void setResponseTimeoutController(TimeoutController responseTimeoutContro\n         }\n     }\n \n+    private void setPendingTimeoutTask(Consumer<TimeoutController> pendingTimeoutTask) {", "originalCommit": "58c45948770817092b945acef0cb4f0ed5310f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MjIwMg==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368392202", "bodyText": "set -> add", "author": "trustin", "createdAt": "2020-01-20T06:58:39Z", "path": "core/src/main/java/com/linecorp/armeria/server/DefaultServiceRequestContext.java", "diffHunk": "@@ -669,6 +669,14 @@ public void setRequestTimeoutController(TimeoutController requestTimeoutControll\n         }\n     }\n \n+    private void setPendingTimeoutTask(Consumer<TimeoutController> pendingTimeoutTask) {", "originalCommit": "58c45948770817092b945acef0cb4f0ed5310f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MjU2Mg==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368392562", "bodyText": "assertThat(prevState).isNotIn(State.INIT, State.DISABLED)", "author": "trustin", "createdAt": "2020-01-20T07:00:13Z", "path": "core/src/test/java/com/linecorp/armeria/internal/DefaultTimeoutControllerTest.java", "diffHunk": "@@ -281,12 +282,12 @@ public boolean scheduleTimeout(long timeoutMillis) {\n             final boolean result = delegate.scheduleTimeout(timeoutMillis);\n             if (result) {\n                 // Previous: DISABLED\n-                assertThat(prevState).isEqualTo(State.DISABLED);\n+                assertThat(prevState == State.INIT || prevState == DISABLED).isTrue();\n                 // Transition to: SCHEDULE\n                 assertThat(delegate.state()).isEqualTo(State.SCHEDULED);\n             } else {\n                 // Previous: !DISABLED\n-                assertThat(prevState).isNotEqualTo(State.DISABLED);\n+                assertThat(prevState == State.INIT || prevState == DISABLED).isFalse();", "originalCommit": "58c45948770817092b945acef0cb4f0ed5310f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MjU3OA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368392578", "bodyText": "assertThat(prevState).isIn(State.INIT, State.DISABLED)", "author": "trustin", "createdAt": "2020-01-20T07:00:20Z", "path": "core/src/test/java/com/linecorp/armeria/internal/DefaultTimeoutControllerTest.java", "diffHunk": "@@ -281,12 +282,12 @@ public boolean scheduleTimeout(long timeoutMillis) {\n             final boolean result = delegate.scheduleTimeout(timeoutMillis);\n             if (result) {\n                 // Previous: DISABLED\n-                assertThat(prevState).isEqualTo(State.DISABLED);\n+                assertThat(prevState == State.INIT || prevState == DISABLED).isTrue();", "originalCommit": "58c45948770817092b945acef0cb4f0ed5310f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MjY3MA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368392670", "bodyText": "Static-import all or none", "author": "trustin", "createdAt": "2020-01-20T07:00:45Z", "path": "core/src/test/java/com/linecorp/armeria/internal/DefaultTimeoutControllerTest.java", "diffHunk": "@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.linecorp.armeria.internal.DefaultTimeoutController.State.DISABLED;", "originalCommit": "58c45948770817092b945acef0cb4f0ed5310f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MzU2Nw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368393567", "bodyText": "Use %s. + will be done even if IllegalArgumentException is not raised.", "author": "trustin", "createdAt": "2020-01-20T07:04:42Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +85,184 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");", "originalCommit": "58c45948770817092b945acef0cb4f0ed5310f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5Mzc1Nw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368393757", "bodyText": "How about: {@link TimeoutTask#canScheduled()} returned {@code false}. to make it more direct and clear?", "author": "trustin", "createdAt": "2020-01-20T07:05:40Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +85,184 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        ensureInitialized();\n+        if (state != State.DISABLED || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n-        }\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.", "originalCommit": "58c45948770817092b945acef0cb4f0ed5310f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5Mzg5Mw==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368393893", "bodyText": "Ditto", "author": "trustin", "createdAt": "2020-01-20T07:06:19Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +85,184 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        ensureInitialized();\n+        if (state != State.DISABLED || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n-        }\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            return false;\n         }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already or\n+     *         the {@link TimeoutTask} could not be scheduled now.", "originalCommit": "58c45948770817092b945acef0cb4f0ed5310f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MzkzOA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368393938", "bodyText": "Ditto", "author": "trustin", "createdAt": "2020-01-20T07:06:30Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +85,184 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: \" + timeoutMillis + \" (expected: > 0)\");\n+        ensureInitialized();\n+        if (state != State.DISABLED || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n-        }\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            return false;\n         }\n+\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already or\n+     *         the {@link TimeoutTask} could not be scheduled now.\n+     */\n     @Override\n-    public void resetTimeout(long newTimeoutMillis) {\n+    public boolean resetTimeout(long newTimeoutMillis) {\n         ensureInitialized();\n+        if (state == State.TIMED_OUT || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n         if (newTimeoutMillis <= 0) {\n             timeoutMillis = newTimeoutMillis;\n             cancelTimeout();\n-            return;\n+            return true;\n         }\n \n-        if (timeoutTask.canSchedule()) {\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            final long remainingTimeoutMillis = LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis);\n-            lastStartTimeNanos = currentNanoTime;\n-            if (remainingTimeoutMillis == newTimeoutMillis) {\n-                return;\n-            }\n+        // Cancel the previously scheduled timeout, if exists.\n+        cancelTimeout();\n+        timeoutMillis = newTimeoutMillis;\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n+    }\n+\n+    /**\n+     * Trigger the current timeout immediately.\n+     *\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} the timeout has been triggered already\n+     *         or the {@link TimeoutTask} could not be scheduled now.", "originalCommit": "58c45948770817092b945acef0cb4f0ed5310f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5NDE2NQ==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368394165", "bodyText": "%s please", "author": "trustin", "createdAt": "2020-01-20T07:07:20Z", "path": "core/src/main/java/com/linecorp/armeria/server/DefaultServiceRequestContext.java", "diffHunk": "@@ -427,12 +446,22 @@ public void setRequestTimeoutAfter(Duration requestTimeout) {\n     public void setRequestTimeoutAtMillis(long requestTimeoutAtMillis) {\n         checkArgument(requestTimeoutAtMillis >= 0,\n                       \"requestTimeoutAtMillis: \" + requestTimeoutAtMillis + \" (expected: >= 0)\");", "originalCommit": "58c45948770817092b945acef0cb4f0ed5310f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9ac1a22f54ca6fd40d4a8c77c79a72494b10db38", "url": "https://github.com/line/armeria/commit/9ac1a22f54ca6fd40d4a8c77c79a72494b10db38", "message": "Address comments by @trustin\n\n- Rename setPendingTimeoutTask to addPendingTimeoutTask\n- Replace string concat with `+` to `%s` in checkArgument and\n  checkState.\n- Update Javadoc", "committedDate": "2020-01-20T08:08:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUwNjE1MA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368506150", "bodyText": "nit: cancelled", "author": "minwoox", "createdAt": "2020-01-20T11:46:30Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/TimeoutController.java", "diffHunk": "@@ -24,32 +26,71 @@\n public interface TimeoutController {\n \n     /**\n-     * Initializes the timeout scheduler with the specified {@code timeoutMillis}.\n+     * Schedules a new timeout with the specified {@code timeoutMillis}.\n+     * If a timeout is scheduled already, this method will not start a new timeout.\n+     *\n+     * @param timeoutMillis a positive time amount value in milliseconds.\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n      */\n-    void initTimeout(long timeoutMillis);\n+    boolean scheduleTimeout(long timeoutMillis);\n \n     /**\n      * Extends the current timeout by the specified {@code adjustmentMillis}.\n      * Note that a negative {@code adjustmentMillis} reduces the current timeout.\n      *\n      * @param adjustmentMillis the adjustment of time amount value in milliseconds.\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n      */\n-    void extendTimeout(long adjustmentMillis);\n+    boolean extendTimeout(long adjustmentMillis);\n \n     /**\n      * Sets the amount of time that is after the specified {@code newTimeoutMillis} from now.\n      *\n      * @param newTimeoutMillis the new timeout value in milliseconds. {@code 0} if disabled.\n+     * @return {@code true} if the current timeout is reset by the specified {@code newTimeoutMillis}.\n+     *         {@code false} if the timeout has been triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n      */\n-    void resetTimeout(long newTimeoutMillis);\n+    boolean resetTimeout(long newTimeoutMillis);\n \n     /**\n-     * Cancels the current timeout scheduled.\n+     * Trigger the current timeout immediately.\n+     *\n+     * @return {@code true} if the current timeout is triggered successfully.\n+     *         {@code false} if the timeout has been triggered already\n+     *         or a timeout cannot be scheduled, e.g. request or response has been handled already.\n+     */\n+    boolean timeoutNow();\n+\n+    /**\n+     * Cancels the current timeout scheduled. You can schedule a new timeout with\n+     * {@link #scheduleTimeout(long)} if the current timeout is canceled successfully.", "originalCommit": "9ac1a22f54ca6fd40d4a8c77c79a72494b10db38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUwOTExMA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368509110", "bodyText": "Because adjustmentMillis can be a negative number, shouldn't this be true?", "author": "minwoox", "createdAt": "2020-01-20T11:54:04Z", "path": "core/src/main/java/com/linecorp/armeria/internal/DefaultTimeoutController.java", "diffHunk": "@@ -76,100 +85,184 @@ public void setTimeoutTask(TimeoutTask timeoutTask) {\n      *\n      * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n      * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the timeout is scheduled.\n+     *         {@code false} if the timeout has been scheduled, the timeout has been triggered already\n+     *         or the {@link TimeoutTask#canSchedule()} returned {@code false}.\n      */\n     @Override\n-    public void initTimeout(long timeoutMillis) {\n-        if (timeoutFuture != null || timeoutTask == null || !timeoutTask.canSchedule()) {\n-            // No need to schedule a response timeout if:\n-            // - the timeout has been scheduled already,\n-            // - the timeout task is not set yet or\n-            // - the timeout task cannot schedule yet or\n-            return;\n+    public boolean scheduleTimeout(long timeoutMillis) {\n+        checkArgument(timeoutMillis > 0,\n+                      \"timeoutMillis: %s (expected: > 0)\", timeoutMillis);\n+        ensureInitialized();\n+        if (state != State.DISABLED || !timeoutTask.canSchedule()) {\n+            return false;\n         }\n \n+        cancelTimeout();\n         this.timeoutMillis = timeoutMillis;\n-        firstStartTimeNanos = lastStartTimeNanos = System.nanoTime();\n-        if (timeoutMillis > 0) {\n-            timeoutFuture = eventLoop.schedule(timeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n-        }\n+        state = State.SCHEDULED;\n+        timeoutFuture = eventLoop.schedule(this::invokeTimeoutTask, timeoutMillis, TimeUnit.MILLISECONDS);\n+        return true;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * <p>Note that the {@link TimeoutTask} should be set via the {@link #setTimeoutTask(TimeoutTask)} or\n+     * the {@link #DefaultTimeoutController(TimeoutTask, EventLoop)} before calling this method.\n+     *\n+     * @return {@code true} if the current timeout is extended by the specified {@code adjustmentMillis}.\n+     *         {@code false} if no timeout was scheduled previously, the timeout has been triggered already\n+     *         or the {@link TimeoutTask#canSchedule()} returned {@code false}.\n+     */\n     @Override\n-    public void extendTimeout(long adjustmentMillis) {\n+    public boolean extendTimeout(long adjustmentMillis) {\n         ensureInitialized();\n+        if (state != State.SCHEDULED || !timeoutTask.canSchedule()) {\n+            return false;\n+        }\n+\n         if (adjustmentMillis == 0) {\n-            return;\n+            return true;\n         }\n \n         // Cancel the previously scheduled timeout, if exists.\n         cancelTimeout();\n \n-        if (timeoutTask.canSchedule()) {\n-            // Calculate the amount of time passed since the creation of this subscriber.\n-            final long currentNanoTime = System.nanoTime();\n-            final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastStartTimeNanos);\n-            // newTimeoutMillis = timeoutMillis - passedTimeMillis + adjustmentMillis\n-            final long newTimeoutMillis = LongMath.saturatedAdd(\n-                    LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n-            timeoutMillis = newTimeoutMillis;\n-            lastStartTimeNanos = currentNanoTime;\n-            if (newTimeoutMillis > 0) {\n-                timeoutFuture = eventLoop.schedule(\n-                        timeoutTask, newTimeoutMillis, TimeUnit.MILLISECONDS);\n-            } else {\n-                // We went past the dead line set by the new timeout already.\n-                timeoutTask.run();\n-            }\n+        // Calculate the amount of time passed since lastStart\n+        final long currentNanoTime = System.nanoTime();\n+        final long passedTimeMillis = TimeUnit.NANOSECONDS.toMillis(currentNanoTime - lastExecutionTimeNanos);\n+        final long newTimeoutMillis = LongMath.saturatedAdd(\n+                LongMath.saturatedSubtract(timeoutMillis, passedTimeMillis), adjustmentMillis);\n+        timeoutMillis = newTimeoutMillis;\n+        lastExecutionTimeNanos = currentNanoTime;\n+\n+        if (newTimeoutMillis <= 0) {\n+            invokeTimeoutTask();\n+            return false;", "originalCommit": "9ac1a22f54ca6fd40d4a8c77c79a72494b10db38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgwMTk1OA==", "url": "https://github.com/line/armeria/pull/2391#discussion_r368801958", "bodyText": "Ah, that makes sense! It seems better to return true.", "author": "ikhoon", "createdAt": "2020-01-21T03:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODUwOTExMA=="}], "type": "inlineReview"}, {"oid": "bdb8886b1932cb6832b122fd93e6ee6c29115c51", "url": "https://github.com/line/armeria/commit/bdb8886b1932cb6832b122fd93e6ee6c29115c51", "message": "Address comments by @minwoox\n\n- Remove `isDisabled` in TimeoutController\n- Rename `DISABLED` to `INACTIVE`", "committedDate": "2020-01-21T02:39:44Z", "type": "commit"}, {"oid": "e8ec1fb8856050550269950be7b7321d8a296c91", "url": "https://github.com/line/armeria/commit/e8ec1fb8856050550269950be7b7321d8a296c91", "message": "Address comments by @minwoox\n\n- Change 'canceled' to 'cancelled'\n- extendTimeout returns 'true' when timeout is triggered", "committedDate": "2020-01-21T04:00:56Z", "type": "commit"}, {"oid": "e8ec1fb8856050550269950be7b7321d8a296c91", "url": "https://github.com/line/armeria/commit/e8ec1fb8856050550269950be7b7321d8a296c91", "message": "Address comments by @minwoox\n\n- Change 'canceled' to 'cancelled'\n- extendTimeout returns 'true' when timeout is triggered", "committedDate": "2020-01-21T04:00:56Z", "type": "forcePushed"}]}