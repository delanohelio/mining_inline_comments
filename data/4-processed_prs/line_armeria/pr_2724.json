{"pr_number": 2724, "pr_title": "Add `RequestScopedMdc` for request-scoped MDC properties", "pr_createdAt": "2020-05-18T09:55:15Z", "pr_url": "https://github.com/line/armeria/pull/2724", "timeline": [{"oid": "e7ba2bbc8fac46e02b0d16ee659438572c3974e1", "url": "https://github.com/line/armeria/commit/e7ba2bbc8fac46e02b0d16ee659438572c3974e1", "message": "Add `RequestScopedMdc` for request-scoped MDC properties\n\nMotivation:\n\nTraditionally, MDC properties were bound to the current thread, but this\ndoes not work really well for asynchronous applications, like Armeria.\n\nModifications:\n\n- Added `RequestScopedMdc` which:\n  - provides an access to an internal map property of `RequestContext`\n  - replaces the default `MDCAdapter` of SLF4J so that `MDC.get()` and\n    `getCopyOfContextMap()` looks into the request-scoped context map\n\nResult:\n\n- A user can easily bind an MDC property to a `RequestContext` and log\n  it using a logging framework.\n  ```java\n  // In some non-Armeria thread:\n  WebClient client = ...;\n  try (SafeCloseable ignored = Clients.withContextCustomizer(ctx -> {\n      RequestScopedMdc.copy(ctx, \"transactionId\");\n  }) {\n      client.execute(...);\n  }\n  ```", "committedDate": "2020-05-18T09:54:46Z", "type": "commit"}, {"oid": "647c0236a881cd2eae5b00ed584564b5a0e8a269", "url": "https://github.com/line/armeria/commit/647c0236a881cd2eae5b00ed584564b5a0e8a269", "message": "Javadoc / Checkstyle", "committedDate": "2020-05-18T10:47:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MTk2OA==", "url": "https://github.com/line/armeria/pull/2724#discussion_r426991968", "bodyText": "nit: double dot.", "author": "minwoox", "createdAt": "2020-05-19T02:20:39Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}..", "originalCommit": "647c0236a881cd2eae5b00ed584564b5a0e8a269", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MjA2Ng==", "url": "https://github.com/line/armeria/pull/2724#discussion_r426992066", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-19T02:20:57Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property\n+     *\n+     * @return the request-scoped {@link MDC} property. {@code null} if not found.\n+     */\n+    @Nullable\n+    public static String get(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        return getMap(ctx).get(key);\n+    }\n+\n+    /**\n+     * Returns the {@link Map} of all request-scoped {@link MDC} properties bound to the specified\n+     * {@link RequestContext}..", "originalCommit": "647c0236a881cd2eae5b00ed584564b5a0e8a269", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MzUxMQ==", "url": "https://github.com/line/armeria/pull/2724#discussion_r426993511", "bodyText": "Isn't it better to always put unmodifiableMap to the context and return the map without making it unmodifiable? because the implementation supposes that reading is a lot than writing?", "author": "minwoox", "createdAt": "2020-05-19T02:26:31Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property\n+     *\n+     * @return the request-scoped {@link MDC} property. {@code null} if not found.\n+     */\n+    @Nullable\n+    public static String get(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        return getMap(ctx).get(key);\n+    }\n+\n+    /**\n+     * Returns the {@link Map} of all request-scoped {@link MDC} properties bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     *\n+     * @return the {@link Map} that contains all request-scoped {@link MDC} properties.\n+     *         An empty {@link Map} if there are no request-scoped {@link MDC} properties.\n+     */\n+    public static Map<String, String> getAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        final Map<String, String> map = getMap(ctx);\n+        // Note: We ensure an empty map is always immutable.\n+        return map.isEmpty() ? map : Collections.unmodifiableMap(map);", "originalCommit": "647c0236a881cd2eae5b00ed584564b5a0e8a269", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NTI4Mg==", "url": "https://github.com/line/armeria/pull/2724#discussion_r426995282", "bodyText": "I'm wondering we should add owdAttr to RequestContext so that we do not have to check the instance all the time. \ud83e\udd14", "author": "minwoox", "createdAt": "2020-05-19T02:33:05Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property\n+     *\n+     * @return the request-scoped {@link MDC} property. {@code null} if not found.\n+     */\n+    @Nullable\n+    public static String get(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        return getMap(ctx).get(key);\n+    }\n+\n+    /**\n+     * Returns the {@link Map} of all request-scoped {@link MDC} properties bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     *\n+     * @return the {@link Map} that contains all request-scoped {@link MDC} properties.\n+     *         An empty {@link Map} if there are no request-scoped {@link MDC} properties.\n+     */\n+    public static Map<String, String> getAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        final Map<String, String> map = getMap(ctx);\n+        // Note: We ensure an empty map is always immutable.\n+        return map.isEmpty() ? map : Collections.unmodifiableMap(map);\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx   the {@link RequestContext}\n+     * @param key   the key of the request-scoped {@link MDC} property\n+     * @param value the value of the request-scoped {@link MDC} property\n+     */\n+    public static void put(RequestContext ctx, String key, @Nullable String value) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = Collections.singletonMap(key, value);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + 1);\n+                newMap.putAll(oldMap);\n+                newMap.put(key, value);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param map the {@link Map} that contains the request-scoped {@link MDC} properties\n+     */\n+    public static void putAll(RequestContext ctx, Map<String, String> map) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(map, \"map\");\n+        if (map.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = new Object2ObjectOpenHashMap<>(map);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n+                newMap.putAll(oldMap);\n+                newMap.putAll(map);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Copies the specified thread-local {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the thread-local {@link MDC} property to copy\n+     */\n+    public static void copy(RequestContext ctx, String key) {\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        put(ctx, key, delegate.get(key));\n+    }\n+\n+    /**\n+     * Copies all thread-local {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void copyAll(RequestContext ctx) {\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        putAll(ctx, firstNonNull(delegate.getCopyOfContextMap(), Collections.emptyMap()));\n+    }\n+\n+    /**\n+     * Unbinds the specified request-scoped {@link MDC} property from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property to unbind\n+     */\n+    public static void remove(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.containsKey(key)) {\n+                return;\n+            }\n+\n+            final Map<String, String> newMap;\n+            if (oldMap.size() == 1) {\n+                newMap = Collections.emptyMap();\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap);\n+                newMap.remove(key);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Unbinds all request-scoped {@link MDC} properties from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void clear(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.isEmpty()) {\n+                ctx.setAttr(MAP, Collections.emptyMap());\n+            }\n+        }\n+    }\n+\n+    private static Map<String, String> getMap(RequestContext ctx) {\n+        final Map<String, String> map;\n+        if (ctx instanceof ClientRequestContext) {\n+            map = ((ClientRequestContext) ctx).ownAttr(MAP);", "originalCommit": "647c0236a881cd2eae5b00ed584564b5a0e8a269", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NjcwMQ==", "url": "https://github.com/line/armeria/pull/2724#discussion_r427046701", "bodyText": "Yeah, and computeOwnAttrIfAbsent(), etc. \ud83d\ude04", "author": "trustin", "createdAt": "2020-05-19T05:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NTI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NjA1NA==", "url": "https://github.com/line/armeria/pull/2724#discussion_r426996054", "bodyText": "Let's add assertThat(MDC.get(\"foo\")).isNull();", "author": "minwoox", "createdAt": "2020-05-19T02:35:48Z", "path": "core/src/test/java/com/linecorp/armeria/common/logging/RequestScopedMdcTest.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.Collections;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.slf4j.MDC;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.RequestContext;\n+import com.linecorp.armeria.common.util.SafeCloseable;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+class RequestScopedMdcTest {\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        MDC.clear();\n+        assertThat(MDC.getCopyOfContextMap()).isIn(Collections.emptyMap(), null);\n+        assertThat(RequestContext.<RequestContext>currentOrNull()).isNull();\n+    }\n+\n+    @Test\n+    void threadLocalGet() {\n+        MDC.put(\"threadLocalProp\", \"1\");\n+        assertThat(MDC.get(\"threadLocalProp\")).isEqualTo(\"1\");\n+    }\n+\n+    @Test\n+    void get() {\n+        final ServiceRequestContext ctx = newContext();\n+        RequestScopedMdc.put(ctx, \"foo\", \"1\");\n+        assertThat(RequestScopedMdc.get(ctx, \"foo\")).isEqualTo(\"1\");\n+        try (SafeCloseable ignored = ctx.push()) {\n+            assertThat(MDC.get(\"foo\")).isEqualTo(\"1\");\n+            // Request-scoped property should have priority over thread-local one.\n+            MDC.put(\"foo\", \"2\");\n+            assertThat(MDC.get(\"foo\")).isEqualTo(\"1\");\n+\n+            // A client context must use its own map.\n+            final ClientRequestContext cctx = ClientRequestContext.of(HttpRequest.of(HttpMethod.GET, \"/\"));\n+            assertThat(cctx.root()).isSameAs(ctx);\n+            assertThat(RequestScopedMdc.get(cctx, \"foo\")).isNull();\n+        }\n+    }", "originalCommit": "647c0236a881cd2eae5b00ed584564b5a0e8a269", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNTUyNg==", "url": "https://github.com/line/armeria/pull/2724#discussion_r427005526", "bodyText": "Could remove @Nullable?", "author": "ikhoon", "createdAt": "2020-05-19T03:14:24Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property\n+     *\n+     * @return the request-scoped {@link MDC} property. {@code null} if not found.\n+     */\n+    @Nullable\n+    public static String get(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        return getMap(ctx).get(key);\n+    }\n+\n+    /**\n+     * Returns the {@link Map} of all request-scoped {@link MDC} properties bound to the specified\n+     * {@link RequestContext}..\n+     *\n+     * @param ctx the {@link RequestContext}\n+     *\n+     * @return the {@link Map} that contains all request-scoped {@link MDC} properties.\n+     *         An empty {@link Map} if there are no request-scoped {@link MDC} properties.\n+     */\n+    public static Map<String, String> getAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        final Map<String, String> map = getMap(ctx);\n+        // Note: We ensure an empty map is always immutable.\n+        return map.isEmpty() ? map : Collections.unmodifiableMap(map);\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx   the {@link RequestContext}\n+     * @param key   the key of the request-scoped {@link MDC} property\n+     * @param value the value of the request-scoped {@link MDC} property\n+     */\n+    public static void put(RequestContext ctx, String key, @Nullable String value) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = Collections.singletonMap(key, value);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + 1);\n+                newMap.putAll(oldMap);\n+                newMap.put(key, value);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param map the {@link Map} that contains the request-scoped {@link MDC} properties\n+     */\n+    public static void putAll(RequestContext ctx, Map<String, String> map) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(map, \"map\");\n+        if (map.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = new Object2ObjectOpenHashMap<>(map);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n+                newMap.putAll(oldMap);\n+                newMap.putAll(map);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Copies the specified thread-local {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the thread-local {@link MDC} property to copy\n+     */\n+    public static void copy(RequestContext ctx, String key) {\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        put(ctx, key, delegate.get(key));\n+    }\n+\n+    /**\n+     * Copies all thread-local {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void copyAll(RequestContext ctx) {\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        putAll(ctx, firstNonNull(delegate.getCopyOfContextMap(), Collections.emptyMap()));\n+    }\n+\n+    /**\n+     * Unbinds the specified request-scoped {@link MDC} property from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property to unbind\n+     */\n+    public static void remove(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.containsKey(key)) {\n+                return;\n+            }\n+\n+            final Map<String, String> newMap;\n+            if (oldMap.size() == 1) {\n+                newMap = Collections.emptyMap();\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap);\n+                newMap.remove(key);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Unbinds all request-scoped {@link MDC} properties from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void clear(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.isEmpty()) {\n+                ctx.setAttr(MAP, Collections.emptyMap());\n+            }\n+        }\n+    }\n+\n+    private static Map<String, String> getMap(RequestContext ctx) {\n+        final Map<String, String> map;\n+        if (ctx instanceof ClientRequestContext) {\n+            map = ((ClientRequestContext) ctx).ownAttr(MAP);\n+        } else {\n+            map = ctx.attr(MAP);\n+        }\n+        return firstNonNull(map, Collections.emptyMap());\n+    }\n+\n+    private RequestScopedMdc() {}\n+\n+    private static final class Adapter implements MDCAdapter {\n+\n+        private final MDCAdapter delegate;\n+\n+        Adapter(MDCAdapter delegate) {\n+            this.delegate = requireNonNull(delegate, \"delegate\");\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String get(String key) {\n+            final RequestContext ctx = RequestContext.currentOrNull();\n+            if (ctx != null) {\n+                final String value = getMap(ctx).get(key);\n+                if (value != null) {\n+                    return value;\n+                }\n+            }\n+\n+            return delegate.get(key);\n+        }\n+\n+        @Override\n+        @Nullable", "originalCommit": "647c0236a881cd2eae5b00ed584564b5a0e8a269", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c0f024e4155db07a86df98abb1eccb44c6442eca", "url": "https://github.com/line/armeria/commit/c0f024e4155db07a86df98abb1eccb44c6442eca", "message": "Address the comments from @minwoox", "committedDate": "2020-05-19T05:59:54Z", "type": "commit"}, {"oid": "6acb487e77ff3b8cfc9fcab4ddb7a77355c6b1a8", "url": "https://github.com/line/armeria/commit/6acb487e77ff3b8cfc9fcab4ddb7a77355c6b1a8", "message": "Merge branch 'master' into request_scoped_mdc", "committedDate": "2020-05-19T06:00:26Z", "type": "commit"}, {"oid": "fdc9e3689415b534ca60f1f8cfa4f20584d7ede0", "url": "https://github.com/line/armeria/commit/fdc9e3689415b534ca60f1f8cfa4f20584d7ede0", "message": "Address the comment from @ikhoon / Remove redundant `unmodifiableMap()`", "committedDate": "2020-05-19T06:02:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzcyNQ==", "url": "https://github.com/line/armeria/pull/2724#discussion_r427053725", "bodyText": "Question: Is it intended to return the modifiable map?", "author": "minwoox", "createdAt": "2020-05-19T06:16:30Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestScopedMdc.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.MDC;\n+import org.slf4j.spi.MDCAdapter;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.common.RequestContext;\n+\n+import io.netty.util.AttributeKey;\n+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\n+\n+/**\n+ * Provides the access to request-scoped {@link MDC} properties. All properties set via the access methods in\n+ * this class are bound to a {@link RequestContext}, unlike the traditional thread-local {@link MDC} properties.\n+ *\n+ * <h3>Updating the request-scoped context map</h3>\n+ *\n+ * <p>Update the request-scoped context map using {@link #put(RequestContext, String, String)},\n+ * {@link #putAll(RequestContext, Map)}, {@link #remove(RequestContext, String)} and\n+ * {@link #clear(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * RequestScopedMdc.putAll(ctx, Map.of(\"foo\", \"1\", \"bar\", \"2\"));\n+ * }</pre></p>\n+ *\n+ * <h3>Transferring thread-local properties</h3>\n+ *\n+ * <p>Use {@link #copy(RequestContext, String)} or {@link #copyAll(RequestContext)} to copy some or all of\n+ * thread-local {@link MDC} properties to the request-scoped context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * MDC.put(\"transactionId\", \"1234\");\n+ * RequestScopedMdc.copy(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <h3>Retrieving a value from the request-scoped context map</h3>\n+ *\n+ * <p>You can explicitly retrieve request-scoped properties using {@link #get(RequestContext, String)} or\n+ * {@link #getAll(RequestContext)}:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * String transactionId = RequestScopedMdc.get(ctx, \"transactionId\");\n+ * }</pre></p>\n+ *\n+ * <p>{@link RequestScopedMdc} replaces SLF4J's underlying {@link MDCAdapter} implementation so that\n+ * {@link MDC#get(String)} and {@link MDC#getCopyOfContextMap()} look into the request-scoped context map\n+ * before the thread-local context map:\n+ * <pre>{@code\n+ * RequestContext ctx = ...;\n+ * RequestScopedMdc.put(ctx, \"transactionId\", \"1234\");\n+ * try (SafeCloseable ignored = ctx.push()) {\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ *\n+ *     // A request-scoped property always gets higher priority:\n+ *     MDC.put(\"transactionId\", \"5678\");\n+ *     assert MDC.get(\"transactionId\").equals(\"1234\");\n+ * }\n+ *\n+ * // Now using the thread-local property\n+ * // because not in a request scope anymore\n+ * assert MDC.get(\"transactionId\").equals(\"5678\");\n+ * }</pre></p>\n+ */\n+public final class RequestScopedMdc {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RequestScopedMdc.class);\n+\n+    private static final AttributeKey<Map<String, String>> MAP =\n+            AttributeKey.valueOf(RequestScopedMdc.class, \"map\");\n+\n+    private static final String ERROR_MESSAGE =\n+            \"Failed to replace the \" + MDCAdapter.class.getSimpleName() + \"; \" +\n+            RequestScopedMdc.class.getSimpleName() + \" will not work.\";\n+\n+    @Nullable\n+    private static final MDCAdapter delegate;\n+\n+    static {\n+        // Trigger the initialization of the default MDC adapter.\n+        MDC.get(\"\");\n+\n+        // Replace the default MDC adapter with ours.\n+        MDCAdapter oldAdapter = null;\n+        try {\n+            final Field mdcAdapterField = MDC.class.getDeclaredField(\"mdcAdapter\");\n+            mdcAdapterField.setAccessible(true);\n+            oldAdapter = (MDCAdapter) mdcAdapterField.get(null);\n+            mdcAdapterField.set(null, new Adapter(oldAdapter));\n+        } catch (Throwable t) {\n+            logger.warn(ERROR_MESSAGE, t);\n+        }\n+        delegate = oldAdapter;\n+    }\n+\n+    /**\n+     * Returns the value of the specified request-scoped {@link MDC} property bound to the specified\n+     * {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property\n+     *\n+     * @return the request-scoped {@link MDC} property. {@code null} if not found.\n+     */\n+    @Nullable\n+    public static String get(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        return getMap(ctx).get(key);\n+    }\n+\n+    /**\n+     * Returns the {@link Map} of all request-scoped {@link MDC} properties bound to the specified\n+     * {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     *\n+     * @return the {@link Map} that contains all request-scoped {@link MDC} properties.\n+     *         An empty {@link Map} if there are no request-scoped {@link MDC} properties.\n+     */\n+    public static Map<String, String> getAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        return getMap(ctx);\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx   the {@link RequestContext}\n+     * @param key   the key of the request-scoped {@link MDC} property\n+     * @param value the value of the request-scoped {@link MDC} property\n+     */\n+    public static void put(RequestContext ctx, String key, @Nullable String value) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = Collections.singletonMap(key, value);\n+            } else {\n+                final Object2ObjectOpenHashMap<String, String> tmp =\n+                        new Object2ObjectOpenHashMap<>(oldMap.size() + 1);\n+                tmp.putAll(oldMap);\n+                tmp.put(key, value);\n+                newMap = Collections.unmodifiableMap(tmp);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Binds the specified request-scoped {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param map the {@link Map} that contains the request-scoped {@link MDC} properties\n+     */\n+    public static void putAll(RequestContext ctx, Map<String, String> map) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(map, \"map\");\n+        if (map.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = new Object2ObjectOpenHashMap<>(map);\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n+                newMap.putAll(oldMap);\n+                newMap.putAll(map);\n+            }\n+            ctx.setAttr(MAP, Collections.unmodifiableMap(newMap));\n+        }\n+    }\n+\n+    /**\n+     * Copies the specified thread-local {@link MDC} property to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the thread-local {@link MDC} property to copy\n+     */\n+    public static void copy(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+        checkState(delegate != null, ERROR_MESSAGE);\n+        put(ctx, key, delegate.get(key));\n+    }\n+\n+    /**\n+     * Copies all thread-local {@link MDC} properties to the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void copyAll(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+        checkState(delegate != null, ERROR_MESSAGE);\n+\n+        final Map<String, String> map = delegate.getCopyOfContextMap();\n+        if (map == null || map.isEmpty()) {\n+            return;\n+        }\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            final Map<String, String> newMap;\n+            if (oldMap.isEmpty()) {\n+                newMap = map;\n+            } else {\n+                newMap = new Object2ObjectOpenHashMap<>(oldMap.size() + map.size());\n+                newMap.putAll(oldMap);\n+                newMap.putAll(map);\n+            }\n+            ctx.setAttr(MAP, Collections.unmodifiableMap(newMap));\n+        }\n+    }\n+\n+    /**\n+     * Unbinds the specified request-scoped {@link MDC} property from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     * @param key the key of the request-scoped {@link MDC} property to unbind\n+     */\n+    public static void remove(RequestContext ctx, String key) {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(key, \"key\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.containsKey(key)) {\n+                return;\n+            }\n+\n+            final Map<String, String> newMap;\n+            if (oldMap.size() == 1) {\n+                newMap = Collections.emptyMap();\n+            } else {\n+                final Object2ObjectOpenHashMap<String, String> tmp = new Object2ObjectOpenHashMap<>(oldMap);\n+                tmp.remove(key);\n+                newMap = Collections.unmodifiableMap(tmp);\n+            }\n+            ctx.setAttr(MAP, newMap);\n+        }\n+    }\n+\n+    /**\n+     * Unbinds all request-scoped {@link MDC} properties from the specified {@link RequestContext}.\n+     *\n+     * @param ctx the {@link RequestContext}\n+     */\n+    public static void clear(RequestContext ctx) {\n+        requireNonNull(ctx, \"ctx\");\n+\n+        synchronized (ctx) {\n+            final Map<String, String> oldMap = getMap(ctx);\n+            if (!oldMap.isEmpty()) {\n+                ctx.setAttr(MAP, Collections.emptyMap());\n+            }\n+        }\n+    }\n+\n+    private static Map<String, String> getMap(RequestContext ctx) {\n+        final Map<String, String> map;\n+        if (ctx instanceof ClientRequestContext) {\n+            map = ((ClientRequestContext) ctx).ownAttr(MAP);\n+        } else {\n+            map = ctx.attr(MAP);\n+        }\n+        return firstNonNull(map, Collections.emptyMap());\n+    }\n+\n+    private RequestScopedMdc() {}\n+\n+    private static final class Adapter implements MDCAdapter {\n+\n+        private final MDCAdapter delegate;\n+\n+        Adapter(MDCAdapter delegate) {\n+            this.delegate = requireNonNull(delegate, \"delegate\");\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String get(String key) {\n+            final RequestContext ctx = RequestContext.currentOrNull();\n+            if (ctx != null) {\n+                final String value = getMap(ctx).get(key);\n+                if (value != null) {\n+                    return value;\n+                }\n+            }\n+\n+            return delegate.get(key);\n+        }\n+\n+        @Override\n+        public Map<String, String> getCopyOfContextMap() {\n+            final Map<String, String> threadLocalMap =\n+                    firstNonNull(delegate.getCopyOfContextMap(), Collections.emptyMap());\n+            final RequestContext ctx = RequestContext.currentOrNull();\n+            if (ctx == null) {\n+                // No context available\n+                return threadLocalMap;\n+            }\n+\n+            final Map<String, String> requestScopedMap =\n+                    firstNonNull(getMap(ctx), Collections.emptyMap());\n+            if (threadLocalMap.isEmpty()) {\n+                // No thread-local map available\n+                return requestScopedMap;\n+            }\n+\n+            // Thread-local map available\n+            if (requestScopedMap.isEmpty()) {\n+                // Only thread-local map available\n+                return threadLocalMap;\n+            }\n+\n+            // Both thread-local and request-scoped map available\n+            final Map<String, String> merged =\n+                    new Object2ObjectOpenHashMap<>(threadLocalMap.size() + requestScopedMap.size());\n+            merged.putAll(threadLocalMap);\n+            merged.putAll(requestScopedMap);\n+            return merged;", "originalCommit": "fdc9e3689415b534ca60f1f8cfa4f20584d7ede0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2MDkyOA==", "url": "https://github.com/line/armeria/pull/2724#discussion_r427060928", "bodyText": "The API documentation does not tell us whether we should return an unmodifiable map or not, so I took a cheaper path.", "author": "trustin", "createdAt": "2020-05-19T06:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA3OTc4MA==", "url": "https://github.com/line/armeria/pull/2724#discussion_r427079780", "bodyText": "Yes, it seems so. Just wanted to make sure. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-05-19T07:16:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzcyNQ=="}], "type": "inlineReview"}]}