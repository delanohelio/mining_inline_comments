{"pr_number": 2523, "pr_title": "Revamp the options API", "pr_createdAt": "2020-02-22T04:16:16Z", "pr_url": "https://github.com/line/armeria/pull/2523", "timeline": [{"oid": "4f1197af4f625086c4874572ba0fadf4ea1c16b6", "url": "https://github.com/line/armeria/commit/4f1197af4f625086c4874572ba0fadf4ea1c16b6", "message": "Revamp the options API\n\nMotivation:\n\nCurrently, the option's default values and the code that validates and\nmerges an option value is placed in the container classes (`*Options`)\nrather than the key classes (`*Option`). This harms the readability and\nmaintainability of options, because:\n\n- An option and its defalut value are maintained in different places. A\n  dev can forget to add a default value when adding a new option.\n- If a new option is added for a certain client type only such as gRPC,\n  there's no way for a dev to implement a merge function specific to\n  that option. A dev must update the container's merge function in the\n  core, breaking modularity.\n\nModifications:\n\n- `AbstractOption` now has default value, validator and merge function.\n  - As a result, type parameters of `AbstractOption`, `AbstractOptions`,\n    `AbstractOptionValue` have been changed.\n- `AbstractOption` does not use Netty's `Constant` API, because it\n  cannot handle the case of having more than ID and name.\n- (Breaking) `AbstractOption` does not have `id()` anymore.\n- (Breaking) `AbstractOptions` does not have `getOrElse()` and\n  `getOrNull()` anymore. `get()` will return the default value for an\n  unspecified option.\n- gRPC related changes:\n  - The behavior of `MAX_INBOUND_MESSAGE_SIZE_BYTES` has been changed\n    slightly, hopefully easier to understand.\n  - Added `GRPC_` prefix to the option names so that they do not clash\n    with other options which may be added in the future.\n- Miscellaneous:\n  - `GrpcStatus.fromThrowable()` now understands `ContentTooLargeException`.\n\nResult:\n\n- Easier to maintain options.\n- Easier to get the default option values.", "committedDate": "2020-02-22T04:15:24Z", "type": "commit"}, {"oid": "0bc8057f47c081b6e2c63e988b2b94a46deeb000", "url": "https://github.com/line/armeria/commit/0bc8057f47c081b6e2c63e988b2b94a46deeb000", "message": "Make `define` fail when there's a duplicate / Add `of()`", "committedDate": "2020-02-22T04:35:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4NjAyMA==", "url": "https://github.com/line/armeria/pull/2523#discussion_r382886020", "bodyText": "Just to confirm is saturated cast the behavior change mentioned in the notes?\nLGTM", "author": "anuraaga", "createdAt": "2020-02-22T04:44:01Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/ArmeriaChannel.java", "diffHunk": "@@ -101,25 +94,27 @@\n         ctx.logBuilder().serializationFormat(serializationFormat);\n         ctx.logBuilder().deferRequestContent();\n         ctx.logBuilder().deferResponseContent();\n+\n+        final ClientOptions options = options();\n+        final int maxOutboundMessageSizeBytes = options.get(GrpcClientOptions.MAX_OUTBOUND_MESSAGE_SIZE_BYTES);\n+        final int maxInboundMessageSizeBytes = options.get(GrpcClientOptions.MAX_INBOUND_MESSAGE_SIZE_BYTES);\n+        final boolean unsafeWrapResponseBuffers = options.get(GrpcClientOptions.UNSAFE_WRAP_RESPONSE_BUFFERS);\n+\n         return new ArmeriaClientCall<>(\n                 ctx,\n                 params.endpointGroup(),\n                 httpClient,\n                 req,\n                 method,\n-                options().getOrElse(GrpcClientOptions.MAX_OUTBOUND_MESSAGE_SIZE_BYTES,\n-                                    ArmeriaMessageFramer.NO_MAX_OUTBOUND_MESSAGE_SIZE),\n-                options().getOrElse(\n-                        GrpcClientOptions.MAX_INBOUND_MESSAGE_SIZE_BYTES,\n-                        options().getOrElse(\n-                                ClientOption.MAX_RESPONSE_LENGTH,\n-                                (long) DEFAULT_MAX_INBOUND_MESSAGE_SIZE).intValue()),\n+                maxOutboundMessageSizeBytes,\n+                maxInboundMessageSizeBytes > 0 ? maxInboundMessageSizeBytes\n+                                               : Ints.saturatedCast(options.maxResponseLength()),", "originalCommit": "0bc8057f47c081b6e2c63e988b2b94a46deeb000", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4NjY1NA==", "url": "https://github.com/line/armeria/pull/2523#discussion_r382886654", "bodyText": "No. The previous behavior was this:\n                options().getOrElse(\n                        GrpcClientOptions.MAX_INBOUND_MESSAGE_SIZE_BYTES,\n                        options().getOrElse(\n                                ClientOption.MAX_RESPONSE_LENGTH,\n                                (long) DEFAULT_MAX_INBOUND_MESSAGE_SIZE).intValue()),\nWe were doing saturated cast already.\nThe difference is that DEFAULT_MAX_INBOUND_MESSAGE_SIZE is not used anymore.", "author": "trustin", "createdAt": "2020-02-22T04:57:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4NjAyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4NzIxMg==", "url": "https://github.com/line/armeria/pull/2523#discussion_r382887212", "bodyText": "Ah thanks for clarifying - the new options API opens up this nice tweak :)", "author": "anuraaga", "createdAt": "2020-02-22T05:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4NjAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNTcxOA==", "url": "https://github.com/line/armeria/pull/2523#discussion_r383125718", "bodyText": "It seems like the oldValue is used? so we need to remove @SuppressWarnings(\"unused\") and add null check?", "author": "minwoox", "createdAt": "2020-02-24T08:18:10Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/AbstractOption.java", "diffHunk": "@@ -15,26 +15,260 @@\n  */\n package com.linecorp.armeria.common.util;\n \n-import io.netty.util.AbstractConstant;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+\n+import com.linecorp.armeria.client.ClientOption;\n \n /**\n  * A configuration option.\n  *\n- * @param <T> the type of the value of the option\n+ * @param <T> the type of the option.\n+ * @param <U> the type of the option value holder.\n+ * @param <V> the type of the option value.\n  *\n  * @see AbstractOptionValue\n  * @see AbstractOptions\n  */\n-@SuppressWarnings(\"rawtypes\")\n-public abstract class AbstractOption<T> extends AbstractConstant {\n+public abstract class AbstractOption<\n+        T extends AbstractOption<T, U, V>,\n+        U extends AbstractOptionValue<U, T, V>,\n+        V> implements Comparable<AbstractOption<?, ?, ?>> {\n+\n+    private static final AtomicLong uniqueIdGenerator = new AtomicLong();\n+\n+    private static final Map<Class<?>, Pool> map = new MapMaker().weakKeys().makeMap();\n+\n+    /**\n+     * Returns all available options of the specified option type.\n+     *\n+     * @return the options which are instances of the specified {@code type}.\n+     */\n+    protected static <T extends Set<?>> T allOptions(Class<?> type) {\n+        requireNonNull(type, \"type\");\n+        final Pool pool = map.get(type);\n+        if (pool == null) {\n+            @SuppressWarnings(\"unchecked\")\n+            final T cast = (T) ImmutableSet.of();\n+            return cast;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        final T cast = (T) pool.getAll();\n+        return cast;\n+    }\n+\n+    /**\n+     * Returns the option of the specified option type and name.\n+     *\n+     * @return the option which is an instance of the specified {@code type} and\n+     *         which has the specified {@code name}.\n+     */\n+    protected static <T extends AbstractOption<?, ?, ?>> T of(Class<?> type, String name) {\n+        requireNonNull(type, \"type\");\n+        requireNonNull(name, \"name\");\n+\n+        final Pool pool = map.get(type);\n+        if (pool == null) {\n+            throw new NoSuchElementException(\n+                    '\\'' + type.getName() + '#' + name + \"' does not exist.\");\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        final T cast = (T) pool.get(name);\n+        return cast;\n+    }\n+\n+    /**\n+     * Defines a new option.\n+     *\n+     * @param type the type of the option, e.g. {@link ClientOption}.\n+     * @param name the name of the option, e.g. {@code \"RESPONSE_TIMEOUT_MILLIS\"}.\n+     * @param defaultValue the default value of the option.\n+     * @param optionFactory the {@link Factory} that creates a new option.\n+     * @param validator the {@link Function} which is used for validating ane normalizing an option value.\n+     * @param mergeFunction the {@link BiFunction} which is used for merging old and new option values.\n+     * @param <T> the type of the option.\n+     * @param <U> the type of the option value holder.\n+     * @param <V> the type of the option value.\n+     *\n+     * @return a new option instance.\n+     *\n+     * @throws IllegalStateException if an option with the specified name exists already.\n+     */\n+    protected static <T extends AbstractOption<T, U, V>, U extends AbstractOptionValue<U, T, V>, V>\n+    T define(Class<?> type, String name, V defaultValue,\n+             Factory<T, U, V> optionFactory, Function<V, V> validator, BiFunction<U, U, U> mergeFunction) {\n+\n+        requireNonNull(type, \"type\");\n+        requireNonNull(name, \"name\");\n+        requireNonNull(defaultValue, \"defaultValue\");\n+        requireNonNull(optionFactory, \"optionFactory\");\n+        requireNonNull(validator, \"validator\");\n+        requireNonNull(mergeFunction, \"mergeFunction\");\n+\n+        return map.computeIfAbsent(type, unused -> new Pool(type, optionFactory))\n+                  .define(name, defaultValue, validator, mergeFunction);\n+    }\n+\n+    private final long uniqueId;\n+    private final String name;\n+    private final V defaultValue;\n+    private final Function<V, V> validator;\n+    private final BiFunction<U, U, U> mergeFunction;\n \n     /**\n      * Creates a new instance.\n      *\n-     * @param id the integral ID of this option\n      * @param name the name of this option\n      */\n-    protected AbstractOption(int id, String name) {\n-        super(id, name);\n+    protected AbstractOption(String name, V defaultValue,\n+                             Function<V, V> validator, BiFunction<U, U, U> mergeFunction) {\n+        uniqueId = uniqueIdGenerator.getAndIncrement();\n+        this.name = requireNonNull(name, \"name\");\n+        this.defaultValue = requireNonNull(defaultValue, \"defaultValue\");\n+        this.validator = requireNonNull(validator, \"validator\");\n+        this.mergeFunction = requireNonNull(mergeFunction, \"mergeFunction\");\n+    }\n+\n+    /**\n+     * Returns the name of this option.\n+     */\n+    public String name() {\n+        return name;\n+    }\n+\n+    /**\n+     * Returns the default value of this option.\n+     */\n+    public V defaultValue() {\n+        return defaultValue;\n+    }\n+\n+    /**\n+     * Merges the specified new option value into the specified old option value.\n+     *\n+     * @param oldValue the old option value.\n+     * @param newValue the new option value.\n+     * @return the merged option value.\n+     */\n+    final U merge(@SuppressWarnings(\"unused\") U oldValue, U newValue) {", "originalCommit": "0bc8057f47c081b6e2c63e988b2b94a46deeb000", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0NzE2OA==", "url": "https://github.com/line/armeria/pull/2523#discussion_r383147168", "bodyText": "Oops! Cruft from the past :-)", "author": "trustin", "createdAt": "2020-02-24T09:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNTcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNjk0Mw==", "url": "https://github.com/line/armeria/pull/2523#discussion_r383126943", "bodyText": "Couldn't this validator be just Predicate or Consumer to make it simple?", "author": "minwoox", "createdAt": "2020-02-24T08:22:06Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/AbstractOption.java", "diffHunk": "@@ -15,26 +15,260 @@\n  */\n package com.linecorp.armeria.common.util;\n \n-import io.netty.util.AbstractConstant;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.MapMaker;\n+\n+import com.linecorp.armeria.client.ClientOption;\n \n /**\n  * A configuration option.\n  *\n- * @param <T> the type of the value of the option\n+ * @param <T> the type of the option.\n+ * @param <U> the type of the option value holder.\n+ * @param <V> the type of the option value.\n  *\n  * @see AbstractOptionValue\n  * @see AbstractOptions\n  */\n-@SuppressWarnings(\"rawtypes\")\n-public abstract class AbstractOption<T> extends AbstractConstant {\n+public abstract class AbstractOption<\n+        T extends AbstractOption<T, U, V>,\n+        U extends AbstractOptionValue<U, T, V>,\n+        V> implements Comparable<AbstractOption<?, ?, ?>> {\n+\n+    private static final AtomicLong uniqueIdGenerator = new AtomicLong();\n+\n+    private static final Map<Class<?>, Pool> map = new MapMaker().weakKeys().makeMap();\n+\n+    /**\n+     * Returns all available options of the specified option type.\n+     *\n+     * @return the options which are instances of the specified {@code type}.\n+     */\n+    protected static <T extends Set<?>> T allOptions(Class<?> type) {\n+        requireNonNull(type, \"type\");\n+        final Pool pool = map.get(type);\n+        if (pool == null) {\n+            @SuppressWarnings(\"unchecked\")\n+            final T cast = (T) ImmutableSet.of();\n+            return cast;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        final T cast = (T) pool.getAll();\n+        return cast;\n+    }\n+\n+    /**\n+     * Returns the option of the specified option type and name.\n+     *\n+     * @return the option which is an instance of the specified {@code type} and\n+     *         which has the specified {@code name}.\n+     */\n+    protected static <T extends AbstractOption<?, ?, ?>> T of(Class<?> type, String name) {\n+        requireNonNull(type, \"type\");\n+        requireNonNull(name, \"name\");\n+\n+        final Pool pool = map.get(type);\n+        if (pool == null) {\n+            throw new NoSuchElementException(\n+                    '\\'' + type.getName() + '#' + name + \"' does not exist.\");\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        final T cast = (T) pool.get(name);\n+        return cast;\n+    }\n+\n+    /**\n+     * Defines a new option.\n+     *\n+     * @param type the type of the option, e.g. {@link ClientOption}.\n+     * @param name the name of the option, e.g. {@code \"RESPONSE_TIMEOUT_MILLIS\"}.\n+     * @param defaultValue the default value of the option.\n+     * @param optionFactory the {@link Factory} that creates a new option.\n+     * @param validator the {@link Function} which is used for validating ane normalizing an option value.\n+     * @param mergeFunction the {@link BiFunction} which is used for merging old and new option values.\n+     * @param <T> the type of the option.\n+     * @param <U> the type of the option value holder.\n+     * @param <V> the type of the option value.\n+     *\n+     * @return a new option instance.\n+     *\n+     * @throws IllegalStateException if an option with the specified name exists already.\n+     */\n+    protected static <T extends AbstractOption<T, U, V>, U extends AbstractOptionValue<U, T, V>, V>\n+    T define(Class<?> type, String name, V defaultValue,\n+             Factory<T, U, V> optionFactory, Function<V, V> validator, BiFunction<U, U, U> mergeFunction) {\n+\n+        requireNonNull(type, \"type\");\n+        requireNonNull(name, \"name\");\n+        requireNonNull(defaultValue, \"defaultValue\");\n+        requireNonNull(optionFactory, \"optionFactory\");\n+        requireNonNull(validator, \"validator\");\n+        requireNonNull(mergeFunction, \"mergeFunction\");\n+\n+        return map.computeIfAbsent(type, unused -> new Pool(type, optionFactory))\n+                  .define(name, defaultValue, validator, mergeFunction);\n+    }\n+\n+    private final long uniqueId;\n+    private final String name;\n+    private final V defaultValue;\n+    private final Function<V, V> validator;\n+    private final BiFunction<U, U, U> mergeFunction;\n \n     /**\n      * Creates a new instance.\n      *\n-     * @param id the integral ID of this option\n      * @param name the name of this option\n      */\n-    protected AbstractOption(int id, String name) {\n-        super(id, name);\n+    protected AbstractOption(String name, V defaultValue,\n+                             Function<V, V> validator, BiFunction<U, U, U> mergeFunction) {", "originalCommit": "0bc8057f47c081b6e2c63e988b2b94a46deeb000", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0NzM3NA==", "url": "https://github.com/line/armeria/pull/2523#discussion_r383147374", "bodyText": "I did so because we may want to perform some sort of normalization during validation phase, e.g. normalizing a negative timeout value to 0 or -1.", "author": "trustin", "createdAt": "2020-02-24T09:14:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNjk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0ODA0MA==", "url": "https://github.com/line/armeria/pull/2523#discussion_r383148040", "bodyText": "Ah, I thought it just returns the original value. \ud83d\ude04\nThen, it's fine as it is.", "author": "minwoox", "createdAt": "2020-02-24T09:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyNjk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyODY2OQ==", "url": "https://github.com/line/armeria/pull/2523#discussion_r383128669", "bodyText": "nit: option?", "author": "minwoox", "createdAt": "2020-02-24T08:27:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientOptionValue.java", "diffHunk": "@@ -22,7 +22,7 @@\n  *\n  * @param <T> the type of the option value\n  */\n-public final class ClientOptionValue<T> extends AbstractOptionValue<ClientOption<T>, T> {\n+public final class ClientOptionValue<T> extends AbstractOptionValue<ClientOptionValue<T>, ClientOption<T>, T> {\n \n     ClientOptionValue(ClientOption<T> constant, T value) {", "originalCommit": "0bc8057f47c081b6e2c63e988b2b94a46deeb000", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTI5MA==", "url": "https://github.com/line/armeria/pull/2523#discussion_r383135290", "bodyText": "nit: ane", "author": "minwoox", "createdAt": "2020-02-24T08:45:54Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOption.java", "diffHunk": "@@ -93,101 +132,149 @@\n      * {@link InetSocketAddress}es.\n      */\n     public static final ClientFactoryOption<Function<? super EventLoopGroup,\n-            ? extends AddressResolverGroup<? extends InetSocketAddress>>>\n-            ADDRESS_RESOLVER_GROUP_FACTORY = valueOf(\"ADDRESS_RESOLVER_GROUP_FACTORY\");\n+            ? extends AddressResolverGroup<? extends InetSocketAddress>>> ADDRESS_RESOLVER_GROUP_FACTORY =\n+            define(\"ADDRESS_RESOLVER_GROUP_FACTORY\",\n+                   eventLoopGroup -> new DnsResolverGroupBuilder().build(eventLoopGroup));\n \n     /**\n      * The HTTP/2 <a href=\"https://tools.ietf.org/html/rfc7540#section-6.9.2\">initial connection flow-control\n      * window size</a>.\n      */\n     public static final ClientFactoryOption<Integer> HTTP2_INITIAL_CONNECTION_WINDOW_SIZE =\n-            valueOf(\"HTTP2_INITIAL_CONNECTION_WINDOW_SIZE\");\n+            define(\"HTTP2_INITIAL_CONNECTION_WINDOW_SIZE\", Flags.defaultHttp2InitialConnectionWindowSize());\n \n     /**\n      * The <a href=\"https://tools.ietf.org/html/rfc7540#section-6.5.2\">SETTINGS_INITIAL_WINDOW_SIZE</a>\n      * for HTTP/2 stream-level flow control.\n      */\n     public static final ClientFactoryOption<Integer> HTTP2_INITIAL_STREAM_WINDOW_SIZE =\n-            valueOf(\"HTTP2_INITIAL_STREAM_WINDOW_SIZE\");\n+            define(\"HTTP2_INITIAL_STREAM_WINDOW_SIZE\", Flags.defaultHttp2InitialStreamWindowSize());\n \n     /**\n      * The <a href=\"https://tools.ietf.org/html/rfc7540#section-6.5.2\">SETTINGS_MAX_FRAME_SIZE</a>\n      * that indicates the size of the largest frame payload that this client is willing to receive.\n      */\n     public static final ClientFactoryOption<Integer> HTTP2_MAX_FRAME_SIZE =\n-            valueOf(\"HTTP2_MAX_FRAME_SIZE\");\n+            define(\"HTTP2_MAX_FRAME_SIZE\", Flags.defaultHttp2MaxFrameSize());\n \n     /**\n      * The HTTP/2 <a href=\"https://tools.ietf.org/html/rfc7540#section-6.5.2\">SETTINGS_MAX_HEADER_LIST_SIZE</a>\n      * that indicates the maximum size of header list that the client is prepared to accept, in octets.\n      */\n     public static final ClientFactoryOption<Long> HTTP2_MAX_HEADER_LIST_SIZE =\n-            valueOf(\"HTTP2_MAX_HEADER_LIST_SIZE\");\n+            define(\"HTTP2_MAX_HEADER_LIST_SIZE\", Flags.defaultHttp2MaxHeaderListSize());\n \n     /**\n      * The maximum length of an HTTP/1 response initial line.\n      */\n     public static final ClientFactoryOption<Integer> HTTP1_MAX_INITIAL_LINE_LENGTH =\n-            valueOf(\"HTTP1_MAX_INITIAL_LINE_LENGTH\");\n+            define(\"HTTP1_MAX_INITIAL_LINE_LENGTH\", Flags.defaultHttp1MaxInitialLineLength());\n \n     /**\n      * The maximum length of all headers in an HTTP/1 response.\n      */\n-    public static final ClientFactoryOption<Integer> HTTP1_MAX_HEADER_SIZE = valueOf(\"HTTP1_MAX_HEADER_SIZE\");\n+    public static final ClientFactoryOption<Integer> HTTP1_MAX_HEADER_SIZE =\n+            define(\"HTTP1_MAX_HEADER_SIZE\", Flags.defaultHttp1MaxHeaderSize());\n \n     /**\n      * The maximum length of each chunk in an HTTP/1 response content.\n      */\n-    public static final ClientFactoryOption<Integer> HTTP1_MAX_CHUNK_SIZE = valueOf(\"HTTP1_MAX_CHUNK_SIZE\");\n+    public static final ClientFactoryOption<Integer> HTTP1_MAX_CHUNK_SIZE =\n+            define(\"HTTP1_MAX_CHUNK_SIZE\", Flags.defaultHttp1MaxChunkSize());\n \n     /**\n      * The idle timeout of a socket connection in milliseconds.\n      */\n-    public static final ClientFactoryOption<Long> IDLE_TIMEOUT_MILLIS = valueOf(\"IDLE_TIMEOUT_MILLIS\");\n+    public static final ClientFactoryOption<Long> IDLE_TIMEOUT_MILLIS =\n+            define(\"IDLE_TIMEOUT_MILLIS\", Flags.defaultClientIdleTimeoutMillis());\n \n     /**\n      * Whether to send an HTTP/2 preface string instead of an HTTP/1 upgrade request to negotiate\n      * the protocol version of a cleartext HTTP connection.\n      */\n-    public static final ClientFactoryOption<Boolean> USE_HTTP2_PREFACE = valueOf(\"USE_HTTP2_PREFACE\");\n+    public static final ClientFactoryOption<Boolean> USE_HTTP2_PREFACE =\n+            define(\"USE_HTTP2_PREFACE\", Flags.defaultUseHttp2Preface());\n \n     /**\n      * Whether to use <a href=\"https://en.wikipedia.org/wiki/HTTP_pipelining\">HTTP pipelining</a> for\n      * HTTP/1 connections.\n      */\n-    public static final ClientFactoryOption<Boolean> USE_HTTP1_PIPELINING = valueOf(\"USE_HTTP1_PIPELINING\");\n+    public static final ClientFactoryOption<Boolean> USE_HTTP1_PIPELINING =\n+            define(\"USE_HTTP1_PIPELINING\", Flags.defaultUseHttp1Pipelining());\n \n     /**\n      * The listener which is notified on a connection pool event.\n      */\n     public static final ClientFactoryOption<ConnectionPoolListener> CONNECTION_POOL_LISTENER =\n-            valueOf(\"CONNECTION_POOL_LISTENER\");\n+            define(\"CONNECTION_POOL_LISTENER\", ConnectionPoolListener.noop());\n \n     /**\n      * The {@link MeterRegistry} which collects various stats.\n      */\n-    public static final ClientFactoryOption<MeterRegistry> METER_REGISTRY = valueOf(\"METER_REGISTRY\");\n+    public static final ClientFactoryOption<MeterRegistry> METER_REGISTRY =\n+            define(\"METER_REGISTRY\", Metrics.globalRegistry);\n \n     /**\n-     * Returns the {@link ClientFactoryOption} of the specified name.\n+     * Returns the all available {@link ClientFactoryOption}s.\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> ClientFactoryOption<T> valueOf(String name) {\n-        return (ClientFactoryOption<T>) pool.valueOf(name);\n+    public static Set<ClientFactoryOption<?>> allOptions() {\n+        return allOptions(ClientFactoryOption.class);\n     }\n \n     /**\n-     * Creates a new {@link ClientFactoryOption} of the specified unique {@code name}.\n+     * Returns the {@link ClientFactoryOption} with the specified {@code name}.\n+     *\n+     * @throws NoSuchElementException if there's no such option defined.\n      */\n-    private ClientFactoryOption(int id, String name) {\n-        super(id, name);\n+    public static ClientFactoryOption<?> of(String name) {\n+        return of(ClientFactoryOption.class, name);\n     }\n \n     /**\n-     * Creates a new value of this option.\n+     * Defines a new {@link ClientFactoryOption} of the specified name and default value.\n+     *\n+     * @param name the name of the option.\n+     * @param defaultValue the default value of the option, which will be used when unspecified.\n+     *\n+     * @throws IllegalStateException if an option with the specified name exists already.\n      */\n-    public ClientFactoryOptionValue<T> newValue(T value) {\n-        requireNonNull(value, \"value\");\n+    public static <T> ClientFactoryOption<T> define(String name, T defaultValue) {\n+        return define(name, defaultValue, Function.identity(), (oldValue, newValue) -> newValue);\n+    }\n+\n+    /**\n+     * Defines a new {@link ClientFactoryOption} of the specified name, default value and merge function.\n+     *\n+     * @param name the name of the option.\n+     * @param defaultValue the default value of the option, which will be used when unspecified.\n+     * @param validator the {@link Function} which is used for validating ane normalizing an option value.", "originalCommit": "0bc8057f47c081b6e2c63e988b2b94a46deeb000", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0ODAyNA==", "url": "https://github.com/line/armeria/pull/2523#discussion_r383148024", "bodyText": "Eagle eyes! \ud83e\udd85\ud83d\udc41", "author": "ikhoon", "createdAt": "2020-02-24T09:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzODExMg==", "url": "https://github.com/line/armeria/pull/2523#discussion_r383138112", "bodyText": "It seems like the second sentence is vague and useless so we have to remove it. \ud83e\udd14", "author": "minwoox", "createdAt": "2020-02-24T08:53:07Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientOption.java", "diffHunk": "@@ -87,51 +91,137 @@\n     @Deprecated\n     public static final ClientOption<Long> DEFAULT_MAX_RESPONSE_LENGTH = MAX_RESPONSE_LENGTH;\n \n+    private static final List<AsciiString> BLACKLISTED_HEADER_NAMES = ImmutableList.of(\n+            HttpHeaderNames.CONNECTION,\n+            HttpHeaderNames.HOST,\n+            HttpHeaderNames.HTTP2_SETTINGS,\n+            HttpHeaderNames.METHOD,\n+            HttpHeaderNames.PATH,\n+            HttpHeaderNames.SCHEME,\n+            HttpHeaderNames.STATUS,\n+            HttpHeaderNames.TRANSFER_ENCODING,\n+            HttpHeaderNames.UPGRADE,\n+            ArmeriaHttpUtil.HEADER_NAME_KEEP_ALIVE,\n+            ArmeriaHttpUtil.HEADER_NAME_PROXY_CONNECTION,\n+            ExtensionHeaderNames.PATH.text(),\n+            ExtensionHeaderNames.SCHEME.text(),\n+            ExtensionHeaderNames.STREAM_DEPENDENCY_ID.text(),\n+            ExtensionHeaderNames.STREAM_ID.text(),\n+            ExtensionHeaderNames.STREAM_PROMISE_ID.text());\n+\n     /**\n      * The additional HTTP headers to send with requests. Used only when the underlying\n      * {@link SessionProtocol} is HTTP.", "originalCommit": "0bc8057f47c081b6e2c63e988b2b94a46deeb000", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0NjY2Mg==", "url": "https://github.com/line/armeria/pull/2523#discussion_r383146662", "bodyText": "Indeed.", "author": "trustin", "createdAt": "2020-02-24T09:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzODExMg=="}], "type": "inlineReview"}, {"oid": "6f76de3d4df18ee2fd1b6634a21ad1f997f309f0", "url": "https://github.com/line/armeria/commit/6f76de3d4df18ee2fd1b6634a21ad1f997f309f0", "message": "Address the comments from @minwoox", "committedDate": "2020-02-24T09:12:33Z", "type": "commit"}, {"oid": "4bf39772783fef9a7d08ba238e456aeeaceacf0e", "url": "https://github.com/line/armeria/commit/4bf39772783fef9a7d08ba238e456aeeaceacf0e", "message": "Checkstyle", "committedDate": "2020-02-24T09:25:30Z", "type": "commit"}]}