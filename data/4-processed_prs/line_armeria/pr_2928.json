{"pr_number": 2928, "pr_title": "Move `Client(Factory)Option.CONSTANT` to `Client(Factory)Options`", "pr_createdAt": "2020-07-21T09:01:11Z", "pr_url": "https://github.com/line/armeria/pull/2928", "timeline": [{"oid": "007dfe7a58bad9913281fedf515365192316a67d", "url": "https://github.com/line/armeria/commit/007dfe7a58bad9913281fedf515365192316a67d", "message": "Move `Client(Factory)Option.CONSTANT` to `Client(Factory)Options`\n\nMotivation:\n\n`*Options` seems to be a better place to host constants because it's\nmore consistent with other constant classes such as `HttpHeaderNames`\nand `GrpcClientOptions`.\n\nModifications:\n\n- Move all constants in `Client(Factory)Option` to\n  `Client(Factory)Options` and deprecate the old ones.\n\nResult:\n\n- More consistency\n  - A user gets the core options from `ClientOptions` and gRPC options\n    from `GrpcClientOptions`.\n- Closes #2917", "committedDate": "2020-07-21T08:57:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1OTc2Mg==", "url": "https://github.com/line/armeria/pull/2928#discussion_r457959762", "bodyText": "nit: Add blank line after 193 line?", "author": "ikhoon", "createdAt": "2020-07-21T09:24:18Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "diffHunk": "@@ -42,6 +50,177 @@\n public final class ClientFactoryOptions\n         extends AbstractOptions<ClientFactoryOption<Object>, ClientFactoryOptionValue<Object>> {\n \n+    /**\n+     * The worker {@link EventLoopGroup}.\n+     */\n+    public static final ClientFactoryOption<EventLoopGroup> WORKER_GROUP =\n+            ClientFactoryOption.define(\"WORKER_GROUP\", CommonPools.workerGroup());\n+\n+    /**\n+     * Whether to shut down the worker {@link EventLoopGroup} when the {@link ClientFactory} is closed.\n+     */\n+    public static final ClientFactoryOption<Boolean> SHUTDOWN_WORKER_GROUP_ON_CLOSE =\n+            ClientFactoryOption.define(\"SHUTDOWN_WORKER_GROUP_ON_CLOSE\", false);\n+\n+    /**\n+     * The factory that creates an {@link EventLoopScheduler} which is responsible for assigning an\n+     * {@link EventLoop} to handle a connection to the specified {@link Endpoint}.\n+     */\n+    public static final ClientFactoryOption<Function<? super EventLoopGroup, ? extends EventLoopScheduler>>\n+            EVENT_LOOP_SCHEDULER_FACTORY = ClientFactoryOption.define(\n+            \"EVENT_LOOP_SCHEDULER_FACTORY\",\n+            eventLoopGroup -> new DefaultEventLoopScheduler(eventLoopGroup, 0, 0, ImmutableList.of()));\n+\n+    /**\n+     * The {@link Consumer} which can arbitrarily configure the {@link SslContextBuilder} that will be\n+     * applied to the SSL session.\n+     */\n+    public static final ClientFactoryOption<Consumer<? super SslContextBuilder>> TLS_CUSTOMIZER =\n+            ClientFactoryOption.define(\"TLS_CUSTOMIZER\", b -> { /* no-op */ });\n+\n+    /**\n+     * The factory that creates an {@link AddressResolverGroup} which resolves remote addresses into\n+     * {@link InetSocketAddress}es.\n+     */\n+    public static final ClientFactoryOption<Function<? super EventLoopGroup,\n+            ? extends AddressResolverGroup<? extends InetSocketAddress>>> ADDRESS_RESOLVER_GROUP_FACTORY =\n+            ClientFactoryOption.define(\"ADDRESS_RESOLVER_GROUP_FACTORY\",\n+                                       eventLoopGroup -> new DnsResolverGroupBuilder().build(eventLoopGroup));\n+\n+    /**\n+     * The HTTP/2 <a href=\"https://tools.ietf.org/html/rfc7540#section-6.9.2\">initial connection flow-control\n+     * window size</a>.\n+     */\n+    public static final ClientFactoryOption<Integer> HTTP2_INITIAL_CONNECTION_WINDOW_SIZE =\n+            ClientFactoryOption.define(\"HTTP2_INITIAL_CONNECTION_WINDOW_SIZE\",\n+                                       Flags.defaultHttp2InitialConnectionWindowSize());\n+\n+    /**\n+     * The <a href=\"https://tools.ietf.org/html/rfc7540#section-6.5.2\">SETTINGS_INITIAL_WINDOW_SIZE</a>\n+     * for HTTP/2 stream-level flow control.\n+     */\n+    public static final ClientFactoryOption<Integer> HTTP2_INITIAL_STREAM_WINDOW_SIZE =\n+            ClientFactoryOption.define(\"HTTP2_INITIAL_STREAM_WINDOW_SIZE\",\n+                                       Flags.defaultHttp2InitialStreamWindowSize());\n+\n+    /**\n+     * The <a href=\"https://tools.ietf.org/html/rfc7540#section-6.5.2\">SETTINGS_MAX_FRAME_SIZE</a>\n+     * that indicates the size of the largest frame payload that this client is willing to receive.\n+     */\n+    public static final ClientFactoryOption<Integer> HTTP2_MAX_FRAME_SIZE =\n+            ClientFactoryOption.define(\"HTTP2_MAX_FRAME_SIZE\", Flags.defaultHttp2MaxFrameSize());\n+\n+    /**\n+     * The HTTP/2 <a href=\"https://tools.ietf.org/html/rfc7540#section-6.5.2\">SETTINGS_MAX_HEADER_LIST_SIZE</a>\n+     * that indicates the maximum size of header list that the client is prepared to accept, in octets.\n+     */\n+    public static final ClientFactoryOption<Long> HTTP2_MAX_HEADER_LIST_SIZE =\n+            ClientFactoryOption.define(\"HTTP2_MAX_HEADER_LIST_SIZE\", Flags.defaultHttp2MaxHeaderListSize());\n+\n+    /**\n+     * The maximum length of an HTTP/1 response initial line.\n+     */\n+    public static final ClientFactoryOption<Integer> HTTP1_MAX_INITIAL_LINE_LENGTH =\n+            ClientFactoryOption.define(\"HTTP1_MAX_INITIAL_LINE_LENGTH\",\n+                                       Flags.defaultHttp1MaxInitialLineLength());\n+\n+    /**\n+     * The maximum length of all headers in an HTTP/1 response.\n+     */\n+    public static final ClientFactoryOption<Integer> HTTP1_MAX_HEADER_SIZE =\n+            ClientFactoryOption.define(\"HTTP1_MAX_HEADER_SIZE\", Flags.defaultHttp1MaxHeaderSize());\n+\n+    /**\n+     * The maximum length of each chunk in an HTTP/1 response content.\n+     */\n+    public static final ClientFactoryOption<Integer> HTTP1_MAX_CHUNK_SIZE =\n+            ClientFactoryOption.define(\"HTTP1_MAX_CHUNK_SIZE\", Flags.defaultHttp1MaxChunkSize());\n+\n+    /**\n+     * The idle timeout of a socket connection in milliseconds.\n+     */\n+    public static final ClientFactoryOption<Long> IDLE_TIMEOUT_MILLIS =\n+            ClientFactoryOption.define(\"IDLE_TIMEOUT_MILLIS\", Flags.defaultClientIdleTimeoutMillis());\n+\n+    /**\n+     * The PING interval in milliseconds.\n+     * When neither read nor write was performed for the specified period of time,\n+     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1.\n+     */\n+    public static final ClientFactoryOption<Long> PING_INTERVAL_MILLIS =\n+            ClientFactoryOption.define(\"PING_INTERVAL_MILLIS\", Flags.defaultPingIntervalMillis());\n+\n+    /**\n+     * Whether to send an HTTP/2 preface string instead of an HTTP/1 upgrade request to negotiate\n+     * the protocol version of a cleartext HTTP connection.\n+     */\n+    public static final ClientFactoryOption<Boolean> USE_HTTP2_PREFACE =\n+            ClientFactoryOption.define(\"USE_HTTP2_PREFACE\", Flags.defaultUseHttp2Preface());\n+\n+    /**\n+     * Whether to use <a href=\"https://en.wikipedia.org/wiki/HTTP_pipelining\">HTTP pipelining</a> for\n+     * HTTP/1 connections.\n+     */\n+    public static final ClientFactoryOption<Boolean> USE_HTTP1_PIPELINING =\n+            ClientFactoryOption.define(\"USE_HTTP1_PIPELINING\", Flags.defaultUseHttp1Pipelining());\n+\n+    /**\n+     * The listener which is notified on a connection pool event.\n+     */\n+    public static final ClientFactoryOption<ConnectionPoolListener> CONNECTION_POOL_LISTENER =\n+            ClientFactoryOption.define(\"CONNECTION_POOL_LISTENER\", ConnectionPoolListener.noop());\n+\n+    /**\n+     * The {@link MeterRegistry} which collects various stats.\n+     */\n+    public static final ClientFactoryOption<MeterRegistry> METER_REGISTRY =\n+            ClientFactoryOption.define(\"METER_REGISTRY\", Metrics.globalRegistry);\n+\n+    /**\n+     * The {@link ProxyConfigSelector} which determines the {@link ProxyConfig} to be used.\n+     */\n+    public static final ClientFactoryOption<ProxyConfigSelector> PROXY_CONFIG_SELECTOR =\n+            ClientFactoryOption.define(\"PROXY_CONFIG_SELECTOR\", ProxyConfigSelector.of(ProxyConfig.direct()));\n+\n+    // Do not accept 1) the options that may break Armeria and 2) the deprecated options.\n+    @SuppressWarnings(\"deprecation\")\n+    private static final Set<ChannelOption<?>> PROHIBITED_SOCKET_OPTIONS = ImmutableSet.of(\n+            ChannelOption.ALLOW_HALF_CLOSURE, ChannelOption.AUTO_READ,\n+            ChannelOption.AUTO_CLOSE, ChannelOption.MAX_MESSAGES_PER_READ,\n+            ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, ChannelOption.WRITE_BUFFER_LOW_WATER_MARK,\n+            EpollChannelOption.EPOLL_MODE);\n+    /**", "originalCommit": "007dfe7a58bad9913281fedf515365192316a67d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d24b8648153047f44ab2591b837f67b76052e013", "url": "https://github.com/line/armeria/commit/d24b8648153047f44ab2591b837f67b76052e013", "message": "nit", "committedDate": "2020-07-21T09:59:13Z", "type": "commit"}]}