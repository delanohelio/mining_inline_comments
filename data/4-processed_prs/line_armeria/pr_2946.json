{"pr_number": 2946, "pr_title": "Fix a bug where grpc-web-text add line-feed when base64 encoding", "pr_createdAt": "2020-07-30T04:48:45Z", "pr_url": "https://github.com/line/armeria/pull/2946", "timeline": [{"oid": "d4ef0cbcedf3eae346a0e4232afcf35a6e64ff30", "url": "https://github.com/line/armeria/commit/d4ef0cbcedf3eae346a0e4232afcf35a6e64ff30", "message": "Follow up for #2938\nAddress the comments from @anuraaga", "committedDate": "2020-07-30T04:46:21Z", "type": "commit"}, {"oid": "fcac56aab26df36dbe011968c69ac9ada58a66e1", "url": "https://github.com/line/armeria/commit/fcac56aab26df36dbe011968c69ac9ada58a66e1", "message": "Do not add line-feed", "committedDate": "2020-07-30T05:09:25Z", "type": "commit"}, {"oid": "4064648bbc58d26eeef4d3daed7a288260dd05c6", "url": "https://github.com/line/armeria/commit/4064648bbc58d26eeef4d3daed7a288260dd05c6", "message": "Update test", "committedDate": "2020-07-30T06:06:04Z", "type": "commit"}, {"oid": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5", "url": "https://github.com/line/armeria/commit/5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5", "message": "Update", "committedDate": "2020-07-30T06:07:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzYwNg==", "url": "https://github.com/line/armeria/pull/2946#discussion_r462833606", "bodyText": "Could be decodedByte < EQUALS_SIGN_ENC ?", "author": "trustin", "createdAt": "2020-07-30T08:25:33Z", "path": "grpc-protocol/src/main/java/com/linecorp/armeria/common/grpc/protocol/Base64Decoder.java", "diffHunk": "@@ -125,17 +123,11 @@ private int decodedBufferSize(int len) {\n     @Override\n     public boolean process(byte value) throws Exception {\n         final byte decodedByte = DECODABET[value & 0xFF];\n-        if (decodedByte < WHITE_SPACE_ENC) {\n+        if (decodedByte <= WHITE_SPACE_ENC) {", "originalCommit": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkyMzYxOA==", "url": "https://github.com/line/armeria/pull/2946#discussion_r462923618", "bodyText": "Fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-07-30T11:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzg1Ng==", "url": "https://github.com/line/armeria/pull/2946#discussion_r462833856", "bodyText": "Could use @CsvSource instead?", "author": "trustin", "createdAt": "2020-07-30T08:26:02Z", "path": "grpc-protocol/src/test/java/com/linecorp/armeria/common/grpc/protocol/Base64DecoderTest.java", "diffHunk": "@@ -19,63 +19,65 @@\n \n import java.nio.charset.Charset;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n-import java.util.Random;\n+import java.util.stream.Stream;\n \n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.base64.Base64;\n \n class Base64DecoderTest {\n \n-    private static final ByteBuf[] EMPTY_BYTE_BUF = new ByteBuf[0];\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decode(String expected, String encoded) {\n+        final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(encoded.getBytes()));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected);\n+        decoded.release();\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeConcatenatedBufs(String expected, String encoded) {\n+        final ByteBuf buf1 = Unpooled.wrappedBuffer(encoded.getBytes());\n+        final ByteBuf buf2 = buf1.retainedDuplicate();\n \n-    @Test\n-    void decodeConcatenatedBufsWithPadding() {\n-        final String str = \"abcd\"; // YWJjZA==\n-        final ByteBuf buf = Unpooled.wrappedBuffer(str.getBytes());\n-        final ByteBuf encoded1 = Base64.encode(buf);\n-        buf.readerIndex(0);\n-        final ByteBuf encoded2 = Base64.encode(buf);\n-        final ByteBuf concatenated = Unpooled.wrappedBuffer(encoded1, encoded2); // YWJjZA==YWJjZA==\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decoded = base64Decoder.decode(concatenated);\n-        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(\"abcdabcd\");\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(buf1, buf2));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected + expected);\n         decoded.release();\n     }\n \n-    @Test\n-    void decodeMultipleEncodedBytes() {\n-        final String str = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz1234567890\";\n-        final byte[] bytes = str.getBytes();\n-        final List<ByteBuf> fragments = fragmentRandomly(bytes);\n-        final int half = fragments.size() / 2;\n-        final ByteBuf first =\n-                Unpooled.wrappedBuffer(fragments.subList(0, half).toArray(EMPTY_BYTE_BUF));\n-        final ByteBuf second =\n-                Unpooled.wrappedBuffer(fragments.subList(half, fragments.size()).toArray(EMPTY_BYTE_BUF));\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeEachByteSeparately(String expected, String encoded) {\n+        final ByteBuf buf = Unpooled.wrappedBuffer(encoded.getBytes());\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decodedFirst = base64Decoder.decode(first);\n-        final ByteBuf decodedSecond = base64Decoder.decode(second);\n-        assertThat(Unpooled.wrappedBuffer(decodedFirst, decodedSecond).toString(Charset.defaultCharset()))\n-                .isEqualTo(str);\n-        decodedFirst.release();\n-        decodedSecond.release();\n+        final int readableBytes = buf.readableBytes();\n+        final List<ByteBuf> bufs = new ArrayList<>();\n+        for (int i = 0; i < readableBytes; i++) {\n+            bufs.add(base64Decoder.decode(buf.retainedSlice(i, 1)));\n+        }\n+        buf.release();\n+        final ByteBuf wrappedBuffer = Unpooled.wrappedBuffer(bufs.toArray(new ByteBuf[0]));\n+        assertThat(wrappedBuffer.toString(Charset.defaultCharset())).isEqualTo(expected);\n+        wrappedBuffer.release();\n     }\n \n-    private static List<ByteBuf> fragmentRandomly(byte[] bytes) {\n-        final List<ByteBuf> fragments = new ArrayList<>();\n-        for (int i = 0; i < bytes.length;) {\n-            final int to = Math.min(bytes.length,\n-                                    new Random().nextInt(5) + 1 + i); // One byte is selected at least.\n-            final ByteBuf encoded = Base64.encode(Unpooled.wrappedBuffer(Arrays.copyOfRange(bytes, i, to)));\n-            fragments.add(encoded);\n-            i = to;\n+    private static final class EncodedStringProvider implements ArgumentsProvider {\n+\n+        @Override\n+        public Stream<? extends Arguments> provideArguments(ExtensionContext context) throws Exception {\n+            return Stream.of(Arguments.of(\"abcde\", \"YWJjZGU=\"),\n+                             Arguments.of(\"123456789\", \"MTIzNDU2Nzg5\"),\n+                             Arguments.of(\"~!@#$%^&*()-_\", \"fiFAIyQlXiYqKCktXw==\"));", "originalCommit": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkyMzU1OQ==", "url": "https://github.com/line/armeria/pull/2946#discussion_r462923559", "bodyText": "Fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-07-30T11:11:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzNTEwMg==", "url": "https://github.com/line/armeria/pull/2946#discussion_r462835102", "bodyText": "Could be simplified into:\nwhile (buf.isReadable()) {\n    bufs.add(base64Decoder.decode(buf.readRetainedSlice(1)));\n}", "author": "trustin", "createdAt": "2020-07-30T08:28:02Z", "path": "grpc-protocol/src/test/java/com/linecorp/armeria/common/grpc/protocol/Base64DecoderTest.java", "diffHunk": "@@ -19,63 +19,65 @@\n \n import java.nio.charset.Charset;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n-import java.util.Random;\n+import java.util.stream.Stream;\n \n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.PooledByteBufAllocator;\n import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.base64.Base64;\n \n class Base64DecoderTest {\n \n-    private static final ByteBuf[] EMPTY_BYTE_BUF = new ByteBuf[0];\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decode(String expected, String encoded) {\n+        final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(encoded.getBytes()));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected);\n+        decoded.release();\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeConcatenatedBufs(String expected, String encoded) {\n+        final ByteBuf buf1 = Unpooled.wrappedBuffer(encoded.getBytes());\n+        final ByteBuf buf2 = buf1.retainedDuplicate();\n \n-    @Test\n-    void decodeConcatenatedBufsWithPadding() {\n-        final String str = \"abcd\"; // YWJjZA==\n-        final ByteBuf buf = Unpooled.wrappedBuffer(str.getBytes());\n-        final ByteBuf encoded1 = Base64.encode(buf);\n-        buf.readerIndex(0);\n-        final ByteBuf encoded2 = Base64.encode(buf);\n-        final ByteBuf concatenated = Unpooled.wrappedBuffer(encoded1, encoded2); // YWJjZA==YWJjZA==\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decoded = base64Decoder.decode(concatenated);\n-        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(\"abcdabcd\");\n+        final ByteBuf decoded = base64Decoder.decode(Unpooled.wrappedBuffer(buf1, buf2));\n+        assertThat(decoded.toString(Charset.defaultCharset())).isEqualTo(expected + expected);\n         decoded.release();\n     }\n \n-    @Test\n-    void decodeMultipleEncodedBytes() {\n-        final String str = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz1234567890\";\n-        final byte[] bytes = str.getBytes();\n-        final List<ByteBuf> fragments = fragmentRandomly(bytes);\n-        final int half = fragments.size() / 2;\n-        final ByteBuf first =\n-                Unpooled.wrappedBuffer(fragments.subList(0, half).toArray(EMPTY_BYTE_BUF));\n-        final ByteBuf second =\n-                Unpooled.wrappedBuffer(fragments.subList(half, fragments.size()).toArray(EMPTY_BYTE_BUF));\n+    @ParameterizedTest\n+    @ArgumentsSource(EncodedStringProvider.class)\n+    void decodeEachByteSeparately(String expected, String encoded) {\n+        final ByteBuf buf = Unpooled.wrappedBuffer(encoded.getBytes());\n         final Base64Decoder base64Decoder = new Base64Decoder(PooledByteBufAllocator.DEFAULT);\n-        final ByteBuf decodedFirst = base64Decoder.decode(first);\n-        final ByteBuf decodedSecond = base64Decoder.decode(second);\n-        assertThat(Unpooled.wrappedBuffer(decodedFirst, decodedSecond).toString(Charset.defaultCharset()))\n-                .isEqualTo(str);\n-        decodedFirst.release();\n-        decodedSecond.release();\n+        final int readableBytes = buf.readableBytes();\n+        final List<ByteBuf> bufs = new ArrayList<>();\n+        for (int i = 0; i < readableBytes; i++) {\n+            bufs.add(base64Decoder.decode(buf.retainedSlice(i, 1)));\n+        }", "originalCommit": "5ea27ef3f3938ae69d45de0f6c1e8cfeb8a480c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkyMzg0OA==", "url": "https://github.com/line/armeria/pull/2946#discussion_r462923848", "bodyText": "Fixed. \ud83d\ude09  Didn't know that ByteBuf has this API. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-07-30T11:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzNTEwMg=="}], "type": "inlineReview"}, {"oid": "8d6dc1b9af3aa5177fbfa170a173ba2b981dd3db", "url": "https://github.com/line/armeria/commit/8d6dc1b9af3aa5177fbfa170a173ba2b981dd3db", "message": "Address comments by @trustin", "committedDate": "2020-07-30T11:11:26Z", "type": "commit"}, {"oid": "b91280aabf814287ffc8cf26020b41d2e0a8f7f3", "url": "https://github.com/line/armeria/commit/b91280aabf814287ffc8cf26020b41d2e0a8f7f3", "message": "Address the comment by @trustin", "committedDate": "2020-07-30T11:37:25Z", "type": "commit"}, {"oid": "79f03795ff247fd720a31ef4243c60c088d11729", "url": "https://github.com/line/armeria/commit/79f03795ff247fd720a31ef4243c60c088d11729", "message": "Add more tests", "committedDate": "2020-07-31T03:14:46Z", "type": "commit"}]}