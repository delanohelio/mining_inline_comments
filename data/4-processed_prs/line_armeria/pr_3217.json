{"pr_number": 3217, "pr_title": "Add ramping up weighted round robin strategy", "pr_createdAt": "2020-12-11T05:05:31Z", "pr_url": "https://github.com/line/armeria/pull/3217", "timeline": [{"oid": "9d84df06cdb94cbc58db0ba4946897faa252e2f0", "url": "https://github.com/line/armeria/commit/9d84df06cdb94cbc58db0ba4946897faa252e2f0", "message": "Add ramping up weighted round robin strategy\nMotivation:\nRelated: #1757\nIt will be nice if we have a strategy `EndpointSelectionStrategy` which increases weight gradually\nfor the newly added `Endpoint`s.\n\nModifications:\n- Add `EndpointSelectionStrategy.rampingUp()` and `builderForRampingUp()`\n  - The strategy increase the weights of newly added `Endpoint`s using `EndpointWeightTransition`\n  - The weight is ramped `totalSteps` times every `rampingUpInterval`.\n  - Endpoints added within the same `updatingTaskWindow` are updated together.\n\nResult:\n- Close #1757\n- You can now use the `EndpointSelectionStrategy` which increases weight gradually\n  for the newly added `Endpoint`s.", "committedDate": "2020-12-11T05:04:51Z", "type": "commit"}, {"oid": "db6ccefe2856f3e9427a5920e5e4d1f302452454", "url": "https://github.com/line/armeria/commit/db6ccefe2856f3e9427a5920e5e4d1f302452454", "message": "Use AtomicInteger instead fo LongAdder", "committedDate": "2020-12-11T05:36:33Z", "type": "commit"}, {"oid": "1a967a89d7c07b652950bcd071bb1b44f446f6c1", "url": "https://github.com/line/armeria/commit/1a967a89d7c07b652950bcd071bb1b44f446f6c1", "message": "Add final", "committedDate": "2020-12-11T06:14:38Z", "type": "commit"}, {"oid": "5d85c555c02e098a295538a6d9766b409e0f8d96", "url": "https://github.com/line/armeria/commit/5d85c555c02e098a295538a6d9766b409e0f8d96", "message": "Rename", "committedDate": "2020-12-13T05:30:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyNzc5OA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542127798", "bodyText": "is ramping up -> ramps up", "author": "trustin", "createdAt": "2020-12-14T05:49:24Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/EndpointSelectionStrategy.java", "diffHunk": "@@ -48,6 +50,24 @@ static EndpointSelectionStrategy roundRobin() {\n         return RoundRobinStrategy.INSTANCE;\n     }\n \n+    /**\n+     * Returns a weighted round-robin strategy which is ramping up the weight of the newly added", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyODMxMQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542128311", "bodyText": "ramped up by 10 percent every 2 seconds up to 100 percent ?", "author": "trustin", "createdAt": "2020-12-14T05:50:57Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/EndpointSelectionStrategy.java", "diffHunk": "@@ -48,6 +50,24 @@ static EndpointSelectionStrategy roundRobin() {\n         return RoundRobinStrategy.INSTANCE;\n     }\n \n+    /**\n+     * Returns a weighted round-robin strategy which is ramping up the weight of the newly added\n+     * {@link Endpoint}s using {@link EndpointWeightTransition#linear()}.\n+     * The weights of {@link Endpoint}s are ramped up ten times every two seconds by default. If you want to", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyODUzNg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542128536", "bodyText": "Wrong instance?", "author": "trustin", "createdAt": "2020-12-14T05:51:40Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/EndpointSelectionStrategy.java", "diffHunk": "@@ -48,6 +50,24 @@ static EndpointSelectionStrategy roundRobin() {\n         return RoundRobinStrategy.INSTANCE;\n     }\n \n+    /**\n+     * Returns a weighted round-robin strategy which is ramping up the weight of the newly added\n+     * {@link Endpoint}s using {@link EndpointWeightTransition#linear()}.\n+     * The weights of {@link Endpoint}s are ramped up ten times every two seconds by default. If you want to\n+     * customize the parameters, use {@link #builderForRampingUp()}.\n+     */\n+    static EndpointSelectionStrategy rampingUp() {\n+        return RoundRobinStrategy.INSTANCE;", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5ODMzNQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542998335", "bodyText": "\ud83d\ude31", "author": "minwoox", "createdAt": "2020-12-15T02:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyODUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyOTYwMQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542129601", "bodyText": "How about using long when no overflow is expected and BigInteger otherwise? double can mask overflows and result in smaller target weight if weight * currentStep results in the value beyond its allowed precision level.", "author": "trustin", "createdAt": "2020-12-14T05:54:56Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/EndpointWeightTransition.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+/**\n+ * Computes the weight of the given {@link Endpoint} using the given {@code currentStep} and {@code totalSteps}.\n+ */\n+@FunctionalInterface\n+public interface EndpointWeightTransition {\n+\n+    /**\n+     * Returns the {@link EndpointWeightTransition} which returns the gradually increased weight as the current\n+     * step increases.\n+     */\n+    static EndpointWeightTransition linear() {\n+        return (endpoint, currentStep, totalSteps) ->\n+                (int) ((double) endpoint.weight() * currentStep / totalSteps);", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5OTE0Mw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542999143", "bodyText": "Ah, that's a good point. Let me cast to long and cast to int again. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-12-15T02:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEyOTYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzMTUzOA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542131538", "bodyText": "Could you rephrase this? It sounds like the weight is multiplied totalSteps times on each tick.", "author": "trustin", "createdAt": "2020-12-14T06:00:45Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weighted round-robin strategy which is ramping up the weight of the newly added {@link Endpoint}s.\n+ */\n+public final class RampingUpWeightedRoundRobinStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_UPDATING_ENTRY_WINDOW_MILLIS = 500;\n+    private static final Ticker DEFAULT_TICKER = Ticker.systemTicker();\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private ScheduledExecutorService executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int totalSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long updatingTaskWindowMillis = DEFAULT_UPDATING_ENTRY_WINDOW_MILLIS;\n+    private Ticker ticker = DEFAULT_TICKER;\n+\n+    /**\n+     * Sets the specified {@link EndpointWeightTransition} that will compute the weight of an {@link Endpoint}\n+     * during the transition. {@link EndpointWeightTransition#linear()} is used by default.\n+     */\n+    public RampingUpWeightedRoundRobinStrategyBuilder transition(EndpointWeightTransition transition) {\n+        this.transition = requireNonNull(transition, \"transition\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link ScheduledExecutorService} that will be used to compute the weight of\n+     * an {@link Endpoint} using {@link EndpointWeightTransition}. An {@link EventLoop} from\n+     * {@link CommonPools#workerGroup()} is used by default.\n+     */\n+    public RampingUpWeightedRoundRobinStrategyBuilder executor(ScheduledExecutorService executor) {\n+        this.executor = requireNonNull(executor, \"executor\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpInterval}. The weight of an {@link Endpoint} is ramped up\n+     * {@link #totalSteps(int) totalSteps} times every {@code rampingUpInterval}.", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzMTk0Mg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542131942", "bodyText": "they are", "author": "trustin", "createdAt": "2020-12-14T06:01:51Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weighted round-robin strategy which is ramping up the weight of the newly added {@link Endpoint}s.\n+ */\n+public final class RampingUpWeightedRoundRobinStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_UPDATING_ENTRY_WINDOW_MILLIS = 500;\n+    private static final Ticker DEFAULT_TICKER = Ticker.systemTicker();\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private ScheduledExecutorService executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int totalSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long updatingTaskWindowMillis = DEFAULT_UPDATING_ENTRY_WINDOW_MILLIS;\n+    private Ticker ticker = DEFAULT_TICKER;\n+\n+    /**\n+     * Sets the specified {@link EndpointWeightTransition} that will compute the weight of an {@link Endpoint}\n+     * during the transition. {@link EndpointWeightTransition#linear()} is used by default.\n+     */\n+    public RampingUpWeightedRoundRobinStrategyBuilder transition(EndpointWeightTransition transition) {\n+        this.transition = requireNonNull(transition, \"transition\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link ScheduledExecutorService} that will be used to compute the weight of\n+     * an {@link Endpoint} using {@link EndpointWeightTransition}. An {@link EventLoop} from\n+     * {@link CommonPools#workerGroup()} is used by default.\n+     */\n+    public RampingUpWeightedRoundRobinStrategyBuilder executor(ScheduledExecutorService executor) {\n+        this.executor = requireNonNull(executor, \"executor\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpInterval}. The weight of an {@link Endpoint} is ramped up\n+     * {@link #totalSteps(int) totalSteps} times every {@code rampingUpInterval}.\n+     * {@value DEFAULT_RAMPING_UP_INTERVAL_MILLIS} millis is used by default.\n+     */\n+    public RampingUpWeightedRoundRobinStrategyBuilder rampingUpInterval(Duration rampingUpInterval) {\n+        requireNonNull(rampingUpInterval, \"rampingUpInterval\");\n+        return rampingUpIntervalMillis(rampingUpInterval.toMillis());\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpIntervalMillis}. The weight of an {@link Endpoint} is ramped up\n+     * {@link #totalSteps(int) totalSteps} times every {@code rampingUpIntervalMillis}.\n+     * {@value DEFAULT_RAMPING_UP_INTERVAL_MILLIS} millis is used by default.\n+     */\n+    public RampingUpWeightedRoundRobinStrategyBuilder rampingUpIntervalMillis(long rampingUpIntervalMillis) {\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (expected: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code totalSteps}. The weight of an {@link Endpoint} is ramped up\n+     * {@code totalSteps} times every {@link #rampingUpIntervalMillis(long) rampingUpIntervalMillis}.\n+     * {@value DEFAULT_NUMBER_OF_STEPS} is used by default.\n+     */\n+    public RampingUpWeightedRoundRobinStrategyBuilder totalSteps(int totalSteps) {\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code updatingTaskWindow} which will be used to combine weight updating tasks.\n+     * If several {@link Endpoint}s are added within the {@code updatingTaskWindow}, the weights of\n+     * them are updated together. If there's already a scheduled job and a new {@link Endpoint}s are added\n+     * within the {@code updatingTaskWindow}, they also updated together.", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzMjE1Mg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542132152", "bodyText": "t+0ms, t+200ms, ...", "author": "trustin", "createdAt": "2020-12-14T06:02:27Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weighted round-robin strategy which is ramping up the weight of the newly added {@link Endpoint}s.\n+ */\n+public final class RampingUpWeightedRoundRobinStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_UPDATING_ENTRY_WINDOW_MILLIS = 500;\n+    private static final Ticker DEFAULT_TICKER = Ticker.systemTicker();\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private ScheduledExecutorService executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int totalSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long updatingTaskWindowMillis = DEFAULT_UPDATING_ENTRY_WINDOW_MILLIS;\n+    private Ticker ticker = DEFAULT_TICKER;\n+\n+    /**\n+     * Sets the specified {@link EndpointWeightTransition} that will compute the weight of an {@link Endpoint}\n+     * during the transition. {@link EndpointWeightTransition#linear()} is used by default.\n+     */\n+    public RampingUpWeightedRoundRobinStrategyBuilder transition(EndpointWeightTransition transition) {\n+        this.transition = requireNonNull(transition, \"transition\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link ScheduledExecutorService} that will be used to compute the weight of\n+     * an {@link Endpoint} using {@link EndpointWeightTransition}. An {@link EventLoop} from\n+     * {@link CommonPools#workerGroup()} is used by default.\n+     */\n+    public RampingUpWeightedRoundRobinStrategyBuilder executor(ScheduledExecutorService executor) {\n+        this.executor = requireNonNull(executor, \"executor\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpInterval}. The weight of an {@link Endpoint} is ramped up\n+     * {@link #totalSteps(int) totalSteps} times every {@code rampingUpInterval}.\n+     * {@value DEFAULT_RAMPING_UP_INTERVAL_MILLIS} millis is used by default.\n+     */\n+    public RampingUpWeightedRoundRobinStrategyBuilder rampingUpInterval(Duration rampingUpInterval) {\n+        requireNonNull(rampingUpInterval, \"rampingUpInterval\");\n+        return rampingUpIntervalMillis(rampingUpInterval.toMillis());\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpIntervalMillis}. The weight of an {@link Endpoint} is ramped up\n+     * {@link #totalSteps(int) totalSteps} times every {@code rampingUpIntervalMillis}.\n+     * {@value DEFAULT_RAMPING_UP_INTERVAL_MILLIS} millis is used by default.\n+     */\n+    public RampingUpWeightedRoundRobinStrategyBuilder rampingUpIntervalMillis(long rampingUpIntervalMillis) {\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (expected: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code totalSteps}. The weight of an {@link Endpoint} is ramped up\n+     * {@code totalSteps} times every {@link #rampingUpIntervalMillis(long) rampingUpIntervalMillis}.\n+     * {@value DEFAULT_NUMBER_OF_STEPS} is used by default.\n+     */\n+    public RampingUpWeightedRoundRobinStrategyBuilder totalSteps(int totalSteps) {\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code updatingTaskWindow} which will be used to combine weight updating tasks.\n+     * If several {@link Endpoint}s are added within the {@code updatingTaskWindow}, the weights of\n+     * them are updated together. If there's already a scheduled job and a new {@link Endpoint}s are added\n+     * within the {@code updatingTaskWindow}, they also updated together.\n+     * This is an example of how it works when {@code updatingTaskWindow} is 500 milliseconds and\n+     * {@code rampingUpIntervalMillis} is 2000 milliseconds:\n+     * <pre>{@code\n+     * ----------------------------------------------------------------------------------------------------\n+     *     A         B                             C                                       D\n+     * ----------------------------------------------------------------------------------------------------\n+     *     0t       200T                        1000T                                    1800T     2000T", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjEzMzA3Mg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542133072", "bodyText": "Could remove the entry before returning if full?", "author": "trustin", "createdAt": "2020-12-14T06:05:22Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightBasedRandomEndpointSelector.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+final class WeightBasedRandomEndpointSelector {\n+    private static final AtomicIntegerFieldUpdater<WeightBasedRandomEndpointSelector> removingEntryUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(WeightBasedRandomEndpointSelector.class, \"removingEntry\");\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private final List<Entry> currentEntries;\n+    private long currentTotalWeight;\n+\n+    private volatile int removingEntry;\n+\n+    WeightBasedRandomEndpointSelector(List<Endpoint> endpoints) {\n+        final Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            builder.add(new Entry(endpoint, totalWeight));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+        currentEntries = new CopyOnWriteArrayList<>(entries);\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        for (;;) {\n+            final Endpoint endpoint = selectEndpoint0();\n+            if (endpoint != null) {\n+                return endpoint;\n+            }\n+        }\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint0() {\n+        final long nextLong = ThreadLocalRandom.current().nextLong(currentTotalWeight);\n+        // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+        // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+        // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+        for (Entry entry : currentEntries) {\n+            if (entry.lowerBound >= nextLong) {\n+                if (entry.increaseCounter()) {\n+                    return entry.endpoint();", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2Njc4Mg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542166782", "bodyText": "It's unclear from the code that this can't become an infinite loop. Is there a way to restructure this to not have a loop? Otherwise probably should add comments here on what the loop is for.", "author": "anuraaga", "createdAt": "2020-12-14T07:34:24Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightBasedRandomEndpointSelector.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+final class WeightBasedRandomEndpointSelector {\n+    private static final AtomicIntegerFieldUpdater<WeightBasedRandomEndpointSelector> removingEntryUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(WeightBasedRandomEndpointSelector.class, \"removingEntry\");\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private final List<Entry> currentEntries;\n+    private long currentTotalWeight;\n+\n+    private volatile int removingEntry;\n+\n+    WeightBasedRandomEndpointSelector(List<Endpoint> endpoints) {\n+        final Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            builder.add(new Entry(endpoint, totalWeight));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+        currentEntries = new CopyOnWriteArrayList<>(entries);\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        for (;;) {", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3OTE2MQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542979161", "bodyText": "Let me add a comment for this. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-12-15T01:39:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2Njc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2Nzc5NQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542167795", "bodyText": "This looks like it's using an intentional spin-lock instead of just a synchronized block (in many code pieces, we have a loop + atomic to prevent duplicate updates of a field, where it does make sense since the loop ends when another thread does the update, here we're literally just looping until the lock opens). FWIU, Java does spin a bit before sleeping a thread on locks so it's generally not recommended to use a spin lock in Java code.", "author": "anuraaga", "createdAt": "2020-12-14T07:36:28Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightBasedRandomEndpointSelector.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+final class WeightBasedRandomEndpointSelector {\n+    private static final AtomicIntegerFieldUpdater<WeightBasedRandomEndpointSelector> removingEntryUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(WeightBasedRandomEndpointSelector.class, \"removingEntry\");\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private final List<Entry> currentEntries;\n+    private long currentTotalWeight;\n+\n+    private volatile int removingEntry;\n+\n+    WeightBasedRandomEndpointSelector(List<Endpoint> endpoints) {\n+        final Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            builder.add(new Entry(endpoint, totalWeight));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+        currentEntries = new CopyOnWriteArrayList<>(entries);\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        for (;;) {\n+            final Endpoint endpoint = selectEndpoint0();\n+            if (endpoint != null) {\n+                return endpoint;\n+            }\n+        }\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint0() {\n+        final long nextLong = ThreadLocalRandom.current().nextLong(currentTotalWeight);\n+        // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+        // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+        // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+        for (Entry entry : currentEntries) {\n+            if (entry.lowerBound >= nextLong) {\n+                if (entry.increaseCounter()) {\n+                    return entry.endpoint();\n+                }\n+                // Should remove the entry from currentEntries.\n+                removeEntry(entry);\n+                return null;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private void removeEntry(Entry entry) {\n+        for (;;) {\n+            if (removingEntryUpdater.compareAndSet(this, 0, 1)) {", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3OTgwMg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542979802", "bodyText": "Yeah, let me use the synchronized block when the currentEntries is modified. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-12-15T01:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2Nzc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2ODgzMQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542168831", "bodyText": "If you really do want to keep the spin lock though, at least move removingEntry = 0 into a finally block", "author": "anuraaga", "createdAt": "2020-12-14T07:38:43Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightBasedRandomEndpointSelector.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+final class WeightBasedRandomEndpointSelector {\n+    private static final AtomicIntegerFieldUpdater<WeightBasedRandomEndpointSelector> removingEntryUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(WeightBasedRandomEndpointSelector.class, \"removingEntry\");\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private final List<Entry> currentEntries;\n+    private long currentTotalWeight;\n+\n+    private volatile int removingEntry;\n+\n+    WeightBasedRandomEndpointSelector(List<Endpoint> endpoints) {\n+        final Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            builder.add(new Entry(endpoint, totalWeight));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+        currentEntries = new CopyOnWriteArrayList<>(entries);\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        for (;;) {\n+            final Endpoint endpoint = selectEndpoint0();\n+            if (endpoint != null) {\n+                return endpoint;\n+            }\n+        }\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint0() {\n+        final long nextLong = ThreadLocalRandom.current().nextLong(currentTotalWeight);\n+        // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+        // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+        // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+        for (Entry entry : currentEntries) {\n+            if (entry.lowerBound >= nextLong) {\n+                if (entry.increaseCounter()) {\n+                    return entry.endpoint();\n+                }\n+                // Should remove the entry from currentEntries.\n+                removeEntry(entry);\n+                return null;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private void removeEntry(Entry entry) {\n+        for (;;) {\n+            if (removingEntryUpdater.compareAndSet(this, 0, 1)) {\n+                // Check again not to remove the entry in case reset() is called by another thread.\n+                if (!entry.isFull()) {\n+                    removingEntry = 0;", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2OTQ3Nw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542169477", "bodyText": "By the way, why does this class have the ability to remove entries but not add them? Seems assymetrical.", "author": "anuraaga", "createdAt": "2020-12-14T07:39:54Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightBasedRandomEndpointSelector.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+final class WeightBasedRandomEndpointSelector {\n+    private static final AtomicIntegerFieldUpdater<WeightBasedRandomEndpointSelector> removingEntryUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(WeightBasedRandomEndpointSelector.class, \"removingEntry\");\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private final List<Entry> currentEntries;\n+    private long currentTotalWeight;\n+\n+    private volatile int removingEntry;\n+\n+    WeightBasedRandomEndpointSelector(List<Endpoint> endpoints) {\n+        final Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            builder.add(new Entry(endpoint, totalWeight));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+        currentEntries = new CopyOnWriteArrayList<>(entries);\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        for (;;) {\n+            final Endpoint endpoint = selectEndpoint0();\n+            if (endpoint != null) {\n+                return endpoint;\n+            }\n+        }\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint0() {\n+        final long nextLong = ThreadLocalRandom.current().nextLong(currentTotalWeight);\n+        // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+        // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+        // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+        for (Entry entry : currentEntries) {\n+            if (entry.lowerBound >= nextLong) {\n+                if (entry.increaseCounter()) {\n+                    return entry.endpoint();\n+                }\n+                // Should remove the entry from currentEntries.\n+                removeEntry(entry);\n+                return null;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private void removeEntry(Entry entry) {", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3OTU5NQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542979595", "bodyText": "Yeah, this is an asymmetric algorithm. \ud83d\ude09\nEach entry is removed from currentEntries when the counter of each endpoint reached the weight.\nAnd the removed entries are added back to the currentEntries when all entries are removed.\nThis guarantees that the endpoint whose weight is very low is always selected when selectEndpoint() is called by totalWeight times.", "author": "minwoox", "createdAt": "2020-12-15T01:40:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2OTQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIyNjQ5NQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542226495", "bodyText": "You might want to add a builder method for ticker.", "author": "ikhoon", "createdAt": "2020-12-14T09:18:16Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weighted round-robin strategy which is ramping up the weight of the newly added {@link Endpoint}s.\n+ */\n+public final class RampingUpWeightedRoundRobinStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_UPDATING_ENTRY_WINDOW_MILLIS = 500;\n+    private static final Ticker DEFAULT_TICKER = Ticker.systemTicker();\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private ScheduledExecutorService executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int totalSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long updatingTaskWindowMillis = DEFAULT_UPDATING_ENTRY_WINDOW_MILLIS;\n+    private Ticker ticker = DEFAULT_TICKER;", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5NjMwMw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542996303", "bodyText": "This is just for the test. Let me remove this. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-12-15T02:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIyNjQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzMjY4Mg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542232682", "bodyText": "Isn't oldEndpoints not-null always?", "author": "ikhoon", "createdAt": "2020-12-14T09:27:23Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategy.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.RampingUpWeightedRoundRobinStrategy.EndpointsInUpdatingEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+final class RampingUpWeightedRoundRobinStrategy implements EndpointSelectionStrategy {\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long updatingTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    RampingUpWeightedRoundRobinStrategy(EndpointWeightTransition weightTransition,\n+                                        ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                                        int totalSteps, long updatingTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(updatingTaskWindowMillis > 0,\n+                      \"updatingTaskWindowMillis: %s (updatingTaskWindowMillis: > 0)\", updatingTaskWindowMillis);\n+        updatingTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(updatingTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightBasedRandomEndpointSelector endpointSelector;\n+\n+        @Nullable\n+        private List<Endpoint> oldEndpoints = new ArrayList<>();", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk4NDI2MA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542984260", "bodyText": "Oops forgot to remove that. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-12-15T01:53:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzMjY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI0NDgwOA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542244808", "bodyText": "Add final?", "author": "ikhoon", "createdAt": "2020-12-14T09:44:25Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategy.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.RampingUpWeightedRoundRobinStrategy.EndpointsInUpdatingEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+final class RampingUpWeightedRoundRobinStrategy implements EndpointSelectionStrategy {\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long updatingTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    RampingUpWeightedRoundRobinStrategy(EndpointWeightTransition weightTransition,\n+                                        ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                                        int totalSteps, long updatingTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(updatingTaskWindowMillis > 0,\n+                      \"updatingTaskWindowMillis: %s (updatingTaskWindowMillis: > 0)\", updatingTaskWindowMillis);\n+        updatingTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(updatingTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightBasedRandomEndpointSelector endpointSelector;\n+\n+        @Nullable\n+        private List<Endpoint> oldEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints = endpointGroup.endpoints();\n+            endpointSelector = new WeightBasedRandomEndpointSelector(initialEndpoints);\n+            oldEndpoints.addAll(initialEndpoints);\n+            endpointGroup.addListener(this::updateEndpoints);\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightBasedRandomEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {\n+            // Use the executor so the order of endpoints change is guaranteed.\n+            executor.execute(() -> updateEndpoints0(newEndpoints));\n+        }\n+\n+        // Only executed by the executor.\n+        private void updateEndpoints0(List<Endpoint> newEndpoints) {\n+            unhandledNewEndpoints = null;\n+            if (updatingTaskWindowNanos > 0) {\n+                if (addToPrevEntry()) {\n+                    // Update weight right away and combine updating weight schedule with the previous Entry.\n+                    final Deque<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(newEndpoints);\n+                    final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+                    addCurrentEndpoints(builder);\n+\n+                    if (!newlyAddedEndpoints.isEmpty()) {\n+                        updateEndpointWeight(newlyAddedEndpoints, builder);\n+                        endpointsInUpdatingEntries.getLast().addEndpoints(newlyAddedEndpoints);\n+                    }\n+                    // Should recreate endpointSelector because the oldEndpoints is changed\n+                    // when newlyAddedEndpoints is empty.\n+                    endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+                    return;\n+                }\n+\n+                if (addToNextEntry()) {\n+                    // Combine with the Entry and let it handle this newEndpoints when it calls updateWeight().\n+                    unhandledNewEndpoints = newEndpoints;\n+                    return;\n+                }\n+            }\n+\n+            final Deque<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(newEndpoints);\n+            if (newlyAddedEndpoints.isEmpty()) {\n+                final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+                addCurrentEndpoints(builder);\n+                // Should recreate endpointSelector because the oldEndpoints is changed\n+                // when newlyAddedEndpoints is empty.\n+                endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+                return;\n+            }\n+\n+            final EndpointsInUpdatingEntry endpointsInUpdatingEntry =\n+                    new EndpointsInUpdatingEntry(newlyAddedEndpoints, ticker,\n+                                                 TimeUnit.MILLISECONDS.toNanos(rampingUpIntervalMillis));\n+            endpointsInUpdatingEntries.add(endpointsInUpdatingEntry);\n+            updateEndpointWeight();\n+        }\n+\n+        private boolean addToPrevEntry() {\n+            final EndpointsInUpdatingEntry lastEndpointsInUpdatingEntry = endpointsInUpdatingEntries.peekLast();\n+            return lastEndpointsInUpdatingEntry != null &&\n+                   ticker.read() - lastEndpointsInUpdatingEntry.lastUpdatedTime <= updatingTaskWindowNanos;\n+        }\n+\n+        private boolean addToNextEntry() {\n+            final EndpointsInUpdatingEntry nextEndpointsInUpdatingEntry = endpointsInUpdatingEntries.peek();\n+            return nextEndpointsInUpdatingEntry != null &&\n+                   nextEndpointsInUpdatingEntry.nextUpdatingTime - ticker.read() <= updatingTaskWindowNanos;\n+        }\n+\n+        private void addCurrentEndpoints(Builder<Endpoint> builder) {\n+            assert oldEndpoints != null;\n+            builder.addAll(oldEndpoints);\n+            endpointsInUpdatingEntries.forEach(entry -> {\n+                entry.endpointAndSteps().forEach(endpointAndStep -> {\n+                    builder.add(endpointAndStep.endpoint().withWeight(endpointAndStep.currentWeight()));\n+                });\n+            });\n+        }\n+\n+        private Deque<EndpointAndStep> updateEndpoints1(List<Endpoint> newEndpoints) {\n+            final List<Endpoint> replacedOldEndpoints = new ArrayList<>();\n+            assert oldEndpoints != null;\n+            for (final Iterator<Endpoint> i = oldEndpoints.iterator(); i.hasNext();) {\n+                final Endpoint oldEndpoint = i.next();\n+                for (Endpoint newEndpoint : newEndpoints) {\n+                    if (oldEndpoint.equals(newEndpoint)) {\n+                        if (oldEndpoint.weight() > newEndpoint.weight()) {\n+                            i.remove();\n+                            // The weight of the new endpoint is lower than old one so we just replace it.\n+                            replacedOldEndpoints.add(newEndpoint);\n+                        } else if (oldEndpoint.weight() < newEndpoint.weight()) {\n+                            // The weight of the new endpoint is greater than old one so we just remove the\n+                            // old endpoint. The new endpoint will be added to\n+                            // newlyAddedEndpoints at the bottom of this method.\n+                            i.remove();\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+            if (!replacedOldEndpoints.isEmpty()) {\n+                oldEndpoints.addAll(replacedOldEndpoints);\n+            }\n+\n+            for (final Iterator<EndpointsInUpdatingEntry> i = endpointsInUpdatingEntries.iterator();\n+                 i.hasNext();) {\n+                final EndpointsInUpdatingEntry endpointsInUpdatingEntry = i.next();\n+\n+                final Deque<EndpointAndStep> endpointAndSteps = endpointsInUpdatingEntry.endpointAndSteps();\n+                removeIfNotInNewEndpoints(endpointAndSteps, newEndpoints);\n+                if (endpointAndSteps.isEmpty()) {\n+                    // All endpointAndSteps are removed so remove the entry from the Deque.\n+                    i.remove();\n+                    final ScheduledFuture<?> scheduledFuture = endpointsInUpdatingEntry.scheduledFuture;\n+                    if (scheduledFuture != null) {\n+                        scheduledFuture.cancel(true);\n+                    }\n+                }\n+            }\n+\n+            final Deque<EndpointAndStep> newlyAddedEndpoints = new ArrayDeque<>();\n+            for (Endpoint newEndpoint : newEndpoints) {\n+                // We don't have to compare the weight because the old endpoint whose host is same and weight\n+                // is different is already removed.\n+                if (oldEndpoints.contains(newEndpoint)) {\n+                    continue;\n+                }\n+\n+                // Two for loops are used but it's only the number of endpoints in updating because there are\n+                // no duplicate endpoints. So no big deal.\n+                boolean found = false;\n+                for (EndpointsInUpdatingEntry endpointsInUpdatingEntry : endpointsInUpdatingEntries) {\n+                    for (EndpointAndStep endpointAndStep : endpointsInUpdatingEntry.endpointAndSteps()) {\n+                        if (endpointAndStep.endpoint().equals(newEndpoint)) {\n+                            found = true;\n+                            break;\n+                        }\n+                    }\n+                    if (found) {\n+                        break;\n+                    }\n+                }\n+\n+                if (!found) {\n+                    newlyAddedEndpoints.add(new EndpointAndStep(newEndpoint));\n+                }\n+            }\n+            return newlyAddedEndpoints;\n+        }\n+\n+        private void removeIfNotInNewEndpoints(Deque<EndpointAndStep> endpointAndSteps,\n+                                               List<Endpoint> newEndpoints) {\n+            final List<EndpointAndStep> replacedEndpoints = new ArrayList<>();\n+            for (final Iterator<EndpointAndStep> i = endpointAndSteps.iterator();\n+                 i.hasNext();) {\n+                removeIfNotInNewEndpoints(i, newEndpoints, replacedEndpoints);\n+            }\n+\n+            if (!replacedEndpoints.isEmpty()) {\n+                endpointAndSteps.addAll(replacedEndpoints);\n+            }\n+        }\n+\n+        private void removeIfNotInNewEndpoints(Iterator<EndpointAndStep> i, List<Endpoint> newEndpoints,\n+                                               List<EndpointAndStep> replacedEndpoints) {\n+            final EndpointAndStep endpointAndStep = i.next();\n+            final Endpoint endpointInUpdating = endpointAndStep.endpoint();\n+            for (Endpoint newEndpoint : newEndpoints) {\n+                if (endpointInUpdating.equals(newEndpoint)) {\n+                    if (endpointInUpdating.weight() == newEndpoint.weight()) {\n+                        // Same weight so we don't do anything.\n+                    } else if (endpointAndStep.currentWeight() > newEndpoint.weight()) {\n+                        // Don't need to update the weight anymore so we add the newEndpoint to oldEndpoints.\n+                        assert oldEndpoints != null;\n+                        oldEndpoints.add(newEndpoint);\n+                        i.remove();\n+                    } else {\n+                        // Should replace the existing endpoint with the new one.\n+                        // To replace, just remove and add the newEndpoint later after iteration is over.\n+                        replacedEndpoints.add(new EndpointAndStep(newEndpoint, endpointAndStep.step));\n+                        i.remove();\n+                    }\n+                    return;\n+                }\n+            }\n+            // The endpoint is not in newEndpoints so remove it.\n+            i.remove();\n+        }\n+\n+        private void updateEndpointWeight() {\n+            final EndpointsInUpdatingEntry entry = endpointsInUpdatingEntries.peekFirst();\n+            assert entry != null;\n+            if (unhandledNewEndpoints != null) {\n+                final Deque<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(unhandledNewEndpoints);\n+                entry.addEndpoints(newlyAddedEndpoints);\n+                unhandledNewEndpoints = null;\n+            }\n+\n+            final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+            final Deque<EndpointAndStep> endpointAndSteps = entry.endpointAndSteps();\n+            updateEndpointWeight(endpointAndSteps, builder);\n+            assert oldEndpoints != null;\n+            builder.addAll(oldEndpoints);\n+\n+            endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+            endpointsInUpdatingEntries.pollFirst();\n+            if (!endpointAndSteps.isEmpty()) {\n+                final ScheduledFuture<?> scheduledFuture = executor.schedule(\n+                        (Runnable) this::updateEndpointWeight,\n+                        rampingUpIntervalMillis,\n+                        TimeUnit.MILLISECONDS);\n+                entry.scheduledFuture(scheduledFuture);\n+                // Added to the last of the entries.\n+                endpointsInUpdatingEntries.add(entry);\n+            }\n+        }\n+\n+        private void updateEndpointWeight(Deque<EndpointAndStep> endpointAndSteps,\n+                                          Builder<Endpoint> builder) {\n+            assert oldEndpoints != null;\n+            for (final Iterator<EndpointAndStep> i = endpointAndSteps.iterator(); i.hasNext();) {\n+                final EndpointAndStep endpointAndStep = i.next();\n+                final int step = endpointAndStep.incrementAndGetStep();\n+                final Endpoint endpoint = endpointAndStep.endpoint();\n+                if (step == totalSteps) {\n+                    oldEndpoints.add(endpoint);\n+                    i.remove();\n+                } else {\n+                    final int calculated =\n+                            weightTransition.compute(endpoint, step, totalSteps);\n+                    final int currentWeight = Math.max(Math.min(calculated, endpoint.weight()), 1);\n+                    endpointAndStep.currentWeight(currentWeight);\n+                    builder.add(endpoint.withWeight(currentWeight));\n+                }\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static class EndpointsInUpdatingEntry {\n+\n+        private final Deque<EndpointAndStep> endpointAndSteps;\n+        private final Ticker ticker;\n+        private final long rampingUpIntervalNanos;\n+\n+        @Nullable\n+        ScheduledFuture<?> scheduledFuture;\n+        long lastUpdatedTime;\n+        long nextUpdatingTime;\n+\n+        EndpointsInUpdatingEntry(Deque<EndpointAndStep> endpointAndSteps, Ticker ticker,\n+                                 long rampingUpIntervalNanos) {\n+            this.endpointAndSteps = endpointAndSteps;\n+            this.ticker = ticker;\n+            this.rampingUpIntervalNanos = rampingUpIntervalNanos;\n+        }\n+\n+        Deque<EndpointAndStep> endpointAndSteps() {\n+            return endpointAndSteps;\n+        }\n+\n+        void addEndpoints(Deque<EndpointAndStep> endpoints) {\n+            endpointAndSteps.addAll(endpoints);\n+        }\n+\n+        void scheduledFuture(ScheduledFuture<?> scheduledFuture) {\n+            this.scheduledFuture = scheduledFuture;\n+            lastUpdatedTime = ticker.read();\n+            nextUpdatingTime = lastUpdatedTime + rampingUpIntervalNanos;\n+        }\n+\n+        @VisibleForTesting\n+        static class EndpointAndStep {", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI1NTM0OQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542255349", "bodyText": "addToPrevEntry sounds behavior like adding something.\nHow about adding canAddEndpoints() to EndpointsInUpdatingEntry and ?\nfinal EndpointsInUpdatingEntry lastEntry = endpointsInUpdatingEntries.peekLast();\nif (lastEntry.canAddEndpoints()) {\n   ...\n}", "author": "ikhoon", "createdAt": "2020-12-14T09:59:38Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategy.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.RampingUpWeightedRoundRobinStrategy.EndpointsInUpdatingEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+final class RampingUpWeightedRoundRobinStrategy implements EndpointSelectionStrategy {\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long updatingTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    RampingUpWeightedRoundRobinStrategy(EndpointWeightTransition weightTransition,\n+                                        ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                                        int totalSteps, long updatingTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(updatingTaskWindowMillis > 0,\n+                      \"updatingTaskWindowMillis: %s (updatingTaskWindowMillis: > 0)\", updatingTaskWindowMillis);\n+        updatingTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(updatingTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightBasedRandomEndpointSelector endpointSelector;\n+\n+        @Nullable\n+        private List<Endpoint> oldEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints = endpointGroup.endpoints();\n+            endpointSelector = new WeightBasedRandomEndpointSelector(initialEndpoints);\n+            oldEndpoints.addAll(initialEndpoints);\n+            endpointGroup.addListener(this::updateEndpoints);\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightBasedRandomEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {\n+            // Use the executor so the order of endpoints change is guaranteed.\n+            executor.execute(() -> updateEndpoints0(newEndpoints));\n+        }\n+\n+        // Only executed by the executor.\n+        private void updateEndpoints0(List<Endpoint> newEndpoints) {\n+            unhandledNewEndpoints = null;\n+            if (updatingTaskWindowNanos > 0) {\n+                if (addToPrevEntry()) {", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk4NTI3Mw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542985273", "bodyText": "Then let me just use canAddToPrevEntry because\nif (lastEntry.canAddEndpoints()) {...} this doesn't telling that the new endpoints should be added to the prev or next entry. As you know, the following action is different.", "author": "minwoox", "createdAt": "2020-12-15T01:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI1NTM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI3MDUxOQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542270519", "bodyText": "If the endponts is a large number such as 2000, these nested loops takes about 2000 * 2000 / 2.\nHow about creating an temporary map to avoid a long loop just in case.\nfinal Map<Endpoint, Endpoint> newEndpointsMap = newEndpoints.stream().collect(toImmutableMap(Function.identity(), Function.identity()));\nfor (...) {\n    final Endpoint endpoint = newEndpointsMap.get(oldEndpoint);\n    if (endpoint != null) {\n        ...\n    }\n}", "author": "ikhoon", "createdAt": "2020-12-14T10:22:02Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategy.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.RampingUpWeightedRoundRobinStrategy.EndpointsInUpdatingEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+final class RampingUpWeightedRoundRobinStrategy implements EndpointSelectionStrategy {\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long updatingTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    RampingUpWeightedRoundRobinStrategy(EndpointWeightTransition weightTransition,\n+                                        ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                                        int totalSteps, long updatingTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(updatingTaskWindowMillis > 0,\n+                      \"updatingTaskWindowMillis: %s (updatingTaskWindowMillis: > 0)\", updatingTaskWindowMillis);\n+        updatingTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(updatingTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightBasedRandomEndpointSelector endpointSelector;\n+\n+        @Nullable\n+        private List<Endpoint> oldEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints = endpointGroup.endpoints();\n+            endpointSelector = new WeightBasedRandomEndpointSelector(initialEndpoints);\n+            oldEndpoints.addAll(initialEndpoints);\n+            endpointGroup.addListener(this::updateEndpoints);\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightBasedRandomEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {\n+            // Use the executor so the order of endpoints change is guaranteed.\n+            executor.execute(() -> updateEndpoints0(newEndpoints));\n+        }\n+\n+        // Only executed by the executor.\n+        private void updateEndpoints0(List<Endpoint> newEndpoints) {\n+            unhandledNewEndpoints = null;\n+            if (updatingTaskWindowNanos > 0) {\n+                if (addToPrevEntry()) {\n+                    // Update weight right away and combine updating weight schedule with the previous Entry.\n+                    final Deque<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(newEndpoints);\n+                    final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+                    addCurrentEndpoints(builder);\n+\n+                    if (!newlyAddedEndpoints.isEmpty()) {\n+                        updateEndpointWeight(newlyAddedEndpoints, builder);\n+                        endpointsInUpdatingEntries.getLast().addEndpoints(newlyAddedEndpoints);\n+                    }\n+                    // Should recreate endpointSelector because the oldEndpoints is changed\n+                    // when newlyAddedEndpoints is empty.\n+                    endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+                    return;\n+                }\n+\n+                if (addToNextEntry()) {\n+                    // Combine with the Entry and let it handle this newEndpoints when it calls updateWeight().\n+                    unhandledNewEndpoints = newEndpoints;\n+                    return;\n+                }\n+            }\n+\n+            final Deque<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(newEndpoints);\n+            if (newlyAddedEndpoints.isEmpty()) {\n+                final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+                addCurrentEndpoints(builder);\n+                // Should recreate endpointSelector because the oldEndpoints is changed\n+                // when newlyAddedEndpoints is empty.\n+                endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+                return;\n+            }\n+\n+            final EndpointsInUpdatingEntry endpointsInUpdatingEntry =\n+                    new EndpointsInUpdatingEntry(newlyAddedEndpoints, ticker,\n+                                                 TimeUnit.MILLISECONDS.toNanos(rampingUpIntervalMillis));\n+            endpointsInUpdatingEntries.add(endpointsInUpdatingEntry);\n+            updateEndpointWeight();\n+        }\n+\n+        private boolean addToPrevEntry() {\n+            final EndpointsInUpdatingEntry lastEndpointsInUpdatingEntry = endpointsInUpdatingEntries.peekLast();\n+            return lastEndpointsInUpdatingEntry != null &&\n+                   ticker.read() - lastEndpointsInUpdatingEntry.lastUpdatedTime <= updatingTaskWindowNanos;\n+        }\n+\n+        private boolean addToNextEntry() {\n+            final EndpointsInUpdatingEntry nextEndpointsInUpdatingEntry = endpointsInUpdatingEntries.peek();\n+            return nextEndpointsInUpdatingEntry != null &&\n+                   nextEndpointsInUpdatingEntry.nextUpdatingTime - ticker.read() <= updatingTaskWindowNanos;\n+        }\n+\n+        private void addCurrentEndpoints(Builder<Endpoint> builder) {\n+            assert oldEndpoints != null;\n+            builder.addAll(oldEndpoints);\n+            endpointsInUpdatingEntries.forEach(entry -> {\n+                entry.endpointAndSteps().forEach(endpointAndStep -> {\n+                    builder.add(endpointAndStep.endpoint().withWeight(endpointAndStep.currentWeight()));\n+                });\n+            });\n+        }\n+\n+        private Deque<EndpointAndStep> updateEndpoints1(List<Endpoint> newEndpoints) {\n+            final List<Endpoint> replacedOldEndpoints = new ArrayList<>();\n+            assert oldEndpoints != null;\n+            for (final Iterator<Endpoint> i = oldEndpoints.iterator(); i.hasNext();) {\n+                final Endpoint oldEndpoint = i.next();\n+                for (Endpoint newEndpoint : newEndpoints) {", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5NDcyMA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542994720", "bodyText": "We also need to remove an oldEnpoint which is not in newEndpoints so this solution does not guarantee the reduction of time complexity when endpoints are such a big number.\nWe also have the same problem in HealthCheckedEndpoint (contatins method uses a for loop inside.)\nTo prevent the situation I think sorting the endpoints and comparing from the first is the best solution when N is such a big number. However, this is not good when N is small and also it will make this PR complicated. So let me just add TODO for that. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-12-15T02:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI3MDUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4MTM3Nw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543781377", "bodyText": "I now understand what you meant. \ud83d\ude04 Let me use the map. Thanks!", "author": "minwoox", "createdAt": "2020-12-16T00:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI3MDUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwNTY2OQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542305669", "bodyText": "nit: ImmutableList.Builder", "author": "ikhoon", "createdAt": "2020-12-14T11:16:52Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightBasedRandomEndpointSelector.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+final class WeightBasedRandomEndpointSelector {\n+    private static final AtomicIntegerFieldUpdater<WeightBasedRandomEndpointSelector> removingEntryUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(WeightBasedRandomEndpointSelector.class, \"removingEntry\");\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private final List<Entry> currentEntries;\n+    private long currentTotalWeight;\n+\n+    private volatile int removingEntry;\n+\n+    WeightBasedRandomEndpointSelector(List<Endpoint> endpoints) {\n+        final Builder<Entry> builder = ImmutableList.builder();", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMxMTAyMw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542311023", "bodyText": "If Entry has only one counter, is it better to extend AtomicInteger to reduce the  retained object size?\nAdd final?", "author": "ikhoon", "createdAt": "2020-12-14T11:25:41Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightBasedRandomEndpointSelector.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+final class WeightBasedRandomEndpointSelector {\n+    private static final AtomicIntegerFieldUpdater<WeightBasedRandomEndpointSelector> removingEntryUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(WeightBasedRandomEndpointSelector.class, \"removingEntry\");\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private final List<Entry> currentEntries;\n+    private long currentTotalWeight;\n+\n+    private volatile int removingEntry;\n+\n+    WeightBasedRandomEndpointSelector(List<Endpoint> endpoints) {\n+        final Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            builder.add(new Entry(endpoint, totalWeight));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+        currentEntries = new CopyOnWriteArrayList<>(entries);\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        for (;;) {\n+            final Endpoint endpoint = selectEndpoint0();\n+            if (endpoint != null) {\n+                return endpoint;\n+            }\n+        }\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint0() {\n+        final long nextLong = ThreadLocalRandom.current().nextLong(currentTotalWeight);\n+        // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+        // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+        // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+        for (Entry entry : currentEntries) {\n+            if (entry.lowerBound >= nextLong) {\n+                if (entry.increaseCounter()) {\n+                    return entry.endpoint();\n+                }\n+                // Should remove the entry from currentEntries.\n+                removeEntry(entry);\n+                return null;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private void removeEntry(Entry entry) {\n+        for (;;) {\n+            if (removingEntryUpdater.compareAndSet(this, 0, 1)) {\n+                // Check again not to remove the entry in case reset() is called by another thread.\n+                if (!entry.isFull()) {\n+                    removingEntry = 0;\n+                    return;\n+                }\n+                if (currentEntries.remove(entry)) {\n+                    if (currentEntries.isEmpty()) {\n+                        reset();\n+                    } else {\n+                        currentTotalWeight -= entry.endpoint().weight();\n+                    }\n+                } else {\n+                    // The entry is removed by other thread.\n+                }\n+                removingEntry = 0;\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void reset() {\n+        for (Entry entry : entries) {\n+            entry.reset();\n+        }\n+        currentEntries.addAll(entries);\n+        currentTotalWeight = totalWeight;\n+    }\n+\n+    @VisibleForTesting\n+    static class Entry {", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5NjM2NQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542996365", "bodyText": "That's a good suggestion.", "author": "minwoox", "createdAt": "2020-12-15T02:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMxMTAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMzNjIzMA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542336230", "bodyText": "Add final?", "author": "ikhoon", "createdAt": "2020-12-14T12:10:53Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategy.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.RampingUpWeightedRoundRobinStrategy.EndpointsInUpdatingEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+final class RampingUpWeightedRoundRobinStrategy implements EndpointSelectionStrategy {\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long updatingTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    RampingUpWeightedRoundRobinStrategy(EndpointWeightTransition weightTransition,\n+                                        ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                                        int totalSteps, long updatingTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(updatingTaskWindowMillis > 0,\n+                      \"updatingTaskWindowMillis: %s (updatingTaskWindowMillis: > 0)\", updatingTaskWindowMillis);\n+        updatingTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(updatingTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightBasedRandomEndpointSelector endpointSelector;\n+\n+        @Nullable\n+        private List<Endpoint> oldEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints = endpointGroup.endpoints();\n+            endpointSelector = new WeightBasedRandomEndpointSelector(initialEndpoints);\n+            oldEndpoints.addAll(initialEndpoints);\n+            endpointGroup.addListener(this::updateEndpoints);\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightBasedRandomEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {\n+            // Use the executor so the order of endpoints change is guaranteed.\n+            executor.execute(() -> updateEndpoints0(newEndpoints));\n+        }\n+\n+        // Only executed by the executor.\n+        private void updateEndpoints0(List<Endpoint> newEndpoints) {\n+            unhandledNewEndpoints = null;\n+            if (updatingTaskWindowNanos > 0) {\n+                if (addToPrevEntry()) {\n+                    // Update weight right away and combine updating weight schedule with the previous Entry.\n+                    final Deque<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(newEndpoints);\n+                    final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+                    addCurrentEndpoints(builder);\n+\n+                    if (!newlyAddedEndpoints.isEmpty()) {\n+                        updateEndpointWeight(newlyAddedEndpoints, builder);\n+                        endpointsInUpdatingEntries.getLast().addEndpoints(newlyAddedEndpoints);\n+                    }\n+                    // Should recreate endpointSelector because the oldEndpoints is changed\n+                    // when newlyAddedEndpoints is empty.\n+                    endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+                    return;\n+                }\n+\n+                if (addToNextEntry()) {\n+                    // Combine with the Entry and let it handle this newEndpoints when it calls updateWeight().\n+                    unhandledNewEndpoints = newEndpoints;\n+                    return;\n+                }\n+            }\n+\n+            final Deque<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(newEndpoints);\n+            if (newlyAddedEndpoints.isEmpty()) {\n+                final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+                addCurrentEndpoints(builder);\n+                // Should recreate endpointSelector because the oldEndpoints is changed\n+                // when newlyAddedEndpoints is empty.\n+                endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+                return;\n+            }\n+\n+            final EndpointsInUpdatingEntry endpointsInUpdatingEntry =\n+                    new EndpointsInUpdatingEntry(newlyAddedEndpoints, ticker,\n+                                                 TimeUnit.MILLISECONDS.toNanos(rampingUpIntervalMillis));\n+            endpointsInUpdatingEntries.add(endpointsInUpdatingEntry);\n+            updateEndpointWeight();\n+        }\n+\n+        private boolean addToPrevEntry() {\n+            final EndpointsInUpdatingEntry lastEndpointsInUpdatingEntry = endpointsInUpdatingEntries.peekLast();\n+            return lastEndpointsInUpdatingEntry != null &&\n+                   ticker.read() - lastEndpointsInUpdatingEntry.lastUpdatedTime <= updatingTaskWindowNanos;\n+        }\n+\n+        private boolean addToNextEntry() {\n+            final EndpointsInUpdatingEntry nextEndpointsInUpdatingEntry = endpointsInUpdatingEntries.peek();\n+            return nextEndpointsInUpdatingEntry != null &&\n+                   nextEndpointsInUpdatingEntry.nextUpdatingTime - ticker.read() <= updatingTaskWindowNanos;\n+        }\n+\n+        private void addCurrentEndpoints(Builder<Endpoint> builder) {\n+            assert oldEndpoints != null;\n+            builder.addAll(oldEndpoints);\n+            endpointsInUpdatingEntries.forEach(entry -> {\n+                entry.endpointAndSteps().forEach(endpointAndStep -> {\n+                    builder.add(endpointAndStep.endpoint().withWeight(endpointAndStep.currentWeight()));\n+                });\n+            });\n+        }\n+\n+        private Deque<EndpointAndStep> updateEndpoints1(List<Endpoint> newEndpoints) {\n+            final List<Endpoint> replacedOldEndpoints = new ArrayList<>();\n+            assert oldEndpoints != null;\n+            for (final Iterator<Endpoint> i = oldEndpoints.iterator(); i.hasNext();) {\n+                final Endpoint oldEndpoint = i.next();\n+                for (Endpoint newEndpoint : newEndpoints) {\n+                    if (oldEndpoint.equals(newEndpoint)) {\n+                        if (oldEndpoint.weight() > newEndpoint.weight()) {\n+                            i.remove();\n+                            // The weight of the new endpoint is lower than old one so we just replace it.\n+                            replacedOldEndpoints.add(newEndpoint);\n+                        } else if (oldEndpoint.weight() < newEndpoint.weight()) {\n+                            // The weight of the new endpoint is greater than old one so we just remove the\n+                            // old endpoint. The new endpoint will be added to\n+                            // newlyAddedEndpoints at the bottom of this method.\n+                            i.remove();\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+            if (!replacedOldEndpoints.isEmpty()) {\n+                oldEndpoints.addAll(replacedOldEndpoints);\n+            }\n+\n+            for (final Iterator<EndpointsInUpdatingEntry> i = endpointsInUpdatingEntries.iterator();\n+                 i.hasNext();) {\n+                final EndpointsInUpdatingEntry endpointsInUpdatingEntry = i.next();\n+\n+                final Deque<EndpointAndStep> endpointAndSteps = endpointsInUpdatingEntry.endpointAndSteps();\n+                removeIfNotInNewEndpoints(endpointAndSteps, newEndpoints);\n+                if (endpointAndSteps.isEmpty()) {\n+                    // All endpointAndSteps are removed so remove the entry from the Deque.\n+                    i.remove();\n+                    final ScheduledFuture<?> scheduledFuture = endpointsInUpdatingEntry.scheduledFuture;\n+                    if (scheduledFuture != null) {\n+                        scheduledFuture.cancel(true);\n+                    }\n+                }\n+            }\n+\n+            final Deque<EndpointAndStep> newlyAddedEndpoints = new ArrayDeque<>();\n+            for (Endpoint newEndpoint : newEndpoints) {\n+                // We don't have to compare the weight because the old endpoint whose host is same and weight\n+                // is different is already removed.\n+                if (oldEndpoints.contains(newEndpoint)) {\n+                    continue;\n+                }\n+\n+                // Two for loops are used but it's only the number of endpoints in updating because there are\n+                // no duplicate endpoints. So no big deal.\n+                boolean found = false;\n+                for (EndpointsInUpdatingEntry endpointsInUpdatingEntry : endpointsInUpdatingEntries) {\n+                    for (EndpointAndStep endpointAndStep : endpointsInUpdatingEntry.endpointAndSteps()) {\n+                        if (endpointAndStep.endpoint().equals(newEndpoint)) {\n+                            found = true;\n+                            break;\n+                        }\n+                    }\n+                    if (found) {\n+                        break;\n+                    }\n+                }\n+\n+                if (!found) {\n+                    newlyAddedEndpoints.add(new EndpointAndStep(newEndpoint));\n+                }\n+            }\n+            return newlyAddedEndpoints;\n+        }\n+\n+        private void removeIfNotInNewEndpoints(Deque<EndpointAndStep> endpointAndSteps,\n+                                               List<Endpoint> newEndpoints) {\n+            final List<EndpointAndStep> replacedEndpoints = new ArrayList<>();\n+            for (final Iterator<EndpointAndStep> i = endpointAndSteps.iterator();\n+                 i.hasNext();) {\n+                removeIfNotInNewEndpoints(i, newEndpoints, replacedEndpoints);\n+            }\n+\n+            if (!replacedEndpoints.isEmpty()) {\n+                endpointAndSteps.addAll(replacedEndpoints);\n+            }\n+        }\n+\n+        private void removeIfNotInNewEndpoints(Iterator<EndpointAndStep> i, List<Endpoint> newEndpoints,\n+                                               List<EndpointAndStep> replacedEndpoints) {\n+            final EndpointAndStep endpointAndStep = i.next();\n+            final Endpoint endpointInUpdating = endpointAndStep.endpoint();\n+            for (Endpoint newEndpoint : newEndpoints) {\n+                if (endpointInUpdating.equals(newEndpoint)) {\n+                    if (endpointInUpdating.weight() == newEndpoint.weight()) {\n+                        // Same weight so we don't do anything.\n+                    } else if (endpointAndStep.currentWeight() > newEndpoint.weight()) {\n+                        // Don't need to update the weight anymore so we add the newEndpoint to oldEndpoints.\n+                        assert oldEndpoints != null;\n+                        oldEndpoints.add(newEndpoint);\n+                        i.remove();\n+                    } else {\n+                        // Should replace the existing endpoint with the new one.\n+                        // To replace, just remove and add the newEndpoint later after iteration is over.\n+                        replacedEndpoints.add(new EndpointAndStep(newEndpoint, endpointAndStep.step));\n+                        i.remove();\n+                    }\n+                    return;\n+                }\n+            }\n+            // The endpoint is not in newEndpoints so remove it.\n+            i.remove();\n+        }\n+\n+        private void updateEndpointWeight() {\n+            final EndpointsInUpdatingEntry entry = endpointsInUpdatingEntries.peekFirst();\n+            assert entry != null;\n+            if (unhandledNewEndpoints != null) {\n+                final Deque<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(unhandledNewEndpoints);\n+                entry.addEndpoints(newlyAddedEndpoints);\n+                unhandledNewEndpoints = null;\n+            }\n+\n+            final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+            final Deque<EndpointAndStep> endpointAndSteps = entry.endpointAndSteps();\n+            updateEndpointWeight(endpointAndSteps, builder);\n+            assert oldEndpoints != null;\n+            builder.addAll(oldEndpoints);\n+\n+            endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+            endpointsInUpdatingEntries.pollFirst();\n+            if (!endpointAndSteps.isEmpty()) {\n+                final ScheduledFuture<?> scheduledFuture = executor.schedule(\n+                        (Runnable) this::updateEndpointWeight,\n+                        rampingUpIntervalMillis,\n+                        TimeUnit.MILLISECONDS);\n+                entry.scheduledFuture(scheduledFuture);\n+                // Added to the last of the entries.\n+                endpointsInUpdatingEntries.add(entry);\n+            }\n+        }\n+\n+        private void updateEndpointWeight(Deque<EndpointAndStep> endpointAndSteps,\n+                                          Builder<Endpoint> builder) {\n+            assert oldEndpoints != null;\n+            for (final Iterator<EndpointAndStep> i = endpointAndSteps.iterator(); i.hasNext();) {\n+                final EndpointAndStep endpointAndStep = i.next();\n+                final int step = endpointAndStep.incrementAndGetStep();\n+                final Endpoint endpoint = endpointAndStep.endpoint();\n+                if (step == totalSteps) {\n+                    oldEndpoints.add(endpoint);\n+                    i.remove();\n+                } else {\n+                    final int calculated =\n+                            weightTransition.compute(endpoint, step, totalSteps);\n+                    final int currentWeight = Math.max(Math.min(calculated, endpoint.weight()), 1);\n+                    endpointAndStep.currentWeight(currentWeight);\n+                    builder.add(endpoint.withWeight(currentWeight));\n+                }\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static class EndpointsInUpdatingEntry {", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM0MTI2MQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542341261", "bodyText": "updateEndpointWeight()?", "author": "ikhoon", "createdAt": "2020-12-14T12:20:13Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategy.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.RampingUpWeightedRoundRobinStrategy.EndpointsInUpdatingEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+final class RampingUpWeightedRoundRobinStrategy implements EndpointSelectionStrategy {\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long updatingTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    RampingUpWeightedRoundRobinStrategy(EndpointWeightTransition weightTransition,\n+                                        ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                                        int totalSteps, long updatingTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(updatingTaskWindowMillis > 0,\n+                      \"updatingTaskWindowMillis: %s (updatingTaskWindowMillis: > 0)\", updatingTaskWindowMillis);\n+        updatingTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(updatingTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightBasedRandomEndpointSelector endpointSelector;\n+\n+        @Nullable\n+        private List<Endpoint> oldEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints = endpointGroup.endpoints();\n+            endpointSelector = new WeightBasedRandomEndpointSelector(initialEndpoints);\n+            oldEndpoints.addAll(initialEndpoints);\n+            endpointGroup.addListener(this::updateEndpoints);\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightBasedRandomEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {\n+            // Use the executor so the order of endpoints change is guaranteed.\n+            executor.execute(() -> updateEndpoints0(newEndpoints));\n+        }\n+\n+        // Only executed by the executor.\n+        private void updateEndpoints0(List<Endpoint> newEndpoints) {\n+            unhandledNewEndpoints = null;\n+            if (updatingTaskWindowNanos > 0) {\n+                if (addToPrevEntry()) {\n+                    // Update weight right away and combine updating weight schedule with the previous Entry.\n+                    final Deque<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(newEndpoints);\n+                    final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+                    addCurrentEndpoints(builder);\n+\n+                    if (!newlyAddedEndpoints.isEmpty()) {\n+                        updateEndpointWeight(newlyAddedEndpoints, builder);\n+                        endpointsInUpdatingEntries.getLast().addEndpoints(newlyAddedEndpoints);\n+                    }\n+                    // Should recreate endpointSelector because the oldEndpoints is changed\n+                    // when newlyAddedEndpoints is empty.\n+                    endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+                    return;\n+                }\n+\n+                if (addToNextEntry()) {\n+                    // Combine with the Entry and let it handle this newEndpoints when it calls updateWeight().", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjM5OQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542352399", "bodyText": "Question: Isn't it better to make endpointAndStep a Set? Do we need to use Deque?", "author": "ikhoon", "createdAt": "2020-12-14T12:40:16Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategy.java", "diffHunk": "@@ -0,0 +1,433 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.RampingUpWeightedRoundRobinStrategy.EndpointsInUpdatingEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+final class RampingUpWeightedRoundRobinStrategy implements EndpointSelectionStrategy {\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long updatingTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    RampingUpWeightedRoundRobinStrategy(EndpointWeightTransition weightTransition,\n+                                        ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                                        int totalSteps, long updatingTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(updatingTaskWindowMillis > 0,\n+                      \"updatingTaskWindowMillis: %s (updatingTaskWindowMillis: > 0)\", updatingTaskWindowMillis);\n+        updatingTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(updatingTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightBasedRandomEndpointSelector endpointSelector;\n+\n+        @Nullable\n+        private List<Endpoint> oldEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints = endpointGroup.endpoints();\n+            endpointSelector = new WeightBasedRandomEndpointSelector(initialEndpoints);\n+            oldEndpoints.addAll(initialEndpoints);\n+            endpointGroup.addListener(this::updateEndpoints);\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightBasedRandomEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {\n+            // Use the executor so the order of endpoints change is guaranteed.\n+            executor.execute(() -> updateEndpoints0(newEndpoints));\n+        }\n+\n+        // Only executed by the executor.\n+        private void updateEndpoints0(List<Endpoint> newEndpoints) {\n+            unhandledNewEndpoints = null;\n+            if (updatingTaskWindowNanos > 0) {\n+                if (addToPrevEntry()) {\n+                    // Update weight right away and combine updating weight schedule with the previous Entry.\n+                    final Deque<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(newEndpoints);\n+                    final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+                    addCurrentEndpoints(builder);\n+\n+                    if (!newlyAddedEndpoints.isEmpty()) {\n+                        updateEndpointWeight(newlyAddedEndpoints, builder);\n+                        endpointsInUpdatingEntries.getLast().addEndpoints(newlyAddedEndpoints);\n+                    }\n+                    // Should recreate endpointSelector because the oldEndpoints is changed\n+                    // when newlyAddedEndpoints is empty.\n+                    endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+                    return;\n+                }\n+\n+                if (addToNextEntry()) {\n+                    // Combine with the Entry and let it handle this newEndpoints when it calls updateWeight().\n+                    unhandledNewEndpoints = newEndpoints;\n+                    return;\n+                }\n+            }\n+\n+            final Deque<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(newEndpoints);\n+            if (newlyAddedEndpoints.isEmpty()) {\n+                final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+                addCurrentEndpoints(builder);\n+                // Should recreate endpointSelector because the oldEndpoints is changed\n+                // when newlyAddedEndpoints is empty.\n+                endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+                return;\n+            }\n+\n+            final EndpointsInUpdatingEntry endpointsInUpdatingEntry =\n+                    new EndpointsInUpdatingEntry(newlyAddedEndpoints, ticker,\n+                                                 TimeUnit.MILLISECONDS.toNanos(rampingUpIntervalMillis));\n+            endpointsInUpdatingEntries.add(endpointsInUpdatingEntry);\n+            updateEndpointWeight();\n+        }\n+\n+        private boolean addToPrevEntry() {\n+            final EndpointsInUpdatingEntry lastEndpointsInUpdatingEntry = endpointsInUpdatingEntries.peekLast();\n+            return lastEndpointsInUpdatingEntry != null &&\n+                   ticker.read() - lastEndpointsInUpdatingEntry.lastUpdatedTime <= updatingTaskWindowNanos;\n+        }\n+\n+        private boolean addToNextEntry() {\n+            final EndpointsInUpdatingEntry nextEndpointsInUpdatingEntry = endpointsInUpdatingEntries.peek();\n+            return nextEndpointsInUpdatingEntry != null &&\n+                   nextEndpointsInUpdatingEntry.nextUpdatingTime - ticker.read() <= updatingTaskWindowNanos;\n+        }\n+\n+        private void addCurrentEndpoints(Builder<Endpoint> builder) {\n+            assert oldEndpoints != null;\n+            builder.addAll(oldEndpoints);\n+            endpointsInUpdatingEntries.forEach(entry -> {\n+                entry.endpointAndSteps().forEach(endpointAndStep -> {\n+                    builder.add(endpointAndStep.endpoint().withWeight(endpointAndStep.currentWeight()));\n+                });\n+            });\n+        }\n+\n+        private Deque<EndpointAndStep> updateEndpoints1(List<Endpoint> newEndpoints) {\n+            final List<Endpoint> replacedOldEndpoints = new ArrayList<>();\n+            assert oldEndpoints != null;\n+            for (final Iterator<Endpoint> i = oldEndpoints.iterator(); i.hasNext();) {\n+                final Endpoint oldEndpoint = i.next();\n+                for (Endpoint newEndpoint : newEndpoints) {\n+                    if (oldEndpoint.equals(newEndpoint)) {\n+                        if (oldEndpoint.weight() > newEndpoint.weight()) {\n+                            i.remove();\n+                            // The weight of the new endpoint is lower than old one so we just replace it.\n+                            replacedOldEndpoints.add(newEndpoint);\n+                        } else if (oldEndpoint.weight() < newEndpoint.weight()) {\n+                            // The weight of the new endpoint is greater than old one so we just remove the\n+                            // old endpoint. The new endpoint will be added to\n+                            // newlyAddedEndpoints at the bottom of this method.\n+                            i.remove();\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+            if (!replacedOldEndpoints.isEmpty()) {\n+                oldEndpoints.addAll(replacedOldEndpoints);\n+            }\n+\n+            for (final Iterator<EndpointsInUpdatingEntry> i = endpointsInUpdatingEntries.iterator();\n+                 i.hasNext();) {\n+                final EndpointsInUpdatingEntry endpointsInUpdatingEntry = i.next();\n+\n+                final Deque<EndpointAndStep> endpointAndSteps = endpointsInUpdatingEntry.endpointAndSteps();\n+                removeIfNotInNewEndpoints(endpointAndSteps, newEndpoints);\n+                if (endpointAndSteps.isEmpty()) {\n+                    // All endpointAndSteps are removed so remove the entry from the Deque.\n+                    i.remove();\n+                    final ScheduledFuture<?> scheduledFuture = endpointsInUpdatingEntry.scheduledFuture;\n+                    if (scheduledFuture != null) {\n+                        scheduledFuture.cancel(true);\n+                    }\n+                }\n+            }\n+\n+            final Deque<EndpointAndStep> newlyAddedEndpoints = new ArrayDeque<>();\n+            for (Endpoint newEndpoint : newEndpoints) {\n+                // We don't have to compare the weight because the old endpoint whose host is same and weight\n+                // is different is already removed.\n+                if (oldEndpoints.contains(newEndpoint)) {\n+                    continue;\n+                }\n+\n+                // Two for loops are used but it's only the number of endpoints in updating because there are\n+                // no duplicate endpoints. So no big deal.\n+                boolean found = false;\n+                for (EndpointsInUpdatingEntry endpointsInUpdatingEntry : endpointsInUpdatingEntries) {\n+                    for (EndpointAndStep endpointAndStep : endpointsInUpdatingEntry.endpointAndSteps()) {", "originalCommit": "5d85c555c02e098a295538a6d9766b409e0f8d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5ODEyOQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r542998129", "bodyText": "It's just that there's much chance endpointAndStep is removed from the first while iterating so I wanted to use a circular queue. But there's also a chance that the endpointAndStep in the middle is removed. So let me use the Set. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-12-15T02:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjM5OQ=="}], "type": "inlineReview"}, {"oid": "4192d984116b27c7d05cbfdf537316c7ac5dcede", "url": "https://github.com/line/armeria/commit/4192d984116b27c7d05cbfdf537316c7ac5dcede", "message": "Address comments by @trustin, @anuraaga and @ikhoon", "committedDate": "2020-12-15T07:11:50Z", "type": "commit"}, {"oid": "e553428acfb546503fe30f47a80d9e22949a2f41", "url": "https://github.com/line/armeria/commit/e553428acfb546503fe30f47a80d9e22949a2f41", "message": "Fix", "committedDate": "2020-12-15T07:20:10Z", "type": "commit"}, {"oid": "1a7e72f2245b4751a54dab912bb0f47b63c9622b", "url": "https://github.com/line/armeria/commit/1a7e72f2245b4751a54dab912bb0f47b63c9622b", "message": "Fix test", "committedDate": "2020-12-15T08:27:21Z", "type": "commit"}, {"oid": "bfd70ca5815363a1f8a8f0420cfdef71ecb7824a", "url": "https://github.com/line/armeria/commit/bfd70ca5815363a1f8a8f0420cfdef71ecb7824a", "message": "Merge branch 'master' into cslb_slowStart", "committedDate": "2020-12-15T08:27:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NTM3OQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543145379", "bodyText": "Just wondering, is the removal easier to reason about than making entries as unavailable? Something like this? Not sure if this works exactly but something along these lines\nif (!entry.isFull()) {\n  return selected;\n} else if (entry.isUnavailable()) {\n  continue;\n}\nentry.markUnavailable();\ncurrentTotalWeight.decrementAndGet(entry.endpoint().weight());", "author": "anuraaga", "createdAt": "2020-12-15T08:35:06Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightBasedRandomEndpointSelector.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+final class WeightBasedRandomEndpointSelector {\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private final List<Entry> currentEntries;\n+    private long currentTotalWeight;\n+\n+    WeightBasedRandomEndpointSelector(List<Endpoint> endpoints) {\n+        final ImmutableList.Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            builder.add(new Entry(endpoint, totalWeight));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+        currentEntries = new CopyOnWriteArrayList<>(entries);\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        for (;;) {\n+            // selectEndpoint0() returns null if the endpoint is selected more than its weight while\n+            // other endpoints are not. In that case the entry of that endpoint is removed and returns null.\n+            // So we should loop to select another endpoint.\n+            // This guarantees that the endpoint whose weight is very low is always selected when\n+            // selectEndpoint() is called by totalWeight times even though we use random.\n+            final Endpoint endpoint = selectEndpoint0();\n+            if (endpoint != null) {\n+                return endpoint;\n+            }\n+        }\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint0() {\n+        final long nextLong = ThreadLocalRandom.current().nextLong(currentTotalWeight);\n+        // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+        // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+        // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+        Endpoint selected = null;\n+        for (Entry entry : currentEntries) {\n+            if (entry.lowerBound >= nextLong) {\n+                if (entry.increaseCounter()) {\n+                    selected = entry.endpoint();\n+                }\n+                if (!entry.isFull()) {\n+                    return selected;\n+                }\n+\n+                // The entry is full so we should remove the entry from currentEntries.\n+                synchronized (currentEntries) {", "originalCommit": "bfd70ca5815363a1f8a8f0420cfdef71ecb7824a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1ODg5OA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543158898", "bodyText": "Hm, if we don't remove the entry, isn't there chances that the endpoint with low weight (e.g. 1) is not selected even after one turn(totalWeigth) is passed?\nWe use a random number to select an endpoint so removing entries will guarantee that the endpoint is selected evenly with its weight. \ud83e\udd14", "author": "minwoox", "createdAt": "2020-12-15T08:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMzNDk0Ng==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543334946", "bodyText": "Well I figured an unavailable marker should be equivalent to removal, just without having to manage the list and maybe easier to mutate it atomically. if (unavailable) continue; feels equivalent semantically to removal. But maybe missing some corner case.", "author": "anuraaga", "createdAt": "2020-12-15T13:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4NDMxOA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543784318", "bodyText": "I now realized the logic I implemented was not working as I expected. \ud83d\ude05  Maybe that's the reason that I got confused.\nThe current logic is slanted because the entry, which is next to the endpoint whose weight is large, will get much chance to get selected after the endpoint is full.\nSo I have to recalculate the lowerBound after the entry is removed but I forgot about it. \ud83d\ude05\nOn the other hand, I'm a bit doubtful about recalculation. Let me think about this. \ud83e\udd14", "author": "minwoox", "createdAt": "2020-12-16T00:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg3NTQ5Mw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543875493", "bodyText": "@anuraaga I updated the logic a bit. PTAL. \ud83d\ude47\u200d\u2642\ufe0f", "author": "minwoox", "createdAt": "2020-12-16T03:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NTM3OQ=="}], "type": "inlineReview"}, {"oid": "c4a5c598380ebeeb08fcca66205b168cbcb85729", "url": "https://github.com/line/armeria/commit/c4a5c598380ebeeb08fcca66205b168cbcb85729", "message": "Add toString", "committedDate": "2020-12-15T09:10:00Z", "type": "commit"}, {"oid": "465495e299c5474b3efeef30a5a8652e6ea95b70", "url": "https://github.com/line/armeria/commit/465495e299c5474b3efeef30a5a8652e6ea95b70", "message": "Use map to compare new endpoints", "committedDate": "2020-12-16T00:52:30Z", "type": "commit"}, {"oid": "5e81e84a602d96e87667e7a5ca5ca125815f6d01", "url": "https://github.com/line/armeria/commit/5e81e84a602d96e87667e7a5ca5ca125815f6d01", "message": "Update selection logic", "committedDate": "2020-12-16T03:00:52Z", "type": "commit"}, {"oid": "f4a7270d031ba22a23abdbb905f3cfebc16f2950", "url": "https://github.com/line/armeria/commit/f4a7270d031ba22a23abdbb905f3cfebc16f2950", "message": "Fix checkstyle", "committedDate": "2020-12-16T04:05:22Z", "type": "commit"}, {"oid": "5f27fbcdffadb64f3fe99851e67b2ae8172bc8bd", "url": "https://github.com/line/armeria/commit/5f27fbcdffadb64f3fe99851e67b2ae8172bc8bd", "message": "Remove auto generated Tomcat files", "committedDate": "2020-12-16T04:27:11Z", "type": "commit"}, {"oid": "dc979d792c877afb2b996980472f9321847e1c4d", "url": "https://github.com/line/armeria/commit/dc979d792c877afb2b996980472f9321847e1c4d", "message": "Add description", "committedDate": "2020-12-16T06:02:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg5MzU1MQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543893551", "bodyText": "camel or upper case?", "author": "ikhoon", "createdAt": "2020-12-16T03:37:50Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategy.java", "diffHunk": "@@ -0,0 +1,437 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.RampingUpWeightedRoundRobinStrategy.EndpointsInUpdatingEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+final class RampingUpWeightedRoundRobinStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker default_ticker = Ticker.systemTicker();", "originalCommit": "5e81e84a602d96e87667e7a5ca5ca125815f6d01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAyNDkzNw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r544024937", "bodyText": "Oops. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-12-16T06:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg5MzU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg5MzgwNg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543893806", "bodyText": "nit: builderForRampingUp().build() ?", "author": "ikhoon", "createdAt": "2020-12-16T03:38:11Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/EndpointSelectionStrategy.java", "diffHunk": "@@ -48,6 +50,24 @@ static EndpointSelectionStrategy roundRobin() {\n         return RoundRobinStrategy.INSTANCE;\n     }\n \n+    /**\n+     * Returns a weighted round-robin strategy which ramps the weight of the newly added\n+     * {@link Endpoint}s using {@link EndpointWeightTransition#linear()}.\n+     * The weights of {@link Endpoint}s are ramped up by 10 percent every 2 seconds up to 100 percent\n+     * by default. If you want to customize the parameters, use {@link #builderForRampingUp()}.\n+     */\n+    static EndpointSelectionStrategy rampingUp() {\n+        return new RampingUpWeightedRoundRobinStrategyBuilder().build();", "originalCommit": "5e81e84a602d96e87667e7a5ca5ca125815f6d01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg5Nzc3OQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543897779", "bodyText": "Could use Ints.saturatedCast() for clarity?", "author": "ikhoon", "createdAt": "2020-12-16T03:44:18Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/EndpointWeightTransition.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+/**\n+ * Computes the weight of the given {@link Endpoint} using the given {@code currentStep} and {@code totalSteps}.\n+ */\n+@FunctionalInterface\n+public interface EndpointWeightTransition {\n+\n+    /**\n+     * Returns the {@link EndpointWeightTransition} which returns the gradually increased weight as the current\n+     * step increases.\n+     */\n+    static EndpointWeightTransition linear() {\n+        return (endpoint, currentStep, totalSteps) ->\n+                // currentStep is never greater than totalSteps so we can cast long to int.\n+                (int) ((long) endpoint.weight() * currentStep / totalSteps);", "originalCommit": "5e81e84a602d96e87667e7a5ca5ca125815f6d01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkyMzkzNQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543923935", "bodyText": "Mixed usages of entry.endpoint and entry.endpoint().\nIntroduce a local variable for entry.endpoint.weight()?", "author": "ikhoon", "createdAt": "2020-12-16T04:19:04Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightBasedRandomEndpointSelector.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+final class WeightBasedRandomEndpointSelector {\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private final List<Entry> currentEntries;\n+    private long currentTotalWeight;\n+\n+    WeightBasedRandomEndpointSelector(List<Endpoint> endpoints) {\n+        final ImmutableList.Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            builder.add(new Entry(endpoint));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+        currentEntries = new CopyOnWriteArrayList<>(entries);\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        Endpoint selected = null;\n+        for (;;) {\n+            long nextLong = ThreadLocalRandom.current().nextLong(currentTotalWeight);\n+            // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+            // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+            // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+            for (Entry entry : currentEntries) {\n+                nextLong -= entry.endpoint.weight();", "originalCommit": "5e81e84a602d96e87667e7a5ca5ca125815f6d01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAzMzIwMQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r544033201", "bodyText": "Fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-12-16T06:40:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkyMzkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkyNjk3NA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543926974", "bodyText": "nit: In my opinion, it is easier to understand if condition with non-negate expression.\nHow about the following style for readability?\nif (entry.isFull()) {\n   // Do something if entry is full\n   if (currentEntries.remove(entry)) {\n       ...\n   }\n}", "author": "ikhoon", "createdAt": "2020-12-16T04:23:01Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightBasedRandomEndpointSelector.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+final class WeightBasedRandomEndpointSelector {\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private final List<Entry> currentEntries;\n+    private long currentTotalWeight;\n+\n+    WeightBasedRandomEndpointSelector(List<Endpoint> endpoints) {\n+        final ImmutableList.Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            builder.add(new Entry(endpoint));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+        currentEntries = new CopyOnWriteArrayList<>(entries);\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        Endpoint selected = null;\n+        for (;;) {\n+            long nextLong = ThreadLocalRandom.current().nextLong(currentTotalWeight);\n+            // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+            // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+            // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+            for (Entry entry : currentEntries) {\n+                nextLong -= entry.endpoint.weight();\n+                if (nextLong < 0) {\n+                    if (entry.increaseCounter()) {\n+                        selected = entry.endpoint();\n+                    }\n+                    if (!entry.isFull()) {\n+                        break;\n+                    }\n+\n+                    // The entry is full so we should remove the entry from currentEntries.\n+                    synchronized (currentEntries) {\n+                        // Check again not to remove the entry where reset() is called by another thread.\n+                        if (!entry.isFull()) {\n+                            break;\n+                        }\n+                        if (currentEntries.remove(entry)) {\n+                            if (currentEntries.isEmpty()) {\n+                                reset();\n+                            } else {\n+                                currentTotalWeight -= entry.endpoint().weight();\n+                            }\n+                        } else {\n+                            // The entry is removed by another thread.\n+                        }\n+                    }", "originalCommit": "5e81e84a602d96e87667e7a5ca5ca125815f6d01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkyODAyNA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543928024", "bodyText": "EndpointWithCounter or EndpointCounter?", "author": "ikhoon", "createdAt": "2020-12-16T04:24:22Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightBasedRandomEndpointSelector.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+final class WeightBasedRandomEndpointSelector {\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private final List<Entry> currentEntries;\n+    private long currentTotalWeight;\n+\n+    WeightBasedRandomEndpointSelector(List<Endpoint> endpoints) {\n+        final ImmutableList.Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            builder.add(new Entry(endpoint));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+        currentEntries = new CopyOnWriteArrayList<>(entries);\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        Endpoint selected = null;\n+        for (;;) {\n+            long nextLong = ThreadLocalRandom.current().nextLong(currentTotalWeight);\n+            // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+            // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+            // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+            for (Entry entry : currentEntries) {\n+                nextLong -= entry.endpoint.weight();\n+                if (nextLong < 0) {\n+                    if (entry.increaseCounter()) {\n+                        selected = entry.endpoint();\n+                    }\n+                    if (!entry.isFull()) {\n+                        break;\n+                    }\n+\n+                    // The entry is full so we should remove the entry from currentEntries.\n+                    synchronized (currentEntries) {\n+                        // Check again not to remove the entry where reset() is called by another thread.\n+                        if (!entry.isFull()) {\n+                            break;\n+                        }\n+                        if (currentEntries.remove(entry)) {\n+                            if (currentEntries.isEmpty()) {\n+                                reset();\n+                            } else {\n+                                currentTotalWeight -= entry.endpoint().weight();\n+                            }\n+                        } else {\n+                            // The entry is removed by another thread.\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            if (selected != null) {\n+                return selected;\n+            }\n+        }\n+    }\n+\n+    private void reset() {\n+        for (Entry entry : entries) {\n+            entry.set(0);\n+        }\n+        currentEntries.addAll(entries);\n+        currentTotalWeight = totalWeight;\n+    }\n+\n+    @VisibleForTesting\n+    static final class Entry extends AtomicInteger {", "originalCommit": "5e81e84a602d96e87667e7a5ca5ca125815f6d01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAzMjkyMw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r544032923", "bodyText": "Let me just use Entry as we discussed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-12-16T06:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkyODAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkzMTEyNg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543931126", "bodyText": "How about setting entry.set(0) before removing an entry in order to remove an initializing loop in reset()?", "author": "ikhoon", "createdAt": "2020-12-16T04:28:32Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightBasedRandomEndpointSelector.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+final class WeightBasedRandomEndpointSelector {\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private final List<Entry> currentEntries;\n+    private long currentTotalWeight;\n+\n+    WeightBasedRandomEndpointSelector(List<Endpoint> endpoints) {\n+        final ImmutableList.Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            builder.add(new Entry(endpoint));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+        currentEntries = new CopyOnWriteArrayList<>(entries);\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        Endpoint selected = null;\n+        for (;;) {\n+            long nextLong = ThreadLocalRandom.current().nextLong(currentTotalWeight);\n+            // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+            // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+            // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+            for (Entry entry : currentEntries) {\n+                nextLong -= entry.endpoint.weight();\n+                if (nextLong < 0) {\n+                    if (entry.increaseCounter()) {\n+                        selected = entry.endpoint();\n+                    }\n+                    if (!entry.isFull()) {\n+                        break;\n+                    }\n+\n+                    // The entry is full so we should remove the entry from currentEntries.\n+                    synchronized (currentEntries) {\n+                        // Check again not to remove the entry where reset() is called by another thread.\n+                        if (!entry.isFull()) {\n+                            break;\n+                        }\n+                        if (currentEntries.remove(entry)) {", "originalCommit": "5e81e84a602d96e87667e7a5ca5ca125815f6d01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAyNjc2Mw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r544026763", "bodyText": "We can't because another thread might access the entry and use it even though it shouldn't.", "author": "minwoox", "createdAt": "2020-12-16T06:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkzMTEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA1ODQxMg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r544058412", "bodyText": "Ah. I missed that point.", "author": "ikhoon", "createdAt": "2020-12-16T07:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkzMTEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA2NzkwNw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r544067907", "bodyText": "No problem. Thanks for the review. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-12-16T07:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkzMTEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk5OTY2MQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r543999661", "bodyText": "How about renaming the method name to removeOrUpdateEndpointAndSteps()? Because this method also updates the existing endpointAndSteps.", "author": "ikhoon", "createdAt": "2020-12-16T05:58:33Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategy.java", "diffHunk": "@@ -0,0 +1,437 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.RampingUpWeightedRoundRobinStrategy.EndpointsInUpdatingEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+final class RampingUpWeightedRoundRobinStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker default_ticker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long updatingTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    RampingUpWeightedRoundRobinStrategy(EndpointWeightTransition weightTransition,\n+                                        ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                                        int totalSteps, long updatingTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, totalSteps, updatingTaskWindowMillis,\n+             default_ticker);\n+    }\n+\n+    @VisibleForTesting\n+    RampingUpWeightedRoundRobinStrategy(EndpointWeightTransition weightTransition,\n+                                        ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                                        int totalSteps, long updatingTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(updatingTaskWindowMillis > 0,\n+                      \"updatingTaskWindowMillis: %s (updatingTaskWindowMillis: > 0)\", updatingTaskWindowMillis);\n+        updatingTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(updatingTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightBasedRandomEndpointSelector endpointSelector;\n+\n+        private final List<Endpoint> oldEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints = endpointGroup.endpoints();\n+            endpointSelector = new WeightBasedRandomEndpointSelector(initialEndpoints);\n+            oldEndpoints.addAll(initialEndpoints);\n+            endpointGroup.addListener(this::updateEndpoints);\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightBasedRandomEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {\n+            // Use the executor so the order of endpoints change is guaranteed.\n+            executor.execute(() -> updateEndpoints0(newEndpoints));\n+        }\n+\n+        // Only executed by the executor.\n+        private void updateEndpoints0(List<Endpoint> newEndpoints) {\n+            unhandledNewEndpoints = null;\n+            if (updatingTaskWindowNanos > 0) {\n+                if (canAddToPrevEntry()) {\n+                    // Update weight right away and combine updating weight schedule with the previous Entry.\n+                    final Set<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(newEndpoints);\n+                    final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+                    addCurrentEndpoints(builder);\n+\n+                    if (!newlyAddedEndpoints.isEmpty()) {\n+                        updateEndpointWeight(newlyAddedEndpoints, builder);\n+                        endpointsInUpdatingEntries.getLast().addEndpoints(newlyAddedEndpoints);\n+                    }\n+                    // Should recreate endpointSelector even when newlyAddedEndpoints is empty because\n+                    // the oldEndpoints is changed.\n+                    endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+                    return;\n+                }\n+\n+                if (canAddToNextEntry()) {\n+                    // Combine with the next entry and let it handle this newEndpoints when\n+                    // updateEndpointWeight() is executed.\n+                    unhandledNewEndpoints = newEndpoints;\n+                    return;\n+                }\n+            }\n+\n+            final Set<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(newEndpoints);\n+            if (newlyAddedEndpoints.isEmpty()) {\n+                final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+                addCurrentEndpoints(builder);\n+                // Should recreate endpointSelector because the oldEndpoints is changed\n+                // when newlyAddedEndpoints is empty.\n+                endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+                return;\n+            }\n+\n+            final EndpointsInUpdatingEntry endpointsInUpdatingEntry =\n+                    new EndpointsInUpdatingEntry(newlyAddedEndpoints, ticker,\n+                                                 TimeUnit.MILLISECONDS.toNanos(rampingUpIntervalMillis));\n+            endpointsInUpdatingEntries.add(endpointsInUpdatingEntry);\n+            updateEndpointWeight();\n+        }\n+\n+        private boolean canAddToPrevEntry() {\n+            final EndpointsInUpdatingEntry lastEndpointsInUpdatingEntry = endpointsInUpdatingEntries.peekLast();\n+            return lastEndpointsInUpdatingEntry != null &&\n+                   ticker.read() - lastEndpointsInUpdatingEntry.lastUpdatedTime <= updatingTaskWindowNanos;\n+        }\n+\n+        private boolean canAddToNextEntry() {\n+            final EndpointsInUpdatingEntry nextEndpointsInUpdatingEntry = endpointsInUpdatingEntries.peek();\n+            return nextEndpointsInUpdatingEntry != null &&\n+                   nextEndpointsInUpdatingEntry.nextUpdatingTime - ticker.read() <= updatingTaskWindowNanos;\n+        }\n+\n+        private void addCurrentEndpoints(Builder<Endpoint> builder) {\n+            builder.addAll(oldEndpoints);\n+            endpointsInUpdatingEntries.forEach(\n+                    entry -> entry.endpointAndSteps().forEach(\n+                            endpointAndStep -> builder.add(\n+                                    endpointAndStep.endpoint().withWeight(endpointAndStep.currentWeight()))));\n+        }\n+\n+        private Set<EndpointAndStep> updateEndpoints1(List<Endpoint> newEndpoints) {\n+            final Map<Endpoint, Endpoint> newEndpointsMap = new HashMap<>(newEndpoints.size());\n+            // The value is retrieved to compare the weight of the endpoint.\n+            newEndpoints.forEach(newEndpoint -> newEndpointsMap.put(newEndpoint, newEndpoint));\n+\n+            final List<Endpoint> replacedOldEndpoints = new ArrayList<>();\n+            for (final Iterator<Endpoint> i = oldEndpoints.iterator(); i.hasNext();) {\n+                final Endpoint oldEndpoint = i.next();\n+                final Endpoint newEndpoint = newEndpointsMap.get(oldEndpoint);\n+                if (newEndpoint == null) {\n+                    // newEndpoints does not have this old endpoint so we remove it.\n+                    i.remove();\n+                    continue;\n+                }\n+\n+                if (oldEndpoint.weight() > newEndpoint.weight()) {\n+                    // The weight of the new endpoint is lower than the old endpoint so we just replace it\n+                    // because we don't have to ramp up the weight.\n+                    replacedOldEndpoints.add(newEndpoint);\n+                    // Also remove the new endpoint from the map so we don't ramp up for the endpoint.\n+                    newEndpointsMap.remove(newEndpoint);\n+                    i.remove();\n+                } else if (oldEndpoint.weight() < newEndpoint.weight()) {\n+                    // The weight of the new endpoint is greater than the old endpoint so we remove the\n+                    // old one. The new endpoint will be ramping up\n+                    i.remove();\n+                } else {\n+                    // The weights are same so we keep the old endpoint and remove the new endpoint from\n+                    // the map so we don't ramp up for the endpoint.\n+                    newEndpointsMap.remove(newEndpoint);\n+                }\n+            }\n+            if (!replacedOldEndpoints.isEmpty()) {\n+                oldEndpoints.addAll(replacedOldEndpoints);\n+            }\n+\n+            for (final Iterator<EndpointsInUpdatingEntry> i = endpointsInUpdatingEntries.iterator();\n+                 i.hasNext();) {\n+                final EndpointsInUpdatingEntry endpointsInUpdatingEntry = i.next();\n+\n+                final Set<EndpointAndStep> endpointAndSteps = endpointsInUpdatingEntry.endpointAndSteps();\n+                removeIfNotInNewEndpoints(endpointAndSteps, newEndpointsMap);\n+                if (endpointAndSteps.isEmpty()) {\n+                    // All endpointAndSteps are removed so remove the entry completely.\n+                    i.remove();\n+                    final ScheduledFuture<?> scheduledFuture = endpointsInUpdatingEntry.scheduledFuture;\n+                    if (scheduledFuture != null) {\n+                        scheduledFuture.cancel(true);\n+                    }\n+                }\n+            }\n+\n+            // At this point, newEndpointsMap only contains the new endpoints that have to be ramped up.\n+            final Set<EndpointAndStep> newlyAddedEndpoints = new HashSet<>(newEndpointsMap.size());\n+            newEndpointsMap.keySet().forEach(\n+                    endpoint -> newlyAddedEndpoints.add(new EndpointAndStep(endpoint)));\n+            return newlyAddedEndpoints;\n+        }\n+\n+        private void removeIfNotInNewEndpoints(Set<EndpointAndStep> endpointAndSteps,", "originalCommit": "5f27fbcdffadb64f3fe99851e67b2ae8172bc8bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAyNjI5NQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r544026295", "bodyText": "That's a good suggestion, thanks!", "author": "minwoox", "createdAt": "2020-12-16T06:32:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk5OTY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAwMTMzNw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r544001337", "bodyText": "How about returning a mutable List here? The created immutable list of Endpoint is copied again in the constructor of WeightBasedRandomEndpointSelector.", "author": "ikhoon", "createdAt": "2020-12-16T06:00:43Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/RampingUpWeightedRoundRobinStrategy.java", "diffHunk": "@@ -0,0 +1,437 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableList.Builder;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.RampingUpWeightedRoundRobinStrategy.EndpointsInUpdatingEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+final class RampingUpWeightedRoundRobinStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker default_ticker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long updatingTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    RampingUpWeightedRoundRobinStrategy(EndpointWeightTransition weightTransition,\n+                                        ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                                        int totalSteps, long updatingTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, totalSteps, updatingTaskWindowMillis,\n+             default_ticker);\n+    }\n+\n+    @VisibleForTesting\n+    RampingUpWeightedRoundRobinStrategy(EndpointWeightTransition weightTransition,\n+                                        ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                                        int totalSteps, long updatingTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(updatingTaskWindowMillis > 0,\n+                      \"updatingTaskWindowMillis: %s (updatingTaskWindowMillis: > 0)\", updatingTaskWindowMillis);\n+        updatingTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(updatingTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightBasedRandomEndpointSelector endpointSelector;\n+\n+        private final List<Endpoint> oldEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints = endpointGroup.endpoints();\n+            endpointSelector = new WeightBasedRandomEndpointSelector(initialEndpoints);\n+            oldEndpoints.addAll(initialEndpoints);\n+            endpointGroup.addListener(this::updateEndpoints);\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightBasedRandomEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {\n+            // Use the executor so the order of endpoints change is guaranteed.\n+            executor.execute(() -> updateEndpoints0(newEndpoints));\n+        }\n+\n+        // Only executed by the executor.\n+        private void updateEndpoints0(List<Endpoint> newEndpoints) {\n+            unhandledNewEndpoints = null;\n+            if (updatingTaskWindowNanos > 0) {\n+                if (canAddToPrevEntry()) {\n+                    // Update weight right away and combine updating weight schedule with the previous Entry.\n+                    final Set<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(newEndpoints);\n+                    final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+                    addCurrentEndpoints(builder);\n+\n+                    if (!newlyAddedEndpoints.isEmpty()) {\n+                        updateEndpointWeight(newlyAddedEndpoints, builder);\n+                        endpointsInUpdatingEntries.getLast().addEndpoints(newlyAddedEndpoints);\n+                    }\n+                    // Should recreate endpointSelector even when newlyAddedEndpoints is empty because\n+                    // the oldEndpoints is changed.\n+                    endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+                    return;\n+                }\n+\n+                if (canAddToNextEntry()) {\n+                    // Combine with the next entry and let it handle this newEndpoints when\n+                    // updateEndpointWeight() is executed.\n+                    unhandledNewEndpoints = newEndpoints;\n+                    return;\n+                }\n+            }\n+\n+            final Set<EndpointAndStep> newlyAddedEndpoints = updateEndpoints1(newEndpoints);\n+            if (newlyAddedEndpoints.isEmpty()) {\n+                final ImmutableList.Builder<Endpoint> builder = ImmutableList.builder();\n+                addCurrentEndpoints(builder);\n+                // Should recreate endpointSelector because the oldEndpoints is changed\n+                // when newlyAddedEndpoints is empty.\n+                endpointSelector = new WeightBasedRandomEndpointSelector(builder.build());\n+                return;\n+            }\n+\n+            final EndpointsInUpdatingEntry endpointsInUpdatingEntry =\n+                    new EndpointsInUpdatingEntry(newlyAddedEndpoints, ticker,\n+                                                 TimeUnit.MILLISECONDS.toNanos(rampingUpIntervalMillis));\n+            endpointsInUpdatingEntries.add(endpointsInUpdatingEntry);\n+            updateEndpointWeight();\n+        }\n+\n+        private boolean canAddToPrevEntry() {\n+            final EndpointsInUpdatingEntry lastEndpointsInUpdatingEntry = endpointsInUpdatingEntries.peekLast();\n+            return lastEndpointsInUpdatingEntry != null &&\n+                   ticker.read() - lastEndpointsInUpdatingEntry.lastUpdatedTime <= updatingTaskWindowNanos;\n+        }\n+\n+        private boolean canAddToNextEntry() {\n+            final EndpointsInUpdatingEntry nextEndpointsInUpdatingEntry = endpointsInUpdatingEntries.peek();\n+            return nextEndpointsInUpdatingEntry != null &&\n+                   nextEndpointsInUpdatingEntry.nextUpdatingTime - ticker.read() <= updatingTaskWindowNanos;\n+        }\n+\n+        private void addCurrentEndpoints(Builder<Endpoint> builder) {", "originalCommit": "5f27fbcdffadb64f3fe99851e67b2ae8172bc8bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAzOTEzNg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r544039136", "bodyText": "Changed the name to targetEndpointsBuilder as we discussed. Thanks!", "author": "minwoox", "createdAt": "2020-12-16T06:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAwMTMzNw=="}], "type": "inlineReview"}, {"oid": "ea8d1d0e90ac3dc7b50ad6f572711c915581956c", "url": "https://github.com/line/armeria/commit/ea8d1d0e90ac3dc7b50ad6f572711c915581956c", "message": "Address comments by @ikhoon", "committedDate": "2020-12-16T06:46:32Z", "type": "commit"}, {"oid": "7d2a1138ecb5fe5b581248bc3265c0f3699ff751", "url": "https://github.com/line/armeria/commit/7d2a1138ecb5fe5b581248bc3265c0f3699ff751", "message": "Add more tests", "committedDate": "2020-12-18T02:19:52Z", "type": "commit"}, {"oid": "25202b7ad4e88fa93e4956b854b9475519e5d89c", "url": "https://github.com/line/armeria/commit/25202b7ad4e88fa93e4956b854b9475519e5d89c", "message": "Rename to WeightRampingUp", "committedDate": "2020-12-18T02:46:14Z", "type": "commit"}, {"oid": "27391d8a6edb59a90659432000a73bca72926977", "url": "https://github.com/line/armeria/commit/27391d8a6edb59a90659432000a73bca72926977", "message": "Aggregate same endpoints", "committedDate": "2020-12-18T03:49:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwNjkxOQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r547106919", "bodyText": "This if condition seems not to work properly. Regardless of it, this block will return 0", "author": "ikhoon", "createdAt": "2020-12-22T07:12:07Z", "path": "core/src/test/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategyTest.java", "diffHunk": "@@ -0,0 +1,536 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.linecorp.armeria.client.endpoint.EndpointWeightTransition.linear;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.EndpointsInUpdatingEntry;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.EndpointsInUpdatingEntry.EndpointAndStep;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.RampingUpEndpointWeightSelector;\n+import com.linecorp.armeria.client.endpoint.WeightedRandomDistributionEndpointSelector.Entry;\n+\n+final class WeightRampingUpStrategyTest {\n+\n+    private static final AtomicLong ticker = new AtomicLong();\n+\n+    private static final Queue<Runnable> scheduledJobs = new ConcurrentLinkedQueue<>();\n+    private static final Queue<ScheduledFuture<?>> scheduledFutures = new ConcurrentLinkedQueue<>();\n+\n+    @BeforeEach\n+    void setUp() {\n+        ticker.set(0);\n+        scheduledJobs.clear();\n+        scheduledFutures.clear();\n+    }\n+\n+    @Test\n+    void endpointIsRemovedIfNotInNewEndpoints() {\n+        final DynamicEndpointGroup endpointGroup = new DynamicEndpointGroup();\n+        final RampingUpEndpointWeightSelector selector = setInitialEndpoints(endpointGroup, 2);\n+        ticker.addAndGet(1);\n+        // Because we set only foo1.com, foo.com is removed.\n+        endpointGroup.setEndpoints(ImmutableList.of(Endpoint.of(\"foo1.com\")));\n+        final List<Endpoint> endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactly(\n+                                              Endpoint.of(\"foo1.com\")\n+                                      );\n+    }\n+\n+    @Test\n+    void updatingWeightIsDoneAfterNumberOfSteps() {\n+        final DynamicEndpointGroup endpointGroup = new DynamicEndpointGroup();\n+        final RampingUpEndpointWeightSelector selector = setInitialEndpoints(endpointGroup, 2);\n+        ticker.addAndGet(1);\n+        endpointGroup.addEndpoint(Endpoint.of(\"bar.com\"));\n+        Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = selector.endpointsInUpdatingEntries;\n+        assertThat(endpointsInUpdatingEntries).hasSize(1);\n+        final Set<EndpointAndStep> endpointAndSteps = endpointsInUpdatingEntries.peek().endpointAndSteps();\n+        assertThat(endpointAndSteps).containsExactly(\n+                endpointAndStep(Endpoint.of(\"bar.com\"), 1, 500));\n+        List<Endpoint> endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\"),\n+                                              Endpoint.of(\"bar.com\").withWeight(500)\n+                                      );\n+\n+        ticker.addAndGet(TimeUnit.SECONDS.toNanos(20));\n+        scheduledJobs.poll().run();\n+        // Updating weight is done because the step reached the numberOfSteps.\n+\n+        endpointsInUpdatingEntries = selector.endpointsInUpdatingEntries;\n+        assertThat(endpointsInUpdatingEntries).isEmpty();\n+        endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\"),\n+                                              Endpoint.of(\"bar.com\")\n+                                      );\n+    }\n+\n+    @Test\n+    void endpointsAreAddedToPreviousEntry_IfTheyAreAddedWithinWindow() {\n+        final DynamicEndpointGroup endpointGroup = new DynamicEndpointGroup();\n+        final RampingUpEndpointWeightSelector selector = setInitialEndpoints(endpointGroup, 10);\n+\n+        ticker.addAndGet(1);\n+\n+        addSecondEndpoints(endpointGroup, selector);\n+\n+        ticker.addAndGet(1);\n+\n+        endpointGroup.addEndpoint(Endpoint.of(\"baz.com\"));\n+        endpointGroup.addEndpoint(Endpoint.of(\"baz1.com\"));\n+\n+        final Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = selector.endpointsInUpdatingEntries;\n+        assertThat(endpointsInUpdatingEntries).hasSize(1);\n+        final Set<EndpointAndStep> endpointAndSteps1 = endpointsInUpdatingEntries.peek().endpointAndSteps();\n+        assertThat(endpointAndSteps1).containsExactlyInAnyOrder(\n+                endpointAndStep(Endpoint.of(\"bar.com\"), 1, 100),\n+                endpointAndStep(Endpoint.of(\"bar1.com\"), 1, 100),\n+                endpointAndStep(Endpoint.of(\"baz.com\"), 1, 100),\n+                endpointAndStep(Endpoint.of(\"baz1.com\"), 1, 100));\n+        final List<Endpoint> endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\"),\n+                                              Endpoint.of(\"bar.com\").withWeight(100),\n+                                              Endpoint.of(\"bar1.com\").withWeight(100),\n+                                              Endpoint.of(\"baz.com\").withWeight(100),\n+                                              Endpoint.of(\"baz1.com\").withWeight(100)\n+                                      );\n+    }\n+\n+    @Test\n+    void endpointsAreAddedToNextEntry_IfTheyAreAddedWithinWindow() {\n+        final DynamicEndpointGroup endpointGroup = new DynamicEndpointGroup();\n+        final RampingUpEndpointWeightSelector selector = setInitialEndpoints(endpointGroup, 10);\n+        ticker.addAndGet(1);\n+\n+        addSecondEndpoints(endpointGroup, selector);\n+\n+        // Add 19 seconds so now it's within the window of second updating weight of bar.com and bar1.com.\n+        ticker.addAndGet(TimeUnit.SECONDS.toNanos(19));\n+\n+        // baz endpoint is not calculated and removed because it's overridden by the next setEndpoints() call.\n+        endpointGroup.addEndpoint(Endpoint.of(\"baz.com\"));\n+        Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = selector.endpointsInUpdatingEntries;\n+        assertThat(endpointsInUpdatingEntries).hasSize(1);\n+        final Set<EndpointAndStep> endpointAndSteps1 = endpointsInUpdatingEntries.peek().endpointAndSteps();\n+        assertThat(endpointAndSteps1).containsExactlyInAnyOrder(\n+                endpointAndStep(Endpoint.of(\"bar.com\"), 1, 100),\n+                endpointAndStep(Endpoint.of(\"bar1.com\"), 1, 100));\n+        List<Endpoint> endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\"),\n+                                              Endpoint.of(\"bar.com\").withWeight(100),\n+                                              Endpoint.of(\"bar1.com\").withWeight(100)\n+                                      );\n+\n+        // The weights of qux.com and qux1.com will be updated with bar.com and bar1.com.\n+        endpointGroup.setEndpoints(ImmutableList.of(Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\"),\n+                                                    Endpoint.of(\"bar.com\"), Endpoint.of(\"bar1.com\"),\n+                                                    Endpoint.of(\"qux.com\"), Endpoint.of(\"qux1.com\")));\n+\n+        ticker.addAndGet(TimeUnit.SECONDS.toNanos(1));\n+        scheduledJobs.poll().run();\n+        endpointsInUpdatingEntries = selector.endpointsInUpdatingEntries;\n+        assertThat(endpointsInUpdatingEntries).hasSize(1);\n+        final Set<EndpointAndStep> endpointAndSteps2 = endpointsInUpdatingEntries.peek().endpointAndSteps();\n+        assertThat(endpointAndSteps2).containsExactlyInAnyOrder(\n+                endpointAndStep(Endpoint.of(\"bar.com\"), 2, 200),\n+                endpointAndStep(Endpoint.of(\"bar1.com\"), 2, 200),\n+                endpointAndStep(Endpoint.of(\"qux.com\"), 1, 100),\n+                endpointAndStep(Endpoint.of(\"qux1.com\"), 1, 100));\n+        endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\"),\n+                                              // 1000 * (2 / 10) => weight * (step / numberOfSteps)\n+                                              Endpoint.of(\"bar.com\").withWeight(200),\n+                                              Endpoint.of(\"bar1.com\").withWeight(200),\n+                                              // 1000 * (1 / 10) => weight * (step / numberOfSteps)\n+                                              Endpoint.of(\"qux.com\").withWeight(100),\n+                                              Endpoint.of(\"qux1.com\").withWeight(100)\n+                                      );\n+    }\n+\n+    @Test\n+    void setEndpointWithDifferentWeight() {\n+        final DynamicEndpointGroup endpointGroup = new DynamicEndpointGroup();\n+        final RampingUpEndpointWeightSelector selector = setInitialEndpoints(endpointGroup, 10);\n+        ticker.addAndGet(1);\n+\n+        // Set an endpoint with the weight which is lower than current weight so updating weight is\n+        // not happening for the endpoint.\n+        endpointGroup.setEndpoints(\n+                ImmutableList.of(Endpoint.of(\"foo.com\").withWeight(100), Endpoint.of(\"foo1.com\")));\n+        Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = selector.endpointsInUpdatingEntries;\n+        assertThat(endpointsInUpdatingEntries).hasSize(0);\n+        List<Endpoint> endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              Endpoint.of(\"foo.com\").withWeight(100), Endpoint.of(\"foo1.com\")\n+                                      );\n+\n+        // Set an endpoint with the weight which is greater than current weight so updating weight is scheduled.\n+        endpointGroup.setEndpoints(ImmutableList.of(Endpoint.of(\"foo.com\").withWeight(3000),\n+                                                    Endpoint.of(\"foo1.com\"),\n+                                                    Endpoint.of(\"bar.com\")));\n+\n+        endpointsInUpdatingEntries = selector.endpointsInUpdatingEntries;\n+        assertThat(endpointsInUpdatingEntries).hasSize(1);\n+        Set<EndpointAndStep> endpointAndSteps = endpointsInUpdatingEntries.peek().endpointAndSteps();\n+        assertThat(endpointAndSteps).containsExactlyInAnyOrder(\n+                endpointAndStep(Endpoint.of(\"foo.com\").withWeight(3000), 1, 300),\n+                endpointAndStep(Endpoint.of(\"bar.com\"), 1, 100));\n+        endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              Endpoint.of(\"foo.com\").withWeight(300), Endpoint.of(\"foo1.com\"),\n+                                              Endpoint.of(\"bar.com\").withWeight(100)\n+                                      );\n+\n+        // Execute the scheduled job so the weight is updated.\n+        ticker.addAndGet(TimeUnit.SECONDS.toNanos(20));\n+        scheduledJobs.poll().run();\n+\n+        endpointsInUpdatingEntries = selector.endpointsInUpdatingEntries;\n+        assertThat(endpointsInUpdatingEntries).hasSize(1);\n+        endpointAndSteps = endpointsInUpdatingEntries.peek().endpointAndSteps();\n+        assertThat(endpointAndSteps).containsExactlyInAnyOrder(\n+                endpointAndStep(Endpoint.of(\"foo.com\").withWeight(3000), 2, 600),\n+                endpointAndStep(Endpoint.of(\"bar.com\"), 2, 200));\n+        endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              // 3000 * 2 / 10 = 600\n+                                              Endpoint.of(\"foo.com\").withWeight(600), Endpoint.of(\"foo1.com\"),\n+                                              Endpoint.of(\"bar.com\").withWeight(200)\n+                                      );\n+\n+        ticker.addAndGet(1);\n+\n+        // Set an endpoint with the weight which is lower than current weight so scheduling is canceled.\n+        endpointGroup.setEndpoints(ImmutableList.of(Endpoint.of(\"foo.com\").withWeight(599),\n+                                                    Endpoint.of(\"foo1.com\"),\n+                                                    Endpoint.of(\"bar.com\")));\n+        endpointsInUpdatingEntries = selector.endpointsInUpdatingEntries;\n+        assertThat(endpointsInUpdatingEntries).hasSize(1);\n+        assertThat(endpointAndSteps).containsExactly(\n+                endpointAndStep(Endpoint.of(\"bar.com\"), 2, 200));\n+        endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              Endpoint.of(\"foo.com\").withWeight(599), Endpoint.of(\"foo1.com\"),\n+                                              Endpoint.of(\"bar.com\").withWeight(200)\n+                                      );\n+    }\n+\n+    @Test\n+    void endpointsInUpdatingAreRemoved() {\n+        final DynamicEndpointGroup endpointGroup = new DynamicEndpointGroup();\n+        final RampingUpEndpointWeightSelector selector = setInitialEndpoints(endpointGroup, 10);\n+\n+        ticker.addAndGet(1);\n+\n+        addSecondEndpoints(endpointGroup, selector);\n+\n+        ticker.addAndGet(1);\n+\n+        // bar1.com is removed and the weight of bar.com is updated.\n+        endpointGroup.setEndpoints(ImmutableList.of(Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\"),\n+                                                    Endpoint.of(\"bar.com\").withWeight(3000)));\n+\n+        final Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = selector.endpointsInUpdatingEntries;\n+        assertThat(endpointsInUpdatingEntries).hasSize(1);\n+        final Set<EndpointAndStep> endpointAndSteps = endpointsInUpdatingEntries.peek().endpointAndSteps();\n+        assertThat(endpointAndSteps).containsExactly(\n+                endpointAndStep(Endpoint.of(\"bar.com\").withWeight(3000), 1, 300));\n+        List<Endpoint> endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\"),\n+                                              Endpoint.of(\"bar.com\").withWeight(300)\n+                                      );\n+\n+        ticker.addAndGet(1);\n+        // bar.com is removed.\n+        endpointGroup.setEndpoints(ImmutableList.of(Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\")));\n+        assertThat(endpointsInUpdatingEntries).isEmpty();\n+        endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\")\n+                                      );\n+        assertThat(scheduledFutures).hasSize(1);\n+        verify(scheduledFutures.poll(), times(1)).cancel(true);\n+    }\n+\n+    @Test\n+    void sameEndpointsAreSummed() {\n+        final DynamicEndpointGroup endpointGroup = new DynamicEndpointGroup();\n+        final RampingUpEndpointWeightSelector selector = setInitialEndpoints(endpointGroup, 10);\n+\n+        ticker.addAndGet(1);\n+\n+        addSecondEndpoints(endpointGroup, selector);\n+\n+        ticker.addAndGet(1);\n+\n+        // The three bar.com are converted into onw bar.com with 3000 weight.\n+        endpointGroup.setEndpoints(ImmutableList.of(Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\"),\n+                                                    Endpoint.of(\"bar.com\"), Endpoint.of(\"bar.com\"),\n+                                                    Endpoint.of(\"bar.com\"), Endpoint.of(\"bar1.com\")));\n+\n+        final Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = selector.endpointsInUpdatingEntries;\n+        assertThat(endpointsInUpdatingEntries).hasSize(1);\n+        final Set<EndpointAndStep> endpointAndSteps = endpointsInUpdatingEntries.peek().endpointAndSteps();\n+        assertThat(endpointAndSteps).containsExactlyInAnyOrder(\n+                endpointAndStep(Endpoint.of(\"bar.com\").withWeight(3000), 1, 300),\n+                endpointAndStep(Endpoint.of(\"bar1.com\"), 1, 100)\n+                );\n+        final List<Endpoint> endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\"),\n+                                              Endpoint.of(\"bar.com\").withWeight(300),\n+                                              Endpoint.of(\"bar1.com\").withWeight(100)\n+                                      );\n+    }\n+\n+    @Test\n+    void scheduledIsCanceledWhenEndpointGroupIsClosed() {\n+        final DynamicEndpointGroup endpointGroup = new DynamicEndpointGroup();\n+        final RampingUpEndpointWeightSelector selector = setInitialEndpoints(endpointGroup, 10);\n+\n+        ticker.addAndGet(1);\n+\n+        addSecondEndpoints(endpointGroup, selector);\n+        assertThat(scheduledFutures).hasSize(1);\n+\n+        ticker.addAndGet(TimeUnit.SECONDS.toNanos(10));\n+\n+        endpointGroup.addEndpoint(Endpoint.of(\"baz.com\"));\n+        endpointGroup.addEndpoint(Endpoint.of(\"baz1.com\"));\n+        assertThat(scheduledFutures).hasSize(2);\n+\n+        endpointGroup.close();\n+\n+        ScheduledFuture<?> scheduledFuture;\n+        while ((scheduledFuture = scheduledFutures.poll()) != null) {\n+            verify(scheduledFuture, times(1)).cancel(true);\n+        }\n+    }\n+\n+    private static RampingUpEndpointWeightSelector setInitialEndpoints(DynamicEndpointGroup endpointGroup,\n+                                                                       int numberOfSteps) {\n+        final WeightRampingUpStrategy strategy =\n+                new WeightRampingUpStrategy(linear(), new ImmediateExecutor(),\n+                                            20000, numberOfSteps, 1000, ticker::get);\n+\n+        final List<Endpoint> endpoints = ImmutableList.of(Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\"));\n+        endpointGroup.setEndpoints(endpoints);\n+        final RampingUpEndpointWeightSelector selector =\n+                (RampingUpEndpointWeightSelector) strategy.newSelector(endpointGroup);\n+\n+        final List<Endpoint> endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\")\n+                                      );\n+        return selector;\n+    }\n+\n+    private static List<Endpoint> endpointsFromSelectorEntry(RampingUpEndpointWeightSelector selector) {\n+        final ImmutableList.Builder<Endpoint> builder = new ImmutableList.Builder<>();\n+        final List<Entry> entries = selector.endpointSelector().entries();\n+        entries.forEach(entry -> builder.add(entry.endpoint()));\n+        return builder.build();\n+    }\n+\n+    private void addSecondEndpoints(DynamicEndpointGroup endpointGroup,\n+                                    RampingUpEndpointWeightSelector selector) {\n+        endpointGroup.addEndpoint(Endpoint.of(\"bar.com\"));\n+        endpointGroup.addEndpoint(Endpoint.of(\"bar1.com\"));\n+\n+        final Deque<EndpointsInUpdatingEntry> endpointsInUpdatingEntries = selector.endpointsInUpdatingEntries;\n+        assertThat(endpointsInUpdatingEntries).hasSize(1);\n+        final Set<EndpointAndStep> endpointAndSteps = endpointsInUpdatingEntries.peek().endpointAndSteps();\n+        assertThat(endpointAndSteps).containsExactlyInAnyOrder(\n+                endpointAndStep(Endpoint.of(\"bar.com\"), 1, 100),\n+                endpointAndStep(Endpoint.of(\"bar1.com\"), 1, 100));\n+        final List<Endpoint> endpointsFromEntry = endpointsFromSelectorEntry(selector);\n+        assertThat(endpointsFromEntry).usingElementComparator(new EndpointComparator())\n+                                      .containsExactlyInAnyOrder(\n+                                              Endpoint.of(\"foo.com\"), Endpoint.of(\"foo1.com\"),\n+                                              // 1000 * (1 / 10) => weight * (step / numberOfSteps)\n+                                              Endpoint.of(\"bar.com\").withWeight(100),\n+                                              Endpoint.of(\"bar1.com\").withWeight(100)\n+                                      );\n+    }\n+\n+    private static EndpointAndStep endpointAndStep(Endpoint endpoint, int step, int currentWeight) {\n+        final EndpointAndStep endpointAndStep = new EndpointAndStep(endpoint, step);\n+        endpointAndStep.currentWeight(currentWeight);\n+        return endpointAndStep;\n+    }\n+\n+    /**\n+     * A Comparator which includes the weight of an endpoint to compare.\n+     */\n+    static class EndpointComparator implements Comparator<Endpoint>, Serializable {\n+        private static final long serialVersionUID = -3534596922171048613L;\n+\n+        @Override\n+        public int compare(Endpoint o1, Endpoint o2) {\n+            if (o1.host().equals(o2.host()) &&\n+                Objects.equals(o1.ipAddr(), o2.ipAddr()) &&\n+                o1.weight() == o2.weight()) {\n+                if (o1.hasPort() || o2.hasPort() && o1.port() == o2.port()) {\n+                    return 0;\n+                }\n+                return 0;", "originalCommit": "27391d8a6edb59a90659432000a73bca72926977", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEyMTEwMA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r547121100", "bodyText": "\ud83d\ude31", "author": "minwoox", "createdAt": "2020-12-22T07:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwNjkxOQ=="}], "type": "inlineReview"}, {"oid": "e56ee24253c335c167847dabaf880c3769d2d46e", "url": "https://github.com/line/armeria/commit/e56ee24253c335c167847dabaf880c3769d2d46e", "message": "Address the comment by @ikhoon", "committedDate": "2020-12-24T12:21:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NDc3NQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r548794775", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Builds a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of the newly added\n          \n          \n            \n             * Builds a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added", "author": "anuraaga", "createdAt": "2020-12-25T04:04:26Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of the newly added", "originalCommit": "e56ee24253c335c167847dabaf880c3769d2d46e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NTI0OQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r548795249", "bodyText": "I'm still wondering about this use of list removal. If the endpoints are fixed, then intuitively it seems that nothing should be removed. Instead, we can keep track of valid / invalid entries, possibly as a boolean on the entry itself, possibly as a map to boolean. For example, I'm wondering with a high request rate, does this not cause a lot of thrashing with constant creations of CoW list?", "author": "anuraaga", "createdAt": "2020-12-25T04:07:55Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightedRandomDistributionEndpointSelector.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+/**\n+ * This selector selects an {@link Endpoint} using random and the weight of the {@link Endpoint}. If there are\n+ * A(weight 10), B(weight 4) and C(weight 6) {@link Endpoint}s, the chances that {@link Endpoint}s are selected\n+ * are 10/20, 4/20 and 6/20, respectively. If A {@link Endpoint} is selected 10 times and B and C are not\n+ * selected as much as their weight, then A is removed temporarily and the the chances that B and C are selected\n+ * are 4/10 and 6/10.\n+ */\n+final class WeightedRandomDistributionEndpointSelector {\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private final List<Entry> currentEntries;\n+    private long currentTotalWeight;\n+\n+    WeightedRandomDistributionEndpointSelector(List<Endpoint> endpoints) {\n+        final ImmutableList.Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            if (endpoint.weight() <= 0) {\n+                continue;\n+            }\n+            builder.add(new Entry(endpoint));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+        currentEntries = new CopyOnWriteArrayList<>(entries);\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        Endpoint selected = null;\n+        for (;;) {\n+            long nextLong = ThreadLocalRandom.current().nextLong(currentTotalWeight);\n+            // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+            // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+            // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+            for (Entry entry : currentEntries) {\n+                final int weight = entry.endpoint().weight();\n+                nextLong -= weight;\n+                if (nextLong < 0) {\n+                    if (entry.increaseCounter()) {\n+                        selected = entry.endpoint();\n+                    }\n+                    if (!entry.isFull()) {\n+                        break;\n+                    }\n+\n+                    // The entry is full so we should remove the entry from currentEntries.\n+                    synchronized (currentEntries) {\n+                        // Check again not to remove the entry where reset() is called by another thread.\n+                        if (entry.isFull()) {\n+                            if (currentEntries.remove(entry)) {", "originalCommit": "e56ee24253c335c167847dabaf880c3769d2d46e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NTQ3Nw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r548795477", "bodyText": "Or even without high request rate, it seems like if the weights look something like 1, 1, 2, this list will get recreated a ton since the entries fill up every request. Maybe this isn't intended usage of this endpoint selector but it seems fragile.", "author": "anuraaga", "createdAt": "2020-12-25T04:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NTI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5ODMzMA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r548798330", "bodyText": "Thinking about it, BitSet seems like it should work great for tracking removal of indices in a list. clear will be extremely fast.", "author": "anuraaga", "createdAt": "2020-12-25T04:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NTI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTIyNjE1NQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r549226155", "bodyText": "I'm still wondering about this use of list removal.\n\nBecause we don't pre-calculate the weight anymore, we don't need to remove the entry from the list. \ud83d\ude04  PTAL.", "author": "minwoox", "createdAt": "2020-12-28T06:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NTI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NzIzMA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r548797230", "bodyText": "This class is pretty hard to understand from the code, I think it can use a high level design javadoc explaining what it does, how various stages interact with each other (select endpoint, ramp up weight, update list of endpoints). One thing I couldn't answer from looking at the code is whether when the endpoints list is updated, do we only ramp up new endpoints or ramp them all up again.\nAlso, did you consider handling ramping as part of \"select endpoint\" instead of using a background executor? I think it could be easier to reason about, not sure about effect on performance though since I guess it would require a lock, but that could stop once the endpoints are all ramped.", "author": "anuraaga", "createdAt": "2020-12-25T04:23:49Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategy.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.EndpointsInUpdatingEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+final class WeightRampingUpStrategy implements EndpointSelectionStrategy {", "originalCommit": "e56ee24253c335c167847dabaf880c3769d2d46e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTIyNTk2Mw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r549225963", "bodyText": "did you consider handling ramping as part of \"select endpoint\" instead of using a background executor?\n\nI thought selecting endpoint and ramping together will make the code more complicated. If we handle it together, every time before selecting an endpoint, we should check whether there are endpoints that need to be ramped up. Then, we should ramp up the weight and select an endpoint using the new weights.\n\nOne thing I couldn't answer from looking at the code is whether when the endpoints list is updated, do we only ramp up new endpoints or ramp them all up again.\n\nWe only ramp up new endpoints. Should we ramp them all up?\n\nThis class is pretty hard to understand from the code, I think it can use a high level design javadoc explaining what it does\n\nAdd more Javadocs and rename some variables. PTAL. \ud83d\ude47", "author": "minwoox", "createdAt": "2020-12-28T06:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NzIzMA=="}], "type": "inlineReview"}, {"oid": "78b8b11301c5269a70b8f3258d6d19eabb83740e", "url": "https://github.com/line/armeria/commit/78b8b11301c5269a70b8f3258d6d19eabb83740e", "message": "Address comments by @anuraaga", "committedDate": "2020-12-28T05:28:56Z", "type": "commit"}, {"oid": "d142548e8e95baa498f9fe21d206488d810df0f2", "url": "https://github.com/line/armeria/commit/d142548e8e95baa498f9fe21d206488d810df0f2", "message": "Fix javadoc", "committedDate": "2020-12-28T05:50:31Z", "type": "commit"}, {"oid": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "url": "https://github.com/line/armeria/commit/5ef089c779cac8ee886c7cff690389d6c6ccb834", "message": "Rename methods", "committedDate": "2020-12-28T06:54:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5MjMxOQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r551892319", "bodyText": "Sets the specified ... doesn't sound right to me. How about Sets <the description of the value> with the specified ...?", "author": "trustin", "createdAt": "2021-01-05T12:07:26Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s. The {@link Endpoint} is selected using weighted random distribution.\n+ */\n+public final class WeightRampingUpStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS = 500;\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private ScheduledExecutorService executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int totalSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long rampingUpTaskWindowMillis = DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS;\n+\n+    /**\n+     * Sets the specified {@link EndpointWeightTransition} that will compute the weight of an {@link Endpoint}", "originalCommit": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI4OTIzOQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r553289239", "bodyText": "As I talked to @trustin, I was not sure if this was awkward. \ud83d\ude05\n@anuraaga Could you help me with this, please?", "author": "minwoox", "createdAt": "2021-01-07T12:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5MjMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5Mjg0Mw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r551892843", "bodyText": "several Endpoints -> more than one Endpoint", "author": "trustin", "createdAt": "2021-01-05T12:08:29Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s. The {@link Endpoint} is selected using weighted random distribution.\n+ */\n+public final class WeightRampingUpStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS = 500;\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private ScheduledExecutorService executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int totalSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long rampingUpTaskWindowMillis = DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS;\n+\n+    /**\n+     * Sets the specified {@link EndpointWeightTransition} that will compute the weight of an {@link Endpoint}\n+     * during the transition. {@link EndpointWeightTransition#linear()} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder transition(EndpointWeightTransition transition) {\n+        this.transition = requireNonNull(transition, \"transition\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link ScheduledExecutorService} that will be used to compute the weight of\n+     * an {@link Endpoint} using {@link EndpointWeightTransition}. An {@link EventLoop} from\n+     * {@link CommonPools#workerGroup()} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder executor(ScheduledExecutorService executor) {\n+        this.executor = requireNonNull(executor, \"executor\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpInterval}. The weight of an {@link Endpoint} is ramped up\n+     * every {@code rampingUpInterval} until the number of ramping reaches to the\n+     * {@link #totalSteps(int) totalSteps}.\n+     * {@value DEFAULT_RAMPING_UP_INTERVAL_MILLIS} millis is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder rampingUpInterval(Duration rampingUpInterval) {\n+        requireNonNull(rampingUpInterval, \"rampingUpInterval\");\n+        return rampingUpIntervalMillis(rampingUpInterval.toMillis());\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpIntervalMillis}. The weight of an {@link Endpoint} is ramped up\n+     * every {@code rampingUpIntervalMillis} until the number of ramping reaches to the\n+     * {@link #totalSteps(int) totalSteps}.\n+     * {@value DEFAULT_RAMPING_UP_INTERVAL_MILLIS} millis is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder rampingUpIntervalMillis(long rampingUpIntervalMillis) {\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (expected: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code totalSteps}. The weight of an {@link Endpoint} is ramped up\n+     * every {@link #rampingUpIntervalMillis(long) rampingUpIntervalMillis}\n+     * until the number of ramping reaches to the {@code totalSteps}.\n+     * {@value DEFAULT_NUMBER_OF_STEPS} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder totalSteps(int totalSteps) {\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpTaskWindow} which will be used to combine weight ramping up task.\n+     * If several {@link Endpoint}s are added within the {@code rampingUpTaskWindow}, the weights of", "originalCommit": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5MzkwMA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r551893900", "bodyText": "A Endpoint -> Endpoint A", "author": "trustin", "createdAt": "2021-01-05T12:11:07Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightedRandomDistributionEndpointSelector.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+/**\n+ * This selector selects an {@link Endpoint} using random and the weight of the {@link Endpoint}. If there are\n+ * A(weight 10), B(weight 4) and C(weight 6) {@link Endpoint}s, the chances that {@link Endpoint}s are selected\n+ * are 10/20, 4/20 and 6/20, respectively. If A {@link Endpoint} is selected 10 times and B and C are not", "originalCommit": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5NDUwOA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r551894508", "bodyText": "Could get ThreadLocalRandom before beginning the loop so we don't have to access TLV every time.", "author": "trustin", "createdAt": "2021-01-05T12:12:33Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightedRandomDistributionEndpointSelector.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+/**\n+ * This selector selects an {@link Endpoint} using random and the weight of the {@link Endpoint}. If there are\n+ * A(weight 10), B(weight 4) and C(weight 6) {@link Endpoint}s, the chances that {@link Endpoint}s are selected\n+ * are 10/20, 4/20 and 6/20, respectively. If A {@link Endpoint} is selected 10 times and B and C are not\n+ * selected as much as their weight, then A is removed temporarily and the the chances that B and C are selected\n+ * are 4/10 and 6/10.\n+ */\n+final class WeightedRandomDistributionEndpointSelector {\n+\n+    private static final AtomicLongFieldUpdater<WeightedRandomDistributionEndpointSelector> updater =\n+            AtomicLongFieldUpdater.newUpdater(\n+                    WeightedRandomDistributionEndpointSelector.class, \"currentTotalWeight\");\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private volatile long currentTotalWeight;\n+\n+    WeightedRandomDistributionEndpointSelector(List<Endpoint> endpoints) {\n+        final ImmutableList.Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            if (endpoint.weight() <= 0) {\n+                continue;\n+            }\n+            builder.add(new Entry(endpoint));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        Endpoint selected = null;\n+        for (;;) {\n+            final long currentWeight = currentTotalWeight;\n+            if (currentWeight == 0) {\n+                // currentTotalWeight will become totalWeight as soon as it becomes 0 so we just loop again.\n+                continue;\n+            }\n+            long nextLong = ThreadLocalRandom.current().nextLong(currentWeight);", "originalCommit": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5NTA3Ng==", "url": "https://github.com/line/armeria/pull/3217#discussion_r551895076", "bodyText": "currentTotalWeightUpdater for readability", "author": "trustin", "createdAt": "2021-01-05T12:13:41Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightedRandomDistributionEndpointSelector.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+/**\n+ * This selector selects an {@link Endpoint} using random and the weight of the {@link Endpoint}. If there are\n+ * A(weight 10), B(weight 4) and C(weight 6) {@link Endpoint}s, the chances that {@link Endpoint}s are selected\n+ * are 10/20, 4/20 and 6/20, respectively. If A {@link Endpoint} is selected 10 times and B and C are not\n+ * selected as much as their weight, then A is removed temporarily and the the chances that B and C are selected\n+ * are 4/10 and 6/10.\n+ */\n+final class WeightedRandomDistributionEndpointSelector {\n+\n+    private static final AtomicLongFieldUpdater<WeightedRandomDistributionEndpointSelector> updater =", "originalCommit": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5Njk3Mg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r551896972", "bodyText": "This could be moved into the if (counter <= weight) { ... }.", "author": "trustin", "createdAt": "2021-01-05T12:17:56Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightedRandomDistributionEndpointSelector.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+/**\n+ * This selector selects an {@link Endpoint} using random and the weight of the {@link Endpoint}. If there are\n+ * A(weight 10), B(weight 4) and C(weight 6) {@link Endpoint}s, the chances that {@link Endpoint}s are selected\n+ * are 10/20, 4/20 and 6/20, respectively. If A {@link Endpoint} is selected 10 times and B and C are not\n+ * selected as much as their weight, then A is removed temporarily and the the chances that B and C are selected\n+ * are 4/10 and 6/10.\n+ */\n+final class WeightedRandomDistributionEndpointSelector {\n+\n+    private static final AtomicLongFieldUpdater<WeightedRandomDistributionEndpointSelector> updater =\n+            AtomicLongFieldUpdater.newUpdater(\n+                    WeightedRandomDistributionEndpointSelector.class, \"currentTotalWeight\");\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private volatile long currentTotalWeight;\n+\n+    WeightedRandomDistributionEndpointSelector(List<Endpoint> endpoints) {\n+        final ImmutableList.Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            if (endpoint.weight() <= 0) {\n+                continue;\n+            }\n+            builder.add(new Entry(endpoint));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        Endpoint selected = null;\n+        for (;;) {\n+            final long currentWeight = currentTotalWeight;\n+            if (currentWeight == 0) {\n+                // currentTotalWeight will become totalWeight as soon as it becomes 0 so we just loop again.\n+                continue;\n+            }\n+            long nextLong = ThreadLocalRandom.current().nextLong(currentWeight);\n+            // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+            // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+            // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+            for (Entry entry : entries) {\n+                if (entry.isFull()) {\n+                    continue;\n+                }\n+                final Endpoint endpoint = entry.endpoint();\n+                final int weight = endpoint.weight();\n+                nextLong -= weight;\n+                if (nextLong < 0) {\n+                    final int counter = entry.incrementAndGet();\n+                    if (counter <= weight) {\n+                        selected = endpoint;\n+                    }\n+                    if (counter == weight) {\n+                        decreaseCurrentTotalWeight(weight);\n+                    }", "originalCommit": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5OTU1MQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r551899551", "bodyText": "Should we use newWeight here?\nIs there any chance where newWeight becomes a negative value due to a race condition?", "author": "trustin", "createdAt": "2021-01-05T12:23:52Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightedRandomDistributionEndpointSelector.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+/**\n+ * This selector selects an {@link Endpoint} using random and the weight of the {@link Endpoint}. If there are\n+ * A(weight 10), B(weight 4) and C(weight 6) {@link Endpoint}s, the chances that {@link Endpoint}s are selected\n+ * are 10/20, 4/20 and 6/20, respectively. If A {@link Endpoint} is selected 10 times and B and C are not\n+ * selected as much as their weight, then A is removed temporarily and the the chances that B and C are selected\n+ * are 4/10 and 6/10.\n+ */\n+final class WeightedRandomDistributionEndpointSelector {\n+\n+    private static final AtomicLongFieldUpdater<WeightedRandomDistributionEndpointSelector> updater =\n+            AtomicLongFieldUpdater.newUpdater(\n+                    WeightedRandomDistributionEndpointSelector.class, \"currentTotalWeight\");\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private volatile long currentTotalWeight;\n+\n+    WeightedRandomDistributionEndpointSelector(List<Endpoint> endpoints) {\n+        final ImmutableList.Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            if (endpoint.weight() <= 0) {\n+                continue;\n+            }\n+            builder.add(new Entry(endpoint));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        Endpoint selected = null;\n+        for (;;) {\n+            final long currentWeight = currentTotalWeight;\n+            if (currentWeight == 0) {\n+                // currentTotalWeight will become totalWeight as soon as it becomes 0 so we just loop again.\n+                continue;\n+            }\n+            long nextLong = ThreadLocalRandom.current().nextLong(currentWeight);\n+            // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+            // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+            // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+            for (Entry entry : entries) {\n+                if (entry.isFull()) {\n+                    continue;\n+                }\n+                final Endpoint endpoint = entry.endpoint();\n+                final int weight = endpoint.weight();\n+                nextLong -= weight;\n+                if (nextLong < 0) {\n+                    final int counter = entry.incrementAndGet();\n+                    if (counter <= weight) {\n+                        selected = endpoint;\n+                    }\n+                    if (counter == weight) {\n+                        decreaseCurrentTotalWeight(weight);\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            if (selected != null) {\n+                return selected;\n+            }\n+        }\n+    }\n+\n+    private void decreaseCurrentTotalWeight(int weight) {\n+        for (;;) {\n+            final long oldWeight = currentTotalWeight;\n+            final long newWeight = oldWeight - weight;\n+            if (updater.compareAndSet(this, oldWeight, newWeight)) {\n+                if (currentTotalWeight == 0) {", "originalCommit": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMzMDExOA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r552330118", "bodyText": "There's no chance because the weight is decreased by the thread that hits the counter of entry to the weight. (i.e the weight of each entry is decreased by only once. \ud83d\ude04 )\nWill use newWeight. Thanks!", "author": "minwoox", "createdAt": "2021-01-06T02:30:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5OTU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwODkwMQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r551908901", "bodyText": "deduplicateEndpoints()?", "author": "trustin", "createdAt": "2021-01-05T12:44:01Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategy.java", "diffHunk": "@@ -0,0 +1,493 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.RampingUpEndpointsEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+/**\n+ * A ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s using {@link EndpointWeightTransition},\n+ * {@code rampingUpIntervalMillis} and {@code rampingUpTaskWindow}.\n+ * If several {@link Endpoint}s are added within the {@code rampingUpTaskWindow}, the weights of\n+ * them are updated together. If there's already a scheduled job and new {@link Endpoint}s are added\n+ * within the {@code rampingUpTaskWindow}, they are updated together.\n+ * This is an example of how it works when {@code rampingUpTaskWindow} is 500 milliseconds and\n+ * {@code rampingUpIntervalMillis} is 2000 milliseconds:\n+ * <pre>{@code\n+ * ----------------------------------------------------------------------------------------------------\n+ *     A         B                             C                                       D\n+ *     t0        t1                            t2                                      t3         t4\n+ * ----------------------------------------------------------------------------------------------------\n+ *     0ms       t0 + 200ms                    t0 + 1000ms                          t0 + 1800ms  t0 + 2000ms\n+ * }</pre>\n+ * A and B are ramped up right away when they are added and they are ramped up together at t4.\n+ * C is updated alone every 2000 milliseconds. D is ramped up together with A and B at t4.\n+ */\n+final class WeightRampingUpStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker defaultTicker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long rampingUpTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, totalSteps, rampingUpTaskWindowMillis,\n+             defaultTicker);\n+    }\n+\n+    @VisibleForTesting\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(rampingUpTaskWindowMillis >= 0,\n+                      \"rampingUpTaskWindowMillis: %s (rampingUpTaskWindowMillis: >0 0)\",\n+                      rampingUpTaskWindowMillis);\n+        rampingUpTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(rampingUpTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightedRandomDistributionEndpointSelector endpointSelector;\n+\n+        private final List<Endpoint> settledEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<RampingUpEndpointsEntry> rampingUpEndpointsEntries = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints =\n+                    new ArrayList<>(removeDuplicateEndpoints(endpointGroup.endpoints()).values());\n+            endpointSelector = new WeightedRandomDistributionEndpointSelector(initialEndpoints);\n+            settledEndpoints.addAll(initialEndpoints);\n+            endpointGroup.addListener(this::updateEndpoints);\n+            if (endpointGroup instanceof DynamicEndpointGroup) {\n+                ((DynamicEndpointGroup) endpointGroup).whenClosed().thenRunAsync(this::close, executor);\n+            }\n+        }\n+\n+        /**\n+         * Removes the duplicate endpoints in the specified {@code newEndpoints} and returns a new map\n+         * that contains unique endpoints.\n+         * The value of the map is the {@link Endpoint} whose {@link Endpoint#weight()} is the summed weight of\n+         * same {@link Endpoint}s.\n+         */\n+        private Map<Endpoint, Endpoint> removeDuplicateEndpoints(List<Endpoint> newEndpoints) {", "originalCommit": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwOTcwMw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r551909703", "bodyText": "instanceof ListenableAsyncCloseable?", "author": "trustin", "createdAt": "2021-01-05T12:45:41Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategy.java", "diffHunk": "@@ -0,0 +1,493 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.RampingUpEndpointsEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+/**\n+ * A ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s using {@link EndpointWeightTransition},\n+ * {@code rampingUpIntervalMillis} and {@code rampingUpTaskWindow}.\n+ * If several {@link Endpoint}s are added within the {@code rampingUpTaskWindow}, the weights of\n+ * them are updated together. If there's already a scheduled job and new {@link Endpoint}s are added\n+ * within the {@code rampingUpTaskWindow}, they are updated together.\n+ * This is an example of how it works when {@code rampingUpTaskWindow} is 500 milliseconds and\n+ * {@code rampingUpIntervalMillis} is 2000 milliseconds:\n+ * <pre>{@code\n+ * ----------------------------------------------------------------------------------------------------\n+ *     A         B                             C                                       D\n+ *     t0        t1                            t2                                      t3         t4\n+ * ----------------------------------------------------------------------------------------------------\n+ *     0ms       t0 + 200ms                    t0 + 1000ms                          t0 + 1800ms  t0 + 2000ms\n+ * }</pre>\n+ * A and B are ramped up right away when they are added and they are ramped up together at t4.\n+ * C is updated alone every 2000 milliseconds. D is ramped up together with A and B at t4.\n+ */\n+final class WeightRampingUpStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker defaultTicker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long rampingUpTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, totalSteps, rampingUpTaskWindowMillis,\n+             defaultTicker);\n+    }\n+\n+    @VisibleForTesting\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(rampingUpTaskWindowMillis >= 0,\n+                      \"rampingUpTaskWindowMillis: %s (rampingUpTaskWindowMillis: >0 0)\",\n+                      rampingUpTaskWindowMillis);\n+        rampingUpTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(rampingUpTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightedRandomDistributionEndpointSelector endpointSelector;\n+\n+        private final List<Endpoint> settledEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<RampingUpEndpointsEntry> rampingUpEndpointsEntries = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints =\n+                    new ArrayList<>(removeDuplicateEndpoints(endpointGroup.endpoints()).values());\n+            endpointSelector = new WeightedRandomDistributionEndpointSelector(initialEndpoints);\n+            settledEndpoints.addAll(initialEndpoints);\n+            endpointGroup.addListener(this::updateEndpoints);\n+            if (endpointGroup instanceof DynamicEndpointGroup) {", "originalCommit": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkxMDM1Nw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r551910357", "bodyText": "This method is referenced only once. How about just inlining it by using a lambda expression there?", "author": "trustin", "createdAt": "2021-01-05T12:46:54Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategy.java", "diffHunk": "@@ -0,0 +1,493 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.RampingUpEndpointsEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+/**\n+ * A ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s using {@link EndpointWeightTransition},\n+ * {@code rampingUpIntervalMillis} and {@code rampingUpTaskWindow}.\n+ * If several {@link Endpoint}s are added within the {@code rampingUpTaskWindow}, the weights of\n+ * them are updated together. If there's already a scheduled job and new {@link Endpoint}s are added\n+ * within the {@code rampingUpTaskWindow}, they are updated together.\n+ * This is an example of how it works when {@code rampingUpTaskWindow} is 500 milliseconds and\n+ * {@code rampingUpIntervalMillis} is 2000 milliseconds:\n+ * <pre>{@code\n+ * ----------------------------------------------------------------------------------------------------\n+ *     A         B                             C                                       D\n+ *     t0        t1                            t2                                      t3         t4\n+ * ----------------------------------------------------------------------------------------------------\n+ *     0ms       t0 + 200ms                    t0 + 1000ms                          t0 + 1800ms  t0 + 2000ms\n+ * }</pre>\n+ * A and B are ramped up right away when they are added and they are ramped up together at t4.\n+ * C is updated alone every 2000 milliseconds. D is ramped up together with A and B at t4.\n+ */\n+final class WeightRampingUpStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker defaultTicker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long rampingUpTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, totalSteps, rampingUpTaskWindowMillis,\n+             defaultTicker);\n+    }\n+\n+    @VisibleForTesting\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(rampingUpTaskWindowMillis >= 0,\n+                      \"rampingUpTaskWindowMillis: %s (rampingUpTaskWindowMillis: >0 0)\",\n+                      rampingUpTaskWindowMillis);\n+        rampingUpTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(rampingUpTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightedRandomDistributionEndpointSelector endpointSelector;\n+\n+        private final List<Endpoint> settledEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<RampingUpEndpointsEntry> rampingUpEndpointsEntries = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints =\n+                    new ArrayList<>(removeDuplicateEndpoints(endpointGroup.endpoints()).values());\n+            endpointSelector = new WeightedRandomDistributionEndpointSelector(initialEndpoints);\n+            settledEndpoints.addAll(initialEndpoints);\n+            endpointGroup.addListener(this::updateEndpoints);\n+            if (endpointGroup instanceof DynamicEndpointGroup) {\n+                ((DynamicEndpointGroup) endpointGroup).whenClosed().thenRunAsync(this::close, executor);\n+            }\n+        }\n+\n+        /**\n+         * Removes the duplicate endpoints in the specified {@code newEndpoints} and returns a new map\n+         * that contains unique endpoints.\n+         * The value of the map is the {@link Endpoint} whose {@link Endpoint#weight()} is the summed weight of\n+         * same {@link Endpoint}s.\n+         */\n+        private Map<Endpoint, Endpoint> removeDuplicateEndpoints(List<Endpoint> newEndpoints) {\n+            final Map<Endpoint, Endpoint> newEndpointsMap = new HashMap<>(newEndpoints.size());\n+\n+            // The weight of the same endpoints are summed.\n+            newEndpoints.forEach(\n+                    newEndpoint -> newEndpointsMap.compute(newEndpoint, (key, v) -> {\n+                        if (v == null) {\n+                            return newEndpoint;\n+                        }\n+                        final int weightSum = newEndpoint.weight() + v.weight();\n+                        return newEndpoint.withWeight(weightSum);\n+                    }));\n+            return newEndpointsMap;\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightedRandomDistributionEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {", "originalCommit": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkxNDQwMw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r551914403", "bodyText": "Then why do we consider step and currentWeight in equals()?", "author": "trustin", "createdAt": "2021-01-05T12:55:12Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategy.java", "diffHunk": "@@ -0,0 +1,493 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.RampingUpEndpointsEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+/**\n+ * A ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s using {@link EndpointWeightTransition},\n+ * {@code rampingUpIntervalMillis} and {@code rampingUpTaskWindow}.\n+ * If several {@link Endpoint}s are added within the {@code rampingUpTaskWindow}, the weights of\n+ * them are updated together. If there's already a scheduled job and new {@link Endpoint}s are added\n+ * within the {@code rampingUpTaskWindow}, they are updated together.\n+ * This is an example of how it works when {@code rampingUpTaskWindow} is 500 milliseconds and\n+ * {@code rampingUpIntervalMillis} is 2000 milliseconds:\n+ * <pre>{@code\n+ * ----------------------------------------------------------------------------------------------------\n+ *     A         B                             C                                       D\n+ *     t0        t1                            t2                                      t3         t4\n+ * ----------------------------------------------------------------------------------------------------\n+ *     0ms       t0 + 200ms                    t0 + 1000ms                          t0 + 1800ms  t0 + 2000ms\n+ * }</pre>\n+ * A and B are ramped up right away when they are added and they are ramped up together at t4.\n+ * C is updated alone every 2000 milliseconds. D is ramped up together with A and B at t4.\n+ */\n+final class WeightRampingUpStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker defaultTicker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long rampingUpTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, totalSteps, rampingUpTaskWindowMillis,\n+             defaultTicker);\n+    }\n+\n+    @VisibleForTesting\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(rampingUpTaskWindowMillis >= 0,\n+                      \"rampingUpTaskWindowMillis: %s (rampingUpTaskWindowMillis: >0 0)\",\n+                      rampingUpTaskWindowMillis);\n+        rampingUpTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(rampingUpTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightedRandomDistributionEndpointSelector endpointSelector;\n+\n+        private final List<Endpoint> settledEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<RampingUpEndpointsEntry> rampingUpEndpointsEntries = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints =\n+                    new ArrayList<>(removeDuplicateEndpoints(endpointGroup.endpoints()).values());\n+            endpointSelector = new WeightedRandomDistributionEndpointSelector(initialEndpoints);\n+            settledEndpoints.addAll(initialEndpoints);\n+            endpointGroup.addListener(this::updateEndpoints);\n+            if (endpointGroup instanceof DynamicEndpointGroup) {\n+                ((DynamicEndpointGroup) endpointGroup).whenClosed().thenRunAsync(this::close, executor);\n+            }\n+        }\n+\n+        /**\n+         * Removes the duplicate endpoints in the specified {@code newEndpoints} and returns a new map\n+         * that contains unique endpoints.\n+         * The value of the map is the {@link Endpoint} whose {@link Endpoint#weight()} is the summed weight of\n+         * same {@link Endpoint}s.\n+         */\n+        private Map<Endpoint, Endpoint> removeDuplicateEndpoints(List<Endpoint> newEndpoints) {\n+            final Map<Endpoint, Endpoint> newEndpointsMap = new HashMap<>(newEndpoints.size());\n+\n+            // The weight of the same endpoints are summed.\n+            newEndpoints.forEach(\n+                    newEndpoint -> newEndpointsMap.compute(newEndpoint, (key, v) -> {\n+                        if (v == null) {\n+                            return newEndpoint;\n+                        }\n+                        final int weightSum = newEndpoint.weight() + v.weight();\n+                        return newEndpoint.withWeight(weightSum);\n+                    }));\n+            return newEndpointsMap;\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightedRandomDistributionEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {\n+            // Use the executor so the order of endpoints change is guaranteed.\n+            executor.execute(() -> updateEndpoints0(newEndpoints));\n+        }\n+\n+        // Only executed by the executor.\n+        private void updateEndpoints0(List<Endpoint> newEndpoints) {\n+            unhandledNewEndpoints = null;\n+            if (rampingUpTaskWindowNanos > 0) {\n+                // Check whether we can ramp up with the previous ramped up endpoints which are at the last\n+                // of the rampingUpEndpointsEntries.\n+                if (canAddToPrevEntry()) {\n+                    final Set<EndpointAndStep> newlyAddedEndpoints = filterOldEndpoints(newEndpoints);\n+                    if (!newlyAddedEndpoints.isEmpty()) {\n+                        updateWeightAndStep(newlyAddedEndpoints);\n+                        rampingUpEndpointsEntries.getLast().addEndpoints(newlyAddedEndpoints);\n+                    }\n+                    buildEndpointSelector();\n+                    return;\n+                }\n+\n+                // Check whether we can ramp up with the next scheduled rampingUpEndpointsEntry.\n+                if (canAddToNextEntry()) {\n+                    // unhandledNewEndpoints will be ramped up when updateWeightAndStep() is executed.\n+                    unhandledNewEndpoints = newEndpoints;\n+                    return;\n+                }\n+            }\n+\n+            final Set<EndpointAndStep> newlyAddedEndpoints = filterOldEndpoints(newEndpoints);\n+            if (newlyAddedEndpoints.isEmpty()) {\n+                // newlyAddedEndpoints is empty which means that settledEndpoints are changed.\n+                // So rebuild the endpoint selector.\n+                buildEndpointSelector();\n+                return;\n+            }\n+\n+            updateWeightAndStep(newlyAddedEndpoints);\n+\n+            // Check again because newlyAddedEndpoints can be removed in the updateWeightAndStep method.\n+            if (!newlyAddedEndpoints.isEmpty()) {\n+                final ScheduledFuture<?> scheduledFuture = executor.scheduleAtFixedRate(\n+                        this::updateWeightAndStep, rampingUpIntervalMillis,\n+                        rampingUpIntervalMillis, TimeUnit.MILLISECONDS);\n+                final RampingUpEndpointsEntry entry = new RampingUpEndpointsEntry(\n+                        newlyAddedEndpoints, scheduledFuture, ticker, rampingUpIntervalMillis);\n+                rampingUpEndpointsEntries.add(entry);\n+            }\n+            buildEndpointSelector();\n+        }\n+\n+        private void buildEndpointSelector() {\n+            final ImmutableList.Builder<Endpoint> targetEndpointsBuilder = ImmutableList.builder();\n+            targetEndpointsBuilder.addAll(settledEndpoints);\n+            rampingUpEndpointsEntries.forEach(\n+                    entry -> entry.endpointAndSteps().forEach(\n+                            endpointAndStep -> targetEndpointsBuilder.add(\n+                                    endpointAndStep.endpoint().withWeight(endpointAndStep.currentWeight()))));\n+            endpointSelector = new WeightedRandomDistributionEndpointSelector(targetEndpointsBuilder.build());\n+        }\n+\n+        private boolean canAddToPrevEntry() {\n+            final RampingUpEndpointsEntry lastRampingUpEndpointsEntry = rampingUpEndpointsEntries.peekLast();\n+            return lastRampingUpEndpointsEntry != null &&\n+                   ticker.read() - lastRampingUpEndpointsEntry.lastUpdatedTime <= rampingUpTaskWindowNanos;\n+        }\n+\n+        private boolean canAddToNextEntry() {\n+            final RampingUpEndpointsEntry nextRampingUpEndpointsEntry = rampingUpEndpointsEntries.peek();\n+            return nextRampingUpEndpointsEntry != null &&\n+                   nextRampingUpEndpointsEntry.nextUpdatingTime - ticker.read() <= rampingUpTaskWindowNanos;\n+        }\n+\n+        /**\n+         * Removes endpoints in settledEndpoints and endpointsInUpdatingEntries that\n+         * newEndpoints do not contain.\n+         * This also returns the {@link Set} of {@link EndpointAndStep}s whose endpoints are not in\n+         * in settledEndpoints and endpointsInUpdatingEntries.\n+         */\n+        private Set<EndpointAndStep> filterOldEndpoints(List<Endpoint> newEndpoints) {\n+            final Map<Endpoint, Endpoint> newEndpointsMap = removeDuplicateEndpoints(newEndpoints);\n+\n+            final List<Endpoint> replacedSettledEndpoints = new ArrayList<>();\n+            for (final Iterator<Endpoint> i = settledEndpoints.iterator(); i.hasNext();) {\n+                final Endpoint settledEndpoint = i.next();\n+                final Endpoint newEndpoint = newEndpointsMap.remove(settledEndpoint);\n+                if (newEndpoint == null) {\n+                    // newEndpoints does not have this settled endpoint so we remove it.\n+                    i.remove();\n+                    continue;\n+                }\n+\n+                if (settledEndpoint.weight() > newEndpoint.weight()) {\n+                    // The weight of the new endpoint is lower than the settled endpoint so we just replace it\n+                    // because we don't have to ramp up the weight.\n+                    replacedSettledEndpoints.add(newEndpoint);\n+                    i.remove();\n+                } else if (settledEndpoint.weight() < newEndpoint.weight()) {\n+                    // The weight of the new endpoint is greater than the settled endpoint so we remove the\n+                    // settled one and put the newEndpoint back.\n+                    newEndpointsMap.put(newEndpoint, newEndpoint);\n+                    i.remove();\n+                } else {\n+                    // The weights are same so we keep the settled endpoint.\n+                }\n+            }\n+            if (!replacedSettledEndpoints.isEmpty()) {\n+                settledEndpoints.addAll(replacedSettledEndpoints);\n+            }\n+\n+            for (final Iterator<RampingUpEndpointsEntry> i = rampingUpEndpointsEntries.iterator();\n+                 i.hasNext();) {\n+                final RampingUpEndpointsEntry rampingUpEndpointsEntry = i.next();\n+\n+                final Set<EndpointAndStep> endpointAndSteps = rampingUpEndpointsEntry.endpointAndSteps();\n+                filterOldEndpoints(endpointAndSteps, newEndpointsMap);\n+                if (endpointAndSteps.isEmpty()) {\n+                    // All endpointAndSteps are removed so remove the entry completely.\n+                    i.remove();\n+                    rampingUpEndpointsEntry.scheduledFuture.cancel(true);\n+                }\n+            }\n+\n+            // At this point, newEndpointsMap only contains the new endpoints that have to be ramped up.\n+            if (newEndpointsMap.isEmpty()) {\n+                return ImmutableSet.of();\n+            }\n+            final Set<EndpointAndStep> newlyAddedEndpoints = new HashSet<>(newEndpointsMap.size());\n+            newEndpointsMap.values().forEach(\n+                    endpoint -> newlyAddedEndpoints.add(new EndpointAndStep(endpoint)));\n+            return newlyAddedEndpoints;\n+        }\n+\n+        private void filterOldEndpoints(Set<EndpointAndStep> endpointAndSteps,\n+                                        Map<Endpoint, Endpoint> newEndpointsMap) {\n+            final List<EndpointAndStep> replacedEndpoints = new ArrayList<>();\n+            for (final Iterator<EndpointAndStep> i = endpointAndSteps.iterator(); i.hasNext();) {\n+                final EndpointAndStep endpointAndStep = i.next();\n+                final Endpoint rampingUpEndpoint = endpointAndStep.endpoint();\n+                final Endpoint newEndpoint = newEndpointsMap.remove(rampingUpEndpoint);\n+                if (newEndpoint == null) {\n+                    // newEndpointsMap does not contain rampingUpEndpoint so just remove the endpoint.\n+                    i.remove();\n+                    continue;\n+                }\n+\n+                if (rampingUpEndpoint.weight() == newEndpoint.weight()) {\n+                    // Same weight so don't do anything. Ramping up happens as it is scheduled.\n+                } else if (endpointAndStep.currentWeight() > newEndpoint.weight()) {\n+                    // Don't need to update the weight anymore so we add the newEndpoint to settledEndpoints and\n+                    // remove it from the iterator.\n+                    settledEndpoints.add(newEndpoint);\n+                    i.remove();\n+                } else {\n+                    // Should replace the existing endpoint with the new one.\n+                    final int step = endpointAndStep.step();\n+                    final EndpointAndStep replaced = new EndpointAndStep(newEndpoint, step);\n+                    replaced.currentWeight(weightTransition.compute(newEndpoint, step, totalSteps));\n+                    replacedEndpoints.add(replaced);\n+                    i.remove();\n+                }\n+            }\n+\n+            if (!replacedEndpoints.isEmpty()) {\n+                endpointAndSteps.addAll(replacedEndpoints);\n+            }\n+        }\n+\n+        private void updateWeightAndStep() {\n+            if (unhandledNewEndpoints != null) {\n+                final Set<EndpointAndStep> newlyAddedEndpoints =\n+                        filterOldEndpoints(unhandledNewEndpoints);\n+                final RampingUpEndpointsEntry entry = rampingUpEndpointsEntries.peek();\n+                assert entry != null;\n+                entry.addEndpoints(newlyAddedEndpoints);\n+                unhandledNewEndpoints = null;\n+            }\n+            final RampingUpEndpointsEntry entry = rampingUpEndpointsEntries.poll();\n+            assert entry != null;\n+\n+            final Set<EndpointAndStep> endpointAndSteps = entry.endpointAndSteps();\n+            updateWeightAndStep(endpointAndSteps);\n+            if (endpointAndSteps.isEmpty()) {\n+                entry.scheduledFuture.cancel(true);\n+            } else {\n+                // Add to the last of the entries.\n+                rampingUpEndpointsEntries.add(entry);\n+                entry.updateWindowTimestamps();\n+            }\n+            buildEndpointSelector();\n+        }\n+\n+        private void updateWeightAndStep(Set<EndpointAndStep> endpointAndSteps) {\n+            for (final Iterator<EndpointAndStep> i = endpointAndSteps.iterator(); i.hasNext();) {\n+                final EndpointAndStep endpointAndStep = i.next();\n+                final int step = endpointAndStep.incrementAndGetStep();\n+                final Endpoint endpoint = endpointAndStep.endpoint();\n+                if (step == totalSteps) {\n+                    settledEndpoints.add(endpoint);\n+                    i.remove();\n+                } else {\n+                    final int calculated =\n+                            weightTransition.compute(endpoint, step, totalSteps);\n+                    final int currentWeight = Math.max(Math.min(calculated, endpoint.weight()), 0);\n+                    endpointAndStep.currentWeight(currentWeight);\n+                }\n+            }\n+        }\n+\n+        private void close() {\n+            RampingUpEndpointsEntry entry;\n+            while ((entry = rampingUpEndpointsEntries.poll()) != null) {\n+                entry.scheduledFuture.cancel(true);\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static final class RampingUpEndpointsEntry {\n+\n+        private final Set<EndpointAndStep> endpointAndSteps;\n+        private final Ticker ticker;\n+        private final long rampingUpIntervalNanos;\n+\n+        final ScheduledFuture<?> scheduledFuture;\n+        long lastUpdatedTime;\n+        long nextUpdatingTime;\n+\n+        RampingUpEndpointsEntry(Set<EndpointAndStep> endpointAndSteps, ScheduledFuture<?> scheduledFuture,\n+                                Ticker ticker, long rampingUpIntervalMillis) {\n+            this.endpointAndSteps = endpointAndSteps;\n+            this.scheduledFuture = scheduledFuture;\n+            this.ticker = ticker;\n+            rampingUpIntervalNanos = TimeUnit.MILLISECONDS.toNanos(rampingUpIntervalMillis);\n+            updateWindowTimestamps();\n+        }\n+\n+        Set<EndpointAndStep> endpointAndSteps() {\n+            return endpointAndSteps;\n+        }\n+\n+        void addEndpoints(Set<EndpointAndStep> endpoints) {\n+            endpointAndSteps.addAll(endpoints);\n+        }\n+\n+        void updateWindowTimestamps() {\n+            lastUpdatedTime = ticker.read();\n+            nextUpdatingTime = lastUpdatedTime + rampingUpIntervalNanos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return MoreObjects.toStringHelper(this)\n+                              .add(\"endpointAndSteps\", endpointAndSteps)\n+                              .add(\"ticker\", ticker)\n+                              .add(\"rampingUpIntervalNanos\", rampingUpIntervalNanos)\n+                              .add(\"scheduledFuture\", scheduledFuture)\n+                              .add(\"lastUpdatedTime\", lastUpdatedTime)\n+                              .add(\"nextUpdatingTime\", nextUpdatingTime)\n+                              .toString();\n+        }\n+\n+        @VisibleForTesting\n+        static final class EndpointAndStep {\n+\n+            private final Endpoint endpoint;\n+            private int step;\n+            private int currentWeight;\n+\n+            EndpointAndStep(Endpoint endpoint) {\n+                this(endpoint, 0);\n+            }\n+\n+            EndpointAndStep(Endpoint endpoint, int step) {\n+                this.endpoint = endpoint;\n+                this.step = step;\n+            }\n+\n+            int incrementAndGetStep() {\n+                return ++step;\n+            }\n+\n+            void currentWeight(int currentWeight) {\n+                this.currentWeight = currentWeight;\n+            }\n+\n+            int currentWeight() {\n+                return currentWeight;\n+            }\n+\n+            int step() {\n+                return step;\n+            }\n+\n+            Endpoint endpoint() {\n+                return endpoint;\n+            }\n+\n+            @Override\n+            public boolean equals(Object o) {\n+                if (this == o) {\n+                    return true;\n+                }\n+                if (o == null || getClass() != o.getClass()) {\n+                    return false;\n+                }\n+\n+                final EndpointAndStep that = (EndpointAndStep) o;\n+                // Use weight also.\n+                return endpoint.equals(that.endpoint) &&\n+                       endpoint.weight() == that.endpoint().weight() &&\n+                       step == that.step &&\n+                       currentWeight == that.currentWeight();\n+            }\n+\n+            @Override\n+            public int hashCode() {\n+                // Do not use step and currentWeight because they are changed during iteration.\n+                return endpoint.hashCode() * 31 + endpoint.weight();", "originalCommit": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMzMDI2Nw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r552330267", "bodyText": "Forgot to remove them. \ud83d\ude05  Thanks.", "author": "minwoox", "createdAt": "2021-01-06T02:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkxNDQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwNzIwMA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r552407200", "bodyText": "This seems like a state wrapper around Endpoint - does it ever make sense to use value comparison? Maybe can just use default object identity comparison instead.", "author": "anuraaga", "createdAt": "2021-01-06T07:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkxNDQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNzY3OA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r552417678", "bodyText": "I realized that I added step and currentWeight in equals() to use in the test code.\nLet me remove equals() and hashcode() and just use comparator in the test. Thanks!", "author": "minwoox", "createdAt": "2021-01-06T07:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkxNDQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkxNjExNg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r551916116", "bodyText": "How about endpointsFinishedRampingUp and endpointsRampingUp?", "author": "trustin", "createdAt": "2021-01-05T12:58:25Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategy.java", "diffHunk": "@@ -0,0 +1,493 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.RampingUpEndpointsEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+/**\n+ * A ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s using {@link EndpointWeightTransition},\n+ * {@code rampingUpIntervalMillis} and {@code rampingUpTaskWindow}.\n+ * If several {@link Endpoint}s are added within the {@code rampingUpTaskWindow}, the weights of\n+ * them are updated together. If there's already a scheduled job and new {@link Endpoint}s are added\n+ * within the {@code rampingUpTaskWindow}, they are updated together.\n+ * This is an example of how it works when {@code rampingUpTaskWindow} is 500 milliseconds and\n+ * {@code rampingUpIntervalMillis} is 2000 milliseconds:\n+ * <pre>{@code\n+ * ----------------------------------------------------------------------------------------------------\n+ *     A         B                             C                                       D\n+ *     t0        t1                            t2                                      t3         t4\n+ * ----------------------------------------------------------------------------------------------------\n+ *     0ms       t0 + 200ms                    t0 + 1000ms                          t0 + 1800ms  t0 + 2000ms\n+ * }</pre>\n+ * A and B are ramped up right away when they are added and they are ramped up together at t4.\n+ * C is updated alone every 2000 milliseconds. D is ramped up together with A and B at t4.\n+ */\n+final class WeightRampingUpStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker defaultTicker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long rampingUpTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, totalSteps, rampingUpTaskWindowMillis,\n+             defaultTicker);\n+    }\n+\n+    @VisibleForTesting\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(rampingUpTaskWindowMillis >= 0,\n+                      \"rampingUpTaskWindowMillis: %s (rampingUpTaskWindowMillis: >0 0)\",\n+                      rampingUpTaskWindowMillis);\n+        rampingUpTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(rampingUpTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightedRandomDistributionEndpointSelector endpointSelector;\n+\n+        private final List<Endpoint> settledEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<RampingUpEndpointsEntry> rampingUpEndpointsEntries = new ArrayDeque<>();", "originalCommit": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMzMDM0MA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r552330340", "bodyText": "That's a good naming.", "author": "minwoox", "createdAt": "2021-01-06T02:31:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkxNjExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkxNzI2MA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r551917260", "bodyText": "What happens if updateEndpoints0() is invoked before updateWeightAndStep() is invoked? Will the unhandledNewEndpoints here be set with null and lost?", "author": "trustin", "createdAt": "2021-01-05T13:00:48Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategy.java", "diffHunk": "@@ -0,0 +1,493 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.RampingUpEndpointsEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+/**\n+ * A ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s using {@link EndpointWeightTransition},\n+ * {@code rampingUpIntervalMillis} and {@code rampingUpTaskWindow}.\n+ * If several {@link Endpoint}s are added within the {@code rampingUpTaskWindow}, the weights of\n+ * them are updated together. If there's already a scheduled job and new {@link Endpoint}s are added\n+ * within the {@code rampingUpTaskWindow}, they are updated together.\n+ * This is an example of how it works when {@code rampingUpTaskWindow} is 500 milliseconds and\n+ * {@code rampingUpIntervalMillis} is 2000 milliseconds:\n+ * <pre>{@code\n+ * ----------------------------------------------------------------------------------------------------\n+ *     A         B                             C                                       D\n+ *     t0        t1                            t2                                      t3         t4\n+ * ----------------------------------------------------------------------------------------------------\n+ *     0ms       t0 + 200ms                    t0 + 1000ms                          t0 + 1800ms  t0 + 2000ms\n+ * }</pre>\n+ * A and B are ramped up right away when they are added and they are ramped up together at t4.\n+ * C is updated alone every 2000 milliseconds. D is ramped up together with A and B at t4.\n+ */\n+final class WeightRampingUpStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker defaultTicker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long rampingUpTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, totalSteps, rampingUpTaskWindowMillis,\n+             defaultTicker);\n+    }\n+\n+    @VisibleForTesting\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(rampingUpTaskWindowMillis >= 0,\n+                      \"rampingUpTaskWindowMillis: %s (rampingUpTaskWindowMillis: >0 0)\",\n+                      rampingUpTaskWindowMillis);\n+        rampingUpTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(rampingUpTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightedRandomDistributionEndpointSelector endpointSelector;\n+\n+        private final List<Endpoint> settledEndpoints = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<RampingUpEndpointsEntry> rampingUpEndpointsEntries = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints =\n+                    new ArrayList<>(removeDuplicateEndpoints(endpointGroup.endpoints()).values());\n+            endpointSelector = new WeightedRandomDistributionEndpointSelector(initialEndpoints);\n+            settledEndpoints.addAll(initialEndpoints);\n+            endpointGroup.addListener(this::updateEndpoints);\n+            if (endpointGroup instanceof DynamicEndpointGroup) {\n+                ((DynamicEndpointGroup) endpointGroup).whenClosed().thenRunAsync(this::close, executor);\n+            }\n+        }\n+\n+        /**\n+         * Removes the duplicate endpoints in the specified {@code newEndpoints} and returns a new map\n+         * that contains unique endpoints.\n+         * The value of the map is the {@link Endpoint} whose {@link Endpoint#weight()} is the summed weight of\n+         * same {@link Endpoint}s.\n+         */\n+        private Map<Endpoint, Endpoint> removeDuplicateEndpoints(List<Endpoint> newEndpoints) {\n+            final Map<Endpoint, Endpoint> newEndpointsMap = new HashMap<>(newEndpoints.size());\n+\n+            // The weight of the same endpoints are summed.\n+            newEndpoints.forEach(\n+                    newEndpoint -> newEndpointsMap.compute(newEndpoint, (key, v) -> {\n+                        if (v == null) {\n+                            return newEndpoint;\n+                        }\n+                        final int weightSum = newEndpoint.weight() + v.weight();\n+                        return newEndpoint.withWeight(weightSum);\n+                    }));\n+            return newEndpointsMap;\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightedRandomDistributionEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {\n+            // Use the executor so the order of endpoints change is guaranteed.\n+            executor.execute(() -> updateEndpoints0(newEndpoints));\n+        }\n+\n+        // Only executed by the executor.\n+        private void updateEndpoints0(List<Endpoint> newEndpoints) {\n+            unhandledNewEndpoints = null;\n+            if (rampingUpTaskWindowNanos > 0) {\n+                // Check whether we can ramp up with the previous ramped up endpoints which are at the last\n+                // of the rampingUpEndpointsEntries.\n+                if (canAddToPrevEntry()) {\n+                    final Set<EndpointAndStep> newlyAddedEndpoints = filterOldEndpoints(newEndpoints);\n+                    if (!newlyAddedEndpoints.isEmpty()) {\n+                        updateWeightAndStep(newlyAddedEndpoints);\n+                        rampingUpEndpointsEntries.getLast().addEndpoints(newlyAddedEndpoints);\n+                    }\n+                    buildEndpointSelector();\n+                    return;\n+                }\n+\n+                // Check whether we can ramp up with the next scheduled rampingUpEndpointsEntry.\n+                if (canAddToNextEntry()) {\n+                    // unhandledNewEndpoints will be ramped up when updateWeightAndStep() is executed.\n+                    unhandledNewEndpoints = newEndpoints;", "originalCommit": "5ef089c779cac8ee886c7cff690389d6c6ccb834", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMzMjgzNg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r552332836", "bodyText": "Yeah, it's lost and gone.\nLet's say that we are ramping:\na.com and b.com\nand they will be ramped up again like 100 milliseconds later.\nAnd let's say that updateEndpoints() is called with a.com, b.com and c.com.\nthe new endpoints are now assigned to the unhandledNewEndpoints.\nIf updateEndpoints() is called again (with a.com, b.com and d.com) before 100 milliseconds passed, then the previous unhandledNewEndpoints will be gone.\n(In this case the client never send the request to c.com)\nAfter 100 milliseconds passed a.com, b.com and d.com will be ramped up.", "author": "minwoox", "createdAt": "2021-01-06T02:41:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkxNzI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxNDAxNQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r552414015", "bodyText": "OK. That makes sense.", "author": "trustin", "createdAt": "2021-01-06T07:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkxNzI2MA=="}], "type": "inlineReview"}, {"oid": "586bcbc7632f7b838db8ab36d935b0c97fe3cf89", "url": "https://github.com/line/armeria/commit/586bcbc7632f7b838db8ab36d935b0c97fe3cf89", "message": "Address comments by @trustin", "committedDate": "2021-01-06T04:46:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwNDY1NA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r552404654", "bodyText": "I think this drifted, I don't see settledEndpoints anywhere.", "author": "anuraaga", "createdAt": "2021-01-06T07:07:14Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategy.java", "diffHunk": "@@ -0,0 +1,490 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.EndpointsRampingUpEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.ListenableAsyncCloseable;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+/**\n+ * A ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s using {@link EndpointWeightTransition},\n+ * {@code rampingUpIntervalMillis} and {@code rampingUpTaskWindow}.\n+ * If more than one {@link Endpoint} are added within the {@code rampingUpTaskWindow}, the weights of\n+ * them are updated together. If there's already a scheduled job and new {@link Endpoint}s are added\n+ * within the {@code rampingUpTaskWindow}, they are updated together.\n+ * This is an example of how it works when {@code rampingUpTaskWindow} is 500 milliseconds and\n+ * {@code rampingUpIntervalMillis} is 2000 milliseconds:\n+ * <pre>{@code\n+ * ----------------------------------------------------------------------------------------------------\n+ *     A         B                             C                                       D\n+ *     t0        t1                            t2                                      t3         t4\n+ * ----------------------------------------------------------------------------------------------------\n+ *     0ms       t0 + 200ms                    t0 + 1000ms                          t0 + 1800ms  t0 + 2000ms\n+ * }</pre>\n+ * A and B are ramped up right away when they are added and they are ramped up together at t4.\n+ * C is updated alone every 2000 milliseconds. D is ramped up together with A and B at t4.\n+ */\n+final class WeightRampingUpStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker defaultTicker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long rampingUpTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, totalSteps, rampingUpTaskWindowMillis,\n+             defaultTicker);\n+    }\n+\n+    @VisibleForTesting\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(rampingUpTaskWindowMillis >= 0,\n+                      \"rampingUpTaskWindowMillis: %s (rampingUpTaskWindowMillis: >0 0)\",\n+                      rampingUpTaskWindowMillis);\n+        rampingUpTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(rampingUpTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightedRandomDistributionEndpointSelector endpointSelector;\n+\n+        private final List<Endpoint> endpointsFinishedRampingUp = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<EndpointsRampingUpEntry> endpointsRampingUp = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints =\n+                    new ArrayList<>(deduplicateEndpoints(endpointGroup.endpoints()).values());\n+            endpointSelector = new WeightedRandomDistributionEndpointSelector(initialEndpoints);\n+            endpointsFinishedRampingUp.addAll(initialEndpoints);\n+            endpointGroup.addListener(newEndpoints -> {\n+                // Use the executor so the order of endpoints change is guaranteed.\n+                executor.execute(() -> updateEndpoints(newEndpoints));\n+            });\n+            if (endpointGroup instanceof ListenableAsyncCloseable) {\n+                ((ListenableAsyncCloseable) endpointGroup).whenClosed().thenRunAsync(this::close, executor);\n+            }\n+        }\n+\n+        /**\n+         * Removes the duplicate endpoints in the specified {@code newEndpoints} and returns a new map\n+         * that contains unique endpoints.\n+         * The value of the map is the {@link Endpoint} whose {@link Endpoint#weight()} is the summed weight of\n+         * same {@link Endpoint}s.\n+         */\n+        private Map<Endpoint, Endpoint> deduplicateEndpoints(List<Endpoint> newEndpoints) {\n+            final Map<Endpoint, Endpoint> newEndpointsMap = new HashMap<>(newEndpoints.size());\n+\n+            // The weight of the same endpoints are summed.\n+            newEndpoints.forEach(\n+                    newEndpoint -> newEndpointsMap.compute(newEndpoint, (key, v) -> {\n+                        if (v == null) {\n+                            return newEndpoint;\n+                        }\n+                        final int weightSum = newEndpoint.weight() + v.weight();\n+                        return newEndpoint.withWeight(weightSum);\n+                    }));\n+            return newEndpointsMap;\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightedRandomDistributionEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        // Only executed by the executor.\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {\n+            unhandledNewEndpoints = null;\n+            if (rampingUpTaskWindowNanos > 0) {\n+                // Check whether we can ramp up with the previous ramped up endpoints which are at the last\n+                // of the rampingUpEndpointsEntries.\n+                if (shouldRampUpWithPreviousRampedUpEntry()) {\n+                    final Set<EndpointAndStep> newlyAddedEndpoints = filterOldEndpoints(newEndpoints);\n+                    if (!newlyAddedEndpoints.isEmpty()) {\n+                        updateWeightAndStep(newlyAddedEndpoints);\n+                        endpointsRampingUp.getLast().addEndpoints(newlyAddedEndpoints);\n+                    }\n+                    buildEndpointSelector();\n+                    return;\n+                }\n+\n+                // Check whether we can ramp up with the next scheduled endpointsRampingUpEntry.\n+                if (shouldRampUpWithNextScheduledEntry()) {\n+                    // unhandledNewEndpoints will be ramped up when updateWeightAndStep() is executed.\n+                    unhandledNewEndpoints = newEndpoints;\n+                    return;\n+                }\n+            }\n+\n+            final Set<EndpointAndStep> newlyAddedEndpoints = filterOldEndpoints(newEndpoints);\n+            if (newlyAddedEndpoints.isEmpty()) {\n+                // newlyAddedEndpoints is empty which means that settledEndpoints are changed.", "originalCommit": "586bcbc7632f7b838db8ab36d935b0c97fe3cf89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxMjE5Mg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r552412192", "bodyText": "Oops. \ud83d\ude05", "author": "minwoox", "createdAt": "2021-01-06T07:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwNDY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwOTc2MQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r552409761", "bodyText": "Does addAndGet(this, -weight) == 0 without a spin work? This spin looks very suspicious at first glance (no chance of infinite spin?), if we can remove it then problem gone.", "author": "anuraaga", "createdAt": "2021-01-06T07:24:02Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightedRandomDistributionEndpointSelector.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+/**\n+ * This selector selects an {@link Endpoint} using random and the weight of the {@link Endpoint}. If there are\n+ * A(weight 10), B(weight 4) and C(weight 6) {@link Endpoint}s, the chances that {@link Endpoint}s are selected\n+ * are 10/20, 4/20 and 6/20, respectively. If {@link Endpoint} A is selected 10 times and B and C are not\n+ * selected as much as their weight, then A is removed temporarily and the the chances that B and C are selected\n+ * are 4/10 and 6/10.\n+ */\n+final class WeightedRandomDistributionEndpointSelector {\n+\n+    private static final AtomicLongFieldUpdater<WeightedRandomDistributionEndpointSelector>\n+            currentTotalWeightUpdater =\n+            AtomicLongFieldUpdater.newUpdater(\n+                    WeightedRandomDistributionEndpointSelector.class, \"currentTotalWeight\");\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private volatile long currentTotalWeight;\n+\n+    WeightedRandomDistributionEndpointSelector(List<Endpoint> endpoints) {\n+        final ImmutableList.Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            if (endpoint.weight() <= 0) {\n+                continue;\n+            }\n+            builder.add(new Entry(endpoint));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        final ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n+        Endpoint selected = null;\n+        for (;;) {\n+            final long currentWeight = currentTotalWeight;\n+            if (currentWeight == 0) {\n+                // currentTotalWeight will become totalWeight as soon as it becomes 0 so we just loop again.\n+                continue;\n+            }\n+            long nextLong = threadLocalRandom.nextLong(currentWeight);\n+            // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+            // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+            // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+            for (Entry entry : entries) {\n+                if (entry.isFull()) {\n+                    continue;\n+                }\n+                final Endpoint endpoint = entry.endpoint();\n+                final int weight = endpoint.weight();\n+                nextLong -= weight;\n+                if (nextLong < 0) {\n+                    final int counter = entry.incrementAndGet();\n+                    if (counter <= weight) {\n+                        selected = endpoint;\n+                        if (counter == weight) {\n+                            decreaseCurrentTotalWeight(weight);\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            if (selected != null) {\n+                return selected;\n+            }\n+        }\n+    }\n+\n+    private void decreaseCurrentTotalWeight(int weight) {\n+        for (;;) {\n+            final long oldWeight = currentTotalWeight;\n+            final long newWeight = oldWeight - weight;\n+            if (currentTotalWeightUpdater.compareAndSet(this, oldWeight, newWeight)) {", "originalCommit": "586bcbc7632f7b838db8ab36d935b0c97fe3cf89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQxMjY4OQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r552412689", "bodyText": "That's a good suggestion.", "author": "minwoox", "createdAt": "2021-01-06T07:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwOTc2MQ=="}], "type": "inlineReview"}, {"oid": "331b2fa53b403f26a433ee18a70d8c0a41111008", "url": "https://github.com/line/armeria/commit/331b2fa53b403f26a433ee18a70d8c0a41111008", "message": "Address comments by @anuraaga", "committedDate": "2021-01-06T08:25:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA4MDk0OA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r553080948", "bodyText": "Some unintended files?", "author": "anuraaga", "createdAt": "2021-01-07T02:54:21Z", "path": "tomcat8/tomcat.8080/work/Tomcat/localhost/ROOT/org/apache/jsp/index_jsp.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*", "originalCommit": "331b2fa53b403f26a433ee18a70d8c0a41111008", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA4NDg1Mg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r553084852", "bodyText": "\ud83d\ude05", "author": "minwoox", "createdAt": "2021-01-07T03:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA4MDk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzEyOTc1OQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r553129759", "bodyText": "Please update the Javadoc of all setter methods like you did in transition().", "author": "trustin", "createdAt": "2021-01-07T06:17:30Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s. The {@link Endpoint} is selected using weighted random distribution.\n+ */\n+public final class WeightRampingUpStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS = 500;\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private ScheduledExecutorService executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int totalSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long rampingUpTaskWindowMillis = DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS;\n+\n+    /**\n+     * Sets computing the weight of an {@link Endpoint} during the transition with the specified\n+     * {@link EndpointWeightTransition}. {@link EndpointWeightTransition#linear()} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder transition(EndpointWeightTransition transition) {\n+        this.transition = requireNonNull(transition, \"transition\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link ScheduledExecutorService} that will be used to compute the weight of", "originalCommit": "331b2fa53b403f26a433ee18a70d8c0a41111008", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "54074dd880c0dc469bc8428afe1566490b95b716", "url": "https://github.com/line/armeria/commit/54074dd880c0dc469bc8428afe1566490b95b716", "message": "Remove unnecessary generated tomcat files", "committedDate": "2021-01-07T14:14:08Z", "type": "commit"}, {"oid": "95e992c4233c9ac6f882d976cf7114bc37d8b917", "url": "https://github.com/line/armeria/commit/95e992c4233c9ac6f882d976cf7114bc37d8b917", "message": "Merge branch 'master' into cslb_slowStart", "committedDate": "2021-01-07T14:16:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDY3NTY4Mg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554675682", "bodyText": "Sets the EndpointWeightTransition which will be used to compute the weight at each step while ramping up.", "author": "anuraaga", "createdAt": "2021-01-11T03:42:58Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s. The {@link Endpoint} is selected using weighted random distribution.\n+ */\n+public final class WeightRampingUpStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS = 500;\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private ScheduledExecutorService executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int totalSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long rampingUpTaskWindowMillis = DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS;\n+\n+    /**\n+     * Sets computing the weight of an {@link Endpoint} during the transition with the specified", "originalCommit": "95e992c4233c9ac6f882d976cf7114bc37d8b917", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDY3NTkzMQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554675931", "bodyText": "Sets the ScheduledExecutorService to use to execute tasks for computing new weights.\nBy the way is it safe for this to be multi threaded or should it accept a netty type instead?", "author": "anuraaga", "createdAt": "2021-01-11T03:44:28Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s. The {@link Endpoint} is selected using weighted random distribution.\n+ */\n+public final class WeightRampingUpStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS = 500;\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private ScheduledExecutorService executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int totalSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long rampingUpTaskWindowMillis = DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS;\n+\n+    /**\n+     * Sets computing the weight of an {@link Endpoint} during the transition with the specified\n+     * {@link EndpointWeightTransition}. {@link EndpointWeightTransition#linear()} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder transition(EndpointWeightTransition transition) {\n+        this.transition = requireNonNull(transition, \"transition\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link ScheduledExecutorService} that will be used to compute the weight of", "originalCommit": "95e992c4233c9ac6f882d976cf7114bc37d8b917", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDc1MjgxNw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554752817", "bodyText": "Oh, it should be single-threaded. Let me use EventExecutor. Thanks!", "author": "minwoox", "createdAt": "2021-01-11T05:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDY3NTkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDY3NjEwMQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554676101", "bodyText": "Sets the interval between weight updates during ramp up.", "author": "anuraaga", "createdAt": "2021-01-11T03:45:29Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s. The {@link Endpoint} is selected using weighted random distribution.\n+ */\n+public final class WeightRampingUpStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS = 500;\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private ScheduledExecutorService executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int totalSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long rampingUpTaskWindowMillis = DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS;\n+\n+    /**\n+     * Sets computing the weight of an {@link Endpoint} during the transition with the specified\n+     * {@link EndpointWeightTransition}. {@link EndpointWeightTransition#linear()} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder transition(EndpointWeightTransition transition) {\n+        this.transition = requireNonNull(transition, \"transition\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link ScheduledExecutorService} that will be used to compute the weight of\n+     * an {@link Endpoint} using {@link EndpointWeightTransition}. An {@link EventLoop} from\n+     * {@link CommonPools#workerGroup()} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder executor(ScheduledExecutorService executor) {\n+        this.executor = requireNonNull(executor, \"executor\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpInterval}. The weight of an {@link Endpoint} is ramped up", "originalCommit": "95e992c4233c9ac6f882d976cf7114bc37d8b917", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDY3NjIzMg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554676232", "bodyText": "Sets the number of steps to compute weights for a given endpoint while ramping up.", "author": "anuraaga", "createdAt": "2021-01-11T03:46:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s. The {@link Endpoint} is selected using weighted random distribution.\n+ */\n+public final class WeightRampingUpStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS = 500;\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private ScheduledExecutorService executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int totalSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long rampingUpTaskWindowMillis = DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS;\n+\n+    /**\n+     * Sets computing the weight of an {@link Endpoint} during the transition with the specified\n+     * {@link EndpointWeightTransition}. {@link EndpointWeightTransition#linear()} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder transition(EndpointWeightTransition transition) {\n+        this.transition = requireNonNull(transition, \"transition\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link ScheduledExecutorService} that will be used to compute the weight of\n+     * an {@link Endpoint} using {@link EndpointWeightTransition}. An {@link EventLoop} from\n+     * {@link CommonPools#workerGroup()} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder executor(ScheduledExecutorService executor) {\n+        this.executor = requireNonNull(executor, \"executor\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpInterval}. The weight of an {@link Endpoint} is ramped up\n+     * every {@code rampingUpInterval} until the number of ramping reaches to the\n+     * {@link #totalSteps(int) totalSteps}.\n+     * {@value DEFAULT_RAMPING_UP_INTERVAL_MILLIS} millis is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder rampingUpInterval(Duration rampingUpInterval) {\n+        requireNonNull(rampingUpInterval, \"rampingUpInterval\");\n+        return rampingUpIntervalMillis(rampingUpInterval.toMillis());\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpIntervalMillis}. The weight of an {@link Endpoint} is ramped up\n+     * every {@code rampingUpIntervalMillis} until the number of ramping reaches to the\n+     * {@link #totalSteps(int) totalSteps}.\n+     * {@value DEFAULT_RAMPING_UP_INTERVAL_MILLIS} millis is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder rampingUpIntervalMillis(long rampingUpIntervalMillis) {\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (expected: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code totalSteps}. The weight of an {@link Endpoint} is ramped up", "originalCommit": "95e992c4233c9ac6f882d976cf7114bc37d8b917", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDY3NjMxMQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554676311", "bodyText": "numberSteps maybe better, its not so much a total.", "author": "anuraaga", "createdAt": "2021-01-11T03:46:42Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s. The {@link Endpoint} is selected using weighted random distribution.\n+ */\n+public final class WeightRampingUpStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS = 500;\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private ScheduledExecutorService executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int totalSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long rampingUpTaskWindowMillis = DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS;\n+\n+    /**\n+     * Sets computing the weight of an {@link Endpoint} during the transition with the specified\n+     * {@link EndpointWeightTransition}. {@link EndpointWeightTransition#linear()} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder transition(EndpointWeightTransition transition) {\n+        this.transition = requireNonNull(transition, \"transition\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link ScheduledExecutorService} that will be used to compute the weight of\n+     * an {@link Endpoint} using {@link EndpointWeightTransition}. An {@link EventLoop} from\n+     * {@link CommonPools#workerGroup()} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder executor(ScheduledExecutorService executor) {\n+        this.executor = requireNonNull(executor, \"executor\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpInterval}. The weight of an {@link Endpoint} is ramped up\n+     * every {@code rampingUpInterval} until the number of ramping reaches to the\n+     * {@link #totalSteps(int) totalSteps}.\n+     * {@value DEFAULT_RAMPING_UP_INTERVAL_MILLIS} millis is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder rampingUpInterval(Duration rampingUpInterval) {\n+        requireNonNull(rampingUpInterval, \"rampingUpInterval\");\n+        return rampingUpIntervalMillis(rampingUpInterval.toMillis());\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpIntervalMillis}. The weight of an {@link Endpoint} is ramped up\n+     * every {@code rampingUpIntervalMillis} until the number of ramping reaches to the\n+     * {@link #totalSteps(int) totalSteps}.\n+     * {@value DEFAULT_RAMPING_UP_INTERVAL_MILLIS} millis is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder rampingUpIntervalMillis(long rampingUpIntervalMillis) {\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (expected: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code totalSteps}. The weight of an {@link Endpoint} is ramped up\n+     * every {@link #rampingUpIntervalMillis(long) rampingUpIntervalMillis}\n+     * until the number of ramping reaches to the {@code totalSteps}.\n+     * {@value DEFAULT_NUMBER_OF_STEPS} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder totalSteps(int totalSteps) {", "originalCommit": "95e992c4233c9ac6f882d976cf7114bc37d8b917", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDc3NTczNg==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554775736", "bodyText": "That's a good suggestion. \ud83d\udc4d", "author": "minwoox", "createdAt": "2021-01-11T06:11:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDY3NjMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDY3NjQzNQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554676435", "bodyText": "Sets the window for combining weight update tasks.", "author": "anuraaga", "createdAt": "2021-01-11T03:47:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * Builds a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s. The {@link Endpoint} is selected using weighted random distribution.\n+ */\n+public final class WeightRampingUpStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS = 500;\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private ScheduledExecutorService executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int totalSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long rampingUpTaskWindowMillis = DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS;\n+\n+    /**\n+     * Sets computing the weight of an {@link Endpoint} during the transition with the specified\n+     * {@link EndpointWeightTransition}. {@link EndpointWeightTransition#linear()} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder transition(EndpointWeightTransition transition) {\n+        this.transition = requireNonNull(transition, \"transition\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@link ScheduledExecutorService} that will be used to compute the weight of\n+     * an {@link Endpoint} using {@link EndpointWeightTransition}. An {@link EventLoop} from\n+     * {@link CommonPools#workerGroup()} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder executor(ScheduledExecutorService executor) {\n+        this.executor = requireNonNull(executor, \"executor\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpInterval}. The weight of an {@link Endpoint} is ramped up\n+     * every {@code rampingUpInterval} until the number of ramping reaches to the\n+     * {@link #totalSteps(int) totalSteps}.\n+     * {@value DEFAULT_RAMPING_UP_INTERVAL_MILLIS} millis is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder rampingUpInterval(Duration rampingUpInterval) {\n+        requireNonNull(rampingUpInterval, \"rampingUpInterval\");\n+        return rampingUpIntervalMillis(rampingUpInterval.toMillis());\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpIntervalMillis}. The weight of an {@link Endpoint} is ramped up\n+     * every {@code rampingUpIntervalMillis} until the number of ramping reaches to the\n+     * {@link #totalSteps(int) totalSteps}.\n+     * {@value DEFAULT_RAMPING_UP_INTERVAL_MILLIS} millis is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder rampingUpIntervalMillis(long rampingUpIntervalMillis) {\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (expected: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code totalSteps}. The weight of an {@link Endpoint} is ramped up\n+     * every {@link #rampingUpIntervalMillis(long) rampingUpIntervalMillis}\n+     * until the number of ramping reaches to the {@code totalSteps}.\n+     * {@value DEFAULT_NUMBER_OF_STEPS} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder totalSteps(int totalSteps) {\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the specified {@code rampingUpTaskWindow} which will be used to combine weight ramping up task.", "originalCommit": "95e992c4233c9ac6f882d976cf7114bc37d8b917", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "96a01dd629aaf3cce6be6bfd6da06bffef6df387", "url": "https://github.com/line/armeria/commit/96a01dd629aaf3cce6be6bfd6da06bffef6df387", "message": "Address comments by @anuraaga", "committedDate": "2021-01-11T06:10:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDgwNzI3MQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554807271", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sets the {@link EventExecutor} to use to execute tasks for computing new weights. the weight of\n          \n          \n            \n                 * Sets the {@link EventExecutor} to use to execute tasks for computing new weights. The weight of", "author": "anuraaga", "createdAt": "2021-01-11T06:52:30Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategyBuilder.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.time.Duration;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.common.CommonPools;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * Builds a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s. The {@link Endpoint} is selected using weighted random distribution.\n+ */\n+public final class WeightRampingUpStrategyBuilder {\n+\n+    private static final long DEFAULT_RAMPING_UP_INTERVAL_MILLIS = 2000;\n+    private static final int DEFAULT_NUMBER_OF_STEPS = 10;\n+    private static final int DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS = 500;\n+\n+    private EndpointWeightTransition transition = EndpointWeightTransition.linear();\n+\n+    @Nullable\n+    private EventExecutor executor;\n+\n+    private long rampingUpIntervalMillis = DEFAULT_RAMPING_UP_INTERVAL_MILLIS;\n+    private int numberSteps = DEFAULT_NUMBER_OF_STEPS;\n+    private long rampingUpTaskWindowMillis = DEFAULT_RAMPING_UP_ENTRY_WINDOW_MILLIS;\n+\n+    /**\n+     * Sets the {@link EndpointWeightTransition} which will be used to compute the weight at each step while\n+     * ramping up. {@link EndpointWeightTransition#linear()} is used by default.\n+     */\n+    public WeightRampingUpStrategyBuilder transition(EndpointWeightTransition transition) {\n+        this.transition = requireNonNull(transition, \"transition\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the {@link EventExecutor} to use to execute tasks for computing new weights. the weight of", "originalCommit": "96a01dd629aaf3cce6be6bfd6da06bffef6df387", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDgxNTM2Nw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554815367", "bodyText": "Oops fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2021-01-11T07:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDgwNzI3MQ=="}], "type": "inlineReview"}, {"oid": "1532ac12b8bcd0867c87b7d37155f0bd93b7c456", "url": "https://github.com/line/armeria/commit/1532ac12b8bcd0867c87b7d37155f0bd93b7c456", "message": "Fix javadoc", "committedDate": "2021-01-11T07:02:30Z", "type": "commit"}, {"oid": "eaee76b3542f1e529228937ecf9054652f984e61", "url": "https://github.com/line/armeria/commit/eaee76b3542f1e529228937ecf9054652f984e61", "message": "Fix tomcat test", "committedDate": "2021-01-11T07:25:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwNzg5Mw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r552407893", "bodyText": "nit: We can use groupBy of Stream for simplicity. Feel free to ignore this review.\nprivate Map<Endpoint, Endpoint> deduplicateEndpoints(List<Endpoint> newEndpoints) {\n    return newEndpoints.stream()\n                       .collect(groupingBy(e -> e, reducing(null, (a, b) -> {\n                           return a == null ? b : a.withWeight(a.weight() + b.weight());\n                       })));\n}", "author": "ikhoon", "createdAt": "2021-01-06T07:18:27Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategy.java", "diffHunk": "@@ -0,0 +1,490 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.EndpointsRampingUpEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.ListenableAsyncCloseable;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+/**\n+ * A ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s using {@link EndpointWeightTransition},\n+ * {@code rampingUpIntervalMillis} and {@code rampingUpTaskWindow}.\n+ * If more than one {@link Endpoint} are added within the {@code rampingUpTaskWindow}, the weights of\n+ * them are updated together. If there's already a scheduled job and new {@link Endpoint}s are added\n+ * within the {@code rampingUpTaskWindow}, they are updated together.\n+ * This is an example of how it works when {@code rampingUpTaskWindow} is 500 milliseconds and\n+ * {@code rampingUpIntervalMillis} is 2000 milliseconds:\n+ * <pre>{@code\n+ * ----------------------------------------------------------------------------------------------------\n+ *     A         B                             C                                       D\n+ *     t0        t1                            t2                                      t3         t4\n+ * ----------------------------------------------------------------------------------------------------\n+ *     0ms       t0 + 200ms                    t0 + 1000ms                          t0 + 1800ms  t0 + 2000ms\n+ * }</pre>\n+ * A and B are ramped up right away when they are added and they are ramped up together at t4.\n+ * C is updated alone every 2000 milliseconds. D is ramped up together with A and B at t4.\n+ */\n+final class WeightRampingUpStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker defaultTicker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final ScheduledExecutorService executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int totalSteps;\n+    private final long rampingUpTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, totalSteps, rampingUpTaskWindowMillis,\n+             defaultTicker);\n+    }\n+\n+    @VisibleForTesting\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            ScheduledExecutorService executor, long rampingUpIntervalMillis,\n+                            int totalSteps, long rampingUpTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(totalSteps > 0, \"totalSteps: %s (expected: > 0)\", totalSteps);\n+        this.totalSteps = totalSteps;\n+        checkArgument(rampingUpTaskWindowMillis >= 0,\n+                      \"rampingUpTaskWindowMillis: %s (rampingUpTaskWindowMillis: >0 0)\",\n+                      rampingUpTaskWindowMillis);\n+        rampingUpTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(rampingUpTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightedRandomDistributionEndpointSelector endpointSelector;\n+\n+        private final List<Endpoint> endpointsFinishedRampingUp = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<EndpointsRampingUpEntry> endpointsRampingUp = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints =\n+                    new ArrayList<>(deduplicateEndpoints(endpointGroup.endpoints()).values());\n+            endpointSelector = new WeightedRandomDistributionEndpointSelector(initialEndpoints);\n+            endpointsFinishedRampingUp.addAll(initialEndpoints);\n+            endpointGroup.addListener(newEndpoints -> {\n+                // Use the executor so the order of endpoints change is guaranteed.\n+                executor.execute(() -> updateEndpoints(newEndpoints));\n+            });\n+            if (endpointGroup instanceof ListenableAsyncCloseable) {\n+                ((ListenableAsyncCloseable) endpointGroup).whenClosed().thenRunAsync(this::close, executor);\n+            }\n+        }\n+\n+        /**\n+         * Removes the duplicate endpoints in the specified {@code newEndpoints} and returns a new map\n+         * that contains unique endpoints.\n+         * The value of the map is the {@link Endpoint} whose {@link Endpoint#weight()} is the summed weight of\n+         * same {@link Endpoint}s.\n+         */\n+        private Map<Endpoint, Endpoint> deduplicateEndpoints(List<Endpoint> newEndpoints) {\n+            final Map<Endpoint, Endpoint> newEndpointsMap = new HashMap<>(newEndpoints.size());\n+\n+            // The weight of the same endpoints are summed.\n+            newEndpoints.forEach(\n+                    newEndpoint -> newEndpointsMap.compute(newEndpoint, (key, v) -> {\n+                        if (v == null) {\n+                            return newEndpoint;", "originalCommit": "586bcbc7632f7b838db8ab36d935b0c97fe3cf89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDg1OTY2OA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554859668", "bodyText": "Let me just use the current code because I feel it's somehow not readable. \ud83d\ude04", "author": "minwoox", "createdAt": "2021-01-11T07:55:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwNzg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyODAwMA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r552428000", "bodyText": "Is this dead code?", "author": "ikhoon", "createdAt": "2021-01-06T08:15:09Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightedRandomDistributionEndpointSelector.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.Endpoint;\n+\n+/**\n+ * This selector selects an {@link Endpoint} using random and the weight of the {@link Endpoint}. If there are\n+ * A(weight 10), B(weight 4) and C(weight 6) {@link Endpoint}s, the chances that {@link Endpoint}s are selected\n+ * are 10/20, 4/20 and 6/20, respectively. If {@link Endpoint} A is selected 10 times and B and C are not\n+ * selected as much as their weight, then A is removed temporarily and the the chances that B and C are selected\n+ * are 4/10 and 6/10.\n+ */\n+final class WeightedRandomDistributionEndpointSelector {\n+\n+    private static final AtomicLongFieldUpdater<WeightedRandomDistributionEndpointSelector>\n+            currentTotalWeightUpdater =\n+            AtomicLongFieldUpdater.newUpdater(\n+                    WeightedRandomDistributionEndpointSelector.class, \"currentTotalWeight\");\n+\n+    private final List<Entry> entries;\n+    private final long totalWeight;\n+    private volatile long currentTotalWeight;\n+\n+    WeightedRandomDistributionEndpointSelector(List<Endpoint> endpoints) {\n+        final ImmutableList.Builder<Entry> builder = ImmutableList.builder();\n+\n+        long totalWeight = 0;\n+        for (Endpoint endpoint : endpoints) {\n+            if (endpoint.weight() <= 0) {\n+                continue;\n+            }\n+            builder.add(new Entry(endpoint));\n+            totalWeight += endpoint.weight();\n+        }\n+        this.totalWeight = totalWeight;\n+        currentTotalWeight = totalWeight;\n+        entries = builder.build();\n+    }\n+\n+    @VisibleForTesting\n+    List<Entry> entries() {\n+        return entries;\n+    }\n+\n+    @Nullable\n+    Endpoint selectEndpoint() {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        final ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();\n+        Endpoint selected = null;\n+        for (;;) {\n+            final long currentWeight = currentTotalWeight;\n+            if (currentWeight == 0) {\n+                // currentTotalWeight will become totalWeight as soon as it becomes 0 so we just loop again.\n+                continue;\n+            }\n+            long nextLong = threadLocalRandom.nextLong(currentWeight);\n+            // There's a chance that currentTotalWeight is changed before looping currentEntries.\n+            // However, we have counters and choosing an endpoint doesn't have to be exact so no big deal.\n+            // TODO(minwoox): Use binary search when the number of endpoints is greater than N.\n+            for (Entry entry : entries) {\n+                if (entry.isFull()) {\n+                    continue;\n+                }\n+                final Endpoint endpoint = entry.endpoint();\n+                final int weight = endpoint.weight();\n+                nextLong -= weight;\n+                if (nextLong < 0) {\n+                    final int counter = entry.incrementAndGet();\n+                    if (counter <= weight) {\n+                        selected = endpoint;\n+                        if (counter == weight) {\n+                            decreaseCurrentTotalWeight(weight);\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            if (selected != null) {\n+                return selected;\n+            }\n+        }\n+    }\n+\n+    private void decreaseCurrentTotalWeight(int weight) {\n+        for (;;) {\n+            final long oldWeight = currentTotalWeight;\n+            final long newWeight = oldWeight - weight;\n+            if (currentTotalWeightUpdater.compareAndSet(this, oldWeight, newWeight)) {\n+                // There's no chance that newWeight is lower than 0 because decreasing the weight of each entry\n+                // happens only once.\n+                if (newWeight == 0) {\n+                    entries.forEach(entry -> entry.set(0));\n+                    currentTotalWeight = totalWeight;\n+                }\n+                return;\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static final class Entry extends AtomicInteger {\n+        private static final long serialVersionUID = -1719423489992905558L;\n+\n+        private final Endpoint endpoint;\n+\n+        Entry(Endpoint endpoint) {\n+            this.endpoint = endpoint;\n+        }\n+\n+        Endpoint endpoint() {\n+            return endpoint;\n+        }\n+\n+        boolean increaseCounter() {", "originalCommit": "586bcbc7632f7b838db8ab36d935b0c97fe3cf89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDg1NzE5Nw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554857197", "bodyText": "Oops removed. \ud83d\ude09", "author": "minwoox", "createdAt": "2021-01-11T07:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQyODAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDgxOTI4NA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554819284", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                  \"rampingUpTaskWindowMillis: %s (rampingUpTaskWindowMillis: >0 0)\",\n          \n          \n            \n                                  \"rampingUpTaskWindowMillis: %s (expected: > 0)\",", "author": "ikhoon", "createdAt": "2021-01-11T07:07:51Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategy.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.EndpointsRampingUpEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.ListenableAsyncCloseable;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s using {@link EndpointWeightTransition},\n+ * {@code rampingUpIntervalMillis} and {@code rampingUpTaskWindow}.\n+ * If more than one {@link Endpoint} are added within the {@code rampingUpTaskWindow}, the weights of\n+ * them are updated together. If there's already a scheduled job and new {@link Endpoint}s are added\n+ * within the {@code rampingUpTaskWindow}, they are updated together.\n+ * This is an example of how it works when {@code rampingUpTaskWindow} is 500 milliseconds and\n+ * {@code rampingUpIntervalMillis} is 2000 milliseconds:\n+ * <pre>{@code\n+ * ----------------------------------------------------------------------------------------------------\n+ *     A         B                             C                                       D\n+ *     t0        t1                            t2                                      t3         t4\n+ * ----------------------------------------------------------------------------------------------------\n+ *     0ms       t0 + 200ms                    t0 + 1000ms                          t0 + 1800ms  t0 + 2000ms\n+ * }</pre>\n+ * A and B are ramped up right away when they are added and they are ramped up together at t4.\n+ * C is updated alone every 2000 milliseconds. D is ramped up together with A and B at t4.\n+ */\n+final class WeightRampingUpStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker defaultTicker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final EventExecutor executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int numberSteps;\n+    private final long rampingUpTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            EventExecutor executor, long rampingUpIntervalMillis,\n+                            int numberSteps, long rampingUpTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, numberSteps, rampingUpTaskWindowMillis,\n+             defaultTicker);\n+    }\n+\n+    @VisibleForTesting\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            EventExecutor executor, long rampingUpIntervalMillis,\n+                            int numberSteps, long rampingUpTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(numberSteps > 0, \"numberSteps: %s (expected: > 0)\", numberSteps);\n+        this.numberSteps = numberSteps;\n+        checkArgument(rampingUpTaskWindowMillis >= 0,\n+                      \"rampingUpTaskWindowMillis: %s (rampingUpTaskWindowMillis: >0 0)\",", "originalCommit": "1532ac12b8bcd0867c87b7d37155f0bd93b7c456", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDgxOTM5OA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554819398", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                  \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n          \n          \n            \n                                  \"rampingUpIntervalMillis: %s (expected: > 0)\", rampingUpIntervalMillis);", "author": "ikhoon", "createdAt": "2021-01-11T07:08:02Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategy.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.EndpointsRampingUpEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.ListenableAsyncCloseable;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s using {@link EndpointWeightTransition},\n+ * {@code rampingUpIntervalMillis} and {@code rampingUpTaskWindow}.\n+ * If more than one {@link Endpoint} are added within the {@code rampingUpTaskWindow}, the weights of\n+ * them are updated together. If there's already a scheduled job and new {@link Endpoint}s are added\n+ * within the {@code rampingUpTaskWindow}, they are updated together.\n+ * This is an example of how it works when {@code rampingUpTaskWindow} is 500 milliseconds and\n+ * {@code rampingUpIntervalMillis} is 2000 milliseconds:\n+ * <pre>{@code\n+ * ----------------------------------------------------------------------------------------------------\n+ *     A         B                             C                                       D\n+ *     t0        t1                            t2                                      t3         t4\n+ * ----------------------------------------------------------------------------------------------------\n+ *     0ms       t0 + 200ms                    t0 + 1000ms                          t0 + 1800ms  t0 + 2000ms\n+ * }</pre>\n+ * A and B are ramped up right away when they are added and they are ramped up together at t4.\n+ * C is updated alone every 2000 milliseconds. D is ramped up together with A and B at t4.\n+ */\n+final class WeightRampingUpStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker defaultTicker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final EventExecutor executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int numberSteps;\n+    private final long rampingUpTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            EventExecutor executor, long rampingUpIntervalMillis,\n+                            int numberSteps, long rampingUpTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, numberSteps, rampingUpTaskWindowMillis,\n+             defaultTicker);\n+    }\n+\n+    @VisibleForTesting\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            EventExecutor executor, long rampingUpIntervalMillis,\n+                            int numberSteps, long rampingUpTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);", "originalCommit": "1532ac12b8bcd0867c87b7d37155f0bd93b7c456", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDgyOTY4NA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554829684", "bodyText": "nit: How about using stream API or loop to avoid nested indentations?\nendpointsRampingUp.stream()\n                  .flatMap(entry -> entry.endpointAndSteps().stream())\n                  .map(endpointAndStep -> endpointAndStep.endpoint().withWeight(endpointAndStep.currentWeight()))\n                  .forEach(targetEndpointsBuilder::add);\n// or\nfor (EndpointsRampingUpEntry entry : endpointsRampingUp) {\n    for (EndpointAndStep endpointAndStep : entry.endpointAndSteps()) {\n        targetEndpointsBuilder.add(\n                endpointAndStep.endpoint().withWeight(endpointAndStep.currentWeight()));\n    }\n}", "author": "ikhoon", "createdAt": "2021-01-11T07:20:46Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategy.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.EndpointsRampingUpEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.ListenableAsyncCloseable;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s using {@link EndpointWeightTransition},\n+ * {@code rampingUpIntervalMillis} and {@code rampingUpTaskWindow}.\n+ * If more than one {@link Endpoint} are added within the {@code rampingUpTaskWindow}, the weights of\n+ * them are updated together. If there's already a scheduled job and new {@link Endpoint}s are added\n+ * within the {@code rampingUpTaskWindow}, they are updated together.\n+ * This is an example of how it works when {@code rampingUpTaskWindow} is 500 milliseconds and\n+ * {@code rampingUpIntervalMillis} is 2000 milliseconds:\n+ * <pre>{@code\n+ * ----------------------------------------------------------------------------------------------------\n+ *     A         B                             C                                       D\n+ *     t0        t1                            t2                                      t3         t4\n+ * ----------------------------------------------------------------------------------------------------\n+ *     0ms       t0 + 200ms                    t0 + 1000ms                          t0 + 1800ms  t0 + 2000ms\n+ * }</pre>\n+ * A and B are ramped up right away when they are added and they are ramped up together at t4.\n+ * C is updated alone every 2000 milliseconds. D is ramped up together with A and B at t4.\n+ */\n+final class WeightRampingUpStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker defaultTicker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final EventExecutor executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int numberSteps;\n+    private final long rampingUpTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            EventExecutor executor, long rampingUpIntervalMillis,\n+                            int numberSteps, long rampingUpTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, numberSteps, rampingUpTaskWindowMillis,\n+             defaultTicker);\n+    }\n+\n+    @VisibleForTesting\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            EventExecutor executor, long rampingUpIntervalMillis,\n+                            int numberSteps, long rampingUpTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(numberSteps > 0, \"numberSteps: %s (expected: > 0)\", numberSteps);\n+        this.numberSteps = numberSteps;\n+        checkArgument(rampingUpTaskWindowMillis >= 0,\n+                      \"rampingUpTaskWindowMillis: %s (rampingUpTaskWindowMillis: >0 0)\",\n+                      rampingUpTaskWindowMillis);\n+        rampingUpTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(rampingUpTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightedRandomDistributionEndpointSelector endpointSelector;\n+\n+        private final List<Endpoint> endpointsFinishedRampingUp = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<EndpointsRampingUpEntry> endpointsRampingUp = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints =\n+                    new ArrayList<>(deduplicateEndpoints(endpointGroup.endpoints()).values());\n+            endpointSelector = new WeightedRandomDistributionEndpointSelector(initialEndpoints);\n+            endpointsFinishedRampingUp.addAll(initialEndpoints);\n+            endpointGroup.addListener(newEndpoints -> {\n+                // Use the executor so the order of endpoints change is guaranteed.\n+                executor.execute(() -> updateEndpoints(newEndpoints));\n+            });\n+            if (endpointGroup instanceof ListenableAsyncCloseable) {\n+                ((ListenableAsyncCloseable) endpointGroup).whenClosed().thenRunAsync(this::close, executor);\n+            }\n+        }\n+\n+        /**\n+         * Removes the duplicate endpoints in the specified {@code newEndpoints} and returns a new map\n+         * that contains unique endpoints.\n+         * The value of the map is the {@link Endpoint} whose {@link Endpoint#weight()} is the summed weight of\n+         * same {@link Endpoint}s.\n+         */\n+        private Map<Endpoint, Endpoint> deduplicateEndpoints(List<Endpoint> newEndpoints) {\n+            final Map<Endpoint, Endpoint> newEndpointsMap = new HashMap<>(newEndpoints.size());\n+\n+            // The weight of the same endpoints are summed.\n+            newEndpoints.forEach(\n+                    newEndpoint -> newEndpointsMap.compute(newEndpoint, (key, v) -> {\n+                        if (v == null) {\n+                            return newEndpoint;\n+                        }\n+                        final int weightSum = newEndpoint.weight() + v.weight();\n+                        return newEndpoint.withWeight(weightSum);\n+                    }));\n+            return newEndpointsMap;\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightedRandomDistributionEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        // Only executed by the executor.\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {\n+            unhandledNewEndpoints = null;\n+            if (rampingUpTaskWindowNanos > 0) {\n+                // Check whether we can ramp up with the previous ramped up endpoints which are at the last\n+                // of the rampingUpEndpointsEntries.\n+                if (shouldRampUpWithPreviousRampedUpEntry()) {\n+                    final Set<EndpointAndStep> newlyAddedEndpoints = filterOldEndpoints(newEndpoints);\n+                    if (!newlyAddedEndpoints.isEmpty()) {\n+                        updateWeightAndStep(newlyAddedEndpoints);\n+                        endpointsRampingUp.getLast().addEndpoints(newlyAddedEndpoints);\n+                    }\n+                    buildEndpointSelector();\n+                    return;\n+                }\n+\n+                // Check whether we can ramp up with the next scheduled endpointsRampingUpEntry.\n+                if (shouldRampUpWithNextScheduledEntry()) {\n+                    // unhandledNewEndpoints will be ramped up when updateWeightAndStep() is executed.\n+                    unhandledNewEndpoints = newEndpoints;\n+                    return;\n+                }\n+            }\n+\n+            final Set<EndpointAndStep> newlyAddedEndpoints = filterOldEndpoints(newEndpoints);\n+            if (newlyAddedEndpoints.isEmpty()) {\n+                // newlyAddedEndpoints is empty which means that endpointsFinishedRampingUp are changed.\n+                // So rebuild the endpoint selector.\n+                buildEndpointSelector();\n+                return;\n+            }\n+\n+            updateWeightAndStep(newlyAddedEndpoints);\n+\n+            // Check again because newlyAddedEndpoints can be removed in the updateWeightAndStep method.\n+            if (!newlyAddedEndpoints.isEmpty()) {\n+                final ScheduledFuture<?> scheduledFuture = executor.scheduleAtFixedRate(\n+                        this::updateWeightAndStep, rampingUpIntervalMillis,\n+                        rampingUpIntervalMillis, TimeUnit.MILLISECONDS);\n+                final EndpointsRampingUpEntry entry = new EndpointsRampingUpEntry(\n+                        newlyAddedEndpoints, scheduledFuture, ticker, rampingUpIntervalMillis);\n+                endpointsRampingUp.add(entry);\n+            }\n+            buildEndpointSelector();\n+        }\n+\n+        private void buildEndpointSelector() {\n+            final ImmutableList.Builder<Endpoint> targetEndpointsBuilder = ImmutableList.builder();\n+            targetEndpointsBuilder.addAll(endpointsFinishedRampingUp);\n+            endpointsRampingUp.forEach(\n+                    entry -> entry.endpointAndSteps().forEach(\n+                            endpointAndStep -> targetEndpointsBuilder.add(\n+                                    endpointAndStep.endpoint().withWeight(endpointAndStep.currentWeight()))));", "originalCommit": "1532ac12b8bcd0867c87b7d37155f0bd93b7c456", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDg0MzE0Nw==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554843147", "bodyText": "Let me use the foreach version. \ud83d\ude04", "author": "minwoox", "createdAt": "2021-01-11T07:36:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDgyOTY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDgzMjg1Ng==", "url": "https://github.com/line/armeria/pull/3217#discussion_r554832856", "bodyText": "Could use Ints.constrainToRange(calculated, 0, endpoint.weight())?", "author": "ikhoon", "createdAt": "2021-01-11T07:24:43Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/WeightRampingUpStrategy.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.endpoint;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.endpoint.WeightRampingUpStrategy.EndpointsRampingUpEntry.EndpointAndStep;\n+import com.linecorp.armeria.common.util.ListenableAsyncCloseable;\n+import com.linecorp.armeria.common.util.Ticker;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * A ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+ * {@link Endpoint}s using {@link EndpointWeightTransition},\n+ * {@code rampingUpIntervalMillis} and {@code rampingUpTaskWindow}.\n+ * If more than one {@link Endpoint} are added within the {@code rampingUpTaskWindow}, the weights of\n+ * them are updated together. If there's already a scheduled job and new {@link Endpoint}s are added\n+ * within the {@code rampingUpTaskWindow}, they are updated together.\n+ * This is an example of how it works when {@code rampingUpTaskWindow} is 500 milliseconds and\n+ * {@code rampingUpIntervalMillis} is 2000 milliseconds:\n+ * <pre>{@code\n+ * ----------------------------------------------------------------------------------------------------\n+ *     A         B                             C                                       D\n+ *     t0        t1                            t2                                      t3         t4\n+ * ----------------------------------------------------------------------------------------------------\n+ *     0ms       t0 + 200ms                    t0 + 1000ms                          t0 + 1800ms  t0 + 2000ms\n+ * }</pre>\n+ * A and B are ramped up right away when they are added and they are ramped up together at t4.\n+ * C is updated alone every 2000 milliseconds. D is ramped up together with A and B at t4.\n+ */\n+final class WeightRampingUpStrategy implements EndpointSelectionStrategy {\n+\n+    private static final Ticker defaultTicker = Ticker.systemTicker();\n+\n+    private final EndpointWeightTransition weightTransition;\n+    private final EventExecutor executor;\n+    private final long rampingUpIntervalMillis;\n+    private final int numberSteps;\n+    private final long rampingUpTaskWindowNanos;\n+    private final Ticker ticker;\n+\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            EventExecutor executor, long rampingUpIntervalMillis,\n+                            int numberSteps, long rampingUpTaskWindowMillis) {\n+        this(weightTransition, executor, rampingUpIntervalMillis, numberSteps, rampingUpTaskWindowMillis,\n+             defaultTicker);\n+    }\n+\n+    @VisibleForTesting\n+    WeightRampingUpStrategy(EndpointWeightTransition weightTransition,\n+                            EventExecutor executor, long rampingUpIntervalMillis,\n+                            int numberSteps, long rampingUpTaskWindowMillis, Ticker ticker) {\n+        this.weightTransition = requireNonNull(weightTransition, \"weightTransition\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        checkArgument(rampingUpIntervalMillis > 0,\n+                      \"rampingUpIntervalMillis: %s (rampingUpIntervalMillis: > 0)\", rampingUpIntervalMillis);\n+        this.rampingUpIntervalMillis = rampingUpIntervalMillis;\n+        checkArgument(numberSteps > 0, \"numberSteps: %s (expected: > 0)\", numberSteps);\n+        this.numberSteps = numberSteps;\n+        checkArgument(rampingUpTaskWindowMillis >= 0,\n+                      \"rampingUpTaskWindowMillis: %s (rampingUpTaskWindowMillis: >0 0)\",\n+                      rampingUpTaskWindowMillis);\n+        rampingUpTaskWindowNanos = TimeUnit.MILLISECONDS.toNanos(rampingUpTaskWindowMillis);\n+        this.ticker = requireNonNull(ticker, \"ticker\");\n+    }\n+\n+    @Override\n+    public EndpointSelector newSelector(EndpointGroup endpointGroup) {\n+        return new RampingUpEndpointWeightSelector(endpointGroup);\n+    }\n+\n+    @VisibleForTesting\n+    final class RampingUpEndpointWeightSelector extends AbstractEndpointSelector {\n+\n+        private volatile WeightedRandomDistributionEndpointSelector endpointSelector;\n+\n+        private final List<Endpoint> endpointsFinishedRampingUp = new ArrayList<>();\n+\n+        @VisibleForTesting\n+        final Deque<EndpointsRampingUpEntry> endpointsRampingUp = new ArrayDeque<>();\n+\n+        @Nullable\n+        private List<Endpoint> unhandledNewEndpoints;\n+\n+        RampingUpEndpointWeightSelector(EndpointGroup endpointGroup) {\n+            super(endpointGroup);\n+            final List<Endpoint> initialEndpoints =\n+                    new ArrayList<>(deduplicateEndpoints(endpointGroup.endpoints()).values());\n+            endpointSelector = new WeightedRandomDistributionEndpointSelector(initialEndpoints);\n+            endpointsFinishedRampingUp.addAll(initialEndpoints);\n+            endpointGroup.addListener(newEndpoints -> {\n+                // Use the executor so the order of endpoints change is guaranteed.\n+                executor.execute(() -> updateEndpoints(newEndpoints));\n+            });\n+            if (endpointGroup instanceof ListenableAsyncCloseable) {\n+                ((ListenableAsyncCloseable) endpointGroup).whenClosed().thenRunAsync(this::close, executor);\n+            }\n+        }\n+\n+        /**\n+         * Removes the duplicate endpoints in the specified {@code newEndpoints} and returns a new map\n+         * that contains unique endpoints.\n+         * The value of the map is the {@link Endpoint} whose {@link Endpoint#weight()} is the summed weight of\n+         * same {@link Endpoint}s.\n+         */\n+        private Map<Endpoint, Endpoint> deduplicateEndpoints(List<Endpoint> newEndpoints) {\n+            final Map<Endpoint, Endpoint> newEndpointsMap = new HashMap<>(newEndpoints.size());\n+\n+            // The weight of the same endpoints are summed.\n+            newEndpoints.forEach(\n+                    newEndpoint -> newEndpointsMap.compute(newEndpoint, (key, v) -> {\n+                        if (v == null) {\n+                            return newEndpoint;\n+                        }\n+                        final int weightSum = newEndpoint.weight() + v.weight();\n+                        return newEndpoint.withWeight(weightSum);\n+                    }));\n+            return newEndpointsMap;\n+        }\n+\n+        @Override\n+        public Endpoint selectNow(ClientRequestContext ctx) {\n+            return endpointSelector.selectEndpoint();\n+        }\n+\n+        @VisibleForTesting\n+        WeightedRandomDistributionEndpointSelector endpointSelector() {\n+            return endpointSelector;\n+        }\n+\n+        // Only executed by the executor.\n+        private void updateEndpoints(List<Endpoint> newEndpoints) {\n+            unhandledNewEndpoints = null;\n+            if (rampingUpTaskWindowNanos > 0) {\n+                // Check whether we can ramp up with the previous ramped up endpoints which are at the last\n+                // of the rampingUpEndpointsEntries.\n+                if (shouldRampUpWithPreviousRampedUpEntry()) {\n+                    final Set<EndpointAndStep> newlyAddedEndpoints = filterOldEndpoints(newEndpoints);\n+                    if (!newlyAddedEndpoints.isEmpty()) {\n+                        updateWeightAndStep(newlyAddedEndpoints);\n+                        endpointsRampingUp.getLast().addEndpoints(newlyAddedEndpoints);\n+                    }\n+                    buildEndpointSelector();\n+                    return;\n+                }\n+\n+                // Check whether we can ramp up with the next scheduled endpointsRampingUpEntry.\n+                if (shouldRampUpWithNextScheduledEntry()) {\n+                    // unhandledNewEndpoints will be ramped up when updateWeightAndStep() is executed.\n+                    unhandledNewEndpoints = newEndpoints;\n+                    return;\n+                }\n+            }\n+\n+            final Set<EndpointAndStep> newlyAddedEndpoints = filterOldEndpoints(newEndpoints);\n+            if (newlyAddedEndpoints.isEmpty()) {\n+                // newlyAddedEndpoints is empty which means that endpointsFinishedRampingUp are changed.\n+                // So rebuild the endpoint selector.\n+                buildEndpointSelector();\n+                return;\n+            }\n+\n+            updateWeightAndStep(newlyAddedEndpoints);\n+\n+            // Check again because newlyAddedEndpoints can be removed in the updateWeightAndStep method.\n+            if (!newlyAddedEndpoints.isEmpty()) {\n+                final ScheduledFuture<?> scheduledFuture = executor.scheduleAtFixedRate(\n+                        this::updateWeightAndStep, rampingUpIntervalMillis,\n+                        rampingUpIntervalMillis, TimeUnit.MILLISECONDS);\n+                final EndpointsRampingUpEntry entry = new EndpointsRampingUpEntry(\n+                        newlyAddedEndpoints, scheduledFuture, ticker, rampingUpIntervalMillis);\n+                endpointsRampingUp.add(entry);\n+            }\n+            buildEndpointSelector();\n+        }\n+\n+        private void buildEndpointSelector() {\n+            final ImmutableList.Builder<Endpoint> targetEndpointsBuilder = ImmutableList.builder();\n+            targetEndpointsBuilder.addAll(endpointsFinishedRampingUp);\n+            endpointsRampingUp.forEach(\n+                    entry -> entry.endpointAndSteps().forEach(\n+                            endpointAndStep -> targetEndpointsBuilder.add(\n+                                    endpointAndStep.endpoint().withWeight(endpointAndStep.currentWeight()))));\n+            endpointSelector = new WeightedRandomDistributionEndpointSelector(targetEndpointsBuilder.build());\n+        }\n+\n+        private boolean shouldRampUpWithPreviousRampedUpEntry() {\n+            final EndpointsRampingUpEntry lastEndpointsRampingUpEntry = endpointsRampingUp.peekLast();\n+            return lastEndpointsRampingUpEntry != null &&\n+                   ticker.read() - lastEndpointsRampingUpEntry.lastUpdatedTime <= rampingUpTaskWindowNanos;\n+        }\n+\n+        private boolean shouldRampUpWithNextScheduledEntry() {\n+            final EndpointsRampingUpEntry nextEndpointsRampingUpEntry = endpointsRampingUp.peek();\n+            return nextEndpointsRampingUpEntry != null &&\n+                   nextEndpointsRampingUpEntry.nextUpdatingTime - ticker.read() <= rampingUpTaskWindowNanos;\n+        }\n+\n+        /**\n+         * Removes endpoints in endpointsFinishedRampingUp and endpointsRampingUp that\n+         * newEndpoints do not contain.\n+         * This also returns the {@link Set} of {@link EndpointAndStep}s whose endpoints are not in\n+         * in endpointsFinishedRampingUp and endpointsRampingUp.\n+         */\n+        private Set<EndpointAndStep> filterOldEndpoints(List<Endpoint> newEndpoints) {\n+            final Map<Endpoint, Endpoint> newEndpointsMap = deduplicateEndpoints(newEndpoints);\n+\n+            final List<Endpoint> replacedEndpoints = new ArrayList<>();\n+            for (final Iterator<Endpoint> i = endpointsFinishedRampingUp.iterator(); i.hasNext();) {\n+                final Endpoint endpointFinishedRampingUp = i.next();\n+                final Endpoint newEndpoint = newEndpointsMap.remove(endpointFinishedRampingUp);\n+                if (newEndpoint == null) {\n+                    // newEndpoints does not have this endpoint so we remove it.\n+                    i.remove();\n+                    continue;\n+                }\n+\n+                if (endpointFinishedRampingUp.weight() > newEndpoint.weight()) {\n+                    // The weight of the new endpoint is lower than the endpoint so we just replace it\n+                    // because we don't have to ramp up the weight.\n+                    replacedEndpoints.add(newEndpoint);\n+                    i.remove();\n+                } else if (endpointFinishedRampingUp.weight() < newEndpoint.weight()) {\n+                    // The weight of the new endpoint is greater than the endpoint so we remove the\n+                    // endpointFinishedRampingUp and put the newEndpoint back.\n+                    newEndpointsMap.put(newEndpoint, newEndpoint);\n+                    i.remove();\n+                } else {\n+                    // The weights are same so we keep the endpointFinishedRampingUp.\n+                }\n+            }\n+            if (!replacedEndpoints.isEmpty()) {\n+                endpointsFinishedRampingUp.addAll(replacedEndpoints);\n+            }\n+\n+            for (final Iterator<EndpointsRampingUpEntry> i = endpointsRampingUp.iterator();\n+                 i.hasNext();) {\n+                final EndpointsRampingUpEntry endpointsRampingUpEntry = i.next();\n+\n+                final Set<EndpointAndStep> endpointAndSteps = endpointsRampingUpEntry.endpointAndSteps();\n+                filterOldEndpoints(endpointAndSteps, newEndpointsMap);\n+                if (endpointAndSteps.isEmpty()) {\n+                    // All endpointAndSteps are removed so remove the entry completely.\n+                    i.remove();\n+                    endpointsRampingUpEntry.scheduledFuture.cancel(true);\n+                }\n+            }\n+\n+            // At this point, newEndpointsMap only contains the new endpoints that have to be ramped up.\n+            if (newEndpointsMap.isEmpty()) {\n+                return ImmutableSet.of();\n+            }\n+            final Set<EndpointAndStep> newlyAddedEndpoints = new HashSet<>(newEndpointsMap.size());\n+            newEndpointsMap.values().forEach(\n+                    endpoint -> newlyAddedEndpoints.add(new EndpointAndStep(endpoint)));\n+            return newlyAddedEndpoints;\n+        }\n+\n+        private void filterOldEndpoints(Set<EndpointAndStep> endpointAndSteps,\n+                                        Map<Endpoint, Endpoint> newEndpointsMap) {\n+            final List<EndpointAndStep> replacedEndpoints = new ArrayList<>();\n+            for (final Iterator<EndpointAndStep> i = endpointAndSteps.iterator(); i.hasNext();) {\n+                final EndpointAndStep endpointAndStep = i.next();\n+                final Endpoint rampingUpEndpoint = endpointAndStep.endpoint();\n+                final Endpoint newEndpoint = newEndpointsMap.remove(rampingUpEndpoint);\n+                if (newEndpoint == null) {\n+                    // newEndpointsMap does not contain rampingUpEndpoint so just remove the endpoint.\n+                    i.remove();\n+                    continue;\n+                }\n+\n+                if (rampingUpEndpoint.weight() == newEndpoint.weight()) {\n+                    // Same weight so don't do anything. Ramping up happens as it is scheduled.\n+                } else if (endpointAndStep.currentWeight() > newEndpoint.weight()) {\n+                    // Don't need to update the weight anymore so we add the newEndpoint to\n+                    // endpointsFinishedRampingUp and remove it from the iterator.\n+                    endpointsFinishedRampingUp.add(newEndpoint);\n+                    i.remove();\n+                } else {\n+                    // Should replace the existing endpoint with the new one.\n+                    final int step = endpointAndStep.step();\n+                    final EndpointAndStep replaced = new EndpointAndStep(newEndpoint, step);\n+                    replaced.currentWeight(weightTransition.compute(newEndpoint, step, numberSteps));\n+                    replacedEndpoints.add(replaced);\n+                    i.remove();\n+                }\n+            }\n+\n+            if (!replacedEndpoints.isEmpty()) {\n+                endpointAndSteps.addAll(replacedEndpoints);\n+            }\n+        }\n+\n+        private void updateWeightAndStep() {\n+            if (unhandledNewEndpoints != null) {\n+                final Set<EndpointAndStep> newlyAddedEndpoints =\n+                        filterOldEndpoints(unhandledNewEndpoints);\n+                final EndpointsRampingUpEntry entry = endpointsRampingUp.peek();\n+                assert entry != null;\n+                entry.addEndpoints(newlyAddedEndpoints);\n+                unhandledNewEndpoints = null;\n+            }\n+            final EndpointsRampingUpEntry entry = endpointsRampingUp.poll();\n+            assert entry != null;\n+\n+            final Set<EndpointAndStep> endpointAndSteps = entry.endpointAndSteps();\n+            updateWeightAndStep(endpointAndSteps);\n+            if (endpointAndSteps.isEmpty()) {\n+                entry.scheduledFuture.cancel(true);\n+            } else {\n+                // Add to the last of the entries.\n+                endpointsRampingUp.add(entry);\n+                entry.updateWindowTimestamps();\n+            }\n+            buildEndpointSelector();\n+        }\n+\n+        private void updateWeightAndStep(Set<EndpointAndStep> endpointAndSteps) {\n+            for (final Iterator<EndpointAndStep> i = endpointAndSteps.iterator(); i.hasNext();) {\n+                final EndpointAndStep endpointAndStep = i.next();\n+                final int step = endpointAndStep.incrementAndGetStep();\n+                final Endpoint endpoint = endpointAndStep.endpoint();\n+                if (step == numberSteps) {\n+                    endpointsFinishedRampingUp.add(endpoint);\n+                    i.remove();\n+                } else {\n+                    final int calculated =\n+                            weightTransition.compute(endpoint, step, numberSteps);\n+                    final int currentWeight = Math.max(Math.min(calculated, endpoint.weight()), 0);", "originalCommit": "1532ac12b8bcd0867c87b7d37155f0bd93b7c456", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1099faa8c7a2ee799e004d22ef8a1da024554550", "url": "https://github.com/line/armeria/commit/1099faa8c7a2ee799e004d22ef8a1da024554550", "message": "Address comments by @ikhoon", "committedDate": "2021-01-11T07:56:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEzMTkwNA==", "url": "https://github.com/line/armeria/pull/3217#discussion_r563131904", "bodyText": "Better returning a singleton?", "author": "trustin", "createdAt": "2021-01-23T11:43:27Z", "path": "core/src/main/java/com/linecorp/armeria/client/endpoint/EndpointSelectionStrategy.java", "diffHunk": "@@ -48,6 +50,26 @@ static EndpointSelectionStrategy roundRobin() {\n         return RoundRobinStrategy.INSTANCE;\n     }\n \n+    /**\n+     * Returns a weight ramping up {@link EndpointSelectionStrategy} which ramps the weight of newly added\n+     * {@link Endpoint}s using {@link EndpointWeightTransition#linear()}. The {@link Endpoint} is selected\n+     * using weighted random distribution.\n+     * The weights of {@link Endpoint}s are ramped up by 10 percent every 2 seconds up to 100 percent\n+     * by default. If you want to customize the parameters, use {@link #builderForRampingUp()}.\n+     */\n+    static EndpointSelectionStrategy rampingUp() {\n+        return builderForRampingUp().build();", "originalCommit": "1099faa8c7a2ee799e004d22ef8a1da024554550", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzQ4NDk0MQ==", "url": "https://github.com/line/armeria/pull/3217#discussion_r563484941", "bodyText": "Thanks! updated. \ud83d\ude09", "author": "minwoox", "createdAt": "2021-01-25T06:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzEzMTkwNA=="}], "type": "inlineReview"}, {"oid": "2c7189af040db2f8c0b4f2b6908f2d43d4ae87a3", "url": "https://github.com/line/armeria/commit/2c7189af040db2f8c0b4f2b6908f2d43d4ae87a3", "message": "Address comments by @trustin", "committedDate": "2021-01-25T06:21:43Z", "type": "commit"}, {"oid": "b336112c30e40156cbd54b7bf224951d9631eb1b", "url": "https://github.com/line/armeria/commit/b336112c30e40156cbd54b7bf224951d9631eb1b", "message": "Use supplier", "committedDate": "2021-01-25T08:04:14Z", "type": "commit"}]}