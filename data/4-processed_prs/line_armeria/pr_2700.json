{"pr_number": 2700, "pr_title": "Reduce the overhead of piggybacked connection attempts in `HttpChanne\u2026", "pr_createdAt": "2020-05-11T13:47:06Z", "pr_url": "https://github.com/line/armeria/pull/2700", "timeline": [{"oid": "b1dcce1f2515fdc97446b4048407e75836290511", "url": "https://github.com/line/armeria/commit/b1dcce1f2515fdc97446b4048407e75836290511", "message": "Reduce the overhead of piggybacked connection attempts in `HttpChannelPool`\n\nMotivation:\n\nWhen there's already a pending connection attempt, `HttpChannelPool`\npiggybacks the connection attempts to the same endpoint by adding a\ncallback to the existing connection attempt's future, so that it does\nnot create a new connection excessively, especially for HTTP/2.\n\nHowever, completing a `CompletableFuture` with many callbacks can take\nlonger than expected. In Java 8, `CompletableFuture.complete()` can\ntrigger `CompletableFuture.cleanStack()` to run for a very long time.\nFor example, in my desktop PC, `cleanStack()` took 13 seconds to clean\n100K callbacks, which is not too many in high-TPS system.\n\nModifications:\n\n- Keep a separate list of notifications tasks for piggybacked connection\n  attempts, so that the number of callbacks registered to\n  `CompletableFuture` stays minimal.\n- `HttpChannelPool` now always reserves the number of unfinished\n  requests before actually acquiring the connection.\n  - Previously, we relied on the implementation detail of `HttpRequest`\n    implementation where `subscribe()` from an event loop thread will\n    always call `onSubscribe()` immediately.\n\nResult:\n\n- Better performance and memory footprint when a large number of\n  requests are made for a new connection being established.\n- Armeria has even less chance of violating `MAX_CONCURRENT_STREAMS`.", "committedDate": "2020-05-11T13:36:05Z", "type": "commit"}, {"oid": "43ecfd1aed3ff64376c071e71ca2e9ed3cd090d1", "url": "https://github.com/line/armeria/commit/43ecfd1aed3ff64376c071e71ca2e9ed3cd090d1", "message": "Move a method", "committedDate": "2020-05-11T13:49:31Z", "type": "commit"}, {"oid": "faf768bee452f578a1f629edb5e787a2ebf6b686", "url": "https://github.com/line/armeria/commit/faf768bee452f578a1f629edb5e787a2ebf6b686", "message": "Inline", "committedDate": "2020-05-11T13:54:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ3ODYyMg==", "url": "https://github.com/line/armeria/pull/2700#discussion_r423478622", "bodyText": "Oops, I realized that we shouln't call timingsBuilder.pendingAcquisitionEnd(); if usePendingAcquisition(...) returns true.", "author": "minwoox", "createdAt": "2020-05-12T05:56:49Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -681,4 +642,102 @@ private void doRelease() {\n             }\n         }\n     }\n+\n+    /**\n+     * A variant of {@link CompletableFuture} that keeps its completion handlers into a separate list.\n+     * This yields better performance than {@link CompletableFuture#handle(BiFunction)} as the number of\n+     * added handlers increases because it does not create a long linked list with extra wrappers, which is\n+     * especially beneficial for Java 8 which suffers a huge performance hit when complementing a future with\n+     * a deep stack. See {@code cleanStack()} in Java 8 {@link CompletableFuture} for more information.\n+     */\n+    private final class ChannelAcquisitionFuture extends CompletableFuture<PooledChannel> {\n+\n+        @Nullable\n+        private List<Consumer<PooledChannel>> notifications;\n+\n+        void addChild(SessionProtocol desiredProtocol, PoolKey key,\n+                      ChannelAcquisitionFuture childPromise,\n+                      ClientConnectionTimingsBuilder timingsBuilder) {\n+\n+            // Add to the notification list if not complete yet.\n+            if (!isDone()) {\n+                if (notifications == null) {\n+                    notifications = new ArrayList<>();\n+                }\n+                notifications.add(pch -> notifyChild(desiredProtocol, key, childPromise, timingsBuilder, pch));\n+                return;\n+            }\n+\n+            // Invoke the notification task immediately if complete already.\n+            notifyChild(desiredProtocol, key, childPromise, timingsBuilder,\n+                        isCompletedExceptionally() ? null : getNow(null));\n+        }\n+\n+        private void notifyChild(SessionProtocol desiredProtocol, PoolKey key,\n+                                 ChannelAcquisitionFuture childPromise,\n+                                 ClientConnectionTimingsBuilder timingsBuilder,\n+                                 @Nullable PooledChannel pch) {\n+\n+            timingsBuilder.pendingAcquisitionEnd();\n+\n+            if (pch != null) {\n+                final SessionProtocol actualProtocol = pch.protocol();\n+                if (actualProtocol.isMultiplex()) {\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.incrementNumUnfinishedResponses()) {\n+                        childPromise.complete(pch);\n+                    } else if (!usePendingAcquisition(actualProtocol, key, childPromise, timingsBuilder)) {", "originalCommit": "faf768bee452f578a1f629edb5e787a2ebf6b686", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NDgyMQ==", "url": "https://github.com/line/armeria/pull/2700#discussion_r423484821", "bodyText": "Good point. Fixed but couldn't think of a good way to test this.", "author": "trustin", "createdAt": "2020-05-12T06:14:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ3ODYyMg=="}], "type": "inlineReview"}, {"oid": "394840edce413975c527ed60901012c47f24152e", "url": "https://github.com/line/armeria/commit/394840edce413975c527ed60901012c47f24152e", "message": "Address the comment from @minwoox", "committedDate": "2020-05-12T06:13:56Z", "type": "commit"}, {"oid": "0d38c5de050d39a9914b793b27f2dc84f3f05d95", "url": "https://github.com/line/armeria/commit/0d38c5de050d39a9914b793b27f2dc84f3f05d95", "message": "Oops", "committedDate": "2020-05-12T06:15:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NjA2OQ==", "url": "https://github.com/line/armeria/pull/2700#discussion_r423486069", "bodyText": "Think we can extract a helper for this and completeExceptionally code fragments", "author": "anuraaga", "createdAt": "2020-05-12T06:17:59Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -681,4 +642,120 @@ private void doRelease() {\n             }\n         }\n     }\n+\n+    /**\n+     * A variant of {@link CompletableFuture} that keeps its completion handlers into a separate list.\n+     * This yields better performance than {@link CompletableFuture#handle(BiFunction)} as the number of\n+     * added handlers increases because it does not create a long linked list with extra wrappers, which is\n+     * especially beneficial for Java 8 which suffers a huge performance hit when complementing a future with\n+     * a deep stack. See {@code cleanStack()} in Java 8 {@link CompletableFuture} for more information.\n+     */\n+    private final class ChannelAcquisitionFuture extends CompletableFuture<PooledChannel> {\n+\n+        @Nullable\n+        private List<Consumer<PooledChannel>> notifications;\n+\n+        void addChild(SessionProtocol desiredProtocol, PoolKey key,\n+                      ChannelAcquisitionFuture childPromise,\n+                      ClientConnectionTimingsBuilder timingsBuilder) {\n+\n+            // Add to the notification list if not complete yet.\n+            if (!isDone()) {\n+                if (notifications == null) {\n+                    notifications = new ArrayList<>();\n+                }\n+                notifications.add(pch -> notifyChild(desiredProtocol, key, childPromise, timingsBuilder, pch));\n+                return;\n+            }\n+\n+            // Invoke the notification task immediately if complete already.\n+            notifyChild(desiredProtocol, key, childPromise, timingsBuilder,\n+                        isCompletedExceptionally() ? null : getNow(null));\n+        }\n+\n+        private void notifyChild(SessionProtocol desiredProtocol, PoolKey key,\n+                                 ChannelAcquisitionFuture childPromise,\n+                                 ClientConnectionTimingsBuilder timingsBuilder,\n+                                 @Nullable PooledChannel pch) {\n+\n+            // 1 - use the current pending acquisition.\n+            // 2 - create a new connection.\n+            // 3 - use another pending acquisition.\n+            final int result;\n+            if (pch != null) {\n+                final SessionProtocol actualProtocol = pch.protocol();\n+                if (actualProtocol.isMultiplex()) {\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.incrementNumUnfinishedResponses()) {\n+                        result = 1;\n+                    } else if (usePendingAcquisition(actualProtocol, key, childPromise, timingsBuilder)) {\n+                        result = 3;\n+                    } else {\n+                        result = 2;\n+                    }\n+                } else {\n+                    // Try to acquire again because the connection was not HTTP/2.\n+                    // We use the exact protocol (H1 or H1C) instead of 'desiredProtocol' so that\n+                    // we do not waste our time looking for pending acquisitions for the host\n+                    // that does not support HTTP/2.\n+                    final PooledChannel ch = acquireNow(actualProtocol, key);\n+                    if (ch != null) {\n+                        pch = ch;\n+                        result = 1;\n+                    } else {\n+                        result = 2;\n+                    }\n+                }\n+            } else {\n+                result = 2;\n+            }\n+\n+            switch (result) {\n+                case 1:\n+                    timingsBuilder.pendingAcquisitionEnd();\n+                    childPromise.complete(pch);\n+                    break;\n+                case 2:\n+                    timingsBuilder.pendingAcquisitionEnd();\n+                    connect(desiredProtocol, key, childPromise, timingsBuilder);\n+                    break;\n+                case 3:\n+                    // There's nothing to do because usePendingAcquisition() was called successfully above.\n+                    break;\n+            }\n+        }\n+\n+        @Override\n+        public boolean complete(PooledChannel value) {\n+            assert value != null;\n+            if (!super.complete(value)) {\n+                return false;\n+            }\n+\n+            final List<Consumer<PooledChannel>> notifications = this.notifications;", "originalCommit": "0d38c5de050d39a9914b793b27f2dc84f3f05d95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NjMyOQ==", "url": "https://github.com/line/armeria/pull/2700#discussion_r423486329", "bodyText": "Can we define an enum for this for readability?", "author": "anuraaga", "createdAt": "2020-05-12T06:18:39Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -681,4 +642,120 @@ private void doRelease() {\n             }\n         }\n     }\n+\n+    /**\n+     * A variant of {@link CompletableFuture} that keeps its completion handlers into a separate list.\n+     * This yields better performance than {@link CompletableFuture#handle(BiFunction)} as the number of\n+     * added handlers increases because it does not create a long linked list with extra wrappers, which is\n+     * especially beneficial for Java 8 which suffers a huge performance hit when complementing a future with\n+     * a deep stack. See {@code cleanStack()} in Java 8 {@link CompletableFuture} for more information.\n+     */\n+    private final class ChannelAcquisitionFuture extends CompletableFuture<PooledChannel> {\n+\n+        @Nullable\n+        private List<Consumer<PooledChannel>> notifications;\n+\n+        void addChild(SessionProtocol desiredProtocol, PoolKey key,\n+                      ChannelAcquisitionFuture childPromise,\n+                      ClientConnectionTimingsBuilder timingsBuilder) {\n+\n+            // Add to the notification list if not complete yet.\n+            if (!isDone()) {\n+                if (notifications == null) {\n+                    notifications = new ArrayList<>();\n+                }\n+                notifications.add(pch -> notifyChild(desiredProtocol, key, childPromise, timingsBuilder, pch));\n+                return;\n+            }\n+\n+            // Invoke the notification task immediately if complete already.\n+            notifyChild(desiredProtocol, key, childPromise, timingsBuilder,\n+                        isCompletedExceptionally() ? null : getNow(null));\n+        }\n+\n+        private void notifyChild(SessionProtocol desiredProtocol, PoolKey key,\n+                                 ChannelAcquisitionFuture childPromise,\n+                                 ClientConnectionTimingsBuilder timingsBuilder,\n+                                 @Nullable PooledChannel pch) {\n+\n+            // 1 - use the current pending acquisition.\n+            // 2 - create a new connection.\n+            // 3 - use another pending acquisition.\n+            final int result;\n+            if (pch != null) {\n+                final SessionProtocol actualProtocol = pch.protocol();\n+                if (actualProtocol.isMultiplex()) {\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.incrementNumUnfinishedResponses()) {\n+                        result = 1;", "originalCommit": "0d38c5de050d39a9914b793b27f2dc84f3f05d95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxMjIxOQ==", "url": "https://github.com/line/armeria/pull/2700#discussion_r423512219", "bodyText": "Done. \ud83d\udc4d", "author": "trustin", "createdAt": "2020-05-12T07:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NjMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NjcxNA==", "url": "https://github.com/line/armeria/pull/2700#discussion_r423486714", "bodyText": "We could consider inlining a single notification since it seems like there will be two common cases, only one notification, or many notifications. But maybe premature", "author": "anuraaga", "createdAt": "2020-05-12T06:19:42Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -681,4 +642,120 @@ private void doRelease() {\n             }\n         }\n     }\n+\n+    /**\n+     * A variant of {@link CompletableFuture} that keeps its completion handlers into a separate list.\n+     * This yields better performance than {@link CompletableFuture#handle(BiFunction)} as the number of\n+     * added handlers increases because it does not create a long linked list with extra wrappers, which is\n+     * especially beneficial for Java 8 which suffers a huge performance hit when complementing a future with\n+     * a deep stack. See {@code cleanStack()} in Java 8 {@link CompletableFuture} for more information.\n+     */\n+    private final class ChannelAcquisitionFuture extends CompletableFuture<PooledChannel> {\n+\n+        @Nullable\n+        private List<Consumer<PooledChannel>> notifications;", "originalCommit": "0d38c5de050d39a9914b793b27f2dc84f3f05d95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyMTEzMA==", "url": "https://github.com/line/armeria/pull/2700#discussion_r423521130", "bodyText": "Done. PTAL again \ud83d\ude04", "author": "trustin", "createdAt": "2020-05-12T07:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ4NjcxNA=="}], "type": "inlineReview"}, {"oid": "e9e474bdc9290567766de653a0b719b16b0ed228", "url": "https://github.com/line/armeria/commit/e9e474bdc9290567766de653a0b719b16b0ed228", "message": "Use enum", "committedDate": "2020-05-12T07:14:39Z", "type": "commit"}, {"oid": "4f3e408d572486b62a0ef7323ba8346e51bf3b81", "url": "https://github.com/line/armeria/commit/4f3e408d572486b62a0ef7323ba8346e51bf3b81", "message": "Optimization as suggested by @anuraaga", "committedDate": "2020-05-12T07:30:54Z", "type": "commit"}, {"oid": "6bf46483adc0ec59d454aa32412c676d06855ed1", "url": "https://github.com/line/armeria/commit/6bf46483adc0ec59d454aa32412c676d06855ed1", "message": "Comments", "committedDate": "2020-05-12T07:33:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNTMwNQ==", "url": "https://github.com/line/armeria/pull/2700#discussion_r423525305", "bodyText": "Sweet!", "author": "anuraaga", "createdAt": "2020-05-12T07:39:44Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -681,4 +642,175 @@ private void doRelease() {\n             }\n         }\n     }\n+\n+    /**\n+     * The result of piggybacked channel acquisition attempt.\n+     */\n+    private enum PiggybackedChannelAcquisitionResult {\n+        /**\n+         * Piggybacking succeeded. Use the channel from the current pending acquisition.\n+         */\n+        SUCCESS,\n+        /**\n+         * Piggybacking failed. Attempt to establish a new connection.\n+         */\n+        NEW_CONNECTION,\n+        /**\n+         * Piggybacking failed, but there's another pending acquisition.\n+         */\n+        PIGGYBACKED_AGAIN;\n+    }\n+\n+    /**\n+     * A variant of {@link CompletableFuture} that keeps its completion handlers into a separate list.\n+     * This yields better performance than {@link CompletableFuture#handle(BiFunction)} as the number of\n+     * added handlers increases because it does not create a long linked list with extra wrappers, which is\n+     * especially beneficial for Java 8 which suffers a huge performance hit when complementing a future with\n+     * a deep stack. See {@code cleanStack()} in Java 8 {@link CompletableFuture} for more information.\n+     */\n+    private final class ChannelAcquisitionFuture extends CompletableFuture<PooledChannel> {\n+\n+        /**\n+         * A {@code Consumer<PooledChannel>} if only 1 handler.\n+         * A {@code List<Consumer<PooledChannel>>} if there are 2+ handlers.\n+         */\n+        @Nullable\n+        private Object pendingPiggybackHandlers;\n+\n+        void piggyback(SessionProtocol desiredProtocol, PoolKey key,\n+                       ChannelAcquisitionFuture childPromise,\n+                       ClientConnectionTimingsBuilder timingsBuilder) {\n+\n+            // Add to the pending handler list if not complete yet.\n+            if (!isDone()) {\n+                final Consumer<PooledChannel> handler =\n+                        pch -> handlePiggyback(desiredProtocol, key, childPromise, timingsBuilder, pch);\n+\n+                if (pendingPiggybackHandlers == null) {\n+                    // The 1st handler\n+                    pendingPiggybackHandlers = handler;\n+                    return;\n+                }\n+\n+                if (!(pendingPiggybackHandlers instanceof List)) {", "originalCommit": "6bf46483adc0ec59d454aa32412c676d06855ed1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}