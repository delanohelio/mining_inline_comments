{"pr_number": 2374, "pr_title": "Fix `MAX_CONCURRENT_STREAMS` violation on client side", "pr_createdAt": "2020-01-05T16:24:08Z", "pr_url": "https://github.com/line/armeria/pull/2374", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAyNTAzOA==", "url": "https://github.com/line/armeria/pull/2374#discussion_r364025038", "bodyText": "this should be set per PoolKey", "author": "jrhee17", "createdAt": "2020-01-08T01:07:31Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -71,6 +71,7 @@\n     // Fields for creating a new connection:\n     private final Bootstrap[] bootstraps;\n     private final int connectTimeoutMillis;\n+    private volatile int numPendingAcquisitions;", "originalCommit": "37a56de52aedbde51625acdb1480dc6655694008", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAyNTc5NA==", "url": "https://github.com/line/armeria/pull/2374#discussion_r364025794", "bodyText": "this can be optimized by checking existing connections", "author": "jrhee17", "createdAt": "2020-01-08T01:10:52Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -266,14 +267,23 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             return false;\n         }\n \n+        numPendingAcquisitions++;\n+\n         timingsBuilder.pendingAcquisitionStart();\n         pendingAcquisition.handle((pch, cause) -> {\n             timingsBuilder.pendingAcquisitionEnd();\n \n+            numPendingAcquisitions--;\n+\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (numPendingAcquisitions < session.maxUnfinishedResponses() - 1) {\n+                        promise.complete(pch);\n+                    } else {\n+                        connect(actualProtocol, key, promise, timingsBuilder);", "originalCommit": "37a56de52aedbde51625acdb1480dc6655694008", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAyNjM1OA==", "url": "https://github.com/line/armeria/pull/2374#discussion_r364026358", "bodyText": "should also compare with unfinishedResponses.\nalso, technically this may not be a correct check -- should also consider timing with\n\nadding response\ncheck for acquireNowExact", "author": "jrhee17", "createdAt": "2020-01-08T01:13:36Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -266,14 +267,23 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             return false;\n         }\n \n+        numPendingAcquisitions++;\n+\n         timingsBuilder.pendingAcquisitionStart();\n         pendingAcquisition.handle((pch, cause) -> {\n             timingsBuilder.pendingAcquisitionEnd();\n \n+            numPendingAcquisitions--;\n+\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (numPendingAcquisitions < session.maxUnfinishedResponses() - 1) {", "originalCommit": "37a56de52aedbde51625acdb1480dc6655694008", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "32ca3cdf8f89bc10cb2750ec143aabfe7c1cbe66", "url": "https://github.com/line/armeria/commit/32ca3cdf8f89bc10cb2750ec143aabfe7c1cbe66", "message": "fix checkstyle: long line, newline", "committedDate": "2020-01-10T15:11:18Z", "type": "forcePushed"}, {"oid": "c63179d086dd121dbd655b99a162116a2fe3fbec", "url": "https://github.com/line/armeria/commit/c63179d086dd121dbd655b99a162116a2fe3fbec", "message": "very basic fix -- simply create new connection if violated\n\n- this fix assumes pending acquisition isn't done\n- this fix can unnecessarily create many connections", "committedDate": "2020-02-03T15:09:51Z", "type": "forcePushed"}, {"oid": "3dd48cc208b12782823d997a3edaa0606f526d08", "url": "https://github.com/line/armeria/commit/3dd48cc208b12782823d997a3edaa0606f526d08", "message": "open minimal number of connections using recursion", "committedDate": "2020-02-10T14:01:59Z", "type": "forcePushed"}, {"oid": "ef41055a9fb2580ad0ecad51040045e3a6c9dac6", "url": "https://github.com/line/armeria/commit/ef41055a9fb2580ad0ecad51040045e3a6c9dac6", "message": "add initial failing test", "committedDate": "2020-02-10T14:03:38Z", "type": "commit"}, {"oid": "6b8679b72b0e233cf195433a72a023a3d60f93de", "url": "https://github.com/line/armeria/commit/6b8679b72b0e233cf195433a72a023a3d60f93de", "message": "very basic fix -- simply create new connection if violated\n\n- this fix assumes pending acquisition isn't done\n- this fix can unnecessarily create many connections", "committedDate": "2020-02-10T14:03:38Z", "type": "commit"}, {"oid": "40ed8328f394a4732ad4358881e25683a25d74db", "url": "https://github.com/line/armeria/commit/40ed8328f394a4732ad4358881e25683a25d74db", "message": "fix test to succeed when max stream exceeded", "committedDate": "2020-02-10T14:03:38Z", "type": "commit"}, {"oid": "43b1a5f86447f5b8b4ea22003f3f9571d1995be6", "url": "https://github.com/line/armeria/commit/43b1a5f86447f5b8b4ea22003f3f9571d1995be6", "message": "add failing test which opens too many connections", "committedDate": "2020-02-10T14:03:38Z", "type": "commit"}, {"oid": "20f04ecf7fae6604ae3e38b2af8605acdb15431b", "url": "https://github.com/line/armeria/commit/20f04ecf7fae6604ae3e38b2af8605acdb15431b", "message": "fix checkStyleMain newline before brace", "committedDate": "2020-02-10T14:03:38Z", "type": "commit"}, {"oid": "63cd41b9eedcb9e03e265b6f29f6a445740a734a", "url": "https://github.com/line/armeria/commit/63cd41b9eedcb9e03e265b6f29f6a445740a734a", "message": "open minimal number of connections using recursion", "committedDate": "2020-02-10T14:03:38Z", "type": "forcePushed"}, {"oid": "5e3b16d092668b39342414203663711903491133", "url": "https://github.com/line/armeria/commit/5e3b16d092668b39342414203663711903491133", "message": "open minimal number of connections using recursion", "committedDate": "2020-02-10T14:47:17Z", "type": "commit"}, {"oid": "5e3b16d092668b39342414203663711903491133", "url": "https://github.com/line/armeria/commit/5e3b16d092668b39342414203663711903491133", "message": "open minimal number of connections using recursion", "committedDate": "2020-02-10T14:47:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4NTEzOA==", "url": "https://github.com/line/armeria/pull/2374#discussion_r377485138", "bodyText": "I guess we can prevent calling pendingAcquisitionEnd() if acquireLater() will be called?", "author": "trustin", "createdAt": "2020-02-11T08:04:18Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "diffHunk": "@@ -107,8 +107,9 @@ public ClientConnectionTimingsBuilder pendingAcquisitionStart() {\n      * @throws IllegalStateException if {@link #pendingAcquisitionStart()} is not invoked before calling this.\n      */\n     public ClientConnectionTimingsBuilder pendingAcquisitionEnd() {\n-        checkState(pendingAcquisitionStartTimeMicros >= 0, \"pendingAcquisitionStart() is not called yet.\");\n-        checkState(!pendingAcquisitionEndSet, \"pendingAcquisitionEnd() is already called.\");\n+        // TODO: decide how to handle pendingAcquisitionEnd now that it might be called multiple times\n+        // checkState(pendingAcquisitionStartTimeMicros >= 0, \"pendingAcquisitionStart() is not called yet.\");\n+        // checkState(!pendingAcquisitionEndSet, \"pendingAcquisitionEnd() is already called.\");", "originalCommit": "5e3b16d092668b39342414203663711903491133", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4Njg2OQ==", "url": "https://github.com/line/armeria/pull/2374#discussion_r377486869", "bodyText": "Shouldn't we call acquireLater() after pendingAcquisition is cleared? acquireLater() (and inherently usePendingAcquisition()) would use the current pendingAcquisition again and again, making a busy loop.", "author": "trustin", "createdAt": "2020-02-11T08:10:04Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +276,15 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    logger.info(\"session.unfinishedResponses(): {}, session.maxUnfinishedResponses(): {}\",\n+                                session.unfinishedResponses(), session.maxUnfinishedResponses());\n+                    // Need to subtract 1 since the current pending request may also be unfinished\n+                    if (session.unfinishedResponses() >= session.maxUnfinishedResponses() - 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder).thenAccept(promise::complete);", "originalCommit": "5e3b16d092668b39342414203663711903491133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3OTk1Mg==", "url": "https://github.com/line/armeria/pull/2374#discussion_r377779952", "bodyText": "I see~ Of course I'll explore this idea, but just to share my original thought.\nI was thinking pendingAcquisition would always be cleared since notifyConnect clears it before completing the promise.", "author": "jrhee17", "createdAt": "2020-02-11T17:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4Njg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgxMjA2Ng==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379812066", "bodyText": "Ah, OK. pendingAcquisition is removed in notifyConnect() before pendingAcquisition is completed.", "author": "trustin", "createdAt": "2020-02-15T08:54:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ4Njg2OQ=="}], "type": "inlineReview"}, {"oid": "2c2cb9206668a765c1958eff522381126518aebb", "url": "https://github.com/line/armeria/commit/2c2cb9206668a765c1958eff522381126518aebb", "message": "add failing test for proper exception handling", "committedDate": "2020-02-11T17:20:57Z", "type": "commit"}, {"oid": "3e0810efa870a1720c4632ced06d2b1c6689a785", "url": "https://github.com/line/armeria/commit/3e0810efa870a1720c4632ced06d2b1c6689a785", "message": "improve unit test for connection failure to include use pending case", "committedDate": "2020-02-12T16:00:39Z", "type": "commit"}, {"oid": "164cb7b154c92ceb71b6c1b9c9f9c3b701c5c0c0", "url": "https://github.com/line/armeria/commit/164cb7b154c92ceb71b6c1b9c9f9c3b701c5c0c0", "message": "remove potential flakiness for failure test", "committedDate": "2020-02-13T15:06:36Z", "type": "commit"}, {"oid": "6d9e74f9451ca326e05310ee11946908c2870c19", "url": "https://github.com/line/armeria/commit/6d9e74f9451ca326e05310ee11946908c2870c19", "message": "re-use future when acquiring new connection", "committedDate": "2020-02-13T15:19:28Z", "type": "commit"}, {"oid": "3879c7975a32d8f7f6aabacb862a099aeca97ee1", "url": "https://github.com/line/armeria/commit/3879c7975a32d8f7f6aabacb862a099aeca97ee1", "message": "add test for multiple event loops and clean tests", "committedDate": "2020-02-13T15:37:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI3ODczNA==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379278734", "bodyText": "also add checks for pendingAcquisitionMillis to ensure pendingAcquisition was really used", "author": "jrhee17", "createdAt": "2020-02-14T07:11:18Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +170,143 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    public void succeedWhenExceedMaxStreams() throws Exception {\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        // running inside event loop ensures requests are queued before initial connect completes.\n+        for (int j = 0; j < MAX_CONCURRENT_STREAMS + 1; j++) {\n+            receivedResponses.add(client.get(PATH).aggregate());\n+        }\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(MAX_CONCURRENT_STREAMS + 1));", "originalCommit": "3879c7975a32d8f7f6aabacb862a099aeca97ee1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTc3NDU0MA==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379774540", "bodyText": "done -- not applying test for multipleEventLoops since this check depends on how event loops are acquired. (this would actually be do-able, but not sure if it's worth it)", "author": "jrhee17", "createdAt": "2020-02-15T07:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI3ODczNA=="}], "type": "inlineReview"}, {"oid": "d0be6a39788d12129e2f951685a046137b24d4e5", "url": "https://github.com/line/armeria/commit/d0be6a39788d12129e2f951685a046137b24d4e5", "message": "improve flakiness, stricter check for pendingAcquisition called", "committedDate": "2020-02-15T06:59:29Z", "type": "commit"}, {"oid": "6e90705184b616f1bfeac3f8aebd2570446064a7", "url": "https://github.com/line/armeria/commit/6e90705184b616f1bfeac3f8aebd2570446064a7", "message": "add failing test for correct pendingAcquisitionTime", "committedDate": "2020-02-15T07:21:41Z", "type": "commit"}, {"oid": "8373a97d306c9206d63bdf08b2215a5c004d6442", "url": "https://github.com/line/armeria/commit/8373a97d306c9206d63bdf08b2215a5c004d6442", "message": "somewhat dirty fix for correct pendingAcquisition duration", "committedDate": "2020-02-15T07:24:39Z", "type": "commit"}, {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b", "url": "https://github.com/line/armeria/commit/91bb3846b60bc5301b19619ce9488307898bd40b", "message": "migrate to junit 5", "committedDate": "2020-02-15T08:22:46Z", "type": "commit"}, {"oid": "91bb3846b60bc5301b19619ce9488307898bd40b", "url": "https://github.com/line/armeria/commit/91bb3846b60bc5301b19619ce9488307898bd40b", "message": "migrate to junit 5", "committedDate": "2020-02-15T08:22:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwMzY0Nw==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379803647", "bodyText": "Better extracting them into a local variable if you intend to keep the logging above.", "author": "trustin", "createdAt": "2020-02-15T08:30:42Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,15 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    logger.info(\"session.unfinishedResponses(): {}, session.maxUnfinishedResponses(): {}\",\n+                                session.unfinishedResponses(), session.maxUnfinishedResponses());\n+                    // unfinishedResponses >= maxUnfinishedResponses - current connecting request\n+                    if (session.unfinishedResponses() >= session.maxUnfinishedResponses() - 1) {", "originalCommit": "91bb3846b60bc5301b19619ce9488307898bd40b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyNzY4OQ==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379827689", "bodyText": "added a local variable and removed the comment -- let me know if you prefer I leave the comment though \ud83d\ude47", "author": "jrhee17", "createdAt": "2020-02-15T12:06:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwMzY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwMzgxMQ==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379803811", "bodyText": "Probably debug is better? Or do you intend to remove it before removing draft?", "author": "trustin", "createdAt": "2020-02-15T08:31:11Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,15 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    logger.info(\"session.unfinishedResponses(): {}, session.maxUnfinishedResponses(): {}\",\n+                                session.unfinishedResponses(), session.maxUnfinishedResponses());", "originalCommit": "91bb3846b60bc5301b19619ce9488307898bd40b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNDQzOQ==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379804439", "bodyText": "pendingAcquisitionEndNanos == 0 -> !pendingAcquisitionEndSet ?", "author": "trustin", "createdAt": "2020-02-15T08:32:48Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "diffHunk": "@@ -95,8 +95,10 @@ public ClientConnectionTimingsBuilder socketConnectEnd() {\n      * in order to use one connection for HTTP/2.\n      */\n     public ClientConnectionTimingsBuilder pendingAcquisitionStart() {\n-        pendingAcquisitionStartTimeMicros = SystemInfo.currentTimeMicros();\n-        pendingAcquisitionStartNanos = System.nanoTime();\n+        if (pendingAcquisitionStartTimeMicros == 0 && pendingAcquisitionEndNanos == 0) {", "originalCommit": "91bb3846b60bc5301b19619ce9488307898bd40b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNTM2MQ==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379805361", "bodyText": "j could be i?\nCould you add a comment about why you need to execute this via .execute()?", "author": "trustin", "createdAt": "2020-02-15T08:35:34Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {", "originalCommit": "91bb3846b60bc5301b19619ce9488307898bd40b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNzMyNQ==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379807325", "bodyText": "Could you also check the cause of the cause as well? (with hasMessageContaining if possible.)\n// Not sure if this is the best example. Maybe you can just split the assertions.\nassertThatThrownBy(() -> ...)\n        .isInstanceOf(CompletionException.class)\n        .hasCauseInstanceOfSatisfying(UnprocessedRequestException.class, cause -> {\n            assertThat(cause).hasCauseInstanceofSatisfying(SomeException.class, causeOfCause -> {\n                ...\n            });\n        });", "author": "trustin", "createdAt": "2020-02-15T08:41:06Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+            // two more requests which fails due to server maxNumConnections\n+            for (int j = 0; j < numFailedRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally).forEach(\n+                responseFuture -> assertThatThrownBy(responseFuture::get)\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class));", "originalCommit": "91bb3846b60bc5301b19619ce9488307898bd40b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNTM1Nw==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379835357", "bodyText": "leaving for ref.  the stack trace is as follows (without a \"real\" message)\njava.util.concurrent.CompletionException: com.linecorp.armeria.client.UnprocessedRequestException: com.linecorp.armeria.common.ClosedSessionException\n\n\tat java.base/java.util.concurrent.CompletableFuture.reportJoin(CompletableFuture.java:412)\n\tat java.base/java.util.concurrent.CompletableFuture.join(CompletableFuture.java:2115)\n\tat com.linecorp.armeria.common.util.EventLoopCheckingFuture.join(EventLoopCheckingFuture.java:70)\n\tat com.linecorp.armeria.client.HttpClientMaxConcurrentStreamTest.lambda$exceededMaxStreamsPropagatesFailureCorrectly$19(HttpClientMaxConcurrentStreamTest.java:309)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)\n\tat java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177)\n\tat java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1654)\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\n\tat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n\tat java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497)\n\tat com.linecorp.armeria.client.HttpClientMaxConcurrentStreamTest.exceededMaxStreamsPropagatesFailureCorrectly(HttpClientMaxConcurrentStreamTest.java:308)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:567)\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:686)\n\tat org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)\n\tat org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)\n\tat org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:205)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:201)\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:137)\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:71)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1540)\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1540)\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:248)\n\tat org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$5(DefaultLauncher.java:211)\n\tat org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:226)\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:199)\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:132)\n\tat com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:69)\n\tat com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)\nCaused by: com.linecorp.armeria.client.UnprocessedRequestException: com.linecorp.armeria.common.ClosedSessionException\n\tat com.linecorp.armeria.client.HttpChannelPool.notifyConnect(HttpChannelPool.java:475)\n\tat com.linecorp.armeria.client.HttpChannelPool.lambda$connect$5(HttpChannelPool.java:348)\n\tat io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)\n\tat io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)\n\tat io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)\n\tat io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)\n\tat io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)\n\tat io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\n\tat com.linecorp.armeria.client.HttpSessionHandler.channelInactive(HttpSessionHandler.java:335)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:260)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:239)\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:386)\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:351)\n\tat io.netty.handler.codec.http2.Http2ConnectionHandler.channelInactive(Http2ConnectionHandler.java:415)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:260)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:239)\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:386)\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:351)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:260)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:239)\n\tat io.netty.handler.logging.LoggingHandler.channelInactive(LoggingHandler.java:153)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:260)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:239)\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1405)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:260)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:246)\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:901)\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:818)\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute$$$capture(AbstractEventExecutor.java:164)\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:497)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.base/java.lang.Thread.run(Thread.java:835)\nCaused by: com.linecorp.armeria.common.ClosedSessionException\n\tat com.linecorp.armeria.common.ClosedSessionException.get(ClosedSessionException.java:33)\n\tat com.linecorp.armeria.client.HttpSessionHandler.channelInactive(HttpSessionHandler.java:329)\n\t... 31 more", "author": "jrhee17", "createdAt": "2020-02-15T14:44:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNzMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgwNzg3Mg==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379807872", "bodyText": "mapToLong(...).max()", "author": "trustin", "createdAt": "2020-02-15T08:42:39Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+            // two more requests which fails due to server maxNumConnections\n+            for (int j = 0; j < numFailedRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally).forEach(\n+                responseFuture -> assertThatThrownBy(responseFuture::get)\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class));\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+    }\n+\n+    @Test\n+    void ensureCorrectPendingAcquisitionDurationBehavior() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final int sleepMillis = 300;\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                Thread.sleep(sleepMillis);\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+\n+        // There should be at least one request with at least numConnections * pendingAcquisitionsDuration\n+        final Long maxPendingAcquisitionDurationNanos = connectionTimings.stream().map(\n+                ClientConnectionTimings::pendingAcquisitionDurationNanos).max(", "originalCommit": "91bb3846b60bc5301b19619ce9488307898bd40b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0b8536044a4b56ea2b3be8b236ba12ae95387cdb", "url": "https://github.com/line/armeria/commit/0b8536044a4b56ea2b3be8b236ba12ae95387cdb", "message": "(POC) explore idea of maxRetryCount - reverted immediately", "committedDate": "2020-02-15T08:56:47Z", "type": "commit"}, {"oid": "f7c6ada1e43e49c55556bd5d6f849602a18c7eec", "url": "https://github.com/line/armeria/commit/f7c6ada1e43e49c55556bd5d6f849602a18c7eec", "message": "Revert \"(POC) explore idea of maxRetryCount - reverted immediately\"\n\nThis reverts commit 0b8536044a4b56ea2b3be8b236ba12ae95387cdb.", "committedDate": "2020-02-15T08:57:12Z", "type": "commit"}, {"oid": "248c2b15dc2c7e084e368309a58ba471d617f746", "url": "https://github.com/line/armeria/commit/248c2b15dc2c7e084e368309a58ba471d617f746", "message": "add comments, clean up tests", "committedDate": "2020-02-15T09:10:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgxODA3Mw==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379818073", "bodyText": "Note to self: check if this has a potential to be flaky depending on how requests are assigned to event loops", "author": "jrhee17", "createdAt": "2020-02-15T09:13:01Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +177,225 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        clientFactory.eventLoopGroup().execute(() -> {\n+            for (int j = 0; j < numRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+            // two more requests which fails due to server maxNumConnections\n+            for (int j = 0; j < numFailedRequests; j++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally).forEach(\n+                responseFuture -> assertThatThrownBy(responseFuture::get)\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class));\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {", "originalCommit": "91bb3846b60bc5301b19619ce9488307898bd40b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgyODU2Mg==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379828562", "bodyText": "confirmed that HeapBasedEventLoopState guarantees this", "author": "jrhee17", "createdAt": "2020-02-15T12:24:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgxODA3Mw=="}], "type": "inlineReview"}, {"oid": "9257be77ef57b6a4c9f7d49efd67f479b573a296", "url": "https://github.com/line/armeria/commit/9257be77ef57b6a4c9f7d49efd67f479b573a296", "message": "remove unnecessary import for comparator", "committedDate": "2020-02-15T11:53:27Z", "type": "commit"}, {"oid": "6cd25d2635f499c5e310e2b41ba34aa5feb00118", "url": "https://github.com/line/armeria/commit/6cd25d2635f499c5e310e2b41ba34aa5feb00118", "message": "remove debug log for number of connections", "committedDate": "2020-02-15T12:25:53Z", "type": "commit"}, {"oid": "6cd25d2635f499c5e310e2b41ba34aa5feb00118", "url": "https://github.com/line/armeria/commit/6cd25d2635f499c5e310e2b41ba34aa5feb00118", "message": "remove debug log for number of connections", "committedDate": "2020-02-15T12:25:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzMDU5OQ==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379830599", "bodyText": "Highly unlikely, but unfinishedResponses + 1 can overflow theoretically. How about this?\nif (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n\nor ..\nfinal int numRemainingStreams =\n        session.maxUnfinishedResponses() - session.unfinishedResponses();\nif (numRemainingStreams <= 1) {", "author": "trustin", "createdAt": "2020-02-15T13:10:15Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,13 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    final int activeRequests = session.unfinishedResponses() + 1;\n+                    if (activeRequests >= session.maxUnfinishedResponses()) {", "originalCommit": "6cd25d2635f499c5e310e2b41ba34aa5feb00118", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNDA2Nw==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379834067", "bodyText": "good point (hadn't really thought about this -- will keep in mind for future PRs as well)  thanks \ud83d\ude04", "author": "jrhee17", "createdAt": "2020-02-15T14:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzMDU5OQ=="}], "type": "inlineReview"}, {"oid": "da804cd08f47b4e247db5b04df61444040d44dfe", "url": "https://github.com/line/armeria/commit/da804cd08f47b4e247db5b04df61444040d44dfe", "message": "ensure overflow doesn't occur", "committedDate": "2020-02-15T14:14:48Z", "type": "commit"}, {"oid": "f272afcd4c6de9e5adab1dfa11a1bbb2b6aa2fa6", "url": "https://github.com/line/armeria/commit/f272afcd4c6de9e5adab1dfa11a1bbb2b6aa2fa6", "message": "also check root cause for failed connections", "committedDate": "2020-02-15T14:31:35Z", "type": "commit"}, {"oid": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "url": "https://github.com/line/armeria/commit/91c73c4981906eb3fdce803c9184c3cf0751f58c", "message": "also check cause of cause for failed connections", "committedDate": "2020-02-15T14:41:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjA2MA==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836060", "bodyText": "Could use thread-safe data structure like ConcurrentLinkedQueue, because it will be updated from other threads.", "author": "trustin", "createdAt": "2020-02-15T14:57:20Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             assertThat(throwable.getCause()).hasCauseInstanceOf(ClosedSessionException.class);\n+                         });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+    }\n+\n+    @Test\n+    void ensureCorrectPendingAcquisitionDurationBehavior() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();", "originalCommit": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjA2Nw==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836067", "bodyText": "Could use LinkedBlockingQueue or LinkedTransferQueue for thread safety, given that the list will be updated from a different thread. Could be removed as well.", "author": "trustin", "createdAt": "2020-02-15T14:57:30Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             assertThat(throwable.getCause()).hasCauseInstanceOf(ClosedSessionException.class);\n+                         });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+    }\n+\n+    @Test\n+    void ensureCorrectPendingAcquisitionDurationBehavior() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final int sleepMillis = 300;\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                Thread.sleep(sleepMillis);\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();", "originalCommit": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjA3Nw==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836077", "bodyText": "Could be removed.", "author": "trustin", "createdAt": "2020-02-15T14:57:48Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             assertThat(throwable.getCause()).hasCauseInstanceOf(ClosedSessionException.class);\n+                         });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();", "originalCommit": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjE1Mw==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836153", "bodyText": "Could use thread-safe data structure like ConcurrentLinkedQueue, because it will be updated from other threads.", "author": "trustin", "createdAt": "2020-02-15T14:58:57Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();", "originalCommit": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjE5Mg==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836192", "bodyText": "This seems unused.", "author": "trustin", "createdAt": "2020-02-15T14:59:58Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();", "originalCommit": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjE5Nw==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836197", "bodyText": "Could use thread-safe data structure like ConcurrentLinkedQueue, because it will be updated from other threads.", "author": "trustin", "createdAt": "2020-02-15T15:00:14Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();", "originalCommit": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjIxOQ==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836219", "bodyText": "Could be removed.", "author": "trustin", "createdAt": "2020-02-15T15:00:42Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();", "originalCommit": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjI0Mw==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836243", "bodyText": "Could use thread-safe data structure like ConcurrentLinkedQueue, because it will be updated from other threads.", "author": "trustin", "createdAt": "2020-02-15T15:00:56Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();", "originalCommit": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjMzNg==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836336", "bodyText": "Could be deduplicated?", "author": "trustin", "createdAt": "2020-02-15T15:02:29Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })", "originalCommit": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjQyMw==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836423", "bodyText": "initial connect -> an initial connection attempt ?", "author": "trustin", "createdAt": "2020-02-15T15:04:08Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             assertThat(throwable.getCause()).hasCauseInstanceOf(ClosedSessionException.class);\n+                         });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+    }\n+\n+    @Test\n+    void ensureCorrectPendingAcquisitionDurationBehavior() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final int sleepMillis = 300;\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                Thread.sleep(sleepMillis);\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+\n+        // There should be at least one request with at least numConnections * pendingAcquisitionsDuration\n+        final Long maxPendingAcquisitionDurationNanos = connectionTimings.stream().mapToLong(\n+                ClientConnectionTimings::pendingAcquisitionDurationNanos).max().orElse(0L);\n+        assertThat(maxPendingAcquisitionDurationNanos)\n+                .isGreaterThan(TimeUnit.MILLISECONDS.toNanos(sleepMillis * numConnections));\n+    }\n+\n+    // running inside an event loop ensures requests are queued before initial connect completes.", "originalCommit": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjU1Ng==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836556", "bodyText": "Could extract into a constant?", "author": "trustin", "createdAt": "2020-02-15T15:06:32Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -62,6 +69,8 @@ protected void configure(ServerBuilder sb) throws Exception {\n                 return HttpResponse.from(f);\n             });\n             sb.http2MaxStreamsPerConnection(MAX_CONCURRENT_STREAMS);\n+            sb.maxNumConnections(6);", "originalCommit": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTgzNjYwMg==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379836602", "bodyText": "Could be deduplicated as well?", "author": "trustin", "createdAt": "2020-02-15T15:07:14Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +179,230 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final List<ClientConnectionTimings> connectionTimings = new ArrayList<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C, \"/\"))\n+                                          .factory(clientFactory)\n+                                          .decorator((delegate, ctx, req) -> {\n+                                              ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+                                                 .thenAccept(requestLog -> {\n+                                                     connectionTimings.add(requestLog.connectionTimings());\n+                                                 });\n+                                              return delegate.execute(ctx, req);\n+                                          })\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        final AtomicInteger closes = new AtomicInteger();\n+        connectionPoolListener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                opens.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closes.incrementAndGet();\n+            }\n+        };", "originalCommit": "91c73c4981906eb3fdce803c9184c3cf0751f58c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0573d8d496f9d26a8604ba30aeb1bed6aad0224e", "url": "https://github.com/line/armeria/commit/0573d8d496f9d26a8604ba30aeb1bed6aad0224e", "message": "dedup/improve tests, add test case for maxConcStreams 1", "committedDate": "2020-02-15T16:41:48Z", "type": "forcePushed"}, {"oid": "9539c9d1301e40bb5a02e4369f5cfe960f5b9584", "url": "https://github.com/line/armeria/commit/9539c9d1301e40bb5a02e4369f5cfe960f5b9584", "message": "dedup/improve tests, add test case for maxConcStreams 1", "committedDate": "2020-02-15T16:44:36Z", "type": "forcePushed"}, {"oid": "fd15431b6576e3eb3ec7b199b632f8551d623712", "url": "https://github.com/line/armeria/commit/fd15431b6576e3eb3ec7b199b632f8551d623712", "message": "dedup/improve tests, add test case for maxConcStreams 1", "committedDate": "2020-02-15T16:46:06Z", "type": "commit"}, {"oid": "fd15431b6576e3eb3ec7b199b632f8551d623712", "url": "https://github.com/line/armeria/commit/fd15431b6576e3eb3ec7b199b632f8551d623712", "message": "dedup/improve tests, add test case for maxConcStreams 1", "committedDate": "2020-02-15T16:46:06Z", "type": "forcePushed"}, {"oid": "c3e59b45928ffa5190ad94b0ada7531e879dc348", "url": "https://github.com/line/armeria/commit/c3e59b45928ffa5190ad94b0ada7531e879dc348", "message": "assert test cause outside of lambda\n\nin case of flaky tests, we can have a better stacktrace", "committedDate": "2020-02-15T18:06:28Z", "type": "forcePushed"}, {"oid": "198c60a860ffcdf3e6ff3729c617fbdd12925659", "url": "https://github.com/line/armeria/commit/198c60a860ffcdf3e6ff3729c617fbdd12925659", "message": "debug AbstractChannel$AnnotatedConnectException stacktrace", "committedDate": "2020-02-15T18:21:55Z", "type": "forcePushed"}, {"oid": "71f18f0ed308828ae758d5a4cb8c187cd918450b", "url": "https://github.com/line/armeria/commit/71f18f0ed308828ae758d5a4cb8c187cd918450b", "message": "debug AbstractChannel$AnnotatedConnectException stacktrace", "committedDate": "2020-02-15T18:38:17Z", "type": "forcePushed"}, {"oid": "c8ae9cf243ddc72f9c1d74a7f69ebb90ad883e5b", "url": "https://github.com/line/armeria/commit/c8ae9cf243ddc72f9c1d74a7f69ebb90ad883e5b", "message": "debug AbstractChannel$AnnotatedConnectException stacktrace", "committedDate": "2020-02-16T00:15:55Z", "type": "commit"}, {"oid": "c8ae9cf243ddc72f9c1d74a7f69ebb90ad883e5b", "url": "https://github.com/line/armeria/commit/c8ae9cf243ddc72f9c1d74a7f69ebb90ad883e5b", "message": "debug AbstractChannel$AnnotatedConnectException stacktrace", "committedDate": "2020-02-16T00:15:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2NTY4Mg==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379865682", "bodyText": "flaky test stacktrace\nHttpClientMaxConcurrentStreamTest > exceededMaxStreamsPropagatesFailureCorrectly() FAILED\n    java.lang.IllegalStateException: java.util.concurrent.CompletionException: com.linecorp.armeria.client.UnprocessedRequestException: io.netty.channel.AbstractChannel$AnnotatedConnectException: finishConnect(..) failed: Connection reset by peer: 127.0.0.1/127.0.0.1:37365\n        at com.linecorp.armeria.client.HttpClientMaxConcurrentStreamTest.lambda$exceededMaxStreamsPropagatesFailureCorrectly$18(HttpClientMaxConcurrentStreamTest.java:305)\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)\n        at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)\n        at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382)\n        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482)\n        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472)\n        at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\n        at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\n        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n        at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:485)\n        at com.linecorp.armeria.client.HttpClientMaxConcurrentStreamTest.exceededMaxStreamsPropagatesFailureCorrectly(HttpClientMaxConcurrentStreamTest.java:300)\n        Caused by:\n        java.util.concurrent.CompletionException: com.linecorp.armeria.client.UnprocessedRequestException: io.netty.channel.AbstractChannel$AnnotatedConnectException: finishConnect(..) failed: Connection reset by peer: 127.0.0.1/127.0.0.1:37365\n            at java.util.concurrent.CompletableFuture.reportJoin(CompletableFuture.java:375)\n            at java.util.concurrent.CompletableFuture.join(CompletableFuture.java:1947)\n            at com.linecorp.armeria.common.util.EventLoopCheckingFuture.join(EventLoopCheckingFuture.java:70)\n            at org.assertj.core.api.ThrowableAssert.catchThrowable(ThrowableAssert.java:62)\n            at org.assertj.core.api.AssertionsForClassTypes.catchThrowable(AssertionsForClassTypes.java:750)\n            at org.assertj.core.api.Assertions.catchThrowable(Assertions.java:1179)\n            at com.linecorp.armeria.client.HttpClientMaxConcurrentStreamTest.lambda$exceededMaxStreamsPropagatesFailureCorrectly$18(HttpClientMaxConcurrentStreamTest.java:301)\n            ... 10 more\n            Caused by:\n            com.linecorp.armeria.client.UnprocessedRequestException: io.netty.channel.AbstractChannel$AnnotatedConnectException: finishConnect(..) failed: Connection reset by peer: 127.0.0.1/127.0.0.1:37365\n                at com.linecorp.armeria.client.HttpChannelPool.notifyConnect(HttpChannelPool.java:481)\n                at com.linecorp.armeria.client.HttpChannelPool.lambda$connect$5(HttpChannelPool.java:354)\n                at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)\n                at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:551)\n                at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)\n                at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)\n                at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)\n                at io.netty.util.concurrent.DefaultPromise.setFailure(DefaultPromise.java:109)\n                at com.linecorp.armeria.client.HttpChannelPool.lambda$connect$6(HttpChannelPool.java:376)\n                at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577)\n                at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570)\n                at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549)\n                at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490)\n                at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615)\n                at io.netty.util.concurrent.DefaultPromise.setFailure0(DefaultPromise.java:608)\n                at io.netty.util.concurrent.DefaultPromise.tryFailure(DefaultPromise.java:117)\n                at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.fulfillConnectPromise(AbstractEpollChannel.java:636)\n                at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.finishConnect(AbstractEpollChannel.java:655)\n                at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.epollOutReady(AbstractEpollChannel.java:529)\n                at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:465)\n                at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378)\n                at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\n                at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n                at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n                at java.lang.Thread.run(Thread.java:748)\n                Caused by:\n                io.netty.channel.AbstractChannel$AnnotatedConnectException: finishConnect(..) failed: Connection reset by peer: 127.0.0.1/127.0.0.1:37365\n                    Caused by:\n                    java.net.ConnectException: finishConnect(..) failed: Connection reset by peer\n                        at io.netty.channel.unix.Errors.throwConnectException(Errors.java:124)\n                        at io.netty.channel.unix.Socket.finishConnect(Socket.java:243)\n                        at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.doFinishConnect(AbstractEpollChannel.java:672)\n                        at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.finishConnect(AbstractEpollChannel.java:649)\n                        at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.epollOutReady(AbstractEpollChannel.java:529)\n                        at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:465)\n                        at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:378)\n                        at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\n                        at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n                        at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n                        at java.lang.Thread.run(Thread.java:748)", "author": "jrhee17", "createdAt": "2020-02-16T00:29:34Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +217,184 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses.stream().filter(CompletableFuture::isCompletedExceptionally)\n+                         .forEach(responseFuture -> {\n+                             final Throwable throwable = catchThrowable(responseFuture::join);\n+                             assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                                  .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                             if (!(throwable.getCause().getCause() instanceof ClosedSessionException)) {\n+                                 throw new IllegalStateException(throwable);", "originalCommit": "c8ae9cf243ddc72f9c1d74a7f69ebb90ad883e5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3OTQ5MA==", "url": "https://github.com/line/armeria/pull/2374#discussion_r379879490", "bodyText": "decided to also accept reset from server side as a valid exception for now...", "author": "jrhee17", "createdAt": "2020-02-16T06:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2NTY4Mg=="}], "type": "inlineReview"}, {"oid": "251e1325a9795e6c274356862186caab552f8577", "url": "https://github.com/line/armeria/commit/251e1325a9795e6c274356862186caab552f8577", "message": "handle test flakiness due to connection reset", "committedDate": "2020-02-16T06:22:57Z", "type": "commit"}, {"oid": "251e1325a9795e6c274356862186caab552f8577", "url": "https://github.com/line/armeria/commit/251e1325a9795e6c274356862186caab552f8577", "message": "handle test flakiness due to connection reset", "committedDate": "2020-02-16T06:22:57Z", "type": "forcePushed"}, {"oid": "8e11ee18d52c59a58239a1192051172771149df9", "url": "https://github.com/line/armeria/commit/8e11ee18d52c59a58239a1192051172771149df9", "message": "POC for checking maxConcurrentStreams 0 case -- revert immediately", "committedDate": "2020-02-16T06:32:18Z", "type": "commit"}, {"oid": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d", "url": "https://github.com/line/armeria/commit/085c83b554c2fc197fc316b6baa7ddb5b2b1643d", "message": "Revert \"POC for checking maxConcurrentStreams 0 case -- revert immediately\"\n\nThis reverts commit 8e11ee18d52c59a58239a1192051172771149df9.", "committedDate": "2020-02-16T06:32:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNDA3OA==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380024078", "bodyText": "MAX_NUM_CONNECTIONS", "author": "trustin", "createdAt": "2020-02-17T07:46:57Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -168,4 +218,185 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n             assertThat(closes).hasValue(0);\n         }\n     }\n+\n+    @Test\n+    void handleExceedsMaxStreamsBasicCase() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final int numRequests = MAX_CONCURRENT_STREAMS + 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void openMinimalConnectionsWhenExceededMaxStreams() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+\n+        final int numExpectedConnections = 4;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests; i++) {\n+                client.get(PATH).aggregate();\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests - 1);\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsPropagatesFailureCorrectly() throws Exception {\n+        final Queue<ClientConnectionTimings> connectionTimings = new ConcurrentLinkedQueue<>();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .decorator(connectionTimingsAccumulatingDecorator(connectionTimings))\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+        final List<CompletableFuture<AggregatedHttpResponse>> receivedResponses = new ArrayList<>();\n+\n+        final int numExpectedConnections = 6;\n+        final int numRequests = MAX_CONCURRENT_STREAMS * numExpectedConnections;\n+        final int numFailedRequests = MAX_CONCURRENT_STREAMS - 1;\n+\n+        runInsideEventLoop(clientFactory.eventLoopGroup(), () -> {\n+            for (int i = 0; i < numRequests + numFailedRequests; i++) {\n+                receivedResponses.add(client.get(PATH).aggregate());\n+            }\n+        });\n+\n+        await().untilAsserted(() -> assertThat(responses).hasSize(numRequests));\n+        assertThat(opens).hasValue(numExpectedConnections);\n+        assertThat(connectionTimings.stream().filter(\n+                timings -> timings.pendingAcquisitionDurationNanos() > 0))\n+                .hasSize(numRequests + numFailedRequests - 1);\n+\n+        // Check exception thrown by responses\n+        await().untilAsserted(() -> assertThat(receivedResponses.stream().filter(\n+                CompletableFuture::isCompletedExceptionally)).hasSize(2));\n+\n+        receivedResponses\n+                .stream().filter(CompletableFuture::isCompletedExceptionally)\n+                .forEach(responseFuture -> {\n+                    final Throwable throwable = catchThrowable(responseFuture::join);\n+                    assertThat(throwable).isInstanceOf(CompletionException.class)\n+                                         .hasCauseInstanceOf(UnprocessedRequestException.class);\n+                    assertThat(throwable.getCause().getCause()).satisfiesAnyOf(\n+                            e -> assertThat(e).isInstanceOf(ClosedSessionException.class),\n+                            e -> assertThat(e).isInstanceOf(ConnectException.class)\n+                                                .hasMessageContaining(\"reset by peer\"));\n+                });\n+    }\n+\n+    @Test\n+    void exceededMaxStreamsForMultipleEventLoops() {\n+        final ClientFactory clientFactory =\n+                ClientFactory.builder()\n+                             .connectionPoolListener(connectionPoolListenerWrapper)\n+                             .maxNumEventLoopsPerEndpoint(2)\n+                             .build();\n+        final WebClient client = WebClient.builder(server.uri(SessionProtocol.H2C))\n+                                          .factory(clientFactory)\n+                                          .build();\n+        final AtomicInteger opens = new AtomicInteger();\n+        connectionPoolListener = newConnectionPoolListener(opens::incrementAndGet, () -> {});\n+\n+        final int numExpectedConnections = 6;", "originalCommit": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNDUwNw==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380024507", "bodyText": "Could you move these three methods to the bottom for readability?", "author": "trustin", "createdAt": "2020-02-17T07:48:17Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -62,9 +71,59 @@ protected void configure(ServerBuilder sb) throws Exception {\n                 return HttpResponse.from(f);\n             });\n             sb.http2MaxStreamsPerConnection(MAX_CONCURRENT_STREAMS);\n+            sb.maxNumConnections(MAX_NUM_CONNECTIONS);\n+            sb.idleTimeoutMillis(3000);\n         }\n     };\n \n+    @RegisterExtension\n+    static final ServerExtension serverWithMaxConcurrentStreams_1 = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.service(PATH, (ctx, req) -> {\n+                final CompletableFuture<HttpResponse> f = new CompletableFuture<>();\n+                responses.add(f);\n+                return HttpResponse.from(f);\n+            });\n+            sb.http2MaxStreamsPerConnection(1);\n+            sb.maxNumConnections(MAX_NUM_CONNECTIONS);\n+            sb.idleTimeoutMillis(3000);\n+        }\n+    };\n+\n+    // running inside an event loop ensures requests are queued before an initial connect attempt completes.\n+    private static void runInsideEventLoop(EventLoopGroup eventLoopGroup, Runnable runnable) {\n+        eventLoopGroup.execute(runnable);\n+    }\n+\n+    private static DecoratingHttpClientFunction connectionTimingsAccumulatingDecorator(\n+            Queue<ClientConnectionTimings> connectionTimings) {\n+        return (delegate, ctx, req) -> {\n+            ctx.logBuilder().whenAvailable(RequestLogProperty.SESSION)\n+               .thenAccept(requestLog -> {\n+                   connectionTimings.add(requestLog.connectionTimings());\n+               });\n+            return delegate.execute(ctx, req);\n+        };\n+    }\n+\n+    private static ConnectionPoolListener newConnectionPoolListener(\n+            Runnable openRunnable, Runnable closeRunnable) {\n+        return new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                openRunnable.run();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                closeRunnable.run();\n+            }\n+        };\n+    }", "originalCommit": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6d6ade4be729a73e5c41fb35b1e1a315b559442d", "url": "https://github.com/line/armeria/commit/6d6ade4be729a73e5c41fb35b1e1a315b559442d", "message": "oops -- delete random file", "committedDate": "2020-02-17T07:55:23Z", "type": "commit"}, {"oid": "22db592195fb4407f7d70e25f8cd9a756dfb063d", "url": "https://github.com/line/armeria/commit/22db592195fb4407f7d70e25f8cd9a756dfb063d", "message": "reuse static variable, move static methods to bottom for readability", "committedDate": "2020-02-17T07:56:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380026029", "bodyText": "Don't we need to limit pending acquisition time? I think we have no chance to trigger timeout for long waiting requests. \ud83e\uddd0 Any thoughts? /cc @trustin", "author": "ikhoon", "createdAt": "2020-02-17T07:52:57Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpChannelPool.java", "diffHunk": "@@ -276,7 +285,12 @@ private boolean usePendingAcquisition(SessionProtocol desiredProtocol, PoolKey k\n             if (cause == null) {\n                 final SessionProtocol actualProtocol = pch.protocol();\n                 if (actualProtocol.isMultiplex()) {\n-                    promise.complete(pch);\n+                    final HttpSession session = HttpSession.get(pch.get());\n+                    if (session.maxUnfinishedResponses() - session.unfinishedResponses() <= 1) {\n+                        acquireLater(actualProtocol, key, timingsBuilder, promise);", "originalCommit": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMDgzNw==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380030837", "bodyText": "Agreed. Probably worth a separate pull request?", "author": "trustin", "createdAt": "2020-02-17T08:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMTI5MQ==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380031291", "bodyText": "Oh, that is better. \ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-02-17T08:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMjEzOA==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380032138", "bodyText": "You mean on the off-chance an unknowing user uses MAX_CONCURRENT_STREAMS = 1 and burst requests 10000 connections at ocne right?\nLet me create a separate issue for this as this had me a little worried as well", "author": "jrhee17", "createdAt": "2020-02-17T08:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMjc0Ng==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380032746", "bodyText": "You can set a special timeout for pending acquisition time, or could set a call timeout like OkHttp? https://square.github.io/okhttp/4.x/okhttp/okhttp3/-call/timeout/", "author": "ikhoon", "createdAt": "2020-02-17T08:12:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzNDg0NA==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380034844", "bodyText": "Maybe just reuse ChannelOption.CONNECT_TIMEOUT and later introduce a new option if there's demand?", "author": "trustin", "createdAt": "2020-02-17T08:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzNjcxOQ==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380036719", "bodyText": "sounds good to me as I don't think most users will know what pendingAcquisitionTimeoutMillis is \ud83d\ude09", "author": "jrhee17", "createdAt": "2020-02-17T08:22:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzNzQ1Mg==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380037452", "bodyText": "Agreed! I saw only ClientOption.*TIMEOUT_MILLIS. ChannelOption.CONNECT_TIMEOUT makes sense.", "author": "ikhoon", "createdAt": "2020-02-17T08:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyNjk3NA==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380026974", "bodyText": "nit: serverWithMaxConcurrentStreams1? Prefer camel case for variables. \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-02-17T07:55:44Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -62,9 +71,59 @@ protected void configure(ServerBuilder sb) throws Exception {\n                 return HttpResponse.from(f);\n             });\n             sb.http2MaxStreamsPerConnection(MAX_CONCURRENT_STREAMS);\n+            sb.maxNumConnections(MAX_NUM_CONNECTIONS);\n+            sb.idleTimeoutMillis(3000);\n         }\n     };\n \n+    @RegisterExtension\n+    static final ServerExtension serverWithMaxConcurrentStreams_1 = new ServerExtension() {", "originalCommit": "085c83b554c2fc197fc316b6baa7ddb5b2b1643d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9a2f6c8c630c8562ddabd818695894949f83ab8b", "url": "https://github.com/line/armeria/commit/9a2f6c8c630c8562ddabd818695894949f83ab8b", "message": "prefer MAX_NUM_CONNECTIONS over primitive value", "committedDate": "2020-02-17T08:07:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyOTYyMw==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380029623", "bodyText": "Could remove !pendingAcquisitionEndSet?", "author": "ikhoon", "createdAt": "2020-02-17T08:03:26Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ClientConnectionTimingsBuilder.java", "diffHunk": "@@ -95,8 +95,10 @@ public ClientConnectionTimingsBuilder socketConnectEnd() {\n      * in order to use one connection for HTTP/2.\n      */\n     public ClientConnectionTimingsBuilder pendingAcquisitionStart() {\n-        pendingAcquisitionStartTimeMicros = SystemInfo.currentTimeMicros();\n-        pendingAcquisitionStartNanos = System.nanoTime();\n+        if (pendingAcquisitionStartTimeMicros == 0 && !pendingAcquisitionEndSet) {", "originalCommit": "22db592195fb4407f7d70e25f8cd9a756dfb063d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMjUwMQ==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380032501", "bodyText": "I think we can't because pendingAcquisitionStart* will be overwritten", "author": "trustin", "createdAt": "2020-02-17T08:11:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyOTYyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzNDQ2OA==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380034468", "bodyText": "Ah, please ignore this preview. \ud83d\ude09", "author": "ikhoon", "createdAt": "2020-02-17T08:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyOTYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAzMDY1MQ==", "url": "https://github.com/line/armeria/pull/2374#discussion_r380030651", "bodyText": "Remove public for methods and class?", "author": "ikhoon", "createdAt": "2020-02-17T08:06:27Z", "path": "core/src/test/java/com/linecorp/armeria/client/HttpClientMaxConcurrentStreamTest.java", "diffHunk": "@@ -92,16 +118,16 @@ public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteA\n     @Nullable\n     private volatile ConnectionPoolListener connectionPoolListener;\n \n-    @Before\n+    @BeforeEach\n     public void setUp() {\n         clientFactory = ClientFactory.builder()\n                                      .workerGroup(EventLoopGroups.newEventLoopGroup(1), true)\n                                      .connectionPoolListener(connectionPoolListenerWrapper)\n                                      .build();\n     }\n \n-    @After\n-    public void tearDown() {\n+    @AfterEach\n+    public void tearDown() throws Exception {", "originalCommit": "22db592195fb4407f7d70e25f8cd9a756dfb063d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "80122206665ec6c5ea82e25151e8de991df52088", "url": "https://github.com/line/armeria/commit/80122206665ec6c5ea82e25151e8de991df52088", "message": "remove before/after each public modifiers from test", "committedDate": "2020-02-17T08:18:09Z", "type": "commit"}]}