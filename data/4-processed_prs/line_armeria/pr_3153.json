{"pr_number": 3153, "pr_title": "Fix a bug where a gRPC ServerCall is invoked after a stream is closed", "pr_createdAt": "2020-11-04T05:58:09Z", "pr_url": "https://github.com/line/armeria/pull/3153", "timeline": [{"oid": "fe2e927b2616ad18f3a07d27421449c310b567ab", "url": "https://github.com/line/armeria/commit/fe2e927b2616ad18f3a07d27421449c310b567ab", "message": "Fix a bug where a gRPC ServerCall is invoked after a stream is closed\n\nMotivation:\n\nWhen a stream is closed by a remote peer, `ArmeriaServerCall` is closed by `res.whenComplete()` listener.\nhttps://github.com/line/armeria/blob/6e24e7817f8be94ab21ddba7879e9f84ca840229/grpc/src/main/java/com/linecorp/armeria/server/grpc/ArmeriaServerCall.java#L173-L182\n\nIf a service performs a long running task, `ArmeriaServerCall.sendHeaders()` or\n`ArmeriaServerCall.sendMessage()` will be called when a response is written.\nBecause gRPC-Java `ServerCallStreamObserver` implementation invokes `ServerCall` even if a call is cancelled with some conditions.\nhttps://github.com/grpc/grpc-java/blob/d52b359631ee1ac46f47d72d1015e1dd6ce9312c/stub/src/main/java/io/grpc/stub/ServerCalls.java#L346-L358\n\nModifications:\n\n- Check `cancelled` flag before validating the closing states.\n\nResult:\n\n- `ArmeriaServerCall` is now closed exatly once.", "committedDate": "2020-11-04T05:57:40Z", "type": "commit"}, {"oid": "1ec6eb970d7ca17c4b519da2d7659376c7df60e4", "url": "https://github.com/line/armeria/commit/1ec6eb970d7ca17c4b519da2d7659376c7df60e4", "message": "Address comments by @okue", "committedDate": "2020-11-04T06:47:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzODI1Mw==", "url": "https://github.com/line/armeria/pull/3153#discussion_r517138253", "bodyText": "If the understanding is correct,\nArmeria gRPC client sets timeout when either option Client.responseTimeout or io.grpc.Stub.withDelay is specified.\nAfter timed out, the client raises DEADLINE_EXCEEDED.\nhttps://github.com/line/armeria/blob/armeria-1.2.0/grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/ArmeriaClientCall.java#L189-L207\nBesides, if the either options of them is specified, the client send grpc-timeout to the server, and the server also set timeout.\nAfter timed out at the server side, the server returns CANCELLED to the client.\nhttps://github.com/line/armeria/blob/armeria-1.2.0/grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/ArmeriaClientCall.java#L398\nhttps://github.com/line/armeria/blob/armeria-1.2.0/grpc/src/main/java/com/linecorp/armeria/server/grpc/FramedGrpcService.java#L190\nSo, I think there are two possibilities of the error code raised by the client.", "author": "okue", "createdAt": "2020-11-04T07:20:51Z", "path": "grpc/src/test/java/com/linecorp/armeria/client/grpc/GrpcClientTimeoutTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client.grpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowableOfType;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.grpc.GrpcSerializationFormats;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleRequest;\n+import com.linecorp.armeria.grpc.testing.Messages.SimpleResponse;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceBlockingStub;\n+import com.linecorp.armeria.grpc.testing.TestServiceGrpc.TestServiceImplBase;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.grpc.GrpcService;\n+import com.linecorp.armeria.testing.junit5.server.ServerExtension;\n+\n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.Appender;\n+import io.grpc.Status.Code;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+\n+class GrpcClientTimeoutTest {\n+\n+    private static final ch.qos.logback.classic.Logger rootLogger =\n+            (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);\n+\n+    @Mock\n+    private Appender<ILoggingEvent> appender;\n+\n+    @Captor\n+    private ArgumentCaptor<ILoggingEvent> loggingEventCaptor;\n+\n+    @BeforeEach\n+    void setupLogger() {\n+        rootLogger.addAppender(appender);\n+    }\n+\n+    @AfterEach\n+    void cleanupLogger() {\n+        rootLogger.detachAppender(appender);\n+    }\n+\n+    @RegisterExtension\n+    static ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.requestTimeoutMillis(2000);\n+            sb.service(GrpcService.builder()\n+                                  .addService(new SlowService())\n+                                  .build());\n+        }\n+    };\n+\n+    @Test\n+    void clientTimeout() throws InterruptedException {\n+        final TestServiceBlockingStub client =\n+                Clients.newClient(server.httpUri(GrpcSerializationFormats.PROTO),\n+                                  TestServiceBlockingStub.class);\n+        final StatusRuntimeException exception = catchThrowableOfType(() -> {\n+            client.withDeadlineAfter(1000, TimeUnit.MILLISECONDS)\n+                  .unaryCall(SimpleRequest.getDefaultInstance());\n+        }, StatusRuntimeException.class);\n+        assertThat(exception.getStatus().getCode()).isEqualTo(Code.DEADLINE_EXCEEDED);", "originalCommit": "1ec6eb970d7ca17c4b519da2d7659376c7df60e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1MTcyNw==", "url": "https://github.com/line/armeria/pull/3153#discussion_r517151727", "bodyText": "If the understanding is correct,\n\nYes, exactly.\na gRPC client actively raises DEADLINE_EXCEEDED or CANCELLED by retruned status code.", "author": "ikhoon", "createdAt": "2020-11-04T07:52:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzODI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1NDc5NA==", "url": "https://github.com/line/armeria/pull/3153#discussion_r517154794", "bodyText": "JFYI (I guess you already know this code), the following mappings convert an exception to status code.\n\n  \n    \n      armeria/grpc/src/main/java/com/linecorp/armeria/internal/common/grpc/GrpcStatus.java\n    \n    \n        Lines 78 to 112\n      in\n      1b6d85f\n    \n    \n    \n    \n\n        \n          \n           public static Status fromThrowable(Throwable t) { \n        \n\n        \n          \n               t = unwrap(requireNonNull(t, \"t\")); \n        \n\n        \n          \n            \n        \n\n        \n          \n               final Status s = Status.fromThrowable(t); \n        \n\n        \n          \n               if (s.getCode() != Code.UNKNOWN) { \n        \n\n        \n          \n                   return s; \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               if (t instanceof ClosedSessionException || t instanceof ClosedChannelException) { \n        \n\n        \n          \n                   // ClosedChannelException is used any time the Netty channel is closed. Proper error \n        \n\n        \n          \n                   // processing requires remembering the error that occurred before this one and using it \n        \n\n        \n          \n                   // instead. \n        \n\n        \n          \n                   return s; \n        \n\n        \n          \n               } \n        \n\n        \n          \n               if (t instanceof ClosedStreamException) { \n        \n\n        \n          \n                   return Status.CANCELLED; \n        \n\n        \n          \n               } \n        \n\n        \n          \n               if (t instanceof UnprocessedRequestException || t instanceof IOException) { \n        \n\n        \n          \n                   return Status.UNAVAILABLE.withCause(t); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               if (t instanceof Http2Exception) { \n        \n\n        \n          \n                   if (t instanceof Http2Exception.StreamException && \n        \n\n        \n          \n                       ((Http2Exception.StreamException) t).error() == Http2Error.CANCEL) { \n        \n\n        \n          \n                       return Status.CANCELLED; \n        \n\n        \n          \n                   } \n        \n\n        \n          \n                   return Status.INTERNAL.withCause(t); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               if (t instanceof TimeoutException) { \n        \n\n        \n          \n                   return Status.DEADLINE_EXCEEDED.withCause(t); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               if (t instanceof ContentTooLargeException) { \n        \n\n        \n          \n                   return Status.RESOURCE_EXHAUSTED.withCause(t); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               return s; \n        \n\n        \n          \n           }", "author": "ikhoon", "createdAt": "2020-11-04T07:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzODI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE2NDE4NQ==", "url": "https://github.com/line/armeria/pull/3153#discussion_r517164185", "bodyText": "In this test case, does the client never raise CANCELLED?", "author": "okue", "createdAt": "2020-11-04T08:18:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzODI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI4ODI4Nw==", "url": "https://github.com/line/armeria/pull/3153#discussion_r517288287", "bodyText": "Good point. It is possible. I think it depends on Operating System scheduling.\n\n\nA client sends a remaining timeout to a server. When the server schedules the timeout, network latency is not considered. Therefore, in most cases, the client will close a stream if a deadline exceeded.\n\n\nHowever, a client CPU is busy and hard to get CPU cycles to schedule a timeout for the deadline, a server timeout scheduler will be triggered and close a stream before the client deadline exceeded.", "author": "ikhoon", "createdAt": "2020-11-04T11:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzODI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5MDQxMQ==", "url": "https://github.com/line/armeria/pull/3153#discussion_r517290411", "bodyText": "Eventually to resolve this problem, as @trustin said in slack channel, we need to unify the timeout.", "author": "ikhoon", "createdAt": "2020-11-04T11:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzODI1Mw=="}], "type": "inlineReview"}, {"oid": "70d5e80f21e94c981d5ac1205431ee8443453c59", "url": "https://github.com/line/armeria/commit/70d5e80f21e94c981d5ac1205431ee8443453c59", "message": "Fix flasky", "committedDate": "2020-11-04T07:55:43Z", "type": "commit"}]}