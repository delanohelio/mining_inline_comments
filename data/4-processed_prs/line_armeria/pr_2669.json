{"pr_number": 2669, "pr_title": "Support Kotlin-gRPC client CoroutineStub", "pr_createdAt": "2020-04-16T07:37:26Z", "pr_url": "https://github.com/line/armeria/pull/2669", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1NTIzNQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409355235", "bodyText": "Not necessarily related to this PR but how about renaming stubClass to enclosingClass? Stub class is clientType actually.", "author": "trustin", "createdAt": "2020-04-16T07:56:12Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/GrpcClientFactory.java", "diffHunk": "@@ -91,6 +94,13 @@ public Object newClient(ClientBuilderParams params) {\n \n         final HttpClient httpClient = newHttpClient(params);\n         final Method stubFactoryMethod = findStubFactoryMethod(clientType, stubClass);", "originalCommit": "e4fd5331c8258bbda348fddbcf0fab03e01f3f95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1Njg2NA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409356864", "bodyText": "Yeah, sounds good!", "author": "ikhoon", "createdAt": "2020-04-16T07:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1NTIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1ODQ0MQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409358441", "bodyText": "This comment seems inconsistent with the actual code", "author": "gary-lo", "createdAt": "2020-04-16T08:01:24Z", "path": "examples/grpc-kotlin/src/main/kotlin/example/armeria/grpc/kotlin/HelloServiceImpl.kt", "diffHunk": "@@ -42,13 +38,12 @@ class HelloServiceImpl : HelloServiceGrpc.HelloServiceImplBase() {\n         // 3. Call a blocking API in the separate thread pool you manage.\n         //\n         // In this example, we chose the option 1:", "originalCommit": "25fd95fbe0953596cc8830d234a9db1077fc7ebb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM3NjMzMA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409376330", "bodyText": "Let me remove all of this comment. Because this method does not run in the event loop.\nI am investigating how to run a coroutine on an Armeria event loop.", "author": "ikhoon", "createdAt": "2020-04-16T08:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1ODQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM2MDA4OA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409360088", "bodyText": "This sleeps this thread. The original example was trying to emulate a background long running task running. Did we consider  using https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html ?", "author": "gary-lo", "createdAt": "2020-04-16T08:04:15Z", "path": "examples/grpc-kotlin/src/main/kotlin/example/armeria/grpc/kotlin/HelloServiceImpl.kt", "diffHunk": "@@ -42,13 +38,12 @@ class HelloServiceImpl : HelloServiceGrpc.HelloServiceImplBase() {\n         // 3. Call a blocking API in the separate thread pool you manage.\n         //\n         // In this example, we chose the option 1:\n-        ServiceRequestContext.current().blockingTaskExecutor().submit {\n+        return runBlocking {", "originalCommit": "25fd95fbe0953596cc8830d234a9db1077fc7ebb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM3NDIyNQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409374225", "bodyText": "I thought runBlocking submit the task to blocking thread pool. Thanks for pointing out. \ud83d\udc4d\nwithContext(Dispatchers.IO) will work as expected.", "author": "ikhoon", "createdAt": "2020-04-16T08:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM2MDA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MDEyMg==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409460122", "bodyText": "coroutines running on event loop will be awesome. Does Dispatchers.Unconfined allow that to happen? I guess callbacks will return on any arbitrary thread. If that's the case, we should investigate more and probably need to implement Dispatchers.ArmeriaContext. Not sure, but maybe it just means creating an implementation of the interface that delegates all methods to RequestContext.contextAwareExecutor().asCoroutineDispatcher()", "author": "anuraaga", "createdAt": "2020-04-16T10:44:43Z", "path": "examples/grpc-kotlin/src/main/kotlin/example/armeria/grpc/kotlin/HelloServiceImpl.kt", "diffHunk": "@@ -3,52 +3,50 @@ package example.armeria.grpc.kotlin\n import com.linecorp.armeria.server.ServiceRequestContext\n import example.armeria.grpc.kotlin.Hello.HelloReply\n import example.armeria.grpc.kotlin.Hello.HelloRequest\n-import io.grpc.stub.StreamObserver\n-import java.time.Duration\n-import java.util.concurrent.TimeUnit\n-import reactor.core.publisher.Flux\n-import reactor.core.scheduler.Schedulers\n-\n-class HelloServiceImpl : HelloServiceGrpc.HelloServiceImplBase() {\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.delay\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.collect\n+import kotlinx.coroutines.flow.flow\n+import kotlinx.coroutines.flow.map\n+import kotlinx.coroutines.flow.toList\n+import kotlinx.coroutines.withContext\n+\n+/**\n+ * Note that if you want to run [HelloServiceImpl] in an event loop and\n+ * get a current [ServiceRequestContext],\n+ * you should initialize [HelloServiceImpl] with [Dispatchers.Unconfined].", "originalCommit": "d627ad280b1af3b336bb4185ab00431d444f9b62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2NTIzOQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409465239", "bodyText": "For reference, in our non-grpc example, we use this GlobalScope pattern and can confirm the context / executor everywhere.\nhttps://github.com/line/armeria/blob/master/examples/context-propagation/kotlin/src/main/kotlin/example/armeria/contextpropagation/kotlin/MainService.kt#L43\nNot sure how that corresponds to this constructor though.", "author": "anuraaga", "createdAt": "2020-04-16T10:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MDEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2ODIwMw==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409468203", "bodyText": "Thanks for the advice! Let me take a look. \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-04-16T10:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MDEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2OTQxOA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409469418", "bodyText": "Does Dispatchers.Unconfined allow that to happen?\n\nDispatchers.Unconfined run coroutines on the current thread. I thought if this method is called by Armeria gRPC service, this will run an event loop.", "author": "ikhoon", "createdAt": "2020-04-16T11:01:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MDEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ3MDMzNg==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409470336", "bodyText": "If it works that's great :) Main concern is doc says not \"mandating any threading policy\" so it sounds like it'd be random.\nhttps://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html", "author": "anuraaga", "createdAt": "2020-04-16T11:03:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MDEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MDcyNQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409460725", "bodyText": "Not sure, but I guess it's more idiomatic for an armeria app to use the blocking task executor - it's context aware and is language-agnostic. Should we stick with blockingTaskExecutor, either using submit or withContext(blockingTaskExecutor().asCoroutineDispatcher())?", "author": "anuraaga", "createdAt": "2020-04-16T10:45:55Z", "path": "examples/grpc-kotlin/src/main/kotlin/example/armeria/grpc/kotlin/HelloServiceImpl.kt", "diffHunk": "@@ -3,52 +3,50 @@ package example.armeria.grpc.kotlin\n import com.linecorp.armeria.server.ServiceRequestContext\n import example.armeria.grpc.kotlin.Hello.HelloReply\n import example.armeria.grpc.kotlin.Hello.HelloRequest\n-import io.grpc.stub.StreamObserver\n-import java.time.Duration\n-import java.util.concurrent.TimeUnit\n-import reactor.core.publisher.Flux\n-import reactor.core.scheduler.Schedulers\n-\n-class HelloServiceImpl : HelloServiceGrpc.HelloServiceImplBase() {\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.delay\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.collect\n+import kotlinx.coroutines.flow.flow\n+import kotlinx.coroutines.flow.map\n+import kotlinx.coroutines.flow.toList\n+import kotlinx.coroutines.withContext\n+\n+/**\n+ * Note that if you want to run [HelloServiceImpl] in an event loop and\n+ * get a current [ServiceRequestContext],\n+ * you should initialize [HelloServiceImpl] with [Dispatchers.Unconfined].\n+ * See https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html\n+ * Unless [Dispatchers.Default] executor will handle this service.\n+ */\n+class HelloServiceImpl : HelloServiceGrpcKt.HelloServiceCoroutineImplBase(Dispatchers.Unconfined) {\n \n     /**\n      * Sends a [HelloReply] immediately when receiving a request.\n      */\n-    override fun hello(request: HelloRequest, responseObserver: StreamObserver<HelloReply>) {\n-        responseObserver.onNext(buildReply(toMessage(request.name)))\n-        responseObserver.onCompleted()\n+    override suspend fun hello(request: HelloRequest): HelloReply {\n+        // Make sure that current thread is request context aware\n+        ServiceRequestContext.current();\n+        return buildReply(toMessage(request.name))\n     }\n \n-    override fun lazyHello(request: HelloRequest, responseObserver: StreamObserver<HelloReply>) {\n-        // You can use the event loop for scheduling a task.\n-        ServiceRequestContext.current().contextAwareEventLoop().schedule({\n-            responseObserver.onNext(buildReply(toMessage(request.name)))\n-            responseObserver.onCompleted()\n-        }, 3, TimeUnit.SECONDS)\n+    override suspend fun lazyHello(request: HelloRequest): HelloReply {\n+        delay(3000L)\n+        return buildReply(toMessage(request.name))\n     }\n \n     /**\n      * Sends a [HelloReply] using `blockingTaskExecutor`.\n      *\n      * @see [Blocking service implementation](https://line.github.io/armeria/server-grpc.html#blocking-service-implementation)\n      */\n-    override fun blockingHello(request: HelloRequest, responseObserver: StreamObserver<HelloReply>) {\n-        // Unlike upstream gRPC-Java, Armeria does not run service logic in a separate thread pool by default.\n-        // Therefore, this method will run in the event loop, which means that you can suffer the performance\n-        // degradation if you call a blocking API in this method. In this case, you have the following options:\n-        //\n-        // 1. Call a blocking API in the blockingTaskExecutor provided by Armeria.\n-        // 2. Set `GrpcServiceBuilder.useBlockingTaskExecutor(true)` when building your GrpcService.\n-        // 3. Call a blocking API in the separate thread pool you manage.\n-        //\n-        // In this example, we chose the option 1:\n-        ServiceRequestContext.current().blockingTaskExecutor().submit {\n+    override suspend fun blockingHello(request: HelloRequest): HelloReply {\n+        return withContext(Dispatchers.IO) {", "originalCommit": "d627ad280b1af3b336bb4185ab00431d444f9b62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2NjQyMg==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409466422", "bodyText": "I've updated before reading your review \ud83e\udd23", "author": "ikhoon", "createdAt": "2020-04-16T10:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MDcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MDk1Ng==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409460956", "bodyText": "Can you check context between delay / emit?", "author": "anuraaga", "createdAt": "2020-04-16T10:46:21Z", "path": "examples/grpc-kotlin/src/main/kotlin/example/armeria/grpc/kotlin/HelloServiceImpl.kt", "diffHunk": "@@ -57,69 +55,34 @@ class HelloServiceImpl : HelloServiceGrpc.HelloServiceImplBase() {\n      *\n      * @see lazyHello(HelloRequest, StreamObserver)\n      */\n-    override fun lotsOfReplies(request: HelloRequest, responseObserver: StreamObserver<HelloReply>) {\n+    override fun lotsOfReplies(request: HelloRequest): Flow<HelloReply> {\n         // You can also write this code without Reactor like 'lazyHello' example.\n-        Flux.interval(Duration.ofSeconds(1))\n-                .take(5)\n-                .map { \"Hello, ${request.name}! (sequence: ${it + 1})\" }\n-                // You can make your Flux/Mono publish the signals in the RequestContext-aware executor.\n-                .publishOn(Schedulers.fromExecutor(ServiceRequestContext.current().contextAwareExecutor()))\n-                .subscribe({\n-                    // Confirm this callback is being executed on the RequestContext-aware executor.\n-                    ServiceRequestContext.current()\n-                    responseObserver.onNext(buildReply(it))\n-                },\n-                {\n-                    // Confirm this callback is being executed on the RequestContext-aware executor.\n-                    ServiceRequestContext.current()\n-                    responseObserver.onError(it)\n-                },\n-                {\n-                    // Confirm this callback is being executed on the RequestContext-aware executor.\n-                    ServiceRequestContext.current()\n-                    responseObserver.onCompleted()\n-                })\n+        return flow {\n+            for (i in 1..5) {\n+                delay(1000)\n+                emit(buildReply(\"Hello, ${request.name}! (sequence: $i)\")) // emit next value", "originalCommit": "d627ad280b1af3b336bb4185ab00431d444f9b62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2Mzg2NA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409463864", "bodyText": "I guess preserving context is required - even better is if context.eventLoop().inEventLoop(); but if thread is changing without losing context, we could probably fix that later.", "author": "anuraaga", "createdAt": "2020-04-16T10:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MDk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0ODM1MA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409948350", "bodyText": "I thought they are running on the same thread. But delay(1000) changed the current thread to the coroutine default context thread.\nAfter some investigating, I figured out that flowOn(eventLoop().asCoroutineDispatcher()) make delay() and emit() run on Armeria event loop.", "author": "ikhoon", "createdAt": "2020-04-17T01:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MDk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk4NzIxMg==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409987212", "bodyText": "This looks similar to the rxjava pattern we use, but doesn't seem to take advantage of kotlin coroutines fully. I guess it's because of Dispatcher.Unconfined. Did you get to try implementing a custom dispatcher for armeria? I found some tips here\nMaybe this pattern works\n override val executor: Executor get() = RequestContext.current().contextAwareExecutor()\nhttps://github.com/Kotlin/kotlinx.coroutines/blob/d7de5f5ba66a8d005e5cbd03b18522112303fd54/kotlinx-coroutines-core/jvm/src/scheduling/Dispatcher.kt#L54\nI guess we just need to extend this class\nhttps://github.com/Kotlin/kotlinx.coroutines/blob/d7de5f5ba66a8d005e5cbd03b18522112303fd54/kotlinx-coroutines-core/jvm/src/Executors.kt#L19\nSimilar to how it's done here\nhttps://github.com/Kotlin/kotlinx.coroutines/blob/d7de5f5ba66a8d005e5cbd03b18522112303fd54/kotlinx-coroutines-core/jvm/src/Executors.kt#L72\nIt looks sort of complicated, but I guess we need something to make the kotlin experience nice", "author": "anuraaga", "createdAt": "2020-04-17T04:32:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MDk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAwNTM3Nw==", "url": "https://github.com/line/armeria/pull/2669#discussion_r410005377", "bodyText": "Thanks for sharing the useful links! Let me try to implement ArmeriaDispatcher. \ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-04-17T05:49:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MDk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3NDQ5OA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r410174498", "bodyText": "I've tried to implement ArmeriaDispatcher. but faced a problem.\nWhen ArmeriaDispatcher is injected,\n\nAn Armeria event loop serves the coroutine stub directly.\ndelay(..) is handled by a coroutine default dispatcher.\nwhen the delay is done, the dispatcher thread calls the RequestContext.current().contextAwareExecutor()\n\nTo solve this, we need to capture the executor. IMHO it seems to difficult in the current API.\nI approached it in a different way. gRPC-Kotlin propagates gRPC context already.\nhttps://github.com/grpc/grpc-kotlin/blob/2f3d86b661894d2047c98ca8082932dffc8378d1/stub/src/main/java/io/grpc/kotlin/ServerCalls.kt#L199\n\nServiceRequestContext is set to gRPC context before calling Coroutine Stub.\nExtract ServiceRequestContext from gRPC context using ArmeriaContextElement.\nSo we don't need to Armeria event loop to access RequestContext.\n\nIf this workaround is reasonable, I would like to add grpc-kotlin module to Armeria.\n/cc @anuraaga", "author": "ikhoon", "createdAt": "2020-04-17T11:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MDk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0MjM3Mw==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409942373", "bodyText": "Let's move these down.", "author": "minwoox", "createdAt": "2020-04-17T01:34:50Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/GrpcClientFactory.java", "diffHunk": "@@ -84,18 +87,25 @@ public Object newClient(ClientBuilderParams params) {\n         final ClientOptions options = params.options();\n \n         final SerializationFormat serializationFormat = scheme.serializationFormat();\n-        final Class<?> stubClass = clientType.getEnclosingClass();\n-        if (stubClass == null) {\n+        final Class<?> enclosingClass = clientType.getEnclosingClass();\n+        if (enclosingClass == null) {\n             throw newUnknownClientTypeException(clientType);\n         }\n \n         final HttpClient httpClient = newHttpClient(params);\n-        final Method stubFactoryMethod = findStubFactoryMethod(clientType, stubClass);\n+        final Method stubFactoryMethod = findStubFactoryMethod(clientType, enclosingClass);\n+        Constructor<?> stubConstructor = null;\n+        if (stubFactoryMethod == null) {\n+            stubConstructor = findStubConstructor(clientType);\n+            if (stubConstructor == null) {\n+                throw newUnknownClientTypeException(clientType);\n+            }\n+        }", "originalCommit": "eafaa69721d22606c78c830b967a1fdad9de2650", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0MjYzMA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409942630", "bodyText": "final Method stubFactoryMethod = findStubFactoryMethod(clientType, enclosingClass);\ntry {\n    // Verified stubFactoryMethod.getReturnType() == clientType in findStubFactoryMethod().\n    if (stubFactoryMethod != null) {\n        return stubFactoryMethod.invoke(null, channel);\n    } else {\n        final Constructor<?> stubConstructor = findStubConstructor(clientType);\n        if (stubConstructor == null) {\n            throw newUnknownClientTypeException(clientType);\n        }\n        return stubConstructor.newInstance(channel);\n    }\n} catch (IllegalAccessException | InvocationTargetException | InstantiationException e) {\n    throw new IllegalStateException(\"Could not create a gRPC stub through reflection.\", e);\n}", "author": "minwoox", "createdAt": "2020-04-17T01:35:44Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/client/grpc/GrpcClientFactory.java", "diffHunk": "@@ -108,15 +118,20 @@ public Object newClient(ClientBuilderParams params) {\n \n         try {\n             // Verified stubFactoryMethod.getReturnType() == clientType in findStubFactoryMethod().\n-            return stubFactoryMethod.invoke(null, channel);\n-        } catch (IllegalAccessException | InvocationTargetException e) {\n+            if (stubFactoryMethod != null) {\n+                return stubFactoryMethod.invoke(null, channel);\n+            } else {\n+                return stubConstructor.newInstance(channel);\n+            }\n+        } catch (IllegalAccessException | InvocationTargetException | InstantiationException e) {\n             throw new IllegalStateException(\"Could not create a gRPC stub through reflection.\", e);\n         }", "originalCommit": "eafaa69721d22606c78c830b967a1fdad9de2650", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk4NzYyNQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r409987625", "bodyText": "Check context here too, I think similar to the flow below it's not correct - and it'd be quite annoying to have to propagate it here too despite being a coroutine", "author": "anuraaga", "createdAt": "2020-04-17T04:34:15Z", "path": "examples/grpc-kotlin/src/main/kotlin/example/armeria/grpc/kotlin/HelloServiceImpl.kt", "diffHunk": "@@ -3,52 +3,56 @@ package example.armeria.grpc.kotlin\n import com.linecorp.armeria.server.ServiceRequestContext\n import example.armeria.grpc.kotlin.Hello.HelloReply\n import example.armeria.grpc.kotlin.Hello.HelloRequest\n-import io.grpc.stub.StreamObserver\n-import java.time.Duration\n-import java.util.concurrent.TimeUnit\n-import reactor.core.publisher.Flux\n-import reactor.core.scheduler.Schedulers\n-\n-class HelloServiceImpl : HelloServiceGrpc.HelloServiceImplBase() {\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.delay\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.collect\n+import kotlinx.coroutines.flow.flow\n+import kotlinx.coroutines.flow.flowOn\n+import kotlinx.coroutines.flow.map\n+import kotlinx.coroutines.flow.toList\n+import kotlinx.coroutines.withContext\n+\n+\n+/**\n+ * Note that if you want to run [HelloServiceImpl] in an event loop and\n+ * get a current [ServiceRequestContext],\n+ * you should initialize [HelloServiceImpl] with [Dispatchers.Unconfined].\n+ * See https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html\n+ * Unless [Dispatchers.Default] executor will handle this service.\n+ */\n+class HelloServiceImpl : HelloServiceGrpcKt.HelloServiceCoroutineImplBase(Dispatchers.Unconfined) {\n \n     /**\n      * Sends a [HelloReply] immediately when receiving a request.\n      */\n-    override fun hello(request: HelloRequest, responseObserver: StreamObserver<HelloReply>) {\n-        responseObserver.onNext(buildReply(toMessage(request.name)))\n-        responseObserver.onCompleted()\n+    override suspend fun hello(request: HelloRequest): HelloReply {\n+        // Make sure that current thread is request context aware\n+        ServiceRequestContext.current()\n+        return buildReply(toMessage(request.name))\n     }\n \n-    override fun lazyHello(request: HelloRequest, responseObserver: StreamObserver<HelloReply>) {\n-        // You can use the event loop for scheduling a task.\n-        ServiceRequestContext.current().contextAwareEventLoop().schedule({\n-            responseObserver.onNext(buildReply(toMessage(request.name)))\n-            responseObserver.onCompleted()\n-        }, 3, TimeUnit.SECONDS)\n+    override suspend fun lazyHello(request: HelloRequest): HelloReply {\n+        delay(3000L)", "originalCommit": "1bbf8d740618c0a9e87c038caf7668ada82a7f94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAwNDYwNA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r410004604", "bodyText": "Sure!", "author": "ikhoon", "createdAt": "2020-04-17T05:47:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk4NzYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcyNDM5Ng==", "url": "https://github.com/line/armeria/pull/2669#discussion_r410724396", "bodyText": "There are intermittent test failures in gjson-web with coroutine.\nThe response was hanging and waiting infinitely. I cannot reproduce it with the original gRPC-Java BlockingStub or Stub with StreamObserver. \ud83e\udd14", "author": "ikhoon", "createdAt": "2020-04-18T17:12:29Z", "path": "examples/grpc-kotlin/src/test/kotlin/example/armeria/grpc/kotlin/HelloServiceTest.kt", "diffHunk": "@@ -25,156 +19,104 @@ class HelloServiceTest {\n \n     @Test\n     fun reply() {\n-        val helloService = Clients.newClient(uri(), HelloServiceBlockingStub::class.java)\n-        assertThat(helloService.hello(HelloRequest.newBuilder().setName(\"Armeria\").build()).message)\n-                .isEqualTo(\"Hello, Armeria!\")\n+        runBlocking {\n+            val helloService = Clients.newClient(uri(), HelloServiceCoroutineStub::class.java)\n+            assertThat(helloService.hello(HelloRequest.newBuilder().setName(\"Armeria\").build()).message)\n+                    .isEqualTo(\"Hello, Armeria!\")\n+        }\n     }\n \n-    // Should never reach here.\n     @Test\n-    fun replyWithDelay() {\n-        val helloService = Clients.newClient(uri(), HelloServiceFutureStub::class.java)\n-        val future = helloService.lazyHello(HelloRequest.newBuilder().setName(\"Armeria\").build())\n-        val completed = AtomicBoolean()\n-        Futures.addCallback(future, object : FutureCallback<HelloReply> {\n-            override fun onSuccess(result: HelloReply?) {\n-                assertThat(result?.message).isEqualTo(\"Hello, Armeria!\")\n-                completed.set(true)\n-            }\n-\n-            override fun onFailure(t: Throwable) { // Should never reach here.\n-                throw Error(t)\n-            }\n-        }, MoreExecutors.directExecutor())\n+    fun replyWithGJson() {\n+        runBlocking {\n+            val uri = \"gjson-web+http://127.0.0.1:\" + server.activeLocalPort() + '/'\n+            val helloService = Clients.newClient(uri, HelloServiceCoroutineStub::class.java)\n+            assertThat(helloService.hello(HelloRequest.newBuilder().setName(\"Armeria\").build()).message)\n+                    .isEqualTo(\"Hello, Armeria!\")\n+        }\n+    }", "originalCommit": "ea6e0fd65b63b1f1b4571515600c2beafa8608a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMwNjU2NA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r411306564", "bodyText": "This doesn't seem right, why would HttpResponse.whenComplete have been called if there are still messages with the trailers left?", "author": "anuraaga", "createdAt": "2020-04-20T11:36:17Z", "path": "grpc-protocol/src/main/java/com/linecorp/armeria/common/grpc/protocol/ArmeriaMessageDeframer.java", "diffHunk": "@@ -263,12 +263,24 @@ public boolean isStalled() {\n      * @param endOfStream if {@code true}, indicates that {@code data} is the end of the stream from\n      *        the remote endpoint.  End of stream should not be used in the event of a transport\n      *        error, such as a stream reset.\n-     * @throws IllegalStateException if {@link #close()} has been called previously or if\n+     * @throws IllegalStateException if the specified {@code endOfStream} is {@code false} and\n      *         this method has previously been called with {@code endOfStream=true}.\n      */\n     public void deframe(HttpData data, boolean endOfStream) {\n         requireNonNull(data, \"data\");\n         checkNotClosed();\n+\n+        // 'deframe()' could be called twice with endOfStream due to a race condition like the following:\n+        //\n+        // 1) HttpStreamReader.apply(), which invokes closeDeframer(), is called when\n+        //    HttpResponse.whenComplete().\n+        // 2) While ArmeriaClientCall requests next messages, GrpcStatus.reportStatus() is invoked if the next", "originalCommit": "0311513dccebf8f8bd283c8fc0dc26d2e6549e8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyMzY3MA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r411823670", "bodyText": "Yes, I agreed. Let me investigate this more and try to fix the root cause.", "author": "ikhoon", "createdAt": "2020-04-21T02:32:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMwNjU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMDMwNg==", "url": "https://github.com/line/armeria/pull/2669#discussion_r413900306", "bodyText": "I've investigated more and found the exact cause.\n\nHttpStreamReader received all data from publisher and add them to unprocessed of deframer.\ngRPC client does not request next messages yet, so deframer still has unprocessedBytes and is not stalled.\nHttpStreamReader receives onCompleted signal and closes deframer\ngRPC client requests the next message, but it contains trailers so ArmeriaClientCall tries to close deframer.", "author": "ikhoon", "createdAt": "2020-04-23T15:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMwNjU2NA=="}], "type": "inlineReview"}, {"oid": "9c5e797749c620b42a4b1249f227d05e6224770a", "url": "https://github.com/line/armeria/commit/9c5e797749c620b42a4b1249f227d05e6224770a", "message": "Address comments by @anuraaga\n\nLet deframer close when complete when\n- HttpStreamReader received all data from publisher\n- deframer has unprocessedBytes and is not stalled", "committedDate": "2020-04-23T15:24:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2MTgwNQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r414261805", "bodyText": "Ah I see - instead of this how about adding a isClosing method that checks closeWhenComplete and check it inside closeDeframer instead of doing this check. There shouldn't be any need to call closeWhenComplete twice.", "author": "anuraaga", "createdAt": "2020-04-24T03:17:28Z", "path": "grpc/src/main/java/com/linecorp/armeria/internal/common/grpc/HttpStreamReader.java", "diffHunk": "@@ -181,7 +181,15 @@ public Void apply(@Nullable Void unused, @Nullable Throwable cause) {\n         }\n \n         if (cause == null) {\n-            closeDeframer();\n+            if (!deframer.isStalled()) {", "originalCommit": "9c5e797749c620b42a4b1249f227d05e6224770a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2MTkwNA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r414261904", "bodyText": "And probably a good idea to move this bug fix to a separate PR.", "author": "anuraaga", "createdAt": "2020-04-24T03:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2MTgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3MTY0MQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r414271641", "bodyText": "And probably a good idea to move this bug fix to a separate PR.\n\nYes, I'm preparing a PR to resolve this issue. But some tests failed, my change seems to cause side effects.\nLet me elaborate on it after more investigating. \ud83e\udd14", "author": "ikhoon", "createdAt": "2020-04-24T03:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2MTgwNQ=="}], "type": "inlineReview"}, {"oid": "a704ef8d8db676c0f6cc22cc73585632f96c25ac", "url": "https://github.com/line/armeria/commit/a704ef8d8db676c0f6cc22cc73585632f96c25ac", "message": "Support Kotlin-gRPC client CoroutineStub\n\nMotivation:\n\ngRPC for Kotlin is actively developed and\n[0.1.1](https://github.com/grpc/grpc-kotlin/releases/tag/v0.1.1) has been released last week.\n\nModifications:\n\n- Allow GrpcClientFactory creating client from CoroutineStub\n- Migrate Kotlin example to gRPC-Kotlin\n\nResult:\n\n- (Partially) Fixes #2662\n- You can now run Armeria gRPC client with `gproto` protocol and gRPC-Kotline CoroutinStub", "committedDate": "2020-04-24T05:43:19Z", "type": "forcePushed"}, {"oid": "2d0a33c0fe5e0f0c7daf3bd4739d04ca7b6ab457", "url": "https://github.com/line/armeria/commit/2d0a33c0fe5e0f0c7daf3bd4739d04ca7b6ab457", "message": "Support Kotlin-gRPC client CoroutineStub\n\nMotivation:\n\ngRPC for Kotlin is actively developed and\n[0.1.1](https://github.com/grpc/grpc-kotlin/releases/tag/v0.1.1) has been released last week.\n\nModifications:\n\n- Allow GrpcClientFactory creating client from CoroutineStub\n- Migrate Kotlin example to gRPC-Kotlin\n\nResult:\n\n- (Partially) Fixes #2662\n- You can now run Armeria gRPC client with `gproto` protocol and gRPC-Kotline CoroutinStub\n\nCo-authored-by: Gary Lo <gary.lo@airtasker.com>", "committedDate": "2020-04-24T05:47:34Z", "type": "commit"}, {"oid": "2d0a33c0fe5e0f0c7daf3bd4739d04ca7b6ab457", "url": "https://github.com/line/armeria/commit/2d0a33c0fe5e0f0c7daf3bd4739d04ca7b6ab457", "message": "Support Kotlin-gRPC client CoroutineStub\n\nMotivation:\n\ngRPC for Kotlin is actively developed and\n[0.1.1](https://github.com/grpc/grpc-kotlin/releases/tag/v0.1.1) has been released last week.\n\nModifications:\n\n- Allow GrpcClientFactory creating client from CoroutineStub\n- Migrate Kotlin example to gRPC-Kotlin\n\nResult:\n\n- (Partially) Fixes #2662\n- You can now run Armeria gRPC client with `gproto` protocol and gRPC-Kotline CoroutinStub\n\nCo-authored-by: Gary Lo <gary.lo@airtasker.com>", "committedDate": "2020-04-24T05:47:34Z", "type": "forcePushed"}, {"oid": "f9ad40ff8d7e2e67860be14a71044c7f8c88d72c", "url": "https://github.com/line/armeria/commit/f9ad40ff8d7e2e67860be14a71044c7f8c88d72c", "message": "Revert gjson to gproto", "committedDate": "2020-04-24T05:50:42Z", "type": "commit"}, {"oid": "4c6927fa3bbea84648522d65cd88f0e50c658eeb", "url": "https://github.com/line/armeria/commit/4c6927fa3bbea84648522d65cd88f0e50c658eeb", "message": "Fix wrong dependencies", "committedDate": "2020-04-24T06:01:59Z", "type": "commit"}, {"oid": "20bc5bfff26a2853de9c82ebd3a2583f96a3adec", "url": "https://github.com/line/armeria/commit/20bc5bfff26a2853de9c82ebd3a2583f96a3adec", "message": "Kotlin lint", "committedDate": "2020-04-24T09:58:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ1NTYyOQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r414455629", "bodyText": "Could you send a pull request for this to line/gradle-scripts?", "author": "trustin", "createdAt": "2020-04-24T10:05:40Z", "path": "gradle/scripts/lib/java-rpc-proto.gradle", "diffHunk": "@@ -36,6 +36,11 @@ configure(projectsWithFlags('java')) {\n                             artifact = \"com.salesforce.servicelibs:rxgrpc:${managedVersions['com.salesforce.servicelibs:reactor-grpc']}\"\n                         }\n                     }\n+                    if (project.ext.hasFlag('kotlin-grpc')) {\n+                        kotlinGrpc {\n+                            artifact = \"io.grpc:protoc-gen-grpc-kotlin:${managedVersions['io.grpc:protoc-gen-grpc-kotlin']}\"\n+                        }\n+                    }", "originalCommit": "20bc5bfff26a2853de9c82ebd3a2583f96a3adec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ5Mjc5Ng==", "url": "https://github.com/line/armeria/pull/2669#discussion_r414492796", "bodyText": "Since the protoc-gen-grpc-kotlin doesn't run well on Windows, suggest instead of tying the build to what the compiler supports, in this case just checking in the generated code.", "author": "anuraaga", "createdAt": "2020-04-24T11:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ1NTYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQzNjUzNA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r415436534", "bodyText": "Then we could still check this code in to line/gradle-scripts and remove the 'kotlin-grpc' flag from settings.gradle.", "author": "trustin", "createdAt": "2020-04-27T00:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ1NTYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ2ODY1Ng==", "url": "https://github.com/line/armeria/pull/2669#discussion_r415468656", "bodyText": "Could you send a pull request for this to line/gradle-scripts?\n\nSure. let me make a PR.", "author": "ikhoon", "createdAt": "2020-04-27T02:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ1NTYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3MzU1Ng==", "url": "https://github.com/line/armeria/pull/2669#discussion_r415573556", "bodyText": "Time to merge master", "author": "trustin", "createdAt": "2020-04-27T07:25:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ1NTYyOQ=="}], "type": "inlineReview"}, {"oid": "f1a8787c8cb2061a0bf120cdc426bbfa0f8186b3", "url": "https://github.com/line/armeria/commit/f1a8787c8cb2061a0bf120cdc426bbfa0f8186b3", "message": "Check in gRPC-Kotlin stub and exclude it from delete task", "committedDate": "2020-04-27T04:29:35Z", "type": "commit"}, {"oid": "7f3dfdb97a4b995a619f9f5454178f6ebe70f565", "url": "https://github.com/line/armeria/commit/7f3dfdb97a4b995a619f9f5454178f6ebe70f565", "message": "Remove kotlin-grpc flag", "committedDate": "2020-04-27T04:36:05Z", "type": "commit"}, {"oid": "7f3dfdb97a4b995a619f9f5454178f6ebe70f565", "url": "https://github.com/line/armeria/commit/7f3dfdb97a4b995a619f9f5454178f6ebe70f565", "message": "Remove kotlin-grpc flag", "committedDate": "2020-04-27T04:36:05Z", "type": "forcePushed"}, {"oid": "e147c3a2ae951b27da20067b414f11b41f6eb170", "url": "https://github.com/line/armeria/commit/e147c3a2ae951b27da20067b414f11b41f6eb170", "message": "Fix compile error / Add 'kotlinGrpc' path as source set", "committedDate": "2020-04-27T06:12:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3MjE1NQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r415572155", "bodyText": "\"${path}\".endsWith('gen-src') (File separator can be \\ or /)", "author": "trustin", "createdAt": "2020-04-27T07:23:17Z", "path": "examples/grpc-kotlin/build.gradle.kts", "diffHunk": "@@ -46,3 +46,13 @@ tasks.withType<KotlinCompile> {\n         freeCompilerArgs = listOf(\"-Xjsr305=strict\", \"-java-parameters\")\n     }\n }\n+\n+tasks.clean {\n+    // TODO(ikhoon): gRPC-Kotlin compiler does not run well in Window. The generated stub files is added\n+    //               intentionally. Remove this once gRPC-Kotlin compiler supports Window as well.\n+    for (path in delete) {\n+        if (path.toString() == \"$projectDir/gen-src\") {", "originalCommit": "f1a8787c8cb2061a0bf120cdc426bbfa0f8186b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5OTQwNA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r416299404", "bodyText": "I used path == project.ext[\"genSrcDir\"]. \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-04-28T03:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3MjE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3MjU4Mw==", "url": "https://github.com/line/armeria/pull/2669#discussion_r415572583", "bodyText": "Window -> Windows", "author": "trustin", "createdAt": "2020-04-27T07:24:02Z", "path": "examples/grpc-kotlin/build.gradle.kts", "diffHunk": "@@ -44,3 +46,19 @@ tasks.withType<KotlinCompile> {\n         freeCompilerArgs = listOf(\"-Xjsr305=strict\", \"-java-parameters\")\n     }\n }\n+\n+// TODO(ikhoon): gRPC-Kotlin compiler does not run well in Window. The generated stub files are added\n+//               intentionally. Remove this once gRPC-Kotlin compiler supports Window as well.", "originalCommit": "e147c3a2ae951b27da20067b414f11b41f6eb170", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "47bc5ea18d6783b83a69cb59abce69b46cffa6de", "url": "https://github.com/line/armeria/commit/47bc5ea18d6783b83a69cb59abce69b46cffa6de", "message": "Exclude generated source from ktlint", "committedDate": "2020-04-27T08:35:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwMzcxOQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r417203719", "bodyText": "I don't have high hopes for grpc/grpc-kotlin#66 being solved for a long time.\nHow about instead of hacking relying on implementation detail like this, go ahead and use the wrapper function pattern so users implement stubs something like\nclass HelloServiceImpl {\n  override suspend function hello = withArmeriaContext {\n  }\n}", "author": "anuraaga", "createdAt": "2020-04-29T10:06:40Z", "path": "examples/grpc-kotlin/src/main/kotlin/example/armeria/grpc/kotlin/ArmeriaContext.kt", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package example.armeria.grpc.kotlin\n+\n+import com.linecorp.armeria.common.RequestContext\n+import com.linecorp.armeria.server.ServiceRequestContext\n+import kotlin.coroutines.CoroutineContext\n+import kotlin.coroutines.EmptyCoroutineContext\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.asCoroutineDispatcher\n+\n+/**\n+ * A [CoroutineContext] that propagates an [ServiceRequestContext] to coroutines run using\n+ * an Armeria context aware executor.\n+ */\n+internal object ArmeriaContext : CoroutineContext {", "originalCommit": "47bc5ea18d6783b83a69cb59abce69b46cffa6de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwNjYzNQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r417206635", "bodyText": "But... to use withArmeriaContext { ... }, we should change the default dispatcher to Dispatchers.Unconfined", "author": "ikhoon", "createdAt": "2020-04-29T10:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwMzcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwNzg0Nw==", "url": "https://github.com/line/armeria/pull/2669#discussion_r417207847", "bodyText": "I am not sure which one is better. \ud83e\udd14", "author": "ikhoon", "createdAt": "2020-04-29T10:14:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwMzcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwODg0OQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r417208849", "bodyText": "Yeah - the hack is way too hacky though. If it's short lived it's ok, but I don't think we should recommend it for a long time. Our pattern can be the two rules\n\nUse Unconfined\nDecorate all methods with withArmeriaContext", "author": "anuraaga", "createdAt": "2020-04-29T10:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIwMzcxOQ=="}], "type": "inlineReview"}, {"oid": "2f7633a5845c4836e51f34c0d6c8688ae4adafb1", "url": "https://github.com/line/armeria/commit/2f7633a5845c4836e51f34c0d6c8688ae4adafb1", "message": "Address comments by @anuraaga / decorate rpc method with armeria context", "committedDate": "2020-04-29T11:36:25Z", "type": "commit"}, {"oid": "c0a578cd7815c0c9578809c889f4d41d5fe75d49", "url": "https://github.com/line/armeria/commit/c0a578cd7815c0c9578809c889f4d41d5fe75d49", "message": "Add missed one", "committedDate": "2020-04-29T11:40:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM0NDE3MQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r417344171", "bodyText": "Does this need to be flow? I wouldn't expect a for loop in a coroutine to cause any differences compared to our normal withArmeriaContext methods", "author": "anuraaga", "createdAt": "2020-04-29T14:09:11Z", "path": "examples/grpc-kotlin/src/main/kotlin/example/armeria/grpc/kotlin/HelloServiceImpl.kt", "diffHunk": "@@ -3,129 +3,112 @@ package example.armeria.grpc.kotlin\n import com.linecorp.armeria.server.ServiceRequestContext\n import example.armeria.grpc.kotlin.Hello.HelloReply\n import example.armeria.grpc.kotlin.Hello.HelloRequest\n-import io.grpc.stub.StreamObserver\n-import java.time.Duration\n-import java.util.concurrent.TimeUnit\n-import reactor.core.publisher.Flux\n-import reactor.core.scheduler.Schedulers\n-\n-class HelloServiceImpl : HelloServiceGrpc.HelloServiceImplBase() {\n+import example.armeria.grpc.kotlin.HelloServiceImpl.Companion.withArmeriaBlockingContext\n+import example.armeria.grpc.kotlin.HelloServiceImpl.Companion.withArmeriaContext\n+import kotlinx.coroutines.CoroutineDispatcher\n+import kotlinx.coroutines.CoroutineScope\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.asCoroutineDispatcher\n+import kotlinx.coroutines.delay\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.collect\n+import kotlinx.coroutines.flow.flow\n+import kotlinx.coroutines.flow.flowOn\n+import kotlinx.coroutines.flow.map\n+import kotlinx.coroutines.flow.toList\n+import kotlinx.coroutines.withContext\n+\n+/**\n+ * Note that if you want to access a current [ServiceRequestContext] in [HelloServiceImpl],\n+ * you should initialize [HelloServiceImpl] with [Dispatchers.Unconfined] and wrap your rpc methods with\n+ * [withArmeriaContext] or [withArmeriaBlockingContext].\n+ */\n+class HelloServiceImpl : HelloServiceGrpcKt.HelloServiceCoroutineImplBase(Dispatchers.Unconfined) {\n \n     /**\n      * Sends a [HelloReply] immediately when receiving a request.\n      */\n-    override fun hello(request: HelloRequest, responseObserver: StreamObserver<HelloReply>) {\n-        responseObserver.onNext(buildReply(toMessage(request.name)))\n-        responseObserver.onCompleted()\n+    override suspend fun hello(request: HelloRequest): HelloReply = withArmeriaContext {\n+        // Make sure that current thread is request context aware\n+        ServiceRequestContext.current()\n+        buildReply(toMessage(request.name))\n     }\n \n-    override fun lazyHello(request: HelloRequest, responseObserver: StreamObserver<HelloReply>) {\n-        // You can use the event loop for scheduling a task.\n-        ServiceRequestContext.current().contextAwareEventLoop().schedule({\n-            responseObserver.onNext(buildReply(toMessage(request.name)))\n-            responseObserver.onCompleted()\n-        }, 3, TimeUnit.SECONDS)\n+    override suspend fun lazyHello(request: HelloRequest): HelloReply = withArmeriaContext {\n+        delay(3000L)\n+        ServiceRequestContext.current()\n+        buildReply(toMessage(request.name))\n     }\n \n     /**\n      * Sends a [HelloReply] using `blockingTaskExecutor`.\n      *\n      * @see [Blocking service implementation](https://line.github.io/armeria/server-grpc.html#blocking-service-implementation)\n      */\n-    override fun blockingHello(request: HelloRequest, responseObserver: StreamObserver<HelloReply>) {\n-        // Unlike upstream gRPC-Java, Armeria does not run service logic in a separate thread pool by default.\n-        // Therefore, this method will run in the event loop, which means that you can suffer the performance\n-        // degradation if you call a blocking API in this method. In this case, you have the following options:\n-        //\n-        // 1. Call a blocking API in the blockingTaskExecutor provided by Armeria.\n-        // 2. Set `GrpcServiceBuilder.useBlockingTaskExecutor(true)` when building your GrpcService.\n-        // 3. Call a blocking API in the separate thread pool you manage.\n-        //\n-        // In this example, we chose the option 1:\n-        ServiceRequestContext.current().blockingTaskExecutor().submit {\n-            try { // Simulate a blocking API call.\n-                Thread.sleep(3000)\n-            } catch (ignored: Exception) { // Do nothing.\n-            }\n-            responseObserver.onNext(buildReply(toMessage(request.name)))\n-            responseObserver.onCompleted()\n+    override suspend fun blockingHello(request: HelloRequest): HelloReply = withArmeriaBlockingContext {\n+        try { // Simulate a blocking API call.\n+            Thread.sleep(3000)\n+        } catch (ignored: Exception) { // Do nothing.\n         }\n+        // Make sure that current thread is request context aware\n+        ServiceRequestContext.current()\n+        buildReply(toMessage(request.name))\n     }\n \n     /**\n      * Sends 5 [HelloReply] responses when receiving a request.\n      *\n      * @see lazyHello(HelloRequest, StreamObserver)\n      */\n-    override fun lotsOfReplies(request: HelloRequest, responseObserver: StreamObserver<HelloReply>) {\n+    override fun lotsOfReplies(request: HelloRequest): Flow<HelloReply> {", "originalCommit": "c0a578cd7815c0c9578809c889f4d41d5fe75d49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM0NDk3NQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r417344975", "bodyText": "To clarify, it doesn't matter so much whether it's a flow or not but was hoping withArmeriaContext applies to all the methods without having yet another pattern of flowOn", "author": "anuraaga", "createdAt": "2020-04-29T14:10:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM0NDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM0NzkyOQ==", "url": "https://github.com/line/armeria/pull/2669#discussion_r417347929", "bodyText": "I\u2019ve tried but it was impossible to apply because withContext only could be applied to suspend function. This function is just return flow and not suspend :-(", "author": "ikhoon", "createdAt": "2020-04-29T14:13:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM0NDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM1MjIzNA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r417352234", "bodyText": "Or we can wrap withArmeriaContext with the inside of flow block.", "author": "ikhoon", "createdAt": "2020-04-29T14:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM0NDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM2NDIyOA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r417364228", "bodyText": "I see - does that mean we can have\nflow {\n  withArmeriaContext {\n    for (i...)\n\n?\nDefinitely not great but I guess a bit better than a new concept flowOn. And probably good evidence to add to our issue about getting better support for customizing the context globally :)", "author": "anuraaga", "createdAt": "2020-04-29T14:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM0NDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM5NjA0OA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r417396048", "bodyText": "I see - does that mean we can have\n\nYes, flow takes suspend function.\nhttps://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/flow/Builders.kt#L49\n\nAnd probably good evidence to add to our issue about getting better support for customizing the context globally :)\n\nThat sounds good. \ud83d\udc4d", "author": "ikhoon", "createdAt": "2020-04-29T15:15:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM0NDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQxNjEzNA==", "url": "https://github.com/line/armeria/pull/2669#discussion_r417416134", "bodyText": "The test failed, the nested block does not work...\nflow {\n  withArmeriaContext {\n    for (i...)\nemit() should be called from dispatchers of flow block unless it throws ISE.\nhttps://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/flow/Builders.kt#L37-L45", "author": "ikhoon", "createdAt": "2020-04-29T15:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM0NDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQxNzYzMg==", "url": "https://github.com/line/armeria/pull/2669#discussion_r417417632", "bodyText": "Too bad :( Let's stick with flowOn then since best we can do", "author": "anuraaga", "createdAt": "2020-04-29T15:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM0NDE3MQ=="}], "type": "inlineReview"}]}