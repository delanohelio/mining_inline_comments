{"pr_number": 2409, "pr_title": "Send an HTTP/2 PING frame on an idle connection", "pr_createdAt": "2020-01-18T03:39:16Z", "pr_url": "https://github.com/line/armeria/pull/2409", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMzQyMQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368203421", "bodyText": "Is it ok to cancel, or should I have a check in shutdownRunnable to check if state is IDLE and then do not close the channel (basically do nothing)", "author": "sivaalli", "createdAt": "2020-01-18T03:41:10Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2017 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>\n+ * This class is not thread-safe and all methods are to be called from single thread such as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInNanos;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private long lastPingPayload;\n+\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"Closing channel: {} as PING timed out.\", channel);\n+        final ChannelFuture close = channel.close();\n+        close.addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"Closed channel: {} as PING timed out.\", channel);\n+            } else {\n+                logger.debug(\"Cannot close channel: {}.\", channel, future.cause());\n+            }\n+        });\n+    };\n+\n+    private final GenericFutureListener<ChannelFuture> pingWriteListener = future -> {\n+        final EventLoop el = future.channel().eventLoop();\n+        if (future.isSuccess()) {\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInNanos, TimeUnit.NANOSECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // write failed, likely the channel is closed.\n+            logger.debug(\"PING write failed for channel: {}\", channel);\n+        }\n+    };\n+\n+    Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInNanos) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInNanos = pingTimeoutInNanos;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        checkState(state == State.IDLE, \"Waiting for PING ACK or shutdown\");\n+\n+        // Only interested in ALL_IDLE event.\n+        if (event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        logger.debug(\"{} event triggered on channel: {}. Sending PING\", event, channel);\n+        writePing(ctx);\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        state = State.PING_SCHEDULED;\n+        ctx.flush();\n+    }\n+\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+\n+        if (state != State.PENDING_PING_ACK) {\n+            throw new Http2Exception(Http2Error.PROTOCOL_ERROR,\n+                                     \"State expected PENDING_PING_ACK but is \" + state);\n+        }\n+        if (lastPingPayload != data) {\n+            throw new Http2Exception(Http2Error.PROTOCOL_ERROR,\n+                                     \"PING received but payload does not match. \" + \"Expected: \" +\n+                                     lastPingPayload + ' ' + \"Received :\" + data);\n+        }\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);", "originalCommit": "5ea7b48ef5ac6207a90da0807c06e47d1ca8d8a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNTAyOA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368205028", "bodyText": "How about checking the return value of cancel() and log like 'Received a late PING(ACK=1) in {}ns?\nI think it's better cancelling here.", "author": "trustin", "createdAt": "2020-01-18T04:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMzQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDY5OQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368204699", "bodyText": "Our logging convention is to put the current channel or context at the first place, e.g.\nlogger.debug(\"{} Closing channel due to PING timeout\", channel);", "author": "trustin", "createdAt": "2020-01-18T04:13:25Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>\n+ * This class is not thread-safe and all methods are to be called from single thread such as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInNanos;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private long lastPingPayload;\n+\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"Closing channel: {} as PING timed out.\", channel);", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDcyNQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368204725", "bodyText": "nit: Could be merged into a single line?\nchannel.close().addListener(future -> {\n    ...\n}", "author": "trustin", "createdAt": "2020-01-18T04:13:53Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>\n+ * This class is not thread-safe and all methods are to be called from single thread such as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInNanos;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private long lastPingPayload;\n+\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"Closing channel: {} as PING timed out.\", channel);\n+        final ChannelFuture close = channel.close();\n+        close.addListener(future -> {", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDczMg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368204732", "bodyText": "Could use ChannelFutureListener instead.", "author": "trustin", "createdAt": "2020-01-18T04:14:16Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>\n+ * This class is not thread-safe and all methods are to be called from single thread such as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInNanos;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private long lastPingPayload;\n+\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"Closing channel: {} as PING timed out.\", channel);\n+        final ChannelFuture close = channel.close();\n+        close.addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"Closed channel: {} as PING timed out.\", channel);\n+            } else {\n+                logger.debug(\"Cannot close channel: {}.\", channel, future.cause());\n+            }\n+        });\n+    };\n+\n+    private final GenericFutureListener<ChannelFuture> pingWriteListener = future -> {", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDczOQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368204739", "bodyText": "Could get this inside the if block.", "author": "trustin", "createdAt": "2020-01-18T04:14:37Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>\n+ * This class is not thread-safe and all methods are to be called from single thread such as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInNanos;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private long lastPingPayload;\n+\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"Closing channel: {} as PING timed out.\", channel);\n+        final ChannelFuture close = channel.close();\n+        close.addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"Closed channel: {} as PING timed out.\", channel);\n+            } else {\n+                logger.debug(\"Cannot close channel: {}.\", channel, future.cause());\n+            }\n+        });\n+    };\n+\n+    private final GenericFutureListener<ChannelFuture> pingWriteListener = future -> {\n+        final EventLoop el = future.channel().eventLoop();", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDc2NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368204764", "bodyText": "How about logging the cause, if channel.isActive()?", "author": "trustin", "createdAt": "2020-01-18T04:15:28Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>\n+ * This class is not thread-safe and all methods are to be called from single thread such as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInNanos;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private long lastPingPayload;\n+\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"Closing channel: {} as PING timed out.\", channel);\n+        final ChannelFuture close = channel.close();\n+        close.addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"Closed channel: {} as PING timed out.\", channel);\n+            } else {\n+                logger.debug(\"Cannot close channel: {}.\", channel, future.cause());\n+            }\n+        });\n+    };\n+\n+    private final GenericFutureListener<ChannelFuture> pingWriteListener = future -> {\n+        final EventLoop el = future.channel().eventLoop();\n+        if (future.isSuccess()) {\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInNanos, TimeUnit.NANOSECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // write failed, likely the channel is closed.\n+            logger.debug(\"PING write failed for channel: {}\", channel);", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNTEyMg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368205122", "bodyText": "This seems really short. How about 10 seconds? How about making it configurable via ServerBuilder (and ClientFactoryBuilder if you're gonna implement the client side as well), preferably with a new Flags property?", "author": "trustin", "createdAt": "2020-01-18T04:23:45Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2ServerConnectionHandler.java", "diffHunk": "@@ -16,26 +16,32 @@\n \n package com.linecorp.armeria.server;\n \n+import java.time.Duration;\n+\n import com.linecorp.armeria.internal.AbstractHttp2ConnectionHandler;\n \n import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2ConnectionDecoder;\n import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.timeout.IdleStateEvent;\n \n final class Http2ServerConnectionHandler extends AbstractHttp2ConnectionHandler {\n \n     private final GracefulShutdownSupport gracefulShutdownSupport;\n     private final Http2RequestDecoder requestDecoder;\n+    private final Http2KeepAliveHandler keepAlive;\n \n     Http2ServerConnectionHandler(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,\n                                  Http2Settings initialSettings, Channel channel, ServerConfig config,\n                                  GracefulShutdownSupport gracefulShutdownSupport, String scheme) {\n \n         super(decoder, encoder, initialSettings);\n-\n         this.gracefulShutdownSupport = gracefulShutdownSupport;\n-        requestDecoder = new Http2RequestDecoder(config, channel, encoder(), scheme);\n+        keepAlive = new Http2KeepAliveHandler(channel, encoder().frameWriter(),\n+                                              Duration.ofSeconds(1).toNanos());", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNTM5Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368205396", "bodyText": "This was hardcoded for local testing. I will use Flags property.", "author": "sivaalli", "createdAt": "2020-01-18T04:30:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNTEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNTIyMw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368205223", "bodyText": "Missing space before <\nThe first </p> does not have its peer?", "author": "trustin", "createdAt": "2020-01-18T04:25:54Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MTUyMA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368391520", "bodyText": "... but was %s\", state so that string concatenation does not occur when state is correct.", "author": "trustin", "createdAt": "2020-01-20T06:55:48Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -94,22 +92,30 @@\n             }\n         }\n     };\n+    private long lastPingPayload;\n \n-    Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInNanos) {\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInNanos) {\n         this.channel = channel;\n         this.frameWriter = frameWriter;\n         this.pingTimeoutInNanos = pingTimeoutInNanos;\n     }\n \n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     */\n     public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        checkState(state == State.IDLE, \"Waiting for PING ACK or shutdown\");\n+        checkState(state == State.IDLE, \"Invalid state. Expecting IDLE but was \" + state);", "originalCommit": "312cb19b32ac17d9feabafbd3ddc087175256e95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MTc2Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368391767", "bodyText": "Could be:\n *\n * <p>This class is ...\n\nto make Checkstyle happy", "author": "trustin", "createdAt": "2020-01-20T06:56:44Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -46,10 +46,8 @@\n /**\n  * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n  * Specifically, it will write a PING frame to remote and then expects an ACK back within\n- * configured pingTimeOut. If timeout exceeds then channel will be closed.\n- * </p>\n- * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n- * </p>\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ * <p>\n  * This class is <b>not</b> thread-safe and all methods are to be called from single thread such as", "originalCommit": "06ee5cfe443bfee6003ee99d83f295746ad2eb14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODU2NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368758564", "bodyText": "This is for when a client upgrades the connection from http1.1 to http2. If there is a better way to deal with this situation, please do let me know.", "author": "sivaalli", "createdAt": "2020-01-20T23:37:24Z", "path": "core/src/main/java/com/linecorp/armeria/internal/AbstractHttp2ConnectionHandler.java", "diffHunk": "@@ -125,6 +125,27 @@ public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exce\n         super.close(ctx, promise);\n     }\n \n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        super.handlerAdded(ctx);\n+        changeIdleStateHandlerToHttp2(ctx);", "originalCommit": "5dc2d4a29b91cdd0cd8aabecc7b1d883bab7807c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwNTUxMQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368905511", "bodyText": "Probably better passing whether it's HTTP/2 in HttpClientPipelinfConfigurator.finishSuccessfully()?", "author": "trustin", "createdAt": "2020-01-21T09:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTQ4Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369309482", "bodyText": "Sorry, did not get your comment. Let me elaborate the problem:\nFor client, there is change to set isHttp2 flag in HttpClientPipelinfConfigurator.finishSuccessfully(), please see here .\nOn server side, the change is here. But when http client upgrades the connection using upgrade header, then Http2ConnectionHandler is added to pipeline and HttpServerCodec is removed. Since adding Http2ConnectionHandler to pipeline indicates a successful upgrade, I though to flip the state of isHttp2 from false to true in AbstractHttp2ConnectionHandler\nNow that I'm thinking about it, I think we should not have this logic in AbstractHttp2ConnectionHandler but rather in Http2ServerConnectionHandler. Please let me know what do you think \ud83d\ude04", "author": "sivaalli", "createdAt": "2020-01-22T00:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyODg3Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369328876", "bodyText": "Sorry, did not get your comment.\n\nAh, you were asking about the server-side. I thought the problem was in the client side. My bad \ud83d\ude05\n\nNow that I'm thinking about it, I think we should not have this logic in AbstractHttp2ConnectionHandler but rather in Http2ServerConnectionHandler. Please let me know what do you think \ud83d\ude04\n\n+1", "author": "trustin", "createdAt": "2020-01-22T01:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODkwNg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368758906", "bodyText": "I had 2 options:\n\nI can use isHttp2 flag to indicate that connection is http2.\nOr I could remove IdleTimeoutHandler and add IdleStateHandler (netty's base implementation).\n\nI choose (1), please let me know if there are better alternatives.", "author": "sivaalli", "createdAt": "2020-01-20T23:39:16Z", "path": "core/src/main/java/com/linecorp/armeria/internal/IdleTimeoutHandler.java", "diffHunk": "@@ -32,14 +32,24 @@\n     private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutHandler.class);\n \n     private final String name;\n+    private boolean isHttp2;\n \n-    protected IdleTimeoutHandler(String name, long idleTimeoutMillis) {\n+    protected IdleTimeoutHandler(String name, long idleTimeoutMillis, boolean isHttp2) {\n         super(0, 0, idleTimeoutMillis, TimeUnit.MILLISECONDS);\n         this.name = requireNonNull(name, \"name\");\n+        this.isHttp2 = isHttp2;\n     }\n \n+    /**\n+     * If the channel is serving http2 the we will leverage sending PING's using {@link Http2KeepAliveHandler}\n+     * but if it is http1.1 channel then we will close the channel\n+     */\n     @Override\n     protected final void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {\n+        if (isHttp2) {", "originalCommit": "5dc2d4a29b91cdd0cd8aabecc7b1d883bab7807c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwNTg3Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368905876", "bodyText": "+1 for using a flag. \ud83d\ude04", "author": "trustin", "createdAt": "2020-01-21T09:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwNjA2MQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368906061", "bodyText": "(Because it's better keeping the length of a Netty pipeline short for performance's sake)", "author": "trustin", "createdAt": "2020-01-21T09:59:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMzEzOQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368903139", "bodyText": "http2 -> HTTP/2", "author": "trustin", "createdAt": "2020-01-21T09:54:11Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -658,6 +665,19 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value for http2 PING timeout.", "originalCommit": "5dc2d4a29b91cdd0cd8aabecc7b1d883bab7807c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMzY3Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368903672", "bodyText": "Perhaps better using {@link #defaultServerIdleTimeoutMillis()} ... {@link #defaultClientIdleTimeoutMillis()} ?", "author": "trustin", "createdAt": "2020-01-21T09:55:12Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -658,6 +665,19 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value for http2 PING timeout.\n+     * Note that this flag is only in effect when DEFAULT_SERVER_IDLE_TIMEOUT_MILLIS for server and\n+     * DEFAULT_DEFAULT_CLIENT_IDLE_TIMEOUT_MILLIS for client are greater than 0", "originalCommit": "5dc2d4a29b91cdd0cd8aabecc7b1d883bab7807c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMzk4OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368903988", "bodyText": "Do we need sub-millisecond precision for ping timeouts? How about using milliseconds, like other idle timeout flags?", "author": "trustin", "createdAt": "2020-01-21T09:55:44Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -658,6 +665,19 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value for http2 PING timeout.\n+     * Note that this flag is only in effect when DEFAULT_SERVER_IDLE_TIMEOUT_MILLIS for server and\n+     * DEFAULT_DEFAULT_CLIENT_IDLE_TIMEOUT_MILLIS for client are greater than 0\n+     *\n+     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_NANOS}. Specify the\n+     * {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutNanos=<integer>} JVM option to override\n+     * the default value.\n+     */\n+    public static long defaultHttp2PingTimeoutNanos() {\n+        return DEFAULT_HTTP2_PING_TIMEOUT_NANOS;", "originalCommit": "5dc2d4a29b91cdd0cd8aabecc7b1d883bab7807c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAyMDIwMw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369020203", "bodyText": "Sure. Let me change this.", "author": "sivaalli", "createdAt": "2020-01-21T14:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMzk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDgwMQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369980801", "bodyText": "nit: Could be prettier if broken right after the comma?", "author": "trustin", "createdAt": "2020-01-23T08:23:02Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java", "diffHunk": "@@ -341,7 +341,8 @@ void finishSuccessfully(ChannelPipeline pipeline, SessionProtocol protocol) {\n \n         final long idleTimeoutMillis = clientFactory.idleTimeoutMillis();\n         if (idleTimeoutMillis > 0) {\n-            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis));\n+            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis, protocol == H2 ||\n+                                                                                  protocol == H2C));", "originalCommit": "62bc69438e31a0dc11d3ab7bb9819a0bb85de9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MTE4Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369981187", "bodyText": "...MILLIS} milliseconds.", "author": "trustin", "createdAt": "2020-01-23T08:24:03Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -658,6 +664,19 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value for HTTP2 PING timeout.\n+     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n+     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n+     *\n+     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS}. Specify the", "originalCommit": "62bc69438e31a0dc11d3ab7bb9819a0bb85de9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4NDI0Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369984242", "bodyText": "assertThat(ch.finish()).isFalse()", "author": "trustin", "createdAt": "2020-01-23T08:31:33Z", "path": "core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler.State;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.timeout.IdleStateEvent;\n+\n+class Http2KeepAliveHandlerTest {\n+\n+    private static final long pingTimeout = 10;\n+    @Mock\n+    private Http2FrameWriter frameWriter;\n+    private EmbeddedChannel ch;\n+    private ChannelPromise promise;\n+\n+    private Http2KeepAliveHandler keepAlive;\n+\n+    @BeforeEach\n+    public void setup() throws Exception {\n+        ch = new EmbeddedChannel();\n+        keepAlive = new Http2KeepAliveHandler(ch, frameWriter, pingTimeout);\n+        promise = ch.newPromise();\n+\n+        ch.pipeline().addLast(new TestIdleStateHandler(keepAlive));\n+\n+        assertThat(ch.isOpen()).isTrue();\n+    }\n+\n+    @AfterEach\n+    public void after() {\n+        Assertions.assertFalse(ch.finish());", "originalCommit": "62bc69438e31a0dc11d3ab7bb9819a0bb85de9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4NDY2MA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369984660", "bodyText": "nit: Maybe more readable if we swap the two lines?", "author": "trustin", "createdAt": "2020-01-23T08:32:29Z", "path": "core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler.State;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.timeout.IdleStateEvent;\n+\n+class Http2KeepAliveHandlerTest {\n+\n+    private static final long pingTimeout = 10;\n+    @Mock\n+    private Http2FrameWriter frameWriter;\n+    private EmbeddedChannel ch;\n+    private ChannelPromise promise;\n+\n+    private Http2KeepAliveHandler keepAlive;\n+\n+    @BeforeEach\n+    public void setup() throws Exception {\n+        ch = new EmbeddedChannel();\n+        keepAlive = new Http2KeepAliveHandler(ch, frameWriter, pingTimeout);\n+        promise = ch.newPromise();", "originalCommit": "62bc69438e31a0dc11d3ab7bb9819a0bb85de9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4NDg3Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369984876", "bodyText": "Cruft?", "author": "trustin", "createdAt": "2020-01-23T08:33:03Z", "path": "core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler.State;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.timeout.IdleStateEvent;\n+\n+class Http2KeepAliveHandlerTest {\n+\n+    private static final long pingTimeout = 10;\n+    @Mock\n+    private Http2FrameWriter frameWriter;\n+    private EmbeddedChannel ch;\n+    private ChannelPromise promise;\n+\n+    private Http2KeepAliveHandler keepAlive;\n+\n+    @BeforeEach\n+    public void setup() throws Exception {\n+        ch = new EmbeddedChannel();\n+        keepAlive = new Http2KeepAliveHandler(ch, frameWriter, pingTimeout);\n+        promise = ch.newPromise();\n+\n+        ch.pipeline().addLast(new TestIdleStateHandler(keepAlive));\n+\n+        assertThat(ch.isOpen()).isTrue();\n+    }\n+\n+    @AfterEach\n+    public void after() {\n+        Assertions.assertFalse(ch.finish());\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenPingTimesOut_ShouldCloseConnection() throws InterruptedException {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+\n+        promise.setSuccess();\n+        waitUntilPingTimeout();\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isFalse();\n+        assertThat(keepAlive.getState()).isEqualTo(State.SHUTDOWN);\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenWritePingFails_ShouldCloseConnection() throws InterruptedException {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        promise.setFailure(new IOException());\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isFalse();\n+        assertThat(keepAlive.getState()).isEqualTo(State.SHUTDOWN);\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenPingAckIsReceivedWithinTimeout_ShouldNotCloseConnection()\n+            throws Exception {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        promise.setSuccess();\n+        //ch.runPendingTasks();", "originalCommit": "62bc69438e31a0dc11d3ab7bb9819a0bb85de9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4NTQ0Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369985447", "bodyText": "Not sure, but I guess 10 ms might be too short for CI environment which runs much slower machines.", "author": "trustin", "createdAt": "2020-01-23T08:34:31Z", "path": "core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler.State;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.timeout.IdleStateEvent;\n+\n+class Http2KeepAliveHandlerTest {\n+\n+    private static final long pingTimeout = 10;", "originalCommit": "62bc69438e31a0dc11d3ab7bb9819a0bb85de9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExMzgzOQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371113839", "bodyText": "Why do we return here?", "author": "anuraaga", "createdAt": "2020-01-27T08:41:37Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java", "diffHunk": "@@ -66,4 +72,19 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {\n     protected boolean needsImmediateDisconnection() {\n         return clientFactory.isClosing() || responseDecoder.goAwayHandler().receivedErrorGoAway();\n     }\n+\n+    @Override\n+    public void channelInactive(final ChannelHandlerContext ctx) throws Exception {\n+        keepAlive.onChannelInactive();\n+        super.channelInactive(ctx);\n+    }\n+\n+    @Override\n+    public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) throws Exception {\n+        if (evt instanceof IdleStateEvent) {\n+            keepAlive.onChannelIdle(ctx, (IdleStateEvent) evt);\n+            return;", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4NTYyMQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r372185621", "bodyText": "Previously this event was not emitted and I modified code to do so here. No downstream handlers would be interested in this event except for Http2ClientConnectionHandler.", "author": "sivaalli", "createdAt": "2020-01-29T04:38:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExMzgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNDE1Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371114157", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                                           protocol == H2 || protocol == H2C));\n          \n          \n            \n                                                                           protocol.isMultiplex()));", "author": "anuraaga", "createdAt": "2020-01-27T08:42:30Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java", "diffHunk": "@@ -341,7 +341,8 @@ void finishSuccessfully(ChannelPipeline pipeline, SessionProtocol protocol) {\n \n         final long idleTimeoutMillis = clientFactory.idleTimeoutMillis();\n         if (idleTimeoutMillis > 0) {\n-            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis));\n+            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis,\n+                                                               protocol == H2 || protocol == H2C));", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNDQ4OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371114488", "bodyText": "If timeout exceeds -> If no response is received in this time,", "author": "anuraaga", "createdAt": "2020-01-27T08:43:23Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU4MTEzNQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371581135", "bodyText": "{@code pingTimeoutInNanos} -> {@code pingTimeoutInMillis} ?", "author": "ikhoon", "createdAt": "2020-01-28T02:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNDQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTAzOQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371115039", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private long pingTimeoutInMs;\n          \n          \n            \n                private final long pingTimeoutInMs;", "author": "anuraaga", "createdAt": "2020-01-27T08:44:51Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU4MTExNg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371581116", "bodyText": "nit: pingTimeoutInMs -> pingTimeoutInMillis?", "author": "ikhoon", "createdAt": "2020-01-28T02:14:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5MjExNA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r372192114", "bodyText": "or pingTimeoutMillis like other variables in our codebase?", "author": "trustin", "createdAt": "2020-01-29T05:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTI3Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371115273", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Channel channel;\n          \n          \n            \n                private final Channel channel;", "author": "anuraaga", "createdAt": "2020-01-27T08:45:25Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTQ0MQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371115441", "bodyText": "Move all non-final fields into a group after the final ones.", "author": "anuraaga", "createdAt": "2020-01-27T08:45:49Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTY4Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371115683", "bodyText": "I would go ahead and initialize all the fields in the constructor. Especially since these are quite a lot of code, it's hard to see what fields are in this class at a glance.", "author": "anuraaga", "createdAt": "2020-01-27T08:46:23Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4NTY5Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r372185696", "bodyText": "I will fix this to make it more clear. Thanks.", "author": "sivaalli", "createdAt": "2020-01-29T04:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNjM1Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371116357", "bodyText": "Is it ok not to have something like\nif (state != PING_SCHEDULED) {\n  return;\n}", "author": "anuraaga", "createdAt": "2020-01-27T08:48:07Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNzE5NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371117194", "bodyText": "I don't think we should close the channel in this class for anything other than ping ack timeout, I don't think it's easy to reason about why we are in this branch and it's probably someone else's responsibility to take care of this.", "author": "anuraaga", "createdAt": "2020-01-27T08:50:26Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNzM3Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371117373", "bodyText": "Do we need this?\nif (state != State.PENDING_PING_ACK) {\n  return;\n}", "author": "anuraaga", "createdAt": "2020-01-27T08:50:54Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNzc1Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371117753", "bodyText": "Does it make sense to also have onChannelRead where we clear the ping?\nhttps://http2.github.io/http2-spec/#rfc.section.6.7\nNote, a PING ack SHOULD be prioritized by the other end, but it might not be and could come after the timeout even though the connection is very active.", "author": "anuraaga", "createdAt": "2020-01-27T08:51:51Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     * @throws IllegalStateException when subsequent {@link IdleStateEvent} is less than round trip time.\n+     *      For ex:\n+     *      <ol>\n+     *          <li>IdleStateEvent occurred.</li>\n+     *          <li>PING is sent to peer.</li>\n+     *          <li>IdleStateEvent occurred, before ACK is sent by peer.</li>\n+     *      </ol>\n+     */\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzMjgyMg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385532822", "bodyText": "Will you be addressing this? Clearing ping when any data is received, not necessarily ping ack.", "author": "anuraaga", "createdAt": "2020-02-28T06:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNzc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExODEwMQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371118101", "bodyText": "I think we should just return instead of throwing an exception, I don't think it's clear enough why we would be in such a state.", "author": "anuraaga", "createdAt": "2020-01-27T08:52:47Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     * @throws IllegalStateException when subsequent {@link IdleStateEvent} is less than round trip time.\n+     *      For ex:\n+     *      <ol>\n+     *          <li>IdleStateEvent occurred.</li>\n+     *          <li>PING is sent to peer.</li>\n+     *          <li>IdleStateEvent occurred, before ACK is sent by peer.</li>\n+     *      </ol>\n+     */\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        checkState(state == State.IDLE, \"Invalid state. Expecting IDLE but was %s\", state);", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEyMDA1NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371120054", "bodyText": "Same theme ;) I'm not sure we should throw an exception for these two branches. The first seems like it could just happen, and the second doesn't seem like an actual protocol error\nhttps://http2.github.io/http2-spec/#rfc.section.6.7\nThe only protocol error is when the stream ID is set and a server sending random ping acks doesn't seem to be explicitly banned. I think it's fine for us to just check \"get expected ping ack within timeout\", not \"don't get unexpected ping ack\"", "author": "anuraaga", "createdAt": "2020-01-27T08:57:35Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     * @throws IllegalStateException when subsequent {@link IdleStateEvent} is less than round trip time.\n+     *      For ex:\n+     *      <ol>\n+     *          <li>IdleStateEvent occurred.</li>\n+     *          <li>PING is sent to peer.</li>\n+     *          <li>IdleStateEvent occurred, before ACK is sent by peer.</li>\n+     *      </ol>\n+     */\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        checkState(state == State.IDLE, \"Invalid state. Expecting IDLE but was %s\", state);\n+\n+        // Only interested in ALL_IDLE event.\n+        if (event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        logger.debug(\"{} {} event triggered on channel. Sending PING(ACK=0)\", channel, event);\n+        writePing(ctx);\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        state = State.PING_SCHEDULED;\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Validates the PING ACK.\n+     * @param data data received with the PING ACK\n+     * @throws Http2Exception when the PING ACK data does not match to PING data or\n+     *                        when a PING ACK is received without PING sent.\n+     */\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+\n+        if (state != State.PENDING_PING_ACK) {\n+            throwProtocolErrorException(\"State expected PENDING_PING_ACK but is %s\", state);", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEyNTQxNw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371125417", "bodyText": "This might be why grpc had a flag for whether keepalive applies to idle connections or not. If I'm not mistaken, an HTTP/2 connection will never ever be closed if pings are working ok? This seems like reasonable behavior for internal RPC but not for example, externally-exposed RPC.\nDoes IdleStateHandler take into account active streams? I think I would expect different behavior when there are active streams vs not for an externally exposed server that may not want to support infinite length HTTP/2 connections. I'm not sure I see the logic for it\n\nActive streams -> check pings and close if pings aren't acked (connection is busted)\nNo active streams -> close after timeout regardless of pings (reduce resource usage instead of having tons of idle, but pingable connections. For internal RPC, I'm ok with having idle connections to reduce latency, but not for external RPC)\n\nSo far I've been using idle timeout to intentionally close idle HTTP/2 connections when supporting streaming APIs.", "author": "anuraaga", "createdAt": "2020-01-27T09:10:01Z", "path": "core/src/main/java/com/linecorp/armeria/internal/IdleTimeoutHandler.java", "diffHunk": "@@ -32,14 +32,24 @@\n     private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutHandler.class);\n \n     private final String name;\n+    private boolean isHttp2;\n \n-    protected IdleTimeoutHandler(String name, long idleTimeoutMillis) {\n+    protected IdleTimeoutHandler(String name, long idleTimeoutMillis, boolean isHttp2) {\n         super(0, 0, idleTimeoutMillis, TimeUnit.MILLISECONDS);\n         this.name = requireNonNull(name, \"name\");\n+        this.isHttp2 = isHttp2;\n     }\n \n+    /**\n+     * If the channel is serving HTTP/2 the we will leverage sending PING's using {@link Http2KeepAliveHandler}\n+     * but if it is HTTP/1.1 channel then we will close the channel\n+     */\n     @Override\n     protected final void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {\n+        if (isHttp2) {", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwMDk3OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r372900978", "bodyText": "Does IdleStateHandler take into account active streams?\n\nNope.\n\nreduce resource usage instead of having tons of idle, but pingable connections.\n\nNever though about this. Nice thought. I think for a client/server that has a occasional traffic, holding a connection which is idle is just waste of resources. But for a server/client that is active like a reverse-proxy, this could be beneficial. Active meaning it could go idle for a while but will eventually make calls to same host.\nIs it reasonable to have 2 different implementations:\n\nTo PING occasionally on idle connections, regardless of active streams. - This helps to maintain connection liveliness instead of creating a brand new http2 connection which comes with certain cost. Which should be covered as this PR.\nTo PING on when there are active streams.(Like you said) and not PING when active streams=0 and let IdleStateHandler close connections? - This helps to close IDLE connections for cases where a client makes occasional requests.\n\nAnd let users decide on what is best for their use case.\nPlease let me know your thoughts @trustin @anuraaga @ikhoon . Thanks for your suggestions @anuraaga .\nSome interesting conversation over here: golang/go#31643\nAlso, apologies for my late replies. I'm currently on vacation and will be back to work from Feb 15th onwards. Please bear me for the time being :)", "author": "sivaalli", "createdAt": "2020-01-30T11:39:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEyNTQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkyMTI0Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r372921243", "bodyText": "Yup that sounds good to me, including the reasoning. And I don't think we can add #1 without also having #2. Actually #1 is technically implementable by a user using normal no-op payloads instead of ping. But IIUC #2, is nearly impossible for a user to do (nearly since I think it might be possible by examining the channel of a request in a state manager but I definitely don't want anyone to do that...)", "author": "anuraaga", "createdAt": "2020-01-30T12:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEyNTQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxNzkyMg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r370717922", "bodyText": "nit: We prefer to split creating newProtocolErrorException and throwing it.\nFor example:\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n    \n    \n        Lines 240 to 241\n      in\n      f9b38ea\n    \n    \n    \n    \n\n        \n          \n           throw newIllegalStateException( \n        \n\n        \n          \n                   \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o);", "author": "ikhoon", "createdAt": "2020-01-24T16:17:01Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU3Njk1Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371576952", "bodyText": "nit: Move keepAlive over responseDecoder to preserve the initialization orders?", "author": "ikhoon", "createdAt": "2020-01-28T01:53:26Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java", "diffHunk": "@@ -16,27 +16,33 @@\n \n package com.linecorp.armeria.client;\n \n+import com.linecorp.armeria.common.Flags;\n import com.linecorp.armeria.internal.AbstractHttp2ConnectionHandler;\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler;\n \n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2ConnectionDecoder;\n import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.timeout.IdleStateEvent;\n \n final class Http2ClientConnectionHandler extends AbstractHttp2ConnectionHandler {\n \n     private final HttpClientFactory clientFactory;\n     private final Http2ResponseDecoder responseDecoder;\n+    private final Http2KeepAliveHandler keepAlive;", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU4MTkyOQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371581929", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                State getState() {\n          \n          \n            \n                State state() {", "author": "ikhoon", "createdAt": "2020-01-28T02:18:07Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     * @throws IllegalStateException when subsequent {@link IdleStateEvent} is less than round trip time.\n+     *      For ex:\n+     *      <ol>\n+     *          <li>IdleStateEvent occurred.</li>\n+     *          <li>PING is sent to peer.</li>\n+     *          <li>IdleStateEvent occurred, before ACK is sent by peer.</li>\n+     *      </ol>\n+     */\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        checkState(state == State.IDLE, \"Invalid state. Expecting IDLE but was %s\", state);\n+\n+        // Only interested in ALL_IDLE event.\n+        if (event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        logger.debug(\"{} {} event triggered on channel. Sending PING(ACK=0)\", channel, event);\n+        writePing(ctx);\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        state = State.PING_SCHEDULED;\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Validates the PING ACK.\n+     * @param data data received with the PING ACK\n+     * @throws Http2Exception when the PING ACK data does not match to PING data or\n+     *                        when a PING ACK is received without PING sent.\n+     */\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+\n+        if (state != State.PENDING_PING_ACK) {\n+            throwProtocolErrorException(\"State expected PENDING_PING_ACK but is %s\", state);\n+        }\n+        if (lastPingPayload != data) {\n+            throwProtocolErrorException(\"PING received but payload does not match. Expected %d Received %d\",\n+                                        lastPingPayload, data);\n+        }\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    @VisibleForTesting\n+    State getState() {", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU4MTk3OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371581978", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                long getLastPingPayload() {\n          \n          \n            \n                long lastPingPayload() {", "author": "ikhoon", "createdAt": "2020-01-28T02:18:23Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     * @throws IllegalStateException when subsequent {@link IdleStateEvent} is less than round trip time.\n+     *      For ex:\n+     *      <ol>\n+     *          <li>IdleStateEvent occurred.</li>\n+     *          <li>PING is sent to peer.</li>\n+     *          <li>IdleStateEvent occurred, before ACK is sent by peer.</li>\n+     *      </ol>\n+     */\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        checkState(state == State.IDLE, \"Invalid state. Expecting IDLE but was %s\", state);\n+\n+        // Only interested in ALL_IDLE event.\n+        if (event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        logger.debug(\"{} {} event triggered on channel. Sending PING(ACK=0)\", channel, event);\n+        writePing(ctx);\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        state = State.PING_SCHEDULED;\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Validates the PING ACK.\n+     * @param data data received with the PING ACK\n+     * @throws Http2Exception when the PING ACK data does not match to PING data or\n+     *                        when a PING ACK is received without PING sent.\n+     */\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+\n+        if (state != State.PENDING_PING_ACK) {\n+            throwProtocolErrorException(\"State expected PENDING_PING_ACK but is %s\", state);\n+        }\n+        if (lastPingPayload != data) {\n+            throwProtocolErrorException(\"PING received but payload does not match. Expected %d Received %d\",\n+                                        lastPingPayload, data);\n+        }\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    @VisibleForTesting\n+    State getState() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long getLastPingPayload() {", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NTU5NQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371595595", "bodyText": "I think pingWriteListener might be called synchronously if an error has occurred while writing.\nHow about setting State.PING_SCHEDULED before writing ping?", "author": "ikhoon", "createdAt": "2020-01-28T03:33:49Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     * @throws IllegalStateException when subsequent {@link IdleStateEvent} is less than round trip time.\n+     *      For ex:\n+     *      <ol>\n+     *          <li>IdleStateEvent occurred.</li>\n+     *          <li>PING is sent to peer.</li>\n+     *          <li>IdleStateEvent occurred, before ACK is sent by peer.</li>\n+     *      </ol>\n+     */\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        checkState(state == State.IDLE, \"Invalid state. Expecting IDLE but was %s\", state);\n+\n+        // Only interested in ALL_IDLE event.\n+        if (event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        logger.debug(\"{} {} event triggered on channel. Sending PING(ACK=0)\", channel, event);\n+        writePing(ctx);\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        state = State.PING_SCHEDULED;", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "url": "https://github.com/line/armeria/commit/878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "message": "fixing imports", "committedDate": "2020-02-17T14:21:27Z", "type": "forcePushed"}, {"oid": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "url": "https://github.com/line/armeria/commit/d3a320ab4c012b035757907efa1c1d347d9fd17d", "message": "adding necessary changes to handle pings on http2 connection. Tests pending.", "committedDate": "2020-02-25T03:24:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MTQ1Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r384941457", "bodyText": "How about:\n\ndefaultUseHttp2PingOnIdleStream\ndefaultUseHttp2PingOnIdleConnection\n\n..?", "author": "trustin", "createdAt": "2020-02-27T06:54:57Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -247,6 +253,10 @@\n \n     private static final boolean DEFAULT_USE_HTTP2_PREFACE = getBoolean(\"defaultUseHttp2Preface\", true);\n     private static final boolean DEFAULT_USE_HTTP1_PIPELINING = getBoolean(\"defaultUseHttp1Pipelining\", false);\n+    private static final boolean DEFAULT_USE_HTTP2_PING_ON_IDLE =\n+            getBoolean(\"defaultUseHttp2PingOnIdle\", false);\n+    private static final boolean DEFAULT_USE_HTTP2_PING_ON_NO_ACTIVE_STREAMS =\n+            getBoolean(\"defaultUseHttp2PingOnNoActiveStreams\", false);", "originalCommit": "b3377d0c3bdabf5685018fbe314c9aea9894cfed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5MzYxMA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385493610", "bodyText": "Could remove throws Http2Exception?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onPingAck(long data) throws Http2Exception {\n          \n          \n            \n                public void onPingAck(long data) {", "author": "ikhoon", "createdAt": "2020-02-28T03:39:21Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {", "originalCommit": "c73b467215ad3eaf6ebe6f13c4551954998181f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5MzY5Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385493692", "bodyText": "Could remove throws Http2Exception?", "author": "ikhoon", "createdAt": "2020-02-28T03:39:55Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2RequestDecoder.java", "diffHunk": "@@ -316,4 +321,11 @@ public void onGoAwaySent(int lastStreamId, long errorCode, ByteBuf debugData) {\n     public void onGoAwayReceived(int lastStreamId, long errorCode, ByteBuf debugData) {\n         goAwayHandler.onGoAwayReceived(channel, lastStreamId, errorCode, debugData);\n     }\n+\n+    @Override\n+    public void onPingAckRead(final ChannelHandlerContext ctx, final long data) throws Http2Exception {", "originalCommit": "c73b467215ad3eaf6ebe6f13c4551954998181f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NTI0OQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385495249", "bodyText": "Now it seems only to use for debugging. Could we remove stopwatch?", "author": "ikhoon", "createdAt": "2020-02-28T03:48:44Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);", "originalCommit": "c73b467215ad3eaf6ebe6f13c4551954998181f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwMDI1OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385500258", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n          \n          \n            \n                public void onPingAckRead(ChannelHandlerContext ctx, long data) {", "author": "ikhoon", "createdAt": "2020-02-28T04:16:30Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http2ResponseDecoder.java", "diffHunk": "@@ -287,7 +292,11 @@ public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDe\n     public void onPingRead(ChannelHandlerContext ctx, long data) {}\n \n     @Override\n-    public void onPingAckRead(ChannelHandlerContext ctx, long data) {}\n+    public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NzE5NQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385497195", "bodyText": "nit: Perhaps better not using a static import? It's used only once.", "author": "trustin", "createdAt": "2020-02-28T03:59:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java", "diffHunk": "@@ -16,27 +16,38 @@\n \n package com.linecorp.armeria.client;\n \n+import static com.linecorp.armeria.common.Flags.defaultUseHttp2PingOnIdleConnection;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler;\n import com.linecorp.armeria.internal.common.AbstractHttp2ConnectionHandler;\n \n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2ConnectionDecoder;\n import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.timeout.IdleStateEvent;\n \n final class Http2ClientConnectionHandler extends AbstractHttp2ConnectionHandler {\n \n     private final HttpClientFactory clientFactory;\n     private final Http2ResponseDecoder responseDecoder;\n+    @Nullable\n+    private Http2KeepAliveHandler keepAlive;\n \n     Http2ClientConnectionHandler(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,\n                                  Http2Settings initialSettings, Channel channel,\n                                  HttpClientFactory clientFactory) {\n \n         super(decoder, encoder, initialSettings);\n-\n         this.clientFactory = clientFactory;\n-        responseDecoder = new Http2ResponseDecoder(channel, encoder(), clientFactory);\n+\n+        if (defaultUseHttp2PingOnIdleConnection()) {", "originalCommit": "c73b467215ad3eaf6ebe6f13c4551954998181f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NzM2NQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385497365", "bodyText": "Could you rephrase this so that Javadoc summary is more useful to a user?", "author": "trustin", "createdAt": "2020-02-28T04:00:28Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,42 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent on connection, no otherwise.", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NzM3NQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385497375", "bodyText": "Could you rephrase this so that Javadoc summary is more useful to a user?", "author": "trustin", "createdAt": "2020-02-28T04:00:33Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,42 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent on connection, no otherwise.\n+     * Note that if this is set to true, you may use {@link Flags#defaultHttp2PingTimeoutMillis()} to tune\n+     * the timeout interval. The default is 3 seconds.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleConnection=true} JVM option to enable it.\n+     */\n+    public static boolean defaultUseHttp2PingOnIdleConnection() {\n+        return DEFAULT_USE_HTTP2_PING_ON_IDLE_CONNECTION;\n+    }\n+\n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent even there are no active\n+     * HTTP 2.0 stream, no otherwise.", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NzQ4Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385497486", "bodyText": "HTTP2 -> HTTP/2", "author": "trustin", "createdAt": "2020-02-28T04:01:02Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,42 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent on connection, no otherwise.\n+     * Note that if this is set to true, you may use {@link Flags#defaultHttp2PingTimeoutMillis()} to tune\n+     * the timeout interval. The default is 3 seconds.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleConnection=true} JVM option to enable it.\n+     */\n+    public static boolean defaultUseHttp2PingOnIdleConnection() {\n+        return DEFAULT_USE_HTTP2_PING_ON_IDLE_CONNECTION;\n+    }\n+\n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent even there are no active\n+     * HTTP 2.0 stream, no otherwise.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleStream=true} JVM option to enable it.\n+     */\n+    public static boolean defaultUseHttp2PingOnIdleStream() {\n+        return DEFAULT_USE_HTTP2_PING_ON_IDLE_STREAM;\n+    }\n+\n+    /**\n+     * Returns the default value for HTTP2 PING timeout.", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NzUzNw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385497537", "bodyText": "This will send -> Sends an", "author": "trustin", "createdAt": "2020-02-28T04:01:18Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5Nzk2OQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385497969", "bodyText": "IdleStateEvent.toString() returns a string like: IdleStateEvent(...), so the following log message format would be better:\n\"{} {} triggered.\", channel, event", "author": "trustin", "createdAt": "2020-02-28T04:03:45Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5ODQ3NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385498474", "bodyText": "Closing an idle connection ?", "author": "trustin", "createdAt": "2020-02-28T04:06:36Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n+                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    State state() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long lastPingPayload() {\n+        return lastPingPayload;\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (state == State.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing channel\", channel);", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5ODU3Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385498577", "bodyText": "Closed an idle channel and Failed to close an idle channel: ?", "author": "trustin", "createdAt": "2020-02-28T04:07:07Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n+                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    State state() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long lastPingPayload() {\n+        return lastPingPayload;\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (state == State.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5ODkxNg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385498916", "bodyText": "How about not logging if cause is Exceptions.isExpected() returns true? Otherwise, we could log with the cause.", "author": "trustin", "createdAt": "2020-02-28T04:08:56Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n+                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    State state() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long lastPingPayload() {\n+        return lastPingPayload;\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (state == State.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    }\n+\n+    /**\n+     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n+     * channel is inactive then the state changes to SHUTDOWN.\n+     */\n+    enum State {\n+        /* Nothing happening, but waiting for IdleStateEvent */\n+        IDLE,\n+\n+        /* PING is scheduled */\n+        PING_SCHEDULED,\n+\n+        /* PING is sent and is pending ACK */\n+        PENDING_PING_ACK,\n+\n+        /* Not active anymore */\n+        SHUTDOWN\n+    }\n+\n+    private class PingWriteListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            if (future.isSuccess()) {\n+                final EventLoop el = channel.eventLoop();\n+                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n+                state = State.PENDING_PING_ACK;\n+                stopwatch.reset().start();\n+            } else {\n+                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n+                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n+                logger.debug(\"{} Channel PING write failed\", channel);", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5OTE3OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385499178", "bodyText": "How about logging the current channel as well?\n\"{} Unexpected PING(ACK=1, DATA={}) received\", channel, data\n\"{} Unexpected PING(ACK=1, DATA={}) received ....", "author": "trustin", "createdAt": "2020-02-28T04:10:28Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n+                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5OTU2NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385499564", "bodyText": "If stopwatch is used only for debug logging, how about assigning null to this field when logger.isDebugEnabled() is false?", "author": "trustin", "createdAt": "2020-02-28T04:12:30Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5OTY3Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385499673", "bodyText": "Ditto - no need to use a static import.", "author": "trustin", "createdAt": "2020-02-28T04:13:05Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java", "diffHunk": "@@ -32,14 +36,25 @@\n     private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutHandler.class);\n \n     private final String name;\n+    private boolean isHttp2;\n \n-    protected IdleTimeoutHandler(String name, long idleTimeoutMillis) {\n+    protected IdleTimeoutHandler(String name, long idleTimeoutMillis, boolean isHttp2) {\n         super(0, 0, idleTimeoutMillis, TimeUnit.MILLISECONDS);\n         this.name = requireNonNull(name, \"name\");\n+        this.isHttp2 = isHttp2;\n     }\n \n+    /**\n+     * If the channel is serving HTTP/2 and {@link Flags#defaultUseHttp2PingOnIdleConnection()} is set\n+     * then we will forward event to {@link Http2KeepAliveHandler} to start sending PING's.\n+     * But if it is HTTP/1.1 channel then we will close the channel.\n+     */\n     @Override\n     protected final void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {\n+        if (isHttp2 && defaultUseHttp2PingOnIdleConnection()) {", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5OTc4Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385499786", "bodyText": "Ditto - no need to use a static import.", "author": "trustin", "createdAt": "2020-02-28T04:13:40Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2ServerConnectionHandler.java", "diffHunk": "@@ -16,26 +16,40 @@\n \n package com.linecorp.armeria.server;\n \n+import static com.linecorp.armeria.common.Flags.defaultUseHttp2PingOnIdleConnection;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler;\n import com.linecorp.armeria.internal.common.AbstractHttp2ConnectionHandler;\n+import com.linecorp.armeria.internal.common.IdleTimeoutHandler;\n \n import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2ConnectionDecoder;\n import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.timeout.IdleStateEvent;\n \n final class Http2ServerConnectionHandler extends AbstractHttp2ConnectionHandler {\n \n     private final GracefulShutdownSupport gracefulShutdownSupport;\n     private final Http2RequestDecoder requestDecoder;\n \n+    @Nullable\n+    private Http2KeepAliveHandler keepAlive;\n+\n     Http2ServerConnectionHandler(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,\n                                  Http2Settings initialSettings, Channel channel, ServerConfig config,\n                                  GracefulShutdownSupport gracefulShutdownSupport, String scheme) {\n \n         super(decoder, encoder, initialSettings);\n-\n         this.gracefulShutdownSupport = gracefulShutdownSupport;\n-        requestDecoder = new Http2RequestDecoder(config, channel, encoder(), scheme);\n+\n+        if (defaultUseHttp2PingOnIdleConnection()) {", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwMDY2Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385500667", "bodyText": "Oh, I misunderstood how this flag works when I suggested a rename. defaultUseHttp2PingOnNoActiveStreams is correct indeed. Sorry about giving a wrong suggestion. \ud83d\ude47\u200d\u2642\ufe0f", "author": "trustin", "createdAt": "2020-02-28T04:18:51Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,42 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent on connection, no otherwise.\n+     * Note that if this is set to true, you may use {@link Flags#defaultHttp2PingTimeoutMillis()} to tune\n+     * the timeout interval. The default is 3 seconds.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleConnection=true} JVM option to enable it.\n+     */\n+    public static boolean defaultUseHttp2PingOnIdleConnection() {\n+        return DEFAULT_USE_HTTP2_PING_ON_IDLE_CONNECTION;\n+    }\n+\n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent even there are no active\n+     * HTTP 2.0 stream, no otherwise.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleStream=true} JVM option to enable it.\n+     */\n+    public static boolean defaultUseHttp2PingOnIdleStream() {", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NDU4OQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385984589", "bodyText": "No problem \ud83d\ude04", "author": "sivaalli", "createdAt": "2020-02-29T00:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwMDY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzMjMyMQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385532321", "bodyText": "I don't think we need default for any of the new flags - our request / response timeout we do since a user can control them at runtime too but these I think are only controllable by flags.", "author": "anuraaga", "createdAt": "2020-02-28T06:48:48Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -247,6 +253,10 @@\n \n     private static final boolean DEFAULT_USE_HTTP2_PREFACE = getBoolean(\"defaultUseHttp2Preface\", true);\n     private static final boolean DEFAULT_USE_HTTP1_PIPELINING = getBoolean(\"defaultUseHttp1Pipelining\", false);\n+    private static final boolean DEFAULT_USE_HTTP2_PING_ON_IDLE_CONNECTION =\n+            getBoolean(\"defaultUseHttp2PingOnIdleConnection\", false);", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzMzgxNg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385533816", "bodyText": "I don't think we need warnings for these since they don't seem particularly bad, maybe debug?", "author": "anuraaga", "createdAt": "2020-02-28T06:54:49Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzNDkyNw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385534927", "bodyText": "This is hard to read, how about just\nif (state != state.SHUTDOWN) {\n  state = State.IDLE;\n}", "author": "anuraaga", "createdAt": "2020-02-28T06:58:51Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n+                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    State state() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long lastPingPayload() {\n+        return lastPingPayload;\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (state == State.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    }\n+\n+    /**\n+     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n+     * channel is inactive then the state changes to SHUTDOWN.\n+     */\n+    enum State {\n+        /* Nothing happening, but waiting for IdleStateEvent */\n+        IDLE,\n+\n+        /* PING is scheduled */\n+        PING_SCHEDULED,\n+\n+        /* PING is sent and is pending ACK */\n+        PENDING_PING_ACK,\n+\n+        /* Not active anymore */\n+        SHUTDOWN\n+    }\n+\n+    private class PingWriteListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            if (future.isSuccess()) {\n+                final EventLoop el = channel.eventLoop();\n+                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n+                state = State.PENDING_PING_ACK;\n+                stopwatch.reset().start();\n+            } else {\n+                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n+                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n+                logger.debug(\"{} Channel PING write failed\", channel);\n+                state = state == State.SHUTDOWN ? State.SHUTDOWN : State.IDLE;", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NTY4MA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385985680", "bodyText": "Sorry for not fixing this in earlier PR fixes and thanks for doing it \ud83d\ude47", "author": "sivaalli", "createdAt": "2020-02-29T01:07:53Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java", "diffHunk": "@@ -339,7 +339,8 @@ void finishSuccessfully(ChannelPipeline pipeline, SessionProtocol protocol) {\n \n         final long idleTimeoutMillis = clientFactory.idleTimeoutMillis();\n         if (idleTimeoutMillis > 0) {\n-            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis));\n+            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis,\n+                                                               protocol.isMultiplex()));", "originalCommit": "f90b1d2f88c058bf04731f7d812e2e98ae4944fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTQ5NQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386195495", "bodyText": "are sent", "author": "anuraaga", "createdAt": "2020-03-02T04:44:34Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,47 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n+     * frames on an idle HTTP/2 connection.\n+     * If true, then PINGs are send when the connection is idle, no otherwise. Connection is considered idle", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTY5NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386195694", "bodyText": "Can just return , no otherwise", "author": "anuraaga", "createdAt": "2020-03-02T04:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTU1Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386195557", "bodyText": "Remove a boolean indicating", "author": "anuraaga", "createdAt": "2020-03-02T04:45:13Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,47 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTcxNw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386195717", "bodyText": "For all the flags", "author": "anuraaga", "createdAt": "2020-03-02T04:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTg5Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386195897", "bodyText": "I rhink for both flags we can use when instead of on.", "author": "anuraaga", "createdAt": "2020-03-02T04:47:08Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,47 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n+     * frames on an idle HTTP/2 connection.\n+     * If true, then PINGs are send when the connection is idle, no otherwise. Connection is considered idle\n+     * when there is no read or write for at least {@link Flags#defaultClientIdleTimeoutMillis()} for client and\n+     * {@link Flags#defaultServerIdleTimeoutMillis()} ()} for server.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.useHttp2PingOnIdle=true} JVM option to enable it.\n+     */\n+    public static boolean useHttp2PingOnIdle() {", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTk3Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386195972", "bodyText": "Do we need to document any interaction between this and the other flag?", "author": "anuraaga", "createdAt": "2020-03-02T04:47:41Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,47 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n+     * frames on an idle HTTP/2 connection.\n+     * If true, then PINGs are send when the connection is idle, no otherwise. Connection is considered idle\n+     * when there is no read or write for at least {@link Flags#defaultClientIdleTimeoutMillis()} for client and\n+     * {@link Flags#defaultServerIdleTimeoutMillis()} ()} for server.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.useHttp2PingOnIdle=true} JVM option to enable it.\n+     */\n+    public static boolean useHttp2PingOnIdle() {\n+        return USE_HTTP2_PING_ON_IDLE;\n+    }\n+\n+    /**\n+     * Returns a boolean indicating whether to <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n+     * frames on a HTTP/2 connection when it is idle and there are no active HTTP/2 stream.\n+     * A connection is considered having no active streams means that are no requests and responses pending.\n+     * This does not necessarily indicate end of life of a HTTP/2 connection.\n+     * \\A client could create a new stream if it intends to use the same connection.", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIzMzc4Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386233787", "bodyText": "nit: backslash", "author": "trustin", "createdAt": "2020-03-02T07:38:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxNjI1OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386216258", "bodyText": "nit: I think we can make this final by assigning null in the constructor.", "author": "minwoox", "createdAt": "2020-03-02T06:32:18Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java", "diffHunk": "@@ -16,27 +16,37 @@\n \n package com.linecorp.armeria.client;\n \n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler;\n import com.linecorp.armeria.internal.common.AbstractHttp2ConnectionHandler;\n \n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2ConnectionDecoder;\n import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.timeout.IdleStateEvent;\n \n final class Http2ClientConnectionHandler extends AbstractHttp2ConnectionHandler {\n \n     private final HttpClientFactory clientFactory;\n     private final Http2ResponseDecoder responseDecoder;\n+    @Nullable\n+    private Http2KeepAliveHandler keepAlive;", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxODA5Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386218097", "bodyText": "nit: need to remove ()}", "author": "minwoox", "createdAt": "2020-03-02T06:40:12Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,47 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n+     * frames on an idle HTTP/2 connection.\n+     * If true, then PINGs are send when the connection is idle, no otherwise. Connection is considered idle\n+     * when there is no read or write for at least {@link Flags#defaultClientIdleTimeoutMillis()} for client and\n+     * {@link Flags#defaultServerIdleTimeoutMillis()} ()} for server.", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxOTE3OQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386219179", "bodyText": "nit: linkplain -> link", "author": "minwoox", "createdAt": "2020-03-02T06:45:07Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxOTIxOQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386219219", "bodyText": "nit: a -> an", "author": "minwoox", "createdAt": "2020-03-02T06:45:19Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxOTUxNg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386219516", "bodyText": "ditto a -> an", "author": "minwoox", "createdAt": "2020-03-02T06:46:25Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyMDQ2Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386220462", "bodyText": "We can remove public here and add @VisibleForTesting", "author": "minwoox", "createdAt": "2020-03-02T06:50:16Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingOnIdle()\n+ * @see Flags#useHttp2PingOnNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+             Flags.useHttp2PingOnNoActiveStreams());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyMDg1Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386220857", "bodyText": "nit: HTTP/2 (there's no .0 for HTTP/2)", "author": "minwoox", "createdAt": "2020-03-02T06:51:52Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingOnIdle()\n+ * @see Flags#useHttp2PingOnNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+             Flags.useHttp2PingOnNoActiveStreams());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} triggered.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyMTEwNw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386221107", "bodyText": "an -> a", "author": "minwoox", "createdAt": "2020-03-02T06:52:58Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingOnIdle()\n+ * @see Flags#useHttp2PingOnNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+             Flags.useHttp2PingOnNoActiveStreams());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} triggered.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler may not be ready because it is currently handling\n+        // sending a PING or expecting a PING ACK on channel.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public void onChannelRead() {\n+        state = State.IDLE;\n+        cancelFutures();\n+    }\n+\n+    private void cancelFutures() {\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) {\n+        final long elapsed = getStopwatchElapsedInNanos();\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        // This condition can be true when channel read some data other than PING ACK frame\n+        // or a PING ACK is received without sending PING in first place.\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n+                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    State state() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long lastPingPayload() {\n+        return lastPingPayload;\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (state == State.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing an idle channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed an channel\", channel);", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNTE2OQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386225169", "bodyText": "I think we can add pingWriteFuture = null;.", "author": "minwoox", "createdAt": "2020-03-02T07:09:06Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingOnIdle()\n+ * @see Flags#useHttp2PingOnNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+             Flags.useHttp2PingOnNoActiveStreams());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} triggered.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler may not be ready because it is currently handling\n+        // sending a PING or expecting a PING ACK on channel.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public void onChannelRead() {\n+        state = State.IDLE;\n+        cancelFutures();\n+    }\n+\n+    private void cancelFutures() {\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) {\n+        final long elapsed = getStopwatchElapsedInNanos();\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIzNDA2NQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386234065", "bodyText": "Could be moved to internal.common", "author": "trustin", "createdAt": "2020-03-02T07:39:44Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIzNDg1MQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386234851", "bodyText": "Perhaps we should not log anything if the write future has been cancelled by cancelFutures()?", "author": "trustin", "createdAt": "2020-03-02T07:42:11Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingOnIdle()\n+ * @see Flags#useHttp2PingOnNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+             Flags.useHttp2PingOnNoActiveStreams());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} triggered.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler may not be ready because it is currently handling\n+        // sending a PING or expecting a PING ACK on channel.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public void onChannelRead() {\n+        state = State.IDLE;\n+        cancelFutures();\n+    }\n+\n+    private void cancelFutures() {\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) {\n+        final long elapsed = getStopwatchElapsedInNanos();\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        // This condition can be true when channel read some data other than PING ACK frame\n+        // or a PING ACK is received without sending PING in first place.\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n+                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    State state() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long lastPingPayload() {\n+        return lastPingPayload;\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (state == State.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing an idle channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed an channel\", channel);\n+            } else {\n+                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    }\n+\n+    private long getStopwatchElapsedInNanos() {\n+        if (stopwatch == null) {\n+            return -1;\n+        }\n+        return stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+    }\n+\n+    /**\n+     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n+     * channel is inactive then the state changes to SHUTDOWN.\n+     */\n+    enum State {\n+        /* Nothing happening, but waiting for IdleStateEvent */\n+        IDLE,\n+\n+        /* PING is scheduled */\n+        PING_SCHEDULED,\n+\n+        /* PING is sent and is pending ACK */\n+        PENDING_PING_ACK,\n+\n+        /* Not active anymore */\n+        SHUTDOWN\n+    }\n+\n+    private class PingWriteListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            if (future.isSuccess()) {\n+                final EventLoop el = channel.eventLoop();\n+                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n+                state = State.PENDING_PING_ACK;\n+                resetStopwatch();\n+            } else {\n+                // Mostly because the channel is already closed. So ignore and change state to IDLE.", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NTU2Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386765563", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <p>Connection is considered idle when there is no read or write for at least\n          \n          \n            \n                 * <p>A connection is considered idle when there is no read or write for at least", "author": "ikhoon", "createdAt": "2020-03-03T02:24:29Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,58 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n+     * frames on an idle HTTP/2 connection.\n+     *\n+     * <p>Connection is considered idle when there is no read or write for at least", "originalCommit": "46577d53e21a6472072d03cc4eb47ca678f28c62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3MTgyMg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386771822", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final class TestIdleStateHandler extends ChannelInboundHandlerAdapter {\n          \n          \n            \n                private static final class TestIdleStateHandler extends ChannelInboundHandlerAdapter {", "author": "ikhoon", "createdAt": "2020-03-03T02:49:05Z", "path": "core/src/test/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.mockito.Mock;\n+\n+import com.linecorp.armeria.internal.common.Http2KeepAliveHandler.State;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.timeout.IdleStateEvent;\n+\n+class Http2KeepAliveHandlerTest {\n+\n+    private static final String sendPingsOnNoActiveStreams = \"sendPingsOnNoActiveStreams\";\n+\n+    private static final long pingTimeout = 100;\n+    @Mock\n+    private Http2FrameWriter frameWriter;\n+    @Mock\n+    private Http2Connection connection;\n+    private EmbeddedChannel ch;\n+    private ChannelPromise promise;\n+\n+    private Http2KeepAliveHandler keepAlive;\n+\n+    @BeforeEach\n+    public void setup(TestInfo testInfo) throws Exception {\n+        ch = new EmbeddedChannel();\n+        promise = ch.newPromise();\n+        keepAlive = new Http2KeepAliveHandler(ch, frameWriter, connection, pingTimeout,\n+                                              !testInfo.getTags().contains(sendPingsOnNoActiveStreams));\n+\n+        ch.pipeline().addLast(new TestIdleStateHandler(keepAlive));\n+\n+        assertThat(ch.isOpen()).isTrue();\n+        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n+    }\n+\n+    @AfterEach\n+    public void after() {\n+        assertThat(ch.finish()).isFalse();\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenPingTimesOut_ShouldCloseConnection() throws Exception {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n+\n+        promise.setSuccess();\n+        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n+        waitUntilPingTimeout();\n+        assertThat(keepAlive.state()).isEqualTo(State.SHUTDOWN);\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isFalse();\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenWritePingFailsBecauseChannelIsClosed_ShouldSetStateToShutdown() throws\n+                                                                                               Exception {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n+\n+        ch.close();\n+        assertThat(keepAlive.state()).isEqualTo(State.SHUTDOWN);\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isFalse();\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenWritePingFailsOfUnknownReason_ShouldSetStateToIdle() throws Exception {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n+\n+        promise.setFailure(new Exception(\"Unknown reason\"));\n+        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isTrue();\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenPingAckIsReceivedBeforeTimeout_ShouldResetStateToIdle() throws Exception {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n+\n+        promise.setSuccess();\n+        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n+\n+        keepAlive.onPingAck(keepAlive.lastPingPayload());\n+        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isTrue();\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenAnyDataReadBeforeTimeout_ShouldResetStateToIdle() throws Exception {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n+\n+        promise.setSuccess();\n+        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n+\n+        keepAlive.onChannelRead();\n+        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isTrue();\n+    }\n+\n+    @Test\n+    @Tag(\"sendPingsOnNoActiveStreams\")\n+    void testOnChannelIdle_WhenShouldNotSendPingsOnIdleAndActiveStreamsAreZero_ShouldCloseConnection()\n+            throws Exception {\n+        when(connection.numActiveStreams()).thenReturn(0);\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+\n+        assertThat(keepAlive.state()).isEqualTo(State.SHUTDOWN);\n+\n+        verify(frameWriter, never()).writePing(any(), anyBoolean(), anyLong(), any());\n+        assertThat(ch.isOpen()).isFalse();\n+    }\n+\n+    @Test\n+    @Tag(\"sendPingsOnNoActiveStreams\")\n+    void testOnChannelIdle_WhenShouldNotSendPingsOnIdleWithActiveStreams_ShouldCloseConnection()\n+            throws Exception {\n+        when(connection.numActiveStreams()).thenReturn(1);\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n+\n+        promise.setSuccess();\n+        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n+\n+        keepAlive.onPingAck(keepAlive.lastPingPayload());\n+        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isTrue();\n+    }\n+\n+    private void waitUntilPingTimeout() throws InterruptedException {\n+        Thread.sleep(pingTimeout * 3 / 2);\n+        ch.runPendingTasks();\n+    }\n+\n+    public static final class TestIdleStateHandler extends ChannelInboundHandlerAdapter {", "originalCommit": "46577d53e21a6472072d03cc4eb47ca678f28c62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3MTk2NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386771964", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final long pingTimeout = 100;\n          \n          \n            \n                private static final long pingTimeoutMillis = 100;", "author": "ikhoon", "createdAt": "2020-03-03T02:49:44Z", "path": "core/src/test/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.mockito.Mock;\n+\n+import com.linecorp.armeria.internal.common.Http2KeepAliveHandler.State;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.timeout.IdleStateEvent;\n+\n+class Http2KeepAliveHandlerTest {\n+\n+    private static final String sendPingsOnNoActiveStreams = \"sendPingsOnNoActiveStreams\";\n+\n+    private static final long pingTimeout = 100;", "originalCommit": "46577d53e21a6472072d03cc4eb47ca678f28c62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3NDI4Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386774282", "bodyText": "nit: Indent", "author": "ikhoon", "createdAt": "2020-03-03T02:58:49Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@link Flags#useHttp2PingWhenIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@link Flags#useHttp2PingWhenNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingWhenIdle()\n+ * @see Flags#useHttp2PingWhenNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+             Flags.useHttp2PingWhenNoActiveStreams());\n+    }\n+\n+    @VisibleForTesting\n+    Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {", "originalCommit": "46577d53e21a6472072d03cc4eb47ca678f28c62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "url": "https://github.com/line/armeria/commit/c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "message": "adding Http2KeepAlivePinger but mostly incomplete.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "d16c8be67f4d60be9f89eb831904afeb789bb586", "url": "https://github.com/line/armeria/commit/d16c8be67f4d60be9f89eb831904afeb789bb586", "message": "adding some changes but not working yet", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "18c25d1494c37ad049cf2b85d2018f34117e3fd5", "url": "https://github.com/line/armeria/commit/18c25d1494c37ad049cf2b85d2018f34117e3fd5", "message": "Finishing up Http2KeepAlivePinger. Some cosmetic changes are pending.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "9cb48b05732ce3f162ae6b7be85a7f9053693975", "url": "https://github.com/line/armeria/commit/9cb48b05732ce3f162ae6b7be85a7f9053693975", "message": "fixing up a small error.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "b9d2fd7b5685ff201aae33effccf5f7727088cd2", "url": "https://github.com/line/armeria/commit/b9d2fd7b5685ff201aae33effccf5f7727088cd2", "message": "Finishing up Http2KeepAliveHandler", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "44179dfba4e9d0c4c5a419159d14b5ccf8665545", "url": "https://github.com/line/armeria/commit/44179dfba4e9d0c4c5a419159d14b5ccf8665545", "message": "changing state=State.PING_SCHEDULED after flushing.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "cf2b40f35014451a28ae5218659f49b4bd58ce07", "url": "https://github.com/line/armeria/commit/cf2b40f35014451a28ae5218659f49b4bd58ce07", "message": "plugging in Http2KeepAliveHandler into decoders", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "3f5ab2deb3acc13ee912553fff22eab9bdf1e28c", "url": "https://github.com/line/armeria/commit/3f5ab2deb3acc13ee912553fff22eab9bdf1e28c", "message": "Update license version", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "f9196d504c7a43a9f3c0f1ecea29629910a5febd", "url": "https://github.com/line/armeria/commit/f9196d504c7a43a9f3c0f1ecea29629910a5febd", "message": "making some suggestions requested.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "d0c9250dde23800a5e789ed3eebf135cc0a5b274", "url": "https://github.com/line/armeria/commit/d0c9250dde23800a5e789ed3eebf135cc0a5b274", "message": "removing some comments which are obvious", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "7888ab01c737b979df318e009007afcbb4e1a8cb", "url": "https://github.com/line/armeria/commit/7888ab01c737b979df318e009007afcbb4e1a8cb", "message": "implementing changes. Still changes pending with client", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "802543c30e09a8a0df6e07a37352f0da2e4a2620", "url": "https://github.com/line/armeria/commit/802543c30e09a8a0df6e07a37352f0da2e4a2620", "message": "handling client keep-alive.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "75fb9b17c5f467b45cd859becf9dc97281437671", "url": "https://github.com/line/armeria/commit/75fb9b17c5f467b45cd859becf9dc97281437671", "message": "Documentation update.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "fdabf751c3e6113a04b90155696cca9205441f9c", "url": "https://github.com/line/armeria/commit/fdabf751c3e6113a04b90155696cca9205441f9c", "message": "adding the property in Flags.java", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "42f289310280791d97c482d854bc0af10ff08894", "url": "https://github.com/line/armeria/commit/42f289310280791d97c482d854bc0af10ff08894", "message": "fixing checkstyle errors.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "b520d249757f3b16a1022b8046e9792d6145263f", "url": "https://github.com/line/armeria/commit/b520d249757f3b16a1022b8046e9792d6145263f", "message": "Setting IdleTimeoutHandler.isHttp2 to true when AbstractHttp2ConnectionHandler.handlerAdded.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "ca0ef211ea0795cfc18a0e057b27cadc023376d7", "url": "https://github.com/line/armeria/commit/ca0ef211ea0795cfc18a0e057b27cadc023376d7", "message": "finishing up some edge cases after testing", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "5d5431a38e777a0f379ae5c169efe03e04b788a0", "url": "https://github.com/line/armeria/commit/5d5431a38e777a0f379ae5c169efe03e04b788a0", "message": "using milli seconds for ping timeout and making other changes as suggested.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "9bf5895c9a30e151a9e0a176354d3705199d82e4", "url": "https://github.com/line/armeria/commit/9bf5895c9a30e151a9e0a176354d3705199d82e4", "message": "Adding test and moving IdleTimeoutHandler.setHttp2 to Http2ServerConnectionHandler instead of AbstractHttp2ConnectionHandler", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "7d7989d5193caba716df143d5aec10e8011bc8ea", "url": "https://github.com/line/armeria/commit/7d7989d5193caba716df143d5aec10e8011bc8ea", "message": "Adding more docs.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "1fe68c24af2a47d98173c8c94a919715409d0781", "url": "https://github.com/line/armeria/commit/1fe68c24af2a47d98173c8c94a919715409d0781", "message": "capitalizing http verbs", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "3a3d39616deecb4346da3852338fe4024feeea7a", "url": "https://github.com/line/armeria/commit/3a3d39616deecb4346da3852338fe4024feeea7a", "message": "Making suggested changes from @trustin", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "bdc2da4934a053b0c28abe123503818f6fe6d723", "url": "https://github.com/line/armeria/commit/bdc2da4934a053b0c28abe123503818f6fe6d723", "message": "making small typo change", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "16fa1859d9b91ec64ee0d2cbb1afd0aa99db25e0", "url": "https://github.com/line/armeria/commit/16fa1859d9b91ec64ee0d2cbb1afd0aa99db25e0", "message": "fixing imports", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "0eccd07eddec3a702fd9137930dc080ca8eb8506", "url": "https://github.com/line/armeria/commit/0eccd07eddec3a702fd9137930dc080ca8eb8506", "message": "adding necessary changes to handle pings on http2 connection. Tests pending.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "8116abef15a5468bebd3ff644c66554642ff9514", "url": "https://github.com/line/armeria/commit/8116abef15a5468bebd3ff644c66554642ff9514", "message": "mostly finalizing everything. Tests are still pending.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "cb29ae04c75de0c26da549444b87c45cfaaf90f0", "url": "https://github.com/line/armeria/commit/cb29ae04c75de0c26da549444b87c45cfaaf90f0", "message": "fixing an import", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "69fae8ef00901b0d6ed43927783e2d58cac90023", "url": "https://github.com/line/armeria/commit/69fae8ef00901b0d6ed43927783e2d58cac90023", "message": "moving log to start of method.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "5705d3cf8eac0fe42e449ccb4c1f0c4cc42edf7a", "url": "https://github.com/line/armeria/commit/5705d3cf8eac0fe42e449ccb4c1f0c4cc42edf7a", "message": "adding all tests and making final changes.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "236a6b42506844d3ea2b0481d8c3544fa6f0a48f", "url": "https://github.com/line/armeria/commit/236a6b42506844d3ea2b0481d8c3544fa6f0a48f", "message": "fixing names.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "819af8eff49477f010f00c22a9a4db8b72b2a8cb", "url": "https://github.com/line/armeria/commit/819af8eff49477f010f00c22a9a4db8b72b2a8cb", "message": "Update core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java\n\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "83efb5f316dd189691ffc78e32c8f348a4b56de6", "url": "https://github.com/line/armeria/commit/83efb5f316dd189691ffc78e32c8f348a4b56de6", "message": "addressing some suggested changes. More on the way", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "97d447f1b7b999fe78404150687e60b3253e5573", "url": "https://github.com/line/armeria/commit/97d447f1b7b999fe78404150687e60b3253e5573", "message": "renaming to defaultUseHttp2PingOnNoActiveStreams", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "0d14d3bc4bbf15252f3c5509a747ae09d3a8b467", "url": "https://github.com/line/armeria/commit/0d14d3bc4bbf15252f3c5509a747ae09d3a8b467", "message": "not using default for Flags.java", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "4074180bd06684b41affb8dda7859398fc579161", "url": "https://github.com/line/armeria/commit/4074180bd06684b41affb8dda7859398fc579161", "message": "formatting code, but no functional changes", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "b42c13801aa6beba0e7eb7b141d98fb05a0079fc", "url": "https://github.com/line/armeria/commit/b42c13801aa6beba0e7eb7b141d98fb05a0079fc", "message": "implementing onChannelRead changes to reset ping and also fixing a flag name issue", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "2e566b19eeb4501ea55373c8aa953077e3af0baf", "url": "https://github.com/line/armeria/commit/2e566b19eeb4501ea55373c8aa953077e3af0baf", "message": "addressing some missed suggestions", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "a65dda197149b6318115be7b13b7bd90234b63a0", "url": "https://github.com/line/armeria/commit/a65dda197149b6318115be7b13b7bd90234b63a0", "message": "Improving the docs", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "b4fcb85da16809e3a5cc2e7a550870d0aea43730", "url": "https://github.com/line/armeria/commit/b4fcb85da16809e3a5cc2e7a550870d0aea43730", "message": "implementing some suggestions.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "6f2056b7327131670deea5067b2a8300e81b52aa", "url": "https://github.com/line/armeria/commit/6f2056b7327131670deea5067b2a8300e81b52aa", "message": "making suggested java doc changes for flags etc.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "5b73c619ce4d253023cc86248c9cf4f8fa32c987", "url": "https://github.com/line/armeria/commit/5b73c619ce4d253023cc86248c9cf4f8fa32c987", "message": "implementing suggestions from @ikhoon", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "68364342e20f5b8665084dd1609d4f6a340640e2", "url": "https://github.com/line/armeria/commit/68364342e20f5b8665084dd1609d4f6a340640e2", "message": "adding http2 ping related configs on ServerConfig and ClientFactoryBuilder", "committedDate": "2020-03-05T22:40:38Z", "type": "commit"}, {"oid": "68364342e20f5b8665084dd1609d4f6a340640e2", "url": "https://github.com/line/armeria/commit/68364342e20f5b8665084dd1609d4f6a340640e2", "message": "adding http2 ping related configs on ServerConfig and ClientFactoryBuilder", "committedDate": "2020-03-05T22:40:38Z", "type": "forcePushed"}, {"oid": "dbf57b76e2e74b7c9c4a03544199a4a17f5dcdab", "url": "https://github.com/line/armeria/commit/dbf57b76e2e74b7c9c4a03544199a4a17f5dcdab", "message": "removing extra line", "committedDate": "2020-03-05T22:46:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwMTY5Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r388701693", "bodyText": "nit: indentation?", "author": "minwoox", "createdAt": "2020-03-06T03:54:47Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@link Flags#defaultHttp2PingTimeoutMillis()} is greater that zero.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@link Flags#useHttp2PingWhenNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingWhenNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                          long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {", "originalCommit": "dbf57b76e2e74b7c9c4a03544199a4a17f5dcdab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwMjY5Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r388702693", "bodyText": "Fixed :)", "author": "sivaalli", "createdAt": "2020-03-06T03:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwMTY5Mw=="}], "type": "inlineReview"}, {"oid": "141ca3959a59e1897767066f6a63eacddd25bc7a", "url": "https://github.com/line/armeria/commit/141ca3959a59e1897767066f6a63eacddd25bc7a", "message": "fixed indentation", "committedDate": "2020-03-06T03:59:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2ODQwMA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r388768400", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    requireNonNull(http2PingTimeout);\n          \n          \n            \n                    requireNonNull(http2PingTimeout, \"http2PingTimeout\");", "author": "ikhoon", "createdAt": "2020-03-06T08:27:15Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -412,6 +412,40 @@ public ClientFactoryBuilder idleTimeoutMillis(long idleTimeoutMillis) {\n         return this;\n     }\n \n+    /**\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     *\n+     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n+     */\n+    public ClientFactoryBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n+        checkArgument(http2PingTimeoutMillis >= 0,\n+                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeoutMillis);\n+        option(ClientFactoryOption.HTTP2_PING_TIMEOUT_MILLIS, http2PingTimeoutMillis);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     *\n+     * @param http2PingTimeout the timeout. {@code 0} disables the timeout.\n+     */\n+    public ClientFactoryBuilder http2PingTimeout(Duration http2PingTimeout) {\n+        requireNonNull(http2PingTimeout);", "originalCommit": "141ca3959a59e1897767066f6a63eacddd25bc7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5b786c697f2e28a048cb3fdddee1d5b55fad8fd6", "url": "https://github.com/line/armeria/commit/5b786c697f2e28a048cb3fdddee1d5b55fad8fd6", "message": "committing @ikhoon 's changes", "committedDate": "2020-03-06T13:25:50Z", "type": "commit"}]}