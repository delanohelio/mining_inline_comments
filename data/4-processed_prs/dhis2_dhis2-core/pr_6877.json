{"pr_number": 6877, "pr_title": "feat: Tracker Import metadata cache", "pr_createdAt": "2020-12-10T11:19:29Z", "pr_url": "https://github.com/dhis2/dhis2-core/pull/6877", "timeline": [{"oid": "d39d8386acf5141b3964a33a30269fc17e9feb00", "url": "https://github.com/dhis2/dhis2-core/commit/d39d8386acf5141b3964a33a30269fc17e9feb00", "message": "feat: Tracker Import metadata cache\n\nThis PR introduces a Cache2K-based cache for caching metadata objects accessed during the Preheat stage of the the Tracker Import process.\n\nNotable changes:\n\n- Introduced a `cache` property to the `@StrategyFor` annotation used to pre-load metadata. The property signals if the Metadata fetching class should cache the results\n- Introduced a `PreheatCacheService` in the `preheat` package that is responsible for instantiating the caches for the metadata objects.\n- Introduced a new global property `tracker.import.preheat.cache.enabled` to disable the Tracker Import cache.\n- Bumped version of cache2K to `1.6.0.Final`", "committedDate": "2020-12-10T11:18:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM2OTg3OQ==", "url": "https://github.com/dhis2/dhis2-core/pull/6877#discussion_r543369879", "bodyText": "Do we have a jira issue for this todo?", "author": "stian-sandvold", "createdAt": "2020-12-15T14:07:43Z", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/preheat/supplier/classStrategy/AbstractSchemaStrategy.java", "diffHunk": "@@ -109,24 +111,99 @@ protected void queryForIdentifiableObjects( TrackerPreheat preheat, Schema schem\n             }\n             else\n             {\n-                Query query = Query.from( schema );\n-                query.setUser( preheat.getUser() );\n-                query.add( generateRestrictionFromIdentifiers( idScheme, ids ) );\n-                query.setDefaults( Defaults.INCLUDE );\n-                if ( mapper.isAssignableFrom( CopyMapper.class ) )\n+                objects = cacheAwareFetch( preheat.getUser(), schema, identifier, ids, mapper );\n+            }\n+\n+            preheat.put( identifier, objects );\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private List<IdentifiableObject> cacheAwareFetch( User user, Schema schema, TrackerIdentifier identifier, List<String> ids, Class<? extends PreheatMapper> mapper )\n+    {\n+        TrackerIdScheme idScheme = identifier.getIdScheme();\n+        \n+        List<IdentifiableObject> objects;\n+        final String cacheKey = schema.getKlass().getSimpleName();\n+        \n+        if ( canCache() ) // check if this strategy requires caching\n+        {\n+            List<String> toRemove = new ArrayList<>();\n+            List<IdentifiableObject> cachedObjects = new ArrayList<>();\n+\n+            for ( String id : ids )\n+            {\n+                // is the object reference by the given id in cache?\n+                Optional<IdentifiableObject> o = cache.get( cacheKey, id );\n+                if ( o.isPresent()  )\n                 {\n-                    objects = queryService.query( query );\n+                    // add to objects to set into preheat\n+                    cachedObjects.add( o.get() );\n+                    // remove this id from list of id to fetch from db\n+                    toRemove.add( id );\n                 }\n-                else\n+            }\n+            // is there any object which was not found in cache?\n+            if ( ids.size() > toRemove.size() )\n+            {\n+                // remove from the list of ids the ids found in cache\n+                ids.removeAll( toRemove );\n+                \n+                // execute the query\n+                objects = map((List<IdentifiableObject>) queryService.query( buildQuery( schema, user, idScheme, ids ) ), mapper );\n+\n+                // put objects in query based on given scheme\n+                if ( idScheme.equals( TrackerIdScheme.UID ) )\n                 {\n-                    objects = queryService.query( query ).stream().map( o -> Mappers.getMapper( mapper ).map( o ) )\n-                        .map( IdentifiableObject.class::cast ).collect( Collectors.toList() );\n+                    objects.forEach( o -> cache.put( cacheKey, o.getUid(), o, getCacheTTL(), getCapacity() ) );\n                 }\n-\n+                else if ( idScheme.equals( TrackerIdScheme.CODE ) )\n+                {\n+                    objects.forEach( o -> cache.put( cacheKey, o.getCode(), o, getCacheTTL(), getCapacity() ) );\n+                }\n+                else if ( idScheme.equals( TrackerIdScheme.ATTRIBUTE ) )\n+                {\n+                    // TODO", "originalCommit": "d39d8386acf5141b3964a33a30269fc17e9feb00", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}