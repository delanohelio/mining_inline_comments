{"pr_number": 5935, "pr_title": "feat: Dataset openPeriodsAfterCoEndDate", "pr_createdAt": "2020-08-14T17:30:11Z", "pr_url": "https://github.com/dhis2/dhis2-core/pull/5935", "timeline": [{"oid": "c771446ccd47ccc44016b3096f2d9d22582557c7", "url": "https://github.com/dhis2/dhis2-core/commit/c771446ccd47ccc44016b3096f2d9d22582557c7", "message": "feat: Dataset openPeriodsAfterCoEndDate", "committedDate": "2020-08-14T17:17:11Z", "type": "commit"}, {"oid": "ba18d90187d575349a72260e0f7f202095ec815c", "url": "https://github.com/dhis2/dhis2-core/commit/ba18d90187d575349a72260e0f7f202095ec815c", "message": "Merge branch 'master' into DHIS2-9081", "committedDate": "2020-08-14T17:19:05Z", "type": "commit"}, {"oid": "adcd99949e70e14cfc7be95f912fcead337aed13", "url": "https://github.com/dhis2/dhis2-core/commit/adcd99949e70e14cfc7be95f912fcead337aed13", "message": "Rename flyway script", "committedDate": "2020-08-14T17:29:31Z", "type": "commit"}, {"oid": "2883e99713ca3578de66ff94dbf36b6046adc9b7", "url": "https://github.com/dhis2/dhis2-core/commit/2883e99713ca3578de66ff94dbf36b6046adc9b7", "message": "Rename flyway script to V2_35_18", "committedDate": "2020-08-14T18:08:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk1MTg1NA==", "url": "https://github.com/dhis2/dhis2-core/pull/5935#discussion_r470951854", "bodyText": "Minor: I wonder if we should make this variable's name more explicit (Co -> CategoryOption)", "author": "luciano-fiandesio", "createdAt": "2020-08-15T07:59:20Z", "path": "dhis-2/dhis-api/src/main/java/org/hisp/dhis/dataset/DataSet.java", "diffHunk": "@@ -192,6 +192,12 @@\n      */\n     private int openFuturePeriods;\n \n+    /**\n+     * Number of periods to open for data capture that are after the category\n+     * option's end date.\n+     */\n+    private int openPeriodsAfterCoEndDate;", "originalCommit": "2883e99713ca3578de66ff94dbf36b6046adc9b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk3MTk4NQ==", "url": "https://github.com/dhis2/dhis2-core/pull/5935#discussion_r470971985", "bodyText": "That sounds good to me. What do others think? Presumably we would change the database column name and the WebAPI identifier name to match. Would this be too long? openperiodsaftercategoryoptionenddate, openPeriodsAfterCategoryOptionEndDate.", "author": "jimgrace", "createdAt": "2020-08-15T12:19:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk1MTg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM3NDc2OA==", "url": "https://github.com/dhis2/dhis2-core/pull/5935#discussion_r471374768", "bodyText": "Sounds good to me.", "author": "stian-sandvold", "createdAt": "2020-08-17T10:05:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk1MTg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk1MjA2OA==", "url": "https://github.com/dhis2/dhis2-core/pull/5935#discussion_r470952068", "bodyText": "I'm not sure about this: we are now adding sql (postgres specific) logic to a domain class, which should be agnostic regarding the underlying persistent engine. I wonder if it would be better to have a separate utility class that would return this interval String based on the given period. This would have the benefit of reducing the number of Period subclasses to modify.", "author": "luciano-fiandesio", "createdAt": "2020-08-15T08:02:01Z", "path": "dhis-2/dhis-api/src/main/java/org/hisp/dhis/period/PeriodType.java", "diffHunk": "@@ -344,6 +344,13 @@ public Period toIsoPeriod( DateTimeUnit dateTimeUnit )\n      */\n     public abstract int getFrequencyOrder();\n \n+    /**\n+     * Returns a string usable as the interval value in PostgreSQL queries.\n+     *\n+     * @return the SQL interval.\n+     */\n+    public abstract String getSqlInterval();", "originalCommit": "2883e99713ca3578de66ff94dbf36b6046adc9b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk3MjI1OQ==", "url": "https://github.com/dhis2/dhis2-core/pull/5935#discussion_r470972259", "bodyText": "I'd be interested in another opinion about this also. I agree with the principle. The main reason I did it this way is so that if/when we implement a new PeriodType we won't forget to put this code in. (And we are now assuming postgres in some other parts of the code.)", "author": "jimgrace", "createdAt": "2020-08-15T12:22:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk1MjA2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM3NTkwMg==", "url": "https://github.com/dhis2/dhis2-core/pull/5935#discussion_r471375902", "bodyText": "We have comitted to Postgres, so I think it's fine to do some postgres specific stuff in places. @luciano-fiandesio would it make more sense to make this an enum, that would contain the postgres specific value, or a utility class that converted from the enum to the postgres value? I am open for both.", "author": "stian-sandvold", "createdAt": "2020-08-17T10:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk1MjA2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4Mjg3Ng==", "url": "https://github.com/dhis2/dhis2-core/pull/5935#discussion_r471382876", "bodyText": "@stian-sandvold is not really about Postgres vs. any other DB, but is more adding DB specific logic to domain classes (which are growing in complexity since we are adding new functionalities all the time). In this case, I agree it's not really logic, but more like a constant, but still, from a single-responsibility concept point of view, I think a simple utility class would be better (e.g. SqlIntervalUtil.getInterval(Period p))", "author": "luciano-fiandesio", "createdAt": "2020-08-17T10:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk1MjA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk1MjIzMw==", "url": "https://github.com/dhis2/dhis2-core/pull/5935#discussion_r470952233", "bodyText": "This test is perfectly fine, but you may also consider using Junit parametrized test: https://github.com/junit-team/junit4/wiki/Parameterized-tests", "author": "luciano-fiandesio", "createdAt": "2020-08-15T08:04:21Z", "path": "dhis-2/dhis-api/src/test/java/org/hisp/dhis/dataApproval/DataApprovalWorkflowTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package org.hisp.dhis.dataApproval;\n+\n+/*\n+ * Copyright (c) 2004-2020, University of Oslo\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following disclaimer in the documentation\n+ * and/or other materials provided with the distribution.\n+ * Neither the name of the HISP project nor the names of its contributors may\n+ * be used to endorse or promote products derived from this software without\n+ * specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+import org.hisp.dhis.dataapproval.DataApprovalLevel;\n+import org.hisp.dhis.dataapproval.DataApprovalWorkflow;\n+import org.hisp.dhis.dataset.DataSet;\n+import org.hisp.dhis.period.*;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import static com.google.common.collect.Sets.newHashSet;\n+import static org.junit.Assert.assertEquals;\n+\n+/**\n+ * @author Jim Grace\n+ */\n+public class DataApprovalWorkflowTest\n+{\n+    @Test\n+    public void testGetSortedLevels()\n+    {\n+        DataApprovalLevel level1 = new DataApprovalLevel( \"level1\", 1, null );\n+        level1.setLevel( 1 );\n+\n+        DataApprovalLevel level2 = new DataApprovalLevel( \"level2\", 2, null );\n+        level2.setLevel( 2 );\n+\n+        DataApprovalLevel level3 = new DataApprovalLevel( \"level3\", 3, null );\n+        level3.setLevel( 3 );\n+\n+        DataApprovalWorkflow workflow = new DataApprovalWorkflow( \"test workflow\", new DailyPeriodType(), newHashSet(level3, level2, level1 ) );\n+\n+        List<DataApprovalLevel> levels = workflow.getSortedLevels();\n+\n+        assertEquals( 1, levels.get( 0 ).getLevel() );\n+        assertEquals( 2, levels.get( 1 ).getLevel() );\n+        assertEquals( 3, levels.get( 2 ).getLevel() );\n+    }\n+\n+    @Test\n+    public void testGetWorkflowSqlCoEnddateExtension()", "originalCommit": "2883e99713ca3578de66ff94dbf36b6046adc9b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk3MzAzMg==", "url": "https://github.com/dhis2/dhis2-core/pull/5935#discussion_r470973032", "bodyText": "Thanks for the tip. There are undoubtedly places where I should be using parameterized JUnit tests. One reason to keep this test as coded, however, is because it's also testing to be sure that the longest extension is always returned as data sets are added to the workflow. Note that the (nominal period length) * (the number of periods) is always increasing, so the latest one should always be returned. (It might be worth mentioning this in a method JavaDoc header!)", "author": "jimgrace", "createdAt": "2020-08-15T12:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk1MjIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk1MjQwMw==", "url": "https://github.com/dhis2/dhis2-core/pull/5935#discussion_r470952403", "bodyText": "I got to trust you on this one \ud83d\ude03", "author": "luciano-fiandesio", "createdAt": "2020-08-15T08:06:20Z", "path": "dhis-2/dhis-services/dhis-service-core/src/main/java/org/hisp/dhis/dataapproval/hibernate/HibernateDataApprovalStore.java", "diffHunk": "@@ -477,33 +509,56 @@ else if ( orgUnits != null && orgUnitLevel != highestUserApprovalLevel.getOrgUni\n                 highestApprovedOrgUnitJoin +\n                 \"where da.workflowid = \" + workflow.getId() + \" \" +\n                 \"and da.periodid = \" + getWorkflowPeriodId( workflow, endDate ) + \" \" +\n-                \"and da.attributeoptioncomboid = cocco.categoryoptioncomboid \" +\n+                \"and da.attributeoptioncomboid = coc.categoryoptioncomboid \" +\n                 \"and \" + highestApprovedOrgUnitCompare + userApprovalLevelRestrictions +\n             \") as highest_approved, \" +\n             readyBelowSubquery + \" as ready_below, \" +\n             approvedAboveSubquery + \" as approved_above \" +\n             \"from categoryoptioncombo coc \" +\n-            \"join categoryoptioncombos_categoryoptions cocco on cocco.categoryoptioncomboid = coc.categoryoptioncomboid \" +\n-            ( attributeCombo == null ? \"\" : \"join categorycombos_optioncombos ccoc on ccoc.categoryoptioncomboid = cocco.categoryoptioncomboid \" +\n-                \"and ccoc.categorycomboid = \" + attributeCombo.getId() + \" \" ) +\n-            \"join dataelementcategoryoption co on co.categoryoptionid = cocco.categoryoptionid \" +\n-                \"and (co.startdate is null or co.startdate <= '\" + endDate + \"') and (co.enddate is null or co.enddate >= '\" + startDate + \"') \" +\n-            \"join organisationunit o on \" + (orgUnits != null ? \"o.organisationunitid in (\" + orgUnitIds + \")\" : \"o.hierarchylevel = \" + orgUnitLevel + userOrgUnitRestrictions ) + \" \" +\n-            \"left join categoryoption_organisationunits coo on coo.categoryoptionid = co.categoryoptionid \" +\n-            \"left join organisationunit oc on oc.organisationunitid = coo.organisationunitid \" +\n-            \"where ( coo.categoryoptionid is null or \" +\n-                statementBuilder.position( \"o.uid\", \"oc.path\" ) + \" <> 0  or \" +\n-                statementBuilder.position( \"oc.uid\", \"o.path\" ) + \" <> 0 )\" +\n-            ( attributeOptionCombos == null || attributeOptionCombos.isEmpty() ? \"\" : \" and cocco.categoryoptioncomboid in (\" +\n-                StringUtils.join( IdentifiableObjectUtils.getIdentifiers( attributeOptionCombos ), \",\" ) + \") \" ) +\n-            ( isSuperUser ? \"\" :\n-                \" and ( co.publicaccess is null or left(co.publicaccess, 1) = 'r' or co.userid is null or co.userid = \" + user.getId() + \" or exists ( \" +\n-                \"select 1 from dataelementcategoryoptionusergroupaccesses couga \" +\n-                \"left join usergroupaccess uga on uga.usergroupaccessid = couga.usergroupaccessid \" +\n-                \"left join usergroupmembers ugm on ugm.usergroupid = uga.usergroupid \" +\n-                    \"where couga.categoryoptionid = cocco.categoryoptionid and ugm.userid = \" + user.getId() + \") ) \" ) +\n-                \" and exists (select 1 from organisationunit od where od.path like o.path || '%' and od.organisationunitid in \" +\n-                \"(select distinct sourceid from datasetsource dss join dataset ds on ds.datasetid = dss.datasetid where ds.workflowid = \" + workflow.getId() + \"))\";\n+            \"join organisationunit o on \" + ( orgUnits != null ? \"o.organisationunitid in (\" + orgUnitIds + \") \" : \"o.hierarchylevel = \" + orgUnitLevel + userOrgUnitRestrictions + \" \" ) +", "originalCommit": "2883e99713ca3578de66ff94dbf36b6046adc9b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk3MzQzNA==", "url": "https://github.com/dhis2/dhis2-core/pull/5935#discussion_r470973434", "bodyText": "Thanks. :)", "author": "jimgrace", "createdAt": "2020-08-15T12:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk1MjQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM3Mzk1OA==", "url": "https://github.com/dhis2/dhis2-core/pull/5935#discussion_r471373958", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if ( coEndDate != null && (earliestEndDate == null || coEndDate.before( earliestEndDate ) ) )\n          \n          \n            \n                        if ( coEndDate != null && ( earliestEndDate == null || coEndDate.before( earliestEndDate ) ) )", "author": "stian-sandvold", "createdAt": "2020-08-17T10:03:35Z", "path": "dhis-2/dhis-api/src/main/java/org/hisp/dhis/category/CategoryOptionCombo.java", "diffHunk": "@@ -303,6 +327,43 @@ public Date getEarliestEndDate()\n         return earliestEndDate;\n     }\n \n+    // -------------------------------------------------------------------------\n+    // Supportive methods\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * Gets a range of valid dates for this (attribute) cateogry option combo\n+     * for a data set or, if that is not present, a data element.\n+     *\n+     * @param dataSet the data set to get the range for, or\n+     * @param dataElement the data element to get the range for\n+     * @return valid date range for this (attribute) category option combo.\n+     */\n+    private DateRange getDateRange( DataSet dataSet, DataElement dataElement )\n+    {\n+        Date latestStartDate = null;\n+        Date earliestEndDate = null;\n+\n+        for ( CategoryOption co : getCategoryOptions() )\n+        {\n+            if ( co.getStartDate() != null && (latestStartDate == null || co.getStartDate().after( latestStartDate ) ) )\n+            {\n+                latestStartDate = co.getStartDate();\n+            }\n+\n+            Date coEndDate = dataSet != null\n+                ? co.getAdjustedEndDate( dataSet )\n+                : co.getAdjustedEndDate( dataElement );\n+\n+            if ( coEndDate != null && (earliestEndDate == null || coEndDate.before( earliestEndDate ) ) )", "originalCommit": "2883e99713ca3578de66ff94dbf36b6046adc9b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}