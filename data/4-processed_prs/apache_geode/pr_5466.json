{"pr_number": 5466, "pr_title": "GEODE-8119: Threads hangs when offline disk store command is invoked", "pr_createdAt": "2020-08-20T11:42:30Z", "pr_url": "https://github.com/apache/geode/pull/5466", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxMDM2Mw==", "url": "https://github.com/apache/geode/pull/5466#discussion_r474010363", "bodyText": "Can you change the test name to something more meaningful?, maybe offlineDiskStoreCommandShouldFailWhenDiskStoreFileDoesNotExist?.", "author": "jujoramos", "createdAt": "2020-08-20T14:06:38Z", "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsDUnitTest.java", "diffHunk": "@@ -519,6 +520,25 @@ public void offlineDiskStoreCommandShouldNotCreateFolderIfDiskStoreDoesNotExist(\n     assertThat(Files.exists(nonExistingDiskStorePath)).isFalse();\n   }\n \n+  @Test\n+  @Parameters({\"compact offline-disk-store\", \"describe offline-disk-store\",\n+      \"upgrade offline-disk-store\", \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void offlineDiskStoreCommandShouldNotPassIfDiskStoreFileDoesNotExist(", "originalCommit": "aaa9106caf3df2293c7d9622c652ac4923246ea3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxMTgzMA==", "url": "https://github.com/apache/geode/pull/5466#discussion_r474011830", "bodyText": "Can you change the test name to something more meaningful?, maybe offlineDiskStoreCommandsShouldSucceedWhenDiskStoreHasMultipleDirectories, or offlineDiskStoreCommandsSupportDiskStoresWithMultipleDirerctories?", "author": "jujoramos", "createdAt": "2020-08-20T14:08:50Z", "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/OfflineDiskStoreCommandsDUnitTest.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskInitFile;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+@RunWith(JUnitParamsRunner.class)\n+public class OfflineDiskStoreCommandsDUnitTest implements Serializable {\n+  private static final String REGION_NAME = \"testRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String WRONG_DISK_STORE_ID = \"wrongTestDisk\";\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public transient TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\n+  private Properties createLocatorConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore(File[] diskStoreDirectories) {\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setMaxOplogSize(1);\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(diskStoreDirectories);\n+\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion() {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(RegionShortcut.PARTITION_PERSISTENT)\n+        .setDiskStoreName(DISK_STORE_ID)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createServerWithRegionAndPersistentRegion(File[] diskStoreDirectories) {\n+    createDiskStore(diskStoreDirectories);\n+    createRegion();\n+    cacheRule.getCache().getRegion(REGION_NAME);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  @Test\n+  @Parameters({\"compact offline-disk-store\", \"describe offline-disk-store\",\n+      \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void testOfflineCommandsWithMultipleDirs(String baseCommand) throws IOException {", "originalCommit": "aaa9106caf3df2293c7d9622c652ac4923246ea3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNDU4MA==", "url": "https://github.com/apache/geode/pull/5466#discussion_r474014580", "bodyText": "Can you change the test name to something more meaningful?, maybe asyncFlusherThreadIsNotStartedForOfflineDiskStoreCommands, or offlineDiskStoreCommandsDoNotLeaveLingeringThreadsRunning?", "author": "jujoramos", "createdAt": "2020-08-20T14:12:42Z", "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/OfflineDiskStoreCommandsDUnitTest.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskInitFile;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+@RunWith(JUnitParamsRunner.class)\n+public class OfflineDiskStoreCommandsDUnitTest implements Serializable {\n+  private static final String REGION_NAME = \"testRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String WRONG_DISK_STORE_ID = \"wrongTestDisk\";\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public transient TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\n+  private Properties createLocatorConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore(File[] diskStoreDirectories) {\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setMaxOplogSize(1);\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(diskStoreDirectories);\n+\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion() {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(RegionShortcut.PARTITION_PERSISTENT)\n+        .setDiskStoreName(DISK_STORE_ID)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createServerWithRegionAndPersistentRegion(File[] diskStoreDirectories) {\n+    createDiskStore(diskStoreDirectories);\n+    createRegion();\n+    cacheRule.getCache().getRegion(REGION_NAME);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  @Test\n+  @Parameters({\"compact offline-disk-store\", \"describe offline-disk-store\",\n+      \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void testOfflineCommandsWithMultipleDirs(String baseCommand) throws IOException {\n+    VM locator = getVM(0);\n+    VM server = getVM(1);\n+    final int ENTRIES = 100000;\n+    int site1Port = getRandomAvailableTCPPortsForDUnitSite(1)[0];\n+\n+    File diskStoreDirectory1 = temporaryFolder.newFolder(\"diskDir1\");\n+    File diskStoreDirectory2 = temporaryFolder.newFolder(\"diskDir2\");\n+    File diskStoreDirectory3 = temporaryFolder.newFolder(\"diskDir3\");\n+    File[] diskStoreDirectories =\n+        new File[] {diskStoreDirectory1, diskStoreDirectory2, diskStoreDirectory3};\n+    String diskDirs = Arrays.stream(diskStoreDirectories).map(File::getAbsolutePath)\n+        .collect(Collectors.joining(\",\"));\n+\n+    locator.invoke(() -> cacheRule.createCache(createLocatorConfiguration(site1Port)));\n+    server.invoke(() -> cacheRule.createCache(createServerConfiguration(site1Port)));\n+    server.invoke(() -> {\n+      createServerWithRegionAndPersistentRegion(diskStoreDirectories);\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, ENTRIES).forEach(i -> region.put(\"Key_\" + i, \"Value_\" + i));\n+    });\n+    locator.invoke(this::gracefullyDisconnect);\n+    server.invoke(this::gracefullyDisconnect);\n+    gfsh.executeAndAssertThat(\n+        baseCommand + \" --name=\" + DISK_STORE_ID + \" --disk-dirs=\" + diskDirs)\n+        .statusIsSuccess();\n+  }\n+\n+  @Test\n+  @Parameters({\"describe offline-disk-store\",\n+      \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void testThreadHangWithOfflineDiskStoreCommands(String baseCommand) throws IOException {", "originalCommit": "aaa9106caf3df2293c7d9622c652ac4923246ea3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNTEyMw==", "url": "https://github.com/apache/geode/pull/5466#discussion_r474015123", "bodyText": "Can you change the test name to something more meaningful?, maybe offlineDiskStoreCommandShouldFailWhenDiskStoreFileDoesNotExist?.", "author": "jujoramos", "createdAt": "2020-08-20T14:13:27Z", "path": "geode-gfsh/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/OfflineDiskStoreCommandsDUnitTest.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management.internal.cli.commands;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskInitFile;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+\n+@RunWith(JUnitParamsRunner.class)\n+public class OfflineDiskStoreCommandsDUnitTest implements Serializable {\n+  private static final String REGION_NAME = \"testRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String WRONG_DISK_STORE_ID = \"wrongTestDisk\";\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public transient TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+\n+  private Properties createLocatorConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore(File[] diskStoreDirectories) {\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setMaxOplogSize(1);\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(diskStoreDirectories);\n+\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion() {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(RegionShortcut.PARTITION_PERSISTENT)\n+        .setDiskStoreName(DISK_STORE_ID)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createServerWithRegionAndPersistentRegion(File[] diskStoreDirectories) {\n+    createDiskStore(diskStoreDirectories);\n+    createRegion();\n+    cacheRule.getCache().getRegion(REGION_NAME);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  @Test\n+  @Parameters({\"compact offline-disk-store\", \"describe offline-disk-store\",\n+      \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void testOfflineCommandsWithMultipleDirs(String baseCommand) throws IOException {\n+    VM locator = getVM(0);\n+    VM server = getVM(1);\n+    final int ENTRIES = 100000;\n+    int site1Port = getRandomAvailableTCPPortsForDUnitSite(1)[0];\n+\n+    File diskStoreDirectory1 = temporaryFolder.newFolder(\"diskDir1\");\n+    File diskStoreDirectory2 = temporaryFolder.newFolder(\"diskDir2\");\n+    File diskStoreDirectory3 = temporaryFolder.newFolder(\"diskDir3\");\n+    File[] diskStoreDirectories =\n+        new File[] {diskStoreDirectory1, diskStoreDirectory2, diskStoreDirectory3};\n+    String diskDirs = Arrays.stream(diskStoreDirectories).map(File::getAbsolutePath)\n+        .collect(Collectors.joining(\",\"));\n+\n+    locator.invoke(() -> cacheRule.createCache(createLocatorConfiguration(site1Port)));\n+    server.invoke(() -> cacheRule.createCache(createServerConfiguration(site1Port)));\n+    server.invoke(() -> {\n+      createServerWithRegionAndPersistentRegion(diskStoreDirectories);\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, ENTRIES).forEach(i -> region.put(\"Key_\" + i, \"Value_\" + i));\n+    });\n+    locator.invoke(this::gracefullyDisconnect);\n+    server.invoke(this::gracefullyDisconnect);\n+    gfsh.executeAndAssertThat(\n+        baseCommand + \" --name=\" + DISK_STORE_ID + \" --disk-dirs=\" + diskDirs)\n+        .statusIsSuccess();\n+  }\n+\n+  @Test\n+  @Parameters({\"describe offline-disk-store\",\n+      \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void testThreadHangWithOfflineDiskStoreCommands(String baseCommand) throws IOException {\n+    VM locator = getVM(0);\n+    VM server = getVM(1);\n+    final int ENTRIES = 100000;\n+    int site1Port = getRandomAvailableTCPPortsForDUnitSite(1)[0];\n+    String threadName = \"Asynchronous disk writer for region\";\n+    int counter = 0;\n+\n+    File diskStoreDirectory1 = temporaryFolder.newFolder(\"diskDir1\");\n+\n+    File[] diskStoreDirectories =\n+        new File[] {diskStoreDirectory1};\n+    String diskDirs = Arrays.stream(diskStoreDirectories).map(File::getAbsolutePath)\n+        .collect(Collectors.joining(\",\"));\n+\n+    locator.invoke(() -> cacheRule.createCache(createLocatorConfiguration(site1Port)));\n+    server.invoke(() -> cacheRule.createCache(createServerConfiguration(site1Port)));\n+    server.invoke(() -> {\n+      createServerWithRegionAndPersistentRegion(diskStoreDirectories);\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+      IntStream.range(0, ENTRIES).forEach(i -> region.put(\"Key_\" + i, \"Value_\" + i));\n+    });\n+    locator.invoke(this::gracefullyDisconnect);\n+    server.invoke(this::gracefullyDisconnect);\n+\n+    gfsh.executeAndAssertThat(\n+        baseCommand + \" --name=\" + DISK_STORE_ID + \" --disk-dirs=\" + diskDirs)\n+        .statusIsSuccess();\n+\n+    File tempFile = temporaryFolder.newFile(\"dumpFile.txt\");\n+    BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile));\n+    ThreadMXBean bean = ManagementFactory.getThreadMXBean();\n+    ThreadInfo[] infos = bean.dumpAllThreads(true, true);\n+    for (ThreadInfo info : infos) {\n+      if (info.toString().contains(threadName))\n+        writer.append(info.toString());\n+    }\n+\n+    writer.close();\n+\n+    try (BufferedReader br = new BufferedReader(new FileReader(tempFile))) {\n+      String line;\n+      while ((line = br.readLine()) != null) {\n+        if (line.contains(threadName))\n+          counter++;\n+      }\n+    }\n+    assertThat(counter).isEqualTo(0);\n+  }\n+\n+  @Test\n+  @Parameters({\"compact offline-disk-store\", \"describe offline-disk-store\",\n+      \"validate offline-disk-store\",\n+      \"alter disk-store --region=testRegion --enable-statistics=true\"})\n+  public void testOfflineCommandsWithMultipleDirsAndWrongName(String baseCommand)", "originalCommit": "aaa9106caf3df2293c7d9622c652ac4923246ea3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNTg0MQ==", "url": "https://github.com/apache/geode/pull/5466#discussion_r474015841", "bodyText": "Can you remove throws IOException as it's not thrown from within the method body?.", "author": "jujoramos", "createdAt": "2020-08-20T14:14:31Z", "path": "geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreCommandIntegrationTest.java", "diffHunk": "@@ -55,4 +59,33 @@ public void removeOptionMustBeUsedAlone() {\n     gfsh.executeAndAssertThat(command, commandString).statusIsError()\n         .containsOutput(\"Cannot use the --remove=true parameter with any other parameters\");\n   }\n+\n+  @Test\n+  public void testDirValidation() throws IOException {", "originalCommit": "aaa9106caf3df2293c7d9622c652ac4923246ea3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNTkzNg==", "url": "https://github.com/apache/geode/pull/5466#discussion_r474015936", "bodyText": "Can you remove throws IOException as it's not thrown from within the method body?.", "author": "jujoramos", "createdAt": "2020-08-20T14:14:39Z", "path": "geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreCommandIntegrationTest.java", "diffHunk": "@@ -55,4 +59,33 @@ public void removeOptionMustBeUsedAlone() {\n     gfsh.executeAndAssertThat(command, commandString).statusIsError()\n         .containsOutput(\"Cannot use the --remove=true parameter with any other parameters\");\n   }\n+\n+  @Test\n+  public void testDirValidation() throws IOException {\n+    CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_DISK_STORE);\n+    csb.addOption(CliStrings.ALTER_DISK_STORE__DISKSTORENAME, \"diskStoreName\");\n+    csb.addOption(CliStrings.ALTER_DISK_STORE__REGIONNAME, \"regionName\");\n+    csb.addOption(CliStrings.ALTER_DISK_STORE__DISKDIRS, \"wrongDiskDir\");\n+    csb.addOption(CliStrings.ALTER_DISK_STORE__CONCURRENCY__LEVEL, \"5\");\n+    String commandString = csb.toString();\n+\n+    gfsh.executeAndAssertThat(command, commandString).statusIsError()\n+        .containsOutput(\"Could not find disk-dirs: \\\"wrongDiskDir\");\n+  }\n+\n+  @Test\n+  public void testNameValidation() throws IOException {", "originalCommit": "aaa9106caf3df2293c7d9622c652ac4923246ea3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNjc4Mw==", "url": "https://github.com/apache/geode/pull/5466#discussion_r474016783", "bodyText": "This variable is not used across the test, can you delete it?.", "author": "jujoramos", "createdAt": "2020-08-20T14:15:47Z", "path": "geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java", "diffHunk": "@@ -34,6 +38,7 @@\n   private static final String REGION_NAME = \"test-region\";\n   private static final String MEMBER_NAME = \"testServer\";\n   private static final String DISK_STORE_NAME = \"testDiskStore\";\n+  private static final String WRONG_DISK_STORE_NAME = \"wrongTestDiskStore\";", "originalCommit": "aaa9106caf3df2293c7d9622c652ac4923246ea3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNzYzNQ==", "url": "https://github.com/apache/geode/pull/5466#discussion_r474017635", "bodyText": "Can you remove throws Exception as it's not thrown from within the method body?. Since you're already modifying the file, also, it would be great if you can remove throws Exception from every single method in the class as none actually throws anything \ud83d\udc4d .", "author": "jujoramos", "createdAt": "2020-08-20T14:17:03Z", "path": "geode-gfsh/src/integrationTest/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java", "diffHunk": "@@ -98,4 +106,16 @@ public void commandSucceedsWithNameAndMember() throws Exception {\n     gfsh.executeAndAssertThat(cmd).statusIsSuccess()\n         .containsOutput(expectedData.toArray(new String[0]));\n   }\n+\n+  @Test\n+  public void testDirValidation() throws Exception {", "originalCommit": "aaa9106caf3df2293c7d9622c652ac4923246ea3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "08660e253641012d5eca4b6861f3c209ca584eca", "url": "https://github.com/apache/geode/commit/08660e253641012d5eca4b6861f3c209ca584eca", "message": "GEODE-8119: Threads hangs when offline disk store command is invoked", "committedDate": "2020-08-21T09:34:16Z", "type": "commit"}, {"oid": "86bf3ee30c705aa23a44ee8c77cdf487bd90d76f", "url": "https://github.com/apache/geode/commit/86bf3ee30c705aa23a44ee8c77cdf487bd90d76f", "message": "changes after comments", "committedDate": "2020-08-21T09:34:16Z", "type": "commit"}, {"oid": "86bf3ee30c705aa23a44ee8c77cdf487bd90d76f", "url": "https://github.com/apache/geode/commit/86bf3ee30c705aa23a44ee8c77cdf487bd90d76f", "message": "changes after comments", "committedDate": "2020-08-21T09:34:16Z", "type": "forcePushed"}]}