{"pr_number": 5637, "pr_title": "GEODE-8626: Omitting field-mapping tag of cache.xml when using Simple JDBC Connector", "pr_createdAt": "2020-10-17T14:54:26Z", "pr_url": "https://github.com/apache/geode/pull/5637", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcwNjUzOQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517706539", "bodyText": "Is this replacement of & necessary?", "author": "jchen21", "createdAt": "2020-11-05T00:14:20Z", "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+\n+import org.junit.Rule;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.internal.cache.InternalCache;\n+\n+public class CacheXmlJdbcMappingIntegrationTest extends JdbcMappingIntegrationTest {\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  @Override\n+  protected InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzAzMA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153030", "bodyText": "When expanding Java system properties like <jndi-binding ... connection-url=\"${TestDataSourceUrl}\"> in cache.xml and the connection string contains '?' such as jdbc:mysql://localhost:3306?user=root&useSSL=false, if the connection string is not escaped, an error will occur when connecting to the database.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcwNjUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxOTI4OQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520019289", "bodyText": "\ud83d\udc4d", "author": "jchen21", "createdAt": "2020-11-09T18:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcwNjUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517713217", "bodyText": "To create region, data store and mapping etc, I would recommend using GfshRule and execute gfsh commands, instead of calling the internal functions that implement the gfsh commands.", "author": "jchen21", "createdAt": "2020-11-05T00:36:40Z", "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/GfshJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import java.lang.reflect.Constructor;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.cache.configuration.JndiBindingsType;\n+import org.apache.geode.cache.configuration.RegionConfig;\n+import org.apache.geode.cache.execute.Function;\n+import org.apache.geode.cache.execute.ResultCollector;\n+import org.apache.geode.connectors.jdbc.internal.cli.CreateMappingFunction;\n+import org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunction;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.management.configuration.RegionType;\n+import org.apache.geode.management.internal.cli.commands.CreateJndiBindingCommand;\n+import org.apache.geode.management.internal.cli.functions.CreateJndiBindingFunction;\n+import org.apache.geode.management.internal.cli.functions.CreateRegionFunctionArgs;\n+import org.apache.geode.management.internal.cli.functions.RegionCreateFunction;\n+import org.apache.geode.management.internal.configuration.converters.RegionConverter;\n+import org.apache.geode.management.internal.functions.CliFunctionResult;\n+import org.apache.geode.management.internal.util.ManagementUtils;\n+\n+public class GfshJdbcMappingIntegrationTest extends JdbcMappingIntegrationTest {\n+\n+  @Override\n+  protected InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\").create();\n+    Set<DistributedMember> targetMembers = findMembers(cache, null, null);\n+\n+    CliFunctionResult createRegionFuncResult = executeCreateRegionFunction(targetMembers);", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzA5NQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153095", "bodyText": "I understand that it is recommended to use GfshRule.\nWith this change, I would like to achieve the same behavior in gfsh command and cache.xml.\nSo I have implimented JdbcMappingIntegrationTest class to standardize tests.\nI have used the internal functions because some parts of GfshRule can not verify in case of errors.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA4OTE5NA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520089194", "bodyText": "This is an integration test, which tests the behavior of gfsh commands from a user's point view. I don't think this test should use internal functions of specific gfsh command's implementation. The users should not worry about the gfsh implementation.\nAnd I don't recommend using a lot of System.out.println in the tests. Is that for debugging purpose?\nIf you have to use internal functions, I would recommend testing them in a unit test, or some other integration test or dunit that specifically test a specific gfsh command.  You said you use the internal functions because some parts of GfshRule can not verify in case of errors. Can you give a specific example?", "author": "jchen21", "createdAt": "2020-11-09T20:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzNzYwNQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520637605", "bodyText": "OK, I will try to implement the test using gfsh commands.", "author": "masaki-yamakawa", "createdAt": "2020-11-10T15:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg4NDc1MQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r523884751", "bodyText": "I tried to implement the test using GfshRule, but I couldn't do it because I use cache.getService(JdbcConnectorService.class) to get the implementation of JdbcConnectorService to verify FieldMapping, and GfshRule does not allow it.\nAnd I would like to make the condition setting part and the verification part of CacheXmlJdbcMappingIntegrationTest and GfshXmlJdbcMappingIntegrationTest common.\nSo I plan one of the following.\n\nChange the GfshJdbcMappingIntegrationTest to FunctionJdbcMappingIntegrationTest.\nRemove GfshJdbcMappingIntegrationTest. (I can use the describe jdbc-mapping command to verify it, but I don't think I should do that because it would reduce maintainability and make it difficult to commonize tests.)", "author": "masaki-yamakawa", "createdAt": "2020-11-16T03:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI3MzQxNA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r554273414", "bodyText": "If you want to use gfsh and verify the field mapping, CreateMappingCommandDUnitTest has some good examples which use GfshCommandRule (not GfshRule though). You can see if you would like add some more tests there. Typically, a DUnit is used for testing that involves gfsh commands. In the DUnit, you create a cluster with locator and server(s) and execute the gfsh commands.\nUsing the functions that implement a specific gfsh command in integration tests is discouraged. That is not what an integration test should do.", "author": "jchen21", "createdAt": "2021-01-09T01:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEzMzI0Nw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555133247", "bodyText": "I removed GfshJdbcMappingIntegrationTest because I no longer need to impliment it.", "author": "masaki-yamakawa", "createdAt": "2021-01-11T15:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTQwNw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517719407", "bodyText": "Why this class has to be public?", "author": "jchen21", "createdAt": "2020-11-05T00:57:21Z", "path": "geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java", "diffHunk": "@@ -1142,7 +1142,7 @@ public void createMappingWithExistingQueueFails() {\n             + \" must not already exist.\");\n   }\n \n-  private static class Employee implements PdxSerializable {\n+  public static class Employee implements PdxSerializable {", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzE4MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153180", "bodyText": "In the test, CreatemappingPreconditionCheckFunction is called and executed on several JVMs(Distributed members).\nIn this Function, PDX class such as Employee is instantiated, so I need to be able to access this class even if it runs on another JVM.\nIf it is in private scope, the following exceptions will be thrown\n[error 2020/11/07 12:08:19.411 JST <Function Execution Processor2> tid=69] Could not generate a PdxType for the class org.apache.geode.connectors.jdbc.internal.cli.CreateMappingCommandDUnitTest$IdAndName because it did not have a public zero arg constructor. Details: java.lang.IllegalAccessException: Class org.apache.geode.connectors.jdbc.internal.JdbcConnectorServiceImpl can not access a member of class org.apache.geode.connectors.jdbc.internal.cli.CreateMappingCommandDUnitTest$IdAndName with modifiers \"public\"\norg.apache.geode.connectors.jdbc.JdbcConnectorException: Could not generate a PdxType for the class org.apache.geode.connectors.jdbc.internal.cli.CreateMappingCommandDUnitTest$IdAndName because it did not have a public zero arg constructor. Details: java.lang.IllegalAccessException: Class org.apache.geode.connectors.jdbc.internal.JdbcConnectorServiceImpl can not access a member of class org.apache.geode.connectors.jdbc.internal.cli.CreateMappingCommandDUnitTest$IdAndName with modifiers \"public\"\n    at org.apache.geode.connectors.jdbc.internal.JdbcConnectorServiceImpl.createInstance(JdbcConnectorServiceImpl.java:361)\n    at org.apache.geode.connectors.jdbc.internal.JdbcConnectorServiceImpl.generatePdxTypeForClass(JdbcConnectorServiceImpl.java:334)\n    at org.apache.geode.connectors.jdbc.internal.JdbcConnectorServiceImpl.getPdxTypeForClass(JdbcConnectorServiceImpl.java:320)\n    at org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunction.executeFunction(CreateMappingPreconditionCheckFunction.java:74)\n    at org.apache.geode.management.cli.CliFunction.execute(CliFunction.java:37)\n    ...\n\nOther similar tests like CreateMapingCommandForProxyRegionDUnitTest are also public scope.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI3MDg5Mw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r554270893", "bodyText": "On the surface, it seems a trivial change from private to public, in order to fix the exception.  However, under the hood, it is doing unnecessary serialization and deserialization of the Employee class. Because getPdxTypeForClass(), generatePdxTypeForClass()  and createInstance() are moved from CreateMappingPreconditionCheckFunction to JdbcConnectorServiceImpl, which is probably because you want to use these methods in RegionMappingConfiguration.\nI would recommend keeping getPdxTypeForClass(), generatePdxTypeForClass()  and createInstance() in CreateMappingPreconditionCheckFunction. And in RegionMappingConfiguration, implement similar methods. Though it looks like duplicating the code, it does avoid unnecessary serialization and deserialization of user defined classes like Employee, which is more important.\nAnd I don't think adding more methods to JdbcConnectorService is necessary. e.g. createDefaultFieldMapping() is something you want to automatically achieve for the users, so it is not necessary be exposed as an API. Just put it as a private method in RegionMappingConfiguration should be good. The same reason applies for getTableMetaDataView() and getPdxTypeForClass.  Basically, keep JdbcConnectorService unchanged.", "author": "jchen21", "createdAt": "2021-01-09T01:32:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEzMjU2OQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555132569", "bodyText": "Thank you for your detailed explanation. I have reverted the CreateMappingPreconditionCheckFunction and JdbcConnectorService to the original source code. And I have implemented similar methods in RegionMappingConfiguration.", "author": "masaki-yamakawa", "createdAt": "2021-01-11T15:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTY1Mg==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517719652", "bodyText": "Why this class has to be public?", "author": "jchen21", "createdAt": "2020-11-05T00:58:09Z", "path": "geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java", "diffHunk": "@@ -1185,7 +1185,7 @@ public void fromData(PdxReader reader) {\n     }\n   }\n \n-  private static class EmployeeNumeric implements PdxSerializerObject {\n+  public static class EmployeeNumeric implements PdxSerializerObject {", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzI0OA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153248", "bodyText": "The reason is the same as previous one.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTY4Mw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517719683", "bodyText": "Why this class has to be public?", "author": "jchen21", "createdAt": "2020-11-05T00:58:16Z", "path": "geode-connectors/src/distributedTest/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingCommandDUnitTest.java", "diffHunk": "@@ -1234,7 +1234,7 @@ void setRefid(long refid) {\n     }\n   }\n \n-  private static class IdAndName implements PdxSerializable {\n+  public static class IdAndName implements PdxSerializable {", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzI1Ng==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153256", "bodyText": "The reason is the same as previous one.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTEzNQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517721135", "bodyText": "The data source has nothing to do with table metadata or region name. I recommend removing this line of error message.", "author": "jchen21", "createdAt": "2020-11-05T01:03:12Z", "path": "geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java", "diffHunk": "@@ -210,4 +224,152 @@ private TableMetaDataView getTableMetaDataView(RegionMapping regionMapping,\n               + regionMapping.getDataSourceName() + \"\\\": \", ex);\n     }\n   }\n+\n+  @Override\n+  public TableMetaDataView getTableMetaDataView(RegionMapping regionMapping) {\n+    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+          + \"\\\" found when getting table meta data \\\"\" + regionMapping.getRegionName() + \"\\\"\");", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzMxMg==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153312", "bodyText": "The data source is used to get the table metadata.\nI would like to confirm your suggestion.\nYour suggestion is the following, right?\nif (dataSource == null) {\n//  throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n//      + \"\\\" found when getting table meta data \\\"\" + regionMapping.getRegionName() + \"\\\"\");\n  throw new JdbcConnectorException();\n}", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyMzU4OA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520023588", "bodyText": "I was trying to say:\nif (dataSource == null) {\n      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName());\n}\n\nIf you would like to provide more information,\nif (dataSource == null) {\n      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n          + \"\\\" found when getting table meta data \\\"\" + regionMapping.getTableName() + \"\\\"\");\n}\n\nNote that it is regionMapping.getTableName(), not regionMapping.getRegionName().", "author": "jchen21", "createdAt": "2020-11-09T18:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzNzg3Ng==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520637876", "bodyText": "Thank you.\nI would like to fix it as you suggested.", "author": "masaki-yamakawa", "createdAt": "2020-11-10T15:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg4NDE0OA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r523884148", "bodyText": "I have fixed it.", "author": "masaki-yamakawa", "createdAt": "2020-11-16T03:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTIxMQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517721211", "bodyText": "The data source has nothing to do with table metadata or region name. I recommend removing this line of error message.", "author": "jchen21", "createdAt": "2020-11-05T01:03:28Z", "path": "geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceImpl.java", "diffHunk": "@@ -210,4 +224,152 @@ private TableMetaDataView getTableMetaDataView(RegionMapping regionMapping,\n               + regionMapping.getDataSourceName() + \"\\\": \", ex);\n     }\n   }\n+\n+  @Override\n+  public TableMetaDataView getTableMetaDataView(RegionMapping regionMapping) {\n+    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+          + \"\\\" found when getting table meta data \\\"\" + regionMapping.getRegionName() + \"\\\"\");\n+    }\n+    return getTableMetaDataView(regionMapping, dataSource);\n+  }\n+\n+  @Override\n+  public List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,\n+      PdxType pdxType) {\n+    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+          + \"\\\" found when creating mapping \\\"\" + regionMapping.getRegionName() + \"\\\"\");", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg4NDE5Mw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r523884193", "bodyText": "I have fixed it.", "author": "masaki-yamakawa", "createdAt": "2020-11-16T03:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyODAzNQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517728035", "bodyText": "Since its implementation is just one line, why not inline it?", "author": "jchen21", "createdAt": "2020-11-05T01:27:09Z", "path": "geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java", "diffHunk": "@@ -62,4 +77,17 @@ private void createRegionMapping(JdbcConnectorService service,\n       throw new InternalGemFireException(e);\n     }\n   }\n+\n+  private Class<?> loadPdxClass(String className) {\n+    try {\n+      return loadClass(className);", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzM1MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153350", "bodyText": "I have fixed this part.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyODAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDEwMTA5Ng==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520101096", "bodyText": "\ud83d\udc4d", "author": "jchen21", "createdAt": "2020-11-09T20:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyODAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMTc4Ng==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517731786", "bodyText": "Why this test is removed?", "author": "jchen21", "createdAt": "2020-11-05T01:39:59Z", "path": "geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java", "diffHunk": "@@ -172,16 +168,6 @@ public void executeFunctionThrowsIfDataSourceDoesNotExist() {\n             + DATA_SOURCE_NAME + \"'.\");\n   }\n \n-  @Test", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzM4MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153380", "bodyText": "I changed CreateMappingPreconditionCheckFunction class to use JdbcConnectorService.getTableMetaDataView(regionMapping).\nThis test covered by JdbcConnectorServiceTest.getTableMetaDataViewThrowsExceptionWhenGetConnectionHasSqlException.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMTc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzNjY3MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520036670", "bodyText": "\ud83d\udc4d", "author": "jchen21", "createdAt": "2020-11-09T18:45:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMTc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDI0MQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r517734241", "bodyText": "Some functions of CreateMappingPreconditionCheckFunction are moved to JdbcConnectorServiceImpl. So if you remove this test here, there should be similar test coverage added in JdbcConnectorServiceTest. In JdbcConnectorServiceTest there are some tests that test ReflectionBasedAutoSerializer. However, those tests don't verify FieldMapping like this test.", "author": "jchen21", "createdAt": "2020-11-05T01:48:12Z", "path": "geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/cli/CreateMappingPreconditionCheckFunctionTest.java", "diffHunk": "@@ -306,45 +292,10 @@ public void executeFunctionThrowsGivenPdxSerializableWithNoZeroArgConstructor()\n             \"Could not generate a PdxType for the class org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunctionTest$PdxClassDummyNoZeroArg because it did not have a public zero arg constructor. Details: java.lang.NoSuchMethodException: org.apache.geode.connectors.jdbc.internal.cli.CreateMappingPreconditionCheckFunctionTest$PdxClassDummyNoZeroArg.<init>()\");\n   }\n \n-  @Test", "originalCommit": "784f29f1ae07e98fb6cf39bd95718b8cc05cf726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MzQxNQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r519153415", "bodyText": "As you mentioned, I have moved some methods.\nIn addition, I have reduced the the particle size of the test.\nThe corresponding test for executionFuncationGivenNonPdxUsesReflectionBasedAutoSerializer is JdbcConnectorServiceTest.getPdxTypeForClassSucceedsWithGivenNonPdxUsesReflectionBasedAutoSerializer.\nThis test verify the PdxType. And then, the PdxType is specified to createDefaultFieldMapping to create the FieldMapping.\ncreateDefaultFieldMapping is tested with JdbcConnectorServiceTest.createDefaultFieldMappingXXX, which verify the FieldMapping at this level.", "author": "masaki-yamakawa", "createdAt": "2020-11-07T08:38:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA1NzQwNQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520057405", "bodyText": "I understand that. However, none of the JdbcConnectorServiceTest.createDefaultFieldMapping* uses ReflectionBasedAutoSerializer. Although those tests do verify the field mapping. I expect there is some test that uses ReflectionBasedAutoSerializer and verifies the field mapping as well, like the test deleted below.", "author": "jchen21", "createdAt": "2020-11-09T19:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzODQyNQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520638425", "bodyText": "I will add the test using the ReflectionBasedAutoSerializer and verify the field mapping.", "author": "masaki-yamakawa", "createdAt": "2020-11-10T15:12:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg4NDU3MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r523884570", "bodyText": "I have added mappingSuccessWhenFieldMappingsAreOmittedWithNonSerializedClass test method that uses ReflectionBasedAutoSerializer to JdbcMappingIntegrationTest", "author": "masaki-yamakawa", "createdAt": "2020-11-16T03:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNDI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzODczNg==", "url": "https://github.com/apache/geode/pull/5637#discussion_r520038736", "bodyText": "Minor pick. I would recommend some error message for the SQLException, e.g.\n String reason = \"connection failed\";\t\n    when(dataSource.getConnection()).thenThrow(new SQLException(reason));\n\nThe the error message in the next few lines would be Exception thrown while connecting to datasource \\\"dataSource\\\": connection failed, instead of Exception thrown while connecting to datasource \\\"dataSource\\\": null", "author": "jchen21", "createdAt": "2020-11-09T18:49:18Z", "path": "geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/internal/JdbcConnectorServiceTest.java", "diffHunk": "@@ -216,4 +249,213 @@ public void validateMappingSucceedsWithCompositeKeys() {\n     when(mapping.getIds()).thenReturn(KEY_COLUMN_NAME + \",\" + COMPOSITE_KEY_COLUMN_NAME);\n     service.validateMapping(mapping);\n   }\n+\n+  @Test\n+  public void getTableMetaDataViewSucceeds() {\n+    TableMetaDataView result = service.getTableMetaDataView(mapping);\n+    assertThat(result).isEqualTo(view);\n+    verify(manager).getTableMetaDataView(connection, mapping);\n+  }\n+\n+  @Test\n+  public void getTableMetaDataViewThrowsExceptionWhenDataSourceDoesNotExist() {\n+    doReturn(null).when(service).getDataSource(DATA_SOURCE_NAME);\n+    Throwable throwable = catchThrowable(() -> service.getTableMetaDataView(mapping));\n+    assertThat(throwable).isInstanceOf(JdbcConnectorException.class).hasMessageContaining(\n+        String.format(\"No datasource \\\"%s\\\" found when getting table meta data \\\"%s\\\"\",\n+            mapping.getDataSourceName(), mapping.getRegionName()));\n+  }\n+\n+  @Test\n+  public void getTableMetaDataViewThrowsExceptionWhenGetConnectionHasSqlException()\n+      throws SQLException {\n+    when(dataSource.getConnection()).thenThrow(SQLException.class);", "originalCommit": "7fc1417ec80c177e4cb46add831dfdfc4c99224f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzg5MDM2MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r523890360", "bodyText": "Thank you for your recommendation. I have fixed it.", "author": "masaki-yamakawa", "createdAt": "2020-11-16T04:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzODczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxODYzOQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555418639", "bodyText": "This is a bug. I believe the string in the quote should be WrongPdxName instead of NoPdxName. There is no such file CacheXmlJdbcMappingIntegrationTest.NoPdxName.cache.xml. So the actual error is something like FileNotFoundException returned by getXmlFileForTest(). And the assertion at line 241 and 242 doesn't really catch the bug.", "author": "jchen21", "createdAt": "2021-01-12T00:09:04Z", "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.JDBCType;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.connectors.jdbc.internal.JdbcConnectorService;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.DatabaseConnectionRule;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.MySqlConnectionRule;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.jndi.JNDIInvoker;\n+import org.apache.geode.pdx.FieldType;\n+import org.apache.geode.pdx.internal.AutoSerializableManager;\n+\n+public class CacheXmlJdbcMappingIntegrationTest {\n+\n+  private static final URL COMPOSE_RESOURCE_PATH =\n+      CacheXmlJdbcMappingIntegrationTest.class.getResource(\"mysql.yml\");\n+  protected static final String DATA_SOURCE_NAME = \"TestDataSource\";\n+  protected static final String DB_NAME = \"test\";\n+  protected static final String REGION_TABLE_NAME = \"employees\";\n+  protected static final String REGION_NAME = \"Region1\";\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  private Connection connection;\n+  private Statement statement;\n+  private InternalCache cache;\n+\n+  @ClassRule\n+  public static DatabaseConnectionRule dbRule = new MySqlConnectionRule.Builder()\n+      .file(COMPOSE_RESOURCE_PATH.getPath()).serviceName(\"db\").port(3306).database(DB_NAME).build();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(AutoSerializableManager.NO_HARDCODED_EXCLUDES_PARAM, \"true\");\n+    connection = dbRule.getConnection();\n+    statement = connection.createStatement();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    JNDIInvoker.unMapDatasource(DATA_SOURCE_NAME);\n+\n+    if (cache != null) {\n+      cache.close();\n+    }\n+\n+    if (statement == null) {\n+      statement = connection.createStatement();\n+    }\n+    statement.execute(\"Drop table IF EXISTS \" + REGION_TABLE_NAME);\n+    statement.close();\n+\n+    if (connection != null) {\n+      connection.close();\n+    }\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n+    System.setProperty(\"TestDataSourceUrl\", url);\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithNonSerializedClass(\n+      String cacheXmlTestName) throws Exception {\n+    return createCacheAndCreateJdbcMapping(cacheXmlTestName);\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithWrongDataSource(\n+      String cacheXmlTestName) throws Exception {\n+    System.setProperty(\"TestDataSourceUrl\", \"jdbc:mysql://localhost/test\");\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithWrongPdxName(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n+    System.setProperty(\"TestDataSourceUrl\", url);\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private String getXmlFileForTest(String testName) {\n+    return createTempFileFromResource(getClass(),\n+        getClassSimpleName() + \".\" + testName + \".cache.xml\").getAbsolutePath();\n+  }\n+\n+  private String getClassSimpleName() {\n+    return getClass().getSimpleName();\n+  }\n+\n+  private void createEmployeeTable() throws Exception {\n+    statement.execute(\"Create Table \" + REGION_TABLE_NAME\n+        + \" (id varchar(10) primary key not null, name varchar(10), age int)\");\n+  }\n+\n+  private void createEmployeeTableWithColumnNamesWithUnderscores() throws Exception {\n+    statement.execute(\"Create Table \" + REGION_TABLE_NAME\n+        + \" (id varchar(10) primary key not null, _name varchar(10), _age int)\");\n+  }\n+\n+  private List<FieldMapping> getEmployeeTableFieldMappings() {\n+    List<FieldMapping> fieldMappings = Arrays.asList(\n+        new FieldMapping(\"id\", FieldType.STRING.name(), \"id\", JDBCType.VARCHAR.name(), false),\n+        new FieldMapping(\"name\", FieldType.STRING.name(), \"name\", JDBCType.VARCHAR.name(), true),\n+        new FieldMapping(\"age\", FieldType.INT.name(), \"age\", JDBCType.INTEGER.name(), true));\n+    return fieldMappings;\n+  }\n+\n+  private List<FieldMapping> getEmployeeTableColumnNameWithUnderscoresFieldMappings() {\n+    List<FieldMapping> fieldMappings = Arrays.asList(\n+        new FieldMapping(\"id\", FieldType.STRING.name(), \"id\", JDBCType.VARCHAR.name(), false),\n+        new FieldMapping(\"name\", FieldType.STRING.name(), \"_name\", JDBCType.VARCHAR.name(), true),\n+        new FieldMapping(\"age\", FieldType.INT.name(), \"_age\", JDBCType.INTEGER.name(), true));\n+    return fieldMappings;\n+  }\n+\n+  @Test\n+  public void mappingSuccessWhenFieldMappingsAreExists() throws Exception {\n+    createEmployeeTable();\n+\n+    cache = createCacheAndCreateJdbcMapping(\"FieldMappings\");\n+    JdbcConnectorService service = cache.getService(JdbcConnectorService.class);\n+\n+    RegionMapping mapping = service.getMappingForRegion(REGION_NAME);\n+    assertThat(mapping.getDataSourceName()).isEqualTo(DATA_SOURCE_NAME);\n+    assertThat(mapping.getTableName()).isEqualTo(REGION_TABLE_NAME);\n+    assertThat(mapping.getRegionName()).isEqualTo(REGION_NAME);\n+    assertThat(mapping.getPdxName()).isEqualTo(Employee.class.getName());\n+    assertThat(mapping.getIds()).isEqualTo(\"id\");\n+    assertThat(mapping.getFieldMappings().size()).isEqualTo(3);\n+    assertThat(mapping.getFieldMappings()).containsAll(getEmployeeTableFieldMappings());\n+  }\n+\n+  @Test\n+  public void mappingSuccessWhenFieldMappingsAreOmitted() throws Exception {\n+    createEmployeeTable();\n+\n+    cache = createCacheAndCreateJdbcMapping(\"NoFieldMappings\");\n+    JdbcConnectorService service = cache.getService(JdbcConnectorService.class);\n+\n+    RegionMapping mapping = service.getMappingForRegion(REGION_NAME);\n+    assertThat(mapping.getDataSourceName()).isEqualTo(DATA_SOURCE_NAME);\n+    assertThat(mapping.getTableName()).isEqualTo(REGION_TABLE_NAME);\n+    assertThat(mapping.getRegionName()).isEqualTo(REGION_NAME);\n+    assertThat(mapping.getPdxName()).isEqualTo(Employee.class.getName());\n+    assertThat(mapping.getIds()).isEqualTo(\"id\");\n+    assertThat(mapping.getFieldMappings().size()).isEqualTo(3);\n+    assertThat(mapping.getFieldMappings()).containsAll(getEmployeeTableFieldMappings());\n+  }\n+\n+  @Test\n+  public void mappingSuccessWhenFieldMappingsAreOmittedWithNonSerializedClass() throws Exception {\n+    createEmployeeTable();\n+\n+    cache = createCacheAndCreateJdbcMappingWithNonSerializedClass(\n+        \"NoFieldMappingsWithNonSerializedClass\");\n+    JdbcConnectorService service = cache.getService(JdbcConnectorService.class);\n+\n+    RegionMapping mapping = service.getMappingForRegion(REGION_NAME);\n+    assertThat(mapping.getDataSourceName()).isEqualTo(DATA_SOURCE_NAME);\n+    assertThat(mapping.getTableName()).isEqualTo(REGION_TABLE_NAME);\n+    assertThat(mapping.getRegionName()).isEqualTo(REGION_NAME);\n+    assertThat(mapping.getPdxName()).isEqualTo(NonSerializedEmployee.class.getName());\n+    assertThat(mapping.getIds()).isEqualTo(\"id\");\n+    assertThat(mapping.getFieldMappings().size()).isEqualTo(3);\n+    assertThat(mapping.getFieldMappings()).containsAll(getEmployeeTableFieldMappings());\n+  }\n+\n+  @Test\n+  public void mappingFailureWhenConnectWrongDataSource() {\n+    Throwable throwable =\n+        catchThrowable(() -> createCacheAndCreateJdbcMappingWithWrongDataSource(\"NoFieldMappings\"));\n+\n+    assertThat(throwable).isInstanceOf(JdbcConnectorException.class)\n+        .hasMessage(String.format(\"No datasource \\\"%s\\\" found when creating default field mapping\",\n+            DATA_SOURCE_NAME));\n+  }\n+\n+  @Test\n+  public void mappingFailureWhenTableNotExists() {\n+    Throwable throwable = catchThrowable(() -> createCacheAndCreateJdbcMapping(\"NoFieldMappings\"));\n+\n+    assertThat(throwable).isInstanceOf(JdbcConnectorException.class)\n+        .hasMessage(String.format(\"No table was found that matches \\\"%s\\\"\", REGION_TABLE_NAME));\n+  }\n+\n+  @Test\n+  public void mappingFailureWhenPdxNotExists() throws Exception {\n+    createEmployeeTable();\n+\n+    Throwable throwable =\n+        catchThrowable(() -> createCacheAndCreateJdbcMappingWithWrongPdxName(\"NoPdxName\"));", "originalCommit": "135a7797f557bbde0e89a954a79275639f5021f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQzNTk3Ng==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555435976", "bodyText": "This is method implementation is exactly the same as createCacheAndCreateJdbcMapping(). The only difference is the method name. So how about just using createCacheAndCreateJdbcMapping()?", "author": "jchen21", "createdAt": "2021-01-12T00:50:24Z", "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.JDBCType;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.connectors.jdbc.internal.JdbcConnectorService;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.DatabaseConnectionRule;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.MySqlConnectionRule;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.jndi.JNDIInvoker;\n+import org.apache.geode.pdx.FieldType;\n+import org.apache.geode.pdx.internal.AutoSerializableManager;\n+\n+public class CacheXmlJdbcMappingIntegrationTest {\n+\n+  private static final URL COMPOSE_RESOURCE_PATH =\n+      CacheXmlJdbcMappingIntegrationTest.class.getResource(\"mysql.yml\");\n+  protected static final String DATA_SOURCE_NAME = \"TestDataSource\";\n+  protected static final String DB_NAME = \"test\";\n+  protected static final String REGION_TABLE_NAME = \"employees\";\n+  protected static final String REGION_NAME = \"Region1\";\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  private Connection connection;\n+  private Statement statement;\n+  private InternalCache cache;\n+\n+  @ClassRule\n+  public static DatabaseConnectionRule dbRule = new MySqlConnectionRule.Builder()\n+      .file(COMPOSE_RESOURCE_PATH.getPath()).serviceName(\"db\").port(3306).database(DB_NAME).build();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(AutoSerializableManager.NO_HARDCODED_EXCLUDES_PARAM, \"true\");\n+    connection = dbRule.getConnection();\n+    statement = connection.createStatement();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    JNDIInvoker.unMapDatasource(DATA_SOURCE_NAME);\n+\n+    if (cache != null) {\n+      cache.close();\n+    }\n+\n+    if (statement == null) {\n+      statement = connection.createStatement();\n+    }\n+    statement.execute(\"Drop table IF EXISTS \" + REGION_TABLE_NAME);\n+    statement.close();\n+\n+    if (connection != null) {\n+      connection.close();\n+    }\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n+    System.setProperty(\"TestDataSourceUrl\", url);\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithNonSerializedClass(\n+      String cacheXmlTestName) throws Exception {\n+    return createCacheAndCreateJdbcMapping(cacheXmlTestName);\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithWrongDataSource(\n+      String cacheXmlTestName) throws Exception {\n+    System.setProperty(\"TestDataSourceUrl\", \"jdbc:mysql://localhost/test\");\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithWrongPdxName(String cacheXmlTestName)", "originalCommit": "135a7797f557bbde0e89a954a79275639f5021f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQzNjQwMw==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555436403", "bodyText": "This throws Exception can be removed. The same for line 93, 109 and 119.", "author": "jchen21", "createdAt": "2021-01-12T00:52:02Z", "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.JDBCType;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.connectors.jdbc.internal.JdbcConnectorService;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.DatabaseConnectionRule;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.MySqlConnectionRule;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.jndi.JNDIInvoker;\n+import org.apache.geode.pdx.FieldType;\n+import org.apache.geode.pdx.internal.AutoSerializableManager;\n+\n+public class CacheXmlJdbcMappingIntegrationTest {\n+\n+  private static final URL COMPOSE_RESOURCE_PATH =\n+      CacheXmlJdbcMappingIntegrationTest.class.getResource(\"mysql.yml\");\n+  protected static final String DATA_SOURCE_NAME = \"TestDataSource\";\n+  protected static final String DB_NAME = \"test\";\n+  protected static final String REGION_TABLE_NAME = \"employees\";\n+  protected static final String REGION_NAME = \"Region1\";\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  private Connection connection;\n+  private Statement statement;\n+  private InternalCache cache;\n+\n+  @ClassRule\n+  public static DatabaseConnectionRule dbRule = new MySqlConnectionRule.Builder()\n+      .file(COMPOSE_RESOURCE_PATH.getPath()).serviceName(\"db\").port(3306).database(DB_NAME).build();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(AutoSerializableManager.NO_HARDCODED_EXCLUDES_PARAM, \"true\");\n+    connection = dbRule.getConnection();\n+    statement = connection.createStatement();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    JNDIInvoker.unMapDatasource(DATA_SOURCE_NAME);\n+\n+    if (cache != null) {\n+      cache.close();\n+    }\n+\n+    if (statement == null) {\n+      statement = connection.createStatement();\n+    }\n+    statement.execute(\"Drop table IF EXISTS \" + REGION_TABLE_NAME);\n+    statement.close();\n+\n+    if (connection != null) {\n+      connection.close();\n+    }\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {", "originalCommit": "135a7797f557bbde0e89a954a79275639f5021f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQzNjY3NQ==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555436675", "bodyText": "I would recommend inline this one-line implementation for readability of code.", "author": "jchen21", "createdAt": "2021-01-12T00:52:54Z", "path": "geode-connectors/src/acceptanceTest/java/org/apache/geode/connectors/jdbc/CacheXmlJdbcMappingIntegrationTest.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.connectors.jdbc;\n+\n+import static org.apache.geode.test.util.ResourceUtils.createTempFileFromResource;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.JDBCType;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+\n+import org.apache.geode.cache.CacheFactory;\n+import org.apache.geode.connectors.jdbc.internal.JdbcConnectorService;\n+import org.apache.geode.connectors.jdbc.internal.configuration.FieldMapping;\n+import org.apache.geode.connectors.jdbc.internal.configuration.RegionMapping;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.DatabaseConnectionRule;\n+import org.apache.geode.connectors.jdbc.test.junit.rules.MySqlConnectionRule;\n+import org.apache.geode.internal.cache.InternalCache;\n+import org.apache.geode.internal.jndi.JNDIInvoker;\n+import org.apache.geode.pdx.FieldType;\n+import org.apache.geode.pdx.internal.AutoSerializableManager;\n+\n+public class CacheXmlJdbcMappingIntegrationTest {\n+\n+  private static final URL COMPOSE_RESOURCE_PATH =\n+      CacheXmlJdbcMappingIntegrationTest.class.getResource(\"mysql.yml\");\n+  protected static final String DATA_SOURCE_NAME = \"TestDataSource\";\n+  protected static final String DB_NAME = \"test\";\n+  protected static final String REGION_TABLE_NAME = \"employees\";\n+  protected static final String REGION_NAME = \"Region1\";\n+\n+  @Rule\n+  public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();\n+\n+  private Connection connection;\n+  private Statement statement;\n+  private InternalCache cache;\n+\n+  @ClassRule\n+  public static DatabaseConnectionRule dbRule = new MySqlConnectionRule.Builder()\n+      .file(COMPOSE_RESOURCE_PATH.getPath()).serviceName(\"db\").port(3306).database(DB_NAME).build();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    System.setProperty(AutoSerializableManager.NO_HARDCODED_EXCLUDES_PARAM, \"true\");\n+    connection = dbRule.getConnection();\n+    statement = connection.createStatement();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    JNDIInvoker.unMapDatasource(DATA_SOURCE_NAME);\n+\n+    if (cache != null) {\n+      cache.close();\n+    }\n+\n+    if (statement == null) {\n+      statement = connection.createStatement();\n+    }\n+    statement.execute(\"Drop table IF EXISTS \" + REGION_TABLE_NAME);\n+    statement.close();\n+\n+    if (connection != null) {\n+      connection.close();\n+    }\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMapping(String cacheXmlTestName)\n+      throws Exception {\n+    String url = dbRule.getConnectionUrl().replaceAll(\"&\", \"&amp;\");\n+    System.setProperty(\"TestDataSourceUrl\", url);\n+    InternalCache cache =\n+        (InternalCache) new CacheFactory().set(\"locators\", \"\").set(\"mcast-port\", \"0\")\n+            .set(\"cache-xml-file\", getXmlFileForTest(cacheXmlTestName))\n+            .create();\n+    return cache;\n+  }\n+\n+  private InternalCache createCacheAndCreateJdbcMappingWithNonSerializedClass(\n+      String cacheXmlTestName) throws Exception {\n+    return createCacheAndCreateJdbcMapping(cacheXmlTestName);", "originalCommit": "135a7797f557bbde0e89a954a79275639f5021f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ0MTc5MA==", "url": "https://github.com/apache/geode/pull/5637#discussion_r555441790", "bodyText": "The regionMapping argument is not used, and can be removed.", "author": "jchen21", "createdAt": "2021-01-12T01:09:37Z", "path": "geode-connectors/src/main/java/org/apache/geode/connectors/jdbc/internal/xml/RegionMappingConfiguration.java", "diffHunk": "@@ -62,4 +96,159 @@ private void createRegionMapping(JdbcConnectorService service,\n       throw new InternalGemFireException(e);\n     }\n   }\n+\n+  protected List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,\n+      PdxType pdxType) {\n+    DataSource dataSource = getDataSource(regionMapping.getDataSourceName());\n+    if (dataSource == null) {\n+      throw new JdbcConnectorException(\"No datasource \\\"\" + regionMapping.getDataSourceName()\n+          + \"\\\" found when creating default field mapping\");\n+    }\n+    TableMetaDataManager manager = getTableMetaDataManager();\n+    try (Connection connection = dataSource.getConnection()) {\n+      TableMetaDataView tableMetaData = manager.getTableMetaDataView(connection, regionMapping);\n+      return createDefaultFieldMapping(regionMapping, pdxType, tableMetaData);\n+    } catch (SQLException e) {\n+      throw JdbcConnectorException.createException(e);\n+    }\n+  }\n+\n+  private List<FieldMapping> createDefaultFieldMapping(RegionMapping regionMapping,", "originalCommit": "135a7797f557bbde0e89a954a79275639f5021f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "url": "https://github.com/apache/geode/commit/5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "message": "GEODE-8626: Omitting field-mapping tag of cache.xml when using Simple JDBC Connector\n\nUse the default mapping when using the Simple JDBC Connector in cache.xml and without the field-mapping tag", "committedDate": "2021-01-14T22:31:08Z", "type": "commit"}, {"oid": "5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "url": "https://github.com/apache/geode/commit/5f4aa56eb6eb1a0090fc0122b39dbbc8fae532b4", "message": "GEODE-8626: Omitting field-mapping tag of cache.xml when using Simple JDBC Connector\n\nUse the default mapping when using the Simple JDBC Connector in cache.xml and without the field-mapping tag", "committedDate": "2021-01-14T22:31:08Z", "type": "forcePushed"}, {"oid": "fd326746ef0778a781af03d103bfba662bae2ea8", "url": "https://github.com/apache/geode/commit/fd326746ef0778a781af03d103bfba662bae2ea8", "message": "Merge branch 'develop' into feature/GEODE-8626", "committedDate": "2021-06-12T11:34:00Z", "type": "commit"}, {"oid": "e29918ce27e172859148f24f59f59e59e0b18f91", "url": "https://github.com/apache/geode/commit/e29918ce27e172859148f24f59f59e59e0b18f91", "message": "Move some methods of CreateMappingPreconditionCheckFunction class to JdbcConnectorServiceImpl class", "committedDate": "2021-06-13T08:05:10Z", "type": "commit"}]}