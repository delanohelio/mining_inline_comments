{"pr_number": 5728, "pr_title": "GEODE-8696: Fix synchronization in FederatingManager", "pr_createdAt": "2020-11-10T23:58:23Z", "pr_url": "https://github.com/apache/geode/pull/5728", "timeline": [{"oid": "38d5fd0d070373b7343cf3df9909374a0dadc89a", "url": "https://github.com/apache/geode/commit/38d5fd0d070373b7343cf3df9909374a0dadc89a", "message": "Rename log4j2.xml", "committedDate": "2020-11-20T23:00:21Z", "type": "forcePushed"}, {"oid": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4", "url": "https://github.com/apache/geode/commit/84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4", "message": "GEODE-8696: Fix synchronization in FederatingManager\n\nPrevent hang while protecting against removal of member artifacts\nduring startup of manager.", "committedDate": "2020-11-30T20:12:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUyMjcwMQ==", "url": "https://github.com/apache/geode/pull/5728#discussion_r535522701", "bodyText": "Can the result of expectedServerMXBeans(\u2026) change each time through the loop? If not, is it worth it to call it before the loop, rather than inside?\nSimilar for other inside-the-loop calls to get lists of expected beans.", "author": "demery-pivotal", "createdAt": "2020-12-03T19:30:09Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/management/JMXMBeanLocatorRestartTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management;\n+\n+import static java.lang.management.ManagementFactory.getPlatformMBeanServer;\n+import static java.util.Arrays.asList;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static javax.management.ObjectName.getInstance;\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_START;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.MEMBER_TIMEOUT;\n+import static org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper.crashDistributedSystem;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPorts;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.getTimeout;\n+import static org.apache.geode.test.dunit.Disconnect.disconnectAllFromDS;\n+import static org.apache.geode.test.dunit.IgnoredException.addIgnoredException;\n+import static org.apache.geode.test.dunit.Invoke.invokeInEveryVM;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.apache.geode.test.dunit.VM.getVMId;\n+import static org.apache.geode.util.internal.GeodeGlossary.GEMFIRE_PREFIX;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelException;\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.alerting.internal.spi.AlertingIOException;\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.LocatorLauncher;\n+import org.apache.geode.distributed.ServerLauncher;\n+import org.apache.geode.distributed.internal.InternalLocator;\n+import org.apache.geode.distributed.internal.membership.api.MemberDisconnectedException;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedErrorCollector;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+\n+public class JMXMBeanLocatorRestartTest implements Serializable {\n+\n+  private static final long TIMEOUT_MILLIS = getTimeout().toMillis();\n+  private static final LocatorLauncher DUMMY_LOCATOR = mock(LocatorLauncher.class);\n+  private static final ServerLauncher DUMMY_SERVER = mock(ServerLauncher.class);\n+\n+  private static final AtomicReference<CountDownLatch> BEFORE =\n+      new AtomicReference<>(new CountDownLatch(0));\n+  private static final AtomicReference<CountDownLatch> AFTER =\n+      new AtomicReference<>(new CountDownLatch(0));\n+\n+  private static final AtomicReference<LocatorLauncher> LOCATOR =\n+      new AtomicReference<>(DUMMY_LOCATOR);\n+  private static final AtomicReference<ServerLauncher> SERVER =\n+      new AtomicReference<>(DUMMY_SERVER);\n+\n+  private VM locatorVM;\n+  private VM serverVM;\n+\n+  private String locatorName;\n+  private String serverName;\n+  private String locators;\n+  private int locatorPort;\n+  private int locatorJmxPort;\n+  private String regionName;\n+  private Set<ObjectName> mxbeansOnServer;\n+  private Set<ObjectName> mxbeansOnLocator;\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+  @Rule\n+  public SerializableTemporaryFolder temporaryFolder = new SerializableTemporaryFolder();\n+  @Rule\n+  public DistributedErrorCollector errorCollector = new DistributedErrorCollector();\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreProps = new DistributedRestoreSystemProperties();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    locatorVM = getVM(1);\n+    serverVM = getVM(0);\n+\n+    for (VM vm : asList(locatorVM, serverVM)) {\n+      vm.invoke(() -> System.setProperty(GEMFIRE_PREFIX + \"standard-output-always-on\", \"true\"));\n+    }\n+\n+    locatorName = \"locator1\";\n+    serverName = \"server1\";\n+    File locator1Dir = temporaryFolder.newFolder(locatorName);\n+    File serverDir = temporaryFolder.newFolder(serverName);\n+\n+    int[] port = getRandomAvailableTCPPorts(4);\n+    locatorPort = port[0];\n+    locatorJmxPort = port[2];\n+    locators = \"localhost[\" + locatorPort + \"]\";\n+\n+    locatorVM.invoke(() -> {\n+      startLocator(locatorName, locator1Dir, locatorPort, locatorJmxPort, locators);\n+    });\n+\n+    serverVM.invoke(() -> startServer(serverName, serverDir, locators));\n+\n+    gfsh.connectAndVerify(locatorJmxPort, GfshCommandRule.PortType.jmxManager);\n+\n+    regionName = \"region1\";\n+    String createRegionCommand = \"create region --type=REPLICATE --name=\" + SEPARATOR + regionName;\n+    gfsh.executeAndAssertThat(createRegionCommand).statusIsSuccess();\n+\n+    addIgnoredException(AlertingIOException.class);\n+    addIgnoredException(CacheClosedException.class);\n+    addIgnoredException(CancelException.class);\n+    addIgnoredException(DistributedSystemDisconnectedException.class);\n+    addIgnoredException(ForcedDisconnectException.class);\n+    addIgnoredException(MemberDisconnectedException.class);\n+    addIgnoredException(\"Possible loss of quorum\");\n+\n+    mxbeansOnServer = serverVM.invoke(() -> {\n+      await().untilAsserted(() -> {\n+        assertThat(getPlatformMBeanServer().queryNames(getInstance(\"GemFire:*\"), null))\n+            .as(\"GemFire mbeans on server1\")\n+            .containsAll(expectedServerMXBeans(serverName, regionName));", "originalCommit": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzMDQyMg==", "url": "https://github.com/apache/geode/pull/5728#discussion_r535530422", "bodyText": "Yeah I should probably change those to be invoked outside the await loop. They end up creating new instances of ObjectName every time they're called.", "author": "kirklund", "createdAt": "2020-12-03T19:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUyMjcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY5MDkzMg==", "url": "https://github.com/apache/geode/pull/5728#discussion_r535690932", "bodyText": "I just remembered why I have it like this: for easier reading. I'm converting them all to variables and one field, but it's not as readable.", "author": "kirklund", "createdAt": "2020-12-03T22:30:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUyMjcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY5MzQ0NA==", "url": "https://github.com/apache/geode/pull/5728#discussion_r535693444", "bodyText": "Yeah, that's part of why I was wondering whether my suggestion was worth the effort.", "author": "demery-pivotal", "createdAt": "2020-12-03T22:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUyMjcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI5NTUwOA==", "url": "https://github.com/apache/geode/pull/5728#discussion_r536295508", "bodyText": "I think I found a good way to improve readability along with making things more efficient. Please take a look at both JmxLocatorReconnectDistributedTest (my new test) and JmxServerReconnectDistributedTest (overhauled for consistency). Thanks!", "author": "kirklund", "createdAt": "2020-12-04T18:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUyMjcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzMjUxMw==", "url": "https://github.com/apache/geode/pull/5728#discussion_r536332513", "bodyText": "Oops, I forgot to push earlier. The updated distributed tests are pushed now.", "author": "kirklund", "createdAt": "2020-12-04T19:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUyMjcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzNDg2NA==", "url": "https://github.com/apache/geode/pull/5728#discussion_r535534864", "bodyText": "Does this need to be a spy? I don't see any uses of the spyness (spyity?) in this test.", "author": "demery-pivotal", "createdAt": "2020-12-03T19:44:06Z", "path": "geode-core/src/test/java/org/apache/geode/management/internal/FederatingManagerTest.java", "diffHunk": "@@ -437,14 +474,79 @@ public void removeMemberArtifactsDoesNotRemoveAllProxiesIfMonitoringRegionIsNull\n         .thenReturn(mock(Region.class));\n     when(system.getDistributedMember())\n         .thenReturn(member);\n-    FederatingManager federatingManager = new FederatingManager(repo, system, service, cache,\n-        statisticsFactory, statisticsClock, proxyFactory, messenger, executorService);\n+    FederatingManager federatingManager =\n+        new FederatingManager(repo, system, service, cache, statisticsFactory,\n+            statisticsClock, proxyFactory, messenger, cancelCriterion, executorService);\n \n     federatingManager.removeMemberArtifacts(member, false);\n \n     verifyNoMoreInteractions(proxyFactory);\n   }\n \n+  @Test\n+  public void removeMemberWaitsForStartManager() throws Exception {\n+    CountDownLatch latch = new CountDownLatch(1);\n+    CyclicBarrier barrier = new CyclicBarrier(2);\n+    ExecutorService executorService = mock(ExecutorService.class);\n+    List<Future<InternalDistributedMember>> futureTaskList = Collections.emptyList();\n+\n+    when(executorService.invokeAll(any())).thenAnswer(invocation -> {\n+      awaitCyclicBarrier(barrier);\n+      awaitCountDownLatch(latch);\n+      return futureTaskList;\n+    });\n+\n+    FederatingManager federatingManager =\n+        spy(new FederatingManager(repo, system, service, cache, statisticsFactory, statisticsClock,", "originalCommit": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY4MDYyNg==", "url": "https://github.com/apache/geode/pull/5728#discussion_r535680626", "bodyText": "Removing use of spy. The test no longer does any spying.", "author": "kirklund", "createdAt": "2020-12-03T22:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzNDg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI5NTYyMg==", "url": "https://github.com/apache/geode/pull/5728#discussion_r536295622", "bodyText": "Spy is gone!", "author": "kirklund", "createdAt": "2020-12-04T18:29:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzNDg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzNzU4MQ==", "url": "https://github.com/apache/geode/pull/5728#discussion_r535537581", "bodyText": "The concern I have with pendingStartup being set to true when FederatingManager is created is that removeMember could build up a big list of pending tasks if the call of startManager is delayed.\nIn some cases we are careful to call start right after create. But in others, based on how the gemfire properties configure jmx, it can be delayed. If you look in ManagementAdapter this code:     if (cache.getInternalDistributedSystem().getConfig().getJmxManager()) { service.createManager(); if (cache.getInternalDistributedSystem().getConfig().getJmxManagerStart()) { service.startManager(); } }\nwill not always call startManager.", "author": "dschneider-pivotal", "createdAt": "2020-12-03T19:48:34Z", "path": "geode-core/src/main/java/org/apache/geode/management/internal/FederatingManager.java", "diffHunk": "@@ -79,26 +82,39 @@\n    * unbounded in practical situation as number of members will be a finite set at any given point\n    * of time\n    */\n-  private ExecutorService executorService;\n+  private final AtomicReference<ExecutorService> executorService = new AtomicReference<>();\n+  private boolean pendingStartup = true;", "originalCommit": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY4NjE3OQ==", "url": "https://github.com/apache/geode/pull/5728#discussion_r535686179", "bodyText": "Do you have any suggestions how to fix FederatingManager without this problem? The membership listener callbacks need to never block on synchronization but they cannot add or remove until after the manager is started.", "author": "kirklund", "createdAt": "2020-12-03T22:21:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzNzU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI5NjI1MQ==", "url": "https://github.com/apache/geode/pull/5728#discussion_r536296251", "bodyText": "I believe I can prevent building up an unused collection of membership tasks by overhauling SystemManagementService and ManagementMembershipListener to avoid adding a membership listener until the manager actually starts.", "author": "kirklund", "createdAt": "2020-12-04T18:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzNzU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzOTU0Mg==", "url": "https://github.com/apache/geode/pull/5728#discussion_r535539542", "bodyText": "I don't see port[1] and port[3] being used. Is it on purpose?", "author": "jchen21", "createdAt": "2020-12-03T19:51:37Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/management/JMXMBeanLocatorRestartTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management;\n+\n+import static java.lang.management.ManagementFactory.getPlatformMBeanServer;\n+import static java.util.Arrays.asList;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static javax.management.ObjectName.getInstance;\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_START;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.MEMBER_TIMEOUT;\n+import static org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper.crashDistributedSystem;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPorts;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.getTimeout;\n+import static org.apache.geode.test.dunit.Disconnect.disconnectAllFromDS;\n+import static org.apache.geode.test.dunit.IgnoredException.addIgnoredException;\n+import static org.apache.geode.test.dunit.Invoke.invokeInEveryVM;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.apache.geode.test.dunit.VM.getVMId;\n+import static org.apache.geode.util.internal.GeodeGlossary.GEMFIRE_PREFIX;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelException;\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.alerting.internal.spi.AlertingIOException;\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.LocatorLauncher;\n+import org.apache.geode.distributed.ServerLauncher;\n+import org.apache.geode.distributed.internal.InternalLocator;\n+import org.apache.geode.distributed.internal.membership.api.MemberDisconnectedException;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedErrorCollector;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+\n+public class JMXMBeanLocatorRestartTest implements Serializable {\n+\n+  private static final long TIMEOUT_MILLIS = getTimeout().toMillis();\n+  private static final LocatorLauncher DUMMY_LOCATOR = mock(LocatorLauncher.class);\n+  private static final ServerLauncher DUMMY_SERVER = mock(ServerLauncher.class);\n+\n+  private static final AtomicReference<CountDownLatch> BEFORE =\n+      new AtomicReference<>(new CountDownLatch(0));\n+  private static final AtomicReference<CountDownLatch> AFTER =\n+      new AtomicReference<>(new CountDownLatch(0));\n+\n+  private static final AtomicReference<LocatorLauncher> LOCATOR =\n+      new AtomicReference<>(DUMMY_LOCATOR);\n+  private static final AtomicReference<ServerLauncher> SERVER =\n+      new AtomicReference<>(DUMMY_SERVER);\n+\n+  private VM locatorVM;\n+  private VM serverVM;\n+\n+  private String locatorName;\n+  private String serverName;\n+  private String locators;\n+  private int locatorPort;\n+  private int locatorJmxPort;\n+  private String regionName;\n+  private Set<ObjectName> mxbeansOnServer;\n+  private Set<ObjectName> mxbeansOnLocator;\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+  @Rule\n+  public SerializableTemporaryFolder temporaryFolder = new SerializableTemporaryFolder();\n+  @Rule\n+  public DistributedErrorCollector errorCollector = new DistributedErrorCollector();\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreProps = new DistributedRestoreSystemProperties();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    locatorVM = getVM(1);\n+    serverVM = getVM(0);\n+\n+    for (VM vm : asList(locatorVM, serverVM)) {\n+      vm.invoke(() -> System.setProperty(GEMFIRE_PREFIX + \"standard-output-always-on\", \"true\"));\n+    }\n+\n+    locatorName = \"locator1\";\n+    serverName = \"server1\";\n+    File locator1Dir = temporaryFolder.newFolder(locatorName);\n+    File serverDir = temporaryFolder.newFolder(serverName);\n+\n+    int[] port = getRandomAvailableTCPPorts(4);", "originalCommit": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY4MjUwMw==", "url": "https://github.com/apache/geode/pull/5728#discussion_r535682503", "bodyText": "Thanks for catching that! I originally had the test using 4 ports. I'll change it to 2 ports.", "author": "kirklund", "createdAt": "2020-12-03T22:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzOTU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI5NzA5Ng==", "url": "https://github.com/apache/geode/pull/5728#discussion_r536297096", "bodyText": "Fixed! I've renamed the test to JmxLocatorReconnectDistributedTest and also renamed/overhauled JmxServerReconnectDistributedTest for consistency. I also updated them to use DistributedReference to make the launcher handling of easier. Please take a look when you have a chance. Thanks!", "author": "kirklund", "createdAt": "2020-12-04T18:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzOTU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzMzc5Mw==", "url": "https://github.com/apache/geode/pull/5728#discussion_r536333793", "bodyText": "The changes have been pushed now.", "author": "kirklund", "createdAt": "2020-12-04T19:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzOTU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU0NDk5NQ==", "url": "https://github.com/apache/geode/pull/5728#discussion_r535544995", "bodyText": "The latches BEFORE and AFTER are initialized as 0. But I don't see them being used anywhere else.", "author": "jchen21", "createdAt": "2020-12-03T19:59:38Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/management/JMXMBeanLocatorRestartTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.management;\n+\n+import static java.lang.management.ManagementFactory.getPlatformMBeanServer;\n+import static java.util.Arrays.asList;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static javax.management.ObjectName.getInstance;\n+import static org.apache.geode.cache.Region.SEPARATOR;\n+import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_START;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;\n+import static org.apache.geode.distributed.ConfigurationProperties.MAX_WAIT_TIME_RECONNECT;\n+import static org.apache.geode.distributed.ConfigurationProperties.MEMBER_TIMEOUT;\n+import static org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper.crashDistributedSystem;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPorts;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.getTimeout;\n+import static org.apache.geode.test.dunit.Disconnect.disconnectAllFromDS;\n+import static org.apache.geode.test.dunit.IgnoredException.addIgnoredException;\n+import static org.apache.geode.test.dunit.Invoke.invokeInEveryVM;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.apache.geode.test.dunit.VM.getVMId;\n+import static org.apache.geode.util.internal.GeodeGlossary.GEMFIRE_PREFIX;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import org.awaitility.core.ConditionFactory;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelException;\n+import org.apache.geode.ForcedDisconnectException;\n+import org.apache.geode.alerting.internal.spi.AlertingIOException;\n+import org.apache.geode.cache.CacheClosedException;\n+import org.apache.geode.distributed.DistributedSystemDisconnectedException;\n+import org.apache.geode.distributed.LocatorLauncher;\n+import org.apache.geode.distributed.ServerLauncher;\n+import org.apache.geode.distributed.internal.InternalLocator;\n+import org.apache.geode.distributed.internal.membership.api.MemberDisconnectedException;\n+import org.apache.geode.test.awaitility.GeodeAwaitility;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.DistributedErrorCollector;\n+import org.apache.geode.test.dunit.rules.DistributedRestoreSystemProperties;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.GfshCommandRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;\n+\n+public class JMXMBeanLocatorRestartTest implements Serializable {\n+\n+  private static final long TIMEOUT_MILLIS = getTimeout().toMillis();\n+  private static final LocatorLauncher DUMMY_LOCATOR = mock(LocatorLauncher.class);\n+  private static final ServerLauncher DUMMY_SERVER = mock(ServerLauncher.class);\n+\n+  private static final AtomicReference<CountDownLatch> BEFORE =\n+      new AtomicReference<>(new CountDownLatch(0));\n+  private static final AtomicReference<CountDownLatch> AFTER =\n+      new AtomicReference<>(new CountDownLatch(0));\n+\n+  private static final AtomicReference<LocatorLauncher> LOCATOR =\n+      new AtomicReference<>(DUMMY_LOCATOR);\n+  private static final AtomicReference<ServerLauncher> SERVER =\n+      new AtomicReference<>(DUMMY_SERVER);\n+\n+  private VM locatorVM;\n+  private VM serverVM;\n+\n+  private String locatorName;\n+  private String serverName;\n+  private String locators;\n+  private int locatorPort;\n+  private int locatorJmxPort;\n+  private String regionName;\n+  private Set<ObjectName> mxbeansOnServer;\n+  private Set<ObjectName> mxbeansOnLocator;\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+  @Rule\n+  public SerializableTemporaryFolder temporaryFolder = new SerializableTemporaryFolder();\n+  @Rule\n+  public DistributedErrorCollector errorCollector = new DistributedErrorCollector();\n+  @Rule\n+  public transient GfshCommandRule gfsh = new GfshCommandRule();\n+  @Rule\n+  public DistributedRestoreSystemProperties restoreProps = new DistributedRestoreSystemProperties();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    locatorVM = getVM(1);\n+    serverVM = getVM(0);\n+\n+    for (VM vm : asList(locatorVM, serverVM)) {\n+      vm.invoke(() -> System.setProperty(GEMFIRE_PREFIX + \"standard-output-always-on\", \"true\"));\n+    }\n+\n+    locatorName = \"locator1\";\n+    serverName = \"server1\";\n+    File locator1Dir = temporaryFolder.newFolder(locatorName);\n+    File serverDir = temporaryFolder.newFolder(serverName);\n+\n+    int[] port = getRandomAvailableTCPPorts(4);\n+    locatorPort = port[0];\n+    locatorJmxPort = port[2];\n+    locators = \"localhost[\" + locatorPort + \"]\";\n+\n+    locatorVM.invoke(() -> {\n+      startLocator(locatorName, locator1Dir, locatorPort, locatorJmxPort, locators);\n+    });\n+\n+    serverVM.invoke(() -> startServer(serverName, serverDir, locators));\n+\n+    gfsh.connectAndVerify(locatorJmxPort, GfshCommandRule.PortType.jmxManager);\n+\n+    regionName = \"region1\";\n+    String createRegionCommand = \"create region --type=REPLICATE --name=\" + SEPARATOR + regionName;\n+    gfsh.executeAndAssertThat(createRegionCommand).statusIsSuccess();\n+\n+    addIgnoredException(AlertingIOException.class);\n+    addIgnoredException(CacheClosedException.class);\n+    addIgnoredException(CancelException.class);\n+    addIgnoredException(DistributedSystemDisconnectedException.class);\n+    addIgnoredException(ForcedDisconnectException.class);\n+    addIgnoredException(MemberDisconnectedException.class);\n+    addIgnoredException(\"Possible loss of quorum\");\n+\n+    mxbeansOnServer = serverVM.invoke(() -> {\n+      await().untilAsserted(() -> {\n+        assertThat(getPlatformMBeanServer().queryNames(getInstance(\"GemFire:*\"), null))\n+            .as(\"GemFire mbeans on server1\")\n+            .containsAll(expectedServerMXBeans(serverName, regionName));\n+      });\n+      return getPlatformMBeanServer().queryNames(getInstance(\"GemFire:*\"), null);\n+    });\n+\n+    mxbeansOnLocator = locatorVM.invoke(() -> {\n+      await().untilAsserted(() -> {\n+        assertThat(getPlatformMBeanServer().queryNames(getInstance(\"GemFire:*\"), null))\n+            .as(\"GemFire mbeans on locator1\")\n+            .containsAll(expectedServerMXBeans(serverName, regionName))\n+            .containsAll(expectedLocatorMXBeans(locatorName))\n+            .containsAll(expectedDistributedMXBeans(regionName));\n+      });\n+\n+      return getPlatformMBeanServer().queryNames(getInstance(\"GemFire:*\"), null);\n+    });\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    invokeInEveryVM(() -> {\n+      BEFORE.get().countDown();", "originalCommit": "84ee7bc9ab5a2fda8f83a4d19c5dc153809d94d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY4MzU4OQ==", "url": "https://github.com/apache/geode/pull/5728#discussion_r535683589", "bodyText": "I copied too much code from JMXMBeanReconnectDUnitTest which focuses on restart of servers.\nJMXMBeanLocatorRestartTest is new and focuses on restart of locator. I need to do more cleanup. Thanks!", "author": "kirklund", "createdAt": "2020-12-03T22:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU0NDk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjI5NzIyMw==", "url": "https://github.com/apache/geode/pull/5728#discussion_r536297223", "bodyText": "Fixed!", "author": "kirklund", "createdAt": "2020-12-04T18:32:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU0NDk5NQ=="}], "type": "inlineReview"}, {"oid": "f76ed9fdb8145b3e95ace1844bfe4f50c41a8833", "url": "https://github.com/apache/geode/commit/f76ed9fdb8145b3e95ace1844bfe4f50c41a8833", "message": "Extract cleanUpFailedStart method", "committedDate": "2020-12-08T18:57:28Z", "type": "forcePushed"}, {"oid": "7354ee34e5b33ea9610abd9ea6737b9c1a061f78", "url": "https://github.com/apache/geode/commit/7354ee34e5b33ea9610abd9ea6737b9c1a061f78", "message": "GEODE-8696: Fix synchronization in FederatingManager\n\nPrevent hang while protecting against removal of member artifacts\nduring startup of manager.", "committedDate": "2021-01-04T22:50:55Z", "type": "commit"}, {"oid": "6b09a511a5ab6545b48c252dcc7295088db7d3ea", "url": "https://github.com/apache/geode/commit/6b09a511a5ab6545b48c252dcc7295088db7d3ea", "message": "Fixup", "committedDate": "2021-01-04T22:48:43Z", "type": "forcePushed"}, {"oid": "70e207b8ab460625e2a3df44f00f5320da8d8bef", "url": "https://github.com/apache/geode/commit/70e207b8ab460625e2a3df44f00f5320da8d8bef", "message": "Rename and fixup both JMX reconnect distributed tests", "committedDate": "2021-01-04T22:56:40Z", "type": "forcePushed"}, {"oid": "93524b77568052c49e215bb6b2322626f279b7d6", "url": "https://github.com/apache/geode/commit/93524b77568052c49e215bb6b2322626f279b7d6", "message": "Partial wip with green precheckin", "committedDate": "2021-01-04T22:57:19Z", "type": "commit"}, {"oid": "86cbf6d5c08d9225564e5a8946c9b5cc2c9fb6b0", "url": "https://github.com/apache/geode/commit/86cbf6d5c08d9225564e5a8946c9b5cc2c9fb6b0", "message": "Fixup", "committedDate": "2021-01-04T23:16:32Z", "type": "forcePushed"}, {"oid": "93524b77568052c49e215bb6b2322626f279b7d6", "url": "https://github.com/apache/geode/commit/93524b77568052c49e215bb6b2322626f279b7d6", "message": "Partial wip with green precheckin", "committedDate": "2021-01-04T22:57:19Z", "type": "forcePushed"}, {"oid": "821fe758653898c02204e4807d825721328e0f46", "url": "https://github.com/apache/geode/commit/821fe758653898c02204e4807d825721328e0f46", "message": "Remove unused parameters.", "committedDate": "2021-01-06T00:17:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExNzc0Mw==", "url": "https://github.com/apache/geode/pull/5728#discussion_r554117743", "bodyText": "Should this clear and setting running and starting also be protected by a lifecycleLock.lock/unlock?", "author": "dschneider-pivotal", "createdAt": "2021-01-08T18:28:00Z", "path": "geode-core/src/main/java/org/apache/geode/management/internal/FederatingManager.java", "diffHunk": "@@ -108,31 +114,60 @@\n   @Override\n   public synchronized void startManager() {\n     try {\n-      if (logger.isDebugEnabled()) {\n-        logger.debug(\"Starting the Federating Manager.... \");\n+      lifecycleLock.lock();\n+      try {\n+        if (starting || running) {\n+          return;\n+        }\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"Starting the Federating Manager.... \");\n+        }\n+        starting = true;\n+        executorService.set(executorServiceSupplier.get());\n+        running = true;\n+      } finally {\n+        lifecycleLock.unlock();\n       }\n \n-      executorService = executorServiceSupplier.get();\n-\n-      running = true;\n       startManagingActivity();\n+\n+      lifecycleLock.lock();\n+      try {\n+        for (Runnable task : pendingTasks) {\n+          executeTask(task);\n+        }\n+      } finally {\n+        pendingTasks.clear();\n+        starting = false;\n+        lifecycleLock.unlock();\n+      }\n+\n       messenger.broadcastManagerInfo();\n+\n     } catch (Exception e) {\n+      pendingTasks.clear();", "originalCommit": "821fe758653898c02204e4807d825721328e0f46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDEyNjE3Mg==", "url": "https://github.com/apache/geode/pull/5728#discussion_r554126172", "bodyText": "Yeah, I'm not sure if it's necessary but it would be more consistent. I'll try making that change and try to write a new test or two in which startup fails.", "author": "kirklund", "createdAt": "2021-01-08T18:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExNzc0Mw=="}], "type": "inlineReview"}, {"oid": "72c802dd54b4bd40a5ea4134ee8f739bba20d2e3", "url": "https://github.com/apache/geode/commit/72c802dd54b4bd40a5ea4134ee8f739bba20d2e3", "message": "Improve cleanup for failed start.", "committedDate": "2021-01-08T19:11:13Z", "type": "commit"}]}