{"pr_number": 5146, "pr_title": "GEODE-8175: removed list, sorted set, hyperLog and transaction redis commands and code", "pr_createdAt": "2020-05-22T00:02:23Z", "pr_url": "https://github.com/apache/geode/pull/5146", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI2NzQxNA==", "url": "https://github.com/apache/geode/pull/5146#discussion_r429267414", "bodyText": "Can we get rid of the @ignore on this test now that we're only testing hashes and sets?", "author": "ringles", "createdAt": "2020-05-22T14:06:31Z", "path": "geode-redis/src/distributedTest/java/org/apache/geode/redis/RedisDistDUnitTest.java", "diffHunk": "@@ -209,18 +209,6 @@ public void run() throws InterruptedException {\n             } else {\n               jedis.del(hKey);\n             }\n-          } else if (n == 1) {", "originalCommit": "507b9db04a041a943fc28c1c6d0a1ee1e99f97fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM1MjEzOA==", "url": "https://github.com/apache/geode/pull/5146#discussion_r429352138", "bodyText": "done", "author": "dschneider-pivotal", "createdAt": "2020-05-22T16:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI2NzQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI3MTYxNA==", "url": "https://github.com/apache/geode/pull/5146#discussion_r429271614", "bodyText": "Doesn't look like the arguments are needed anymore. In fact, the whole function may be eliminated...", "author": "ringles", "createdAt": "2020-05-22T14:13:58Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/KeyRegistrar.java", "diffHunk": "@@ -201,11 +172,7 @@ private void throwDataTypeException(ByteArrayWrapper key, RedisData data) {\n   }\n \n   private void throwDataTypeException(ByteArrayWrapper key, RedisDataType dataType) {\n-    if (RedisDataType.REDIS_PROTECTED.equals(dataType)) {\n-      throw new RedisDataTypeMismatchException(\"The key name \\\"\" + key + \"\\\" is protected\");\n-    } else {\n-      throw new RedisDataTypeMismatchException(\n-          RedisConstants.ERROR_WRONG_TYPE);\n-    }\n+    throw new RedisDataTypeMismatchException(", "originalCommit": "507b9db04a041a943fc28c1c6d0a1ee1e99f97fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM1MjM1Ng==", "url": "https://github.com/apache/geode/pull/5146#discussion_r429352356", "bodyText": "done", "author": "dschneider-pivotal", "createdAt": "2020-05-22T16:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI3MTYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI3ODI2OQ==", "url": "https://github.com/apache/geode/pull/5146#discussion_r429278269", "bodyText": "So, because we don't care whether or not these calls return true or false, we don't really need the lock anymore? If two threads try to remove the same key, at least one will succeed so no harm, no foul?", "author": "ringles", "createdAt": "2020-05-22T14:25:06Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RegionProvider.java", "diffHunk": "@@ -205,281 +98,27 @@ private boolean typeStoresDataInKeyRegistrar(RedisDataType type) {\n   }\n \n   public boolean removeKey(ByteArrayWrapper key, RedisDataType type, boolean cancelExpiration) {\n-    if (type == RedisDataType.REDIS_PROTECTED) {\n-      return false;\n+    if (!typeStoresDataInKeyRegistrar(type)) {\n+      keyRegistrar.unregister(key);\n     }\n-    Lock lock = dynamicRegionLocks.get(key);\n+    RedisKeyCommands redisKeyCommands = new RedisKeyCommandsFunctionExecutor(dataRegion);\n     try {\n-      if (lock != null) { // only typeUsesDynamicRegions will have a lock\n-        lock.lock();\n-      }\n-      if (!typeStoresDataInKeyRegistrar(type)) {\n-        keyRegistrar.unregister(key);\n-      }\n-      RedisKeyCommands redisKeyCommands = new RedisKeyCommandsFunctionExecutor(dataRegion);\n-      try {\n-        if (type == RedisDataType.REDIS_STRING) {\n-          return stringsRegion.remove(key) != null;\n-        } else if (type == RedisDataType.REDIS_HLL) {\n-          return hLLRegion.remove(key) != null;\n-        } else if (type == RedisDataType.REDIS_LIST || type == RedisDataType.REDIS_SORTEDSET) {\n-          return destroyRegion(key, type);\n-        } else if (type == RedisDataType.REDIS_SET || type == RedisDataType.REDIS_HASH) {\n-          return redisKeyCommands.del(key);\n-        } else {\n-          return false;\n-        }\n-      } catch (Exception exc) {\n+      if (type == RedisDataType.REDIS_STRING) {\n+        return stringsRegion.remove(key) != null;\n+      } else if (type == RedisDataType.REDIS_SET || type == RedisDataType.REDIS_HASH) {\n+        return redisKeyCommands.del(key);\n+      } else {\n         return false;\n-      } finally {\n-        if (cancelExpiration) {\n-          cancelKeyExpiration(key);\n-        } else {\n-          removeKeyExpiration(key);\n-        }\n-        if (lock != null) {\n-          dynamicRegionLocks.remove(key);\n-        }\n       }\n+    } catch (Exception exc) {\n+      return false;\n     } finally {\n-      if (lock != null) {\n-        lock.unlock();\n-      }\n-    }\n-  }\n-\n-  public Region<?, ?> getOrCreateRegion(ByteArrayWrapper key, RedisDataType type,\n-      ExecutionHandlerContext context) {\n-    return getOrCreateRegion0(key, type, context, true);\n-  }\n-\n-  public boolean typeUsesDynamicRegions(RedisDataType type) {\n-    return type == RedisDataType.REDIS_LIST || type == RedisDataType.REDIS_SORTEDSET;\n-  }\n-\n-  public void createRemoteRegionReferenceLocally(ByteArrayWrapper key, RedisDataType type) {\n-    if (!typeUsesDynamicRegions(type)) {\n-      return;\n-    }\n-    Region<Object, Object> r = dynamicRegions.get(key);\n-    if (r != null) {\n-      return;\n-    }\n-    Lock lock = dynamicRegionLocks.get(key);\n-    if (lock == null) {\n-      Lock newLock = new ReentrantLock();\n-      lock = dynamicRegionLocks.putIfAbsent(key, newLock);\n-      if (lock == null) {\n-        lock = newLock;\n-      }\n-    }\n-    boolean locked = lock.tryLock();\n-    // If we cannot get the lock then this remote event may have been initialized\n-    // independently on this machine, so if we wait on the lock it is more than\n-    // likely we will deadlock just to do the same task. This event can be ignored\n-    if (locked) {\n-      try {\n-        r = cache.getRegion(key.toString());\n-        // If r is null, this implies that we are after a create/destroy\n-        // simply ignore. Calls to getRegion or getOrCreate will work correctly\n-        if (r == null) {\n-          // TODO: one caller of this method only calls it if getRegion returned null. It was\n-          // expecting us to create it locally. If someone else will create it locally then this\n-          // method does not need to be called.\n-          return;\n-        }\n-\n-        if (type == RedisDataType.REDIS_LIST) {\n-          doInitializeList(key, r);\n-        } else if (type == RedisDataType.REDIS_SORTEDSET) {\n-          try {\n-            doInitializeSortedSet(key, r);\n-          } catch (RegionNotFoundException | IndexInvalidException e) {\n-            // ignore\n-          }\n-        }\n-        dynamicRegions.put(key, r);\n-      } finally {\n-        lock.unlock();\n-      }\n-    }\n-  }\n-\n-  private Region<?, ?> getOrCreateRegion0(ByteArrayWrapper key, RedisDataType type,\n-      ExecutionHandlerContext context, boolean addToMeta) {\n-\n-    keyRegistrar.validate(key, type);\n-    Region<Object, Object> r = dynamicRegions.get(key);\n-    if (r != null && r.isDestroyed()) {\n-      removeKey(key, type);\n-      r = null;\n-    }\n-    if (r == null) {\n-      Lock lock = dynamicRegionLocks.get(key);\n-      if (lock == null) {\n-        Lock newLock = new ReentrantLock();\n-        lock = dynamicRegionLocks.putIfAbsent(key, newLock);\n-        if (lock == null) {\n-          lock = newLock;\n-        }\n-      }\n-\n-      lock.lock();\n-      try {\n-        r = dynamicRegions.get(key);\n-        if (r == null) {\n-          boolean hasTransaction = context != null && context.hasTransaction(); // Can create\n-          // without context\n-          CacheTransactionManager txm = null;\n-          TransactionId transactionId = null;\n-          try {\n-            if (hasTransaction) {\n-              txm = cache.getCacheTransactionManager();\n-              transactionId = txm.suspend();\n-            }\n-            Exception concurrentCreateDestroyException;\n-            do {\n-              concurrentCreateDestroyException = null;\n-\n-              r = createRegionGlobally(key.toString());\n-\n-              try {\n-                if (type == RedisDataType.REDIS_LIST) {\n-                  doInitializeList(key, r);\n-                } else if (type == RedisDataType.REDIS_SORTEDSET) {\n-                  try {\n-                    doInitializeSortedSet(key, r);\n-                  } catch (RegionNotFoundException | IndexInvalidException e) {\n-                    concurrentCreateDestroyException = e;\n-                  }\n-                }\n-              } catch (QueryInvalidException e) {\n-                if (e.getCause() instanceof RegionNotFoundException) {\n-                  concurrentCreateDestroyException = e;\n-                }\n-              }\n-            } while (concurrentCreateDestroyException != null);\n-            dynamicRegions.put(key, r);\n-            if (addToMeta) {\n-              keyRegistrar.register(key, type);\n-            }\n-          } finally {\n-            if (hasTransaction) {\n-              txm.resume(transactionId);\n-            }\n-          }\n-        }\n-      } finally {\n-        lock.unlock();\n-      }\n-    }\n-    return r;\n-  }\n-\n-  /**\n-   * SYNCHRONIZE EXTERNALLY OF this.locks.get(key)!!!!!\n-   *\n-   * @param key Key of region to destroy\n-   * @param type Type of region to destroyu\n-   * @return Flag if destroyed\n-   */\n-  private boolean destroyRegion(ByteArrayWrapper key, RedisDataType type) {\n-    Region<?, ?> r = dynamicRegions.get(key);\n-    if (r != null) {\n-      try {\n-        r.destroyRegion();\n-      } catch (Exception e) {\n-        return false;\n-      } finally {\n-        removeRegionState(key, type);\n+      if (cancelExpiration) {", "originalCommit": "507b9db04a041a943fc28c1c6d0a1ee1e99f97fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0ODE2Mg==", "url": "https://github.com/apache/geode/pull/5146#discussion_r429348162", "bodyText": "The locks on this method had to do with dynamic regions which no longer exist because they were only used by lists a zset. I do think we care about what we return from this and we end up being protected by the StripedExecutor now. I think once Strings have moved to the new data model this \"del\" code can be cleaned up some more. Also once everything is on the new expiration model then expiration cleanup this method does will not be needed.", "author": "dschneider-pivotal", "createdAt": "2020-05-22T16:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI3ODI2OQ=="}], "type": "inlineReview"}, {"oid": "96719b5042336a0cb46e878aa4fe63f1b629ad6b", "url": "https://github.com/apache/geode/commit/96719b5042336a0cb46e878aa4fe63f1b629ad6b", "message": "removed list and sorted set commands and code\n\nremoved redis HyperLog commands\n\nremoved PROTECTED as a type\n\nremoved redis transaction commands", "committedDate": "2020-05-22T23:16:08Z", "type": "commit"}, {"oid": "96719b5042336a0cb46e878aa4fe63f1b629ad6b", "url": "https://github.com/apache/geode/commit/96719b5042336a0cb46e878aa4fe63f1b629ad6b", "message": "removed list and sorted set commands and code\n\nremoved redis HyperLog commands\n\nremoved PROTECTED as a type\n\nremoved redis transaction commands", "committedDate": "2020-05-22T23:16:08Z", "type": "forcePushed"}]}