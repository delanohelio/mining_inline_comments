{"pr_number": 5667, "pr_title": "GEODE-8647: Support multiple instances of DistributedMap", "pr_createdAt": "2020-10-24T01:17:40Z", "pr_url": "https://github.com/apache/geode/pull/5667", "timeline": [{"oid": "0da61e93da01eb15771ab53e1201c35d2a99aa9c", "url": "https://github.com/apache/geode/commit/0da61e93da01eb15771ab53e1201c35d2a99aa9c", "message": "GEODE-8647: Support multiple instances of DistributedMap\n\nIncludes additional improvements for usage of DistributedMap.", "committedDate": "2020-10-26T17:36:25Z", "type": "forcePushed"}, {"oid": "e8591490eed0ca4fee90f05a1815aee785753616", "url": "https://github.com/apache/geode/commit/e8591490eed0ca4fee90f05a1815aee785753616", "message": "GEODE-8647: Support multiple instances of DistributedMap\n\nIncludes additional improvements for usage of DistributedMap.", "committedDate": "2020-10-26T22:13:04Z", "type": "commit"}, {"oid": "e8591490eed0ca4fee90f05a1815aee785753616", "url": "https://github.com/apache/geode/commit/e8591490eed0ca4fee90f05a1815aee785753616", "message": "GEODE-8647: Support multiple instances of DistributedMap\n\nIncludes additional improvements for usage of DistributedMap.", "committedDate": "2020-10-26T22:13:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA3MDcxNw==", "url": "https://github.com/apache/geode/pull/5667#discussion_r513070717", "bodyText": "Might it be worth extracting the hardcoded string keys/values in this test class to constants?", "author": "DonalEvans", "createdAt": "2020-10-27T22:28:34Z", "path": "geode-dunit/src/distributedTest/java/org/apache/geode/test/dunit/rules/tests/DistributedMapTest.java", "diffHunk": "@@ -491,4 +495,162 @@ public void getReturnsSameValueInEveryVmAsPutInOtherVm() {\n       });\n     }\n   }\n+\n+  @Test\n+  public void accessesDistributedMapInEachVm() {\n+    runTestWithValidation(HasDistributedMap.class);\n+  }\n+\n+  @Test\n+  public void tearsDownDistributedMapInEachVm() {\n+    runTestWithValidation(HasDistributedMap.class);\n+\n+    getController().invoke(() -> {\n+      assertThat(HasDistributedMap.map.get()).isEmpty();\n+    });\n+  }\n+\n+  @Test\n+  public void accessesTwoDistributedMapsInEachVm() {\n+    runTestWithValidation(HasTwoDistributedMaps.class);\n+  }\n+\n+  @Test\n+  public void tearsDownTwoDistributedMapsInEachVm() {\n+    runTestWithValidation(HasTwoDistributedMaps.class);\n+\n+    getController().invoke(() -> {\n+      assertThat(HasTwoDistributedMaps.map1.get()).isEmpty();\n+      assertThat(HasTwoDistributedMaps.map2.get()).isEmpty();\n+    });\n+  }\n+\n+  @Test\n+  public void accessesManyDistributedMapsInEachVm() {\n+    runTestWithValidation(HasManyDistributedMaps.class);\n+  }\n+\n+  @Test\n+  public void tearsDownManyDistributedMapsInEachVm() {\n+    runTestWithValidation(HasManyDistributedMaps.class);\n+\n+    getController().invoke(() -> {\n+      assertThat(HasManyDistributedMaps.map1.get()).isEmpty();\n+      assertThat(HasManyDistributedMaps.map2.get()).isEmpty();\n+      assertThat(HasManyDistributedMaps.map3.get()).isEmpty();\n+    });\n+  }\n+\n+  public static class HasDistributedMap implements Serializable {\n+\n+    private static final AtomicReference<Map<Object, Object>> map = new AtomicReference<>();\n+\n+    @Rule\n+    public DistributedMap<Object, Object> distributedMap = new DistributedMap<>();\n+\n+    @Before\n+    public void setUp() {\n+      getController().invoke(() -> {\n+        map.set(distributedMap.map());\n+        distributedMap.put(\"key1\", \"value1\");\n+      });\n+    }\n+\n+    @Test\n+    public void distributedMapIsAccessibleInEveryVm() {\n+      for (VM vm : asList(getVM(0), getVM(1), getVM(2), getVM(3), getController())) {\n+        vm.invoke(() -> {\n+          assertThat(distributedMap.map()).isSameAs(map.get());\n+          assertThat(distributedMap.get(\"key1\")).isEqualTo(\"value1\");\n+        });\n+      }\n+    }\n+  }\n+\n+  public static class HasTwoDistributedMaps implements Serializable {\n+\n+    private static final AtomicReference<Map<Object, Object>> map1 = new AtomicReference<>();\n+    private static final AtomicReference<Map<Object, Object>> map2 = new AtomicReference<>();\n+\n+    @Rule\n+    public DistributedMap<Object, Object> distributedMap1 = new DistributedMap<>();\n+    @Rule\n+    public DistributedMap<Object, Object> distributedMap2 = new DistributedMap<>();\n+\n+    @Before\n+    public void setUp() {\n+      getController().invoke(() -> {\n+        map1.set(distributedMap1.map());\n+        distributedMap1.put(\"key1\", \"value1\");\n+\n+        map2.set(distributedMap2.map());\n+        distributedMap2.put(\"key2\", \"value2\");\n+      });\n+    }\n+\n+    @Test\n+    public void twoDistributedMapsAreAccessibleInEveryVm() {\n+      for (VM vm : asList(getVM(0), getVM(1), getVM(2), getVM(3), getController())) {\n+        vm.invoke(() -> {\n+          assertThat(distributedMap1.map()).isSameAs(map1.get());\n+          assertThat(distributedMap1.get(\"key1\")).isEqualTo(\"value1\");\n+          assertThat(distributedMap1.get(\"key2\")).isNull();\n+\n+          assertThat(distributedMap2.map()).isSameAs(map2.get());\n+          assertThat(distributedMap2.get(\"key1\")).isNull();\n+          assertThat(distributedMap2.get(\"key2\")).isEqualTo(\"value2\");\n+        });\n+      }\n+    }\n+  }\n+\n+  public static class HasManyDistributedMaps implements Serializable {\n+\n+    private static final AtomicReference<Map<Object, Object>> map1 = new AtomicReference<>();\n+    private static final AtomicReference<Map<Object, Object>> map2 = new AtomicReference<>();\n+    private static final AtomicReference<Map<Object, Object>> map3 = new AtomicReference<>();\n+\n+    @Rule\n+    public DistributedMap<Object, Object> distributedMap1 = new DistributedMap<>();\n+    @Rule\n+    public DistributedMap<Object, Object> distributedMap2 = new DistributedMap<>();\n+    @Rule\n+    public DistributedMap<Object, Object> distributedMap3 = new DistributedMap<>();\n+\n+    @Before\n+    public void setUp() {\n+      getController().invoke(() -> {\n+        map1.set(distributedMap1.map());\n+        distributedMap1.put(\"key1\", \"value1\");\n+\n+        map2.set(distributedMap2.map());\n+        distributedMap2.put(\"key2\", \"value2\");\n+\n+        map3.set(distributedMap3.map());\n+        distributedMap3.put(\"key3\", \"value3\");", "originalCommit": "e8591490eed0ca4fee90f05a1815aee785753616", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}