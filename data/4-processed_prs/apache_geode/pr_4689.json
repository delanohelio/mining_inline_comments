{"pr_number": 4689, "pr_title": "GEODE-7684: Create messaging for PR Clear", "pr_createdAt": "2020-02-11T23:12:57Z", "pr_url": "https://github.com/apache/geode/pull/4689", "timeline": [{"oid": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a", "url": "https://github.com/apache/geode/commit/31f29ae77edaab636b0f57129c6ebce2c6b38e1a", "message": "Made correct cmnClearRegion method public\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-12T00:02:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4MTc2NQ==", "url": "https://github.com/apache/geode/pull/4689#discussion_r377981765", "bodyText": "This is currently never used, so unless it's going to be needed for the API story, it should probably be removed.", "author": "DonalEvans", "createdAt": "2020-02-12T00:35:46Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;", "originalCommit": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ4MDU1Nw==", "url": "https://github.com/apache/geode/pull/4689#discussion_r378480557", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-12T19:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4MTc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4MjE3Mw==", "url": "https://github.com/apache/geode/pull/4689#discussion_r377982173", "bodyText": "This is set in the constructor and used in toData() and fromData() but other than that it's never accessed or modified, so it can probably be removed.", "author": "DonalEvans", "createdAt": "2020-02-12T00:37:12Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;", "originalCommit": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ4MDY3NQ==", "url": "https://github.com/apache/geode/pull/4689#discussion_r378480675", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-12T19:58:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4MjE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4MzEwNw==", "url": "https://github.com/apache/geode/pull/4689#discussion_r377983107", "bodyText": "This value is never used or modified by this class, so it can probably be removed.", "author": "DonalEvans", "createdAt": "2020-02-12T00:40:36Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId, boolean notificationOnly, boolean posDup,\n+      Object callbackArg) {\n+    this.bucketId = bucketId;\n+    this.notificationOnly = notificationOnly;\n+    this.posDup = posDup;", "originalCommit": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ4MTM5NA==", "url": "https://github.com/apache/geode/pull/4689#discussion_r378481394", "bodyText": "I don't think we should remove this entirely as they are fields of the parent class and are called by methods in the parent class that will end up running when this message is sent - however, as we never need this to be anything but false, I have changed it to automatically set this value to false in the constructer, rather than allowing a custom value for each instance of the message via the constructor.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-12T19:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4MzEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5MTc2OA==", "url": "https://github.com/apache/geode/pull/4689#discussion_r378491768", "bodyText": "Since they're boolean you don't need to explicitly set them to false; they default to that value even if they're not initialized, so we can avoid cluttering the constructor with assignments that are never used by the class.", "author": "DonalEvans", "createdAt": "2020-02-12T20:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4MzEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzMjY2Mg==", "url": "https://github.com/apache/geode/pull/4689#discussion_r378532662", "bodyText": "This is true, but I feel expressly setting them is more clear. If they were expressly set to false in the parent class as a default that would be different, but just allowing the compiler to default their values to false kind of hides the fact that this is an intentional value. Our message class will use these values (albeit in methods defined by its parent) and it's important that they're set to false, otherwise we run the risk of improperly processing the message.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-12T21:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4MzEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4NDQ2NA==", "url": "https://github.com/apache/geode/pull/4689#discussion_r377984464", "bodyText": "We set this value in the constructor and in the initMessage() method, but it's never used in this class, so it can probably be removed.", "author": "DonalEvans", "createdAt": "2020-02-12T00:45:15Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId, boolean notificationOnly, boolean posDup,\n+      Object callbackArg) {\n+    this.bucketId = bucketId;\n+    this.notificationOnly = notificationOnly;", "originalCommit": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ4MTU5Mw==", "url": "https://github.com/apache/geode/pull/4689#discussion_r378481593", "bodyText": "This is the same as the posDup above, always false, but needed by the parent. I've set it to false in the constructor as well.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-12T19:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4NDQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4NDgxMg==", "url": "https://github.com/apache/geode/pull/4689#discussion_r377984812", "bodyText": "This method is never used, and neither is posDup in this class, so it can probably be removed.", "author": "DonalEvans", "createdAt": "2020-02-12T00:46:24Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId, boolean notificationOnly, boolean posDup,\n+      Object callbackArg) {\n+    this.bucketId = bucketId;\n+    this.notificationOnly = notificationOnly;\n+    this.posDup = posDup;\n+    this.callbackArg = callbackArg;\n+    initTxMemberId();\n+  }\n+\n+  public void setEventId(RegionEventImpl event) {\n+    regionEvent = event;\n+  }\n+\n+  public void initMessage(PartitionedRegion region, Set<InternalDistributedMember> recipients,\n+      boolean notifyOnly, DirectReplyProcessor replyProcessor) {\n+    this.resetRecipients();\n+    if (recipients != null) {\n+      setRecipients(recipients);\n+    }\n+    this.regionId = region.getPRId();\n+    this.processor = replyProcessor;\n+    this.processorId = replyProcessor == null ? 0 : replyProcessor.getProcessorId();\n+    if (replyProcessor != null && this.isSevereAlertCompatible()) {\n+      replyProcessor.enableSevereAlertProcessing();\n+    }\n+    this.notificationOnly = notifyOnly;\n+  }\n+\n+  @Override\n+  public boolean isSevereAlertCompatible() {\n+    // allow forced-disconnect processing for all cache op messages\n+    return true;\n+  }\n+\n+  public void setPossibleDuplicate(boolean posDup) {", "originalCommit": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU3NTQ0Mg==", "url": "https://github.com/apache/geode/pull/4689#discussion_r378575442", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-12T23:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4NDgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4NTQ4MQ==", "url": "https://github.com/apache/geode/pull/4689#discussion_r377985481", "bodyText": "Remove comment.", "author": "DonalEvans", "createdAt": "2020-02-12T00:48:46Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId, boolean notificationOnly, boolean posDup,\n+      Object callbackArg) {\n+    this.bucketId = bucketId;\n+    this.notificationOnly = notificationOnly;\n+    this.posDup = posDup;\n+    this.callbackArg = callbackArg;\n+    initTxMemberId();\n+  }\n+\n+  public void setEventId(RegionEventImpl event) {\n+    regionEvent = event;\n+  }\n+\n+  public void initMessage(PartitionedRegion region, Set<InternalDistributedMember> recipients,\n+      boolean notifyOnly, DirectReplyProcessor replyProcessor) {\n+    this.resetRecipients();\n+    if (recipients != null) {\n+      setRecipients(recipients);\n+    }\n+    this.regionId = region.getPRId();\n+    this.processor = replyProcessor;\n+    this.processorId = replyProcessor == null ? 0 : replyProcessor.getProcessorId();\n+    if (replyProcessor != null && this.isSevereAlertCompatible()) {\n+      replyProcessor.enableSevereAlertProcessing();\n+    }\n+    this.notificationOnly = notifyOnly;\n+  }\n+\n+  @Override\n+  public boolean isSevereAlertCompatible() {\n+    // allow forced-disconnect processing for all cache op messages\n+    return true;\n+  }\n+\n+  public void setPossibleDuplicate(boolean posDup) {\n+    this.posDup = posDup;\n+  }\n+\n+  public RegionEventImpl getRegionEvent() {\n+    return regionEvent;\n+  }\n+\n+  public ClearResponse send(DistributedMember recipient, PartitionedRegion region)\n+      throws ForceReattemptException {\n+    Set<InternalDistributedMember> recipients =\n+        Collections.singleton((InternalDistributedMember) recipient);\n+    ClearResponse clearResponse = new ClearResponse(region.getSystem(), recipients);\n+    initMessage(region, recipients, false, clearResponse);\n+    setTransactionDistributed(region.getCache().getTxManager().isDistributed());\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"ClearPRMessage.send: recipient is {}, msg is {}\", recipient, this);\n+    }\n+\n+    Set<InternalDistributedMember> failures = region.getDistributionManager().putOutgoing(this);\n+    if (failures != null && failures.size() > 0) {\n+      throw new ForceReattemptException(\"Failed sending <\" + this + \">\");\n+    }\n+    return clearResponse;\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return PR_CLEAR_MESSAGE;\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out, SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    if (bucketId == null) {\n+      InternalDataSerializer.writeSignedVL(-1, out);\n+    } else {\n+      InternalDataSerializer.writeSignedVL(bucketId, out);\n+    }\n+    DataSerializer.writeObject(this.callbackArg, out);\n+    // BR: This may not work properly", "originalCommit": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ4MTc1MQ==", "url": "https://github.com/apache/geode/pull/4689#discussion_r378481751", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-12T20:00:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4NTQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5MTg3MA==", "url": "https://github.com/apache/geode/pull/4689#discussion_r377991870", "bodyText": "This method always returns false. Is that intentional? Also, I'm not sure if this method can actually throw any exceptions, since we catch the ForceReattemptException from doLocalClear() and the other two don't seem to be thrown by anything we're calling here.", "author": "DonalEvans", "createdAt": "2020-02-12T01:13:12Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId, boolean notificationOnly, boolean posDup,\n+      Object callbackArg) {\n+    this.bucketId = bucketId;\n+    this.notificationOnly = notificationOnly;\n+    this.posDup = posDup;\n+    this.callbackArg = callbackArg;\n+    initTxMemberId();\n+  }\n+\n+  public void setEventId(RegionEventImpl event) {\n+    regionEvent = event;\n+  }\n+\n+  public void initMessage(PartitionedRegion region, Set<InternalDistributedMember> recipients,\n+      boolean notifyOnly, DirectReplyProcessor replyProcessor) {\n+    this.resetRecipients();\n+    if (recipients != null) {\n+      setRecipients(recipients);\n+    }\n+    this.regionId = region.getPRId();\n+    this.processor = replyProcessor;\n+    this.processorId = replyProcessor == null ? 0 : replyProcessor.getProcessorId();\n+    if (replyProcessor != null && this.isSevereAlertCompatible()) {\n+      replyProcessor.enableSevereAlertProcessing();\n+    }\n+    this.notificationOnly = notifyOnly;\n+  }\n+\n+  @Override\n+  public boolean isSevereAlertCompatible() {\n+    // allow forced-disconnect processing for all cache op messages\n+    return true;\n+  }\n+\n+  public void setPossibleDuplicate(boolean posDup) {\n+    this.posDup = posDup;\n+  }\n+\n+  public RegionEventImpl getRegionEvent() {\n+    return regionEvent;\n+  }\n+\n+  public ClearResponse send(DistributedMember recipient, PartitionedRegion region)\n+      throws ForceReattemptException {\n+    Set<InternalDistributedMember> recipients =\n+        Collections.singleton((InternalDistributedMember) recipient);\n+    ClearResponse clearResponse = new ClearResponse(region.getSystem(), recipients);\n+    initMessage(region, recipients, false, clearResponse);\n+    setTransactionDistributed(region.getCache().getTxManager().isDistributed());\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"ClearPRMessage.send: recipient is {}, msg is {}\", recipient, this);\n+    }\n+\n+    Set<InternalDistributedMember> failures = region.getDistributionManager().putOutgoing(this);\n+    if (failures != null && failures.size() > 0) {\n+      throw new ForceReattemptException(\"Failed sending <\" + this + \">\");\n+    }\n+    return clearResponse;\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return PR_CLEAR_MESSAGE;\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out, SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    if (bucketId == null) {\n+      InternalDataSerializer.writeSignedVL(-1, out);\n+    } else {\n+      InternalDataSerializer.writeSignedVL(bucketId, out);\n+    }\n+    DataSerializer.writeObject(this.callbackArg, out);\n+    // BR: This may not work properly\n+    DataSerializer.writeObject(regionEvent, out);\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in, DeserializationContext context)\n+      throws IOException, ClassNotFoundException {\n+    super.fromData(in, context);\n+    this.bucketId = (int) InternalDataSerializer.readSignedVL(in);\n+    this.callbackArg = DataSerializer.readObject(in);\n+    this.regionEvent = DataSerializer.readObject(in);\n+  }\n+\n+  @Override\n+  public EventID getEventID() {\n+    return regionEvent.getEventId();\n+  }\n+\n+  /**\n+   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:\n+   * It is very important that this message does NOT cause any deadlocks as the sender will wait\n+   * indefinitely for the acknowledgement\n+   */\n+  @Override\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager distributionManager,", "originalCommit": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3OTA5Mw==", "url": "https://github.com/apache/geode/pull/4689#discussion_r378479093", "bodyText": "OperateOnPartitionedRegion() is invoked by the process() method on the message class which is defined in the parent, and the return value is used to indicate to the Process() method whether or not it needs to construct and send a reply. Since we construct a reply ourselves in both return cases in this method, we don't need a case which returns true.\nIt also doesn't need to throw any ForceReattemptExceptions since it's bundling those in the reply sent from the case in which those are thrown by the doLocalClear() method.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-12T19:54:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5MTg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5MjIyMg==", "url": "https://github.com/apache/geode/pull/4689#discussion_r377992222", "bodyText": "this.isSevereAlertCompatible() is always true for this class, so it can probably be removed from this if statement.", "author": "DonalEvans", "createdAt": "2020-02-12T01:14:43Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.cache.EntryExistsException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.DataLocationException;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  private Object callbackArg;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 100;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+\n+  protected static final short HAS_BRIDGE_CONTEXT = UNRESERVED_FLAGS_START;\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId, boolean notificationOnly, boolean posDup,\n+      Object callbackArg) {\n+    this.bucketId = bucketId;\n+    this.notificationOnly = notificationOnly;\n+    this.posDup = posDup;\n+    this.callbackArg = callbackArg;\n+    initTxMemberId();\n+  }\n+\n+  public void setEventId(RegionEventImpl event) {\n+    regionEvent = event;\n+  }\n+\n+  public void initMessage(PartitionedRegion region, Set<InternalDistributedMember> recipients,\n+      boolean notifyOnly, DirectReplyProcessor replyProcessor) {\n+    this.resetRecipients();\n+    if (recipients != null) {\n+      setRecipients(recipients);\n+    }\n+    this.regionId = region.getPRId();\n+    this.processor = replyProcessor;\n+    this.processorId = replyProcessor == null ? 0 : replyProcessor.getProcessorId();\n+    if (replyProcessor != null && this.isSevereAlertCompatible()) {", "originalCommit": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ4MTgzNA==", "url": "https://github.com/apache/geode/pull/4689#discussion_r378481834", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-12T20:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5MjIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5NDIwMQ==", "url": "https://github.com/apache/geode/pull/4689#discussion_r377994201", "bodyText": "It might be worth including tests to confirm that initMessage() correctly sets the processorId and doesn't call enableSevereAlertProcessing() on the ReplyProcessor if the processor is null, a test to confirm that send() throws an exception if putOutgoing(this) returns a non-null set, a test to confirm that operateOnPartitionedRegion() calls sendReply() with the correct arguments if a ForceReattemptException is thrown during doLocalClear(), a test to confirm that we call endPartitionMessagesProcessing() in sendReply() when appropriate and a test to confirm that we only call replyProcessor.process() in ClearReplyMessage.process() when the replyProcessor is not null.", "author": "DonalEvans", "createdAt": "2020-02-12T01:22:43Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/partitioned/ClearPRMessageTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionDataStore;\n+import org.apache.geode.internal.cache.PartitionedRegionException;\n+\n+public class ClearPRMessageTest {", "originalCommit": "31f29ae77edaab636b0f57129c6ebce2c6b38e1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU3NTk5NA==", "url": "https://github.com/apache/geode/pull/4689#discussion_r378575994", "bodyText": "I added all these tests - a few of them were just making sure that methods weren't called on fields that were null, and these tests felt a little unnecessary (they pretty much just involved calling the method and relying on an NPE to fail) but I've added them anyway just to be safe. Let me know if you think these are unnecessary.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-12T23:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5NDIwMQ=="}], "type": "inlineReview"}, {"oid": "768be1301cce7d7ef095b7a9cb6be6ed2482e9e0", "url": "https://github.com/apache/geode/commit/768be1301cce7d7ef095b7a9cb6be6ed2482e9e0", "message": "Added new message class and test\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-12T23:51:20Z", "type": "commit"}, {"oid": "33b148f69ff632da44f925af713cd7b21d21e748", "url": "https://github.com/apache/geode/commit/33b148f69ff632da44f925af713cd7b21d21e748", "message": "Connected feature to bucket clear functionality\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-12T23:51:20Z", "type": "commit"}, {"oid": "ef12570f190c3575d1368a2549e73f9e4e9b3e7e", "url": "https://github.com/apache/geode/commit/ef12570f190c3575d1368a2549e73f9e4e9b3e7e", "message": "Removed unnessessary changes\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-12T23:51:20Z", "type": "commit"}, {"oid": "5d123434deaef7633e4a2f147e10fa8481ff9129", "url": "https://github.com/apache/geode/commit/5d123434deaef7633e4a2f147e10fa8481ff9129", "message": "Fixed spacing issue with reverted code\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-12T23:51:20Z", "type": "commit"}, {"oid": "63193bbaad24bddbebd977b9343615b82619dc99", "url": "https://github.com/apache/geode/commit/63193bbaad24bddbebd977b9343615b82619dc99", "message": "Disabled transactions for PR Clear Message\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-12T23:51:20Z", "type": "commit"}, {"oid": "512992de0192fa690e0673c5d7dfced4d594270a", "url": "https://github.com/apache/geode/commit/512992de0192fa690e0673c5d7dfced4d594270a", "message": "Made correct cmnClearRegion method public\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-12T23:51:20Z", "type": "commit"}, {"oid": "70e62b1dd219e8ccb6a9a2928c844090ea04a4da", "url": "https://github.com/apache/geode/commit/70e62b1dd219e8ccb6a9a2928c844090ea04a4da", "message": "Addressing initial PR feedback\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-12T23:51:20Z", "type": "commit"}, {"oid": "b0288c39b64558a1ce413f6774e6a13340e562b0", "url": "https://github.com/apache/geode/commit/b0288c39b64558a1ce413f6774e6a13340e562b0", "message": "Added new unit tests recommended in PR feedback\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-12T23:51:20Z", "type": "commit"}, {"oid": "b0288c39b64558a1ce413f6774e6a13340e562b0", "url": "https://github.com/apache/geode/commit/b0288c39b64558a1ce413f6774e6a13340e562b0", "message": "Added new unit tests recommended in PR feedback\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-12T23:51:20Z", "type": "forcePushed"}, {"oid": "f9270048956e58bb4f12acc99799daaa64b496bf", "url": "https://github.com/apache/geode/commit/f9270048956e58bb4f12acc99799daaa64b496bf", "message": "Fix serializable errors\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-13T17:24:03Z", "type": "commit"}, {"oid": "11d8a40a2e491d15001136cfbc6f4f76cd531321", "url": "https://github.com/apache/geode/commit/11d8a40a2e491d15001136cfbc6f4f76cd531321", "message": "Made additional improvements based on PR review\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-13T19:06:28Z", "type": "commit"}, {"oid": "1ab174e346e1841d5bc6b0987c0941b22e10d8f9", "url": "https://github.com/apache/geode/commit/1ab174e346e1841d5bc6b0987c0941b22e10d8f9", "message": "Removed extra serialization code\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-13T19:12:19Z", "type": "commit"}, {"oid": "5bc8f18743d3d02306d31f2ceadd231f51666344", "url": "https://github.com/apache/geode/commit/5bc8f18743d3d02306d31f2ceadd231f51666344", "message": "Additional review changes\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-13T19:44:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA4NzE4MQ==", "url": "https://github.com/apache/geode/pull/4689#discussion_r379087181", "bodyText": "This exception is never thrown from this method, so can be safely removed.", "author": "DonalEvans", "createdAt": "2020-02-13T19:58:49Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/partitioned/ClearPRMessageTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.notNull;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionDataStore;\n+import org.apache.geode.internal.cache.PartitionedRegionStats;\n+\n+public class ClearPRMessageTest {\n+\n+  ClearPRMessage message;\n+  PartitionedRegion region;\n+  PartitionedRegionDataStore dataStore;\n+  BucketRegion bucketRegion;\n+\n+  @Before\n+  public void setup() throws ForceReattemptException {\n+    message = spy(new ClearPRMessage());\n+    region = mock(PartitionedRegion.class, RETURNS_DEEP_STUBS);\n+    dataStore = mock(PartitionedRegionDataStore.class);\n+    when(region.getDataStore()).thenReturn(dataStore);\n+    bucketRegion = mock(BucketRegion.class);\n+    when(dataStore.getInitializedBucketForId(any(), any())).thenReturn(bucketRegion);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenBucketIsNotPrimaryAtFirstCheck() {\n+    when(bucketRegion.isPrimary()).thenReturn(false);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_NON_PRIMARY_MESSAGE);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenLockCannotBeObtained() {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+\n+    when(mockLockService.lock(anyString(), anyLong(), anyLong())).thenReturn(false);\n+    when(bucketRegion.isPrimary()).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenBucketIsNotPrimaryAfterObtainingLock() {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+\n+    // Be primary on the first check, then be not primary on the second check\n+    when(bucketRegion.isPrimary()).thenReturn(true).thenReturn(false);\n+    when(mockLockService.lock(any(), anyLong(), anyLong())).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_NON_PRIMARY_MESSAGE);\n+    // Confirm that we actually obtained and released the lock\n+    verify(mockLockService, times(1)).lock(any(), anyLong(), anyLong());\n+    verify(mockLockService, times(1)).unlock(any());\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsForceReattemptExceptionWhenAnExceptionIsThrownDuringClearOperation()\n+      throws ForceReattemptException {", "originalCommit": "5bc8f18743d3d02306d31f2ceadd231f51666344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1NTgxOA==", "url": "https://github.com/apache/geode/pull/4689#discussion_r379155818", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-13T22:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA4NzE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA4Nzg1Nw==", "url": "https://github.com/apache/geode/pull/4689#discussion_r379087857", "bodyText": "This test isn't trying to verify anything about whether we do or don't obtain locks, just the behaviour when we get an exception from cmnClearRegion(), so these last couple of verifies aren't needed.", "author": "DonalEvans", "createdAt": "2020-02-13T20:00:11Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/partitioned/ClearPRMessageTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.notNull;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionDataStore;\n+import org.apache.geode.internal.cache.PartitionedRegionStats;\n+\n+public class ClearPRMessageTest {\n+\n+  ClearPRMessage message;\n+  PartitionedRegion region;\n+  PartitionedRegionDataStore dataStore;\n+  BucketRegion bucketRegion;\n+\n+  @Before\n+  public void setup() throws ForceReattemptException {\n+    message = spy(new ClearPRMessage());\n+    region = mock(PartitionedRegion.class, RETURNS_DEEP_STUBS);\n+    dataStore = mock(PartitionedRegionDataStore.class);\n+    when(region.getDataStore()).thenReturn(dataStore);\n+    bucketRegion = mock(BucketRegion.class);\n+    when(dataStore.getInitializedBucketForId(any(), any())).thenReturn(bucketRegion);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenBucketIsNotPrimaryAtFirstCheck() {\n+    when(bucketRegion.isPrimary()).thenReturn(false);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_NON_PRIMARY_MESSAGE);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenLockCannotBeObtained() {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+\n+    when(mockLockService.lock(anyString(), anyLong(), anyLong())).thenReturn(false);\n+    when(bucketRegion.isPrimary()).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenBucketIsNotPrimaryAfterObtainingLock() {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+\n+    // Be primary on the first check, then be not primary on the second check\n+    when(bucketRegion.isPrimary()).thenReturn(true).thenReturn(false);\n+    when(mockLockService.lock(any(), anyLong(), anyLong())).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_NON_PRIMARY_MESSAGE);\n+    // Confirm that we actually obtained and released the lock\n+    verify(mockLockService, times(1)).lock(any(), anyLong(), anyLong());\n+    verify(mockLockService, times(1)).unlock(any());\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsForceReattemptExceptionWhenAnExceptionIsThrownDuringClearOperation()\n+      throws ForceReattemptException {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+    NullPointerException exception = new NullPointerException(\"Error encountered\");\n+    doThrow(exception).when(bucketRegion).cmnClearRegion(any(), anyBoolean(), anyBoolean());\n+\n+    // Be primary on the first check, then be not primary on the second check\n+    when(bucketRegion.isPrimary()).thenReturn(true);\n+    when(mockLockService.lock(any(), anyLong(), anyLong())).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.EXCEPTION_THROWN_DURING_CLEAR_OPERATION);\n+\n+    // Confirm that cmnClearRegion was called\n+    verify(bucketRegion, times(1)).cmnClearRegion(any(), anyBoolean(), anyBoolean());\n+\n+    // Confirm that we actually obtained and released the lock\n+    verify(mockLockService, times(1)).lock(any(), anyLong(), anyLong());\n+    verify(mockLockService, times(1)).unlock(any());", "originalCommit": "5bc8f18743d3d02306d31f2ceadd231f51666344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1NTg2OA==", "url": "https://github.com/apache/geode/pull/4689#discussion_r379155868", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-13T22:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA4Nzg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA4ODM1Mw==", "url": "https://github.com/apache/geode/pull/4689#discussion_r379088353", "bodyText": "There's an extra line here that could be tidied up.", "author": "DonalEvans", "createdAt": "2020-02-13T20:01:12Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/partitioned/ClearPRMessageTest.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.notNull;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionDataStore;\n+import org.apache.geode.internal.cache.PartitionedRegionStats;\n+\n+public class ClearPRMessageTest {\n+\n+  ClearPRMessage message;\n+  PartitionedRegion region;\n+  PartitionedRegionDataStore dataStore;\n+  BucketRegion bucketRegion;\n+\n+  @Before\n+  public void setup() throws ForceReattemptException {\n+    message = spy(new ClearPRMessage());\n+    region = mock(PartitionedRegion.class, RETURNS_DEEP_STUBS);\n+    dataStore = mock(PartitionedRegionDataStore.class);\n+    when(region.getDataStore()).thenReturn(dataStore);\n+    bucketRegion = mock(BucketRegion.class);\n+    when(dataStore.getInitializedBucketForId(any(), any())).thenReturn(bucketRegion);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenBucketIsNotPrimaryAtFirstCheck() {\n+    when(bucketRegion.isPrimary()).thenReturn(false);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_NON_PRIMARY_MESSAGE);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenLockCannotBeObtained() {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+\n+    when(mockLockService.lock(anyString(), anyLong(), anyLong())).thenReturn(false);\n+    when(bucketRegion.isPrimary()).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE);\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsExceptionWhenBucketIsNotPrimaryAfterObtainingLock() {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+\n+    // Be primary on the first check, then be not primary on the second check\n+    when(bucketRegion.isPrimary()).thenReturn(true).thenReturn(false);\n+    when(mockLockService.lock(any(), anyLong(), anyLong())).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.BUCKET_NON_PRIMARY_MESSAGE);\n+    // Confirm that we actually obtained and released the lock\n+    verify(mockLockService, times(1)).lock(any(), anyLong(), anyLong());\n+    verify(mockLockService, times(1)).unlock(any());\n+  }\n+\n+  @Test\n+  public void doLocalClearThrowsForceReattemptExceptionWhenAnExceptionIsThrownDuringClearOperation()\n+      throws ForceReattemptException {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+    NullPointerException exception = new NullPointerException(\"Error encountered\");\n+    doThrow(exception).when(bucketRegion).cmnClearRegion(any(), anyBoolean(), anyBoolean());\n+\n+    // Be primary on the first check, then be not primary on the second check\n+    when(bucketRegion.isPrimary()).thenReturn(true);\n+    when(mockLockService.lock(any(), anyLong(), anyLong())).thenReturn(true);\n+\n+    assertThatThrownBy(() -> message.doLocalClear(region))\n+        .isInstanceOf(ForceReattemptException.class)\n+        .hasMessageContaining(ClearPRMessage.EXCEPTION_THROWN_DURING_CLEAR_OPERATION);\n+\n+    // Confirm that cmnClearRegion was called\n+    verify(bucketRegion, times(1)).cmnClearRegion(any(), anyBoolean(), anyBoolean());\n+\n+    // Confirm that we actually obtained and released the lock\n+    verify(mockLockService, times(1)).lock(any(), anyLong(), anyLong());\n+    verify(mockLockService, times(1)).unlock(any());\n+  }\n+\n+  @Test\n+  public void doLocalClearInvokesCmnClearRegionWhenBucketIsPrimaryAndLockIsObtained()\n+      throws ForceReattemptException {\n+    DistributedLockService mockLockService = mock(DistributedLockService.class);\n+    doReturn(mockLockService).when(message).getPartitionRegionLockService();\n+", "originalCommit": "5bc8f18743d3d02306d31f2ceadd231f51666344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1NTkwMw==", "url": "https://github.com/apache/geode/pull/4689#discussion_r379155903", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-13T22:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA4ODM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5MzUxMA==", "url": "https://github.com/apache/geode/pull/4689#discussion_r379093510", "bodyText": "I think this comment is probably no longer needed, as it was originally just a placeholder and the thing it's describing is very self-explanatory.", "author": "DonalEvans", "createdAt": "2020-02-13T20:12:35Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/ClearPRMessage.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.internal.cache.partitioned;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+import org.apache.geode.DataSerializer;\n+import org.apache.geode.annotations.VisibleForTesting;\n+import org.apache.geode.cache.CacheException;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.DistributedMember;\n+import org.apache.geode.distributed.internal.ClusterDistributionManager;\n+import org.apache.geode.distributed.internal.DirectReplyProcessor;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.ReplyException;\n+import org.apache.geode.distributed.internal.ReplyMessage;\n+import org.apache.geode.distributed.internal.ReplyProcessor21;\n+import org.apache.geode.distributed.internal.ReplySender;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.Assert;\n+import org.apache.geode.internal.InternalDataSerializer;\n+import org.apache.geode.internal.NanoTimer;\n+import org.apache.geode.internal.cache.BucketRegion;\n+import org.apache.geode.internal.cache.EventID;\n+import org.apache.geode.internal.cache.ForceReattemptException;\n+import org.apache.geode.internal.cache.PartitionedRegion;\n+import org.apache.geode.internal.cache.PartitionedRegionHelper;\n+import org.apache.geode.internal.cache.RegionEventImpl;\n+import org.apache.geode.internal.logging.log4j.LogMarker;\n+import org.apache.geode.internal.serialization.DeserializationContext;\n+import org.apache.geode.internal.serialization.SerializationContext;\n+import org.apache.geode.logging.internal.log4j.api.LogService;\n+\n+public class ClearPRMessage extends PartitionMessageWithDirectReply {\n+  private static final Logger logger = LogService.getLogger();\n+\n+  private RegionEventImpl regionEvent;\n+\n+  private Integer bucketId;\n+\n+  /** The time in ms to wait for a lock to be obtained during doLocalClear() */\n+  public static final int LOCK_WAIT_TIMEOUT_MS = 1000;\n+  public static final String BUCKET_NON_PRIMARY_MESSAGE =\n+      \"The bucket region on target member is no longer primary\";\n+  public static final String BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE =\n+      \"A lock for the bucket region could not be obtained.\";\n+  public static final String EXCEPTION_THROWN_DURING_CLEAR_OPERATION =\n+      \"An exception was thrown during the local clear operation: \";\n+\n+  /**\n+   * state from operateOnRegion that must be preserved for transmission from the waiting pool\n+   */\n+  transient boolean result = false;\n+\n+  /**\n+   * Empty constructor to satisfy {@link DataSerializer}requirements\n+   */\n+  public ClearPRMessage() {}\n+\n+  public ClearPRMessage(int bucketId) {\n+    this.bucketId = bucketId;\n+\n+    // These are both used by the parent class, but don't apply to this message type\n+    this.notificationOnly = false;\n+    this.posDup = false;\n+  }\n+\n+  public void setRegionEvent(RegionEventImpl event) {\n+    regionEvent = event;\n+  }\n+\n+  public void initMessage(PartitionedRegion region, Set<InternalDistributedMember> recipients,\n+      DirectReplyProcessor replyProcessor) {\n+    this.resetRecipients();\n+    if (recipients != null) {\n+      setRecipients(recipients);\n+    }\n+    this.regionId = region.getPRId();\n+    this.processor = replyProcessor;\n+    this.processorId = replyProcessor == null ? 0 : replyProcessor.getProcessorId();\n+    if (replyProcessor != null) {\n+      replyProcessor.enableSevereAlertProcessing();\n+    }\n+  }\n+\n+  @Override\n+  public boolean isSevereAlertCompatible() {\n+    // allow forced-disconnect processing for all cache op messages\n+    return true;\n+  }\n+\n+  public RegionEventImpl getRegionEvent() {\n+    return regionEvent;\n+  }\n+\n+  public ClearResponse send(DistributedMember recipient, PartitionedRegion region)\n+      throws ForceReattemptException {\n+    Set<InternalDistributedMember> recipients =\n+        Collections.singleton((InternalDistributedMember) recipient);\n+    ClearResponse clearResponse = new ClearResponse(region.getSystem(), recipients);\n+    initMessage(region, recipients, clearResponse);\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"ClearPRMessage.send: recipient is {}, msg is {}\", recipient, this);\n+    }\n+\n+    Set<InternalDistributedMember> failures = region.getDistributionManager().putOutgoing(this);\n+    if (failures != null && failures.size() > 0) {\n+      throw new ForceReattemptException(\"Failed sending <\" + this + \">\");\n+    }\n+    return clearResponse;\n+  }\n+\n+  @Override\n+  public int getDSFID() {\n+    return PR_CLEAR_MESSAGE;\n+  }\n+\n+  @Override\n+  public void toData(DataOutput out, SerializationContext context) throws IOException {\n+    super.toData(out, context);\n+    if (bucketId == null) {\n+      InternalDataSerializer.writeSignedVL(-1, out);\n+    } else {\n+      InternalDataSerializer.writeSignedVL(bucketId, out);\n+    }\n+    DataSerializer.writeObject(regionEvent, out);\n+  }\n+\n+  @Override\n+  public void fromData(DataInput in, DeserializationContext context)\n+      throws IOException, ClassNotFoundException {\n+    super.fromData(in, context);\n+    this.bucketId = (int) InternalDataSerializer.readSignedVL(in);\n+    this.regionEvent = DataSerializer.readObject(in);\n+  }\n+\n+  @Override\n+  public EventID getEventID() {\n+    return regionEvent.getEventId();\n+  }\n+\n+  /**\n+   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:\n+   * It is very important that this message does NOT cause any deadlocks as the sender will wait\n+   * indefinitely for the acknowledgement\n+   */\n+  @Override\n+  @VisibleForTesting\n+  protected boolean operateOnPartitionedRegion(ClusterDistributionManager distributionManager,\n+      PartitionedRegion region, long startTime) {\n+    try {\n+      result = doLocalClear(region);\n+    } catch (ForceReattemptException ex) {\n+      sendReply(getSender(), getProcessorId(), distributionManager, new ReplyException(ex), region,\n+          startTime);\n+      return false;\n+    }\n+    sendReply(getSender(), getProcessorId(), distributionManager, null, region, startTime);\n+    return false;\n+  }\n+\n+  public boolean doLocalClear(PartitionedRegion region) throws ForceReattemptException {\n+    // Retrieve local bucket region which matches target bucketId\n+    BucketRegion bucketRegion = region.getDataStore().getInitializedBucketForId(null, bucketId);\n+\n+    // Check if we are primary, throw exception if not\n+    if (!bucketRegion.isPrimary()) {\n+      throw new ForceReattemptException(BUCKET_NON_PRIMARY_MESSAGE);\n+    }\n+\n+    DistributedLockService lockService = getPartitionRegionLockService();\n+    String lockName = bucketRegion.getFullPath();\n+    try {\n+      boolean locked = lockService.lock(lockName, LOCK_WAIT_TIMEOUT_MS, -1);\n+\n+      if (!locked) {\n+        throw new ForceReattemptException(BUCKET_REGION_LOCK_UNAVAILABLE_MESSAGE);\n+      }\n+\n+      // Double check if we are still primary, as this could have changed between our first check\n+      // and obtaining the lock\n+      if (!bucketRegion.isPrimary()) {\n+        throw new ForceReattemptException(BUCKET_NON_PRIMARY_MESSAGE);\n+      }\n+\n+      try {\n+        // call new cmnClearRegion on the target bucket region", "originalCommit": "5bc8f18743d3d02306d31f2ceadd231f51666344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1NTk0Mw==", "url": "https://github.com/apache/geode/pull/4689#discussion_r379155943", "bodyText": "Done.", "author": "BenjaminPerryRoss", "createdAt": "2020-02-13T22:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA5MzUxMA=="}], "type": "inlineReview"}, {"oid": "88982af9a5e4bde9e7a5062c46d854aaf8bdf98b", "url": "https://github.com/apache/geode/commit/88982af9a5e4bde9e7a5062c46d854aaf8bdf98b", "message": "Fixed minor test details\n\nCo-authored-by: Benjamin Ross <bross@pivotal.io>\nCo-authored-by: Donal Evans <doevans@pivotal.io>", "committedDate": "2020-02-13T22:29:12Z", "type": "commit"}]}