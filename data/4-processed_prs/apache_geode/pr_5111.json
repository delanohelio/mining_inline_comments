{"pr_number": 5111, "pr_title": "GEODE-8078: log and report error at the correct place.", "pr_createdAt": "2020-05-13T21:15:29Z", "pr_url": "https://github.com/apache/geode/pull/5111", "timeline": [{"oid": "abad17029387ff0843c011334819a4225472f458", "url": "https://github.com/apache/geode/commit/abad17029387ff0843c011334819a4225472f458", "message": "GEODE-8078: log and report error at the correct place.\n\n* For get operation, if cache is not ready, just don't report any runtime information\n* do not log the CacheClosedException", "committedDate": "2020-05-13T23:21:25Z", "type": "commit"}, {"oid": "abad17029387ff0843c011334819a4225472f458", "url": "https://github.com/apache/geode/commit/abad17029387ff0843c011334819a4225472f458", "message": "GEODE-8078: log and report error at the correct place.\n\n* For get operation, if cache is not ready, just don't report any runtime information\n* do not log the CacheClosedException", "committedDate": "2020-05-13T23:21:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyMjgyOA==", "url": "https://github.com/apache/geode/pull/5111#discussion_r425422828", "bodyText": "I recommend annotating with @VisibleForTesting because the method would probably be private if we didn't need to call it directly for testing.", "author": "kirklund", "createdAt": "2020-05-14T20:51:56Z", "path": "geode-core/src/main/java/org/apache/geode/management/internal/functions/CacheRealizationFunction.java", "diffHunk": "@@ -78,24 +79,44 @@\n   public void execute(FunctionContext<List> context) {\n     AbstractConfiguration cacheElement = (AbstractConfiguration) context.getArguments().get(0);\n     CacheElementOperation operation = (CacheElementOperation) context.getArguments().get(1);\n-    RemoteInputStream jarStream = (RemoteInputStream) context.getArguments().get(2);\n \n-    InternalCache cache = (InternalCache) context.getCache();\n-    try {\n-      if (operation == CacheElementOperation.GET) {\n+    // for get operation, caller is expecting RuntimeInfo\n+    if (operation == CacheElementOperation.GET) {\n+      try {\n+        InternalCache cache = (InternalCache) context.getCache();\n         context.getResultSender().lastResult(executeGet(context, cache, cacheElement));\n-      } else {\n+      } catch (CacheClosedException e) {\n+        // cache not ready or closed already, no need to log and do not return any runtime info\n+        context.getResultSender().lastResult(null);\n+      } catch (Exception e) {\n+        logError(\"Unable to gather runtime information on this member. \", e);\n+        context.getResultSender().lastResult(null);\n+      }\n+    }\n+    // for other operations, caller is expecting RealizationResult\n+    else {\n+      try {\n+        RemoteInputStream jarStream = (RemoteInputStream) context.getArguments().get(2);\n+        InternalCache cache = (InternalCache) context.getCache();\n         context.getResultSender()\n             .lastResult(executeUpdate(context, cache, cacheElement, operation, jarStream));\n+      } catch (CacheClosedException e) {\n+        // cache not ready or closed already, no need to log it\n+        context.getResultSender().lastResult(new RealizationResult()\n+            .setSuccess(false)\n+            .setMessage(e.getMessage()));\n+      } catch (Exception e) {\n+        logError(\"unable to update cache with the configuration.\", e);\n+        context.getResultSender().lastResult(new RealizationResult()\n+            .setSuccess(false)\n+            .setMemberName(context.getMemberName())\n+            .setMessage(e.getMessage()));\n       }\n-    } catch (Exception e) {\n-      logger.error(e.getMessage(), e);\n-      context.getResultSender().lastResult(new RealizationResult()\n-          .setSuccess(false)\n-          .setMemberName(context.getMemberName())\n-          .setMessage(e.getMessage()));\n     }\n+  }\n \n+  void logError(String s, Exception e) {", "originalCommit": "abad17029387ff0843c011334819a4225472f458", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyOTkzMA==", "url": "https://github.com/apache/geode/pull/5111#discussion_r425429930", "bodyText": "I recommend using GeodeAwaitility instead of a while-loop without timeout (I realize that ConcurrencyRule is ultimately providing the cancellation):\nawait()\n  .ignoreException(ClusterManagementException.class)\n  .until(() -> client.get(server0) != null);", "author": "kirklund", "createdAt": "2020-05-14T21:05:19Z", "path": "geode-web-management/src/distributedTest/java/org/apache/geode/management/client/GetStartingMemberTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.client;\n+\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit4.SpringRunner;\n+import org.springframework.test.context.web.WebAppConfiguration;\n+import org.springframework.web.client.RestTemplate;\n+import org.springframework.web.context.WebApplicationContext;\n+\n+import org.apache.geode.management.api.ClusterManagementException;\n+import org.apache.geode.management.api.ClusterManagementGetResult;\n+import org.apache.geode.management.api.ClusterManagementService;\n+import org.apache.geode.management.api.RestTemplateClusterManagementServiceTransport;\n+import org.apache.geode.management.configuration.Member;\n+import org.apache.geode.management.internal.rest.LocatorWebContext;\n+import org.apache.geode.management.internal.rest.PlainLocatorContextLoader;\n+import org.apache.geode.management.runtime.MemberInformation;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.junit.rules.ConcurrencyRule;\n+\n+@RunWith(SpringRunner.class)\n+@ContextConfiguration(locations = {\"classpath*:WEB-INF/management-servlet.xml\"},\n+    loader = PlainLocatorContextLoader.class)\n+@WebAppConfiguration\n+@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)\n+public class GetStartingMemberTest {\n+\n+  @Autowired\n+  private WebApplicationContext webApplicationContext;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(1);\n+\n+  @Rule\n+  public ConcurrencyRule concurrency = new ConcurrencyRule();\n+\n+  private ClusterManagementService client;\n+  private LocatorWebContext webContext;\n+\n+  @Before\n+  public void before() {\n+    cluster.setSkipLocalDistributedSystemCleanup(true);\n+    webContext = new LocatorWebContext(webApplicationContext);\n+    client = new ClusterManagementServiceBuilder().setTransport(\n+        new RestTemplateClusterManagementServiceTransport(\n+            new RestTemplate(webContext.getRequestFactory())))\n+        .build();\n+  }\n+\n+  @Test\n+  public void getStartingMember() throws Exception {\n+    Member server0 = new Member();\n+    server0.setId(\"server-0\");\n+    concurrency.add(() -> cluster.startServerVM(0, webContext.getLocator().getPort()));\n+    concurrency.add(() -> {\n+      ClusterManagementGetResult<Member, MemberInformation> result = null;\n+      while (result == null) {", "originalCommit": "abad17029387ff0843c011334819a4225472f458", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzNjUzNQ==", "url": "https://github.com/apache/geode/pull/5111#discussion_r425436535", "bodyText": "ExecutorServiceRule would really clean this up and I think we should look into merging these two rules. In general, I think ExecutorServiceRule is preferable (I can explain outside of PR). If you switch to ExecutorServiceRule the test could use an assertion in await and seems much more readable to me:\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static org.apache.geode.test.awaitility.GeodeAwaitility.await;\nimport static org.assertj.core.api.Assertions.assertThat;\n\n  @Rule\n  public ExecutorServiceRule executorServiceRule = new ExecutorServiceRule();\n\n  @Test\n  public void getStartingMember() throws Exception {\n    Member server0 = new Member();\n    server0.setId(\"server-0\");\n\n    Future<Void> startServer = executorServiceRule.submit(() -> {\n      cluster.startServerVM(0, webContext.getLocator().getPort());\n    });\n\n    await()\n        .ignoreException(ClusterManagementException.class)\n        .untilAsserted(() -> assertThat(client.get(server0)).isNotNull());\n\n    startServer.get(getTimeout().toMillis(), MILLISECONDS);\n  }", "author": "kirklund", "createdAt": "2020-05-14T21:18:40Z", "path": "geode-web-management/src/distributedTest/java/org/apache/geode/management/client/GetStartingMemberTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package org.apache.geode.management.client;\n+\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit4.SpringRunner;\n+import org.springframework.test.context.web.WebAppConfiguration;\n+import org.springframework.web.client.RestTemplate;\n+import org.springframework.web.context.WebApplicationContext;\n+\n+import org.apache.geode.management.api.ClusterManagementException;\n+import org.apache.geode.management.api.ClusterManagementGetResult;\n+import org.apache.geode.management.api.ClusterManagementService;\n+import org.apache.geode.management.api.RestTemplateClusterManagementServiceTransport;\n+import org.apache.geode.management.configuration.Member;\n+import org.apache.geode.management.internal.rest.LocatorWebContext;\n+import org.apache.geode.management.internal.rest.PlainLocatorContextLoader;\n+import org.apache.geode.management.runtime.MemberInformation;\n+import org.apache.geode.test.dunit.rules.ClusterStartupRule;\n+import org.apache.geode.test.junit.rules.ConcurrencyRule;\n+\n+@RunWith(SpringRunner.class)\n+@ContextConfiguration(locations = {\"classpath*:WEB-INF/management-servlet.xml\"},\n+    loader = PlainLocatorContextLoader.class)\n+@WebAppConfiguration\n+@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)\n+public class GetStartingMemberTest {\n+\n+  @Autowired\n+  private WebApplicationContext webApplicationContext;\n+\n+  @Rule\n+  public ClusterStartupRule cluster = new ClusterStartupRule(1);\n+\n+  @Rule\n+  public ConcurrencyRule concurrency = new ConcurrencyRule();\n+\n+  private ClusterManagementService client;\n+  private LocatorWebContext webContext;\n+\n+  @Before\n+  public void before() {\n+    cluster.setSkipLocalDistributedSystemCleanup(true);\n+    webContext = new LocatorWebContext(webApplicationContext);\n+    client = new ClusterManagementServiceBuilder().setTransport(\n+        new RestTemplateClusterManagementServiceTransport(\n+            new RestTemplate(webContext.getRequestFactory())))\n+        .build();\n+  }\n+\n+  @Test\n+  public void getStartingMember() throws Exception {\n+    Member server0 = new Member();\n+    server0.setId(\"server-0\");\n+    concurrency.add(() -> cluster.startServerVM(0, webContext.getLocator().getPort()));\n+    concurrency.add(() -> {\n+      ClusterManagementGetResult<Member, MemberInformation> result = null;\n+      while (result == null) {\n+        try {\n+          result = client.get(server0);\n+        } catch (ClusterManagementException e) {\n+          // this is expected for the first several tries\n+        }\n+      }\n+      return result;\n+    });\n+    concurrency.executeInParallel();", "originalCommit": "abad17029387ff0843c011334819a4225472f458", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4MTMxMQ==", "url": "https://github.com/apache/geode/pull/5111#discussion_r425481311", "bodyText": "Great, thank you so much!", "author": "jinmeiliao", "createdAt": "2020-05-14T23:16:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzNjUzNQ=="}], "type": "inlineReview"}, {"oid": "2efa6bbdf21583a1fbf4095cc85acc9655ee5c8b", "url": "https://github.com/apache/geode/commit/2efa6bbdf21583a1fbf4095cc85acc9655ee5c8b", "message": "review changes", "committedDate": "2020-05-14T23:16:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUwOTU4Mg==", "url": "https://github.com/apache/geode/pull/5111#discussion_r425509582", "bodyText": "I am not sure the CacheClosedException in the JIRA is thrown this function. This function does not call ResultSender.sendException() to the caller. How can the caller LocatorClusterManagementService get the CacheClosedException and then ClassCastException?", "author": "jchen21", "createdAt": "2020-05-15T00:59:08Z", "path": "geode-core/src/main/java/org/apache/geode/management/internal/functions/CacheRealizationFunction.java", "diffHunk": "@@ -78,24 +79,44 @@\n   public void execute(FunctionContext<List> context) {\n     AbstractConfiguration cacheElement = (AbstractConfiguration) context.getArguments().get(0);\n     CacheElementOperation operation = (CacheElementOperation) context.getArguments().get(1);\n-    RemoteInputStream jarStream = (RemoteInputStream) context.getArguments().get(2);\n \n-    InternalCache cache = (InternalCache) context.getCache();\n-    try {\n-      if (operation == CacheElementOperation.GET) {\n+    // for get operation, caller is expecting RuntimeInfo\n+    if (operation == CacheElementOperation.GET) {\n+      try {\n+        InternalCache cache = (InternalCache) context.getCache();\n         context.getResultSender().lastResult(executeGet(context, cache, cacheElement));\n-      } else {\n+      } catch (CacheClosedException e) {", "originalCommit": "abad17029387ff0843c011334819a4225472f458", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUzNzEzNw==", "url": "https://github.com/apache/geode/pull/5111#discussion_r425537137", "bodyText": "I am not sure the CacheClosedException in the JIRA is thrown this function. This function does not call ResultSender.sendException() to the caller. How can the caller LocatorClusterManagementService get the CacheClosedException and then ClassCastException?\n\nthe exception is thrown by context.getCache() method, \n  \n    \n      geode/geode-core/src/main/java/org/apache/geode/internal/cache/execute/FunctionContextImpl.java\n    \n    \n         Line 109\n      in\n      ba8a552\n    \n    \n    \n    \n\n        \n          \n           throw new CacheClosedException(\"FunctionContext does not have a valid Cache\"); \n        \n    \n  \n\n. Before the fix, the exception is thrown and caught by the function executor and then it directly gave the exception back to the caller, but caller is expecting a RuntimeInfo object and tried to cast the exception to RuntimeInfo, thus the error.", "author": "jinmeiliao", "createdAt": "2020-05-15T02:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUwOTU4Mg=="}], "type": "inlineReview"}]}