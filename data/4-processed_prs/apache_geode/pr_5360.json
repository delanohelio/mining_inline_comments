{"pr_number": 5360, "pr_title": "GEODE-8329: Fix for durable CQ reqistration recovery", "pr_createdAt": "2020-07-09T05:50:20Z", "pr_url": "https://github.com/apache/geode/pull/5360", "timeline": [{"oid": "f86067e623fb5fce67cd19a802165879d8d005e5", "url": "https://github.com/apache/geode/commit/f86067e623fb5fce67cd19a802165879d8d005e5", "message": "GEODE-8329: Fix for durable CQ reqistration recovery\n\nThis change solves the issue when the client without configured HA is\nwrongly re-registering durable CQs as non durable during the server\nfailover.", "committedDate": "2020-07-09T05:21:25Z", "type": "commit"}, {"oid": "692b7e7eb1cfd6ad7b3d31219dbec5f8529ec93b", "url": "https://github.com/apache/geode/commit/692b7e7eb1cfd6ad7b3d31219dbec5f8529ec93b", "message": "Fix for stressTest", "committedDate": "2020-07-09T12:56:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzODgyOQ==", "url": "https://github.com/apache/geode/pull/5360#discussion_r452538829", "bodyText": "The value for \"isDurable\" is passed by the caller. If you look into the only caller of this method; it calls the \"recoverCQs\" twice if the client is durable, with isDurable value as true. Not sure why its doing twice...\nThis method is also called while satisfying the redundancy-level, which is not related to client durability.\nSay if the redundancy is set to 5 and there are only 3 servers available; when a new server is added to the cluster this code is executed to satisfy the redundancy. You could try adding test scenario for this.\nAlso, isDurable is the meta-info sent to server to say if its durable client (in this context).\nIn QueueManagerImpl can you try changing the following method:\nprivate void recoverAllInterestTypes(final Connection recoveredConnection,\n      boolean isFirstNewConnection) {\n    if (PoolImpl.BEFORE_RECOVER_INTEREST_CALLBACK_FLAG) {\n      ClientServerObserver bo = ClientServerObserverHolder.getInstance();\n      bo.beforeInterestRecovery();\n    }\n    recoverInterestList(recoveredConnection, false, true, isFirstNewConnection);\n    recoverInterestList(recoveredConnection, false, false, isFirstNewConnection);\n    recoverCqs(recoveredConnection, false);\n    if (getPool().isDurableClient()) {\n      recoverInterestList(recoveredConnection, true, true, isFirstNewConnection);\n      recoverInterestList(recoveredConnection, true, false, isFirstNewConnection);\n      recoverCqs(recoveredConnection, true);\n    }\n  }\n\nTO\n\n private void recoverAllInterestTypes(final Connection recoveredConnection,\n      boolean isFirstNewConnection) {\n    if (PoolImpl.BEFORE_RECOVER_INTEREST_CALLBACK_FLAG) {\n      ClientServerObserver bo = ClientServerObserverHolder.getInstance();\n      bo.beforeInterestRecovery();\n    }\n\n    boolean isDurableClient = getPool().isDurableClient();\n    recoverInterestList(recoveredConnection, isDurableClient, true, isFirstNewConnection);\n    recoverInterestList(recoveredConnection, isDurableClient, false, isFirstNewConnection);\n    recoverCqs(recoveredConnection, isDurableClient);\n  }", "author": "agingade", "createdAt": "2020-07-09T23:13:06Z", "path": "geode-core/src/main/java/org/apache/geode/cache/client/internal/QueueManagerImpl.java", "diffHunk": "@@ -1112,7 +1112,8 @@ private void recoverCqs(Connection recoveredConnection, boolean isDurable) {\n             .set(((DefaultQueryService) this.pool.getQueryService()).getUserAttributes(name));\n       }\n       try {\n-        if (((CqStateImpl) cqi.getState()).getState() != CqStateImpl.INIT) {\n+        if (((CqStateImpl) cqi.getState()).getState() != CqStateImpl.INIT", "originalCommit": "692b7e7eb1cfd6ad7b3d31219dbec5f8529ec93b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczNDgyOA==", "url": "https://github.com/apache/geode/pull/5360#discussion_r452734828", "bodyText": "Hi @agingade ,\nThanks for your comments!\nMy understanding was that it is possible to configure durable client identity with the combination of non-durable and durable CQs/Interests. For Example the parameters and API used to configure durable client identity, CQs and region Interests :\n// API\nregisterInterestForAllKeys(InterestResultPolicy policy, boolean isDurable)\nnewCq(String queryString, CqAttributes cqAttr, boolean isDurable)\n// Parameters\ndurable-client-id, durable-client-timeout\n\nIf you look at the recoverAllInterestTypes function code with this in mind, then the code there make sense:\n\nFirst register non-durable CQs and Interests\nIn case of durable client identity, then also register durable CQs and Interests (Not possible to have durable CQ/Interests without durable client identity)\n\nAlso when we look deeper at function level in the recoverInterestList->recoverSingleList->getRegionToInterestsMap->getInterestLookupIndex(isDurable, receiveUpdatesAsInvalidates) :\npublic static int getInterestLookupIndex(boolean isDurable, boolean receiveUpdatesAsInvalidates) {\n  if (isDurable) {\n    if (receiveUpdatesAsInvalidates) {\n      return durableInterestListIndexForUpdatesAsInvalidates;\n    } else {\n      return durableInterestListIndex;\n    }\n  } else {\n    if (receiveUpdatesAsInvalidates) {\n      return interestListIndexForUpdatesAsInvalidates;\n    } else {\n      return interestListIndex;\n    }\n  }\n}\n\nIt filters Interest lists based on the durable flag. So in recoverAllInterestTypes function this would result that the non-durable Interests are recovered first, and then the durable (If durable client identity is configured).\nMy solution was to simply follow this approach with CQs and to first register non-durable CQs, and then durable. I have used CqQuery.isDurable() flag since it is set with following API:\nnewCq(String queryString, CqAttributes cqAttr, **boolean isDurable**)\nI think that the code you proposed would not register non-durable Interests, and would register only durable Interests in case durable client is configured. Additionally in case of durable client, it would register all CQs as durable (even those that are configured as non-durable). I will try to perform some test with the solution you proposed, since there are couple cases it will take some time.\nRelated to your comment about redundancy, I have already tested with configured redundancy and didn't observe any problem in that case. I will take a look at that case in more details, since it seems that the recovery of CQs and Interests is performed differently than when redundancy is not configured for subscriptions event queues.\nBR/Jakov", "author": "jvarenina", "createdAt": "2020-07-10T09:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzODgyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyODU5Ng==", "url": "https://github.com/apache/geode/pull/5360#discussion_r453128596", "bodyText": "Thanks for pointing \"isDurable\" as argument to the CQ API. I missed it.\nYou are right, even though the client is durable the CQs and Interests doesn't have to be durable. Based on this condition either they need to be registered as durable or non-durable on durable client.\nIf you look into, how the recoverCQ is performed, it is done in one go. Its not like register non-durable CQs first and durable CQs next. Please point me if I missed the code path.\nAnd looking at the code, looks like the durable value passed by user is ignored.\nThe code change I suggested with \"recoverAllInterestTypes\" looks right. With additional code change in:\nprivate void recoverCqs(Connection recoveredConnection, boolean isDurable) {\n -\n -\n  // Change\n cqi.createOn(recoveredConnection, isDurable);\n // TO:\n cqi.createOn(recoveredConnection, (isDurable && cqi.isDurable());\n}\n\nAlso, you may want to look at the \"CreateCQOp.execute()\"\nThis is called when CQ is executed and while during redundancy-recovery. In case of execute, it seems to take the isDurable value set while creating the CQ into consideration not the client durability. Not sure if there are any additional mechanism in server side to know if its a durable client and only use the isDurable value passed during the CQ/interest creation.", "author": "agingade", "createdAt": "2020-07-11T00:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzODgyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ4OTgwNA==", "url": "https://github.com/apache/geode/pull/5360#discussion_r453489804", "bodyText": "I have tested TC with redundancy configured and it seems that the recovery of CQs is done a differently in this case. The primary server sends within InitialImageOperation$FilterInfoMessage all releveant CQs information to the starting server. At the reception of the message the starting server then registers CQs as durable (so no problem in this case observed).\nPrimary server:\n[debug 2020/07/10 13:30:54.916 CEST <P2P message reader for 192.168.1.102(server3:31347)<v4>:41001 shared unordered uid=1 local port=53683 remote port=45674> tid=0x57] Received message 'InitialImageOperation$RequestFilterInfoMessage(region path='/_gfe_durable_client_with_id_AppCounters_1_queue'; sender=192.168.1.102(server3:31347)<v4>:41001; processorId=27)' from <192.168.1.102(server3:31347)<v4>:41001>\n\nStarting server:\n[debug 2020/07/10 13:30:54.916 CEST <Client Queue Initialization Thread 1> tid=0x48] Sending (InitialImageOperation$RequestFilterInfoMessage(region path='/_gfe_durable_client_with_id_AppCounters_1_queue'; sender=192.168.1.102(server3:31347)<v4>:41001; processorId=27)) to 1 peers ([192.168.1.102(server1:30862)<v1>:41000]) via tcp/ip\n\n[debug 2020/07/10 13:30:54.918 CEST <P2P message reader for 192.168.1.102(server1:30862)<v1>:41000 shared unordered uid=5 local port=52175 remote port=46552> tid=0x30] Received message 'InitialImageOperation$FilterInfoMessage processorId=27 from 192.168.1.102(server1:30862)<v1>:41000; NON_DURABLE allKeys=0; allKeysInv=0; keysOfInterest=0; keysOfInterestInv=0; patternsOfInterest=0; patternsOfInterestInv=0; filtersOfInterest=0; filtersOfInterestInv=0; DURABLE allKeys=0; allKeysInv=0; keysOfInterest=0; keysOfInterestInv=0; patternsOfInterest=0; patternsOfInterestInv=0; filtersOfInterest=0; filtersOfInterestInv=0; cqs=1' from <192.168.1.102(server1:30862)<v1>:41000>\n\n[debug 2020/07/10 13:30:54.919 CEST <Pooled High Priority Message Processor 3> tid=0x3d] Processing FilterInfo for proxy: CacheClientProxy[identity(192.168.1.102(31226:loner):45576:8b927d38,connection=1,durableAttributes=DurableClientAttributes[id=AppCounters; timeout=200]); port=57552; primary=false; version=GEODE 1.12.0] : InitialImageOperation$FilterInfoMessage processorId=27 from 192.168.1.102(server1:30862)<v1>:41000; NON_DURABLE allKeys=0; allKeysInv=0; keysOfInterest=0; keysOfInterestInv=0; patternsOfInterest=0; patternsOfInterestInv=0; filtersOfInterest=0; filtersOfInterestInv=0; DURABLE allKeys=0; allKeysInv=0; keysOfInterest=0; keysOfInterestInv=0; patternsOfInterest=0; patternsOfInterestInv=0; filtersOfInterest=0; filtersOfInterestInv=0; cqs=1\n\n[debug 2020/07/10 13:30:54.944 CEST <Pooled High Priority Message Processor 3> tid=0x3d] Server side query for the cq: randomTracker is: SELECT * FROM /example-region i where i > 70\n[debug 2020/07/10 13:30:54.944 CEST <Pooled High Priority Message Processor 3> tid=0x3d] Added CQ to the base region: /example-region With key as: randomTracker__AppCounters\n[debug 2020/07/10 13:30:54.944 CEST <Pooled High Priority Message Processor 3> tid=0x3d] Adding CQ into MatchingCQ map, CQName: randomTracker__AppCounters Number of matched querys are: 1\n[debug 2020/07/10 13:30:54.945 CEST <Pooled High Priority Message Processor 3> tid=0x3d] Adding to CQ Repository. CqName : randomTracker ServerCqName : randomTracker__AppCounters\n[debug 2020/07/10 13:30:54.945 CEST <Pooled High Priority Message Processor 3> tid=0x3d] Adding CQ randomTracker__AppCounters to this members FilterProfile.\n[debug 2020/07/10 13:30:54.945 CEST <Pooled High Priority Message Processor 3> tid=0x3d] Successfully created CQ on the server. CqName : randomTracker\n\nI can attach full logs if you need. Also, I have found the the following comment in the client code:\n// Even though the new redundant queue will usually recover\n// subscription information (see bug #39014) from its initial\n// image provider, in bug #42280 we found that this is not always\n// the case, so clients must always register interest with the new\n// redundant server.\nif (recoverInterest) {\n  recoverInterest(queueConnection, isFirstNewConnection);\n}\n\nIt is stated here the there is possible case when redundant queue isn't recovered by InitialImageOperation$FilterInfoMessage, but I haven't been able to reproduce that case. Do you see any benefit in finding and creating TC for this scenario, since recovery of durable CQ is already tested with TC without redundancy?", "author": "jvarenina", "createdAt": "2020-07-13T08:44:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzODgyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwNzM5OQ==", "url": "https://github.com/apache/geode/pull/5360#discussion_r453607399", "bodyText": "Thanks for your comments!\nRelated to the Interest recovery, I have tried following case:\nStart three servers. Start client with following config:\n- redundnacy set to 0\n- register non-durable Interests\n- configure durable id\n\nAfter I shutdown primary server I expected that the client should register/recover Interests on the another running server. I have tried exactly same case with and without the code you suggested. What I have noticed that some steps are missing related to the recovery of non-durable Interest when using solution you suggested (please check logs below). Is this expected?\nwithout your code:\n[debug 2020/07/13 13:56:37.574 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] SubscriptionManager redundancy satisfier - Non backup server was made primary. Recovering interest jakov:26486\n[info 2020/07/13 13:56:37.574 CEST <Cache Client Updater Thread  on 192.168.1.101(12538)<v4>:41002 port 26486> tid=0x5b] Cache Client Updater Thread  on 192.168.1.101(12538)<v4>:41002 port 26486 (jakov:26486) : ready to process messages.\n[debug 2020/07/13 13:56:37.576 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] org.apache.geode.cache.client.internal.QueueManagerImpl@69610f07.recoverSingleRegion starting kind=KEY region=/HAInterestBaseTest_region: {k1=KEYS, k2=KEYS}\n[debug 2020/07/13 13:56:37.576 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] registerInterestsStarted: new count = 1\n[debug 2020/07/13 13:56:37.578 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] localDestroyNoCallbacks key=k2\n[debug 2020/07/13 13:56:37.579 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] basicDestroyPart2: k2, version=null\n[debug 2020/07/13 13:56:37.580 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] VersionedThinRegionEntryHeapStringKey1@1f47aafa (key=k2; rawValue=REMOVED_PHASE1; version={v1; rv2; mbr=192.168.1.101(12538)<v4>:41002; time=1594641397170};member=192.168.1.101(12538)<v4>:41002) dispatching event EntryEventImpl[op=LOCAL_DESTROY;region=/HAInterestBaseTest_region;key=k2;callbackArg=null;originRemote=false;originMember=jakov(12395:loner):57906:02b10848]\n[debug 2020/07/13 13:56:37.580 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] localDestroyNoCallbacks key=k1\n[debug 2020/07/13 13:56:37.580 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] basicDestroyPart2: k1, version=null\n[debug 2020/07/13 13:56:37.580 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] VersionedThinRegionEntryHeapStringKey1@5ecf6c9c (key=k1; rawValue=REMOVED_PHASE1; version={v1; rv1; mbr=192.168.1.101(12538)<v4>:41002; time=1594641397148};member=192.168.1.101(12538)<v4>:41002) dispatching event EntryEventImpl[op=LOCAL_DESTROY;region=/HAInterestBaseTest_region;key=k1;callbackArg=null;originRemote=false;originMember=jakov(12395:loner):57906:02b10848]\n[debug 2020/07/13 13:56:37.580 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] org.apache.geode.cache.client.internal.QueueManagerImpl@69610f07.recoverSingleRegion :Endpoint recovered is primary so clearing the keys of interest starting kind=KEY region=/HAInterestBaseTest_region: [k1, k2]\n[debug 2020/07/13 13:56:37.584 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] org.apache.geode.internal.cache.LocalRegion[path='/HAInterestBaseTest_region';scope=LOCAL';dataPolicy=NORMAL; concurrencyChecksEnabled] refreshEntriesFromServerKeys count=2 policy=KEYS\n  k1\n  k2\n[debug 2020/07/13 13:56:37.584 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] refreshEntries region=/HAInterestBaseTest_region\n[debug 2020/07/13 13:56:37.585 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] registerInterestCompleted: new value = 0\n[debug 2020/07/13 13:56:37.585 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] registerInterestCompleted: Signalling end of register-interest\n[debug 2020/07/13 13:56:37.586 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] Primary recovery not needed\n\n\nwith your code:\n[debug 2020/07/13 13:44:20.028 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] SubscriptionManager redundancy satisfier - Non backup server was made primary. Recovering interest jakov:28101\n[info 2020/07/13 13:44:20.028 CEST <Cache Client Updater Thread  on 192.168.1.101(11053)<v4>:41002 port 28101> tid=0x5b] Cache Client Updater Thread  on 192.168.1.101(11053)<v4>:41002 port 28101 (jakov:28101) : ready to process messages.\n[debug 2020/07/13 13:44:20.030 CEST <queueTimer-HAInterestBaseTestPool1> tid=0x5a] Primary recovery not needed", "author": "jvarenina", "createdAt": "2020-07-13T12:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzODgyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkyNjY1Mg==", "url": "https://github.com/apache/geode/pull/5360#discussion_r457926652", "bodyText": "Hi @agingade ,\nHave you had a time to check above comments?", "author": "jvarenina", "createdAt": "2020-07-21T08:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzODgyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkyMjc5Ng==", "url": "https://github.com/apache/geode/pull/5360#discussion_r494922796", "bodyText": "Hi @agingade ,\nSorry for bothering, but this request change hangs here for a long period of time. If you don't have time or my comments are not clear please don't hesitate to contact me, but I would be really grateful if we could decide how to proceed with this PR.", "author": "jvarenina", "createdAt": "2020-09-25T11:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzODgyOQ=="}], "type": "inlineReview"}, {"oid": "6b06eb8169e5d39993ccd4c9aa9d2dde789b855b", "url": "https://github.com/apache/geode/commit/6b06eb8169e5d39993ccd4c9aa9d2dde789b855b", "message": "empty commit to re-launch CI", "committedDate": "2020-12-07T08:08:28Z", "type": "commit"}]}