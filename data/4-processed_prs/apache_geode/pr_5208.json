{"pr_number": 5208, "pr_title": "GEODE-8173: Add unit test (coverage) for PartitionedRegionClear class.", "pr_createdAt": "2020-06-03T19:15:35Z", "pr_url": "https://github.com/apache/geode/pull/5208", "timeline": [{"oid": "46e3c93f2d4c62d24b1fae0339efe6f5546952d1", "url": "https://github.com/apache/geode/commit/46e3c93f2d4c62d24b1fae0339efe6f5546952d1", "message": "GEODE-8173: Add unit test (coverage) for PartitionedRegionClear class.", "committedDate": "2020-06-03T19:09:43Z", "type": "commit"}, {"oid": "1cb8de5194b1ed5fe03b13c924936e57d2cdc2bf", "url": "https://github.com/apache/geode/commit/1cb8de5194b1ed5fe03b13c924936e57d2cdc2bf", "message": "Fixing test issue in PR pipeline.\nThe afterDestroy() could be triggered more than once in a server.\nAnother test case in this test verifies similarlly.", "committedDate": "2020-06-03T21:52:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzI2Ng==", "url": "https://github.com/apache/geode/pull/5208#discussion_r435527266", "bodyText": "Probably should use proper types for the Regions and Sets etc rather than raw types.", "author": "mhansonp", "createdAt": "2020-06-04T20:23:24Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,594 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+  int numBuckets = 2;\n+  PartitionedRegionClear partitionedRegionClear;\n+  DistributionManager distributionManager;\n+  PartitionedRegion partitionedRegion;", "originalCommit": "1cb8de5194b1ed5fe03b13c924936e57d2cdc2bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNTkzNA==", "url": "https://github.com/apache/geode/pull/5208#discussion_r435605934", "bodyText": "Addressed.", "author": "agingade", "createdAt": "2020-06-04T23:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzI2Ng=="}], "type": "inlineReview"}, {"oid": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0", "url": "https://github.com/apache/geode/commit/7bf63222b8acb0c12e38469a7c05819d2b8e2fd0", "message": "Add reveiew comments.", "committedDate": "2020-06-04T23:26:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTY4NQ==", "url": "https://github.com/apache/geode/pull/5208#discussion_r436075685", "bodyText": "I hate the idea of adding methods like this to Regions. It has nothing to do with Region. Maybe Transaction or TransactionManager would be a better place for this method.", "author": "kirklund", "createdAt": "2020-06-05T17:55:44Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/PartitionedRegion.java", "diffHunk": "@@ -10269,4 +10269,8 @@ boolean hasAnyClientsInterested() {\n     return (getRegionAdvisor().hasPRServerWithInterest()\n         || getRegionAdvisor().hasPRServerWithCQs());\n   }\n+\n+  boolean isTransactionDistributed() {", "originalCommit": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDk4NA==", "url": "https://github.com/apache/geode/pull/5208#discussion_r436214984", "bodyText": "Removed the change.", "author": "agingade", "createdAt": "2020-06-06T00:26:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NjM1NA==", "url": "https://github.com/apache/geode/pull/5208#discussion_r436076354", "bodyText": "We should be declaring vars as the interface instead of the impl:\nSet<BucketRegion> bucketRegions = new HashSet<>();", "author": "kirklund", "createdAt": "2020-06-05T17:56:57Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+\n+  private PartitionedRegionClear partitionedRegionClear;\n+  private DistributionManager distributionManager;\n+  private PartitionedRegion partitionedRegion;\n+\n+  @Before\n+  public void setUp() {\n+\n+    partitionedRegion = mock(PartitionedRegion.class);\n+    distributionManager = mock(DistributionManager.class);\n+\n+    when(partitionedRegion.getDistributionManager()).thenReturn(distributionManager);\n+    when(partitionedRegion.getName()).thenReturn(\"prRegion\");\n+\n+    partitionedRegionClear = new PartitionedRegionClear(partitionedRegion);\n+  }\n+\n+  private Set<BucketRegion> setupBucketRegions(\n+      PartitionedRegionDataStore partitionedRegionDataStore,\n+      BucketAdvisor bucketAdvisor) {\n+    final int numBuckets = 2;\n+    HashSet<BucketRegion> bucketRegions = new HashSet<>();", "originalCommit": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTAyMw==", "url": "https://github.com/apache/geode/pull/5208#discussion_r436215023", "bodyText": "Modified in the latest checkin", "author": "agingade", "createdAt": "2020-06-06T00:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NjM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NzU4Mw==", "url": "https://github.com/apache/geode/pull/5208#discussion_r436077583", "bodyText": "You typically want to avoid if-else blocks like this, and separate it into two different tests. One for PR and one for Replicate.\nThe test class is ReplicateCacheListenerDistributedTest. I can't find any PartitionedRegions being created in this test. Does this belong in PRCacheListenerDistributedTest instead?", "author": "kirklund", "createdAt": "2020-06-05T17:59:07Z", "path": "geode-core/src/distributedTest/java/org/apache/geode/cache/ReplicateCacheListenerDistributedTest.java", "diffHunk": "@@ -179,7 +180,13 @@ public void afterRegionDestroyIsInvokedInEveryMember() {\n \n     region.destroyRegion();\n \n-    assertThat(sharedCountersRule.getTotal(REGION_DESTROY)).isEqualTo(expectedRegionDestroys());\n+    if (region instanceof PartitionedRegion) {", "originalCommit": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTA0Mw==", "url": "https://github.com/apache/geode/pull/5208#discussion_r436215043", "bodyText": "Separated the PRCacheListenerDistributedTest", "author": "agingade", "createdAt": "2020-06-06T00:27:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NzU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMDQwNQ==", "url": "https://github.com/apache/geode/pull/5208#discussion_r436210405", "bodyText": "I think this should be releaseClearLockLocal() instead?", "author": "DonalEvans", "createdAt": "2020-06-05T23:56:34Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+\n+  private PartitionedRegionClear partitionedRegionClear;\n+  private DistributionManager distributionManager;\n+  private PartitionedRegion partitionedRegion;\n+\n+  @Before\n+  public void setUp() {\n+\n+    partitionedRegion = mock(PartitionedRegion.class);\n+    distributionManager = mock(DistributionManager.class);\n+\n+    when(partitionedRegion.getDistributionManager()).thenReturn(distributionManager);\n+    when(partitionedRegion.getName()).thenReturn(\"prRegion\");\n+\n+    partitionedRegionClear = new PartitionedRegionClear(partitionedRegion);\n+  }\n+\n+  private Set<BucketRegion> setupBucketRegions(\n+      PartitionedRegionDataStore partitionedRegionDataStore,\n+      BucketAdvisor bucketAdvisor) {\n+    final int numBuckets = 2;\n+    HashSet<BucketRegion> bucketRegions = new HashSet<>();\n+    for (int i = 0; i < numBuckets; i++) {\n+      BucketRegion bucketRegion = mock(BucketRegion.class);\n+      when(bucketRegion.getBucketAdvisor()).thenReturn(bucketAdvisor);\n+      when(bucketRegion.size()).thenReturn(1);\n+      when(bucketRegion.getId()).thenReturn(i);\n+      bucketRegions.add(bucketRegion);\n+    }\n+\n+    when(partitionedRegionDataStore.getAllLocalBucketRegions()).thenReturn(bucketRegions);\n+    when(partitionedRegionDataStore.getAllLocalPrimaryBucketRegions()).thenReturn(bucketRegions);\n+\n+    return bucketRegions;\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsTrueWhenLocked() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(true);\n+    partitionedRegionClear.obtainClearLockLocal(internalDistributedMember);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isTrue();\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsFalseWhenMemberNotInTheSystemRequestsLock() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(false);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isFalse();\n+  }\n+\n+  @Test\n+  public void acquireDistributedClearLockGetsDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.acquireDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).lock(lockName, -1, -1);\n+  }\n+\n+  @Test\n+  public void releaseDistributedClearLockReleasesDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.releaseDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).unlock(lockName);\n+  }\n+\n+  @Test\n+  public void obtainLockForClearGetsLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.obtainLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).obtainClearLockLocal(internalDistributedMember);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void releaseLockForClearReleasesLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.releaseLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).releaseClearLockLocal();\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void clearRegionClearsLocalAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+    RegionVersionVector regionVersionVector = mock(RegionVersionVector.class);\n+\n+    spyPartitionedRegionClear.clearRegion(regionEvent, false, regionVersionVector);\n+\n+    verify(spyPartitionedRegionClear, times(1)).clearRegionLocal(regionEvent);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterFindingAllPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterRetryForPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(false).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(1)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryThrowsPartitionedRegionPartialClearException() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+    when(retryTimer.overMaximum()).thenReturn(true);\n+\n+    Throwable thrown = catchThrowable(() -> partitionedRegionClear.waitForPrimary(retryTimer));\n+\n+    assertThat(thrown)\n+        .isInstanceOf(PartitionedRegionPartialClearException.class)\n+        .hasMessage(\n+            \"Unable to find primary bucket region during clear operation for region: prRegion\");\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void clearRegionLocalCallsClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+\n+    List bucketsCleared = partitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    assertThat(bucketsCleared.size()).isEqualTo(buckets.size());\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void clearRegionLocalRetriesClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    when(spyPartitionedRegionClear.getMembershipChange()).thenReturn(true).thenReturn(false);\n+\n+    List bucketsCleared = spyPartitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    int expectedClears = buckets.size() * 2; /* clear is called twice on each bucket */\n+    assertThat(bucketsCleared.size()).isEqualTo(expectedClears);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(2)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void doAfterClearCallsNotifyClientsWhenClientHaveInterests() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasAnyClientsInterested()).thenReturn(true);\n+    FilterProfile filterProfile = mock(FilterProfile.class);\n+    FilterRoutingInfo filterRoutingInfo = mock(FilterRoutingInfo.class);\n+    when(filterProfile.getFilterRoutingInfoPart1(regionEvent, FilterProfile.NO_PROFILES,\n+        Collections.emptySet())).thenReturn(filterRoutingInfo);\n+    when(filterProfile.getFilterRoutingInfoPart2(filterRoutingInfo, regionEvent)).thenReturn(\n+        filterRoutingInfo);\n+    when(partitionedRegion.getFilterProfile()).thenReturn(filterProfile);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(regionEvent, times(1)).setLocalFilterInfo(any());\n+    verify(partitionedRegion, times(1)).notifyBridgeClients(regionEvent);\n+  }\n+\n+  @Test\n+  public void doAfterClearDispatchesListenerEvents() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasListener()).thenReturn(true);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(partitionedRegion, times(1)).dispatchListenerEvent(\n+        EnumListenerEvent.AFTER_REGION_CLEAR, regionEvent);\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalGetsLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isSameAs(member);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalDoesNotGetLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(false);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isNull();\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(0)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalReleasesLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+    partitionedRegionClear.lockForListenerAndClientNotification.setLocked(member);\n+\n+    partitionedRegionClear.releaseClearLockLocal();\n+\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).releaseLockLocallyForClear(null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalDoesNotReleaseLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);", "originalCommit": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTg1NA==", "url": "https://github.com/apache/geode/pull/5208#discussion_r436215854", "bodyText": "Good catch. Thanks.\nUpdated the test.", "author": "agingade", "createdAt": "2020-06-06T00:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMDQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMDgzMw==", "url": "https://github.com/apache/geode/pull/5208#discussion_r436210833", "bodyText": "Small suggestion; you can instead use Set<InternalDistributedMember> prNodes = Collections.singleton(member); and Set<Node> configNodes = Collections.singleton(node); to condense the code a little.", "author": "DonalEvans", "createdAt": "2020-06-05T23:59:27Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/PartitionedRegionClearTest.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.catchThrowable;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import org.apache.geode.CancelCriterion;\n+import org.apache.geode.cache.PartitionedRegionPartialClearException;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.distributed.DistributedLockService;\n+import org.apache.geode.distributed.internal.DMStats;\n+import org.apache.geode.distributed.internal.DistributionManager;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.distributed.internal.MembershipListener;\n+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;\n+import org.apache.geode.internal.cache.partitioned.RegionAdvisor;\n+import org.apache.geode.internal.cache.versions.RegionVersionVector;\n+\n+public class PartitionedRegionClearTest {\n+\n+\n+  private PartitionedRegionClear partitionedRegionClear;\n+  private DistributionManager distributionManager;\n+  private PartitionedRegion partitionedRegion;\n+\n+  @Before\n+  public void setUp() {\n+\n+    partitionedRegion = mock(PartitionedRegion.class);\n+    distributionManager = mock(DistributionManager.class);\n+\n+    when(partitionedRegion.getDistributionManager()).thenReturn(distributionManager);\n+    when(partitionedRegion.getName()).thenReturn(\"prRegion\");\n+\n+    partitionedRegionClear = new PartitionedRegionClear(partitionedRegion);\n+  }\n+\n+  private Set<BucketRegion> setupBucketRegions(\n+      PartitionedRegionDataStore partitionedRegionDataStore,\n+      BucketAdvisor bucketAdvisor) {\n+    final int numBuckets = 2;\n+    HashSet<BucketRegion> bucketRegions = new HashSet<>();\n+    for (int i = 0; i < numBuckets; i++) {\n+      BucketRegion bucketRegion = mock(BucketRegion.class);\n+      when(bucketRegion.getBucketAdvisor()).thenReturn(bucketAdvisor);\n+      when(bucketRegion.size()).thenReturn(1);\n+      when(bucketRegion.getId()).thenReturn(i);\n+      bucketRegions.add(bucketRegion);\n+    }\n+\n+    when(partitionedRegionDataStore.getAllLocalBucketRegions()).thenReturn(bucketRegions);\n+    when(partitionedRegionDataStore.getAllLocalPrimaryBucketRegions()).thenReturn(bucketRegions);\n+\n+    return bucketRegions;\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsTrueWhenLocked() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(true);\n+    partitionedRegionClear.obtainClearLockLocal(internalDistributedMember);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isTrue();\n+  }\n+\n+  @Test\n+  public void isLockedForListenerAndClientNotificationReturnsFalseWhenMemberNotInTheSystemRequestsLock() {\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(internalDistributedMember)).thenReturn(false);\n+\n+    assertThat(partitionedRegionClear.isLockedForListenerAndClientNotification()).isFalse();\n+  }\n+\n+  @Test\n+  public void acquireDistributedClearLockGetsDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.acquireDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).lock(lockName, -1, -1);\n+  }\n+\n+  @Test\n+  public void releaseDistributedClearLockReleasesDistributedLock() {\n+    DistributedLockService distributedLockService = mock(DistributedLockService.class);\n+    String lockName = PartitionedRegionClear.CLEAR_OPERATION + partitionedRegion.getName();\n+    when(partitionedRegion.getPartitionedRegionLockService()).thenReturn(distributedLockService);\n+\n+    partitionedRegionClear.releaseDistributedClearLock(lockName);\n+\n+    verify(distributedLockService, times(1)).unlock(lockName);\n+  }\n+\n+  @Test\n+  public void obtainLockForClearGetsLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.obtainLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).obtainClearLockLocal(internalDistributedMember);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_LOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void releaseLockForClearReleasesLocalLockAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+\n+    spyPartitionedRegionClear.releaseLockForClear(regionEvent);\n+\n+    verify(spyPartitionedRegionClear, times(1)).releaseClearLockLocal();\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_UNLOCK_FOR_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void clearRegionClearsLocalAndSendsMessageForRemote() throws Exception {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> region = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(region);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    doReturn(Collections.EMPTY_LIST).when(spyPartitionedRegionClear)\n+        .attemptToSendPartitionedRegionClearMessage(regionEvent,\n+            PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+    InternalDistributedMember internalDistributedMember = mock(InternalDistributedMember.class);\n+    when(distributionManager.getId()).thenReturn(internalDistributedMember);\n+    RegionVersionVector regionVersionVector = mock(RegionVersionVector.class);\n+\n+    spyPartitionedRegionClear.clearRegion(regionEvent, false, regionVersionVector);\n+\n+    verify(spyPartitionedRegionClear, times(1)).clearRegionLocal(regionEvent);\n+    verify(spyPartitionedRegionClear, times(1)).sendPartitionedRegionClearMessage(regionEvent,\n+        PartitionedRegionClearMessage.OperationType.OP_PR_CLEAR);\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterFindingAllPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryReturnsAfterRetryForPrimary() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(false).thenReturn(true);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+\n+    partitionedRegionClear.waitForPrimary(retryTimer);\n+\n+    verify(retryTimer, times(1)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void waitForPrimaryThrowsPartitionedRegionPartialClearException() {\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegion.RetryTimeKeeper retryTimer = mock(PartitionedRegion.RetryTimeKeeper.class);\n+    when(retryTimer.overMaximum()).thenReturn(true);\n+\n+    Throwable thrown = catchThrowable(() -> partitionedRegionClear.waitForPrimary(retryTimer));\n+\n+    assertThat(thrown)\n+        .isInstanceOf(PartitionedRegionPartialClearException.class)\n+        .hasMessage(\n+            \"Unable to find primary bucket region during clear operation for region: prRegion\");\n+    verify(retryTimer, times(0)).waitForBucketsRecovery();\n+  }\n+\n+  @Test\n+  public void clearRegionLocalCallsClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+\n+    List bucketsCleared = partitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    assertThat(bucketsCleared.size()).isEqualTo(buckets.size());\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void clearRegionLocalRetriesClearOnLocalPrimaryBucketRegions() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    doNothing().when(partitionedRegionDataStore).lockBucketCreationForRegionClear();\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    PartitionedRegionClear spyPartitionedRegionClear = spy(partitionedRegionClear);\n+    when(spyPartitionedRegionClear.getMembershipChange()).thenReturn(true).thenReturn(false);\n+\n+    List bucketsCleared = spyPartitionedRegionClear.clearRegionLocal(regionEvent);\n+\n+    int expectedClears = buckets.size() * 2; /* clear is called twice on each bucket */\n+    assertThat(bucketsCleared.size()).isEqualTo(expectedClears);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(2)).clear();\n+    }\n+  }\n+\n+  @Test\n+  public void doAfterClearCallsNotifyClientsWhenClientHaveInterests() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasAnyClientsInterested()).thenReturn(true);\n+    FilterProfile filterProfile = mock(FilterProfile.class);\n+    FilterRoutingInfo filterRoutingInfo = mock(FilterRoutingInfo.class);\n+    when(filterProfile.getFilterRoutingInfoPart1(regionEvent, FilterProfile.NO_PROFILES,\n+        Collections.emptySet())).thenReturn(filterRoutingInfo);\n+    when(filterProfile.getFilterRoutingInfoPart2(filterRoutingInfo, regionEvent)).thenReturn(\n+        filterRoutingInfo);\n+    when(partitionedRegion.getFilterProfile()).thenReturn(filterProfile);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(regionEvent, times(1)).setLocalFilterInfo(any());\n+    verify(partitionedRegion, times(1)).notifyBridgeClients(regionEvent);\n+  }\n+\n+  @Test\n+  public void doAfterClearDispatchesListenerEvents() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(partitionedRegion.hasListener()).thenReturn(true);\n+\n+    partitionedRegionClear.doAfterClear(regionEvent);\n+\n+    verify(partitionedRegion, times(1)).dispatchListenerEvent(\n+        EnumListenerEvent.AFTER_REGION_CLEAR, regionEvent);\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalGetsLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isSameAs(member);\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void obtainClearLockLocalDoesNotGetLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(false);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isNull();\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(0)).lockLocallyForClear(partitionedRegion.getDistributionManager(),\n+          partitionedRegion.getMyId(), null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalReleasesLockOnPrimaryBuckets() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    when(distributionManager.isCurrentMember(member)).thenReturn(true);\n+    partitionedRegionClear.lockForListenerAndClientNotification.setLocked(member);\n+\n+    partitionedRegionClear.releaseClearLockLocal();\n+\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(1)).releaseLockLocallyForClear(null);\n+    }\n+  }\n+\n+  @Test\n+  public void releaseClearLockLocalDoesNotReleaseLocksOnPrimaryBucketsWhenMemberIsNotCurrent() {\n+    BucketAdvisor bucketAdvisor = mock(BucketAdvisor.class);\n+    when(bucketAdvisor.hasPrimary()).thenReturn(true);\n+    PartitionedRegionDataStore partitionedRegionDataStore = mock(PartitionedRegionDataStore.class);\n+    Set<BucketRegion> buckets = setupBucketRegions(partitionedRegionDataStore, bucketAdvisor);\n+    when(partitionedRegion.getDataStore()).thenReturn(partitionedRegionDataStore);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+\n+    partitionedRegionClear.obtainClearLockLocal(member);\n+\n+    assertThat(partitionedRegionClear.lockForListenerAndClientNotification.getLockRequester())\n+        .isNull();\n+    for (BucketRegion bucketRegion : buckets) {\n+      verify(bucketRegion, times(0)).releaseLockLocallyForClear(null);\n+    }\n+  }\n+\n+  @Test\n+  public void sendPartitionedRegionClearMessageSendsClearMessageToPRNodes() {\n+    RegionEventImpl regionEvent = mock(RegionEventImpl.class);\n+    when(regionEvent.clone()).thenReturn(mock(RegionEventImpl.class));\n+    Region<String, PartitionRegionConfig> prRoot = mock(Region.class);\n+    when(partitionedRegion.getPRRoot()).thenReturn(prRoot);\n+    InternalDistributedMember member = mock(InternalDistributedMember.class);\n+    RegionAdvisor regionAdvisor = mock(RegionAdvisor.class);\n+    Set<InternalDistributedMember> prNodes = new HashSet<>();\n+    prNodes.add(member);\n+    Node node = mock(Node.class);\n+    when(node.getMemberId()).thenReturn(member);\n+    Set<Node> configNodes = new HashSet<>();\n+    configNodes.add(node);", "originalCommit": "7bf63222b8acb0c12e38469a7c05819d2b8e2fd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTkwNg==", "url": "https://github.com/apache/geode/pull/5208#discussion_r436215906", "bodyText": "Good suggestion. Looks little tidy.", "author": "agingade", "createdAt": "2020-06-06T00:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMDgzMw=="}], "type": "inlineReview"}, {"oid": "7f887cb2bea8c68664ce66c89fbc1b7ee83036b5", "url": "https://github.com/apache/geode/commit/7f887cb2bea8c68664ce66c89fbc1b7ee83036b5", "message": "Changes to address review comments.\n- Separate the PRCacheListenerDistributedTest\n- Call bucket.cmnClearRegion()", "committedDate": "2020-06-06T00:24:50Z", "type": "commit"}, {"oid": "f6f704744cd6e0a28f5f6cdb538bf349e01f75a0", "url": "https://github.com/apache/geode/commit/f6f704744cd6e0a28f5f6cdb538bf349e01f75a0", "message": "Add revew comments", "committedDate": "2020-06-06T00:32:59Z", "type": "commit"}]}