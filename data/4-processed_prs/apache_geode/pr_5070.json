{"pr_number": 5070, "pr_title": "GEODE-8079: Fix DistributedRegion Validations", "pr_createdAt": "2020-05-07T17:12:53Z", "pr_url": "https://github.com/apache/geode/pull/5070", "timeline": [{"oid": "9dac17dbe7139b5c05b770cab5c0c1d89065c964", "url": "https://github.com/apache/geode/commit/9dac17dbe7139b5c05b770cab5c0c1d89065c964", "message": "GEODE-8079: Refactor WanValidationsDUnitTest\n\n- Fixed several warnings.\n- Replaced usages of 'junit.Assert' by 'assertj'.\n- Changed test methods to use more meaningful names.\n- Removed references to old ids used by another ticketing system.", "committedDate": "2020-05-07T17:01:16Z", "type": "commit"}, {"oid": "e06789324d2561f739b341da63a6b9dc1c9d4453", "url": "https://github.com/apache/geode/commit/e06789324d2561f739b341da63a6b9dc1c9d4453", "message": "GEODE-8079: Fix DistributedRegion Validations\n\nAttaching a parallel gateway-sender or async-event-queue to a\nReplicate Region through the AttributesMutator class now throws an\nexception instead of wrongly assigning the dispatcher to the region.\n\n- Fixed minor warnings.\n- Added unit and distributed tests.", "committedDate": "2020-05-07T17:01:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczOTU5Mw==", "url": "https://github.com/apache/geode/pull/5070#discussion_r421739593", "bodyText": "I'm a bit confused regarding the use of AsynchronousEventDispatcher in the parameter comment and the method name. Is that just a grouping of GatewaySender and AsyncEventListener?", "author": "boglesby", "createdAt": "2020-05-07T19:24:50Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DistributedRegion.java", "diffHunk": "@@ -1013,34 +1016,38 @@ public Lock getDistributedLock(Object key) throws IllegalStateException {\n     return new DistributedLock(key);\n   }\n \n-  @Override\n-  public void preInitialize() {\n-    Set<String> allGatewaySenderIds = getAllGatewaySenderIds();\n-\n-    if (!allGatewaySenderIds.isEmpty()) {\n-      for (GatewaySender sender : cache.getAllGatewaySenders()) {\n-        if (sender.isParallel() && allGatewaySenderIds.contains(sender.getId())) {\n-          // Once decided to support REPLICATED regions with parallel\n-          // gateway-sender/asynchronous-event-queue, ShadowPartitionedRegionForUserRR should be\n-          // called and this validation should be removed.\n-          if (sender.getId().contains(AsyncEventQueueImpl.ASYNC_EVENT_QUEUE_PREFIX)) {\n-            throw new AsyncEventQueueConfigurationException(\n-                String.format(\n-                    \"Parallel Async Event Queue %s can not be used with replicated region %s\",\n-\n-                    AsyncEventQueueImpl.getAsyncEventQueueIdFromSenderId(sender.getId()),\n-                    getFullPath()));\n-          } else {\n-            throw new GatewaySenderConfigurationException(\n-                String.format(\n-                    \"Parallel gateway sender %s can not be used with replicated region %s\",\n-                    sender.getId(), getFullPath()));\n-          }\n+  /**\n+   * Validates that the GatewaySender/AsyncEventQueue referenced by the {@param asyncDispatcherId}\n+   * can be attached to this region; that is, verifies that the dispatcher is not configured as\n+   * parallel.\n+   *\n+   * @param asyncDispatcherId Id of the AsynchronousEventDispatcher to validate.", "originalCommit": "e06789324d2561f739b341da63a6b9dc1c9d4453", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxMjY3Mg==", "url": "https://github.com/apache/geode/pull/5070#discussion_r422012672", "bodyText": "Yep, you got it right, the name is basically to group both types of async event dispatchers we currently have (gateway-sender and async-event-listener). I'm happy to change it, though, if a better name comes up \ud83d\udc4d", "author": "jujoramos", "createdAt": "2020-05-08T08:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczOTU5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0OTMwOQ==", "url": "https://github.com/apache/geode/pull/5070#discussion_r422249309", "bodyText": "Thanks for the clarification.", "author": "boglesby", "createdAt": "2020-05-08T16:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczOTU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1NzEyMw==", "url": "https://github.com/apache/geode/pull/5070#discussion_r421757123", "bodyText": "Would it be possible to have a spy DistributedRegion instead of a mock here? While using doCallRealMethod() works now because the validateAsynchronousEventDispatcher() method is entirely self-contained, if at some point in the future it's modified to access a field of DistributedRegion or call some other method in the class, the test will either fail, or pass despite not actually testing the true behaviour of the method.", "author": "DonalEvans", "createdAt": "2020-05-07T19:56:15Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "originalCommit": "e06789324d2561f739b341da63a6b9dc1c9d4453", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzM0Ng==", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027346", "bodyText": "It might be possible but it will require some effort as the DistributedRegion class doesn't have a default constructor and the initialisation logic is not trivial (I tried to do it but need to mock a lot of other objects to avoid getting all kind of exceptions)... I can do it if it becomes a blocker to merge this PR, otherwise I prefer to use the same approach the rest of this test class is using.", "author": "jujoramos", "createdAt": "2020-05-08T08:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1NzEyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIyNjQ3NA==", "url": "https://github.com/apache/geode/pull/5070#discussion_r422226474", "bodyText": "Having looked at the constructor for DistributedRegion I can see that it would be way, way too much work to create a spy. The current approach is fine.", "author": "DonalEvans", "createdAt": "2020-05-08T16:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1NzEyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIyNzQ1NA==", "url": "https://github.com/apache/geode/pull/5070#discussion_r422227454", "bodyText": "\ud83d\udc4d", "author": "jujoramos", "createdAt": "2020-05-08T16:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1NzEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1Nzk3NA==", "url": "https://github.com/apache/geode/pull/5070#discussion_r421757974", "bodyText": "Would it be possible to use a spy rather than a mock here?", "author": "DonalEvans", "createdAt": "2020-05-07T19:57:44Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(\"nonExistingDispatcher\");\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenFoundDispatcherIsSerial() {\n+    String senderId = \"mySender\";\n+    GatewaySender serialSender = mock(GatewaySender.class);\n+    when(serialSender.isParallel()).thenReturn(false);\n+    when(serialSender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders()).thenReturn(Collections.singleton(serialSender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "originalCommit": "e06789324d2561f739b341da63a6b9dc1c9d4453", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzM3NA==", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027374", "bodyText": "See my comments above.", "author": "jujoramos", "createdAt": "2020-05-08T08:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1Nzk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1OTA5Ng==", "url": "https://github.com/apache/geode/pull/5070#discussion_r421759096", "bodyText": "Would it be possible to use a spy rather than a mock here?", "author": "DonalEvans", "createdAt": "2020-05-07T19:59:36Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(\"nonExistingDispatcher\");\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenFoundDispatcherIsSerial() {\n+    String senderId = \"mySender\";\n+    GatewaySender serialSender = mock(GatewaySender.class);\n+    when(serialSender.isParallel()).thenReturn(false);\n+    when(serialSender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders()).thenReturn(Collections.singleton(serialSender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(senderId);\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldThrowExceptionWhenDispatcherIdMatchesAnExistingParallelAsyncEventQueue() {\n+    String senderId = \"senderId\";\n+    String regionPath = \"thisRegion\";\n+    String internalSenderId = getSenderIdFromAsyncEventQueueId(senderId);\n+    GatewaySender parallelAsyncEventQueue = mock(GatewaySender.class);\n+    when(parallelAsyncEventQueue.isParallel()).thenReturn(true);\n+    when(parallelAsyncEventQueue.getId()).thenReturn(internalSenderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(parallelAsyncEventQueue));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "originalCommit": "e06789324d2561f739b341da63a6b9dc1c9d4453", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzM5MQ==", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027391", "bodyText": "See my comments above.", "author": "jujoramos", "createdAt": "2020-05-08T08:52:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1OTA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1OTE1MQ==", "url": "https://github.com/apache/geode/pull/5070#discussion_r421759151", "bodyText": "Would it be possible to use a spy rather than a mock here?", "author": "DonalEvans", "createdAt": "2020-05-07T19:59:42Z", "path": "geode-core/src/test/java/org/apache/geode/internal/cache/DistributedRegionTest.java", "diffHunk": "@@ -180,4 +189,75 @@ public void regionSyncNotInvokedInPerformSynchronizeForLostMemberTaskIfRegionNot\n \n     verify(distributedRegion, never()).synchronizeForLostMember(member, lostMemberVersionID);\n   }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenDispatcherIdCanNotBeFound() {\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(mock(GatewaySender.class)));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(\"nonExistingDispatcher\");\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldDoNothingWhenFoundDispatcherIsSerial() {\n+    String senderId = \"mySender\";\n+    GatewaySender serialSender = mock(GatewaySender.class);\n+    when(serialSender.isParallel()).thenReturn(false);\n+    when(serialSender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders()).thenReturn(Collections.singleton(serialSender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    distributedRegion.validateAsynchronousEventDispatcher(senderId);\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldThrowExceptionWhenDispatcherIdMatchesAnExistingParallelAsyncEventQueue() {\n+    String senderId = \"senderId\";\n+    String regionPath = \"thisRegion\";\n+    String internalSenderId = getSenderIdFromAsyncEventQueueId(senderId);\n+    GatewaySender parallelAsyncEventQueue = mock(GatewaySender.class);\n+    when(parallelAsyncEventQueue.isParallel()).thenReturn(true);\n+    when(parallelAsyncEventQueue.getId()).thenReturn(internalSenderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(parallelAsyncEventQueue));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);\n+    when(distributedRegion.getCache()).thenReturn(internalCache);\n+    when(distributedRegion.getFullPath()).thenReturn(regionPath);\n+    doCallRealMethod().when(distributedRegion).validateAsynchronousEventDispatcher(anyString());\n+\n+    assertThatThrownBy(\n+        () -> distributedRegion.validateAsynchronousEventDispatcher(internalSenderId))\n+            .isInstanceOf(AsyncEventQueueConfigurationException.class)\n+            .hasMessage(\"Parallel Async Event Queue \" + senderId\n+                + \" can not be used with replicated region \" + regionPath);\n+  }\n+\n+  @Test\n+  public void validateAsynchronousEventDispatcherShouldThrowExceptionWhenDispatcherIdMatchesAnExistingParallelGatewaySender() {\n+    String senderId = \"senderId\";\n+    String regionPath = \"thisRegion\";\n+    GatewaySender parallelGatewaySender = mock(GatewaySender.class);\n+    when(parallelGatewaySender.isParallel()).thenReturn(true);\n+    when(parallelGatewaySender.getId()).thenReturn(senderId);\n+    InternalCache internalCache = mock(InternalCache.class);\n+    when(internalCache.getAllGatewaySenders())\n+        .thenReturn(Collections.singleton(parallelGatewaySender));\n+    DistributedRegion distributedRegion = mock(DistributedRegion.class);", "originalCommit": "e06789324d2561f739b341da63a6b9dc1c9d4453", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzQ5Mg==", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027492", "bodyText": "See my comments above.", "author": "jujoramos", "createdAt": "2020-05-08T08:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1OTE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NTcxNQ==", "url": "https://github.com/apache/geode/pull/5070#discussion_r421765715", "bodyText": "Could these tests use CommandStringBuilder to generate their gfsh commands? I find it makes things a little more readable.", "author": "DonalEvans", "createdAt": "2020-05-07T20:12:45Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"", "originalCommit": "e06789324d2561f739b341da63a6b9dc1c9d4453", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzUxMg==", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027512", "bodyText": "Done!.", "author": "jujoramos", "createdAt": "2020-05-08T08:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NTcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjE1Mg==", "url": "https://github.com/apache/geode/pull/5070#discussion_r421766152", "bodyText": "Another place to possibly use CommandStringBuilder.", "author": "DonalEvans", "createdAt": "2020-05-07T20:13:36Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"\n+            + gatewaySenderId)\n+        .statusIsSuccess().doesNotContainOutput(\"Did not complete waiting\");\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the gateway-sender\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --gateway-sender-id=\" + gatewaySenderId)", "originalCommit": "e06789324d2561f739b341da63a6b9dc1c9d4453", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzUyOQ==", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027529", "bodyText": "Done!.", "author": "jujoramos", "createdAt": "2020-05-08T08:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjIzNg==", "url": "https://github.com/apache/geode/pull/5070#discussion_r421766236", "bodyText": "Another place to possibly use CommandStringBuilder.", "author": "DonalEvans", "createdAt": "2020-05-07T20:13:47Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"\n+            + gatewaySenderId)\n+        .statusIsSuccess().doesNotContainOutput(\"Did not complete waiting\");\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the gateway-sender\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --gateway-sender-id=\" + gatewaySenderId)\n+        .statusIsError().containsOutput(\"server-1\", \"Parallel Gateway Sender \" + gatewaySenderId\n+            + \" can not be used with replicated region \" + SEPARATOR + regionName);\n+\n+    // Check the cluster configuration service.\n+    locator.invoke(() -> {\n+      InternalLocator internalLocator = ClusterStartupRule.getLocator();\n+      assertThat(internalLocator).isNotNull();\n+      CacheConfig config =\n+          internalLocator.getConfigurationPersistenceService().getCacheConfig(\"cluster\");\n+\n+      RegionConfig regionConfig = find(config.getRegions(), regionName);\n+      assertThat(regionConfig).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes()).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isNull();\n+    });\n+  }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelAsynchronousEventQueueShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(AsyncEventQueueConfigurationException.class);\n+    String regionName = testName.getMethodName();\n+    String asyncEventQueueName = testName.getMethodName() + \"_asyncEventQueue\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create async-event-queue --parallel=true --persistent=false --listener=org.apache.geode.internal.cache.wan.MyAsyncEventListener --id=\"", "originalCommit": "e06789324d2561f739b341da63a6b9dc1c9d4453", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzU1OQ==", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027559", "bodyText": "Done!.", "author": "jujoramos", "createdAt": "2020-05-08T08:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjQzNQ==", "url": "https://github.com/apache/geode/pull/5070#discussion_r421766435", "bodyText": "Another place to possibly use CommandStringBuilder.", "author": "DonalEvans", "createdAt": "2020-05-07T20:14:09Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandDUnitTest.java", "diffHunk": "@@ -343,4 +346,76 @@ public void alterPartitionPersistentRegionWithParallelNonPersistentGatewaySender\n       assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isBlank();\n     });\n   }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelGatewaySenderShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(GatewaySenderConfigurationException.class);\n+    addIgnoredException(\"could not get remote locator information\");\n+    String regionName = testName.getMethodName();\n+    String gatewaySenderId = testName.getMethodName() + \"_parallelGatewaySender\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create gateway-sender --parallel=true --enable-persistence=false --remote-distributed-system-id=2 --id=\"\n+            + gatewaySenderId)\n+        .statusIsSuccess().doesNotContainOutput(\"Did not complete waiting\");\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the gateway-sender\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --gateway-sender-id=\" + gatewaySenderId)\n+        .statusIsError().containsOutput(\"server-1\", \"Parallel Gateway Sender \" + gatewaySenderId\n+            + \" can not be used with replicated region \" + SEPARATOR + regionName);\n+\n+    // Check the cluster configuration service.\n+    locator.invoke(() -> {\n+      InternalLocator internalLocator = ClusterStartupRule.getLocator();\n+      assertThat(internalLocator).isNotNull();\n+      CacheConfig config =\n+          internalLocator.getConfigurationPersistenceService().getCacheConfig(\"cluster\");\n+\n+      RegionConfig regionConfig = find(config.getRegions(), regionName);\n+      assertThat(regionConfig).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes()).isNotNull();\n+      assertThat(regionConfig.getRegionAttributes().getGatewaySenderIds()).isNull();\n+    });\n+  }\n+\n+  @Test\n+  public void alterReplicateRegionWithParallelAsynchronousEventQueueShouldFailAndDoNotPersistChangesIntoTheClusterConfigurationService() {\n+    addIgnoredException(AsyncEventQueueConfigurationException.class);\n+    String regionName = testName.getMethodName();\n+    String asyncEventQueueName = testName.getMethodName() + \"_asyncEventQueue\";\n+\n+    gfsh.executeAndAssertThat(\n+        \"create async-event-queue --parallel=true --persistent=false --listener=org.apache.geode.internal.cache.wan.MyAsyncEventListener --id=\"\n+            + asyncEventQueueName)\n+        .statusIsSuccess();\n+    locator.waitUntilAsyncEventQueuesAreReadyOnExactlyThisManyServers(asyncEventQueueName, 1);\n+\n+    gfsh.executeAndAssertThat(\"create region --type=REPLICATE --name=\" + regionName)\n+        .statusIsSuccess();\n+    locator.waitUntilRegionIsReadyOnExactlyThisManyServers(SEPARATOR + regionName, 1);\n+\n+    // Associate the async-event-queue\n+    gfsh.executeAndAssertThat(\n+        \"alter region --name=\" + regionName + \" --async-event-queue-id=\" + asyncEventQueueName)", "originalCommit": "e06789324d2561f739b341da63a6b9dc1c9d4453", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzU3NQ==", "url": "https://github.com/apache/geode/pull/5070#discussion_r422027575", "bodyText": "Done!.", "author": "jujoramos", "createdAt": "2020-05-08T08:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc2NjQzNQ=="}], "type": "inlineReview"}, {"oid": "2bd6553a2005c1e51b3ba0675268a89bd85feb30", "url": "https://github.com/apache/geode/commit/2bd6553a2005c1e51b3ba0675268a89bd85feb30", "message": "GEODE-8079: Changes requested by reviewers.", "committedDate": "2020-05-08T08:53:57Z", "type": "commit"}]}