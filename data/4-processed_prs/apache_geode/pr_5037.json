{"pr_number": 5037, "pr_title": "GEODE-8029: Delete orphaned drf files", "pr_createdAt": "2020-05-01T10:40:30Z", "pr_url": "https://github.com/apache/geode/pull/5037", "timeline": [{"oid": "957dd90c8cdda4a8578d94fba658d82df640578a", "url": "https://github.com/apache/geode/commit/957dd90c8cdda4a8578d94fba658d82df640578a", "message": "GEODE-8029: Delete orphaned drf files\n\nThe OpLog initialization now delete unused drf files to prevent the\nproliferation of unused records and files within the system, which\ncan could cause members to fail during startup while recovering\ndisk-stores (especially when they are isolated for gateway-senders).\n\n- Added distributed tests.\n- Delete orphaned drf files when deleting the corresponding\n  crf during recovery.", "committedDate": "2020-05-01T10:39:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyMDIwMA==", "url": "https://github.com/apache/geode/pull/5037#discussion_r418620200", "bodyText": "Instead of having two almost identical methods, might it be better to have one call the other to prevent code duplication? Or maybe mark this one as a test method for now?", "author": "DonalEvans", "createdAt": "2020-05-01T16:30:33Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/DiskStoreImpl.java", "diffHunk": "@@ -4279,6 +4279,28 @@ public static void validate(String name, File[] dirs) throws Exception {\n     }\n   }\n \n+  /**\n+   * Validates the disk-store in offline mode, and returns the validated DiskStore instance.\n+   * This method is an \"almost exact copy\" of {@link DiskStoreImpl#validate(String, File[])}.", "originalCommit": "957dd90c8cdda4a8578d94fba658d82df640578a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzMTg1Mg==", "url": "https://github.com/apache/geode/pull/5037#discussion_r419131852", "bodyText": "Sounds good.", "author": "jujoramos", "createdAt": "2020-05-03T17:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyMDIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyMDc0Ng==", "url": "https://github.com/apache/geode/pull/5037#discussion_r418620746", "bodyText": "This should be \"especially\".", "author": "DonalEvans", "createdAt": "2020-05-01T16:31:48Z", "path": "geode-core/src/main/java/org/apache/geode/internal/cache/Oplog.java", "diffHunk": "@@ -937,14 +937,20 @@ void initAfterRecovery(boolean offline) {\n         // this.crf.raf.seek(this.crf.currSize);\n       } else if (!offline) {\n         // drf exists but crf has been deleted (because it was empty).\n-        // I don't think the drf needs to be opened. It is only used during\n-        // recovery.\n-        // At some point the compacter my identify that it can be deleted.\n         this.crf.RAFClosed = true;\n         deleteCRF();\n+\n+        // See GEODE-8029.\n+        // The drf file needs to be deleted, specially when the disk-store is *only* used by", "originalCommit": "957dd90c8cdda4a8578d94fba658d82df640578a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzMTg2MA==", "url": "https://github.com/apache/geode/pull/5037#discussion_r419131860", "bodyText": "\ud83d\udc4d", "author": "jujoramos", "createdAt": "2020-05-03T17:09:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyMDc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMzEyNA==", "url": "https://github.com/apache/geode/pull/5037#discussion_r418633124", "bodyText": "This test should be renamed.", "author": "DonalEvans", "createdAt": "2020-05-01T16:59:48Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStore;\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.wan.GatewayReceiverFactory;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.cache.wan.GatewaySenderFactory;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskStoreImpl;\n+import org.apache.geode.internal.cache.RegionQueue;\n+import org.apache.geode.internal.cache.persistence.OplogType;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTestName;\n+\n+/**\n+ * Tests to verify WAN functionality when the gateway-sender(s) have isolated, non-shared with\n+ * other region(s), disk-store(s).\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest implements Serializable {\n+  private static final String REGION_NAME = \"TestRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String GATEWAY_SENDER_ID = \"testSender\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(RegionType:{0}, Parallel:{1})\";\n+  private int site1Port, site2Port;\n+  private VM serverCluster1, serverCluster2;\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public SerializableTestName testName = new SerializableTestName();\n+\n+  @Rule\n+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();\n+\n+  private Properties createLocatorConfiguration(int distributedSystemId, int localLocatorPort,\n+      int remoteLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(DISTRIBUTED_SYSTEM_ID, String.valueOf(distributedSystemId));\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(REMOTE_LOCATORS, \"localhost[\" + remoteLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore() {\n+    String basePath = distributedDiskDirRule.getDiskDir().getAbsolutePath();\n+    File diskDirectory = new File(basePath + File.separator + DISK_STORE_ID);\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(new File[] {diskDirectory});\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion(RegionShortcut regionShortcut) {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(regionShortcut)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createGatewayReceiver() {\n+    GatewayReceiverFactory gatewayReceiverFactory =\n+        cacheRule.getCache().createGatewayReceiverFactory();\n+    gatewayReceiverFactory.setManualStart(false);\n+    gatewayReceiverFactory.create();\n+  }\n+\n+  private void createGatewaySender(boolean parallel, int remoteDistributedSystemId) {\n+    GatewaySenderFactory gatewaySenderFactory = cacheRule.getCache().createGatewaySenderFactory();\n+    gatewaySenderFactory.setParallel(parallel);\n+    gatewaySenderFactory.setDiskSynchronous(true);\n+    gatewaySenderFactory.setPersistenceEnabled(true);\n+    gatewaySenderFactory.setDiskStoreName(DISK_STORE_ID);\n+    gatewaySenderFactory.create(GATEWAY_SENDER_ID, remoteDistributedSystemId);\n+  }\n+\n+  private void createServerWithRegionAndGatewayReceiver(RegionShortcut regionShortcut) {\n+    createGatewayReceiver();\n+    createRegion(regionShortcut);\n+  }\n+\n+  private void createServerWithRegionAndPersistentGatewaySender(RegionShortcut regionShortcut,\n+      int remoteDistributedSystemId, boolean parallel) {\n+    createDiskStore();\n+    createRegion(regionShortcut);\n+    createGatewaySender(parallel, remoteDistributedSystemId);\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.getAttributesMutator().addGatewaySenderId(GATEWAY_SENDER_ID);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  private void awaitForQueueSize(int queueSize) {\n+    GatewaySender gatewaySender = cacheRule.getCache().getGatewaySender(GATEWAY_SENDER_ID);\n+    await().untilAsserted(() -> {\n+      Set<RegionQueue> queues = ((AbstractGatewaySender) gatewaySender).getQueues();\n+      int totalSize = queues.stream().mapToInt(RegionQueue::size).sum();\n+      assertThat(queueSize).isEqualTo(totalSize);\n+    });\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] regionAndGatewayTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    parameters.add(new Object[] {RegionShortcut.PARTITION, true});\n+    parameters.add(new Object[] {RegionShortcut.REPLICATE, false});\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    VM locatorCluster1 = getVM(0);\n+    serverCluster1 = getVM(1);\n+    VM locatorCluster2 = getVM(2);\n+    serverCluster2 = getVM(3);\n+\n+    int[] ports = getRandomAvailableTCPPortsForDUnitSite(2);\n+    site1Port = ports[0];\n+    site2Port = ports[1];\n+\n+    // Start 2 sites, one locator and one server per site.\n+    locatorCluster1\n+        .invoke(() -> cacheRule.createCache(createLocatorConfiguration(1, site1Port, site2Port)));\n+    locatorCluster2\n+        .invoke(() -> cacheRule.createCache(createLocatorConfiguration(2, site2Port, site1Port)));\n+\n+    serverCluster1.invoke(() -> cacheRule.createCache(createServerConfiguration(site1Port)));\n+    serverCluster2.invoke(() -> cacheRule.createCache(createServerConfiguration(site2Port)));\n+  }\n+\n+  /**\n+   * The tests executes the following:\n+   * - Creates region and gateway-receiver on cluster2.\n+   * - Creates the region and gateway-sender on cluster1.\n+   * - Populates the region and waits until WAN replication has finished.\n+   * - Restarts server on cluster1, and stops it afterwards (the initial compaction occurs during\n+   * startup and the disk validation is done offline).\n+   * - Asserts that there are no orphaned drf files, neither compact-able records on the disks-tore.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"regionAndGatewayTypes\")\n+  public void diskStoreShouldBeCompactedOnMemberRestartWhenAllEventsHaveBeenDispatched(\n+      RegionShortcut regionShortcut, boolean parallel) throws Exception {\n+    final int entries = 100;\n+\n+    // Create Region and Receiver on Cluster2\n+    serverCluster2.invoke(() -> createServerWithRegionAndGatewayReceiver(regionShortcut));\n+\n+    // Create Region, DiskStore and Gateway on Cluster1\n+    String diskStorePath = serverCluster1.invoke(() -> {\n+      createServerWithRegionAndPersistentGatewaySender(regionShortcut, 2, parallel);\n+      DiskStore diskStore = cacheRule.getCache().findDiskStore(DISK_STORE_ID);\n+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+\n+      // Insert entries and wait for WAN replication to finish.\n+      IntStream.range(0, entries).forEach(value -> region.put(\"Key\" + value, \"Value\" + value));\n+      awaitForQueueSize(0);\n+\n+      return diskStore.getDiskDirs()[0].getAbsolutePath();\n+    });\n+\n+    // Wait for Cluster2 to receive all events.\n+    serverCluster2.invoke(() -> await().untilAsserted(\n+        () -> assertThat(cacheRule.getCache().getRegion(REGION_NAME).size()).isEqualTo(entries)));\n+\n+    // Restart and Stop Server on Cluster1\n+    serverCluster1.invoke(() -> {\n+      gracefullyDisconnect();\n+      cacheRule.createCache(createServerConfiguration(site1Port));\n+      createServerWithRegionAndPersistentGatewaySender(regionShortcut, 2, parallel);\n+      gracefullyDisconnect();\n+    });\n+\n+    // There should be no orphaned drf files, neither compact-able records on the disk-store.\n+    File gatewayDiskStore = new File(diskStorePath);\n+    assertThat(gatewayDiskStore.list())\n+        .hasSize(3)\n+        .contains(OplogType.BACKUP.getPrefix() + DISK_STORE_ID + \".if\")\n+        .contains(OplogType.BACKUP.getPrefix() + DISK_STORE_ID + \"_2.drf\")\n+        .contains(OplogType.BACKUP.getPrefix() + DISK_STORE_ID + \"_2.crf\");\n+\n+    DiskStore diskStore =\n+        DiskStoreImpl.offlineValidate(DISK_STORE_ID, new File[] {gatewayDiskStore});\n+    assertThat(((DiskStoreImpl) diskStore).getLiveEntryCount()).isEqualTo(0);\n+    assertThat(((DiskStoreImpl) diskStore).getDeadRecordCount()).isEqualTo(0);\n+  }\n+\n+  /**\n+   * The tests executes the following:\n+   * - Creates the region and a gateway-sender on cluster2.\n+   * - Populates the region and waits until all events have been enqueued.\n+   * - Restarts server on cluster2 and stops it afterwards (the initial compaction occurs during\n+   * startup and the validation is done offline).\n+   * - Verifies that there are no orphaned files neither compact-able records on the disk-store.\n+   * - Creates the region and a gateway-receiver on cluster1.\n+   * - Starts server on cluster2 again and waits for WAN replication to finish.\n+   * - Restart server on cluster2, and stop it afterwards (the initial compaction occurs during\n+   * startup and the validation is done offline).\n+   * - Asserts that there are no orphaned drf files, neither compact-able records on the disks-tore.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"regionAndGatewayTypes\")\n+  public void anotherTest(RegionShortcut regionShortcut, boolean parallel) throws Exception {", "originalCommit": "957dd90c8cdda4a8578d94fba658d82df640578a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzMTg3Ng==", "url": "https://github.com/apache/geode/pull/5037#discussion_r419131876", "bodyText": "Good catch, thanks.", "author": "jujoramos", "createdAt": "2020-05-03T17:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMzEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNDg0Ng==", "url": "https://github.com/apache/geode/pull/5037#discussion_r418634846", "bodyText": "What about the cases where the region is PARTITION and parallel is false, or region is REPLICATE and parallel is true? Do those need to be covered?", "author": "DonalEvans", "createdAt": "2020-05-01T17:03:32Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStore;\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.wan.GatewayReceiverFactory;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.cache.wan.GatewaySenderFactory;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskStoreImpl;\n+import org.apache.geode.internal.cache.RegionQueue;\n+import org.apache.geode.internal.cache.persistence.OplogType;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTestName;\n+\n+/**\n+ * Tests to verify WAN functionality when the gateway-sender(s) have isolated, non-shared with\n+ * other region(s), disk-store(s).\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest implements Serializable {\n+  private static final String REGION_NAME = \"TestRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String GATEWAY_SENDER_ID = \"testSender\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(RegionType:{0}, Parallel:{1})\";\n+  private int site1Port, site2Port;\n+  private VM serverCluster1, serverCluster2;\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public SerializableTestName testName = new SerializableTestName();\n+\n+  @Rule\n+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();\n+\n+  private Properties createLocatorConfiguration(int distributedSystemId, int localLocatorPort,\n+      int remoteLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(DISTRIBUTED_SYSTEM_ID, String.valueOf(distributedSystemId));\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(REMOTE_LOCATORS, \"localhost[\" + remoteLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore() {\n+    String basePath = distributedDiskDirRule.getDiskDir().getAbsolutePath();\n+    File diskDirectory = new File(basePath + File.separator + DISK_STORE_ID);\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(new File[] {diskDirectory});\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion(RegionShortcut regionShortcut) {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(regionShortcut)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createGatewayReceiver() {\n+    GatewayReceiverFactory gatewayReceiverFactory =\n+        cacheRule.getCache().createGatewayReceiverFactory();\n+    gatewayReceiverFactory.setManualStart(false);\n+    gatewayReceiverFactory.create();\n+  }\n+\n+  private void createGatewaySender(boolean parallel, int remoteDistributedSystemId) {\n+    GatewaySenderFactory gatewaySenderFactory = cacheRule.getCache().createGatewaySenderFactory();\n+    gatewaySenderFactory.setParallel(parallel);\n+    gatewaySenderFactory.setDiskSynchronous(true);\n+    gatewaySenderFactory.setPersistenceEnabled(true);\n+    gatewaySenderFactory.setDiskStoreName(DISK_STORE_ID);\n+    gatewaySenderFactory.create(GATEWAY_SENDER_ID, remoteDistributedSystemId);\n+  }\n+\n+  private void createServerWithRegionAndGatewayReceiver(RegionShortcut regionShortcut) {\n+    createGatewayReceiver();\n+    createRegion(regionShortcut);\n+  }\n+\n+  private void createServerWithRegionAndPersistentGatewaySender(RegionShortcut regionShortcut,\n+      int remoteDistributedSystemId, boolean parallel) {\n+    createDiskStore();\n+    createRegion(regionShortcut);\n+    createGatewaySender(parallel, remoteDistributedSystemId);\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.getAttributesMutator().addGatewaySenderId(GATEWAY_SENDER_ID);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  private void awaitForQueueSize(int queueSize) {\n+    GatewaySender gatewaySender = cacheRule.getCache().getGatewaySender(GATEWAY_SENDER_ID);\n+    await().untilAsserted(() -> {\n+      Set<RegionQueue> queues = ((AbstractGatewaySender) gatewaySender).getQueues();\n+      int totalSize = queues.stream().mapToInt(RegionQueue::size).sum();\n+      assertThat(queueSize).isEqualTo(totalSize);\n+    });\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] regionAndGatewayTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    parameters.add(new Object[] {RegionShortcut.PARTITION, true});\n+    parameters.add(new Object[] {RegionShortcut.REPLICATE, false});", "originalCommit": "957dd90c8cdda4a8578d94fba658d82df640578a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzMTkzMQ==", "url": "https://github.com/apache/geode/pull/5037#discussion_r419131931", "bodyText": "It doesn't make much sense to use a PARTITION region with a serial gateway-sender, and the other combination is not even supported (REPLICATE region with parallel gateway-sender). I've added the extra supported combination, anyways, it's harmless, and it's always good to have extra tests.", "author": "jujoramos", "createdAt": "2020-05-03T17:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNDg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNTkwOQ==", "url": "https://github.com/apache/geode/pull/5037#discussion_r418635909", "bodyText": "Is one server per cluster enough to test the behaviour with a parallel gateway sender here? Or is this a situation where that's not relevant?", "author": "DonalEvans", "createdAt": "2020-05-01T17:06:04Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStore;\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.wan.GatewayReceiverFactory;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.cache.wan.GatewaySenderFactory;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskStoreImpl;\n+import org.apache.geode.internal.cache.RegionQueue;\n+import org.apache.geode.internal.cache.persistence.OplogType;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTestName;\n+\n+/**\n+ * Tests to verify WAN functionality when the gateway-sender(s) have isolated, non-shared with\n+ * other region(s), disk-store(s).\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest implements Serializable {\n+  private static final String REGION_NAME = \"TestRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String GATEWAY_SENDER_ID = \"testSender\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(RegionType:{0}, Parallel:{1})\";\n+  private int site1Port, site2Port;\n+  private VM serverCluster1, serverCluster2;\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public SerializableTestName testName = new SerializableTestName();\n+\n+  @Rule\n+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();\n+\n+  private Properties createLocatorConfiguration(int distributedSystemId, int localLocatorPort,\n+      int remoteLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(DISTRIBUTED_SYSTEM_ID, String.valueOf(distributedSystemId));\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(REMOTE_LOCATORS, \"localhost[\" + remoteLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore() {\n+    String basePath = distributedDiskDirRule.getDiskDir().getAbsolutePath();\n+    File diskDirectory = new File(basePath + File.separator + DISK_STORE_ID);\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(new File[] {diskDirectory});\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion(RegionShortcut regionShortcut) {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(regionShortcut)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createGatewayReceiver() {\n+    GatewayReceiverFactory gatewayReceiverFactory =\n+        cacheRule.getCache().createGatewayReceiverFactory();\n+    gatewayReceiverFactory.setManualStart(false);\n+    gatewayReceiverFactory.create();\n+  }\n+\n+  private void createGatewaySender(boolean parallel, int remoteDistributedSystemId) {\n+    GatewaySenderFactory gatewaySenderFactory = cacheRule.getCache().createGatewaySenderFactory();\n+    gatewaySenderFactory.setParallel(parallel);\n+    gatewaySenderFactory.setDiskSynchronous(true);\n+    gatewaySenderFactory.setPersistenceEnabled(true);\n+    gatewaySenderFactory.setDiskStoreName(DISK_STORE_ID);\n+    gatewaySenderFactory.create(GATEWAY_SENDER_ID, remoteDistributedSystemId);\n+  }\n+\n+  private void createServerWithRegionAndGatewayReceiver(RegionShortcut regionShortcut) {\n+    createGatewayReceiver();\n+    createRegion(regionShortcut);\n+  }\n+\n+  private void createServerWithRegionAndPersistentGatewaySender(RegionShortcut regionShortcut,\n+      int remoteDistributedSystemId, boolean parallel) {\n+    createDiskStore();\n+    createRegion(regionShortcut);\n+    createGatewaySender(parallel, remoteDistributedSystemId);\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.getAttributesMutator().addGatewaySenderId(GATEWAY_SENDER_ID);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  private void awaitForQueueSize(int queueSize) {\n+    GatewaySender gatewaySender = cacheRule.getCache().getGatewaySender(GATEWAY_SENDER_ID);\n+    await().untilAsserted(() -> {\n+      Set<RegionQueue> queues = ((AbstractGatewaySender) gatewaySender).getQueues();\n+      int totalSize = queues.stream().mapToInt(RegionQueue::size).sum();\n+      assertThat(queueSize).isEqualTo(totalSize);\n+    });\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] regionAndGatewayTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    parameters.add(new Object[] {RegionShortcut.PARTITION, true});\n+    parameters.add(new Object[] {RegionShortcut.REPLICATE, false});\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    VM locatorCluster1 = getVM(0);\n+    serverCluster1 = getVM(1);\n+    VM locatorCluster2 = getVM(2);\n+    serverCluster2 = getVM(3);", "originalCommit": "957dd90c8cdda4a8578d94fba658d82df640578a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzMTk0Mg==", "url": "https://github.com/apache/geode/pull/5037#discussion_r419131942", "bodyText": "It's irrelevant for this scenario, we're interested only in the disk-stores locally used by the servers.", "author": "jujoramos", "createdAt": "2020-05-03T17:10:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNTkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzOTAyMQ==", "url": "https://github.com/apache/geode/pull/5037#discussion_r418639021", "bodyText": "Small nitpick. The number of entries in this test is 100, but in the other test in this class it's 1000. Could they be the same, for consistency?", "author": "DonalEvans", "createdAt": "2020-05-01T17:12:56Z", "path": "geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.geode.internal.cache.wan;\n+\n+import static org.apache.geode.distributed.ConfigurationProperties.DISTRIBUTED_SYSTEM_ID;\n+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;\n+import static org.apache.geode.distributed.ConfigurationProperties.REMOTE_LOCATORS;\n+import static org.apache.geode.distributed.ConfigurationProperties.START_LOCATOR;\n+import static org.apache.geode.internal.AvailablePortHelper.getRandomAvailableTCPPortsForDUnitSite;\n+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;\n+import static org.apache.geode.test.dunit.VM.getVM;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n+import junitparams.naming.TestCaseName;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import org.apache.geode.cache.DiskStore;\n+import org.apache.geode.cache.DiskStoreFactory;\n+import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.RegionShortcut;\n+import org.apache.geode.cache.wan.GatewayReceiverFactory;\n+import org.apache.geode.cache.wan.GatewaySender;\n+import org.apache.geode.cache.wan.GatewaySenderFactory;\n+import org.apache.geode.distributed.internal.InternalDistributedSystem;\n+import org.apache.geode.internal.cache.DiskStoreImpl;\n+import org.apache.geode.internal.cache.RegionQueue;\n+import org.apache.geode.internal.cache.persistence.OplogType;\n+import org.apache.geode.test.dunit.VM;\n+import org.apache.geode.test.dunit.rules.CacheRule;\n+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;\n+import org.apache.geode.test.dunit.rules.DistributedRule;\n+import org.apache.geode.test.junit.rules.serializable.SerializableTestName;\n+\n+/**\n+ * Tests to verify WAN functionality when the gateway-sender(s) have isolated, non-shared with\n+ * other region(s), disk-store(s).\n+ */\n+@RunWith(JUnitParamsRunner.class)\n+public class PersistentGatewaySenderWithIsolatedDiskStoreDistributedTest implements Serializable {\n+  private static final String REGION_NAME = \"TestRegion\";\n+  private static final String DISK_STORE_ID = \"testDisk\";\n+  private static final String GATEWAY_SENDER_ID = \"testSender\";\n+  private static final String TEST_CASE_NAME = \"[{index}] {method}(RegionType:{0}, Parallel:{1})\";\n+  private int site1Port, site2Port;\n+  private VM serverCluster1, serverCluster2;\n+\n+  @Rule\n+  public CacheRule cacheRule = new CacheRule();\n+\n+  @Rule\n+  public DistributedRule distributedRule = new DistributedRule();\n+\n+  @Rule\n+  public SerializableTestName testName = new SerializableTestName();\n+\n+  @Rule\n+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();\n+\n+  private Properties createLocatorConfiguration(int distributedSystemId, int localLocatorPort,\n+      int remoteLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(DISTRIBUTED_SYSTEM_ID, String.valueOf(distributedSystemId));\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+    config.setProperty(REMOTE_LOCATORS, \"localhost[\" + remoteLocatorPort + ']');\n+    config.setProperty(START_LOCATOR,\n+        \"localhost[\" + localLocatorPort + \"],server=true,peer=true,hostname-for-clients=localhost\");\n+\n+    return config;\n+  }\n+\n+  private Properties createServerConfiguration(int localLocatorPort) {\n+    Properties config = new Properties();\n+    config.setProperty(MCAST_PORT, \"0\");\n+    config.setProperty(LOCATORS, \"localhost[\" + localLocatorPort + ']');\n+\n+    return config;\n+  }\n+\n+  private void createDiskStore() {\n+    String basePath = distributedDiskDirRule.getDiskDir().getAbsolutePath();\n+    File diskDirectory = new File(basePath + File.separator + DISK_STORE_ID);\n+    DiskStoreFactory diskStoreFactory = cacheRule.getCache().createDiskStoreFactory();\n+    diskStoreFactory.setAutoCompact(true);\n+    diskStoreFactory.setAllowForceCompaction(true);\n+    diskStoreFactory.setDiskDirs(new File[] {diskDirectory});\n+    diskStoreFactory.create(DISK_STORE_ID);\n+  }\n+\n+  private void createRegion(RegionShortcut regionShortcut) {\n+    cacheRule.getCache()\n+        .<String, String>createRegionFactory(regionShortcut)\n+        .create(REGION_NAME);\n+  }\n+\n+  private void createGatewayReceiver() {\n+    GatewayReceiverFactory gatewayReceiverFactory =\n+        cacheRule.getCache().createGatewayReceiverFactory();\n+    gatewayReceiverFactory.setManualStart(false);\n+    gatewayReceiverFactory.create();\n+  }\n+\n+  private void createGatewaySender(boolean parallel, int remoteDistributedSystemId) {\n+    GatewaySenderFactory gatewaySenderFactory = cacheRule.getCache().createGatewaySenderFactory();\n+    gatewaySenderFactory.setParallel(parallel);\n+    gatewaySenderFactory.setDiskSynchronous(true);\n+    gatewaySenderFactory.setPersistenceEnabled(true);\n+    gatewaySenderFactory.setDiskStoreName(DISK_STORE_ID);\n+    gatewaySenderFactory.create(GATEWAY_SENDER_ID, remoteDistributedSystemId);\n+  }\n+\n+  private void createServerWithRegionAndGatewayReceiver(RegionShortcut regionShortcut) {\n+    createGatewayReceiver();\n+    createRegion(regionShortcut);\n+  }\n+\n+  private void createServerWithRegionAndPersistentGatewaySender(RegionShortcut regionShortcut,\n+      int remoteDistributedSystemId, boolean parallel) {\n+    createDiskStore();\n+    createRegion(regionShortcut);\n+    createGatewaySender(parallel, remoteDistributedSystemId);\n+    Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);\n+    region.getAttributesMutator().addGatewaySenderId(GATEWAY_SENDER_ID);\n+  }\n+\n+  private void gracefullyDisconnect() {\n+    InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();\n+    InternalDistributedSystem.getConnectedInstance().disconnect();\n+    await()\n+        .untilAsserted(() -> assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());\n+  }\n+\n+  private void awaitForQueueSize(int queueSize) {\n+    GatewaySender gatewaySender = cacheRule.getCache().getGatewaySender(GATEWAY_SENDER_ID);\n+    await().untilAsserted(() -> {\n+      Set<RegionQueue> queues = ((AbstractGatewaySender) gatewaySender).getQueues();\n+      int totalSize = queues.stream().mapToInt(RegionQueue::size).sum();\n+      assertThat(queueSize).isEqualTo(totalSize);\n+    });\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  static Object[] regionAndGatewayTypes() {\n+    ArrayList<Object[]> parameters = new ArrayList<>();\n+    parameters.add(new Object[] {RegionShortcut.PARTITION, true});\n+    parameters.add(new Object[] {RegionShortcut.REPLICATE, false});\n+\n+    return parameters.toArray();\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    VM locatorCluster1 = getVM(0);\n+    serverCluster1 = getVM(1);\n+    VM locatorCluster2 = getVM(2);\n+    serverCluster2 = getVM(3);\n+\n+    int[] ports = getRandomAvailableTCPPortsForDUnitSite(2);\n+    site1Port = ports[0];\n+    site2Port = ports[1];\n+\n+    // Start 2 sites, one locator and one server per site.\n+    locatorCluster1\n+        .invoke(() -> cacheRule.createCache(createLocatorConfiguration(1, site1Port, site2Port)));\n+    locatorCluster2\n+        .invoke(() -> cacheRule.createCache(createLocatorConfiguration(2, site2Port, site1Port)));\n+\n+    serverCluster1.invoke(() -> cacheRule.createCache(createServerConfiguration(site1Port)));\n+    serverCluster2.invoke(() -> cacheRule.createCache(createServerConfiguration(site2Port)));\n+  }\n+\n+  /**\n+   * The tests executes the following:\n+   * - Creates region and gateway-receiver on cluster2.\n+   * - Creates the region and gateway-sender on cluster1.\n+   * - Populates the region and waits until WAN replication has finished.\n+   * - Restarts server on cluster1, and stops it afterwards (the initial compaction occurs during\n+   * startup and the disk validation is done offline).\n+   * - Asserts that there are no orphaned drf files, neither compact-able records on the disks-tore.\n+   */\n+  @Test\n+  @TestCaseName(TEST_CASE_NAME)\n+  @Parameters(method = \"regionAndGatewayTypes\")\n+  public void diskStoreShouldBeCompactedOnMemberRestartWhenAllEventsHaveBeenDispatched(\n+      RegionShortcut regionShortcut, boolean parallel) throws Exception {\n+    final int entries = 100;", "originalCommit": "957dd90c8cdda4a8578d94fba658d82df640578a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzMTk0NQ==", "url": "https://github.com/apache/geode/pull/5037#discussion_r419131945", "bodyText": "I made them different on purpose, the amount of entries is irrelevant and I didn't want to \"hardcode\" it as a static field within the test class as we might want to add extra tests (with specific requirements about the amount of entries to insert) to this class in the future.", "author": "jujoramos", "createdAt": "2020-05-03T17:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzOTAyMQ=="}], "type": "inlineReview"}, {"oid": "d2571d16a499c606e3b6bc09fa0b140e641fd7c6", "url": "https://github.com/apache/geode/commit/d2571d16a499c606e3b6bc09fa0b140e641fd7c6", "message": "GEODE-8029: Changes requested by reviewers.", "committedDate": "2020-05-03T17:09:00Z", "type": "commit"}]}