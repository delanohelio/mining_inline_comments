{"pr_number": 5035, "pr_title": "GEODE-8059: replace multiple redis set functions with one CommandFunction", "pr_createdAt": "2020-05-01T00:30:19Z", "pr_url": "https://github.com/apache/geode/pull/5035", "timeline": [{"oid": "c3973bc4eed86aa6bc299989c88a9e2754667159", "url": "https://github.com/apache/geode/commit/c3973bc4eed86aa6bc299989c88a9e2754667159", "message": "replaced multiple redis set function with one CommandFunction", "committedDate": "2020-05-01T00:27:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwNTQyNQ==", "url": "https://github.com/apache/geode/pull/5035#discussion_r418405425", "bodyText": "I love the use of the RedisCommandType here", "author": "prettyClouds", "createdAt": "2020-05-01T03:53:18Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/CommandFunction.java", "diffHunk": "@@ -11,40 +11,55 @@\n  * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n  * or implied. See the License for the specific language governing permissions and limitations under\n  * the License.\n+ *\n  */\n \n-package org.apache.geode.redis.internal.executor.set;\n+package org.apache.geode.redis.internal.executor;\n \n import java.util.ArrayList;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.apache.geode.cache.Region;\n import org.apache.geode.cache.execute.Function;\n import org.apache.geode.cache.execute.FunctionContext;\n import org.apache.geode.cache.execute.ResultSender;\n import org.apache.geode.internal.cache.execute.RegionFunctionContextImpl;\n import org.apache.geode.redis.internal.ByteArrayWrapper;\n+import org.apache.geode.redis.internal.RedisCommandType;\n+import org.apache.geode.redis.internal.executor.set.DeltaSet;\n \n-class SremFunction implements Function<ArrayList<ByteArrayWrapper>> {\n+public class CommandFunction implements Function<Object[]> {\n \n-  public static final String ID = \"SREM_FUNCTION\";\n+  public static final String ID = \"REDIS_COMMAND_FUNCTION\";\n \n   @SuppressWarnings(\"unchecked\")\n   @Override\n-  public void execute(FunctionContext<ArrayList<ByteArrayWrapper>> context) {\n+  public void execute(FunctionContext<Object[]> context) {\n     RegionFunctionContextImpl regionFunctionContext =\n         (RegionFunctionContextImpl) context;\n     ByteArrayWrapper key =\n         (ByteArrayWrapper) regionFunctionContext.getFilter().iterator().next();\n     Region<ByteArrayWrapper, DeltaSet> localRegion =\n         regionFunctionContext.getLocalDataSet(regionFunctionContext.getDataSet());\n-    ArrayList<ByteArrayWrapper> membersToRemove =\n-        (ArrayList<ByteArrayWrapper>) regionFunctionContext.getArguments();\n-    AtomicBoolean setWasDeleted = new AtomicBoolean();\n-    long membersRemoved = DeltaSet.srem(localRegion, key, membersToRemove, setWasDeleted);\n-    ResultSender<Long> resultSender = regionFunctionContext.getResultSender();\n-    resultSender.sendResult(membersRemoved);\n-    resultSender.lastResult(setWasDeleted.get() ? 1L : 0L);\n+    ResultSender resultSender = regionFunctionContext.getResultSender();\n+    Object[] args = context.getArguments();\n+    RedisCommandType command = (RedisCommandType) args[0];\n+    ArrayList<ByteArrayWrapper> membersToAdd = (ArrayList<ByteArrayWrapper>) args[1];\n+    switch (command) {\n+      case SADD:", "originalCommit": "c3973bc4eed86aa6bc299989c88a9e2754667159", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwNjE3Ng==", "url": "https://github.com/apache/geode/pull/5035#discussion_r418406176", "bodyText": "I think it's odd that the Function abstraction bleeds into DeltaSet via the ResultSender.  It restricts DeltaSet to only run in the context of functions, and adds more responsibility to the class.  What are your thoughts?\nSome alternatives\nSome kind of Decorator Pattern to separate the responsibilities, but still keep the function code really simple\npassing in a more generic consumer into the DeltaSet...that would provide some isolation, but allow for this more asynchronous style of programming.  We could define the consumer in the function, so the resultsender object stays encapsulated in the function.", "author": "prettyClouds", "createdAt": "2020-05-01T03:57:23Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/DeltaSet.java", "diffHunk": "@@ -30,10 +30,37 @@\n import org.apache.geode.Delta;\n import org.apache.geode.InvalidDeltaException;\n import org.apache.geode.cache.Region;\n+import org.apache.geode.cache.execute.ResultSender;\n import org.apache.geode.redis.internal.ByteArrayWrapper;\n \n public class DeltaSet implements Delta, DataSerializable {\n \n+  public static void sadd(ResultSender<Long> resultSender,\n+      Region<ByteArrayWrapper, DeltaSet> localRegion, ByteArrayWrapper key,\n+      ArrayList<ByteArrayWrapper> membersToAdd) {\n+    resultSender.lastResult(sadd(localRegion, key, membersToAdd));", "originalCommit": "c3973bc4eed86aa6bc299989c88a9e2754667159", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ0NzcxMg==", "url": "https://github.com/apache/geode/pull/5035#discussion_r418447712", "bodyText": "ResultSender is just an interface so someone else could implement it. But I think at this point we don't want anyone except the Function interacting with DeltaSet. We have some work to do (the other set ops that directly read the region) but once they all use the function I'm okay with the only public methods on DeltaSet being ones that encourage the methods to only be used by Functions. But I would also be okay with DeltaSet not even having these ResultSender methods and instead the DeltaSet methods return a value and then we have some code in the Function that adds it to the ResultSender. At some point I'd like the static methods on DeltaSet to go away.", "author": "dschneider-pivotal", "createdAt": "2020-05-01T07:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwNjE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwNzk4Ng==", "url": "https://github.com/apache/geode/pull/5035#discussion_r418407986", "bodyText": "this line is duplicated in each function. I don't think the resultcollector abstraction really makes sense in our case, because we are really trying to just call this on one server and get back one result.  Can we short circuit this by just calling this  results.getResult().get(0) in executeFunction()", "author": "prettyClouds", "createdAt": "2020-05-01T04:08:21Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/GeodeRedisSetWithFunctions.java", "diffHunk": "@@ -40,30 +47,18 @@ public GeodeRedisSetWithFunctions(ByteArrayWrapper key,\n   }\n \n   public static void registerFunctions() {\n-    FunctionService.registerFunction(new SaddFunction());\n-    FunctionService.registerFunction(new SremFunction());\n-    FunctionService.registerFunction(new SmembersFunction());\n-    FunctionService.registerFunction(new SdelFunction());\n+    FunctionService.registerFunction(new CommandFunction());\n   }\n \n   @Override\n   public long sadd(ArrayList<ByteArrayWrapper> membersToAdd) {\n-    ResultCollector<ArrayList<ByteArrayWrapper>, List<Long>> results = FunctionService\n-        .onRegion(region)\n-        .withFilter(Collections.singleton(key))\n-        .setArguments(membersToAdd)\n-        .execute(SaddFunction.ID);\n-\n+    ResultCollector<Object[], List<Long>> results = executeFunction(SADD, membersToAdd);\n     return results.getResult().get(0);", "originalCommit": "c3973bc4eed86aa6bc299989c88a9e2754667159", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ0NjA5NQ==", "url": "https://github.com/apache/geode/pull/5035#discussion_r418446095", "bodyText": "srem is different but I think we could make it the same. And then you have the generic challenge of getting executeFunction to return a generic value that the caller can specify. This seems doable and I like having as much of the common code in executeFunction as possible.", "author": "dschneider-pivotal", "createdAt": "2020-05-01T07:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwNzk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwODMzNQ==", "url": "https://github.com/apache/geode/pull/5035#discussion_r418408335", "bodyText": "Could we just send back an object like SremResult?  this code is dependent on ordering of calls to \"sendResult\" when it doesn't need to be.", "author": "prettyClouds", "createdAt": "2020-05-01T04:10:17Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/executor/set/GeodeRedisSetWithFunctions.java", "diffHunk": "@@ -40,30 +47,18 @@ public GeodeRedisSetWithFunctions(ByteArrayWrapper key,\n   }\n \n   public static void registerFunctions() {\n-    FunctionService.registerFunction(new SaddFunction());\n-    FunctionService.registerFunction(new SremFunction());\n-    FunctionService.registerFunction(new SmembersFunction());\n-    FunctionService.registerFunction(new SdelFunction());\n+    FunctionService.registerFunction(new CommandFunction());\n   }\n \n   @Override\n   public long sadd(ArrayList<ByteArrayWrapper> membersToAdd) {\n-    ResultCollector<ArrayList<ByteArrayWrapper>, List<Long>> results = FunctionService\n-        .onRegion(region)\n-        .withFilter(Collections.singleton(key))\n-        .setArguments(membersToAdd)\n-        .execute(SaddFunction.ID);\n-\n+    ResultCollector<Object[], List<Long>> results = executeFunction(SADD, membersToAdd);\n     return results.getResult().get(0);\n   }\n \n   @Override\n   public long srem(ArrayList<ByteArrayWrapper> membersToRemove, AtomicBoolean setWasDeleted) {\n-    ResultCollector<ArrayList<ByteArrayWrapper>, List<Long>> results = FunctionService\n-        .onRegion(region)\n-        .withFilter(Collections.singleton(key))\n-        .setArguments(membersToRemove)\n-        .execute(SremFunction.ID);\n+    ResultCollector<Object[], List<Long>> results = executeFunction(SREM, membersToRemove);\n     List<Long> resultList = results.getResult();\n     long membersRemoved = resultList.get(0);", "originalCommit": "c3973bc4eed86aa6bc299989c88a9e2754667159", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ0NTc1MQ==", "url": "https://github.com/apache/geode/pull/5035#discussion_r418445751", "bodyText": "I think having srem return two things will not be needed for long. Once we have a single region (instead of the metaType region and the dataStore region) then we no longer need to tell the caller that the srem did a delete. So instead of making a new serialize class (like SremResult) we could just have a single result that is an long[] in this case. Then we only need to do resultSender.get(0) like the other operations.", "author": "dschneider-pivotal", "createdAt": "2020-05-01T07:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwODMzNQ=="}], "type": "inlineReview"}]}