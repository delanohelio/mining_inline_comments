{"pr_number": 4998, "pr_title": "GEODE-8028: refactor RedisCommandType", "pr_createdAt": "2020-04-25T19:46:22Z", "pr_url": "https://github.com/apache/geode/pull/4998", "timeline": [{"oid": "097edebb9b6d06775e9de4ddd49630d0de653019", "url": "https://github.com/apache/geode/commit/097edebb9b6d06775e9de4ddd49630d0de653019", "message": "Instead of each enum reimplementing getExecutor and getDataType\nnow those fields are final and initialized with a private constructor.\nThe executor will now be initialized when this class is loaded instead\nof waiting until the first call of getExecutor.\nComments on each enum were also removed since the correspondence to\na REDIS command is obvious and this is an internal API.", "committedDate": "2020-04-25T19:42:06Z", "type": "commit"}, {"oid": "d9d281a353496d7d3d71a648e80ed497c546288a", "url": "https://github.com/apache/geode/commit/d9d281a353496d7d3d71a648e80ed497c546288a", "message": "fixed unit test that could no longer mock enum", "committedDate": "2020-04-25T21:00:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5MDQ1MA==", "url": "https://github.com/apache/geode/pull/4998#discussion_r415390450", "bodyText": "I vaguely remembered that getDataType was unused. I double checked, and it is unused...do you want to get rid of that as well, or do you foresee some purpose for it?", "author": "prettyClouds", "createdAt": "2020-04-26T20:10:54Z", "path": "geode-redis/src/main/java/org/apache/geode/redis/internal/RedisCommandType.java", "diffHunk": "@@ -150,3016 +159,202 @@\n    *************** Keys ******************\n    ***************************************/\n \n-  /**\n-   * AUTH password\n-   * <p>\n-   * Authenticate to the server\n-   */\n-  AUTH {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new AuthExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * DEL key [key ...]\n-   * <p>\n-   * Delete a key\n-   */\n-  DEL {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new DelExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * EXISTS key\n-   * <p>\n-   * Determine if a key exists\n-   */\n-  EXISTS {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ExistsExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * EXPIRE key seconds\n-   * <p>\n-   * Set a key's time to live in seconds\n-   */\n-  EXPIRE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ExpireExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * EXPIREAT key timestamp\n-   * <p>\n-   * Set the expiration for a key as a UNIX timestamp\n-   */\n-  EXPIREAT {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ExpireAtExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * FLUSHALL\n-   * <p>\n-   * Remove all keys from all databases\n-   */\n-  FLUSHALL {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new FlushAllExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * FLUSHDB\n-   * <p>\n-   * Remove all keys from the current database\n-   * <p>\n-   * Same as FLUSHALL for this implementation\n-   */\n-  FLUSHDB {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new FlushAllExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * KEYS pattern\n-   * <p>\n-   * Find all keys matching the given pattern\n-   */\n-  KEYS {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new KeysExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * PERSIST key\n-   * <p>\n-   * Remove the expiration from a key\n-   */\n-  PERSIST {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new PersistExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * PEXPIRE key milliseconds\n-   * <p>\n-   * Set a key's time to live in milliseconds\n-   */\n-  PEXPIRE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new PExpireExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * PEXPIREAT key milliseconds-timestamp\n-   * <p>\n-   * Set the expiration for a key as a UNIX timestamp specified in milliseconds\n-   */\n-  PEXPIREAT {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new PExpireAtExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * PTTL key\n-   * <p>\n-   * Get the time to live for a key in milliseconds\n-   */\n-  PTTL {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new PTTLExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * RENAME key\n-   * <p>\n-   * Renames a key\n-   */\n-  RENAME {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new RenameExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SCAN cursor [MATCH pattern] [COUNT count]\n-   * <p>\n-   * Incrementally iterate the keys space\n-   */\n-  SCAN {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ScanExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * TTL key\n-   * <p>\n-   * Get the time to live for a key\n-   */\n-  TTL {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new TTLExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * TYPE key\n-   * <p>\n-   * Determine the type stored at key\n-   */\n-  TYPE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new TypeExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n+  AUTH(new AuthExecutor()),\n+  DEL(new DelExecutor()),\n+  EXISTS(new ExistsExecutor()),\n+  EXPIRE(new ExpireExecutor()),\n+  EXPIREAT(new ExpireAtExecutor()),\n+  FLUSHALL(new FlushAllExecutor()),\n+  FLUSHDB(new FlushAllExecutor()),\n+  KEYS(new KeysExecutor()),\n+  PERSIST(new PersistExecutor()),\n+  PEXPIRE(new PExpireExecutor()),\n+  PEXPIREAT(new PExpireAtExecutor()),\n+  PTTL(new PTTLExecutor()),\n+  RENAME(new RenameExecutor()),\n+  SCAN(new ScanExecutor()),\n+  TTL(new TTLExecutor()),\n+  TYPE(new TypeExecutor()),\n \n   /***************************************\n    ************** Strings ****************\n    ***************************************/\n \n-  /**\n-   * APPEND key value\n-   * <p>\n-   * Append a value to a key\n-   */\n-  APPEND {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new AppendExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * BITCOUNT key start end [start end ...]\n-   * <p>\n-   * Count set bits in a string\n-   */\n-  BITCOUNT {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new BitCountExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * BITOP operation destkey key [key ...]\n-   * <p>\n-   * Perform bitwise operations between strings\n-   */\n-  BITOP {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new BitOpExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * BITPOS key bit [start] [end]\n-   * <p>\n-   * Find first bit set or clear in a string\n-   */\n-  BITPOS {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new BitPosExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * DECR key\n-   * <p>\n-   * Decrement the integer value of a key by one\n-   */\n-  DECR {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new DecrExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * DECRBY key decrement\n-   * <p>\n-   * Decrement the integer value of a key by the given number\n-   */\n-  DECRBY {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new DecrByExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * GET key\n-   * <p>\n-   * Get the value of a key\n-   */\n-  GET {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new GetExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * GETBIT key offset\n-   * <p>\n-   * Returns the bit value at offset in the string value stored at key\n-   */\n-  GETBIT {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new GetBitExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * GETRANGE key start end\n-   * <p>\n-   * Get a substring of the string stored at a key\n-   */\n-  GETRANGE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new GetRangeExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * GETSET key value\n-   * <p>\n-   * Set the string value of a key and return its old value\n-   */\n-  GETSET {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new GetSetExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * INCR key\n-   * <p>\n-   * Increment the integer value of a key by one\n-   */\n-  INCR {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new IncrExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * INCRBY key increment\n-   * <p>\n-   * Increment the integer value of a key by the given amount\n-   */\n-  INCRBY {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new IncrByExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * INCRBYFLOAT key increment\n-   * <p>\n-   * Increment the float value of a key by the given amount\n-   */\n-  INCRBYFLOAT {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new IncrByFloatExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * MGET key [key ...]\n-   * <p>\n-   * Get the values of all the given keys\n-   */\n-  MGET {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new MGetExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * MSET key value [key value ...]\n-   * <p>\n-   * Set multiple keys to multiple values\n-   */\n-  MSET {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new MSetExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * MSETNX key value [key value ...]\n-   * <p>\n-   * Set multiple keys to multiple values, only if none of the keys exist\n-   */\n-  MSETNX {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new MSetNXExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * PSETEX key milliseconds value\n-   * <p>\n-   * Set the value and expiration in milliseconds of a key\n-   */\n-  PSETEX {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new PSetEXExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SETEX key seconds value\n-   * <p>\n-   * Set the value and expiration of a key\n-   */\n-  SETEX {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SetEXExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SET key value [EX seconds] [PX milliseconds] [NX|XX]\n-   * <p>\n-   * Set the string value of a key\n-   */\n-  SET {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SetExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n+  APPEND(new AppendExecutor(), REDIS_STRING),\n+  BITCOUNT(new BitCountExecutor(), REDIS_STRING),\n+  BITOP(new BitOpExecutor(), REDIS_STRING),\n+  BITPOS(new BitPosExecutor(), REDIS_STRING),\n+  DECR(new DecrExecutor(), REDIS_STRING),\n+  DECRBY(new DecrByExecutor(), REDIS_STRING),\n+  GET(new GetExecutor(), REDIS_STRING),\n+  GETBIT(new GetBitExecutor(), REDIS_STRING),\n+  GETRANGE(new GetRangeExecutor(), REDIS_STRING),\n+  GETSET(new GetSetExecutor(), REDIS_STRING),\n+  INCR(new IncrExecutor(), REDIS_STRING),\n+  INCRBY(new IncrByExecutor(), REDIS_STRING),\n+  INCRBYFLOAT(new IncrByFloatExecutor(), REDIS_STRING),\n+  MGET(new MGetExecutor(), REDIS_STRING),\n+  MSET(new MSetExecutor(), REDIS_STRING),\n+  MSETNX(new MSetNXExecutor(), REDIS_STRING),\n+  PSETEX(new PSetEXExecutor(), REDIS_STRING),\n+  SETEX(new SetEXExecutor(), REDIS_STRING),\n+  SET(new SetExecutor(), REDIS_STRING),\n+  SETBIT(new SetBitExecutor(), REDIS_STRING),\n+  SETNX(new SetNXExecutor(), REDIS_STRING),\n+  SETRANGE(new SetRangeExecutor(), REDIS_STRING),\n+  STRLEN(new StrlenExecutor(), REDIS_STRING),\n \n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SETBIT key offset value\n-   * <p>\n-   * Sets or clears the bit at offset in the string value stored at key\n-   */\n-  SETBIT {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SetBitExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n+  /***************************************\n+   **************** Hashes ***************\n+   ***************************************/\n \n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n+  HDEL(new HDelExecutor(), REDIS_HASH),\n+  HEXISTS(new HExistsExecutor(), REDIS_HASH),\n+  HGET(new HGetExecutor(), REDIS_HASH),\n+  HGETALL(new HGetAllExecutor(), REDIS_HASH),\n+  HINCRBY(new HIncrByExecutor(), REDIS_HASH),\n+  HINCRBYFLOAT(new HIncrByFloatExecutor(), REDIS_HASH),\n+  HKEYS(new HKeysExecutor(), REDIS_HASH),\n+  HLEN(new HLenExecutor(), REDIS_HASH),\n+  HMGET(new HMGetExecutor(), REDIS_HASH),\n+  HMSET(new HMSetExecutor(), REDIS_HASH),\n+  HSCAN(new HScanExecutor(), REDIS_HASH),\n+  HSET(new HSetExecutor(), REDIS_HASH),\n+  HSETNX(new HSetNXExecutor(), REDIS_HASH),\n+  HVALS(new HValsExecutor(), REDIS_HASH),\n \n-  /**\n-   * SETNX key value\n-   * <p>\n-   * Set the value of a key, only if the key does not exist\n-   */\n-  SETNX {\n-    private Executor executor;\n+  /***************************************\n+   *********** HyperLogLogs **************\n+   ***************************************/\n \n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SetNXExecutor();\n-      }\n-      return executor;\n-    }\n+  PFADD(new PFAddExecutor(), REDIS_HLL),\n+  PFCOUNT(new PFCountExecutor(), REDIS_HLL),\n+  PFMERGE(new PFMergeExecutor(), REDIS_HLL),\n \n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n+  /***************************************\n+   *************** Lists *****************\n+   ***************************************/\n \n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n+  LINDEX(new LIndexExecutor(), REDIS_LIST),\n+  LINSERT(new LInsertExecutor(), REDIS_LIST),\n+  LLEN(new LLenExecutor(), REDIS_LIST),\n+  LPOP(new LPopExecutor(), REDIS_LIST),\n+  LPUSH(new LPushExecutor(), REDIS_LIST),\n+  LPUSHX(new LPushXExecutor(), REDIS_LIST),\n+  LRANGE(new LRangeExecutor(), REDIS_LIST),\n+  LREM(new LRemExecutor(), REDIS_LIST),\n+  LSET(new LSetExecutor(), REDIS_LIST),\n+  LTRIM(new LTrimExecutor(), REDIS_LIST),\n+  RPOP(new RPopExecutor(), REDIS_LIST),\n+  RPUSH(new RPushExecutor(), REDIS_LIST),\n+  RPUSHX(new RPushXExecutor(), REDIS_LIST),\n \n-  /**\n-   * SETRANGE key offset value\n-   * <p>\n-   * Overwrite part of a string at key starting at the specified offset\n-   */\n-  SETRANGE {\n-    private Executor executor;\n+  /***************************************\n+   **************** Sets *****************\n+   ***************************************/\n \n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SetRangeExecutor();\n-      }\n-      return executor;\n-    }\n+  SADD(new SAddExecutor(), REDIS_SET),\n+  SCARD(new SCardExecutor(), REDIS_SET),\n+  SDIFF(new SDiffExecutor(), REDIS_SET),\n+  SDIFFSTORE(new SDiffStoreExecutor(), REDIS_SET),\n+  SISMEMBER(new SIsMemberExecutor(), REDIS_SET),\n+  SINTER(new SInterExecutor(), REDIS_SET),\n+  SINTERSTORE(new SInterStoreExecutor(), REDIS_SET),\n+  SMEMBERS(new SMembersExecutor(), REDIS_SET),\n+  SMOVE(new SMoveExecutor(), REDIS_SET),\n+  SPOP(new SPopExecutor(), REDIS_SET),\n+  SRANDMEMBER(new SRandMemberExecutor(), REDIS_SET),\n+  SUNION(new SUnionExecutor(), REDIS_SET),\n+  SUNIONSTORE(new SUnionStoreExecutor(), REDIS_SET),\n+  SSCAN(new SScanExecutor(), REDIS_SET),\n+  SREM(new SRemExecutor(), REDIS_SET),\n \n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n+  /***************************************\n+   ************* Sorted Sets *************\n+   ***************************************/\n \n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n+  ZADD(new ZAddExecutor(), REDIS_SORTEDSET),\n+  ZCARD(new ZCardExecutor(), REDIS_SORTEDSET),\n+  ZCOUNT(new ZCountExecutor(), REDIS_SORTEDSET),\n+  ZINCRBY(new ZIncrByExecutor(), REDIS_SORTEDSET),\n+  ZLEXCOUNT(new ZLexCountExecutor(), REDIS_SORTEDSET),\n+  ZRANGE(new ZRangeExecutor(), REDIS_SORTEDSET),\n+  ZRANGEBYLEX(new ZRangeByLexExecutor(), REDIS_SORTEDSET),\n+  ZRANGEBYSCORE(new ZRangeByScoreExecutor(), REDIS_SORTEDSET),\n+  ZREVRANGE(new ZRevRangeExecutor(), REDIS_SORTEDSET),\n+  ZRANK(new ZRankExecutor(), REDIS_SORTEDSET),\n+  ZREM(new ZRemExecutor(), REDIS_SORTEDSET),\n+  ZREMRANGEBYLEX(new ZRemRangeByLexExecutor(), REDIS_SORTEDSET),\n+  ZREMRANGEBYRANK(new ZRemRangeByRankExecutor(), REDIS_SORTEDSET),\n+  ZREMRANGEBYSCORE(new ZRemRangeByScoreExecutor(), REDIS_SORTEDSET),\n+  ZREVRANGEBYSCORE(new ZRevRangeByScoreExecutor(), REDIS_SORTEDSET),\n+  ZREVRANK(new ZRevRankExecutor(), REDIS_SORTEDSET),\n+  ZSCAN(new ZScanExecutor(), REDIS_SORTEDSET),\n+  ZSCORE(new ZScoreExecutor(), REDIS_SORTEDSET),\n \n-  /**\n-   * STRLEN key\n-   * <p>\n-   * Get the length of the value stored in a key\n-   */\n-  STRLEN {\n-    private Executor executor;\n+  /***************************************\n+   ********** Publish Subscribe **********\n+   ***************************************/\n \n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new StrlenExecutor();\n-      }\n-      return executor;\n-    }\n+  SUBSCRIBE(new SubscribeExecutor(), REDIS_PUBSUB),\n+  PUBLISH(new PublishExecutor(), REDIS_PUBSUB),\n+  UNSUBSCRIBE(new UnsubscribeExecutor(), REDIS_PUBSUB),\n+  PSUBSCRIBE(new PsubscribeExecutor(), REDIS_PUBSUB),\n+  PUNSUBSCRIBE(new PunsubscribeExecutor(), REDIS_PUBSUB),\n \n-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;\n+  /**************************************\n+   * Geospatial commands ****************\n+   **************************************/\n \n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n+  GEOADD(new GeoAddExecutor(), REDIS_SORTEDSET),\n+  GEOHASH(new GeoHashExecutor(), REDIS_SORTEDSET),\n+  GEOPOS(new GeoPosExecutor(), REDIS_SORTEDSET),\n+  GEODIST(new GeoDistExecutor(), REDIS_SORTEDSET),\n+  GEORADIUS(new GeoRadiusExecutor(), REDIS_SORTEDSET),\n+  GEORADIUSBYMEMBER(new GeoRadiusByMemberExecutor(), REDIS_SORTEDSET),\n \n   /***************************************\n-   **************** Hashes ***************\n+   ************ Transactions *************\n    ***************************************/\n-  /**\n-   * HDEL key field [field ...]\n-   * <p>\n-   * Delete one or more hash fields\n-   */\n-  HDEL {\n-    private Executor executor;\n \n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HDelExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * HEXISTS key field\n-   * <p>\n-   * Determine if a hash field exists\n-   */\n-  HEXISTS {\n-    private Executor executor;\n+  DISCARD(new DiscardExecutor()),\n+  EXEC(new ExecExecutor()),\n+  MULTI(new MultiExecutor()),\n+  UNWATCH(new UnwatchExecutor()),\n+  WATCH(new WatchExecutor()),\n \n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HExistsExecutor();\n-      }\n-      return executor;\n-    }\n+  /***************************************\n+   *************** Server ****************\n+   ***************************************/\n \n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n+  DBSIZE(new DBSizeExecutor()),\n+  ECHO(new EchoExecutor()),\n+  TIME(new TimeExecutor()),\n+  PING(new PingExecutor()),\n+  QUIT(new QuitExecutor()),\n+  SHUTDOWN(new ShutDownExecutor()),\n+  UNKNOWN(new UnkownExecutor());\n \n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n+  private final Executor executor;\n+  private final RedisDataType dataType;\n \n   /**\n-   * HGET key field\n-   * <p>\n-   * Get the value of a hash field\n+   * @return {@link Executor} for the command type\n    */\n-  HGET {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HGetExecutor();\n-      }\n-      return executor;\n-    }\n+  public Executor getExecutor() {\n+    return executor;\n+  };\n \n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n+  public RedisDataType getDataType() {\n+    return dataType;\n+  }\n \n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n+  private RedisCommandType(Executor executor) {\n+    this(executor, NONE);\n+  }\n \n-  /**\n-   * HGETALL key\n-   * <p>\n-   * Get all the fields and values in a hash\n-   */\n-  HGETALL {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HGetAllExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * HINCRBY key field increment\n-   * <p>\n-   * Increment the integer value of a hash field by the given number\n-   */\n-  HINCRBY {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HIncrByExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * HINCRBYFLOAT key field increment\n-   * <p>\n-   * Increment the float value of a hash field by the given amount\n-   */\n-  HINCRBYFLOAT {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HIncrByFloatExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * HKEYS key\n-   * <p>\n-   * Get all the fields in a hash\n-   */\n-  HKEYS {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HKeysExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * HLEN key\n-   * <p>\n-   * Get the number of fields in a hash\n-   */\n-  HLEN {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HLenExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * HMGET key field [field ...]\n-   * <p>\n-   * Get the values of all the given hash fields\n-   */\n-  HMGET {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HMGetExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * HMSET key field value [field value ...]\n-   * <p>\n-   * Set multiple hash fields to multiple values\n-   */\n-  HMSET {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HMSetExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * HSCAN key cursor [MATCH pattern] [COUNT count]\n-   * <p>\n-   * Incrementally iterate hash fields and associated values\n-   */\n-  HSCAN {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HScanExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * HSET key field value\n-   * <p>\n-   * Set the string value of a hash field\n-   */\n-  HSET {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HSetExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * HSETNX key field value\n-   * <p>\n-   * Set the value of a hash field, only if the field does not exist\n-   */\n-  HSETNX {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HSetNXExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * HVALS key\n-   * <p>\n-   * Get all the values in a hash\n-   */\n-  HVALS {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new HValsExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /***************************************\n-   *********** HyperLogLogs **************\n-   ***************************************/\n-\n-  /**\n-   * PFADD key element [element ...]\n-   * <p>\n-   * Adds the specified elements to the specified HyperLogLog\n-   */\n-  PFADD {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new PFAddExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HLL;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * PFCOUNT key [key ...]\n-   * <p>\n-   * Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s)\n-   */\n-  PFCOUNT {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new PFCountExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HLL;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * PFMERGE destkey sourcekey [sourcekey ...]\n-   * <p>\n-   * Merge N different HyperLogLogs into a single one\n-   */\n-  PFMERGE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new PFMergeExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_HLL;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /***************************************\n-   *************** Lists *****************\n-   ***************************************/\n-\n-  /**\n-   * LINDEX key index\n-   * <p>\n-   * Get an element from a list by its index\n-   */\n-  LINDEX {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new LIndexExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_LIST;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * LINSERT key BEFORE|AFTER pivot value\n-   * <p>\n-   * Insert an element before or after another element in a list\n-   */\n-  LINSERT {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new LInsertExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_LIST;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * LLEN key\n-   * <p>\n-   * Get the length of a list\n-   */\n-  LLEN {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new LLenExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_LIST;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * LPOP key\n-   * <p>\n-   * Remove and get the first element in a list\n-   */\n-  LPOP {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new LPopExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_LIST;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * LPUSH key value [value ...]\n-   * <p>\n-   * Prepend one or multiple values to a list\n-   */\n-  LPUSH {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new LPushExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_LIST;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * LPUSHX key value\n-   * <p>\n-   * Prepend a value to a list, only if the list exists\n-   */\n-  LPUSHX {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new LPushXExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_LIST;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * LRANGE key start stop\n-   * <p>\n-   * Get a range of elements from a list\n-   */\n-  LRANGE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new LRangeExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_LIST;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * LREM key count value\n-   * <p>\n-   * Remove elements from a list\n-   */\n-  LREM {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new LRemExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_LIST;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * LSET key index value\n-   * <p>\n-   * Set the value of an element in a list by its index\n-   */\n-  LSET {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new LSetExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_LIST;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * LTRIM key start stop\n-   * <p>\n-   * Trim a list to the specified range\n-   */\n-  LTRIM {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new LTrimExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_LIST;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * RPOP key\n-   * <p>\n-   * Remove and get the last element in a list\n-   */\n-  RPOP {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new RPopExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_LIST;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * RPUSH key value [value ...]\n-   * <p>\n-   * Append one or multiple values to a list\n-   */\n-  RPUSH {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new RPushExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_LIST;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * RPUSHX key value\n-   * <p>\n-   * Append a value to a list, only if the list exists\n-   */\n-  RPUSHX {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new RPushXExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_LIST;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /***************************************\n-   **************** Sets *****************\n-   ***************************************/\n-\n-  /**\n-   * SADD key member [member ...]\n-   * <p>\n-   * Add one or more members to a set\n-   */\n-  SADD {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SAddExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SCARD key\n-   * <p>\n-   * Get the number of members in a set\n-   */\n-  SCARD {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SCardExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SDIFF key [key ...]\n-   * <p>\n-   * Subtract multiple sets\n-   */\n-  SDIFF {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SDiffExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SDIFFSTORE destination key [key ...]\n-   * <p>\n-   * Subtract multiple sets and store the resulting set in a key\n-   */\n-  SDIFFSTORE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SDiffStoreExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SISMEMBER key member\n-   * <p>\n-   * Determine if a given value is a member of a set\n-   */\n-  SISMEMBER {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SIsMemberExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SINTER key [key ...]\n-   * <p>\n-   * Intersect multiple sets\n-   */\n-  SINTER {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SInterExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SINTERSTORE destination key [key ...]\n-   * <p>\n-   * Intersect multiple sets and store the resulting set in a key\n-   */\n-  SINTERSTORE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SInterStoreExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SMEMBERS key\n-   * <p>\n-   * Get all the members in a set\n-   */\n-  SMEMBERS {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SMembersExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SMOVE source destination member\n-   * <p>\n-   * Move a member from one set to another\n-   */\n-  SMOVE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SMoveExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SPOP key\n-   * <p>\n-   * Remove and return a random member from a set\n-   */\n-  SPOP {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SPopExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SRANDMEMBER key [count]\n-   * <p>\n-   * Get one or multiple random members from a set\n-   */\n-  SRANDMEMBER {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SRandMemberExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SUNION key [key ...]\n-   * <p>\n-   * Add multiple sets\n-   */\n-  SUNION {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SUnionExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SUNIONSTORE destination key [key ...]\n-   * <p>\n-   * Add multiple sets and store the resulting set in a key\n-   */\n-  SUNIONSTORE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SUnionStoreExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SSCAN key cursor [MATCH pattern] [COUNT count]\n-   * <p>\n-   * Incrementally iterate Set elements\n-   */\n-  SSCAN {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SScanExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SREM key member [member ...]\n-   * <p>\n-   * Remove one or more members from a set\n-   */\n-  SREM {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SRemExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /***************************************\n-   ************* Sorted Sets *************\n-   ***************************************/\n-\n-  /**\n-   * ZADD key score member [score member ...]\n-   * <p>\n-   * Add one or more members to a sorted set, or update its score if it already exists\n-   */\n-  ZADD {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZAddExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZCARD key\n-   * <p>\n-   * Get the number of members in a sorted set\n-   */\n-  ZCARD {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZCardExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZCOUNT key min max\n-   * <p>\n-   * Count the members in a sorted set with scores within the given values\n-   */\n-  ZCOUNT {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZCountExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZINCRBY key increment member\n-   * <p>\n-   * Increment the score of a member in a sorted set\n-   */\n-  ZINCRBY {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZIncrByExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZLEXCOUNT key min max\n-   * <p>\n-   * Count the number of members in a sorted set between a given lexicographical range\n-   */\n-  ZLEXCOUNT {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZLexCountExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZRANGE key start stop [WITHSCORES]\n-   * <p>\n-   * Return a range of members in a sorted set, by index\n-   */\n-  ZRANGE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZRangeExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZRANGEBYLEX key min max [LIMIT offset count]\n-   * <p>\n-   * Return a range of members in a sorted set, by lexicographical range\n-   */\n-  ZRANGEBYLEX {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZRangeByLexExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]\n-   * <p>\n-   * Return a range of members in a sorted set, by score\n-   */\n-  ZRANGEBYSCORE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZRangeByScoreExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZREVRANGE key start stop [WITHSCORES]\n-   * <p>\n-   * Return a range of members in a sorted set, by index, with scores ordered from high to low\n-   */\n-  ZREVRANGE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZRevRangeExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZRANK key member\n-   * <p>\n-   * Determine the index of a member in a sorted set\n-   */\n-  ZRANK {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZRankExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZREM key member [member ...]\n-   * <p>\n-   * Remove one or more members from a sorted set\n-   */\n-  ZREM {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZRemExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZREMRANGEBYLEX key min max\n-   * <p>\n-   * Remove all members in a sorted set between the given lexicographical range\n-   */\n-  ZREMRANGEBYLEX {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZRemRangeByLexExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZREMRANGEBYRANK key start stop\n-   * <p>\n-   * Remove all members in a sorted set within the given indexes\n-   */\n-  ZREMRANGEBYRANK {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZRemRangeByRankExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZREMRANGEBYSCORE key min max\n-   * <p>\n-   * Remove all members in a sorted set within the given scores\n-   */\n-  ZREMRANGEBYSCORE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZRemRangeByScoreExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]\n-   * <p>\n-   * Return a range of members in a sorted set, by score, with scores ordered from high to low\n-   */\n-  ZREVRANGEBYSCORE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZRevRangeByScoreExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZREVRANK key member\n-   * <p>\n-   * Determine the index of a member in a sorted set, with scores ordered from high to low\n-   */\n-  ZREVRANK {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZRevRankExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZSCAN key cursor [MATCH pattern] [COUNT count]\n-   * <p>\n-   * Incrementally iterate sorted sets elements and associated scores\n-   */\n-  ZSCAN {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZScanExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ZSCORE key member\n-   * <p>\n-   * Get the score associated with the given member in a sorted set\n-   */\n-  ZSCORE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ZScoreExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /***************************************\n-   ********** Publish Subscribe **********\n-   ***************************************/\n-  /**\n-   * SUBSCRIBE channel...\n-   * <p>\n-   * subscribe to channel\n-   */\n-  SUBSCRIBE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new SubscribeExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_PUBSUB;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * PUBLISH channel message\n-   */\n-  PUBLISH {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new PublishExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_PUBSUB;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * UNSUBSCRIBE channel...\n-   */\n-  UNSUBSCRIBE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new UnsubscribeExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_PUBSUB;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * PSUBSCRIBE channel-pattern...\n-   * <p>\n-   * subscribe to channel\n-   */\n-  PSUBSCRIBE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new PsubscribeExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_PUBSUB;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * PUNSUBSCRIBE channel...\n-   */\n-  PUNSUBSCRIBE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new PunsubscribeExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_PUBSUB;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**************************************\n-   * Geospatial commands ****************\n-   **************************************/\n-\n-  GEOADD {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new GeoAddExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  GEOHASH {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new GeoHashExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  GEOPOS {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new GeoPosExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  GEODIST {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new GeoDistExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  GEORADIUS {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new GeoRadiusExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  GEORADIUSBYMEMBER {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new GeoRadiusByMemberExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /***************************************\n-   ************ Transactions *************\n-   ***************************************/\n-\n-  /**\n-   * DISCARD\n-   * <p>\n-   * Discard all commands issued after MULTI\n-   */\n-  DISCARD {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new DiscardExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * EXEC\n-   * <p>\n-   * Execute all commands issued after MULTI\n-   */\n-  EXEC {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ExecExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * MULTI\n-   * <p>\n-   * Mark the start of a transaction block\n-   */\n-  MULTI {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new MultiExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * UNWATCH\n-   * <p>\n-   * Forget about all watched keys\n-   */\n-  UNWATCH {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new UnwatchExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * WATCH key [key ...]\n-   * <p>\n-   * Watch the given keys to determine execution of the MULTI/EXEC block\n-   */\n-  WATCH {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new WatchExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /***************************************\n-   *************** Server ****************\n-   ***************************************/\n-\n-  /**\n-   * DBSIZE\n-   * <p>\n-   * Return the number of keys in the selected database\n-   */\n-  DBSIZE {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new DBSizeExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * ECHO message\n-   * <p>\n-   * Echo the given string\n-   */\n-  ECHO {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new EchoExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * TIME\n-   * <p>\n-   * Return the current server time\n-   */\n-  TIME {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new TimeExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * PING\n-   * <p>\n-   * Ping the server\n-   */\n-  PING {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new PingExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * QUIT\n-   * <p>\n-   * Close the connection\n-   */\n-  QUIT {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new QuitExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  /**\n-   * SHUTDOWN\n-   * <p>\n-   * Shut down the server\n-   */\n-  SHUTDOWN {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new ShutDownExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  },\n-\n-  // UNKNOWN\n-  UNKNOWN {\n-    private Executor executor;\n-\n-    @Override\n-    public Executor getExecutor() {\n-      if (executor == null) {\n-        executor = new UnkownExecutor();\n-      }\n-      return executor;\n-    }\n-\n-    private final RedisDataType dataType = RedisDataType.NONE;\n-\n-    @Override\n-    public RedisDataType getDataType() {\n-      return this.dataType;\n-    }\n-  };\n-\n-  /**\n-   * Abstract method overridden by each value in enum to get the executor associated with that\n-   * command type\n-   *\n-   * @return {@link Executor} for command type\n-   */\n-  public abstract Executor getExecutor();\n-\n-  public abstract RedisDataType getDataType();\n-  /*\n-   * private RedisCommandType (RedisDataType dataType) { this.dataType = dataType; }\n-   */\n+  private RedisCommandType(Executor executor, RedisDataType dataType) {", "originalCommit": "d9d281a353496d7d3d71a648e80ed497c546288a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUwNDQzMw==", "url": "https://github.com/apache/geode/pull/4998#discussion_r415504433", "bodyText": "Yes. It is now gone. Thanks", "author": "dschneider-pivotal", "createdAt": "2020-04-27T04:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM5MDQ1MA=="}], "type": "inlineReview"}, {"oid": "b00cf5254fc8873016bd6fb357c643e7492cbf34", "url": "https://github.com/apache/geode/commit/b00cf5254fc8873016bd6fb357c643e7492cbf34", "message": "removed unused getDataType\nfixed analyze serializables test", "committedDate": "2020-04-27T04:36:50Z", "type": "commit"}]}