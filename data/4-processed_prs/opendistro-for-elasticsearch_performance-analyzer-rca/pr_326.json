{"pr_number": 326, "pr_title": "JVM decider", "pr_createdAt": "2020-07-31T18:12:23Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326", "timeline": [{"oid": "5274a1311d2873ad9bc32172c738197c361e3618", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/5274a1311d2873ad9bc32172c738197c361e3618", "message": "JVM decider framework", "committedDate": "2020-07-31T18:03:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4MjU2MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465382561", "bodyText": "I am curious why in case of increase == false, in one constructor we leave desiredCapacity at current value while in the other we decrease it by one step while the logic is identical in case increase == true. Is this intended ? Can we add a comment stating why this is so ?", "author": "yojs", "createdAt": "2020-08-04T23:19:09Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheCapacityAction.java", "diffHunk": "@@ -36,21 +36,51 @@\n     private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n     private Map<ResourceEnum, Long> upperBoundInBytes = new HashMap<>();\n \n+    public ModifyCacheCapacityAction(\n+        final NodeKey esNode,\n+        final ResourceEnum cacheType,\n+        final long currentCapacityInBytes,\n+        final boolean increase) {\n+        this(esNode, cacheType, currentCapacityInBytes);\n+        long desiredCapacity =\n+            increase ? currentCapacityInBytes + getStepSize(cacheType) : currentCapacityInBytes;", "originalCommit": "5274a1311d2873ad9bc32172c738197c361e3618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMTkzNg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465911936", "bodyText": "yes, ideally we need to consider increase==false and decrease cache size accordingly if increase == false. However, lower bound is currently not available in this Action Class and will be added later by @sruti1312 . So will leave this part to Sruti", "author": "rguo-aws", "createdAt": "2020-08-05T18:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4MjU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4MzAzNA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465383034", "bodyText": "can we add a comment as why this makes sense to hard code this ?", "author": "yojs", "createdAt": "2020-08-04T23:20:37Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheCapacityAction.java", "diffHunk": "@@ -142,6 +172,10 @@ public long getDesiredCapacityInBytes() {\n         return desiredCapacityInBytes;\n     }\n \n+    public double getDesiredCapacityInPercent() {\n+        return 0.1;", "originalCommit": "5274a1311d2873ad9bc32172c738197c361e3618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMzIyNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465913225", "bodyText": "this was a placeholder as heap max size metric was not available at the time when this PR was created. update this function now to calculate the value by desire size / heap max size", "author": "rguo-aws", "createdAt": "2020-08-05T18:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4MzAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4ODc3Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465388772", "bodyText": "A lot of the code is the same in both the read**Capacity methods. Can we extract it out to a common method ?", "author": "yojs", "createdAt": "2020-08-04T23:38:57Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/store/collector/NodeConfigCacheUtil.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.MetricEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.Resource;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+\n+public class NodeConfigCacheUtil {\n+\n+  public static Long readCacheSize(NodeKey esNode, NodeConfigCache nodeConfigCache, ResourceEnum resourceEnum) {\n+    Long ret;\n+    Resource resource = Resource.newBuilder()\n+        .setResourceEnum(resourceEnum)\n+        .setMetricEnum(MetricEnum.CACHE_MAX_SIZE).build();\n+    try {\n+      ret = (long) nodeConfigCache.get(esNode, resource);\n+    } catch (Exception e) {\n+      ret = null;\n+    }\n+    return ret;\n+  }\n+\n+  public static Integer readQueueCapacity(NodeKey esNode, NodeConfigCache nodeConfigCache, ResourceEnum resourceEnum) {\n+    Integer ret;\n+    Resource resource = Resource.newBuilder()\n+        .setResourceEnum(resourceEnum)\n+        .setMetricEnum(MetricEnum.QUEUE_CAPACITY).build();\n+    try {\n+      ret = (int) nodeConfigCache.get(esNode, resource);\n+    } catch (Exception e) {\n+      ret = null;\n+    }\n+    return ret;", "originalCommit": "5274a1311d2873ad9bc32172c738197c361e3618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNjg2Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465916867", "bodyText": "removed this util class completely and reuse the util class that Sruti created in another PR", "author": "rguo-aws", "createdAt": "2020-08-05T18:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4ODc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MjQwOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465392409", "bodyText": "I might be wrong, but I think if we name a class as builder, it should follow the builder pattern ?", "author": "yojs", "createdAt": "2020-08-04T23:51:21Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCacheUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder {", "originalCommit": "5274a1311d2873ad9bc32172c738197c361e3618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNDI0MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465914240", "bodyText": "Thanks. that is a good idea. update to follow builder pattern", "author": "rguo-aws", "createdAt": "2020-08-05T18:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MjQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5Mjc4NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465392784", "bodyText": "Because these seem like the initialization methods, would the constructor not be a better place for them ?", "author": "yojs", "createdAt": "2020-08-04T23:52:31Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCacheUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder {\n+  private final NodeKey esNode;\n+  private final NodeConfigCache nodeConfigCache;\n+  private Map<ResourceEnum, ModifyCacheCapacityAction> cacheActionMap;\n+  private Map<ResourceEnum, Boolean> actionFilter;\n+  private static final List<ResourceEnum> targetCaches;\n+\n+  static {\n+    List<ResourceEnum> caches = new ArrayList<>();\n+    caches.add(ResourceEnum.FIELD_DATA_CACHE);\n+    caches.add(ResourceEnum.SHARD_REQUEST_CACHE);\n+    targetCaches = Collections.unmodifiableList(caches);\n+  }\n+\n+  public LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    actionFilter = new HashMap<>();\n+    targetCaches.forEach(r -> actionFilter.put(r, false));\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheUtil.readCacheSize(esNode, nodeConfigCache, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheCapacityAction action = new ModifyCacheCapacityAction(esNode, ResourceEnum.FIELD_DATA_CACHE,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheUtil.readCacheSize(esNode, nodeConfigCache, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheCapacityAction action = new ModifyCacheCapacityAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  /**\n+   * generate final action list based on action priority.\n+   * The default priority in this level is to downsize both caches simultaneously\n+   * unless explicitly overridden by customer yml.\n+   * @return final action list based on action priority\n+   */\n+  // TODO : read priority from yml if customer wants to override default ordering\n+  private void actionPriorityFilter() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  /**\n+   * build actions for level 1 bucket.\n+   * @return List of actions\n+   */\n+  public List<Action> buildActions() {\n+    addFieldDataCacheAction();", "originalCommit": "5274a1311d2873ad9bc32172c738197c361e3618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwMTU0Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466001546", "bodyText": "done. moved to constructor", "author": "rguo-aws", "createdAt": "2020-08-05T21:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5Mjc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MzkyMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465393921", "bodyText": "Some of the code in the LevelledActionBuilders is common. Can we move it to a base class ?", "author": "yojs", "createdAt": "2020-08-04T23:56:09Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCacheUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder {\n+  private final NodeKey esNode;\n+  private final NodeConfigCache nodeConfigCache;\n+  private Map<ResourceEnum, ModifyCacheCapacityAction> cacheActionMap;\n+  private Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  private Map<ResourceEnum, Boolean> actionFilter;\n+  private static final List<ResourceEnum> targetCaches;\n+  private static final List<ResourceEnum> targetQueues;\n+\n+  static {\n+    List<ResourceEnum> caches = new ArrayList<>();\n+    caches.add(ResourceEnum.FIELD_DATA_CACHE);\n+    caches.add(ResourceEnum.SHARD_REQUEST_CACHE);\n+    List<ResourceEnum> queues = new ArrayList<>();\n+    queues.add(ResourceEnum.WRITE_THREADPOOL);\n+    queues.add(ResourceEnum.SEARCH_THREADPOOL);\n+    targetCaches = Collections.unmodifiableList(caches);\n+    targetQueues = Collections.unmodifiableList(queues);\n+  }\n+\n+  public LevelTwoActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {", "originalCommit": "5274a1311d2873ad9bc32172c738197c361e3618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwMTc0OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466001749", "bodyText": "done. created a base class to maintain common code", "author": "rguo-aws", "createdAt": "2020-08-05T21:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MzkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NjY3OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465396679", "bodyText": "What is EWMA ?", "author": "yojs", "createdAt": "2020-08-05T00:05:14Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCacheUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder {\n+  private final NodeKey esNode;\n+  private final NodeConfigCache nodeConfigCache;\n+  private Map<ResourceEnum, ModifyCacheCapacityAction> cacheActionMap;\n+  private Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  private Map<ResourceEnum, Boolean> actionFilter;\n+  private static final List<ResourceEnum> targetCaches;\n+  private static final List<ResourceEnum> targetQueues;\n+\n+  static {\n+    List<ResourceEnum> caches = new ArrayList<>();\n+    caches.add(ResourceEnum.FIELD_DATA_CACHE);\n+    caches.add(ResourceEnum.SHARD_REQUEST_CACHE);\n+    List<ResourceEnum> queues = new ArrayList<>();\n+    queues.add(ResourceEnum.WRITE_THREADPOOL);\n+    queues.add(ResourceEnum.SEARCH_THREADPOOL);\n+    targetCaches = Collections.unmodifiableList(caches);\n+    targetQueues = Collections.unmodifiableList(queues);\n+  }\n+\n+  public LevelTwoActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    actionFilter = new HashMap<>();\n+    targetCaches.forEach(r -> actionFilter.put(r, false));\n+    targetQueues.forEach(r -> actionFilter.put(r, false));\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheUtil.readCacheSize(esNode, nodeConfigCache, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheCapacityAction action = new ModifyCacheCapacityAction(esNode, ResourceEnum.FIELD_DATA_CACHE,\n+        capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheUtil.readCacheSize(esNode, nodeConfigCache, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheCapacityAction action = new ModifyCacheCapacityAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE,\n+        capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    Integer capacity = NodeConfigCacheUtil.readQueueCapacity(esNode, nodeConfigCache, ResourceEnum.WRITE_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.WRITE_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    Integer capacity = NodeConfigCacheUtil.readQueueCapacity(esNode, nodeConfigCache, ResourceEnum.SEARCH_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.SEARCH_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  // allocate value to its bucket\n+  private int bucketization(int lowerBound, int upperBound, int val, int bucketSize) {\n+    double step = (double) (upperBound - lowerBound) / (double) bucketSize;\n+    return (int) ((double) val / step);\n+  }\n+\n+  // downsize queue based on priority and current queue size\n+  private void actionPriorityForQueue() {\n+    Integer writeQueueEWMASize = NodeConfigCacheUtil.readQueueSize(esNode, nodeConfigCache, ResourceEnum.WRITE_THREADPOOL);", "originalCommit": "5274a1311d2873ad9bc32172c738197c361e3618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNTY0Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465915646", "bodyText": "it is an acronym for \"exponentially weighted moving average\" which will be collected as a separate RCA", "author": "rguo-aws", "createdAt": "2020-08-05T18:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NjY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NjkxNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465396915", "bodyText": "Would we not want to take some actions if only one of the queues is non-null ?", "author": "yojs", "createdAt": "2020-08-05T00:06:13Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCacheUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder {\n+  private final NodeKey esNode;\n+  private final NodeConfigCache nodeConfigCache;\n+  private Map<ResourceEnum, ModifyCacheCapacityAction> cacheActionMap;\n+  private Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  private Map<ResourceEnum, Boolean> actionFilter;\n+  private static final List<ResourceEnum> targetCaches;\n+  private static final List<ResourceEnum> targetQueues;\n+\n+  static {\n+    List<ResourceEnum> caches = new ArrayList<>();\n+    caches.add(ResourceEnum.FIELD_DATA_CACHE);\n+    caches.add(ResourceEnum.SHARD_REQUEST_CACHE);\n+    List<ResourceEnum> queues = new ArrayList<>();\n+    queues.add(ResourceEnum.WRITE_THREADPOOL);\n+    queues.add(ResourceEnum.SEARCH_THREADPOOL);\n+    targetCaches = Collections.unmodifiableList(caches);\n+    targetQueues = Collections.unmodifiableList(queues);\n+  }\n+\n+  public LevelTwoActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    actionFilter = new HashMap<>();\n+    targetCaches.forEach(r -> actionFilter.put(r, false));\n+    targetQueues.forEach(r -> actionFilter.put(r, false));\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheUtil.readCacheSize(esNode, nodeConfigCache, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheCapacityAction action = new ModifyCacheCapacityAction(esNode, ResourceEnum.FIELD_DATA_CACHE,\n+        capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheUtil.readCacheSize(esNode, nodeConfigCache, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheCapacityAction action = new ModifyCacheCapacityAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE,\n+        capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    Integer capacity = NodeConfigCacheUtil.readQueueCapacity(esNode, nodeConfigCache, ResourceEnum.WRITE_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.WRITE_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    Integer capacity = NodeConfigCacheUtil.readQueueCapacity(esNode, nodeConfigCache, ResourceEnum.SEARCH_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.SEARCH_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  // allocate value to its bucket\n+  private int bucketization(int lowerBound, int upperBound, int val, int bucketSize) {\n+    double step = (double) (upperBound - lowerBound) / (double) bucketSize;\n+    return (int) ((double) val / step);\n+  }\n+\n+  // downsize queue based on priority and current queue size\n+  private void actionPriorityForQueue() {\n+    Integer writeQueueEWMASize = NodeConfigCacheUtil.readQueueSize(esNode, nodeConfigCache, ResourceEnum.WRITE_THREADPOOL);\n+    Integer searchQueueEWMASize = NodeConfigCacheUtil.readQueueSize(esNode, nodeConfigCache, ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueEWMASize == null || searchQueueEWMASize == null) {", "originalCommit": "5274a1311d2873ad9bc32172c738197c361e3618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxODc5Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r465918793", "bodyText": "That is because we want to compare the size of both queues before selecting a queue to scale down. The absolute value of queue size does really mean a lot here and what we are more interested in is which queue is relatively more contended.", "author": "rguo-aws", "createdAt": "2020-08-05T18:23:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NjkxNQ=="}], "type": "inlineReview"}, {"oid": "c11c54be8cc81e62361aa62292244260fcb0ae05", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/c11c54be8cc81e62361aa62292244260fcb0ae05", "message": "Merge branch 'master' into rguo-jvm-decider", "committedDate": "2020-08-05T17:47:47Z", "type": "commit"}, {"oid": "3ffecf220beb933b0843abee685bec3002122e23", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/3ffecf220beb933b0843abee685bec3002122e23", "message": "Address PR comments", "committedDate": "2020-08-05T20:57:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NDA1MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466054050", "bodyText": "nit: isn't this an upper bound?", "author": "sidheart", "createdAt": "2020-08-05T23:12:19Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -53,29 +53,63 @@\n \n   private Map<ResourceEnum, Long> stepSizeInBytes = new HashMap<>();\n \n-  public ModifyCacheMaxSizeAction(\n+  private ModifyCacheMaxSizeAction(\n       final NodeKey esNode,\n       final ResourceEnum cacheType,\n       final NodeConfigCache nodeConfigCache,\n-      final double cacheSizeUpperBound,\n-      final boolean increase) {\n-    // TODO: Add lower bound for caches\n-    // TODO: Address cache scaling down  when JVM decider is available\n+      final double cacheSizeUpperBound) {\n \n     this.esNode = esNode;\n     this.cacheType = cacheType;\n     this.nodeConfigCache = nodeConfigCache;\n     this.cacheSizeUpperBound = cacheSizeUpperBound;\n \n     setStepSize();\n+  }\n \n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase) {\n+    // TODO: Add lower bound for caches\n+    // TODO: Address cache scaling down  when JVM decider is available\n+\n+    this(esNode, cacheType, nodeConfigCache, cacheSizeUpperBound);\n     if (validateAndSetConfigValues()) {\n       long desiredCapacity =\n               increase ? currentCacheMaxSizeInBytes + getStepSize(cacheType) : currentCacheMaxSizeInBytes;\n       setDesiredCacheMaxSize(desiredCapacity);\n     }\n   }\n \n+  public ModifyCacheMaxSizeAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final double cacheSizeUpperBound,\n+      final boolean increase,\n+      int step) {\n+    this(esNode, cacheType, nodeConfigCache, cacheSizeUpperBound);\n+    if (validateAndSetConfigValues()) {\n+      long desiredCapacity =\n+          increase ? currentCacheMaxSizeInBytes + step * getStepSize(cacheType) : currentCacheMaxSizeInBytes;\n+      setDesiredCacheMaxSize(desiredCapacity);\n+    }\n+  }\n+\n+  public static ModifyCacheMaxSizeAction newMinimalCapacityAction(\n+      final NodeKey esNode,\n+      final ResourceEnum cacheType,\n+      final NodeConfigCache nodeConfigCache,\n+      final long cacheSizeUpperBound) {\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, cacheType, nodeConfigCache, cacheSizeUpperBound);\n+    //TODO : set lower bound to 0 for now", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NjIzNA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r468746234", "bodyText": "no, this is actually the lower bound of cache max capacity. We would like to adjust the max capacity between upper bound and lower bound", "author": "rguo-aws", "createdAt": "2020-08-11T17:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NDA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU0OTcxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r472549711", "bodyText": "Both upper and lower bounds should be read from config and adhered to. We cannot set cache lower bounds to 0 as it is effectively disables the caches.\nCache decider+rca looks for a combination of hit rate and eviction rate to check if size should be increased. Setting it to 0 makes eviction rate 0 - as a result caches are never increased even when enough mem is available.\nWe have to determine apt lower bounds and stick to those values.", "author": "vigyasharma", "createdAt": "2020-08-18T23:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NDA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxMzY2MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r474313660", "bodyText": "yes, this was added as a placeholder to set lower bound because lower bound was not supported in cache action at that time. Removed this placeholder", "author": "rguo-aws", "createdAt": "2020-08-20T22:49:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NDA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NTQ0Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466055446", "bodyText": "Replace with: this(esNode, threadPool, currentCapacity, increase, 1)", "author": "sidheart", "createdAt": "2020-08-05T23:16:41Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyQueueCapacityAction.java", "diffHunk": "@@ -40,14 +41,23 @@\n   private Map<ResourceEnum, Integer> lowerBound = new HashMap<>();\n   private Map<ResourceEnum, Integer> upperBound = new HashMap<>();\n \n+  public ModifyQueueCapacityAction(NodeKey esNode, ResourceEnum threadPool, int currentCapacity, boolean increase, int step) {\n+    this(esNode, threadPool, currentCapacity);\n+    int desiredCapacity = increase ? currentCapacity + step * STEP_SIZE : currentCapacity - step * STEP_SIZE;\n+    setDesiredCapacity(desiredCapacity);\n+  }\n+\n   public ModifyQueueCapacityAction(NodeKey esNode, ResourceEnum threadPool, int currentCapacity, boolean increase) {\n+    this(esNode, threadPool, currentCapacity);\n+    int desiredCapacity = increase ? currentCapacity + STEP_SIZE : currentCapacity - STEP_SIZE;\n+    setDesiredCapacity(desiredCapacity);", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0Njk2Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r468746967", "bodyText": "good point. will make that change", "author": "rguo-aws", "createdAt": "2020-08-11T17:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NTQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NjE0Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466056142", "bodyText": "Add null checks for sanity", "author": "sidheart", "createdAt": "2020-08-05T23:19:09Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyQueueCapacityAction.java", "diffHunk": "@@ -124,4 +134,12 @@ public int getDesiredCapacity() {\n   public ResourceEnum getThreadPool() {\n     return threadPool;\n   }\n+\n+  public int getUpperBound() {\n+    return upperBound.get(threadPool);\n+  }\n+\n+  public int getLowerBound() {\n+    return lowerBound.get(threadPool);\n+  }", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0ODE2MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r468748160", "bodyText": "ideally that shouldn't happen because threadPool is a private variable and it is this class object's responsibility to initialize the upper/lower bound properly. Let me add an assert here instead", "author": "rguo-aws", "createdAt": "2020-08-11T17:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NjE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MTE5Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466061197", "bodyText": "Do ALL actions need these? Might want to move these into a subclass if not.", "author": "sidheart", "createdAt": "2020-08-05T23:34:42Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/BaseActionBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class BaseActionBuilder {\n+  protected final NodeKey esNode;\n+  protected final NodeConfigCache nodeConfigCache;\n+  protected final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  protected final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2MjExNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r468762117", "bodyText": "we might or might not use both cache/queue actions in each level of action builder depending on the result of future performance test. This decision logic is very preliminary and we might introduce more sophisticated algorithm later on.  Let's keep those in base class for now and will move it to subclass if needed.", "author": "rguo-aws", "createdAt": "2020-08-11T17:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MTk3Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466061973", "bodyText": "actionFilter.getOrDefault(cache, false)", "author": "sidheart", "createdAt": "2020-08-05T23:37:25Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/BaseActionBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class BaseActionBuilder {\n+  protected final NodeKey esNode;\n+  protected final NodeConfigCache nodeConfigCache;\n+  protected final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  protected final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  protected final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  BaseActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();\n+    registerActions();\n+    actionPriorityFilter();\n+  }\n+\n+  protected abstract void registerActions();\n+\n+  protected abstract void actionPriorityFilter();\n+\n+  /**\n+   * build actions.\n+   * @return List of actions\n+   */\n+  public List<Action> build() {\n+    List<Action> actions = new ArrayList<>();\n+    cacheActionMap.forEach((cache, action) -> {\n+      if (actionFilter.containsKey(cache) && actionFilter.get(cache)) {", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2NDQ2OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r468764468", "bodyText": "thanks, that is a good point.", "author": "rguo-aws", "createdAt": "2020-08-11T18:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MTk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MjA2Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466062063", "bodyText": "getOrDefault as above", "author": "sidheart", "createdAt": "2020-08-05T23:37:40Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/BaseActionBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class BaseActionBuilder {\n+  protected final NodeKey esNode;\n+  protected final NodeConfigCache nodeConfigCache;\n+  protected final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  protected final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  protected final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  BaseActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();\n+    registerActions();\n+    actionPriorityFilter();\n+  }\n+\n+  protected abstract void registerActions();\n+\n+  protected abstract void actionPriorityFilter();\n+\n+  /**\n+   * build actions.\n+   * @return List of actions\n+   */\n+  public List<Action> build() {\n+    List<Action> actions = new ArrayList<>();\n+    cacheActionMap.forEach((cache, action) -> {\n+      if (actionFilter.containsKey(cache) && actionFilter.get(cache)) {\n+        actions.add(action);\n+      }\n+    });\n+    queueActionMap.forEach((queue, action) -> {\n+      if (actionFilter.containsKey(queue) && actionFilter.get(queue)) {", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2NDU1NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r468764555", "bodyText": "done", "author": "rguo-aws", "createdAt": "2020-08-11T18:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MjA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MzE2Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466063163", "bodyText": "So action.isActionable() takes the upper bound into consideration but not the lower bound? Are there plans to change this in the future?", "author": "sidheart", "createdAt": "2020-08-05T23:41:10Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder extends BaseActionBuilder {\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelOneActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2NTYyMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r468765621", "bodyText": "JVM decider doesn't really care about upper bound because the end goal is to decrease cache/queue capacity and here we want to make sure the new capacity proposed by this action is above the lower bound set in this level", "author": "rguo-aws", "createdAt": "2020-08-11T18:02:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MzE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2NDQ4Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466064483", "bodyText": "Can we rename these? The levels seem to correspond to usage buckets which we're calling healthy with buffer, healthy, underprovisioned, and unhealthy.", "author": "sidheart", "createdAt": "2020-08-05T23:45:32Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelThreeActionBuilder.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level three bucket\n+ *\n+ * <p>if old gen usage(after full gc) falls into this bucket 90% - 100%, JVM heap is extremely\n+ * contended and can run into OOM at any moment. So action builder will build a group of actions\n+ * to scale down caches to their lower bound in one shot. And for queues we will downsize all\n+ * queues simultaneously with even higher steps\n+ */\n+public class LevelThreeActionBuilder extends BaseActionBuilder {", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2Nzk4OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r468767988", "bodyText": "I am also trying to figure out if there is any better name here. But the Level* here does not correspond to the usage of JVM memory.  That is because the threshold of JVM healthiness is 60%(used to be 65%) and in JVM decider we further divide the range of unhealthiness (60%-100%) into three subranges", "author": "rguo-aws", "createdAt": "2020-08-11T18:06:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2NDQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2Njk2NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466066965", "bodyText": "This is very neat for this particular use case, but these actionbuilders aren't reusable", "author": "sidheart", "createdAt": "2020-08-05T23:54:15Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/OldGenDecisionPolicy.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Decision policy for old gen related actions\n+ *\n+ * <p>This policy defines 3 levels of unhealthiness \u2014 60-75% (level 1), 75-90% (level 2) and 90%+ (level 3)\n+ * and create dedicated action builders {@link LevelOneActionBuilder}, {@link LevelTwoActionBuilder},\n+ * {@link LevelThreeActionBuilder} for each level of unhealthiness\n+ */\n+public class OldGenDecisionPolicy {\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_ONE = 0.6;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_TWO = 0.75;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_THREE = 0.9;\n+  private final NodeConfigCache nodeConfigCache;\n+\n+  public OldGenDecisionPolicy(final NodeConfigCache nodeConfigCache) {\n+    this.nodeConfigCache = nodeConfigCache;\n+  }\n+\n+  public List<Action> actions(final NodeKey esNode, double oldGenUsage) {\n+    if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_THREE) {\n+      return LevelThreeActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_TWO) {\n+      return LevelTwoActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_ONE) {\n+      return LevelOneActionBuilder.newBuilder(esNode, nodeConfigCache).build();", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE3NTE0Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466175142", "bodyText": "After rereading this my thoughts are the same. I don't understand what problem we were trying to solve by using the builder pattern here. We don't actually use the builders as legitimate builders, they're just wrappers around specific logic for generating a list of actions given a known bucket level. Why can't the static variables be held in this class with the List generated in actions() itself? Who would reuse these classes down the line?", "author": "sidheart", "createdAt": "2020-08-06T06:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2Njk2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE3NjQ0NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r466176445", "bodyText": "The only moderately complex logic seems to live entirely in LevelTwoActionBuilder#actionPriorityForQueue(), but might not this just live in a function in this class?", "author": "sidheart", "createdAt": "2020-08-06T06:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2Njk2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2OTA2NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r468769065", "bodyText": "You are right, the complex logic right now only sit in Level two but as I mention above, we need to collect more data from experiment and then make changes based on that. So now level 1 & 3 are more like placeholder with very simple logics in it and each bucket in JVM decider can be evolved independently in the future.", "author": "rguo-aws", "createdAt": "2020-08-11T18:08:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2Njk2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIxMDA4MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473210080", "bodyText": "I agree with Sid, I don't really see a need for the common base class here. We have different strategies for each level that we want to be able to evolve independently. A simple interface might be enough.", "author": "vigyasharma", "createdAt": "2020-08-19T17:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2Njk2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxMTczMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r474311732", "bodyText": "This base class approach was suggested by Joydeep because he though we can move those common code into base class. Yes, I agree with you. We don't necessarily need inheritance here and each level can evolve independently. Removed the base class", "author": "rguo-aws", "createdAt": "2020-08-20T22:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2Njk2NQ=="}], "type": "inlineReview"}, {"oid": "a8cea381d6c9d30c51b9f1e1de68c51c97e21c83", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/a8cea381d6c9d30c51b9f1e1de68c51c97e21c83", "message": "Add UTs, WIP", "committedDate": "2020-08-11T22:22:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MDY4Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r472550682", "bodyText": "Do we really need to levels for describing step size (step * STEP_SIZE)? Now caller must remember that the param passed is number of STEP_SIZEs to modify a queue by. How about we directly take the full STEP_SIZE as input, and use default values if that's not provided.", "author": "vigyasharma", "createdAt": "2020-08-18T23:34:41Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyQueueCapacityAction.java", "diffHunk": "@@ -40,14 +41,23 @@\n   private Map<ResourceEnum, Integer> lowerBound = new HashMap<>();\n   private Map<ResourceEnum, Integer> upperBound = new HashMap<>();\n \n+  public ModifyQueueCapacityAction(NodeKey esNode, ResourceEnum threadPool, int currentCapacity, boolean increase, int step) {\n+    this(esNode, threadPool, currentCapacity);\n+    int desiredCapacity = increase ? currentCapacity + step * STEP_SIZE : currentCapacity - step * STEP_SIZE;", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MTM5OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r479561398", "bodyText": "done. we can now pass full step size as parameter in action builder", "author": "rguo-aws", "createdAt": "2020-08-28T22:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MDY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3Nzk2Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473177963", "bodyText": "Pls add a docstring describing the intent of these methods", "author": "vigyasharma", "createdAt": "2020-08-19T16:51:25Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/BaseActionBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class BaseActionBuilder {\n+  protected final NodeKey esNode;\n+  protected final NodeConfigCache nodeConfigCache;\n+  protected final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  protected final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  protected final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  BaseActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();\n+    registerActions();\n+    actionPriorityFilter();\n+  }\n+\n+  protected abstract void registerActions();\n+\n+  protected abstract void actionPriorityFilter();", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc4NTQ4Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r476785487", "bodyText": "removed base class", "author": "rguo-aws", "createdAt": "2020-08-25T22:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3Nzk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3OTI0OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473179248", "bodyText": "What is the purpose of these objects? It's not clear from the base class alone.", "author": "vigyasharma", "createdAt": "2020-08-19T16:53:42Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/BaseActionBuilder.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public abstract class BaseActionBuilder {\n+  protected final NodeKey esNode;\n+  protected final NodeConfigCache nodeConfigCache;\n+  protected final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  protected final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  protected final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  BaseActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    this.esNode = esNode;\n+    this.nodeConfigCache = nodeConfigCache;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMzU0Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r474323543", "bodyText": "removed base class and moved those back to each level of class", "author": "rguo-aws", "createdAt": "2020-08-20T23:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3OTI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4MDIwMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473180202", "bodyText": "Do we need to wrap these consts in a class? Can we just keep them as independent constants and move them to the top of the file?", "author": "vigyasharma", "createdAt": "2020-08-19T16:55:19Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder extends BaseActionBuilder {\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelOneActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  @Override\n+  protected void registerActions() {\n+    addFieldDataCacheAction();\n+    addShardRequestCacheAction();\n+  }\n+\n+  /**\n+   * generate final action list based on action priority.\n+   * The default priority in this level is to downsize both caches simultaneously\n+   * unless explicitly overridden by customer yml.\n+   * @return final action list based on action priority\n+   */\n+  // TODO : read priority from yml if customer wants to override default ordering\n+  @Override\n+  protected void actionPriorityFilter() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  //TODO : read consts from rca.conf\n+  private static class LEVEL_ONE_CONST {", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxMDE5OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r474310198", "bodyText": "moved consts into the corresponding config class (LevelOneActionBuilderConfig.java, etc.). The consts now act as default values and can be overridden by rca.conf", "author": "rguo-aws", "createdAt": "2020-08-20T22:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4MDIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4MjkwOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473182909", "bodyText": "action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND\nThis will be ensured by the action itself, we shouldn't have to check this again at the decider. isActionable() will return false if desiredCap <= lowerBound.", "author": "vigyasharma", "createdAt": "2020-08-19T16:58:04Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder extends BaseActionBuilder {\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelOneActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwODg2NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r474308865", "bodyText": "Use action builder to override lower bound. Removed the boundary check", "author": "rguo-aws", "createdAt": "2020-08-20T22:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4MjkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4MzMzOA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473183338", "bodyText": "Same as above", "author": "vigyasharma", "createdAt": "2020-08-19T16:58:29Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder extends BaseActionBuilder {\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelOneActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxMjgyNA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r474312824", "bodyText": "done", "author": "rguo-aws", "createdAt": "2020-08-20T22:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4MzMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4NTQ3MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473185470", "bodyText": "How does this ensure a priority order? Keys in the HashMap are not ordered, right? I also didn't understand the significance of boolean value field", "author": "vigyasharma", "createdAt": "2020-08-19T17:00:29Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder extends BaseActionBuilder {\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelOneActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE, nodeConfigCache,\n+        capacity, false, LEVEL_ONE_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_ONE_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  @Override\n+  protected void registerActions() {\n+    addFieldDataCacheAction();\n+    addShardRequestCacheAction();\n+  }\n+\n+  /**\n+   * generate final action list based on action priority.\n+   * The default priority in this level is to downsize both caches simultaneously\n+   * unless explicitly overridden by customer yml.\n+   * @return final action list based on action priority\n+   */\n+  // TODO : read priority from yml if customer wants to override default ordering\n+  @Override\n+  protected void actionPriorityFilter() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5OTM5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473199391", "bodyText": "IIUC, you are using the actionFilter to check which actions to pick based on different levels? e.g. only the actions allowed at that level will be marked true. Is this understanding correct?\nIf so, then why don't we just create only the relevant actions in each level and do away with this action filter.", "author": "vigyasharma", "createdAt": "2020-08-19T17:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4NTQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzNDg4OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r474334888", "bodyText": "The intention of creating an action filter is to de-couple the action generation logic away from the priority ordering logic so each one can run independently. By doing this we can avoid a very large function which adds actions and re-order actions based on rca.conf all together in one place.  So registerActions() will be responsible for adding all available actions in this level. and action filter will filter out some actions based on priority order set in rca.conf", "author": "rguo-aws", "createdAt": "2020-08-21T00:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4NTQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI3NDQyNg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r480274426", "bodyText": "I see. But from current changes, I don't see any action being added to actionFilter as false, so it seems like we just add actions to the actionFilter map as true, and pick all of them in build for each level*ActionBuilder. What am i missing?", "author": "vigyasharma", "createdAt": "2020-08-31T17:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4NTQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4OTQ2MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473189461", "bodyText": "Do you also want to add a cacheClearAction for level 3, that clears all ES caches, but runs with a high cool off time to avoid repeated invocations?", "author": "vigyasharma", "createdAt": "2020-08-19T17:04:31Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelThreeActionBuilder.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level three bucket\n+ *\n+ * <p>if old gen usage(after full gc) falls into this bucket 90% - 100%, JVM heap is extremely\n+ * contended and can run into OOM at any moment. So action builder will build a group of actions\n+ * to scale down caches to their lower bound in one shot. And for queues we will downsize all\n+ * queues simultaneously with even higher steps", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxMjczMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r474312730", "bodyText": "we can address this in a separate PR. this will require changes in PerformanceController as well. Let me create a issue to keep track of it", "author": "rguo-aws", "createdAt": "2020-08-20T22:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4OTQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4ODk4Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r483188983", "bodyText": "create an issue to keep track of it #409", "author": "rguo-aws", "createdAt": "2020-09-03T18:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4OTQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwMDQ4MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473200480", "bodyText": "Minor: This can be done via a flag in the builder now.", "author": "vigyasharma", "createdAt": "2020-08-19T17:22:18Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelThreeActionBuilder.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level three bucket\n+ *\n+ * <p>if old gen usage(after full gc) falls into this bucket 90% - 100%, JVM heap is extremely\n+ * contended and can run into OOM at any moment. So action builder will build a group of actions\n+ * to scale down caches to their lower bound in one shot. And for queues we will downsize all\n+ * queues simultaneously with even higher steps\n+ */\n+public class LevelThreeActionBuilder extends BaseActionBuilder {\n+\n+  private LevelThreeActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelThreeActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelThreeActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  //downsize field data cache to its lower bound in one shot\n+  public void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction.newMinimalCapacityAction(esNode,", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxMDQyOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r474310429", "bodyText": "yes. added a new setter in cache action builder to set the cache size to minimal", "author": "rguo-aws", "createdAt": "2020-08-20T22:39:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwMDQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwNzkwNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473207907", "bodyText": "I see what you are doing with bucketization here, this is good. We should add a doc string to explain to future readers.\nThe important point being that we cannot just look at {w|s}QueueEWMASize/{w|s}QueueCapacity because if QueueCapacity is already very low, say 200 for write queue, and all of it is constantly full (likely with small queues), we will get %age used as ~100% and keep reducing the same small queue.\nHence we need to look at the full range of sizes available for each queue (lower bound to upper bound), to get a sense of which queue is using more mem. We also don't simply compare absolute values of {w|s}QueueEWMASizes because they inherently have different overheads. Comparing them according to their full range ensures we maintain the same proportion while comparing them.", "author": "vigyasharma", "createdAt": "2020-08-19T17:35:26Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder extends BaseActionBuilder {\n+\n+  private LevelTwoActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelTwoActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelTwoActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE,\n+        nodeConfigCache, capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE,\n+        nodeConfigCache, capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    Integer capacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.WRITE_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.WRITE_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    Integer capacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.SEARCH_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.SEARCH_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  // allocate value to its bucket\n+  private int bucketization(int lowerBound, int upperBound, int val, int bucketSize) {\n+    double step = (double) (upperBound - lowerBound) / (double) bucketSize;\n+    return (int) ((double) val / step);\n+  }\n+\n+  // downsize queue based on priority and current queue size\n+  private void actionPriorityForQueue() {\n+    Integer writeQueueEWMASize = NodeConfigCacheReaderUtil\n+        .readQueueEWMASize(nodeConfigCache, esNode, ResourceEnum.WRITE_THREADPOOL);\n+    Integer searchQueueEWMASize = NodeConfigCacheReaderUtil\n+        .readQueueEWMASize(nodeConfigCache, esNode, ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueEWMASize == null || searchQueueEWMASize == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction writeQueueAction = queueActionMap.get(ResourceEnum.WRITE_THREADPOOL);\n+    ModifyQueueCapacityAction searchQueueAction = queueActionMap.get(ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueAction != null && searchQueueAction != null) {\n+      int writeQueueSizeBucket = bucketization(writeQueueAction.getLowerBound(),", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc4Njc2MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r476786761", "bodyText": "done. Created a ThreadPoolConfig object to store default config settings read from rca.conf. Use the lower - upper bounds defined in rca.conf (or the default values ) to calculate bucket size.", "author": "rguo-aws", "createdAt": "2020-08-25T22:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwNzkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwODM5Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473208397", "bodyText": "Add a doc string to explain this formulae, and what step means here", "author": "vigyasharma", "createdAt": "2020-08-19T17:36:17Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder extends BaseActionBuilder {\n+\n+  private LevelTwoActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelTwoActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelTwoActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE,\n+        nodeConfigCache, capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE,\n+        nodeConfigCache, capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    Integer capacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.WRITE_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.WRITE_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    Integer capacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.SEARCH_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.SEARCH_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  // allocate value to its bucket\n+  private int bucketization(int lowerBound, int upperBound, int val, int bucketSize) {", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc4NDE3OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r476784178", "bodyText": "done", "author": "rguo-aws", "createdAt": "2020-08-25T22:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwODM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwOTAwNA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473209004", "bodyText": "Should this be a separate constant? These are just bands that you are using to divide the range of queue capacity, can this just be local to the bucketization function?", "author": "vigyasharma", "createdAt": "2020-08-19T17:37:19Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder extends BaseActionBuilder {\n+\n+  private LevelTwoActionBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    super(esNode, nodeConfigCache);\n+  }\n+\n+  public static LevelTwoActionBuilder newBuilder(final NodeKey esNode, final NodeConfigCache nodeConfigCache) {\n+    return new LevelTwoActionBuilder(esNode, nodeConfigCache);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.FIELD_DATA_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.FIELD_DATA_CACHE,\n+        nodeConfigCache, capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.FIELD_DATA_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    Long capacity = NodeConfigCacheReaderUtil\n+        .readCacheMaxSizeInBytes(nodeConfigCache, esNode, ResourceEnum.SHARD_REQUEST_CACHE);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyCacheMaxSizeAction action = new ModifyCacheMaxSizeAction(esNode, ResourceEnum.SHARD_REQUEST_CACHE,\n+        nodeConfigCache, capacity, false, LEVEL_TWO_CONST.CACHE_ACTION_STEP_COUNT);\n+    if (action.isActionable()\n+        && action.getDesiredCapacityInPercent() >= LEVEL_TWO_CONST.SHARD_REQUEST_CACHE_LOWER_BOUND) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    Integer capacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.WRITE_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.WRITE_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    Integer capacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.SEARCH_THREADPOOL);\n+    if (capacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction action = new ModifyQueueCapacityAction(esNode, ResourceEnum.SEARCH_THREADPOOL,\n+        capacity, false, LEVEL_TWO_CONST.QUEUE_ACTION_STEP_COUNT);\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  // allocate value to its bucket\n+  private int bucketization(int lowerBound, int upperBound, int val, int bucketSize) {\n+    double step = (double) (upperBound - lowerBound) / (double) bucketSize;\n+    return (int) ((double) val / step);\n+  }\n+\n+  // downsize queue based on priority and current queue size\n+  private void actionPriorityForQueue() {\n+    Integer writeQueueEWMASize = NodeConfigCacheReaderUtil\n+        .readQueueEWMASize(nodeConfigCache, esNode, ResourceEnum.WRITE_THREADPOOL);\n+    Integer searchQueueEWMASize = NodeConfigCacheReaderUtil\n+        .readQueueEWMASize(nodeConfigCache, esNode, ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueEWMASize == null || searchQueueEWMASize == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction writeQueueAction = queueActionMap.get(ResourceEnum.WRITE_THREADPOOL);\n+    ModifyQueueCapacityAction searchQueueAction = queueActionMap.get(ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueAction != null && searchQueueAction != null) {\n+      int writeQueueSizeBucket = bucketization(writeQueueAction.getLowerBound(),\n+          writeQueueAction.getUpperBound(), writeQueueEWMASize, LEVEL_TWO_CONST.QUEUE_SIZE_BUCKET_SIZE);\n+      int searchQueueSizeBucket = bucketization(searchQueueAction.getLowerBound(),\n+          searchQueueAction.getUpperBound(), searchQueueEWMASize, LEVEL_TWO_CONST.QUEUE_SIZE_BUCKET_SIZE);\n+      if (writeQueueSizeBucket > searchQueueSizeBucket) {\n+        actionFilter.put(ResourceEnum.WRITE_THREADPOOL, true);\n+      }\n+      else if (writeQueueSizeBucket < searchQueueSizeBucket) {\n+        actionFilter.put(ResourceEnum.SEARCH_THREADPOOL, true);\n+      }\n+      //tie breaker. default policy prefer writing over indexing\n+      else {\n+        actionFilter.put(ResourceEnum.WRITE_THREADPOOL, true);\n+      }\n+    }\n+    else if (writeQueueAction != null) {\n+      actionFilter.put(ResourceEnum.WRITE_THREADPOOL, true);\n+    }\n+    else if (searchQueueAction != null) {\n+      actionFilter.put(ResourceEnum.SEARCH_THREADPOOL, true);\n+    }\n+  }\n+\n+  @Override\n+  protected void registerActions() {\n+    addFieldDataCacheAction();\n+    addShardRequestCacheAction();\n+    addSearchQueueAction();\n+    addWriteQueueAction();\n+  }\n+\n+  /**\n+   * The default priority in this level is\n+   * 1. downsize both caches simultaneously with larger step size.\n+   * 2. Allocate size of each queue into buckets and downsize any queue that has\n+   * higher bucket size.\n+   * 3. if the bucket size of both queues are equal,\n+   * the action priority will act as tie breaker and the default setting\n+   * favors write over search as write is more important in log analytic workload\n+   * 4. The above default action priority can be overridden by customer settings\n+   * but customer's acton priority will only affect step 3 above. Step 1 and 2 will\n+   * be executed regardless of priority action settings\n+   */\n+  // TODO : read priority from yml if customer wants to override default ordering\n+  @Override\n+  protected void actionPriorityFilter() {\n+    actionPriorityForCache();\n+    actionPriorityForQueue();\n+  }\n+\n+  //TODO : read consts from rca.conf\n+  private static class LEVEL_TWO_CONST {\n+    public static final double FIELD_DATA_CACHE_LOWER_BOUND = 0.02;\n+    public static final double SHARD_REQUEST_CACHE_LOWER_BOUND = 0.01;\n+    public static final int CACHE_ACTION_STEP_COUNT = 2;\n+    public static final int QUEUE_ACTION_STEP_COUNT = 1;\n+    public static final int QUEUE_SIZE_BUCKET_SIZE = 10;", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxMDgyMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r474310822", "bodyText": "yes, we can make this local to bucketization function but we also want to expose this to rca.conf so that we can tune in ptoduction. So I think it would be better to leave it as part of the confid settings in LevelTwoActionBuilderConfig", "author": "rguo-aws", "createdAt": "2020-08-20T22:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwOTAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIxMDk4Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r473210987", "bodyText": "Do you want to give more observation time for level 2 and level 3? Level 2 & 3 are post GC IHOP - should we factor in some time for gc trying and failing to clear things up?", "author": "vigyasharma", "createdAt": "2020-08-19T17:40:48Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/OldGenDecisionPolicy.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Decision policy for old gen related actions\n+ *\n+ * <p>This policy defines 3 levels of unhealthiness \u2014 60-75% (level 1), 75-90% (level 2) and 90%+ (level 3)\n+ * and create dedicated action builders {@link LevelOneActionBuilder}, {@link LevelTwoActionBuilder},\n+ * {@link LevelThreeActionBuilder} for each level of unhealthiness\n+ */\n+public class OldGenDecisionPolicy {\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_ONE = 0.6;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_TWO = 0.75;\n+  private static final double OLD_GEN_THRESHOLD_LEVEL_THREE = 0.9;\n+  private final NodeConfigCache nodeConfigCache;\n+\n+  public OldGenDecisionPolicy(final NodeConfigCache nodeConfigCache) {\n+    this.nodeConfigCache = nodeConfigCache;\n+  }\n+\n+  public List<Action> actions(final NodeKey esNode, double oldGenUsage) {\n+    if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_THREE) {\n+      return LevelThreeActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_TWO) {\n+      return LevelTwoActionBuilder.newBuilder(esNode, nodeConfigCache).build();\n+    }\n+    else if (oldGenUsage >= OLD_GEN_THRESHOLD_LEVEL_ONE) {", "originalCommit": "3ffecf220beb933b0843abee685bec3002122e23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzOTcwOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r474339709", "bodyText": "Even the oldGenUsage for level 1 is post GC usage I think we should factor in more time for this entire oldGenDecisonPolicy. Do you think that should be done via cool off period or should be done at RCA scheduler level ?\nOne approach is we keeps the decider running but set the cool off period of all queue/cache actions to a very large number (more than 10mins)\nThe other is we change the decisionFrequency in heap decider to run old gen decision logic at a much lower freq.\nWhat do you think ?", "author": "rguo-aws", "createdAt": "2020-08-21T00:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIxMDk4Nw=="}], "type": "inlineReview"}, {"oid": "848c6a798af03fa18ad4014df106c8900196f42c", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/848c6a798af03fa18ad4014df106c8900196f42c", "message": "Merge remote-tracking branch 'origin' into rguo-jvm-decider", "committedDate": "2020-08-19T20:37:45Z", "type": "commit"}, {"oid": "ead5c04f0d8ddd6cd1772d8d1beee64b7f59a804", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/ead5c04f0d8ddd6cd1772d8d1beee64b7f59a804", "message": "Address PR comments", "committedDate": "2020-08-25T23:55:43Z", "type": "commit"}, {"oid": "158721b562b91aa47323b8a62259f8e661e356a1", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/158721b562b91aa47323b8a62259f8e661e356a1", "message": "clean up code", "committedDate": "2020-08-28T22:28:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI3MDkwNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r480270905", "bodyText": "Please review and rebase changes from #402 once merged", "author": "vigyasharma", "createdAt": "2020-08-31T17:14:51Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/ModifyCacheMaxSizeAction.java", "diffHunk": "@@ -144,25 +147,24 @@ public ResourceEnum getCacheType() {\n     private final NodeKey esNode;\n     private final AppContext appContext;\n     private double upperBoundThreshold;\n+    private double lowerBoundThreshold;\n \n     private long stepSizeInBytes;\n     private boolean isIncrease;\n     private boolean canUpdate;\n     private long coolOffPeriodInMillis;\n \n     private Long currentCacheMaxSizeInBytes;\n-    private Long desiredCacheMaxSizeInBytes;\n+    private Double desiredCacheMaxSizeInPercent;\n     private Long heapMaxSizeInBytes;\n \n-    private Builder(\n+    public Builder(", "originalCommit": "158721b562b91aa47323b8a62259f8e661e356a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI3MTM2MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r480271360", "bodyText": "This should already be present in the Decider base class", "author": "vigyasharma", "createdAt": "2020-08-31T17:15:45Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/CacheHealthDecider.java", "diffHunk": "@@ -87,6 +91,11 @@ public Decision operate() {\n     return decision;\n   }\n \n+  @Override\n+  public void readRcaConf(RcaConf conf) {\n+    deciderConfig = conf.getDeciderConfig();\n+  }\n+", "originalCommit": "158721b562b91aa47323b8a62259f8e661e356a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI3MjMzMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r480272330", "bodyText": "Update with changes in #402", "author": "vigyasharma", "createdAt": "2020-08-31T17:17:48Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelOneActionBuilder.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.DeciderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.CacheBoundConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm.LevelOneActionBuilderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level one bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 60% - 75%, it has not yet reach the 75% threshold in GC.\n+ * So we will downsize each cache by regular step size and leave the queues untouched. By default Actions in this\n+ * bucket will ignore priority settings of caches and downsize both caches simultaneously until the capacity\n+ * of those caches reaches the lower bounds.\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 10% of the heap\n+ * and for shard request cache / query cache, it will be 2% of the heap(default ES settings). This is\n+ * to free up excessive heap used by fielddata cache or query cache because JVM decider favors stability\n+ * over performance.\n+ */\n+public class LevelOneActionBuilder {\n+  private final AppContext appContext;\n+  private final LevelOneActionBuilderConfig actionBuilderConfig;\n+  private final CacheBoundConfig cacheBoundConfig;\n+  private final NodeKey esNode;\n+  private final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  private final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  private LevelOneActionBuilder(final NodeKey esNode, final AppContext appContext, final\n+  DeciderConfig deciderConfig) {\n+    this.appContext = appContext;\n+    this.actionBuilderConfig = deciderConfig.getOldGenDecisionPolicyConfig().levelOneActionBuilderConfig();\n+    this.cacheBoundConfig = deciderConfig.getCacheBoundConfig();\n+    this.esNode = esNode;\n+    this.cacheActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();\n+    registerActions();\n+    actionPriorityFilter();\n+  }\n+\n+  public static LevelOneActionBuilder newBuilder(final NodeKey esNode, final AppContext appContext, final\n+  DeciderConfig deciderConfig) {\n+    return new LevelOneActionBuilder(esNode, appContext, deciderConfig);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction\n+        .newBuilder(esNode, ResourceEnum.FIELD_DATA_CACHE, appContext)\n+        .increase(false)\n+        .lowerBoundThreshold(actionBuilderConfig.fieldDataCacheLowerBound())\n+        .upperBoundThreshold(cacheBoundConfig.fieldDataCacheUpperBound())", "originalCommit": "158721b562b91aa47323b8a62259f8e661e356a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI3NTIzMA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r480275230", "bodyText": "Let's use changes in #402 ?", "author": "vigyasharma", "createdAt": "2020-08-31T17:23:27Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/configs/decider/CacheBoundConfig.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.ConfigUtils;\n+import java.util.Map;\n+\n+public class CacheBoundConfig {", "originalCommit": "158721b562b91aa47323b8a62259f8e661e356a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxOTUzOA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r480419538", "bodyText": "typo: write", "author": "vigyasharma", "createdAt": "2020-08-31T21:52:00Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.DeciderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.CacheBoundConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.ThreadPoolConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.WorkLoadTypeConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm.LevelTwoActionBuilderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder {\n+  private final AppContext appContext;\n+  private final LevelTwoActionBuilderConfig actionBuilderConfig;\n+  private final WorkLoadTypeConfig workLoadTypeConfig;\n+  private final CacheBoundConfig cacheBoundConfig;\n+  private final ThreadPoolConfig threadPoolConfig;\n+  private final NodeKey esNode;\n+  private final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  private final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  private final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  private LevelTwoActionBuilder(final NodeKey esNode, final AppContext appContext,\n+      final DeciderConfig deciderConfig) {\n+    this.appContext = appContext;\n+    this.actionBuilderConfig = deciderConfig.getOldGenDecisionPolicyConfig().levelTwoActionBuilderConfig();\n+    this.workLoadTypeConfig = deciderConfig.getWorkLoadTypeConfig();\n+    this.cacheBoundConfig = deciderConfig.getCacheBoundConfig();\n+    this.threadPoolConfig = deciderConfig.getThreadPoolConfig();\n+    this.esNode = esNode;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();\n+    registerActions();\n+    actionPriorityFilter();\n+  }\n+\n+  public static LevelTwoActionBuilder newBuilder(final NodeKey esNode, final AppContext appContext,\n+      final DeciderConfig deciderConfig) {\n+    return new LevelTwoActionBuilder(esNode, appContext, deciderConfig);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    //TODO : increase step size\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction\n+        .newBuilder(esNode, ResourceEnum.FIELD_DATA_CACHE, appContext)\n+        .increase(false)\n+        .lowerBoundThreshold(actionBuilderConfig.fieldDataCacheLowerBound())\n+        .upperBoundThreshold(cacheBoundConfig.fieldDataCacheUpperBound())\n+        .build();\n+    if (action.isActionable()) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    //TODO : increase step size\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction\n+        .newBuilder(esNode, ResourceEnum.SHARD_REQUEST_CACHE, appContext)\n+        .increase(false)\n+        .lowerBoundThreshold(actionBuilderConfig.shardRequestCacheLowerBound())\n+        .upperBoundThreshold(cacheBoundConfig.shardRequestCacheUpperBound())\n+        .build();\n+    if (action.isActionable()) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    ModifyQueueCapacityAction action = ModifyQueueCapacityAction\n+        .newBuilder(esNode, ResourceEnum.WRITE_THREADPOOL, appContext)\n+        .increase(false)\n+        .lowerBound(threadPoolConfig.writeQueueCapacityLowerBound())\n+        .upperBound(threadPoolConfig.writeQueueCapacityUpperBound())\n+        .build();\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    ModifyQueueCapacityAction action = ModifyQueueCapacityAction\n+        .newBuilder(esNode, ResourceEnum.SEARCH_THREADPOOL, appContext)\n+        .increase(false)\n+        .lowerBound(threadPoolConfig.searchQueueCapacityLowerBound())\n+        .upperBound(threadPoolConfig.searchQueueCapacityUpperBound())\n+        .build();\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  /**\n+   * This function divide the range {lower bound - upper bound } of search/wrire queue into", "originalCommit": "158721b562b91aa47323b8a62259f8e661e356a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyNTY5OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r482725698", "bodyText": "@rguo-aws pls fix before merging", "author": "vigyasharma", "createdAt": "2020-09-03T06:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxOTUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE3ODA0MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r483178041", "bodyText": "done", "author": "rguo-aws", "createdAt": "2020-09-03T18:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQxOTUzOA=="}], "type": "inlineReview"}, {"oid": "64d3f72f3eb8c8b5829d0e935548cc7a17d4be31", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/64d3f72f3eb8c8b5829d0e935548cc7a17d4be31", "message": "Merge remote-tracking branch 'origin' into rguo-jvm-decider", "committedDate": "2020-09-01T21:20:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NDI5Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r481484296", "bodyText": "Let's move these to CacheActionConfig? we can call them soft-upper/lower-bound.", "author": "vigyasharma", "createdAt": "2020-09-01T23:19:48Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/configs/decider/jvm/LevelOneActionBuilderConfig.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.ConfigUtils;\n+import java.util.Map;\n+\n+public class LevelOneActionBuilderConfig {\n+  public static final double DEFAULT_FIELD_DATA_CACHE_LOWER_BOUND = 0.1;\n+  public static final double DEFAULT_SHARD_REQUEST_CACHE_LOWER_BOUND = 0.02;\n+  private static String FIELD_DATA_CACHE_LOWER_BOUND_CONFIG_NAME = \"fielddata-cache-lower-bound\";\n+  private static String SHARD_REQUEST_CACHE_LOWER_BOUND_CONFIG_NAME = \"shard-request-cache-lower-bound\";", "originalCommit": "158721b562b91aa47323b8a62259f8e661e356a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NDg4NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r481484884", "bodyText": "Pls see if you really need a lower-bound, level-1-bound, level-2-bound, upper-bound? Can we do away with level-2 bound?", "author": "vigyasharma", "createdAt": "2020-09-01T23:21:29Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/configs/decider/jvm/LevelTwoActionBuilderConfig.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.ConfigUtils;\n+import java.util.Map;\n+\n+public class LevelTwoActionBuilderConfig {\n+  public static final double DEFAULT_FIELD_DATA_CACHE_LOWER_BOUND = 0.02;\n+  public static final double DEFAULT_SHARD_REQUEST_CACHE_LOWER_BOUND = 0.01;\n+  public static final int DEFAULT_CACHE_ACTION_STEP_COUNT = 2;\n+  public static final int DEFAULT_QUEUE_ACTION_STEP_COUNT = 1;\n+  public static final int DEFAULT_QUEUE_BUCKET_SIZE = 10;\n+  private static String FIELD_DATA_CACHE_LOWER_BOUND_CONFIG_NAME = \"fielddata-cache-lower-bound\";\n+  private static String SHARD_REQUEST_CACHE_LOWER_BOUND_CONFIG_NAME = \"shard-request-cache-lower-bound\";", "originalCommit": "158721b562b91aa47323b8a62259f8e661e356a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NTA4Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r481485086", "bodyText": "Can these be merged with queue/cache action configs?", "author": "vigyasharma", "createdAt": "2020-09-01T23:22:01Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/configs/decider/jvm/LevelTwoActionBuilderConfig.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.ConfigUtils;\n+import java.util.Map;\n+\n+public class LevelTwoActionBuilderConfig {", "originalCommit": "158721b562b91aa47323b8a62259f8e661e356a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM5OTU2OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r482399568", "bodyText": "this config object currently defines the step size of each action that decider is going to issue in each level. and we might add more knobs for each level in the future. so i think it would be better to keep this config separately", "author": "rguo-aws", "createdAt": "2020-09-02T20:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4NTA4Ng=="}], "type": "inlineReview"}, {"oid": "e9c6ead72d1fc3b67ba0086aaa0290f8b6dc0198", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/e9c6ead72d1fc3b67ba0086aaa0290f8b6dc0198", "message": "rebase to the latest master", "committedDate": "2020-09-02T01:16:49Z", "type": "commit"}, {"oid": "38366cd4d5266aa1de5e535d27f8134a97d260b8", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/38366cd4d5266aa1de5e535d27f8134a97d260b8", "message": "Address more PR comments", "committedDate": "2020-09-03T01:34:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyMzM0MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r482723340", "bodyText": "Nice!", "author": "vigyasharma", "createdAt": "2020-09-03T06:03:13Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/actions/configs/CacheActionConfig.java", "diffHunk": "@@ -64,9 +68,24 @@ public CacheActionConfig(RcaConf conf) {\n     cacheSettingsConfig = new NestedConfig(\"cache-settings\", actionConfig);\n     fieldDataCacheConfig = new FieldDataCacheConfig(cacheSettingsConfig);\n     shardRequestCacheConfig = new ShardRequestCacheConfig(cacheSettingsConfig);\n+    totalStepCount = new Config<>(TOTAL_STEP_COUNT_CONFIG_NAME, cacheSettingsConfig.getValue(),\n+        DEFAULT_TOTAL_STEP_COUNT, (s) -> (s > 0), Integer.class);\n     createThresholdConfigMap();\n   }\n \n+  public int getTotalStepCount() {\n+    return totalStepCount.getValue();\n+  }\n+\n+  /**\n+   * this function calculate the size of a single step given the range {lower bound - upper bound}\n+   * and number of steps\n+   */\n+  public double getStepSize(ResourceEnum cacheType) {\n+    ThresholdConfig<Double> threshold = getThresholdConfig(cacheType);\n+    return (threshold.upperBound() - threshold.lowerBound()) / (double) getTotalStepCount();\n+  }", "originalCommit": "38366cd4d5266aa1de5e535d27f8134a97d260b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIyODAxNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r483228017", "bodyText": "+1", "author": "sidheart", "createdAt": "2020-09-03T20:13:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyMzM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyNjU3Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r482726572", "bodyText": "if ingest is preferable, we should downsize search queue, no?", "author": "vigyasharma", "createdAt": "2020-09-03T06:12:24Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/decisionmaker/deciders/jvm/old_gen/LevelTwoActionBuilder.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.deciders.jvm.old_gen;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.Action;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyCacheMaxSizeAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.ModifyQueueCapacityAction;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.configs.CacheActionConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.configs.QueueActionConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.decisionmaker.actions.configs.ThresholdConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.ResourceEnum;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.DeciderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.WorkLoadTypeConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm.LevelTwoActionBuilderConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider.jvm.OldGenDecisionPolicyConfig;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.collector.NodeConfigCache;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.cluster.NodeKey;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.util.NodeConfigCacheReaderUtil;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * build actions if old gen falls into level two bucket\n+ *\n+ * <p>if old gen usage(after full gc) is between 75% - 90%, it means the JVM starts to become contended and\n+ * full GC is not able to free up enough objects to bring down heap usage to below 75%.\n+ * In this case, we will downsize both caches by a larger step size and starts to downsize queues.\n+ * The action builder in this level will only try to downsize one type of queue at a time. And action priority\n+ * is used as a tie breaker if both queues are equally important in terms of reducing heap usage..\n+ *\n+ * <p>For field data cache, the lower bound in this bucket is 2% of the heap\n+ * and for shard request cache / query cache, it will be 1% of the heap\n+ */\n+public class LevelTwoActionBuilder {\n+  private final AppContext appContext;\n+  private final RcaConf rcaConf;\n+  private final OldGenDecisionPolicyConfig oldGenDecisionPolicyConfig;\n+  private final LevelTwoActionBuilderConfig actionBuilderConfig;\n+  private final WorkLoadTypeConfig workLoadTypeConfig;\n+  private final CacheActionConfig cacheActionConfig;\n+  private final QueueActionConfig queueActionConfig;\n+  private final NodeKey esNode;\n+  private final Map<ResourceEnum, ModifyCacheMaxSizeAction> cacheActionMap;\n+  private final Map<ResourceEnum, ModifyQueueCapacityAction> queueActionMap;\n+  private final Map<ResourceEnum, Boolean> actionFilter;\n+\n+  private LevelTwoActionBuilder(final NodeKey esNode, final AppContext appContext,\n+      final RcaConf rcaConf) {\n+    this.appContext = appContext;\n+    this.rcaConf = rcaConf;\n+    DeciderConfig deciderConfig = rcaConf.getDeciderConfig();\n+    this.oldGenDecisionPolicyConfig = rcaConf.getDeciderConfig().getOldGenDecisionPolicyConfig();\n+    this.actionBuilderConfig = deciderConfig.getOldGenDecisionPolicyConfig().levelTwoActionBuilderConfig();\n+    this.workLoadTypeConfig = deciderConfig.getWorkLoadTypeConfig();\n+    this.cacheActionConfig = rcaConf.getCacheActionConfig();\n+    this.queueActionConfig = rcaConf.getQueueActionConfig();\n+    this.esNode = esNode;\n+    this.cacheActionMap = new HashMap<>();\n+    this.queueActionMap = new HashMap<>();\n+    this.actionFilter = new HashMap<>();\n+    registerActions();\n+    actionPriorityFilter();\n+  }\n+\n+  public static LevelTwoActionBuilder newBuilder(final NodeKey esNode, final AppContext appContext,\n+      final RcaConf rcaConf) {\n+    return new LevelTwoActionBuilder(esNode, appContext, rcaConf);\n+  }\n+\n+  private void addFieldDataCacheAction() {\n+    double stepSizeInPercent = cacheActionConfig.getStepSize(ResourceEnum.FIELD_DATA_CACHE);\n+\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction\n+        .newBuilder(esNode, ResourceEnum.FIELD_DATA_CACHE, appContext, rcaConf)\n+        .increase(false)\n+        .stepSizeInPercent(stepSizeInPercent * actionBuilderConfig.fieldDataCacheStepSize())\n+        .build();\n+    if (action.isActionable()) {\n+      cacheActionMap.put(ResourceEnum.FIELD_DATA_CACHE, action);\n+    }\n+  }\n+\n+  private void addShardRequestCacheAction() {\n+    double stepSizeInPercent = cacheActionConfig.getStepSize(ResourceEnum.SHARD_REQUEST_CACHE);\n+\n+    ModifyCacheMaxSizeAction action = ModifyCacheMaxSizeAction\n+        .newBuilder(esNode, ResourceEnum.SHARD_REQUEST_CACHE, appContext, rcaConf)\n+        .increase(false)\n+        .stepSizeInPercent(stepSizeInPercent * actionBuilderConfig.shardRequestCacheStepSize())\n+        .build();\n+    if (action.isActionable()) {\n+      cacheActionMap.put(ResourceEnum.SHARD_REQUEST_CACHE, action);\n+    }\n+  }\n+\n+  private void addWriteQueueAction() {\n+    int stepSize = queueActionConfig.getStepSize(ResourceEnum.WRITE_THREADPOOL);\n+\n+    ModifyQueueCapacityAction action = ModifyQueueCapacityAction\n+        .newBuilder(esNode, ResourceEnum.WRITE_THREADPOOL, appContext, rcaConf)\n+        .increase(false)\n+        .stepSize(stepSize * actionBuilderConfig.writeQueueStepSize())\n+        .build();\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.WRITE_THREADPOOL, action);\n+    }\n+  }\n+\n+  private void addSearchQueueAction() {\n+    int stepSize = queueActionConfig.getStepSize(ResourceEnum.SEARCH_THREADPOOL);\n+\n+    ModifyQueueCapacityAction action = ModifyQueueCapacityAction\n+        .newBuilder(esNode, ResourceEnum.SEARCH_THREADPOOL, appContext, rcaConf)\n+        .increase(false)\n+        .stepSize(stepSize * actionBuilderConfig.searchQueueStepSize())\n+        .build();\n+    if (action.isActionable()) {\n+      queueActionMap.put(ResourceEnum.SEARCH_THREADPOOL, action);\n+    }\n+  }\n+\n+\n+  private void actionPriorityForCache() {\n+    actionFilter.put(ResourceEnum.FIELD_DATA_CACHE, true);\n+    actionFilter.put(ResourceEnum.SHARD_REQUEST_CACHE, true);\n+  }\n+\n+  /**\n+   * This function divide the range {lower bound - upper bound } of search/wrire queue into\n+   * buckets. And allocate the val into its corresponding bucket. The value here refers to the\n+   * EWMA size of search/write queue. step here is calculated as {range of queue} / {num of buckets}\n+   * The queue's lower/upper bound can be configured in rca.conf\n+   */\n+  private int bucketization(int lowerBound, int upperBound, int val, int bucketSize) {\n+    double step = (double) (upperBound - lowerBound) / (double) bucketSize;\n+    return (int) ((double) val / step);\n+  }\n+\n+  // downsize queue based on priority and current queue size\n+  private void actionPriorityForQueue() {\n+    NodeConfigCache nodeConfigCache = appContext.getNodeConfigCache();\n+    Integer writeQueueCapacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.WRITE_THREADPOOL);\n+    Integer searchQueueCapacity = NodeConfigCacheReaderUtil\n+        .readQueueCapacity(nodeConfigCache, esNode, ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueCapacity == null || searchQueueCapacity == null) {\n+      return;\n+    }\n+    ModifyQueueCapacityAction writeQueueAction = queueActionMap.get(ResourceEnum.WRITE_THREADPOOL);\n+    ModifyQueueCapacityAction searchQueueAction = queueActionMap.get(ResourceEnum.SEARCH_THREADPOOL);\n+    ThresholdConfig<Integer> writeQueueConfig = queueActionConfig.getThresholdConfig(ResourceEnum.WRITE_THREADPOOL);\n+    ThresholdConfig<Integer> searchQueueConfig = queueActionConfig.getThresholdConfig(ResourceEnum.SEARCH_THREADPOOL);\n+    if (writeQueueAction != null && searchQueueAction != null) {\n+      int writeQueueSizeBucket = bucketization(\n+          writeQueueConfig.lowerBound(),\n+          writeQueueConfig.upperBound(),\n+          writeQueueCapacity,\n+          oldGenDecisionPolicyConfig.queueBucketSize());\n+      int searchQueueSizeBucket = bucketization(\n+          searchQueueConfig.lowerBound(),\n+          searchQueueConfig.upperBound(),\n+          searchQueueCapacity,\n+          oldGenDecisionPolicyConfig.queueBucketSize());\n+      if (writeQueueSizeBucket > searchQueueSizeBucket) {\n+        actionFilter.put(ResourceEnum.WRITE_THREADPOOL, true);\n+      }\n+      else if (writeQueueSizeBucket < searchQueueSizeBucket) {\n+        actionFilter.put(ResourceEnum.SEARCH_THREADPOOL, true);\n+      }\n+      // tie breaker\n+      else {\n+        if (workLoadTypeConfig.preferIngestOverSearch()) {\n+          actionFilter.put(ResourceEnum.WRITE_THREADPOOL, true);", "originalCommit": "38366cd4d5266aa1de5e535d27f8134a97d260b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE3ODM5Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r483178393", "bodyText": "thanks for catching this. Yes we should downsize search queue instead.", "author": "rguo-aws", "createdAt": "2020-09-03T18:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyNjU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyNzIyOA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r482727228", "bodyText": "Does this work? I was having trouble casting with generics", "author": "vigyasharma", "createdAt": "2020-09-03T06:14:21Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/configs/decider/CachePriorityOrderConfig.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.Config;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.NestedConfig;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * \"cache-type\": {\n+ *    \"priority-order\": [\"fielddata-cache\", \"shard-request-cache\"]\n+ * }\n+ */\n+public class CachePriorityOrderConfig {\n+  private static final String PRIORITY_ORDER_CONFIG_NAME = \"priority-order\";\n+  private static String FIELDDATA_CACHE = \"fielddata-cache\";\n+  private static String SHARD_REQUEST_CACHE = \"shard-request-cache\";\n+  public static final List<String> DEFAULT_PRIORITY_ORDER = Collections.unmodifiableList(\n+      Arrays.asList(FIELDDATA_CACHE, SHARD_REQUEST_CACHE));\n+  private Config<List<String>> priorityOrder;\n+\n+  public CachePriorityOrderConfig(NestedConfig configs) {\n+    priorityOrder = new Config(PRIORITY_ORDER_CONFIG_NAME, configs.getValue(),\n+        DEFAULT_PRIORITY_ORDER, List.class);", "originalCommit": "38366cd4d5266aa1de5e535d27f8134a97d260b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE3ODc1NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r483178755", "bodyText": "yes, casting to a raw list still works. it can still pass the UTs that Adithya wrote which overrides the config settings in rca.conf and read this object to verify the changes.", "author": "rguo-aws", "createdAt": "2020-09-03T18:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyNzIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyODM0NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r482728344", "bodyText": "Since there is only search and ingest (2 values), we can make this simpler by renaming the config. Instead of taking a list, we can do things like:\n{ \"decider-config-settings\": {\n    \"prefer-ingest-over-search\": true\n    }\n}", "author": "vigyasharma", "createdAt": "2020-09-03T06:17:29Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/configs/decider/WorkLoadTypeConfig.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.configs.decider;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.Config;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.NestedConfig;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+/**\n+ * \"workload-type\": {\n+ *   \"priority-order\": [\"ingest\", \"search\"]\n+ * }\n+ */\n+public class WorkLoadTypeConfig {\n+\n+  private static final String PRIORITY_ORDER_CONFIG_NAME = \"priority-order\";\n+  private static String INGEST = \"ingest\";\n+  private static String SEARCH = \"search\";\n+  public static final List<String> DEFAULT_PRIORITY_ORDER = Collections.unmodifiableList(\n+      Arrays.asList(INGEST, SEARCH));\n+  private Config<List<String>> priorityOrder;\n+  private Predicate<List<String>> listValidator;\n+\n+  public WorkLoadTypeConfig(NestedConfig configs) {\n+    listValidator = (list) -> {", "originalCommit": "38366cd4d5266aa1de5e535d27f8134a97d260b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNjY3MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/326#discussion_r483206670", "bodyText": "done. changed the config to\n\"workload-type\": {\n\"prefer-ingest\": true,\n\"prefer-search\": false\n},\nThis will allow user to not assign workload preference to any queue type", "author": "rguo-aws", "createdAt": "2020-09-03T19:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyODM0NA=="}], "type": "inlineReview"}, {"oid": "d7ef3396d129aa3d99ae926eec4e87507c15ce72", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/d7ef3396d129aa3d99ae926eec4e87507c15ce72", "message": "Address more comments", "committedDate": "2020-09-03T19:34:22Z", "type": "commit"}]}