{"pr_number": 301, "pr_title": "Integration test framework to test RCAs and decision Makers ", "pr_createdAt": "2020-07-24T04:26:37Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301", "timeline": [{"oid": "9ad007c5ea8eb5d30f129aa30c39d4c845d25563", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/9ad007c5ea8eb5d30f129aa30c39d4c845d25563", "message": "rebasing changes", "committedDate": "2020-08-03T18:24:45Z", "type": "forcePushed"}, {"oid": "c43eab49ba40a6ca875c2ba0a30afa263b2356ca", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/c43eab49ba40a6ca875c2ba0a30afa263b2356ca", "message": "Integration test framework to test RCAs and decision Makers\n\nThis PR introduces a framework that can be used to write tests concerning\nRCA graph and all the components that leverage it(RCAs, Deciders etc.).\nCurrently it supports adding custom metrics, running tests against\nsingle node cluster, multi-node clusters with dedicated masters and\nthe ones without dedicated masters. It provies a way to query the\nSQLite datastore file on a particular host or hit the rest endpoint\non a particular node. Currently, the nodes of the clsuters work over\nhttp only.", "committedDate": "2020-08-04T18:25:35Z", "type": "forcePushed"}, {"oid": "8ac14bfe465c2a87105aded687745ab165d9de55", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/8ac14bfe465c2a87105aded687745ab165d9de55", "message": "Integration test framework to test RCAs and decision Makers\n\nThis PR introduces a framework that can be used to write tests concerning\nRCA graph and all the components that leverage it(RCAs, Deciders etc.).\nCurrently it supports adding custom metrics, running tests against\nsingle node cluster, multi-node clusters with dedicated masters and\nthe ones without dedicated masters. It provies a way to query the\nSQLite datastore file on a particular host or hit the rest endpoint\non a particular node. Currently, the nodes of the clsuters work over\nhttp only.", "committedDate": "2020-08-05T19:17:30Z", "type": "forcePushed"}, {"oid": "d5f98c1af5304377226d18f19b52d00b9e98ea5f", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/d5f98c1af5304377226d18f19b52d00b9e98ea5f", "message": "Fixed a bug where the database was being corrupted because of multiple scheduler initializations.", "committedDate": "2020-08-07T00:10:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMDUwOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r467320509", "bodyText": "Result and Record are closely coupled with SQL. Do we want to expose that level of details in Persistable interface ?", "author": "rguo-aws", "createdAt": "2020-08-07T23:01:37Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/Persistable.java", "diffHunk": "@@ -54,4 +56,10 @@\n   <T extends ResourceFlowUnit> void write(Node<?> node, T flowUnit) throws SQLException, IOException;\n \n   void close() throws SQLException;\n+\n+  List<Result<Record>> getRecordsForAllTables();", "originalCommit": "d5f98c1af5304377226d18f19b52d00b9e98ea5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxMDc0Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468210743", "bodyText": "Making it so that we can access the RCAs only via the Rest API.", "author": "yojs", "createdAt": "2020-08-10T22:01:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMDUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMTU2OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r467321568", "bodyText": "Maybe I am wrong. but since we've already added synchronized keyword in the parent function which calls this private function, do we still need to add another synchronized keyword here ?", "author": "rguo-aws", "createdAt": "2020-08-07T23:06:08Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/PersistorBase.java", "diffHunk": "@@ -245,14 +249,14 @@ private synchronized void rotateRegisterGarbageThenCreateNewDB(RotationType type\n   }\n \n   /** recursively insert nested summary to sql tables */\n-  private void writeSummary(\n+  private synchronized void writeSummary(", "originalCommit": "d5f98c1af5304377226d18f19b52d00b9e98ea5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxMTE1OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468211158", "bodyText": "No you are 100% right. Its not required. Its just that some of the private methods in the class were marked as synchronized so I made them all be so. Just making the public methods should suffice.", "author": "yojs", "createdAt": "2020-08-10T22:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyNzY5MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r467327690", "bodyText": "should we print an error log if otherwise", "author": "rguo-aws", "createdAt": "2020-08-07T23:34:57Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -321,8 +376,10 @@ private synchronized JsonElement getNonTemperatureRcas(String rca) {\n         }\n       }\n     } catch (DataAccessException de) {\n-      // it is totally fine if we fail to read some certain tables.\n-      LOG.warn(\"Fail to read RCA : {}, query = {},  exceptions : {}\", rca, rcaQuery.toString(), de.getStackTrace());\n+      if (!de.getMessage().contains(\"no such table\")) {\n+        // it is totally fine if we fail to read some certain tables.\n+        LOG.warn(\"Fail to read RCA : {}.\", rca, de);\n+      }", "originalCommit": "d5f98c1af5304377226d18f19b52d00b9e98ea5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxMTg4Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468211887", "bodyText": "You mean make it an error log instead of warning ?", "author": "yojs", "createdAt": "2020-08-10T22:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyNzY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyODQxOA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r467328418", "bodyText": "this will contain RCAs that are not cluster level RCAs. Do we also want to expose node level RCAs on local master node to user ?", "author": "rguo-aws", "createdAt": "2020-08-07T23:38:48Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rest/QueryRcaRequestHandler.java", "diffHunk": "@@ -162,13 +162,20 @@ public void handle(HttpExchange exchange) throws IOException {\n \n   private void handleClusterRcaRequest(Map<String, String> params, HttpExchange exchange)\n       throws IOException {\n+    //check if we are querying from elected master\n+    if (!validNodeRole()) {\n+      JsonObject errResponse = new JsonObject();\n+      errResponse.addProperty(\"error\", \"Node being queried is not elected master.\");\n+      sendResponse(exchange, errResponse.toString(),\n+              HttpURLConnection.HTTP_BAD_REQUEST);\n+      return;\n+    }\n     List<String> rcaList = metricsRestUtil.parseArrayParam(params, NAME_PARAM, true);\n     // query all cluster level RCAs if no RCA is specified in name.\n     if (rcaList.isEmpty()) {\n-      rcaList = SQLiteQueryUtils.getClusterLevelRca();\n-    }\n-    //check if RCA is valid\n-    if (!validParams(rcaList)) {\n+      // rcaList = SQLiteQueryUtils.getClusterLevelRca();\n+      rcaList = persistable.getAllPersistedRcas();", "originalCommit": "d5f98c1af5304377226d18f19b52d00b9e98ea5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxMjcxNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468212715", "bodyText": "I would like to. Eventually, We would want to expose the RCAs on the local node, if they are not elected master.\nThe only thing with RCAs are that they are nested so, we won't want one node to gather RCAs from all nodes but if the request hits a node, it should be able to get all local RCAs.", "author": "yojs", "createdAt": "2020-08-10T22:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyODQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyODU2Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r467328563", "bodyText": "same as above", "author": "rguo-aws", "createdAt": "2020-08-07T23:39:34Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rest/QueryRcaRequestHandler.java", "diffHunk": "@@ -178,14 +185,6 @@ private void handleClusterRcaRequest(Map<String, String> params, HttpExchange ex\n           HttpURLConnection.HTTP_BAD_REQUEST);\n       return;\n     }\n-    //check if we are querying from elected master", "originalCommit": "d5f98c1af5304377226d18f19b52d00b9e98ea5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxMjg4MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468212880", "bodyText": "we would want to", "author": "yojs", "createdAt": "2020-08-10T22:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyODU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyOTY3NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r467329675", "bodyText": "Can we simply pass the Cluster object into Host object ?", "author": "rguo-aws", "createdAt": "2020-08-07T23:45:10Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/Host.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.ClientServers;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.PerformanceAnalyzerApp;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaController;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATuple;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.Consts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.HostTag;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaControllerIt;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaItMetricsDBProvider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RCAScheduler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RcaSchedulerState;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.threads.ThreadProvider;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.junit.Assert;\n+\n+/**\n+ * This class simulates a cluster node that executes an RCA graph. Each node has its own\n+ * - GRPC server,\n+ * - web server\n+ * - RCAController and everything that it starts.\n+ */\n+public class Host {\n+  private static final Logger LOG = LogManager.getLogger(Host.class);\n+  private final boolean useHttps;\n+  /**\n+   * Each host has its own AppContext instance.\n+   */\n+  private final AppContext appContext;\n+  private final HostTag myTag;\n+  /**\n+   * This uniquely identifies a host.\n+   */\n+  private final int hostId;\n+  /**\n+   * For Integration tests, where all the virtual nodes are part of the same JVM, Ip string does not matter. But for\n+   * the sake of having this value filled, the string is 127.0.0.(hostId).\n+   */\n+  private final String hostIp;\n+  private final AllMetrics.NodeRole role;\n+  private final int webServerPort;\n+  private final int grpcServerPort;\n+  private final File hostDir;\n+  private final boolean rcaEnabled;\n+  private GRPCConnectionManager connectionManager;\n+  private ClientServers clientServers;\n+  private ScheduledExecutorService netOperationsExecutor;\n+  private RcaControllerIt rcaController;\n+  private Thread grpcThread;\n+  private Thread webServerThread;\n+  private Thread rcaControllerThread;\n+  private ThreadProvider threadProvider;\n+  private Path rcaEnabledFile;\n+\n+  public Host(int hostId,\n+              boolean useHttps,\n+              AllMetrics.NodeRole role,\n+              int httpServerPort,\n+              int grpcServerPort,\n+              File clusterDir,", "originalCommit": "d5f98c1af5304377226d18f19b52d00b9e98ea5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxMzIzNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468213237", "bodyText": "This will disrupt the layered structure. The way it is that cluster has the data for all the hosts but hosts don't", "author": "yojs", "createdAt": "2020-08-10T22:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyOTY3NQ=="}], "type": "inlineReview"}, {"oid": "759cd64fdfd0ed028b017940f14b52b3871c60f2", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/759cd64fdfd0ed028b017940f14b52b3871c60f2", "message": "Integration test framework to test RCAs and decision Makers\n\nThis PR introduces a framework that can be used to write tests concerning\nRCA graph and all the components that leverage it(RCAs, Deciders etc.).\nCurrently it supports adding custom metrics, running tests against\nsingle node cluster, multi-node clusters with dedicated masters and\nthe ones without dedicated masters. It provies a way to query the\nSQLite datastore file on a particular host or hit the rest endpoint\non a particular node. Currently, the nodes of the clsuters work over\nhttp only.", "committedDate": "2020-08-10T23:00:00Z", "type": "commit"}, {"oid": "209e36f6f6087924b7e834f02c4aaa0ce938a45e", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/209e36f6f6087924b7e834f02c4aaa0ce938a45e", "message": "Fixed a bug where the database was being corrupted because of multiple scheduler initializations.", "committedDate": "2020-08-10T23:00:00Z", "type": "commit"}, {"oid": "ccf1ebdf02645e945d9513047f82259a5d1901f3", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/ccf1ebdf02645e945d9513047f82259a5d1901f3", "message": "Fix the POC graph", "committedDate": "2020-08-10T23:00:00Z", "type": "commit"}, {"oid": "0d43965d5e687b61ba81553042ce50f836b6ec76", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/0d43965d5e687b61ba81553042ce50f836b6ec76", "message": "Removing unused methods", "committedDate": "2020-08-10T23:00:00Z", "type": "commit"}, {"oid": "0d43965d5e687b61ba81553042ce50f836b6ec76", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/0d43965d5e687b61ba81553042ce50f836b6ec76", "message": "Removing unused methods", "committedDate": "2020-08-10T23:00:00Z", "type": "forcePushed"}, {"oid": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "message": "Name the validation checks that failed", "committedDate": "2020-08-11T00:47:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MTM0Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466571342", "bodyText": "For my own curiosity, why did this method need to be synchronized?", "author": "sidheart", "createdAt": "2020-08-06T17:26:32Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -187,6 +192,35 @@ synchronized String readTables() {\n     return tablesObject.toString();\n   }\n \n+  public synchronized List<Result<Record>> getRecordsForAllTables() {", "originalCommit": "8ac14bfe465c2a87105aded687745ab165d9de55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODczNjAyNg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468736026", "bodyText": "We removed this in the latest revision. Because the REST API queries the DB to return the result. Therefore, we don't need this. This will simplify, what a validator has to override.", "author": "yojs", "createdAt": "2020-08-11T17:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MTM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0MDE1MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468740150", "bodyText": "To answer the question, this is required because a the SQLite will synchronize access to DB by default (unless you ask it not to bother about it). In our cases, we don't override so writes to DB are synchronized. But we do something that can lead to errors. We, rotate the DB file with  certain periodicity. SO it might so happen that when we wanted to read, the DB context was invalid and we will error out.", "author": "yojs", "createdAt": "2020-08-11T17:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MTM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MzIzMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466573231", "bodyText": "Why did you wrap this method call instead of just making getRecords public?", "author": "sidheart", "createdAt": "2020-08-06T17:29:51Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -187,6 +192,35 @@ synchronized String readTables() {\n     return tablesObject.toString();\n   }\n \n+  public synchronized List<Result<Record>> getRecordsForAllTables() {\n+    List<Result<Record>> results = new ArrayList<>();\n+    super.tableNames.forEach(\n+            table -> results.add(getRecords(table))\n+    );\n+    return results;\n+  }\n+\n+  @Override\n+  public Result<Record> getRecordsForTable(String tableName) {\n+    return getRecords(tableName);\n+  }", "originalCommit": "8ac14bfe465c2a87105aded687745ab165d9de55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0MDQ1MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468740451", "bodyText": "This is no longer present in the latest revision", "author": "yojs", "createdAt": "2020-08-11T17:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MzIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3ODgxNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466578817", "bodyText": "nit: slightly misleading, this isn't a list of tables, but a list of rcaNames right?", "author": "sidheart", "createdAt": "2020-08-06T17:39:32Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -187,6 +192,35 @@ synchronized String readTables() {\n     return tablesObject.toString();\n   }\n \n+  public synchronized List<Result<Record>> getRecordsForAllTables() {\n+    List<Result<Record>> results = new ArrayList<>();\n+    super.tableNames.forEach(\n+            table -> results.add(getRecords(table))\n+    );\n+    return results;\n+  }\n+\n+  @Override\n+  public Result<Record> getRecordsForTable(String tableName) {\n+    return getRecords(tableName);\n+  }\n+\n+\n+  @Override\n+  public List<String> getAllPersistedRcas() {\n+    List<String> tables = new ArrayList<>();", "originalCommit": "8ac14bfe465c2a87105aded687745ab165d9de55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0MTQ1NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468741454", "bodyText": "you are right. I will rename the variable.", "author": "yojs", "createdAt": "2020-08-11T17:20:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3ODgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4MDQyNQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466580425", "bodyText": "Remove the exceptions: {} portion of the message.  Passing a throwable as the final argument to a Logger call prints the message and the stacktrace.", "author": "sidheart", "createdAt": "2020-08-06T17:42:29Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -287,7 +339,7 @@ private synchronized void readSummary(GenericSummary upperLevelSummary, int uppe\n       } catch (DataAccessException de) {\n         // it is totally fine if we fail to read some certain tables as some types of summaries might be missing\n         LOG.warn(\"Fail to read Summary table : {}, query = {},  exceptions : {}\",\n-            nestedTableName, rcaQuery.toString(), de.getStackTrace());\n+            nestedTableName, rcaQuery.toString(), de);\n       } catch (IllegalArgumentException ie) {", "originalCommit": "8ac14bfe465c2a87105aded687745ab165d9de55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0Mzk1OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468743958", "bodyText": "I missed that. Thanks for catching it", "author": "yojs", "createdAt": "2020-08-11T17:24:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4MDQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4MDU5NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466580595", "bodyText": "Same as above", "author": "sidheart", "createdAt": "2020-08-06T17:42:48Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/SQLitePersistor.java", "diffHunk": "@@ -322,7 +374,7 @@ private synchronized JsonElement getNonTemperatureRcas(String rca) {\n       }\n     } catch (DataAccessException de) {\n       // it is totally fine if we fail to read some certain tables.\n-      LOG.warn(\"Fail to read RCA : {}, query = {},  exceptions : {}\", rca, rcaQuery.toString(), de.getStackTrace());\n+      LOG.warn(\"Fail to read RCA : {}, query = {},  exceptions : {}\", rca, rcaQuery.toString(), de);", "originalCommit": "8ac14bfe465c2a87105aded687745ab165d9de55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4MzA3Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466583077", "bodyText": "nit: This file didn't need to be changed as part of this commit", "author": "sidheart", "createdAt": "2020-08-06T17:47:18Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/reader/ClusterDetailsEventProcessor.java", "diffHunk": "@@ -184,6 +176,14 @@ public NodeDetails(final NodeDetails other) {\n       }\n     }\n \n+    public NodeDetails(AllMetrics.NodeRole role, String id, String hostAddress, boolean isMaster, int grpcPort) {\n+      this.role = role.toString();\n+      this.id = id;\n+      this.hostAddress = hostAddress;\n+      this.isMasterNode = isMaster;\n+      this.grpcPort = grpcPort;\n+    }\n+", "originalCommit": "8ac14bfe465c2a87105aded687745ab165d9de55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5Mzk5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466593991", "bodyText": "nit: delete extra tab", "author": "sidheart", "createdAt": "2020-08-06T18:06:25Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/RcaControllerTest.java", "diffHunk": "@@ -129,7 +127,8 @@ public void setUp() throws Exception {\n             rcaEnabledFileLoc.toString(),\n             100,\n             200,\n-            appContext\n+            appContext,\n+                new MetricsDBProviderTestHelper()", "originalCommit": "8ac14bfe465c2a87105aded687745ab165d9de55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NTI4Mg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466595282", "bodyText": "Thanks for removing this. Do you know why we were doing this Whitebox stuff in the first place?", "author": "sidheart", "createdAt": "2020-08-06T18:08:47Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/RcaControllerTest.java", "diffHunk": "@@ -203,14 +202,14 @@ public void readAndUpdateMutedRcasBeforeGraphCreation() throws Exception {\n     Field mutedGraphNodesField = Stats.class.getDeclaredField(\"mutedGraphNodes\");\n     mutedGraphNodesField.setAccessible(true);\n     mutedGraphNodesField.set(Stats.getInstance(), null);\n-    Set<String> initialComponentSet = ConnectedComponent.getNodeNames();\n-    Whitebox.setInternalState(ConnectedComponent.class, \"nodeNames\", new HashSet<>());\n+    Set<String> initialComponentSet = ConnectedComponent.getNodesForAllComponents(rcaController.getConnectedComponents());\n+    // Whitebox.setInternalState(ConnectedComponent.class, \"nodeNames\", new HashSet<>());\n \n     readAndUpdateMutesRcas.invoke(rcaController);\n     Assert.assertNull(Stats.getInstance().getMutedGraphNodes());\n \n     // Re-set back to initialComponentSet\n-    Whitebox.setInternalState(ConnectedComponent.class, \"nodeNames\", initialComponentSet);", "originalCommit": "8ac14bfe465c2a87105aded687745ab165d9de55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNTc3Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466615773", "bodyText": "LOG.error(\"netOE failed to terminate\", e);", "author": "sidheart", "createdAt": "2020-08-06T18:47:12Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/Host.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.ClientServers;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.PerformanceAnalyzerApp;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaController;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATuple;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.Consts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.HostTag;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaControllerIt;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaItMetricsDBProvider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RCAScheduler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RcaSchedulerState;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.threads.ThreadProvider;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.junit.Assert;\n+\n+/**\n+ * This class simulates a cluster node that executes an RCA graph. Each node has its own\n+ * - GRPC server,\n+ * - web server\n+ * - RCAController and everything that it starts.\n+ */\n+public class Host {\n+  private static final Logger LOG = LogManager.getLogger(Host.class);\n+  private final boolean useHttps;\n+  /**\n+   * Each host has its own AppContext instance.\n+   */\n+  private final AppContext appContext;\n+  private final HostTag myTag;\n+  /**\n+   * This uniquely identifies a host.\n+   */\n+  private final int hostId;\n+  /**\n+   * For Integration tests, where all the virtual nodes are part of the same JVM, Ip string does not matter. But for\n+   * the sake of having this value filled, the string is 127.0.0.(hostId).\n+   */\n+  private final String hostIp;\n+  private final AllMetrics.NodeRole role;\n+  private final int webServerPort;\n+  private final int grpcServerPort;\n+  private final File hostDir;\n+  private final boolean rcaEnabled;\n+  private GRPCConnectionManager connectionManager;\n+  private ClientServers clientServers;\n+  private ScheduledExecutorService netOperationsExecutor;\n+  private RcaControllerIt rcaController;\n+  private Thread grpcThread;\n+  private Thread webServerThread;\n+  private Thread rcaControllerThread;\n+  private ThreadProvider threadProvider;\n+  private Path rcaEnabledFile;\n+\n+  public Host(int hostId,\n+              boolean useHttps,\n+              AllMetrics.NodeRole role,\n+              int httpServerPort,\n+              int grpcServerPort,\n+              File clusterDir,\n+              boolean rcaEnabled,\n+              HostTag myTag) {\n+    this.rcaEnabled = rcaEnabled;\n+    this.useHttps = useHttps;\n+    this.appContext = new AppContext();\n+\n+    this.hostId = hostId;\n+    this.myTag = myTag;\n+\n+    //TODO: make sure this works with the grpc and the webserver.\n+    this.hostIp = createHostIp();\n+    this.role = role;\n+\n+    this.webServerPort = httpServerPort;\n+    this.grpcServerPort = grpcServerPort;\n+\n+    this.hostDir = createHostDir(clusterDir, myTag);\n+  }\n+\n+  public static String createHostIp() {\n+    return \"127.0.0.1\";\n+  }\n+\n+  private static File createHostDir(File clusterDir, HostTag hostTag) {\n+    File hostFile = Paths.get(clusterDir.getAbsolutePath(), hostTag.toString()).toFile();\n+    if (!hostFile.exists() && !hostFile.mkdirs()) {\n+      throw new IllegalStateException(\"Couldn't create dir: \" + hostFile);\n+    }\n+    return hostFile;\n+  }\n+\n+  public void createServersAndThreads(final ThreadProvider threadProvider) throws Exception {\n+    this.threadProvider = threadProvider;\n+    Objects.requireNonNull(appContext.getClusterDetailsEventProcessor(),\n+        \"ClusterDetailsEventProcessor cannot be null in the AppContext\");\n+\n+    rcaEnabledFile = Paths.get(hostDir.getAbsolutePath(), RcaController.RCA_ENABLED_CONF_FILE);\n+    RcaSchedulerState state = rcaEnabled ? RcaSchedulerState.STATE_STARTED : RcaSchedulerState.STATE_STOPPED;\n+    setRcaState(state);\n+\n+    this.connectionManager = new GRPCConnectionManager(useHttps);\n+    this.clientServers = PerformanceAnalyzerApp.createClientServers(connectionManager,\n+        grpcServerPort,\n+        null,\n+        null,\n+        useHttps,\n+        String.valueOf(webServerPort),\n+        null,  // A null host is fine as this will use the loopback address\n+        this.appContext);\n+\n+    this.grpcThread = PerformanceAnalyzerApp.startGrpcServerThread(clientServers.getNetServer(), threadProvider);\n+    this.webServerThread = PerformanceAnalyzerApp.startWebServerThread(clientServers.getHttpServer(), threadProvider);\n+\n+    netOperationsExecutor =\n+        Executors.newScheduledThreadPool(\n+            3, new ThreadFactoryBuilder().setNameFormat(\"test-network-thread-%d\").build());\n+\n+    this.rcaController = new RcaControllerIt(\n+        threadProvider,\n+        netOperationsExecutor,\n+        connectionManager,\n+        clientServers,\n+        hostDir.getAbsolutePath(),\n+        10,\n+        10,\n+        role,\n+        appContext,\n+        null);\n+  }\n+\n+  // We create a temporary file and then swap it for the rca.enabled file.\n+  public void setRcaState(RcaSchedulerState rcaState) {\n+    Path rcaEnabledTmp = Paths.get(rcaEnabledFile + \".tmp\");\n+    try (FileWriter f2 = new FileWriter(rcaEnabledTmp.toFile(), false /*To create a new file*/)) {\n+      boolean value = true;\n+      switch (rcaState) {\n+        case STATE_NOT_STARTED:\n+          break;\n+        case STATE_STOPPED_DUE_TO_EXCEPTION:\n+          break;\n+        case STATE_STARTED:\n+          value = true;\n+          break;\n+        case STATE_STOPPED:\n+          value = false;\n+          break;\n+      }\n+      f2.write(String.valueOf(value));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+      return;\n+    }\n+    rcaEnabledTmp.toFile().renameTo(rcaEnabledFile.toFile());\n+  }\n+\n+  public void setClusterDetails(final List<Host> allHosts) {\n+    List<ClusterDetailsEventProcessor.NodeDetails> nodeDetails = new ArrayList<>();\n+\n+    // The first node in the list is always the node-itself.\n+    nodeDetails.add(hostToNodeDetails(this));\n+\n+    for (Host host : allHosts) {\n+      if (host.hostId != this.hostId) {\n+        nodeDetails.add(hostToNodeDetails(host));\n+      }\n+    }\n+    ClusterDetailsEventProcessor clusterDetailsEventProcessor = new ClusterDetailsEventProcessor();\n+    clusterDetailsEventProcessor.setNodesDetails(nodeDetails);\n+    appContext.setClusterDetailsEventProcessor(clusterDetailsEventProcessor);\n+  }\n+\n+  public static ClusterDetailsEventProcessor.NodeDetails hostToNodeDetails(final Host host) {\n+    return new ClusterDetailsEventProcessor.NodeDetails(\n+        host.role,\n+        host.getMyTag().toString(),\n+        host.hostIp,\n+        host.isElectedMaster(),\n+        host.grpcServerPort);\n+  }\n+\n+  public HostTag getMyTag() {\n+    return myTag;\n+  }\n+\n+  public boolean isElectedMaster() {\n+    return AllMetrics.NodeRole.ELECTED_MASTER == this.role;\n+  }\n+\n+  public void deleteHost() throws IOException {\n+    try {\n+      stopRcaScheduler();\n+    } catch (Exception e) {\n+      LOG.error(\"** Error shutting down the scheduler while deleting host.\", e);\n+    }\n+    RCAScheduler rcaScheduler = rcaController.getRcaScheduler();\n+    if (rcaScheduler != null && rcaScheduler.getState() == RcaSchedulerState.STATE_STARTED) {\n+      rcaScheduler.shutdown();\n+    }\n+    netOperationsExecutor.shutdown();\n+    try {\n+      netOperationsExecutor.awaitTermination(1, TimeUnit.MINUTES);\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();", "originalCommit": "8ac14bfe465c2a87105aded687745ab165d9de55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNjAwMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466616001", "bodyText": "Just LOG.error(ie);", "author": "sidheart", "createdAt": "2020-08-06T18:47:35Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/Host.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.ClientServers;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.PerformanceAnalyzerApp;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaController;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATuple;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.Consts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.HostTag;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaControllerIt;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaItMetricsDBProvider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RCAScheduler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RcaSchedulerState;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.threads.ThreadProvider;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.junit.Assert;\n+\n+/**\n+ * This class simulates a cluster node that executes an RCA graph. Each node has its own\n+ * - GRPC server,\n+ * - web server\n+ * - RCAController and everything that it starts.\n+ */\n+public class Host {\n+  private static final Logger LOG = LogManager.getLogger(Host.class);\n+  private final boolean useHttps;\n+  /**\n+   * Each host has its own AppContext instance.\n+   */\n+  private final AppContext appContext;\n+  private final HostTag myTag;\n+  /**\n+   * This uniquely identifies a host.\n+   */\n+  private final int hostId;\n+  /**\n+   * For Integration tests, where all the virtual nodes are part of the same JVM, Ip string does not matter. But for\n+   * the sake of having this value filled, the string is 127.0.0.(hostId).\n+   */\n+  private final String hostIp;\n+  private final AllMetrics.NodeRole role;\n+  private final int webServerPort;\n+  private final int grpcServerPort;\n+  private final File hostDir;\n+  private final boolean rcaEnabled;\n+  private GRPCConnectionManager connectionManager;\n+  private ClientServers clientServers;\n+  private ScheduledExecutorService netOperationsExecutor;\n+  private RcaControllerIt rcaController;\n+  private Thread grpcThread;\n+  private Thread webServerThread;\n+  private Thread rcaControllerThread;\n+  private ThreadProvider threadProvider;\n+  private Path rcaEnabledFile;\n+\n+  public Host(int hostId,\n+              boolean useHttps,\n+              AllMetrics.NodeRole role,\n+              int httpServerPort,\n+              int grpcServerPort,\n+              File clusterDir,\n+              boolean rcaEnabled,\n+              HostTag myTag) {\n+    this.rcaEnabled = rcaEnabled;\n+    this.useHttps = useHttps;\n+    this.appContext = new AppContext();\n+\n+    this.hostId = hostId;\n+    this.myTag = myTag;\n+\n+    //TODO: make sure this works with the grpc and the webserver.\n+    this.hostIp = createHostIp();\n+    this.role = role;\n+\n+    this.webServerPort = httpServerPort;\n+    this.grpcServerPort = grpcServerPort;\n+\n+    this.hostDir = createHostDir(clusterDir, myTag);\n+  }\n+\n+  public static String createHostIp() {\n+    return \"127.0.0.1\";\n+  }\n+\n+  private static File createHostDir(File clusterDir, HostTag hostTag) {\n+    File hostFile = Paths.get(clusterDir.getAbsolutePath(), hostTag.toString()).toFile();\n+    if (!hostFile.exists() && !hostFile.mkdirs()) {\n+      throw new IllegalStateException(\"Couldn't create dir: \" + hostFile);\n+    }\n+    return hostFile;\n+  }\n+\n+  public void createServersAndThreads(final ThreadProvider threadProvider) throws Exception {\n+    this.threadProvider = threadProvider;\n+    Objects.requireNonNull(appContext.getClusterDetailsEventProcessor(),\n+        \"ClusterDetailsEventProcessor cannot be null in the AppContext\");\n+\n+    rcaEnabledFile = Paths.get(hostDir.getAbsolutePath(), RcaController.RCA_ENABLED_CONF_FILE);\n+    RcaSchedulerState state = rcaEnabled ? RcaSchedulerState.STATE_STARTED : RcaSchedulerState.STATE_STOPPED;\n+    setRcaState(state);\n+\n+    this.connectionManager = new GRPCConnectionManager(useHttps);\n+    this.clientServers = PerformanceAnalyzerApp.createClientServers(connectionManager,\n+        grpcServerPort,\n+        null,\n+        null,\n+        useHttps,\n+        String.valueOf(webServerPort),\n+        null,  // A null host is fine as this will use the loopback address\n+        this.appContext);\n+\n+    this.grpcThread = PerformanceAnalyzerApp.startGrpcServerThread(clientServers.getNetServer(), threadProvider);\n+    this.webServerThread = PerformanceAnalyzerApp.startWebServerThread(clientServers.getHttpServer(), threadProvider);\n+\n+    netOperationsExecutor =\n+        Executors.newScheduledThreadPool(\n+            3, new ThreadFactoryBuilder().setNameFormat(\"test-network-thread-%d\").build());\n+\n+    this.rcaController = new RcaControllerIt(\n+        threadProvider,\n+        netOperationsExecutor,\n+        connectionManager,\n+        clientServers,\n+        hostDir.getAbsolutePath(),\n+        10,\n+        10,\n+        role,\n+        appContext,\n+        null);\n+  }\n+\n+  // We create a temporary file and then swap it for the rca.enabled file.\n+  public void setRcaState(RcaSchedulerState rcaState) {\n+    Path rcaEnabledTmp = Paths.get(rcaEnabledFile + \".tmp\");\n+    try (FileWriter f2 = new FileWriter(rcaEnabledTmp.toFile(), false /*To create a new file*/)) {\n+      boolean value = true;\n+      switch (rcaState) {\n+        case STATE_NOT_STARTED:\n+          break;\n+        case STATE_STOPPED_DUE_TO_EXCEPTION:\n+          break;\n+        case STATE_STARTED:\n+          value = true;\n+          break;\n+        case STATE_STOPPED:\n+          value = false;\n+          break;\n+      }\n+      f2.write(String.valueOf(value));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+      return;\n+    }\n+    rcaEnabledTmp.toFile().renameTo(rcaEnabledFile.toFile());\n+  }\n+\n+  public void setClusterDetails(final List<Host> allHosts) {\n+    List<ClusterDetailsEventProcessor.NodeDetails> nodeDetails = new ArrayList<>();\n+\n+    // The first node in the list is always the node-itself.\n+    nodeDetails.add(hostToNodeDetails(this));\n+\n+    for (Host host : allHosts) {\n+      if (host.hostId != this.hostId) {\n+        nodeDetails.add(hostToNodeDetails(host));\n+      }\n+    }\n+    ClusterDetailsEventProcessor clusterDetailsEventProcessor = new ClusterDetailsEventProcessor();\n+    clusterDetailsEventProcessor.setNodesDetails(nodeDetails);\n+    appContext.setClusterDetailsEventProcessor(clusterDetailsEventProcessor);\n+  }\n+\n+  public static ClusterDetailsEventProcessor.NodeDetails hostToNodeDetails(final Host host) {\n+    return new ClusterDetailsEventProcessor.NodeDetails(\n+        host.role,\n+        host.getMyTag().toString(),\n+        host.hostIp,\n+        host.isElectedMaster(),\n+        host.grpcServerPort);\n+  }\n+\n+  public HostTag getMyTag() {\n+    return myTag;\n+  }\n+\n+  public boolean isElectedMaster() {\n+    return AllMetrics.NodeRole.ELECTED_MASTER == this.role;\n+  }\n+\n+  public void deleteHost() throws IOException {\n+    try {\n+      stopRcaScheduler();\n+    } catch (Exception e) {\n+      LOG.error(\"** Error shutting down the scheduler while deleting host.\", e);\n+    }\n+    RCAScheduler rcaScheduler = rcaController.getRcaScheduler();\n+    if (rcaScheduler != null && rcaScheduler.getState() == RcaSchedulerState.STATE_STARTED) {\n+      rcaScheduler.shutdown();\n+    }\n+    netOperationsExecutor.shutdown();\n+    try {\n+      netOperationsExecutor.awaitTermination(1, TimeUnit.MINUTES);\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+    clientServers.getHttpServer().stop(10);\n+    clientServers.getNetClient().stop();\n+    clientServers.getNetServer().shutdown();\n+\n+    connectionManager.shutdown();\n+\n+    try {\n+      Thread.sleep(1000);\n+    } catch (InterruptedException ie) {\n+      ie.printStackTrace();", "originalCommit": "8ac14bfe465c2a87105aded687745ab165d9de55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1ODUyNg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466658526", "bodyText": "Should be https if httpsEnabled", "author": "sidheart", "createdAt": "2020-08-06T20:09:59Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/Host.java", "diffHunk": "@@ -0,0 +1,443 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.ClientServers;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.PerformanceAnalyzerApp;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaController;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATuple;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.Consts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.HostTag;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaControllerIt;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaItMetricsDBProvider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RCAScheduler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RcaSchedulerState;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.threads.ThreadProvider;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.junit.Assert;\n+\n+/**\n+ * This class simulates a cluster node that executes an RCA graph. Each node has its own\n+ * - GRPC server,\n+ * - web server\n+ * - RCAController and everything that it starts.\n+ */\n+public class Host {\n+  private static final Logger LOG = LogManager.getLogger(Host.class);\n+  private final boolean useHttps;\n+  /**\n+   * Each host has its own AppContext instance.\n+   */\n+  private final AppContext appContext;\n+  private final HostTag myTag;\n+  /**\n+   * This uniquely identifies a host.\n+   */\n+  private final int hostId;\n+  /**\n+   * For Integration tests, where all the virtual nodes are part of the same JVM, Ip string does not matter. But for\n+   * the sake of having this value filled, the string is 127.0.0.(hostId).\n+   */\n+  private final String hostIp;\n+  private final AllMetrics.NodeRole role;\n+  private final int webServerPort;\n+  private final int grpcServerPort;\n+  private final File hostDir;\n+  private final boolean rcaEnabled;\n+  private GRPCConnectionManager connectionManager;\n+  private ClientServers clientServers;\n+  private ScheduledExecutorService netOperationsExecutor;\n+  private RcaControllerIt rcaController;\n+  private Thread grpcThread;\n+  private Thread webServerThread;\n+  private Thread rcaControllerThread;\n+  private ThreadProvider threadProvider;\n+  private Path rcaEnabledFile;\n+\n+  public Host(int hostId,\n+              boolean useHttps,\n+              AllMetrics.NodeRole role,\n+              int httpServerPort,\n+              int grpcServerPort,\n+              File clusterDir,\n+              boolean rcaEnabled,\n+              HostTag myTag) {\n+    this.rcaEnabled = rcaEnabled;\n+    this.useHttps = useHttps;\n+    this.appContext = new AppContext();\n+\n+    this.hostId = hostId;\n+    this.myTag = myTag;\n+\n+    //TODO: make sure this works with the grpc and the webserver.\n+    this.hostIp = createHostIp();\n+    this.role = role;\n+\n+    this.webServerPort = httpServerPort;\n+    this.grpcServerPort = grpcServerPort;\n+\n+    this.hostDir = createHostDir(clusterDir, myTag);\n+  }\n+\n+  public static String createHostIp() {\n+    return \"127.0.0.1\";\n+  }\n+\n+  private static File createHostDir(File clusterDir, HostTag hostTag) {\n+    File hostFile = Paths.get(clusterDir.getAbsolutePath(), hostTag.toString()).toFile();\n+    if (!hostFile.exists() && !hostFile.mkdirs()) {\n+      throw new IllegalStateException(\"Couldn't create dir: \" + hostFile);\n+    }\n+    return hostFile;\n+  }\n+\n+  public void createServersAndThreads(final ThreadProvider threadProvider) throws Exception {\n+    this.threadProvider = threadProvider;\n+    Objects.requireNonNull(appContext.getClusterDetailsEventProcessor(),\n+        \"ClusterDetailsEventProcessor cannot be null in the AppContext\");\n+\n+    rcaEnabledFile = Paths.get(hostDir.getAbsolutePath(), RcaController.RCA_ENABLED_CONF_FILE);\n+    RcaSchedulerState state = rcaEnabled ? RcaSchedulerState.STATE_STARTED : RcaSchedulerState.STATE_STOPPED;\n+    setRcaState(state);\n+\n+    this.connectionManager = new GRPCConnectionManager(useHttps);\n+    this.clientServers = PerformanceAnalyzerApp.createClientServers(connectionManager,\n+        grpcServerPort,\n+        null,\n+        null,\n+        useHttps,\n+        String.valueOf(webServerPort),\n+        null,  // A null host is fine as this will use the loopback address\n+        this.appContext);\n+\n+    this.grpcThread = PerformanceAnalyzerApp.startGrpcServerThread(clientServers.getNetServer(), threadProvider);\n+    this.webServerThread = PerformanceAnalyzerApp.startWebServerThread(clientServers.getHttpServer(), threadProvider);\n+\n+    netOperationsExecutor =\n+        Executors.newScheduledThreadPool(\n+            3, new ThreadFactoryBuilder().setNameFormat(\"test-network-thread-%d\").build());\n+\n+    this.rcaController = new RcaControllerIt(\n+        threadProvider,\n+        netOperationsExecutor,\n+        connectionManager,\n+        clientServers,\n+        hostDir.getAbsolutePath(),\n+        10,\n+        10,\n+        role,\n+        appContext,\n+        null);\n+  }\n+\n+  // We create a temporary file and then swap it for the rca.enabled file.\n+  public void setRcaState(RcaSchedulerState rcaState) {\n+    Path rcaEnabledTmp = Paths.get(rcaEnabledFile + \".tmp\");\n+    try (FileWriter f2 = new FileWriter(rcaEnabledTmp.toFile(), false /*To create a new file*/)) {\n+      boolean value = true;\n+      switch (rcaState) {\n+        case STATE_NOT_STARTED:\n+          break;\n+        case STATE_STOPPED_DUE_TO_EXCEPTION:\n+          break;\n+        case STATE_STARTED:\n+          value = true;\n+          break;\n+        case STATE_STOPPED:\n+          value = false;\n+          break;\n+      }\n+      f2.write(String.valueOf(value));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+      return;\n+    }\n+    rcaEnabledTmp.toFile().renameTo(rcaEnabledFile.toFile());\n+  }\n+\n+  public void setClusterDetails(final List<Host> allHosts) {\n+    List<ClusterDetailsEventProcessor.NodeDetails> nodeDetails = new ArrayList<>();\n+\n+    // The first node in the list is always the node-itself.\n+    nodeDetails.add(hostToNodeDetails(this));\n+\n+    for (Host host : allHosts) {\n+      if (host.hostId != this.hostId) {\n+        nodeDetails.add(hostToNodeDetails(host));\n+      }\n+    }\n+    ClusterDetailsEventProcessor clusterDetailsEventProcessor = new ClusterDetailsEventProcessor();\n+    clusterDetailsEventProcessor.setNodesDetails(nodeDetails);\n+    appContext.setClusterDetailsEventProcessor(clusterDetailsEventProcessor);\n+  }\n+\n+  public static ClusterDetailsEventProcessor.NodeDetails hostToNodeDetails(final Host host) {\n+    return new ClusterDetailsEventProcessor.NodeDetails(\n+        host.role,\n+        host.getMyTag().toString(),\n+        host.hostIp,\n+        host.isElectedMaster(),\n+        host.grpcServerPort);\n+  }\n+\n+  public HostTag getMyTag() {\n+    return myTag;\n+  }\n+\n+  public boolean isElectedMaster() {\n+    return AllMetrics.NodeRole.ELECTED_MASTER == this.role;\n+  }\n+\n+  public void deleteHost() throws IOException {\n+    try {\n+      stopRcaScheduler();\n+    } catch (Exception e) {\n+      LOG.error(\"** Error shutting down the scheduler while deleting host.\", e);\n+    }\n+    RCAScheduler rcaScheduler = rcaController.getRcaScheduler();\n+    if (rcaScheduler != null && rcaScheduler.getState() == RcaSchedulerState.STATE_STARTED) {\n+      rcaScheduler.shutdown();\n+    }\n+    netOperationsExecutor.shutdown();\n+    try {\n+      netOperationsExecutor.awaitTermination(1, TimeUnit.MINUTES);\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+    clientServers.getHttpServer().stop(10);\n+    clientServers.getNetClient().stop();\n+    clientServers.getNetServer().shutdown();\n+\n+    connectionManager.shutdown();\n+\n+    try {\n+      Thread.sleep(1000);\n+    } catch (InterruptedException ie) {\n+      ie.printStackTrace();\n+    }\n+\n+    webServerThread.interrupt();\n+\n+    clientServers.getNetServer().setAttemptedShutdown();\n+    grpcThread.interrupt();\n+\n+    rcaController.setDeliberateInterrupt();\n+\n+    LOG.info(\"RCA Controller thread for host {} is being interrupted.\" + hostId);\n+    rcaControllerThread.interrupt();\n+    deleteHostDir();\n+    LOG.info(\"Host '{} with role '{}' cleaned up.\", hostId, rcaController.getCurrentRole());\n+  }\n+\n+  public void deleteHostDir() throws IOException {\n+    FileUtils.deleteDirectory(hostDir);\n+  }\n+\n+  public void stopRcaScheduler() throws Exception {\n+    setRcaState(RcaSchedulerState.STATE_STOPPED);\n+    rcaController.waitForRcaState(RcaSchedulerState.STATE_STOPPED);\n+    LOG.info(\"RCA Scheduler STOPPED\");\n+  }\n+\n+  public void startRcaControllerThread() {\n+    this.rcaControllerThread = PerformanceAnalyzerApp.startRcaTopLevelThread(rcaController, threadProvider);\n+  }\n+\n+  public void startRcaScheduler() throws Exception {\n+    setRcaState(RcaSchedulerState.STATE_STARTED);\n+    rcaController.waitForRcaState(RcaSchedulerState.STATE_STARTED);\n+    LOG.info(\"RCA scheduler STARTED successfully on host: {}.\", myTag);\n+  }\n+\n+  public void updateRcaGraph(final Class rcaGraphClass)\n+      throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n+    rcaController.setRcaGraphComponents(rcaGraphClass);\n+  }\n+\n+  public void updateMetricsDB(AMetric[] metricAnnotations) throws Exception {\n+    RcaItMetricsDBProvider dbProvider =\n+        new RcaItMetricsDBProvider(Paths.get(hostDir.getPath(), \"metricsdb\").toString());\n+    for (AMetric metric : metricAnnotations) {\n+      boolean foundDataForHost = false;\n+      // Each metric can have only one data table that can be associated to a host.\n+      // Which one is determined by the hostTag. The first matching is added to the host\n+      // for the current metric.\n+      dataLoop:\n+      for (ATable table : metric.tables()) {\n+        for (HostTag dataTag : table.hostTag()) {\n+          if (myTag == dataTag) {\n+            // First data-tag to match the hostTags is considered to be a match\n+            for (ATuple tuple : table.tuple()) {\n+              String metricName;\n+              try {\n+                metricName = (String) metric.name().getField(\"NAME\").get(null);\n+              } catch (Exception ex) {\n+                LOG.error(\"Error getting metric name.\", ex);\n+                throw ex;\n+              }\n+              dbProvider.insertRow(\n+                  metricName,\n+                  metric.dimensionNames(),\n+                  tuple.dimensionValues(),\n+                  tuple.min(),\n+                  tuple.max(),\n+                  tuple.avg(),\n+                  tuple.sum());\n+            }\n+            foundDataForHost = true;\n+            // We found a data table matching the tags of the host. Let's move to the\n+            // next metric.\n+            break dataLoop;\n+          }\n+        }\n+      }\n+      if (!foundDataForHost) {\n+        // This is not an error though. For example, a dedicated master node cannot emit\n+        // a shard related metric.\n+        System.out.println(\"No data found for host \" + hostId + \" for metric \" + metric.name());\n+      }\n+    }\n+    rcaController.setDbProvider(dbProvider);\n+  }\n+\n+  public JsonObject getAllRcaData() {\n+    JsonParser parser = new JsonParser();\n+    JsonElement data = parser.parse(this.rcaController.getPersistenceProvider().read());\n+    JsonObject obj = new JsonObject();\n+    obj.addProperty(Consts.HOST_ID_KEY, myTag.toString());\n+    obj.addProperty(Consts.HOST_ROLE_KEY, role.toString());\n+    obj.add(Consts.DATA_KEY, data);\n+    return obj;\n+  }\n+\n+  public JsonElement getDataForRca(String rcaName) {\n+    JsonElement data = this.rcaController.getPersistenceProvider().read(rcaName);\n+    JsonObject obj = new JsonObject();\n+    obj.addProperty(Consts.HOST_ID_KEY, hostId);\n+    obj.addProperty(Consts.HOST_ROLE_KEY, role.toString());\n+    obj.add(Consts.DATA_KEY, data);\n+    return obj;\n+  }\n+\n+  public List<Result<Record>> getRecordsForAllTables() {\n+    return this.rcaController.getPersistenceProvider().getRecordsForAllTables();\n+  }\n+\n+  Result<Record> getRecordsForTable(String tableName) {\n+    return this.rcaController.getPersistenceProvider().getRecordsForTable(tableName);\n+  }\n+\n+  public String makeRestRequest(final Map<String, String> kvRequestParams) {\n+    StringBuilder queryString = new StringBuilder();\n+\n+    String appender = \"\";\n+    for (Map.Entry<String, String> entry : kvRequestParams.entrySet()) {\n+      queryString.append(appender).append(entry.getKey()).append(\"=\").append(entry.getValue());\n+      appender = \"&\";\n+    }\n+    StringBuilder uri =\n+        new StringBuilder(\"http://localhost:\" + webServerPort + Util.RCA_QUERY_URL);", "originalCommit": "8ac14bfe465c2a87105aded687745ab165d9de55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MTU0Mw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r466661543", "bodyText": "See above, computing annotationsPresent seems superfluous", "author": "sidheart", "createdAt": "2020-08-06T20:16:14Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/TestEnvironment.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaControllerHelper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ARcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ARcaGraph;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TestEnvironment {\n+  private final Cluster cluster;\n+  private final Env classLevelEnv;\n+\n+  private Env currentEnv;\n+\n+  public TestEnvironment(final Cluster cluster, final Class testClass) throws Exception {\n+    this.cluster = cluster;\n+    this.classLevelEnv = updateEnvironment(testClass);\n+  }\n+\n+  private Env updateEnvironment(final Class testClass) throws Exception {\n+    boolean annotationsPresent = testClass.isAnnotationPresent(ARcaConf.class)\n+        | testClass.isAnnotationPresent(ARcaGraph.class)\n+        | testClass.isAnnotationPresent(ARcaConf.class);\n+\n+    Env env = new Env();\n+\n+    if (annotationsPresent) {\n+      if (testClass.isAnnotationPresent(ARcaConf.class)) {\n+        updateRcaConf((ARcaConf) testClass.getAnnotation(ARcaConf.class), env);\n+      }\n+      if (testClass.isAnnotationPresent(ARcaGraph.class)) {\n+        updateRcaGraph((ARcaGraph) testClass.getAnnotation(ARcaGraph.class), env);\n+      }\n+\n+      if (testClass.isAnnotationPresent(AMetric.Metrics.class)\n+          || testClass.isAnnotationPresent(AMetric.class)) {\n+        updateMetricsDB((AMetric[]) testClass.getAnnotationsByType(AMetric.class), env);\n+      }\n+    }\n+    if (env.rcaConfMap.isEmpty()) {\n+      updateWithDefaultRcaConfAnnotation(env);\n+    }\n+    return env;\n+  }\n+\n+  public void updateEnvironment(final Method method) throws Exception {\n+    boolean annotationsPresent = method.isAnnotationPresent(ARcaConf.class)\n+        | method.isAnnotationPresent(ARcaGraph.class)\n+        | method.isAnnotationPresent(ARcaConf.class);\n+\n+    this.currentEnv = new Env(this.classLevelEnv);\n+\n+    if (annotationsPresent) {\n+      if (method.isAnnotationPresent(ARcaConf.class)) {\n+        updateRcaConf(method.getAnnotation(ARcaConf.class), currentEnv);\n+      }\n+      if (method.isAnnotationPresent(ARcaGraph.class)) {\n+        updateRcaGraph(method.getAnnotation(ARcaGraph.class), currentEnv);\n+      }\n+\n+      if (method.isAnnotationPresent(AMetric.Metrics.class)) {\n+        updateMetricsDB(method.getAnnotationsByType(AMetric.class), currentEnv);\n+      }\n+    }", "originalCommit": "8ac14bfe465c2a87105aded687745ab165d9de55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2MjE4Nw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468362187", "bodyText": "Is there a reason we don't throw after this?", "author": "sidheart", "createdAt": "2020-08-11T06:49:04Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/RcaController.java", "diffHunk": "@@ -221,9 +229,21 @@ private void start() {\n           new SubscribeServerHandler(subscriptionManager, networkThreadPoolReference));\n \n       Thread rcaSchedulerThread = threadProvider.createThreadForRunnable(() -> rcaScheduler.start(),\n-          PerformanceAnalyzerThreads.RCA_SCHEDULER);\n+          PerformanceAnalyzerThreads.RCA_SCHEDULER,\n+          copyAppContext.getMyInstanceDetails().getInstanceId().toString());\n \n+      CountDownLatch schedulerStartLatch = new CountDownLatch(1);\n+      rcaScheduler.setSchedulerTrackingLatch(schedulerStartLatch);\n       rcaSchedulerThread.start();\n+      if (!schedulerStartLatch.await(WAIT_FOR_SCHED_START_SECS, TimeUnit.SECONDS)) {\n+        LOG.error(\"Failed to start RcaScheduler.\");\n+        throw new IllegalStateException(\n+            \"Failed to start RcaScheduler within \" + WAIT_FOR_SCHED_START_SECS + \" seconds.\");\n+      }\n+\n+      if (rcaScheduler.getState() != RcaSchedulerState.STATE_STARTED) {\n+        LOG.error(\"RCA scheduler didn't start within {} seconds\", WAIT_FOR_SCHED_START_SECS);\n+      }", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2MjgwNw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468362807", "bodyText": "Are these imports still needed?", "author": "sidheart", "createdAt": "2020-08-11T06:50:34Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/persistence/Persistable.java", "diffHunk": "@@ -22,6 +22,8 @@\n import java.io.IOException;\n import java.sql.SQLException;\n import java.util.List;\n+import org.jooq.Record;\n+import org.jooq.Result;", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3ODQ3NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468378474", "bodyText": "nullCheck or @NotNull", "author": "sidheart", "createdAt": "2020-08-11T07:24:48Z", "path": "src/main/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/threads/ThreadProvider.java", "diffHunk": "@@ -41,7 +41,13 @@\n    * @return The thread with the wrapped runnable.\n    */\n   public Thread createThreadForRunnable(final Runnable innerRunnable,\n-      final PerformanceAnalyzerThreads paThread) {\n+      final PerformanceAnalyzerThreads paThread, String threadNameAppender) {\n+    StringBuilder threadName = new StringBuilder(paThread.toString());\n+    if (!threadNameAppender.isEmpty()) {", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3ODk1NQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468378955", "bodyText": "this would be good for paThread as well just for sanity", "author": "sidheart", "createdAt": "2020-08-11T07:25:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3ODQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM4MTM5Ng==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468381396", "bodyText": "Can you add a TODO here? This REST logic has been independently implemented by multiple engineers and should just live in a utility class. This would simplify the https case as well.", "author": "sidheart", "createdAt": "2020-08-11T07:30:27Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/Host.java", "diffHunk": "@@ -0,0 +1,436 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.ClientServers;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.PerformanceAnalyzerApp;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.core.Util;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaController;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATuple;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.Consts;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.HostTag;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaControllerIt;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides.RcaItMetricsDBProvider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RCAScheduler;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RcaSchedulerState;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.reader.ClusterDetailsEventProcessor;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.threads.ThreadProvider;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.junit.Assert;\n+\n+/**\n+ * This class simulates a cluster node that executes an RCA graph. Each node has its own\n+ * - GRPC server,\n+ * - web server\n+ * - RCAController and everything that it starts.\n+ */\n+public class Host {\n+  private static final Logger LOG = LogManager.getLogger(Host.class);\n+  private final boolean useHttps;\n+  /**\n+   * Each host has its own AppContext instance.\n+   */\n+  private final AppContext appContext;\n+  private final HostTag myTag;\n+  /**\n+   * This uniquely identifies a host.\n+   */\n+  private final int hostId;\n+  /**\n+   * For Integration tests, where all the virtual nodes are part of the same JVM, Ip string does not matter. But for\n+   * the sake of having this value filled, the string is 127.0.0.(hostId).\n+   */\n+  private final String hostIp;\n+  private final AllMetrics.NodeRole role;\n+  private final int webServerPort;\n+  private final int grpcServerPort;\n+  private final File hostDir;\n+  private final boolean rcaEnabled;\n+  private GRPCConnectionManager connectionManager;\n+  private ClientServers clientServers;\n+  private ScheduledExecutorService netOperationsExecutor;\n+  private RcaControllerIt rcaController;\n+  private Thread grpcThread;\n+  private Thread webServerThread;\n+  private Thread rcaControllerThread;\n+  private ThreadProvider threadProvider;\n+  private Path rcaEnabledFile;\n+\n+  public Host(int hostId,\n+              boolean useHttps,\n+              AllMetrics.NodeRole role,\n+              int httpServerPort,\n+              int grpcServerPort,\n+              File clusterDir,\n+              boolean rcaEnabled,\n+              HostTag myTag) {\n+    this.rcaEnabled = rcaEnabled;\n+    this.useHttps = useHttps;\n+    this.appContext = new AppContext();\n+\n+    this.hostId = hostId;\n+    this.myTag = myTag;\n+\n+    //TODO: make sure this works with the grpc and the webserver.\n+    this.hostIp = createHostIp();\n+    this.role = role;\n+\n+    this.webServerPort = httpServerPort;\n+    this.grpcServerPort = grpcServerPort;\n+\n+    this.hostDir = createHostDir(clusterDir, myTag);\n+  }\n+\n+  public static String createHostIp() {\n+    return \"127.0.0.1\";\n+  }\n+\n+  private static File createHostDir(File clusterDir, HostTag hostTag) {\n+    File hostFile = Paths.get(clusterDir.getAbsolutePath(), hostTag.toString()).toFile();\n+    if (!hostFile.exists() && !hostFile.mkdirs()) {\n+      throw new IllegalStateException(\"Couldn't create dir: \" + hostFile);\n+    }\n+    return hostFile;\n+  }\n+\n+  public void createServersAndThreads(final ThreadProvider threadProvider) {\n+    this.threadProvider = threadProvider;\n+    Objects.requireNonNull(appContext.getClusterDetailsEventProcessor(),\n+        \"ClusterDetailsEventProcessor cannot be null in the AppContext\");\n+\n+    rcaEnabledFile = Paths.get(hostDir.getAbsolutePath(), RcaController.RCA_ENABLED_CONF_FILE);\n+    RcaSchedulerState state = rcaEnabled ? RcaSchedulerState.STATE_STARTED : RcaSchedulerState.STATE_STOPPED;\n+    setExpectedRcaState(state);\n+\n+    this.connectionManager = new GRPCConnectionManager(useHttps);\n+    this.clientServers = PerformanceAnalyzerApp.createClientServers(connectionManager,\n+        grpcServerPort,\n+        null,\n+        null,\n+        useHttps,\n+        String.valueOf(webServerPort),\n+        null,  // A null host is fine as this will use the loopback address\n+        this.appContext);\n+\n+    this.grpcThread = PerformanceAnalyzerApp.startGrpcServerThread(clientServers.getNetServer(), threadProvider);\n+    this.webServerThread = PerformanceAnalyzerApp.startWebServerThread(clientServers.getHttpServer(), threadProvider);\n+\n+    netOperationsExecutor =\n+        Executors.newScheduledThreadPool(\n+            3, new ThreadFactoryBuilder().setNameFormat(\"test-network-thread-%d\").build());\n+\n+    this.rcaController = new RcaControllerIt(\n+        threadProvider,\n+        netOperationsExecutor,\n+        connectionManager,\n+        clientServers,\n+        hostDir.getAbsolutePath(),\n+        10,\n+        10,\n+        role,\n+        appContext,\n+        null);\n+  }\n+\n+  // We create a temporary file and then swap it for the rca.enabled file.\n+  public void setExpectedRcaState(RcaSchedulerState rcaState) {\n+    Path rcaEnabledTmp = Paths.get(rcaEnabledFile + \".tmp\");\n+    try (FileWriter f2 = new FileWriter(rcaEnabledTmp.toFile(), false /*To create a new file*/)) {\n+      boolean value = true;\n+      switch (rcaState) {\n+        case STATE_NOT_STARTED:\n+          break;\n+        case STATE_STOPPED_DUE_TO_EXCEPTION:\n+          break;\n+        case STATE_STARTED:\n+          value = true;\n+          break;\n+        case STATE_STOPPED:\n+          value = false;\n+          break;\n+      }\n+      f2.write(String.valueOf(value));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+      return;\n+    }\n+    rcaEnabledTmp.toFile().renameTo(rcaEnabledFile.toFile());\n+  }\n+\n+  public void setClusterDetails(final List<Host> allHosts) {\n+    List<ClusterDetailsEventProcessor.NodeDetails> nodeDetails = new ArrayList<>();\n+\n+    // The first node in the list is always the node-itself.\n+    nodeDetails.add(hostToNodeDetails(this));\n+\n+    for (Host host : allHosts) {\n+      if (host.hostId != this.hostId) {\n+        nodeDetails.add(hostToNodeDetails(host));\n+      }\n+    }\n+    ClusterDetailsEventProcessor clusterDetailsEventProcessor = new ClusterDetailsEventProcessor();\n+    clusterDetailsEventProcessor.setNodesDetails(nodeDetails);\n+    appContext.setClusterDetailsEventProcessor(clusterDetailsEventProcessor);\n+  }\n+\n+  public static ClusterDetailsEventProcessor.NodeDetails hostToNodeDetails(final Host host) {\n+    return new ClusterDetailsEventProcessor.NodeDetails(\n+        host.role,\n+        host.getMyTag().toString(),\n+        host.hostIp,\n+        host.isElectedMaster(),\n+        host.grpcServerPort);\n+  }\n+\n+  public HostTag getMyTag() {\n+    return myTag;\n+  }\n+\n+  public boolean isElectedMaster() {\n+    return AllMetrics.NodeRole.ELECTED_MASTER == this.role;\n+  }\n+\n+  public void deleteHost() throws IOException {\n+    try {\n+      stopRcaScheduler();\n+    } catch (Exception e) {\n+      LOG.error(\"** Error shutting down the scheduler while deleting host.\", e);\n+    }\n+    RCAScheduler rcaScheduler = rcaController.getRcaScheduler();\n+    if (rcaScheduler != null && rcaScheduler.getState() == RcaSchedulerState.STATE_STARTED) {\n+      rcaScheduler.shutdown();\n+    }\n+    netOperationsExecutor.shutdown();\n+    try {\n+      netOperationsExecutor.awaitTermination(1, TimeUnit.MINUTES);\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+    clientServers.getHttpServer().stop(10);\n+    clientServers.getNetClient().stop();\n+    clientServers.getNetServer().shutdown();\n+\n+    connectionManager.shutdown();\n+\n+    try {\n+      Thread.sleep(1000);\n+    } catch (InterruptedException ie) {\n+      ie.printStackTrace();\n+    }\n+\n+    webServerThread.interrupt();\n+\n+    clientServers.getNetServer().setAttemptedShutdown();\n+    grpcThread.interrupt();\n+\n+    rcaController.setDeliberateInterrupt();\n+\n+    LOG.info(\"RCA Controller thread for host {} is being interrupted.\" + hostId);\n+    rcaControllerThread.interrupt();\n+    deleteHostDir();\n+    LOG.info(\"Host '{} with role '{}' cleaned up.\", hostId, rcaController.getCurrentRole());\n+  }\n+\n+  public void deleteHostDir() throws IOException {\n+    FileUtils.deleteDirectory(hostDir);\n+  }\n+\n+  public void stopRcaScheduler() throws Exception {\n+    RCAScheduler sched = rcaController.getRcaScheduler();\n+    CountDownLatch shutdownLatch = null;\n+    if (sched != null) {\n+      shutdownLatch = new CountDownLatch(1);\n+      sched.setSchedulerTrackingLatch(shutdownLatch);\n+    }\n+    setExpectedRcaState(RcaSchedulerState.STATE_STOPPED);\n+    if (shutdownLatch != null) {\n+      shutdownLatch.await(10, TimeUnit.SECONDS);\n+    }\n+    LOG.info(\"RCA Scheduler is STOPPED by TestRunner on node: {}\", myTag);\n+  }\n+\n+  public void startRcaControllerThread() {\n+    this.rcaControllerThread = PerformanceAnalyzerApp.startRcaTopLevelThread(\n+        rcaController,\n+        threadProvider,\n+        appContext.getMyInstanceDetails().getInstanceId().toString());\n+  }\n+\n+  public void startRcaScheduler() throws Exception {\n+    setExpectedRcaState(RcaSchedulerState.STATE_STARTED);\n+    rcaController.waitForRcaState(RcaSchedulerState.STATE_STARTED);\n+  }\n+\n+  public void updateRcaGraph(final Class rcaGraphClass)\n+      throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\n+    rcaController.setRcaGraphComponents(rcaGraphClass);\n+  }\n+\n+  public void updateMetricsDB(AMetric[] metricAnnotations) throws Exception {\n+    RcaItMetricsDBProvider dbProvider =\n+        new RcaItMetricsDBProvider(Paths.get(hostDir.getPath(), \"metricsdb\").toString());\n+    for (AMetric metric : metricAnnotations) {\n+      boolean foundDataForHost = false;\n+      // Each metric can have only one data table that can be associated to a host.\n+      // Which one is determined by the hostTag. The first matching is added to the host\n+      // for the current metric.\n+      dataLoop:\n+      for (ATable table : metric.tables()) {\n+        for (HostTag dataTag : table.hostTag()) {\n+          if (myTag == dataTag) {\n+            // First data-tag to match the hostTags is considered to be a match\n+            for (ATuple tuple : table.tuple()) {\n+              String metricName;\n+              try {\n+                metricName = (String) metric.name().getField(\"NAME\").get(null);\n+              } catch (Exception ex) {\n+                LOG.error(\"Error getting metric name.\", ex);\n+                throw ex;\n+              }\n+              dbProvider.insertRow(\n+                  metricName,\n+                  metric.dimensionNames(),\n+                  tuple.dimensionValues(),\n+                  tuple.min(),\n+                  tuple.max(),\n+                  tuple.avg(),\n+                  tuple.sum());\n+            }\n+            foundDataForHost = true;\n+            // We found a data table matching the tags of the host. Let's move to the\n+            // next metric.\n+            break dataLoop;\n+          }\n+        }\n+      }\n+      if (!foundDataForHost) {\n+        // This is not an error though. For example, a dedicated master node cannot emit\n+        // a shard related metric.\n+        System.out.println(\"No data found for host \" + hostId + \" for metric \" + metric.name());\n+      }\n+    }\n+    rcaController.setDbProvider(dbProvider);\n+  }\n+\n+  public JsonElement getDataForRca(String rcaName) {\n+    JsonElement data = this.rcaController.getPersistenceProvider().read(rcaName);\n+    JsonObject obj = new JsonObject();\n+    obj.addProperty(Consts.HOST_ID_KEY, hostId);\n+    obj.addProperty(Consts.HOST_ROLE_KEY, role.toString());\n+    obj.add(Consts.DATA_KEY, data);\n+    return obj;\n+  }\n+\n+  public String makeRestRequest(final Map<String, String> kvRequestParams) {\n+    StringBuilder queryString = new StringBuilder();\n+\n+    String appender = \"\";\n+    for (Map.Entry<String, String> entry : kvRequestParams.entrySet()) {\n+      queryString.append(appender).append(entry.getKey()).append(\"=\").append(entry.getValue());\n+      appender = \"&\";\n+    }\n+    StringBuilder uri =\n+        new StringBuilder(\"http://localhost:\" + webServerPort + Util.RCA_QUERY_URL);\n+    uri.append(\"?\").append(queryString);\n+\n+    URL url = null;\n+    try {\n+      url = new URL(uri.toString());\n+    } catch (MalformedURLException e) {\n+      e.printStackTrace();\n+      Assert.fail();\n+    }\n+\n+    String response = \"\";\n+    HttpURLConnection connection = null;\n+\n+    try {\n+      connection = (HttpURLConnection) url.openConnection();\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+      Assert.fail();\n+    }\n+\n+    try {\n+      connection.setRequestMethod(\"GET\");\n+    } catch (ProtocolException e) {\n+      e.printStackTrace();\n+      connection.disconnect();\n+      Assert.fail();\n+    }\n+\n+    try {", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM4Njg1OA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468386858", "bodyText": "nit: should be metric", "author": "sidheart", "createdAt": "2020-08-11T07:41:16Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/annotations/AMetric.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * This annotation can be used to specify the metrics that will be poured onto the RCA Graph. Under the covers,\n+ * the framework will try to simulate a DBProvider that will respond with these metrics when the RCA Metrics\n+ * nodes query for one. This annotation lets you specify one or more metric tables, similar to the 5 second\n+ * metric snapshots of the metricsdb files, and also specify a table for one or a group of cluster hosts.\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Repeatable(value = AMetric.Metrics.class)\n+@Target({ElementType.TYPE, ElementType.METHOD})\n+public @interface AMetric {\n+  // The metric this data is emulating.\n+  Class name();", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5NTEyMw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468395123", "bodyText": "Curious, why is this Class instead of AnalysisGraph if it's cast to AnalysisGraph anyway? Does reflection not support polymorphism?", "author": "sidheart", "createdAt": "2020-08-11T07:56:52Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/overrides/RcaControllerIt.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ *  A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed\n+ *  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.overrides;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.AppContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.ClientServers;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.net.GRPCConnectionManager;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaController;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.AnalysisGraph;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.ConnectedComponent;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.Queryable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.core.RcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaUtil;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.RcaSchedulerState;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.threads.ThreadProvider;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.util.WaitFor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+public class RcaControllerIt extends RcaController {\n+  private final String rcaPath;\n+  private List<ConnectedComponent> rcaGraphComponents;\n+\n+  public RcaControllerIt(ThreadProvider threadProvider,\n+                         ScheduledExecutorService netOpsExecutorService,\n+                         GRPCConnectionManager grpcConnectionManager,\n+                         ClientServers clientServers,\n+                         String rca_enabled_conf_location,\n+                         long rcaStateCheckIntervalMillis,\n+                         long nodeRoleCheckPeriodicityMillis,\n+                         AllMetrics.NodeRole nodeRole,\n+                         final AppContext appContext,\n+                         final Queryable dbProvider) {\n+    super(threadProvider,\n+        netOpsExecutorService,\n+        grpcConnectionManager,\n+        clientServers,\n+        rca_enabled_conf_location,\n+        rcaStateCheckIntervalMillis,\n+        nodeRoleCheckPeriodicityMillis,\n+        appContext,\n+        dbProvider);\n+    this.currentRole = nodeRole;\n+    this.rcaPath = rca_enabled_conf_location;\n+  }\n+\n+  @Override\n+  protected List<ConnectedComponent> getRcaGraphComponents(RcaConf rcaConf) throws\n+      ClassNotFoundException,\n+      NoSuchMethodException,\n+      InvocationTargetException,\n+      InstantiationException,\n+      IllegalAccessException {\n+    if (rcaGraphComponents != null) {\n+      return rcaGraphComponents;\n+    } else {\n+      return super.getRcaGraphComponents(rcaConf);\n+    }\n+  }\n+\n+  @Override\n+  protected RcaConf getRcaConfForMyRole(AllMetrics.NodeRole nodeRole) {\n+    RcaConfIt rcaConfIt = new RcaConfIt(super.getRcaConfForMyRole(nodeRole));\n+    rcaConfIt.setRcaDataStorePath(rcaPath);\n+    return rcaConfIt;\n+  }\n+\n+  public void setDbProvider(final Queryable db) {\n+    dbProvider = db;\n+  }\n+\n+  public void setRcaGraphComponents(Class rcaGraphClass)", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5OTU0OQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468399549", "bodyText": "nit: isn't computing this a waste given that we redo the checks below anyway?", "author": "sidheart", "createdAt": "2020-08-11T08:04:58Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/TestEnvironment.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.RcaControllerHelper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ARcaConf;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ARcaGraph;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TestEnvironment {\n+  private final Cluster cluster;\n+  private final Env classLevelEnv;\n+\n+  private Env currentEnv;\n+\n+  public TestEnvironment(final Cluster cluster, final Class testClass) throws Exception {\n+    this.cluster = cluster;\n+    this.classLevelEnv = updateEnvironment(testClass);\n+  }\n+\n+  private Env updateEnvironment(final Class testClass) throws Exception {\n+    boolean annotationsPresent = testClass.isAnnotationPresent(ARcaConf.class)\n+        | testClass.isAnnotationPresent(ARcaGraph.class)\n+        | testClass.isAnnotationPresent(ARcaConf.class);", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQwNTgyMw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468405823", "bodyText": "nit: SET_API_METHOD?", "author": "sidheart", "createdAt": "2020-08-11T08:16:22Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/runners/IRcaItRunner.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.runners;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.Cluster;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.ClusterType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.Consts;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.sql.Timestamp;\n+import java.text.SimpleDateFormat;\n+import org.apache.commons.io.FileUtils;\n+\n+public interface IRcaItRunner {\n+  String SET_CLUSTER_METHOD = \"setTestApi\";", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQxNzYwMw==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468417603", "bodyText": "nit: delete startMillis", "author": "sidheart", "createdAt": "2020-08-11T08:35:55Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/runners/RcaItRunnerBase.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.runners;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.Cluster;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.TestEnvironment;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AClusterType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AExpect;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.IValidator;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.TestApi;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.ClusterType;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.Test;\n+import org.junit.runner.Description;\n+import org.junit.runner.Runner;\n+import org.junit.runner.notification.Failure;\n+import org.junit.runner.notification.RunNotifier;\n+\n+/**\n+ * This is the main runner class that is used by the RCA-IT.\n+ */\n+public abstract class RcaItRunnerBase extends Runner implements IRcaItRunner {\n+  private static final Logger LOG = LogManager.getLogger(RcaItRunnerBase.class);\n+\n+  // The class whose tests the runner is currently executing.\n+  private final Class testClass;\n+\n+  // An instance of the test class the runner is executing.\n+  private final Object testObject;\n+\n+  // This is used to set up the environment. An environment for running RCA graph would be to push the RCA graph itself,\n+  // the metrics, the rca.conf if that needs to be changed. It reads them from the annotations and sets them up for the\n+  // cluster object.\n+  private final TestEnvironment testEnvironment;\n+\n+  // An instance of the cluster where tests are running.\n+  private final Cluster cluster;\n+\n+  // This is wrapper on top of the cluster object that is passed on to the testClass to get access to the cluster.\n+  private final TestApi testApi;\n+\n+  public RcaItRunnerBase(Class testClass, boolean useHttps) throws Exception {\n+    super();\n+    this.testClass = testClass;\n+    ClusterType clusterType = getClusterTypeFromAnnotation(testClass);\n+    this.cluster = createCluster(clusterType, useHttps);\n+    this.testApi = new TestApi(cluster);\n+    this.testObject = testClass.getDeclaredConstructor().newInstance();\n+\n+    try {\n+      Method setClusterMethod = testClass.getMethod(SET_CLUSTER_METHOD, TestApi.class);\n+      setClusterMethod.setAccessible(true);\n+      setClusterMethod.invoke(testObject, testApi);\n+    } catch (NoSuchMethodException ex) {\n+      // This test class hasn't defined a method setCluster(Cluster). SO probably it does not need\n+      // access to the cluster object. Which is fine. We move on to the method execution.\n+    }\n+\n+    cluster.createServersAndThreads();\n+    try {\n+      this.testEnvironment = new TestEnvironment(cluster, testClass);\n+    } catch (Exception ex) {\n+      cluster.deleteClusterDir();\n+      ex.printStackTrace();\n+      throw ex;\n+    }\n+    cluster.startRcaControllerThread();\n+  }\n+\n+  private static ClusterType getClusterTypeFromAnnotation(Class testClass) {\n+    if (!testClass.isAnnotationPresent(AClusterType.class)) {\n+      throw new IllegalArgumentException(\n+          testClass.getSimpleName() + \" does not have the mandatory annotation: \" + AClusterType.class.getSimpleName());\n+    }\n+    return ((AClusterType) testClass.getAnnotation(AClusterType.class)).value();\n+  }\n+\n+  @Override\n+  public Description getDescription() {\n+    return Description.createTestDescription(testClass, \"A custom runner for RcaIt\");\n+  }\n+\n+  @Override\n+  public void run(RunNotifier notifier) {\n+    try {\n+      for (Method method : testClass.getMethods()) {\n+        if (method.isAnnotationPresent(Test.class)) {\n+          notifier.fireTestStarted(Description\n+              .createTestDescription(testClass, method.getName()));\n+\n+          try {\n+            this.testEnvironment.updateEnvironment(method);\n+            this.testEnvironment.verifyEnvironmentSetup();\n+          } catch (Exception ex) {\n+            notifier.fireTestFailure(\n+                new Failure(\n+                    Description.createTestDescription(testClass.getClass(), method.getName()), ex));\n+          }\n+          cluster.startRcaScheduler();\n+\n+          try {\n+            method.invoke(testObject);\n+            List<Class> failedChecks = validate(method);\n+\n+            if (!failedChecks.isEmpty()) {\n+              StringBuilder sb = new StringBuilder(\"Failed validations for:\");\n+              for (Class failed: failedChecks) {\n+                sb.append(System.lineSeparator()).append(failed);\n+              }\n+\n+              notifier.fireTestFailure(\n+                  new Failure(\n+                      Description.createTestDescription(testClass.getClass(), method.getName()),\n+                      new AssertionError(sb.toString())));\n+            }\n+          } catch (Exception exception) {\n+            LOG.error(\"** ERR: While running method: '{}'\", method.getName(), exception);\n+            notifier.fireTestFailure(\n+                new Failure(\n+                    Description.createTestDescription(testClass.getClass(), method.getName()), exception));\n+          }\n+\n+          cluster.stopRcaScheduler();\n+          this.testEnvironment.clearUpMethodLevelEnvOverride();\n+\n+          notifier.fireTestFinished(Description.createTestDescription(testClass, method.getName()));\n+        }\n+      }\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      throw new RuntimeException(e);\n+    } finally {\n+      try {\n+        cluster.deleteCluster();\n+      } catch (IOException e) {\n+        e.printStackTrace();\n+      }\n+    }\n+  }\n+\n+  private List<Class> validate(Method method)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    List<Class> failedValidations = new ArrayList<>();\n+    if (method.isAnnotationPresent(AExpect.Expectations.class) || method.isAnnotationPresent(AExpect.class)) {\n+      AExpect[] expectations = method.getDeclaredAnnotationsByType(AExpect.class);\n+\n+      IValidator[] validators = new IValidator[expectations.length];\n+      long maxWaitMillis = 0;\n+\n+      // Initialization loop for validation and the maximum wait time for the checks to pass.\n+      for (int i = 0; i < expectations.length; i++) {\n+        AExpect expect = expectations[i];\n+        validators[i] = (IValidator) expect.validator().getDeclaredConstructor().newInstance();\n+        long timeOutMillis = TimeUnit.MILLISECONDS.convert(expect.timeoutSeconds(), TimeUnit.SECONDS);\n+        if (timeOutMillis > maxWaitMillis) {\n+          maxWaitMillis = timeOutMillis;\n+        }\n+      }\n+\n+      long startMillis = System.currentTimeMillis();", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQyMTEyMg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468421122", "bodyText": "Most of these classes need preamble. You'll get even more lines on this PR!", "author": "sidheart", "createdAt": "2020-08-11T08:41:56Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/runners/RcaItRunnerBase.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.runners;", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQyMjkyMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468422921", "bodyText": "Misleading, we might have exceeded our max wait time and returned the failed validations", "author": "sidheart", "createdAt": "2020-08-11T08:44:51Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/runners/RcaItRunnerBase.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.runners;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.Cluster;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.TestEnvironment;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AClusterType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AExpect;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.IValidator;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.TestApi;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.ClusterType;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.Test;\n+import org.junit.runner.Description;\n+import org.junit.runner.Runner;\n+import org.junit.runner.notification.Failure;\n+import org.junit.runner.notification.RunNotifier;\n+\n+/**\n+ * This is the main runner class that is used by the RCA-IT.\n+ */\n+public abstract class RcaItRunnerBase extends Runner implements IRcaItRunner {\n+  private static final Logger LOG = LogManager.getLogger(RcaItRunnerBase.class);\n+\n+  // The class whose tests the runner is currently executing.\n+  private final Class testClass;\n+\n+  // An instance of the test class the runner is executing.\n+  private final Object testObject;\n+\n+  // This is used to set up the environment. An environment for running RCA graph would be to push the RCA graph itself,\n+  // the metrics, the rca.conf if that needs to be changed. It reads them from the annotations and sets them up for the\n+  // cluster object.\n+  private final TestEnvironment testEnvironment;\n+\n+  // An instance of the cluster where tests are running.\n+  private final Cluster cluster;\n+\n+  // This is wrapper on top of the cluster object that is passed on to the testClass to get access to the cluster.\n+  private final TestApi testApi;\n+\n+  public RcaItRunnerBase(Class testClass, boolean useHttps) throws Exception {\n+    super();\n+    this.testClass = testClass;\n+    ClusterType clusterType = getClusterTypeFromAnnotation(testClass);\n+    this.cluster = createCluster(clusterType, useHttps);\n+    this.testApi = new TestApi(cluster);\n+    this.testObject = testClass.getDeclaredConstructor().newInstance();\n+\n+    try {\n+      Method setClusterMethod = testClass.getMethod(SET_CLUSTER_METHOD, TestApi.class);\n+      setClusterMethod.setAccessible(true);\n+      setClusterMethod.invoke(testObject, testApi);\n+    } catch (NoSuchMethodException ex) {\n+      // This test class hasn't defined a method setCluster(Cluster). SO probably it does not need\n+      // access to the cluster object. Which is fine. We move on to the method execution.\n+    }\n+\n+    cluster.createServersAndThreads();\n+    try {\n+      this.testEnvironment = new TestEnvironment(cluster, testClass);\n+    } catch (Exception ex) {\n+      cluster.deleteClusterDir();\n+      ex.printStackTrace();\n+      throw ex;\n+    }\n+    cluster.startRcaControllerThread();\n+  }\n+\n+  private static ClusterType getClusterTypeFromAnnotation(Class testClass) {\n+    if (!testClass.isAnnotationPresent(AClusterType.class)) {\n+      throw new IllegalArgumentException(\n+          testClass.getSimpleName() + \" does not have the mandatory annotation: \" + AClusterType.class.getSimpleName());\n+    }\n+    return ((AClusterType) testClass.getAnnotation(AClusterType.class)).value();\n+  }\n+\n+  @Override\n+  public Description getDescription() {\n+    return Description.createTestDescription(testClass, \"A custom runner for RcaIt\");\n+  }\n+\n+  @Override\n+  public void run(RunNotifier notifier) {\n+    try {\n+      for (Method method : testClass.getMethods()) {\n+        if (method.isAnnotationPresent(Test.class)) {\n+          notifier.fireTestStarted(Description\n+              .createTestDescription(testClass, method.getName()));\n+\n+          try {\n+            this.testEnvironment.updateEnvironment(method);\n+            this.testEnvironment.verifyEnvironmentSetup();\n+          } catch (Exception ex) {\n+            notifier.fireTestFailure(\n+                new Failure(\n+                    Description.createTestDescription(testClass.getClass(), method.getName()), ex));\n+          }\n+          cluster.startRcaScheduler();\n+\n+          try {\n+            method.invoke(testObject);\n+            List<Class> failedChecks = validate(method);\n+\n+            if (!failedChecks.isEmpty()) {\n+              StringBuilder sb = new StringBuilder(\"Failed validations for:\");\n+              for (Class failed: failedChecks) {\n+                sb.append(System.lineSeparator()).append(failed);\n+              }\n+\n+              notifier.fireTestFailure(\n+                  new Failure(\n+                      Description.createTestDescription(testClass.getClass(), method.getName()),\n+                      new AssertionError(sb.toString())));\n+            }\n+          } catch (Exception exception) {\n+            LOG.error(\"** ERR: While running method: '{}'\", method.getName(), exception);\n+            notifier.fireTestFailure(\n+                new Failure(\n+                    Description.createTestDescription(testClass.getClass(), method.getName()), exception));\n+          }\n+\n+          cluster.stopRcaScheduler();\n+          this.testEnvironment.clearUpMethodLevelEnvOverride();\n+\n+          notifier.fireTestFinished(Description.createTestDescription(testClass, method.getName()));\n+        }\n+      }\n+    } catch (Exception e) {\n+      e.printStackTrace();\n+      throw new RuntimeException(e);\n+    } finally {\n+      try {\n+        cluster.deleteCluster();\n+      } catch (IOException e) {\n+        e.printStackTrace();\n+      }\n+    }\n+  }\n+\n+  private List<Class> validate(Method method)\n+      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n+    List<Class> failedValidations = new ArrayList<>();\n+    if (method.isAnnotationPresent(AExpect.Expectations.class) || method.isAnnotationPresent(AExpect.class)) {\n+      AExpect[] expectations = method.getDeclaredAnnotationsByType(AExpect.class);\n+\n+      IValidator[] validators = new IValidator[expectations.length];\n+      long maxWaitMillis = 0;\n+\n+      // Initialization loop for validation and the maximum wait time for the checks to pass.\n+      for (int i = 0; i < expectations.length; i++) {\n+        AExpect expect = expectations[i];\n+        validators[i] = (IValidator) expect.validator().getDeclaredConstructor().newInstance();\n+        long timeOutMillis = TimeUnit.MILLISECONDS.convert(expect.timeoutSeconds(), TimeUnit.SECONDS);\n+        if (timeOutMillis > maxWaitMillis) {\n+          maxWaitMillis = timeOutMillis;\n+        }\n+      }\n+\n+      long startMillis = System.currentTimeMillis();\n+      long endTimeMillis = startMillis + maxWaitMillis;\n+\n+\n+      while (System.currentTimeMillis() <= endTimeMillis) {\n+        failedValidations.clear();\n+        int passedCount = 0;\n+        // All checks must pass for one run for the validations to succeed. It's not valid if\n+        // different checks pass for different runs.\n+        for (int i = 0; i < expectations.length; i++) {\n+          // This is already initialized. Cannot be null.\n+          IValidator validator = validators[i];\n+          AExpect expect = expectations[i];\n+          AExpect.Type what = expect.what();\n+          boolean successful = false;\n+\n+          Class rca = expect.forRca();\n+\n+          switch (what) {\n+            case REST_API:\n+              successful = validator.check(testApi.getRcaDataOnHost(expect.on(), rca.getSimpleName()));\n+              if (!successful) {\n+                failedValidations.add(validator.getClass());\n+              }\n+              break;\n+          }\n+          if (successful) {\n+            passedCount += 1;\n+          }\n+        }\n+\n+        if (passedCount == expectations.length) {\n+          break;\n+        }\n+      }\n+    }\n+    // The test writer asked for no validations to be performed by the framework. So, we return success.", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NTQxOQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468745419", "bodyText": "removed it", "author": "yojs", "createdAt": "2020-08-11T17:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQyMjkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQyNDYyMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468424621", "bodyText": "random thought: it's weird that Java has a method invoke an object instead of the other way around", "author": "sidheart", "createdAt": "2020-08-11T08:47:46Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/framework/runners/RcaItRunnerBase.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.runners;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.Cluster;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.TestEnvironment;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AClusterType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AExpect;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.IValidator;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.TestApi;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.ClusterType;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.junit.Test;\n+import org.junit.runner.Description;\n+import org.junit.runner.Runner;\n+import org.junit.runner.notification.Failure;\n+import org.junit.runner.notification.RunNotifier;\n+\n+/**\n+ * This is the main runner class that is used by the RCA-IT.\n+ */\n+public abstract class RcaItRunnerBase extends Runner implements IRcaItRunner {\n+  private static final Logger LOG = LogManager.getLogger(RcaItRunnerBase.class);\n+\n+  // The class whose tests the runner is currently executing.\n+  private final Class testClass;\n+\n+  // An instance of the test class the runner is executing.\n+  private final Object testObject;\n+\n+  // This is used to set up the environment. An environment for running RCA graph would be to push the RCA graph itself,\n+  // the metrics, the rca.conf if that needs to be changed. It reads them from the annotations and sets them up for the\n+  // cluster object.\n+  private final TestEnvironment testEnvironment;\n+\n+  // An instance of the cluster where tests are running.\n+  private final Cluster cluster;\n+\n+  // This is wrapper on top of the cluster object that is passed on to the testClass to get access to the cluster.\n+  private final TestApi testApi;\n+\n+  public RcaItRunnerBase(Class testClass, boolean useHttps) throws Exception {\n+    super();\n+    this.testClass = testClass;\n+    ClusterType clusterType = getClusterTypeFromAnnotation(testClass);\n+    this.cluster = createCluster(clusterType, useHttps);\n+    this.testApi = new TestApi(cluster);\n+    this.testObject = testClass.getDeclaredConstructor().newInstance();\n+\n+    try {\n+      Method setClusterMethod = testClass.getMethod(SET_CLUSTER_METHOD, TestApi.class);\n+      setClusterMethod.setAccessible(true);\n+      setClusterMethod.invoke(testObject, testApi);\n+    } catch (NoSuchMethodException ex) {\n+      // This test class hasn't defined a method setCluster(Cluster). SO probably it does not need\n+      // access to the cluster object. Which is fine. We move on to the method execution.\n+    }\n+\n+    cluster.createServersAndThreads();\n+    try {\n+      this.testEnvironment = new TestEnvironment(cluster, testClass);\n+    } catch (Exception ex) {\n+      cluster.deleteClusterDir();\n+      ex.printStackTrace();\n+      throw ex;\n+    }\n+    cluster.startRcaControllerThread();\n+  }\n+\n+  private static ClusterType getClusterTypeFromAnnotation(Class testClass) {\n+    if (!testClass.isAnnotationPresent(AClusterType.class)) {\n+      throw new IllegalArgumentException(\n+          testClass.getSimpleName() + \" does not have the mandatory annotation: \" + AClusterType.class.getSimpleName());\n+    }\n+    return ((AClusterType) testClass.getAnnotation(AClusterType.class)).value();\n+  }\n+\n+  @Override\n+  public Description getDescription() {\n+    return Description.createTestDescription(testClass, \"A custom runner for RcaIt\");\n+  }\n+\n+  @Override\n+  public void run(RunNotifier notifier) {\n+    try {\n+      for (Method method : testClass.getMethods()) {\n+        if (method.isAnnotationPresent(Test.class)) {\n+          notifier.fireTestStarted(Description\n+              .createTestDescription(testClass, method.getName()));\n+\n+          try {\n+            this.testEnvironment.updateEnvironment(method);\n+            this.testEnvironment.verifyEnvironmentSetup();\n+          } catch (Exception ex) {\n+            notifier.fireTestFailure(\n+                new Failure(\n+                    Description.createTestDescription(testClass.getClass(), method.getName()), ex));\n+          }\n+          cluster.startRcaScheduler();\n+\n+          try {\n+            method.invoke(testObject);", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0Njc3MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468746770", "bodyText": "The method is the reflection interface. It does not want to instantiate the object and therefore, you have to provide the object on which this method has to be executed.", "author": "yojs", "createdAt": "2020-08-11T17:29:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQyNDYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQzMTE4NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468431184", "bodyText": "Curious, how do we know there's only a single shard, or is this by design, or does this mean something else entirely?", "author": "sidheart", "createdAt": "2020-08-11T08:58:35Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/tests/poc/SimpleAnalysisGraph.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.tests.poc;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonDimension.INDEX_NAME;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonDimension.SHARD_ID;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.grpc.FlowUnitMessage;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.metricsdb.MetricsDB;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Rca;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.Resources;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.contexts.ResourceContext;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.MetricFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.flow_units.ResourceFlowUnit;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.metrics.CPU_Utilization;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotClusterSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotNodeSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.summaries.HotShardSummary;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.InstanceDetails;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.scheduler.FlowUnitOperationArgWrapper;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.ElasticSearchAnalysisGraph;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.store.rca.hotshard.IndexShardKey;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.jooq.Record;\n+\n+public class SimpleAnalysisGraph extends ElasticSearchAnalysisGraph {\n+  public static class NodeRca extends Rca<ResourceFlowUnit<HotNodeSummary>> {\n+    private final CPU_Utilization cpuUtilization;\n+\n+    public NodeRca(CPU_Utilization cpu_utilization) {\n+      super(1);\n+      this.cpuUtilization = cpu_utilization;\n+    }\n+\n+    @Override\n+    public void generateFlowUnitListFromWire(FlowUnitOperationArgWrapper args) {\n+      final List<FlowUnitMessage> flowUnitMessages =\n+          args.getWireHopper().readFromWire(args.getNode());\n+      List<ResourceFlowUnit<HotNodeSummary>> flowUnitList = new ArrayList<>();\n+      for (FlowUnitMessage flowUnitMessage : flowUnitMessages) {\n+        flowUnitList.add(ResourceFlowUnit.buildFlowUnitFromWrapper(flowUnitMessage));\n+      }\n+      setFlowUnits(flowUnitList);\n+    }\n+\n+    @Override\n+    public ResourceFlowUnit<HotNodeSummary> operate() {\n+      double maxCpu = 0;\n+      IndexShardKey indexShardKey = null;\n+      for (MetricFlowUnit metricFlowUnit : cpuUtilization.getFlowUnits()) {\n+        if (metricFlowUnit.getData() != null) {\n+          // Go through all the entries and find out the shard with the highest CPU\n+          // utilization.\n+          for (Record record : metricFlowUnit.getData()) {\n+            try {\n+              String indexName = record.getValue(INDEX_NAME.toString(), String.class);\n+              // System.out.println(record);\n+              Integer shardId = record.getValue(SHARD_ID.toString(), Integer.class);\n+              if (indexName != null && shardId != null) {\n+                double usage = record.getValue(MetricsDB.MAX, Double.class);\n+                if (usage > maxCpu) {\n+                  maxCpu = usage;\n+                  indexShardKey = IndexShardKey.buildIndexShardKey(record);\n+                }\n+              }\n+            } catch (IllegalArgumentException ex) {\n+\n+            }\n+          }\n+        }\n+      }\n+      InstanceDetails instanceDetails = getInstanceDetails();\n+      HotNodeSummary nodeSummary = new HotNodeSummary(instanceDetails.getInstanceId(),\n+          instanceDetails.getInstanceIp());\n+      ResourceFlowUnit rfu;\n+      if (indexShardKey != null) {\n+        //System.out.println(\"NodeRca running on \" + instanceDetails.getInstanceId());\n+\n+        HotShardSummary summary = new HotShardSummary(\n+            indexShardKey.getIndexName(),\n+            String.valueOf(indexShardKey.getShardId()),\n+            instanceDetails.getInstanceId().toString(),\n+            0);\n+        summary.setcpuUtilization(maxCpu);\n+        nodeSummary.appendNestedSummary(summary);\n+        rfu = new ResourceFlowUnit<>(\n+            System.currentTimeMillis(),\n+            new ResourceContext(Resources.State.UNHEALTHY),\n+            nodeSummary,\n+            true);\n+\n+        //System.out.println(\"NODE RCA: \" + rfu);\n+      } else {\n+        rfu = new ResourceFlowUnit<>(System.currentTimeMillis());\n+      }\n+      return rfu;\n+    }\n+  }\n+\n+  public static class ClusterRca extends Rca<ResourceFlowUnit<HotClusterSummary>> {\n+    private final NodeRca nodeRca;\n+\n+    public ClusterRca(NodeRca nodeRca) {\n+      super(1);\n+      this.nodeRca = nodeRca;\n+    }\n+\n+    @Override\n+    public void generateFlowUnitListFromWire(FlowUnitOperationArgWrapper args) {\n+      throw new IllegalArgumentException(name() + \"'s generateFlowUnitListFromWire() should not \"\n+          + \"be required.\");\n+    }\n+\n+    // The cluster level RCA goes through all the nodeLevel summaries and then picks the node\n+    // with the highest CPU and states which shard it is the highest for.\n+    @Override\n+    public ResourceFlowUnit<HotClusterSummary> operate() {\n+      final List<ResourceFlowUnit<HotNodeSummary>> resourceFlowUnits = nodeRca.getFlowUnits();\n+      HotClusterSummary summary = new HotClusterSummary(\n+          getAllClusterInstances().size(), 1);\n+\n+      final InstanceDetails.Id defaultId = new InstanceDetails.Id(\"default-id\");\n+      final InstanceDetails.Ip defaultIp = new InstanceDetails.Ip(\"1.1.1.1\");\n+\n+      InstanceDetails.Id hotNodeId = defaultId;\n+      InstanceDetails.Ip hotsNodeAddr = defaultIp;\n+      String hotShard = \"\";\n+      String hotShardIndex = \"\";\n+      double cpuUtilization = 0.0;\n+\n+      for (final ResourceFlowUnit<HotNodeSummary> resourceFlowUnit : resourceFlowUnits) {\n+        if (resourceFlowUnit.isEmpty()) {\n+          continue;\n+        }\n+        HotNodeSummary nodeSummary = resourceFlowUnit.getSummary();\n+        HotShardSummary hotShardSummary = nodeSummary.getHotShardSummaryList().get(0);", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0ODIxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468748211", "bodyText": "This is just a simplistic test to show how to write tests using this framework. The way it works is that, it picks the shard with the maximum CPU usage and that's how we know there will be only 1.", "author": "yojs", "createdAt": "2020-08-11T17:32:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQzMTE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQzMzg2MA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468433860", "bodyText": "What does this mean? I get that cluster level RCA's must be computed on the master, but what's TAG_AGGREGATE_UPSTREAM? And does a DATA_MASTER count as a MASTER?", "author": "sidheart", "createdAt": "2020-08-11T09:03:17Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/tests/poc/RcaItPocSingleNode.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.tests.poc;\n+\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonDimension.Constants.INDEX_NAME_VALUE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonDimension.Constants.OPERATION_VALUE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonDimension.Constants.SHARDID_VALUE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.metrics.AllMetrics.CommonDimension.Constants.SHARD_ROLE_VALUE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts.RcaTagConstants.LOCUS_DATA_MASTER_NODE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts.RcaTagConstants.LOCUS_DATA_NODE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts.RcaTagConstants.LOCUS_MASTER_NODE;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts.RcaTagConstants.TAG_AGGREGATE_UPSTREAM;\n+import static com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.util.RcaConsts.RcaTagConstants.TAG_LOCUS;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.framework.api.metrics.CPU_Utilization;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AClusterType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AExpect;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.AMetric;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ARcaGraph;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATable;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.annotations.ATuple;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.TestApi;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.ClusterType;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.configs.HostTag;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.runners.RcaItNotEncryptedRunner;\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.tests.poc.validator.PocValidator;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+@RunWith(RcaItNotEncryptedRunner.class)\n+\n+@AClusterType(ClusterType.SINGLE_NODE)\n+@ARcaGraph(RcaItPocSingleNode.SimpleAnalysisGraphForCoLocated.class)\n+@AMetric(name = CPU_Utilization.class,\n+    dimensionNames = {SHARDID_VALUE, INDEX_NAME_VALUE, OPERATION_VALUE, SHARD_ROLE_VALUE},\n+    tables = {\n+        @ATable(hostTag = HostTag.DATA_0,\n+            tuple = {\n+                @ATuple(dimensionValues = {\"0\", \"logs\", \"bulk\", \"p\"},\n+                    sum = 0.0, avg = 0.0, min = 0.0, max = 0.0),\n+                @ATuple(dimensionValues = {\"1\", \"logs\", \"bulk\", \"r\"},\n+                    sum = 0.0, avg = 0.0, min = 0.0, max = 80.0),\n+                @ATuple(dimensionValues = {\"2\", \"logs\", \"bulk\", \"p\"},\n+                    sum = 0.0, avg = 0.0, min = 0.0, max = 10.0)\n+            }\n+        )\n+    }\n+)\n+public class RcaItPocSingleNode {\n+  private TestApi api;\n+\n+  @Test\n+  @AExpect(\n+      what = AExpect.Type.REST_API,\n+      on = HostTag.DATA_0,\n+      validator = PocValidator.class,\n+      forRca = SimpleAnalysisGraphForCoLocated.ClusterRca.class)\n+  public void simple() {\n+  }\n+\n+  public void setTestApi(final TestApi api) {\n+    this.api = api;\n+  }\n+\n+\n+  public static class SimpleAnalysisGraphForCoLocated extends SimpleAnalysisGraph {\n+\n+    @Override\n+    public void construct() {\n+      CPU_Utilization cpuUtilization = new CPU_Utilization(1);\n+      cpuUtilization.addTag(TAG_LOCUS, LOCUS_DATA_MASTER_NODE);\n+      addLeaf(cpuUtilization);\n+\n+      SimpleAnalysisGraph.NodeRca nodeRca = new SimpleAnalysisGraph.NodeRca(cpuUtilization);\n+      nodeRca.addTag(TAG_LOCUS, LOCUS_DATA_MASTER_NODE);\n+      nodeRca.addAllUpstreams(Arrays.asList(cpuUtilization));\n+\n+      SimpleAnalysisGraph.ClusterRca clusterRca = new SimpleAnalysisGraph.ClusterRca(nodeRca);\n+      clusterRca.addTag(TAG_LOCUS, LOCUS_MASTER_NODE);\n+      clusterRca.addAllUpstreams(Collections.singletonList(nodeRca));\n+      clusterRca.addTag(TAG_AGGREGATE_UPSTREAM, LOCUS_DATA_NODE);", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0OTk4NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468749984", "bodyText": "The data master means this RCA can execute on data as well as the master node. This flag wasn't something added in this framework. But this is a good point. The confusion arises because our documentation isn't clear about it. Will add that.", "author": "yojs", "createdAt": "2020-08-11T17:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQzMzg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQzNTE5NA==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468435194", "bodyText": "Either this comment is incorrect or the call to object.get(\"state\") down below is incorrect", "author": "sidheart", "createdAt": "2020-08-11T09:05:37Z", "path": "src/test/java/com/amazon/opendistro/elasticsearch/performanceanalyzer/rca/integTests/tests/poc/validator/PocValidator.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.tests.poc.validator;\n+\n+import com.amazon.opendistro.elasticsearch.performanceanalyzer.rca.integTests.framework.api.IValidator;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import java.util.List;\n+import org.jooq.Record;\n+import org.jooq.Result;\n+import org.junit.Assert;\n+\n+// Validators are only initialized once to evaluate a test method.\n+public class PocValidator implements IValidator {\n+  long startTime;\n+\n+  public PocValidator() {\n+    startTime = System.currentTimeMillis();\n+  }\n+\n+  /**\n+   * {\"rca_name\":\"ClusterRca\",\n+   * \"timestamp\":1596557050522,\n+   * \"state\":\"unhealthy\",\n+   * \"HotClusterSummary\":[\n+   * {\"number_of_nodes\":1,\"number_of_unhealthy_nodes\":1}\n+   * ]}\n+   */\n+  @Override\n+  public boolean check(JsonElement response) {\n+    JsonArray array = response.getAsJsonObject().get(\"data\").getAsJsonArray();\n+    if (array.size() == 0) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < array.size(); i++) {\n+      JsonObject object = array.get(i).getAsJsonObject();\n+      if (object.get(\"rca_name\").getAsString().equals(\"ClusterRca\")) {\n+        return checkClusterRca(object);\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * \"HotClusterSummary\":[{\"number_of_nodes\":1,\"number_of_unhealthy_nodes\":1}]", "originalCommit": "9caaaac68ac9d9285c2b4ef9367cea87024a9f7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1MjYwNg==", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/pull/301#discussion_r468752606", "bodyText": "The comment doesn't capture the full object but just one of the k/v pairs. I have updated the comment to include the full object. This should make it more clear.", "author": "yojs", "createdAt": "2020-08-11T17:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQzNTE5NA=="}], "type": "inlineReview"}, {"oid": "086cdb4ef6db738c4d3c06d605bee2b324211eb9", "url": "https://github.com/opendistro-for-elasticsearch/performance-analyzer-rca/commit/086cdb4ef6db738c4d3c06d605bee2b324211eb9", "message": "Addressing PR comments", "committedDate": "2020-08-11T17:40:51Z", "type": "commit"}]}