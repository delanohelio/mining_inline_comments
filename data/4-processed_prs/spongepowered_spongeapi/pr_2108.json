{"pr_number": 2108, "pr_title": "Api8 Keys", "pr_createdAt": "2020-04-13T14:59:10Z", "pr_url": "https://github.com/SpongePowered/SpongeAPI/pull/2108", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwNjc1Ng==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r408706756", "bodyText": "APPLICABLE_POTION_EFFECTS", "author": "Cybermaxke", "createdAt": "2020-04-15T09:30:15Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -273,8 +296,12 @@\n     public static final Supplier<Key<BoundedValue<Integer>>> ANGER_LEVEL = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ANGER\");\n \n     /**\n-     * Represents the {@link Key} for the enchantments applied to an\n-     * {@link ItemStack}.\n+     * The set of {@link PotionEffect}s applied on use of an {@link ItemStack}.\n+     */\n+    public static final Supplier<Key<Value<Set<PotionEffect>>>> APPLICABLE_EFFECTS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"APPLICABLE_EFFECTS\");", "originalCommit": "b8751271af7a7d06b8bd48adc136638397cf7513", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwODIyNA==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r408708224", "bodyText": "Rename this back to MINECART_BLOCK_OFFSET, I named it like this to prevent conflicts with possible new keys that don't use an Int.", "author": "Cybermaxke", "createdAt": "2020-04-15T09:32:50Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -285,280 +312,100 @@\n     public static final Supplier<Key<ListValue<Enchantment>>> APPLIED_ENCHANTMENTS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ITEM_ENCHANTMENTS\");\n \n     /**\n-     * Represents the {@link Key} for the age (in ticks) of an\n-     * {@link AreaEffectCloud} created by a lingering potion.\n-     */\n-    public static final Supplier<Key<BoundedValue<Integer>>> AREA_EFFECT_CLOUD_AGE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_AGE\");\n-\n-    /**\n-     * Represents the {@link Key} for the color of an {@link AreaEffectCloud}\n-     * created by a lingering potion.\n-     */\n-    public static final Supplier<Key<Value<Color>>> AREA_EFFECT_CLOUD_COLOR = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_COLOR\");\n-\n-    /**\n-     * Represents the {@link Key} for the maximum age (in ticks) of an\n-     * {@link AreaEffectCloud} created by a lingering potion.\n-     */\n-    public static final Supplier<Key<BoundedValue<Integer>>> AREA_EFFECT_CLOUD_DURATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_DURATION\");\n-\n-    /**\n-     * Represents the {@link Key} for the amount of ticks the duration of an\n-     * {@link AreaEffectCloud} is increased or reduced when it applies its\n-     * effect.\n-     */\n-    public static final Supplier<Key<BoundedValue<Integer>>> AREA_EFFECT_CLOUD_DURATION_ON_USE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_DURATION_ON_USE\");\n-\n-    /**\n-     * Represents the {@link Key} for the particle type of an\n-     * {@link AreaEffectCloud} created by a lingering potion.\n-     *\n-     * <p>Only a few {@link ParticleOption}s will be usable for this\n-     * effect for specific {@link ParticleType}s and not every\n-     * {@link ParticleType} will be applicable.</p>\n-     */\n-    public static final Supplier<Key<Value<ParticleEffect>>> AREA_EFFECT_CLOUD_PARTICLE_EFFECT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_PARTICLE_EFFECT\");\n-\n-    /**\n-     * Represents the {@link Key} for the radius of an {@link AreaEffectCloud}.\n-     */\n-    public static final Supplier<Key<BoundedValue<Double>>> AREA_EFFECT_CLOUD_RADIUS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_RADIUS\");\n-\n-    /**\n-     * Represents the {@link Key} for the amount the radius of an\n-     * {@link AreaEffectCloud} grows or shrinks each time it applies its\n-     * effect.\n-     */\n-    public static final Supplier<Key<BoundedValue<Double>>> AREA_EFFECT_CLOUD_RADIUS_ON_USE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_RADIUS_ON_USE\");\n-\n-    /**\n-     * Represents the {@link Key} for the amount the radius of an\n-     * {@link AreaEffectCloud} grows or shrinks per tick.\n-     */\n-    public static final Supplier<Key<BoundedValue<Double>>> AREA_EFFECT_CLOUD_RADIUS_PER_TICK = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_RADIUS_PER_TICK\");\n-\n-    /**\n-     * Represents the {@link Key} for the delay (in ticks) after which an\n-     * {@link AreaEffectCloud} will reapply its effect on a previously\n-     * affected {@link Entity}.\n-     */\n-    public static final Supplier<Key<BoundedValue<Integer>>> AREA_EFFECT_CLOUD_REAPPLICATION_DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_REAPPLICATION_DELAY\");\n-\n-    /**\n-     * Represents the {@link Key} for the duration in ticks after which an\n-     * {@link AreaEffectCloud} will begin to apply its effect to entities.\n-     */\n-    public static final Supplier<Key<BoundedValue<Integer>>> AREA_EFFECT_CLOUD_WAIT_TIME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_WAIT_TIME\");\n-\n-    /**\n-     * Represents the {@link Key} for whether an {@link ArmorStand}'s arms are\n-     * visible.\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> ARMOR_STAND_HAS_ARMS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ARMOR_STAND_HAS_ARMS\");\n-\n-    /**\n-     * Represents the {@link Key} for whether an {@link ArmorStand} has a\n-     * visible base plate.\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> ARMOR_STAND_HAS_BASE_PLATE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ARMOR_STAND_HAS_BASE_PLATE\");\n-\n-    /**\n-     * Represents the {@link Key} for if an {@link ArmorStand} is a \"marker\" stand.\n-     *\n-     * <p>If {@code true}, the armor stand's bounding box is near\n-     * impossible to see, and the armor stand can no longer be\n-     * interacted with.</p>\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> ARMOR_STAND_HAS_MARKER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ARMOR_STAND_HAS_MARKER\");\n-\n-    /**\n-     * Represents the {@link Key} for whether an {@link ArmorStand} is small.\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> ARMOR_STAND_IS_SMALL = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ARMOR_STAND_IS_SMALL\");\n-\n-    /**\n-     * Represents the {@link Key} for whether players are prevented from taking\n-     * items from an equipment slot on an {@link ArmorStand}\n-     */\n-    public static final Supplier<Key<SetValue<EquipmentType>>> ARMOR_STAND_PLACING_DISABLED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ARMOR_STAND_PLACING_DISABLED\");\n-\n-    /**\n-     * Represents the {@link Key} for whether players are prevented from taking\n-     * items from an equipment slot on an {@link ArmorStand}\n-     */\n-    public static final Supplier<Key<SetValue<EquipmentType>>> ARMOR_STAND_TAKING_DISABLED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ARMOR_STAND_TAKING_DISABLED\");\n-\n-    /**\n-     * Represents the {@link Key} for the type of {@link ArtType} shown by\n-     * (usually) a {@link Painting}.\n+     * The type of {@link ArtType} shown by {@link Painting}s.\n      */\n     public static final Supplier<Key<Value<ArtType>>> ART = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ART\");\n \n     /**\n-     * Represents the {@link Key} for the attachment {@link Surface}\n-     * of a button or lever.\n+     * The attachment {@link Surface} of a button or lever.\n      */\n     public static final Supplier<Key<Value<Surface>>> ATTACHMENT_SURFACE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ATTACHMENT_SURFACE\");\n \n     /**\n-     * Represents the {@link Key} for the damage dealt by a\n-     * {@link DamagingProjectile}, e.g. an {@link ArrowEntity}.\n+     * The damage dealt by a {@link DamagingProjectile}, e.g. an {@link ArrowEntity}.\n      */\n     public static final Supplier<Key<BoundedValue<Double>>> ATTACK_DAMAGE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ATTACK_DAMAGE\");\n \n     /**\n-     * Represents the {@link Key} for the time of a {@link Ravager} is considered attacking.\n+     * The time of a {@link Ravager} is considered attacking.\n      */\n     public static final Supplier<Key<Value<Integer>>> ATTACK_TIME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ATTACK_TIME\");\n \n     /**\n-     * Represents the {@link Key} for representing the {@link Axis} direction\n-     * of a {@link BlockState}.\n+     * The author of a {@link ItemTypes#WRITTEN_BOOK}.\n      */\n-    public static final Supplier<Key<Value<Axis>>> AXIS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AXIS\");\n+    public static final Supplier<Key<Value<Text>>> AUTHOR = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AUTHOR\");\n \n     /**\n-     * Represents the {@link Key} for a {@link Banner}'s base {@link DyeColor}.\n+     * The {@link Axis} direction of a {@link BlockState}.\n      */\n-    public static final Supplier<Key<Value<DyeColor>>> BANNER_BASE_COLOR = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BANNER_BASE_COLOR\");\n+    public static final Supplier<Key<Value<Axis>>> AXIS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AXIS\");\n \n     /**\n-     * Represents the {@link Key} for a {@link Banner}'s patterns.\n+     * The base {@link DyeColor} of a {@link Banner} or {@link TropicalFish}.\n      */\n-    public static final Supplier<Key<ListValue<BannerPatternLayer>>> BANNER_PATTERN_LAYERS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BANNER_PATTERN_LAYERS\");\n+    public static final Supplier<Key<Value<DyeColor>>> BASE_COLOR = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BASE_COLOR\");\n \n     /**\n-     * Represents the {@link Key} for the width of the physical form of an\n-     * {@link Entity}.\n+     * The width of the physical form of an {@link Entity}.\n      *\n-     * <p>Together with {@link #HEIGHT} this defines the size of an\n+     * <p>Together with {@link #HEIGHT} and {@link #SCALE} this defines the size of an\n      * {@link Entity}.</p>\n      */\n     public static final Supplier<Key<BoundedValue<Double>>> BASE_SIZE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BASE_SIZE\");\n \n     /**\n-     * Represents the {@link Key} for the base vehicle a passenger is riding\n-     * at the moment. This may be different from {@link Keys#VEHICLE} as the\n+     * The base vehicle a passenger is riding at the moment.\n+     * This may be different from {@link Keys#VEHICLE} as the\n      * vehicle an {@link Entity} is riding may itself be the passenger of\n      * another vehicle.\n      */\n     public static final Supplier<Key<Value<Entity>>> BASE_VEHICLE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BASE_VEHICLE\");\n \n     /**\n-     * Represents the {@link Key} for a {@link Beacon}'s primary effect.\n-     */\n-    public static final Supplier<Key<Value<PotionEffectType>>> BEACON_PRIMARY_EFFECT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BEACON_PRIMARY_EFFECT\");\n-\n-    /**\n-     * Represents the {@link Key} for a {@link Beacon}'s secondary effect.\n+     * The default temperature of a biome at a specific {@link Location}.\n+     * For the exact block temperature see {@link #BLOCK_TEMPERATURE}.\n      */\n-    public static final Supplier<Key<Value<PotionEffectType>>> BEACON_SECONDARY_EFFECT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BEACON_SECONDARY_EFFECT\");\n-\n-    /**\n-     * Represents the {@link Key} for the {@link Living} who is being targeted by a\n-     * {@link Guardian}.\n-     */\n-    public static final Supplier<Key<Value<Living>>> BEAM_TARGET_ENTITY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BEAM_TARGET_ENTITY\");\n-\n-    /**\n-     * Represents the {@link Key} for a {@link EnderCrystal}'s beam target.\n-     */\n-    public static final Supplier<Key<Value<Vector3i>>> BEAM_TARGET_POSITION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BEAM_TARGET_POSITION\");\n-\n-    /**\n-     * Represents the {@link Key} for the pore sides\n-     * of a {@link BlockTypes#BROWN_MUSHROOM_BLOCK} or\n-     * {@link BlockTypes#RED_MUSHROOM_BLOCK} {@link BlockState}.\n-     */\n-    public static final Supplier<Key<SetValue<Direction>>> BIG_MUSHROOM_PORES = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BIG_MUSHROOM_PORES\");\n-\n-    /**\n-     * Represents the {@link Key} for the {@link Direction#DOWN}\n-     * pores side of a {@link BlockTypes#BROWN_MUSHROOM_BLOCK} or\n-     * {@link BlockTypes#RED_MUSHROOM_BLOCK} {@link BlockState}.\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> BIG_MUSHROOM_PORES_DOWN = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BIG_MUSHROOM_PORES_DOWN\");\n-\n-    /**\n-     * Represents the {@link Key} for the {@link Direction#EAST}\n-     * pores side of a {@link BlockTypes#BROWN_MUSHROOM_BLOCK} or\n-     * {@link BlockTypes#RED_MUSHROOM_BLOCK} {@link BlockState}.\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> BIG_MUSHROOM_PORES_EAST = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BIG_MUSHROOM_PORES_EAST\");\n-\n-    /**\n-     * Represents the {@link Key} for the {@link Direction#NORTH}\n-     * pores side of a {@link BlockTypes#BROWN_MUSHROOM_BLOCK} or\n-     * {@link BlockTypes#RED_MUSHROOM_BLOCK} {@link BlockState}.\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> BIG_MUSHROOM_PORES_NORTH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BIG_MUSHROOM_PORES_NORTH\");\n-\n-    /**\n-     * Represents the {@link Key} for the {@link Direction#SOUTH}\n-     * pores side of a {@link BlockTypes#BROWN_MUSHROOM_BLOCK} or\n-     * {@link BlockTypes#RED_MUSHROOM_BLOCK} {@link BlockState}.\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> BIG_MUSHROOM_PORES_SOUTH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BIG_MUSHROOM_PORES_SOUTH\");\n-\n-    /**\n-     * Represents the {@link Key} for the {@link Direction#UP}\n-     * pores side of a {@link BlockTypes#BROWN_MUSHROOM_BLOCK} or\n-     * {@link BlockTypes#RED_MUSHROOM_BLOCK} {@link BlockState}.\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> BIG_MUSHROOM_PORES_UP = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BIG_MUSHROOM_PORES_UP\");\n-\n-    /**\n-     * Represents the {@link Key} for the {@link Direction#WEST}\n-     * pores side of a {@link BlockTypes#BROWN_MUSHROOM_BLOCK} or\n-     * {@link BlockTypes#RED_MUSHROOM_BLOCK} {@link BlockState}.\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> BIG_MUSHROOM_PORES_WEST = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BIG_MUSHROOM_PORES_WEST\");\n+    public static final Supplier<Key<Value<Double>>> BIOME_TEMPERATURE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BIOME_TEMPERATURE\");\n \n     /**\n-     * Represents the {@link Key} for the temperature of a biome at a block location.\n+     * The blast resistance of a block.\n      */\n-    public static final Supplier<Key<Value<Double>>> BIOME_TEMPERATURE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BIOME_TEMPERATURE\");\n+    public static final Supplier<Key<Value<Double>>> BLAST_RESISTANCE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BLAST_RESISTANCE\");\n \n     /**\n-     * Represents the {@link Key} for the blast resistance of a block.\n+     * The blocklight value at a {@link Location}.\n+     * For the skylight see {@link #SKY_LIGHT}.\n      */\n-    public static final Supplier<Key<Value<Double>>> BLAST_RESISTANCE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BLAST_RESISTANCE\");\n+    public static final Supplier<Key<Value<Integer>>> BLOCK_LIGHT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BLOCK_LIGHT\");\n \n     /**\n-     * Represents the {@link Key} for the amount of light that is emitted by the\n-     * surrounding blocks at a block location. The value scales normally from 0 to 1.\n+     * TODO {@link #BLOCK_LIGHT}?\n+     * The amount of light that is emitted by the surrounding blocks at a block location.\n+     * The value scales normally from 0 to 1.\n      *\n      * <p>In vanilla minecraft is this value in steps of 1/15 from 0 to 1.</p>\n      */\n     public static final Supplier<Key<Value<Double>>> BLOCK_LUMINANCE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BLOCK_LUMINANCE\");\n \n     /**\n-     * Represents the {@link Key} for the {@link BlockState} of a {@link BlockOccupiedMinecart} or {@link FallingBlock}.\n-     */\n-    public static final Supplier<Key<Value<BlockState>>> BLOCK_STATE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BLOCK_STATE\");\n-\n-    /**\n-     * Represents the {@link Key} for if a {@link Boat} can move on land.\n+     * The represented block's offset of a {@link MinecartEntity}.\n      */\n-    public static final Supplier<Key<Value<Boolean>>> BOAT_CAN_MOVE_ON_LAND = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BOAT_CAN_MOVE_ON_LAND\");\n+    public static final Supplier<Key<Value<Integer>>> BLOCK_OFFSET = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BLOCK_OFFSET\");", "originalCommit": "b8751271af7a7d06b8bd48adc136638397cf7513", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwODk0OA==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r408708948", "bodyText": "Use Double", "author": "Cybermaxke", "createdAt": "2020-04-15T09:34:04Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -770,105 +607,96 @@\n     public static final Supplier<Key<MapValue<EntityType<?>, Double>>> CUSTOM_ATTACK_DAMAGE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"CUSTOM_ATTACK_DAMAGE_MAPPING\");\n \n     /**\n-     * Represents the {@link Key} for how much damage a {@link FallingBlock}\n-     * deals to {@link Living} entities it hits.\n+     * The damage absorbed by an armor {@link ItemStack}.\n+     */\n+    public static final Supplier<Key<Value<Integer>>> DAMAGE_ABSORBTION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DAMAGE_ABSORBTION\");\n+\n+    /**\n+     * How much damage a {@link FallingBlock} deals to {@link Living} entities\n+     * it hits per block fallen.\n      *\n      * <p>This damage is capped by {@link #MAX_FALL_DAMAGE}.</p>\n      */\n     public static final Supplier<Key<BoundedValue<Double>>> DAMAGE_PER_BLOCK = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DAMAGE_PER_BLOCK\");\n \n     /**\n-     * Represents the {@link Key} for representing at which distance a {@link BlockState}\n-     * will decay. This usually applies to leaves, for example {@link BlockTypes#OAK_LEAVES}.\n+     * The distance at which a {@link BlockState} will decay.\n+     * This usually applies to leaves, for example {@link BlockTypes#OAK_LEAVES}.\n      */\n     public static final Supplier<Key<BoundedValue<Integer>>> DECAY_DISTANCE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DECAY_DISTANCE\");\n \n     /**\n-     * Represents the {@link Key} for the delay on a redstone repeater.\n+     * The modifier to {@link Keys#VELOCITY} of a {@link Minecart} while derailed.\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DELAY\");\n+    public static final Supplier<Key<Value<Vector3d>>> DERAILED_VELOCITY_MODIFIER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DERAILED_VELOCITY_MODIFIER\");\n \n     /**\n-     * Represents the {@link Key} for representing the despawn delay of a {@link Item} or {@link TraderLlama}.\n+     * The despawn delay of a {@link Item} or {@link TraderLlama}.\n      */\n     public static final Supplier<Key<BoundedValue<Integer>>> DESPAWN_DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DESPAWN_DELAY\");\n \n     /**\n-     * Represents the {@link Key} for the detonator of a {@link PrimedTNT}.\n+     * The detonator of a {@link PrimedTNT}.\n      */\n     public static final Supplier<Key<Value<Living>>> DETONATOR = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DETONATOR\");\n \n     /**\n-     * Represents the {@link Key} for representing the {@link Direction} a {@link BlockState}, {@link Hanging}, or {@link Shulker} is facing or the\n+     * The {@link Direction} a {@link BlockState}, {@link Hanging}, or {@link Shulker} is facing or the\n      * heading of a {@link ShulkerBullet}.\n      */\n     public static final Supplier<Key<Value<Direction>>> DIRECTION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DIRECTION\");\n \n     /**\n-     * Represents the {@link Key} for displaying the chest of a {@link PackHorse}.\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> DISPLAY_CHEST = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DISPLAY_CHEST\");\n-\n-    /**\n-     * Represents the {@link Key} for the display name of an {@link Entity},\n-     * {@link ItemStack} or {@link BlockEntity}.\n+     * The display name of an {@link Entity}, {@link ItemStack} or {@link BlockEntity}.\n      *\n      * <p>On a {@link ItemTypes#WRITTEN_BOOK} item this will also set the title\n      * of the book.</p>\n      */\n     public static final Supplier<Key<Value<Text>>> DISPLAY_NAME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DISPLAY_NAME\");\n \n     /**\n-     * Represents the {@link Key} for representing the \"got fish\" state of a {@link Dolphin}.\n+     * The dominant {@link HandPreference} of a {@link Living} entity.\n      *\n-     * <p>\n-     *     Dolphins will navigate to a treasure (if a structure that provides one is nearby)\n-     *     if they have been given a fish.\n-     * </p>\n+     * <p><em>NOTE:</em> For {@link Player}s is this key read-only, the\n+     * {@link HandPreference} of a player can not be changed server-side.</p>\n      */\n-    public static final Supplier<Key<Value<Boolean>>> DOLPHIN_DOES_GOT_FISH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DOLPHIN_DOES_GOT_FISH\");\n+    public static final Supplier<Key<Value<HandPreference>>> DOMINANT_HAND = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DOMINANT_HAND\");\n \n     /**\n-     * Represents the {@link Key} for representing the \"moisture\" state of a {@link Dolphin}.\n-     *\n-     * <p>\n-     *     Vanilla sets the dolphin's skin moisture to 2400 so long as the entity\n-     *     is in water, being rained on, or in a bubble column. If not, the dolphin\n-     *     will loose 1 moisture per tick. Once this value is 0 or below, the dolphin\n-     *     will be damaged via {@link DamageSources#DRYOUT} with a value of 1 per tick\n-     *     until death.\n-     * </p>\n+     * Whether exact teleport location should be used with a {@link EndGateway}.\n      */\n-    public static final Supplier<Key<Value<Integer>>> DOLPHIN_SKIN_MOISTURE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DOLPHIN_SKIN_MOISTURE\");\n+    public static final Supplier<Key<Value<Boolean>>> DO_EXACT_TELEPORT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DO_EXACT_TELEPORT\");\n \n     /**\n-     * Represents the {@link Key} for representing the dominant {@link HandPreference}\n-     * of a {@link Living} entity.\n-     *\n-     * <p><em>NOTE:</em> For {@link Player}s is this key read-only, the\n-     * {@link HandPreference} of a player can not be changed server-side.</p>\n+     * The maximum age (in ticks) of an\n+     * {@link AreaEffectCloud} created by a lingering potion.\n      */\n-    public static final Supplier<Key<Value<HandPreference>>> DOMINANT_HAND = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DOMINANT_HAND\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> DURATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DURATION\");\n \n     /**\n-     * Represents the {@link Key} for representing if the exact teleport location\n-     * should be used with a {@link EndGateway}.\n+     * The amount of ticks the duration of an\n+     * {@link AreaEffectCloud} is increased or reduced when it applies its\n+     * effect.\n      */\n-    public static final Supplier<Key<Value<Boolean>>> DO_EXACT_TELEPORT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DO_EXACT_TELEPORT\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> DURATION_ON_USE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DURATION_ON_USE\");\n \n     /**\n-     * Represents the {@link Key} for the color of a dyeable block, item or\n-     * entity.\n+     * The color of a dyeable block, item or entity.\n      */\n     public static final Supplier<Key<Value<DyeColor>>> DYE_COLOR = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"DYE_COLOR\");\n \n     /**\n-     * Represents the {@link Key} for the time a {@link Panda} has been eating (in ticks)\n+     * The time a {@link Panda} has been eating (in ticks)\n      */\n     public static final Supplier<Key<Value<Integer>>> EATING_TIME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"EATING_TIME\");\n \n     /**\n-     * Represents the {@link Key} for the time until a {@link Chicken} lays an {@link ItemTypes#EGG}.\n+     * The efficiency of an {@link ItemStack} tool. Affects mining speed of supported materials.\n+     */\n+    public static final Supplier<Key<Value<Float>>> EFFICIENCY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"EFFICIENCY\");", "originalCommit": "b8751271af7a7d06b8bd48adc136638397cf7513", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwOTc3Nw==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r408709777", "bodyText": "REPLENISHED_FOOD and REPLENISHED_SATURATION", "author": "Cybermaxke", "createdAt": "2020-04-15T09:35:27Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -1044,54 +857,109 @@\n     public static final Supplier<Key<BoundedValue<Integer>>> FOOD_LEVEL = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"FOOD_LEVEL\");\n \n     /**\n-     * Represents the {@link Key} for the type of a {@link Fox}.\n+     * The amount of food a food {@link ItemStack} restores when eaten.\n+     */\n+    public static final Supplier<Key<Value<Integer>>> FOOD_RESTORATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"FOOD_RESTORATION\");\n+\n+    /**\n+     * The amount of saturation a food {@link ItemStack} provides when eaten.\n+     */\n+    public static final Supplier<Key<Value<Double>>> FOOD_SATURATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"FOOD_SATURATION\");", "originalCommit": "b8751271af7a7d06b8bd48adc136638397cf7513", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMDg0MA==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r408710840", "bodyText": "IS_FULL_BLOCK", "author": "Cybermaxke", "createdAt": "2020-04-15T09:37:14Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -1044,54 +857,109 @@\n     public static final Supplier<Key<BoundedValue<Integer>>> FOOD_LEVEL = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"FOOD_LEVEL\");\n \n     /**\n-     * Represents the {@link Key} for the type of a {@link Fox}.\n+     * The amount of food a food {@link ItemStack} restores when eaten.\n+     */\n+    public static final Supplier<Key<Value<Integer>>> FOOD_RESTORATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"FOOD_RESTORATION\");\n+\n+    /**\n+     * The amount of saturation a food {@link ItemStack} provides when eaten.\n+     */\n+    public static final Supplier<Key<Value<Double>>> FOOD_SATURATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"FOOD_SATURATION\");\n+\n+    /**\n+     * The type of a {@link Fox}.\n      */\n     public static final Supplier<Key<Value<FoxType>>> FOX_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"FOX_TYPE\");\n \n     /**\n-     * Represents the {@link Key} for the modifier to {@link Keys#VELOCITY} of a {@link Minecart} while airborne.\n+     * Represents the {@link Key} for the amount of fuel left in a {@link BrewingStand} or {@link FurnaceBlockEntity} or {@link FurnaceMinecart}\n+     *\n+     * <p>One {@link ItemTypes#BLAZE_POWDER} adds 20 fuel to the brewing stand.</p>\n+     * <p>The fuel value corresponds with the number of batches of potions that can be brewed.</p>\n+     *\n+     * <p>See {@link #BURN_TIME} for the burn time added by a fuel {@link ItemStack} to a furnace</p>\n+     */\n+    public static final Supplier<Key<BoundedValue<Integer>>> FUEL = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"FUEL\");\n+\n+    /**\n+     * Whether the block at the {@link Location} is a full block.\n      */\n-    public static final Supplier<Key<Value<Duration>>> FURNACE_MINECART_FUEL_DURATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_FUEL_DURATION\");\n+    public static final Supplier<Key<Value<Boolean>>> FULL_BLOCK = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"FULL_BLOCK\");", "originalCommit": "b8751271af7a7d06b8bd48adc136638397cf7513", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMjc4OA==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r408712788", "bodyText": "I don't think this is specific enough, MAX_SPAWN_DELAY?\n(MAXIMUM -> MAX) for consistency with other keys.", "author": "Cybermaxke", "createdAt": "2020-04-15T09:40:17Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -1563,229 +1435,264 @@\n     public static final Supplier<Key<Value<Boolean>>> IS_SLEEPING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SLEEPING\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Player Player's} sleeping status is ignored when checking whether to\n+     * Whether a {@link Player Player's} sleeping status is ignored when checking whether to\n      * skip the night due to players sleeping. The time in a world will be\n      * advanced to day if all players in it either are sleeping or are set to ignore.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SLEEPING_IGNORED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SLEEPING_IGNORED\");\n \n     /**\n-     * Represents the {@link Key} for whether an {@link Entity} is sneaking.\n+     * Whether an {@link ArmorStand} is small.\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_SMALL = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SMALL\");\n+\n+    /**\n+     * Whether an {@link Entity} is sneaking.\n      *\n      * <p>Sneaking entities generally move slower and do not make walking\n      * sounds.</p>\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SNEAKING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SNEAKING\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Panda} is sneezing.\n+     * Whether a {@link Panda} is sneezing.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SNEEZING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SNEEZING\");\n \n     /**\n-     * Represents the {@link Key} for whether an {@link Entity} is sprinting.\n+     * Whether a {@link BlockState} is solid.\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_SOLID = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SOLID\");\n+\n+    /**\n+     * Whether an {@link Entity} is sprinting.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SPRINTING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SPRINTING\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link PolarBear} is currently standing.\n+     * Whether a {@link PolarBear} is currently standing.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_STANDING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_STANDING\");\n \n     /**\n-     * Represents the {@link Key} for whether an entity is stunned.\n+     * Whether a {@link Ravager} is stunned.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_STUNNED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_STUNNED\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link TameableAnimal} is currently tamed\n+     * Whether a {@link BlockState} is a surrogate block for a block that was provided in an environment\n+     * (almost always modded), that the block type provider no longer exists.\n+     * If true this may indicate that the surrogate block functions differently than the original block.\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_SURROGATE_BLOCK = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SURROGATE_BLOCK\");\n+\n+    /**\n+     * Whether a {@link TameableAnimal} is currently tamed\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_TAMED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_TAMED\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Trader} is currently trading with a {@link Player}.\n+     * Whether a {@link Trader} is currently trading with a {@link Player}.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_TRADING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_TRADING\");\n \n     /**\n-     * Represents the {@link Key} for if an {@link Ocelot} is currently trusting of {@link Player}s.\n+     * Whether a {@link Turtle} is currently traveling.\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_TRAVELING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_TRAVELING\");\n+\n+    /**\n+     * Whether an {@link Ocelot} is currently trusting of {@link Player}s.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_TRUSTING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_TRUSTING\");\n \n     /**\n-     * Represents the {@link Key} for whether an {@link ItemStack} or {@link BlockState} is unbreakable.\n+     * Whether an {@link ItemStack} or {@link BlockState} is unbreakable.\n      *\n-     * <p>Setting this to {@code  true} will prevent the item stack's\n+     * <p>Setting this to {@code true} will prevent the item stack's\n      * {@link #ITEM_DURABILITY} from changing.</p>\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_UNBREAKABLE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_UNBREAKABLE\");\n \n     /**\n-     * Represents the {@link Key} for whether a {@link Panda} is unhappy.\n+     * Whether a {@link Panda} is unhappy.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_UNHAPPY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_UNHAPPY\");\n \n     /**\n-     * Represents the {@link Key} for whether a {@link Wolf}, a\n-     * {@link BlockState} of {@link BlockTypes#SPONGE} or an {@link ItemStack}\n-     * of {@link ItemTypes#SPONGE} is wet.\n+     * Whether an {@link Entity} like {@link Wolf} or a\n+     * {@link BlockState} of {@link BlockTypes#SPONGE} is wet.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_WET = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_WET\");\n \n     /**\n-     * Represents the {@link Key} for the durability of an {@link ItemStack}.\n+     * The durability of an {@link ItemStack}.\n      */\n     public static final Supplier<Key<BoundedValue<Integer>>> ITEM_DURABILITY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ITEM_DURABILITY\");\n \n     /**\n-     * Represents the {@link Key} for the displayed description (\"lore\") text\n-     * of an {@link ItemStack}.\n-     *\n-     * <p>The lore text is usually displayed when the player hovers his cursor\n-     * over the stack. For the contents of a book see {@link #BOOK_PAGES}\n-     * instead.</p>\n-     */\n-    public static final Supplier<Key<ListValue<Text>>> ITEM_LORE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ITEM_LORE\");\n-\n-    /**\n-     * Represents the {@link Key} for the {@link ItemStackSnapshot item} in an\n+     * The {@link ItemStackSnapshot item} in an\n      * {@link Item}, {@link ItemFrame}, {@link Jukebox}, {@link Lectern} or\n      * {@link Potion}.\n      */\n     public static final Supplier<Key<Value<ItemStackSnapshot>>> ITEM_STACK_SNAPSHOT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ITEM_STACK_SNAPSHOT\");\n \n     /**\n-     * Represents the {@link Key} for the knockback strength applied by an\n-     * {@link ArrowEntity}.\n+     * The knockback strength applied by an {@link ArrowEntity}.\n      *\n      * <p>For the knockback provided by hits with a weapon according to the\n      * enchantment of the same name, see {@link #APPLIED_ENCHANTMENTS}.</p>\n      */\n     public static final Supplier<Key<BoundedValue<Double>>> KNOCKBACK_STRENGTH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"KNOCKBACK_STRENGTH\");\n \n     /**\n-     * Represents the {@link Key} for the known {@link PandaGene gene} of a {@link Panda}.\n+     * The known {@link PandaGene gene} of a {@link Panda}.\n      */\n     public static final Supplier<Key<Value<PandaGene>>> KNOWN_GENE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"KNOWN_GENE\");\n \n     /**\n-     * Represents the {@link Key} for the last attacking {@link Entity} of a {@link Living}.\n+     * The last attacking {@link Entity} of a {@link Living}.\n      */\n     public static final Supplier<Key<Value<Entity>>> LAST_ATTACKER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LAST_ATTACKER\");\n \n     /**\n-     * Represents the {@link Key} for the output yielded by the last command of\n-     * a {@link CommandBlock}.\n+     * The output yielded by the last command of a {@link CommandBlock} or {@link CommandBlockMinecart}.\n      */\n     public static final Supplier<Key<Value<Text>>> LAST_COMMAND_OUTPUT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LAST_COMMAND_OUTPUT\");\n \n     /**\n-     * Represents the {@link Key} for the last damage received by a {@link Living}.\n+     * The last damage a {@link Living} received.\n      */\n     public static final Supplier<Key<Value<Double>>> LAST_DAMAGE_RECEIVED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LAST_DAMAGE_RECEIVED\");\n \n     /**\n-     * Represents the {@link Key} for the last time a {@link User} has been\n-     * playing on the server.\n+     * The last time a {@link User} has been playing on the server.\n      */\n     public static final Supplier<Key<Value<Instant>>> LAST_DATE_PLAYED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LAST_DATE_PLAYED\");\n \n     /**\n-     * Represents the {@link Key} for representing the \"layer\" value of\n-     * {@link BlockTypes#SNOW}, {@link BlockTypes#CAKE} and other possible layered blocks.\n+     * The amount of layers a {@link BlockState} has.\n+     * e.g. {@link BlockTypes#SNOW}, {@link BlockTypes#CAKE}\n      */\n     public static final Supplier<Key<BoundedValue<Integer>>> LAYER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LAYER\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Patroller} is the leader.\n+     * Whether a {@link Patroller} is the leader.\n      */\n     public static final Supplier<Key<Value<Boolean>>> LEADER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LEADER\");\n \n     /**\n-     * Represents the {@link Key} for the leashed {@link Entity} of a {@link LeashKnot}.\n+     * The leashed {@link Entity} of a {@link LeashKnot}.\n      *\n      * <p>Usually, a {@link LeashKnot} will always exist so long as there is\n      * a leashed {@link Entity} attached. If the leash is broken, the leash\n      * hitch is removed.</p>\n+     * TODO merge into {@link #TARGET_ENTITY}?\n      */\n     public static final Supplier<Key<Value<Entity>>> LEASHED_ENTITY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LEASHED_ENTITY\");\n \n     /**\n-     * Represents the {@link Key} for the rotation of an {@link Entity}'s left\n-     * arm.\n+     * The rotation of an {@link ArmorStand}'s left arm.\n      */\n     public static final Supplier<Key<Value<Vector3d>>> LEFT_ARM_ROTATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LEFT_ARM_ROTATION\");\n \n     /**\n-     * Represents the {@link Key} for the rotation of an {@link Entity}'s left\n-     * leg.\n+     * The rotation of an {@link ArmorStand}'s left leg.\n      */\n     public static final Supplier<Key<Value<Vector3d>>> LEFT_LEG_ROTATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LEFT_LEG_ROTATION\");\n \n     /**\n-     * Represents the {@link Key} of the amount of light that emitted by a light source,\n-     * usually blocks.\n+     * The amount of ticks till a {@link Vex} starts\n+     * taking damage due to living too long.\n+     *\n+     * <p>When this value hits 0 or lower, the Vex will receive damage and\n+     * then the value will set back to 20 until the Vex dies.</p>\n+     *\n+     * <p>If the Vex was summoned by a player, this value will be pegged at 0\n+     * and the Vex will not take any damage.</p>\n+     */\n+    public static final Supplier<Key<Value<Integer>>> LIFE_TICKS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LIFE_TICKS\");\n+\n+    /**\n+     * The amount of light that emitted by a {@link BlockState}.\n      */\n     public static final Supplier<Key<Value<Integer>>> LIGHT_EMISSION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LIGHT_EMISSION\");\n \n     /**\n-     * Represents the {@link Key} for the state that something is \"lit\",\n-     * for example a {@link BlockTypes#FURNACE}, {@link BlockTypes#CAMPFIRE}\n+     * Whether a {@link BlockState} is lit.\n+     * e.g. {@link BlockTypes#FURNACE}, {@link BlockTypes#CAMPFIRE}\n      * or {@link BlockTypes#REDSTONE_TORCH}.\n      */\n     public static final Supplier<Key<Value<Boolean>>> LIT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LIT\");\n \n     /**\n-     * Represents the {@link Key} for a {@link Llama}s carrying strength. The higher the strength,\n-     * the more items it can carry (effectively the size of inventory).\n+     * A {@link Llama}'s {@link LlamaType}.\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> LLAMA_STRENGTH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LLAMA_STRENGTH\");\n+    public static final Supplier<Key<Value<LlamaType>>> LLAMA_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LLAMA_TYPE\");\n \n     /**\n-     * Represents the {@link Key} for a {@link Llama}'s {@link LlamaType}.\n+     * The token used to lock a {@link CarrierBlockEntity}. Or the token on an {@link ItemStack} to unlock it.\n      */\n-    public static final Supplier<Key<Value<LlamaType>>> LLAMA_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LLAMA_TYPE\");\n+    public static final Supplier<Key<Value<String>>> LOCK_TOKEN = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LOCK_TOKEN\");\n \n     /**\n-     * Represents the {@link Key} for the token used to lock a\n-     * {@link CarrierBlockEntity}.\n+     * The displayed description (\"lore\") text of an {@link ItemStack}.\n+     *\n+     * <p>The lore text is usually displayed when the player hovers his cursor\n+     * over the stack. For the contents of a book see {@link #PAGES}\n+     * instead.</p>\n      */\n-    public static final Supplier<Key<Value<String>>> LOCK_TOKEN = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LOCK_TOKEN\");\n+    public static final Supplier<Key<ListValue<Text>>> LORE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LORE\");\n \n     /**\n-     * Represents the {@link Key} for the matter\n-     * state. Usually of a block.\n+     * The matter state of a {@link BlockState}\n      */\n     public static final Supplier<Key<Value<MatterState>>> MATTER_STATE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MATTER_STATE\");\n \n     /**\n-     * Represents the {@link Key} for the maximum air supply a {@link Living}\n-     * may have.\n+     * The maximum amount of ticks between two\n+     * batches of entities spawned by a {@link MobSpawner}.\n+     */\n+    public static final Supplier<Key<BoundedValue<Integer>>> MAXIMUM_DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAXIMUM_DELAY\");", "originalCommit": "b8751271af7a7d06b8bd48adc136638397cf7513", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMjk2NQ==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r408712965", "bodyText": "MAX_NEARBY_ENTITIES\n(MAXIMUM -> MAX) for consistency with other keys.", "author": "Cybermaxke", "createdAt": "2020-04-15T09:40:37Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -1563,229 +1435,264 @@\n     public static final Supplier<Key<Value<Boolean>>> IS_SLEEPING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SLEEPING\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Player Player's} sleeping status is ignored when checking whether to\n+     * Whether a {@link Player Player's} sleeping status is ignored when checking whether to\n      * skip the night due to players sleeping. The time in a world will be\n      * advanced to day if all players in it either are sleeping or are set to ignore.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SLEEPING_IGNORED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SLEEPING_IGNORED\");\n \n     /**\n-     * Represents the {@link Key} for whether an {@link Entity} is sneaking.\n+     * Whether an {@link ArmorStand} is small.\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_SMALL = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SMALL\");\n+\n+    /**\n+     * Whether an {@link Entity} is sneaking.\n      *\n      * <p>Sneaking entities generally move slower and do not make walking\n      * sounds.</p>\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SNEAKING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SNEAKING\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Panda} is sneezing.\n+     * Whether a {@link Panda} is sneezing.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SNEEZING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SNEEZING\");\n \n     /**\n-     * Represents the {@link Key} for whether an {@link Entity} is sprinting.\n+     * Whether a {@link BlockState} is solid.\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_SOLID = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SOLID\");\n+\n+    /**\n+     * Whether an {@link Entity} is sprinting.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SPRINTING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SPRINTING\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link PolarBear} is currently standing.\n+     * Whether a {@link PolarBear} is currently standing.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_STANDING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_STANDING\");\n \n     /**\n-     * Represents the {@link Key} for whether an entity is stunned.\n+     * Whether a {@link Ravager} is stunned.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_STUNNED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_STUNNED\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link TameableAnimal} is currently tamed\n+     * Whether a {@link BlockState} is a surrogate block for a block that was provided in an environment\n+     * (almost always modded), that the block type provider no longer exists.\n+     * If true this may indicate that the surrogate block functions differently than the original block.\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_SURROGATE_BLOCK = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SURROGATE_BLOCK\");\n+\n+    /**\n+     * Whether a {@link TameableAnimal} is currently tamed\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_TAMED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_TAMED\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Trader} is currently trading with a {@link Player}.\n+     * Whether a {@link Trader} is currently trading with a {@link Player}.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_TRADING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_TRADING\");\n \n     /**\n-     * Represents the {@link Key} for if an {@link Ocelot} is currently trusting of {@link Player}s.\n+     * Whether a {@link Turtle} is currently traveling.\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_TRAVELING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_TRAVELING\");\n+\n+    /**\n+     * Whether an {@link Ocelot} is currently trusting of {@link Player}s.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_TRUSTING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_TRUSTING\");\n \n     /**\n-     * Represents the {@link Key} for whether an {@link ItemStack} or {@link BlockState} is unbreakable.\n+     * Whether an {@link ItemStack} or {@link BlockState} is unbreakable.\n      *\n-     * <p>Setting this to {@code  true} will prevent the item stack's\n+     * <p>Setting this to {@code true} will prevent the item stack's\n      * {@link #ITEM_DURABILITY} from changing.</p>\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_UNBREAKABLE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_UNBREAKABLE\");\n \n     /**\n-     * Represents the {@link Key} for whether a {@link Panda} is unhappy.\n+     * Whether a {@link Panda} is unhappy.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_UNHAPPY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_UNHAPPY\");\n \n     /**\n-     * Represents the {@link Key} for whether a {@link Wolf}, a\n-     * {@link BlockState} of {@link BlockTypes#SPONGE} or an {@link ItemStack}\n-     * of {@link ItemTypes#SPONGE} is wet.\n+     * Whether an {@link Entity} like {@link Wolf} or a\n+     * {@link BlockState} of {@link BlockTypes#SPONGE} is wet.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_WET = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_WET\");\n \n     /**\n-     * Represents the {@link Key} for the durability of an {@link ItemStack}.\n+     * The durability of an {@link ItemStack}.\n      */\n     public static final Supplier<Key<BoundedValue<Integer>>> ITEM_DURABILITY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ITEM_DURABILITY\");\n \n     /**\n-     * Represents the {@link Key} for the displayed description (\"lore\") text\n-     * of an {@link ItemStack}.\n-     *\n-     * <p>The lore text is usually displayed when the player hovers his cursor\n-     * over the stack. For the contents of a book see {@link #BOOK_PAGES}\n-     * instead.</p>\n-     */\n-    public static final Supplier<Key<ListValue<Text>>> ITEM_LORE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ITEM_LORE\");\n-\n-    /**\n-     * Represents the {@link Key} for the {@link ItemStackSnapshot item} in an\n+     * The {@link ItemStackSnapshot item} in an\n      * {@link Item}, {@link ItemFrame}, {@link Jukebox}, {@link Lectern} or\n      * {@link Potion}.\n      */\n     public static final Supplier<Key<Value<ItemStackSnapshot>>> ITEM_STACK_SNAPSHOT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ITEM_STACK_SNAPSHOT\");\n \n     /**\n-     * Represents the {@link Key} for the knockback strength applied by an\n-     * {@link ArrowEntity}.\n+     * The knockback strength applied by an {@link ArrowEntity}.\n      *\n      * <p>For the knockback provided by hits with a weapon according to the\n      * enchantment of the same name, see {@link #APPLIED_ENCHANTMENTS}.</p>\n      */\n     public static final Supplier<Key<BoundedValue<Double>>> KNOCKBACK_STRENGTH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"KNOCKBACK_STRENGTH\");\n \n     /**\n-     * Represents the {@link Key} for the known {@link PandaGene gene} of a {@link Panda}.\n+     * The known {@link PandaGene gene} of a {@link Panda}.\n      */\n     public static final Supplier<Key<Value<PandaGene>>> KNOWN_GENE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"KNOWN_GENE\");\n \n     /**\n-     * Represents the {@link Key} for the last attacking {@link Entity} of a {@link Living}.\n+     * The last attacking {@link Entity} of a {@link Living}.\n      */\n     public static final Supplier<Key<Value<Entity>>> LAST_ATTACKER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LAST_ATTACKER\");\n \n     /**\n-     * Represents the {@link Key} for the output yielded by the last command of\n-     * a {@link CommandBlock}.\n+     * The output yielded by the last command of a {@link CommandBlock} or {@link CommandBlockMinecart}.\n      */\n     public static final Supplier<Key<Value<Text>>> LAST_COMMAND_OUTPUT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LAST_COMMAND_OUTPUT\");\n \n     /**\n-     * Represents the {@link Key} for the last damage received by a {@link Living}.\n+     * The last damage a {@link Living} received.\n      */\n     public static final Supplier<Key<Value<Double>>> LAST_DAMAGE_RECEIVED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LAST_DAMAGE_RECEIVED\");\n \n     /**\n-     * Represents the {@link Key} for the last time a {@link User} has been\n-     * playing on the server.\n+     * The last time a {@link User} has been playing on the server.\n      */\n     public static final Supplier<Key<Value<Instant>>> LAST_DATE_PLAYED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LAST_DATE_PLAYED\");\n \n     /**\n-     * Represents the {@link Key} for representing the \"layer\" value of\n-     * {@link BlockTypes#SNOW}, {@link BlockTypes#CAKE} and other possible layered blocks.\n+     * The amount of layers a {@link BlockState} has.\n+     * e.g. {@link BlockTypes#SNOW}, {@link BlockTypes#CAKE}\n      */\n     public static final Supplier<Key<BoundedValue<Integer>>> LAYER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LAYER\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Patroller} is the leader.\n+     * Whether a {@link Patroller} is the leader.\n      */\n     public static final Supplier<Key<Value<Boolean>>> LEADER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LEADER\");\n \n     /**\n-     * Represents the {@link Key} for the leashed {@link Entity} of a {@link LeashKnot}.\n+     * The leashed {@link Entity} of a {@link LeashKnot}.\n      *\n      * <p>Usually, a {@link LeashKnot} will always exist so long as there is\n      * a leashed {@link Entity} attached. If the leash is broken, the leash\n      * hitch is removed.</p>\n+     * TODO merge into {@link #TARGET_ENTITY}?\n      */\n     public static final Supplier<Key<Value<Entity>>> LEASHED_ENTITY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LEASHED_ENTITY\");\n \n     /**\n-     * Represents the {@link Key} for the rotation of an {@link Entity}'s left\n-     * arm.\n+     * The rotation of an {@link ArmorStand}'s left arm.\n      */\n     public static final Supplier<Key<Value<Vector3d>>> LEFT_ARM_ROTATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LEFT_ARM_ROTATION\");\n \n     /**\n-     * Represents the {@link Key} for the rotation of an {@link Entity}'s left\n-     * leg.\n+     * The rotation of an {@link ArmorStand}'s left leg.\n      */\n     public static final Supplier<Key<Value<Vector3d>>> LEFT_LEG_ROTATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LEFT_LEG_ROTATION\");\n \n     /**\n-     * Represents the {@link Key} of the amount of light that emitted by a light source,\n-     * usually blocks.\n+     * The amount of ticks till a {@link Vex} starts\n+     * taking damage due to living too long.\n+     *\n+     * <p>When this value hits 0 or lower, the Vex will receive damage and\n+     * then the value will set back to 20 until the Vex dies.</p>\n+     *\n+     * <p>If the Vex was summoned by a player, this value will be pegged at 0\n+     * and the Vex will not take any damage.</p>\n+     */\n+    public static final Supplier<Key<Value<Integer>>> LIFE_TICKS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LIFE_TICKS\");\n+\n+    /**\n+     * The amount of light that emitted by a {@link BlockState}.\n      */\n     public static final Supplier<Key<Value<Integer>>> LIGHT_EMISSION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LIGHT_EMISSION\");\n \n     /**\n-     * Represents the {@link Key} for the state that something is \"lit\",\n-     * for example a {@link BlockTypes#FURNACE}, {@link BlockTypes#CAMPFIRE}\n+     * Whether a {@link BlockState} is lit.\n+     * e.g. {@link BlockTypes#FURNACE}, {@link BlockTypes#CAMPFIRE}\n      * or {@link BlockTypes#REDSTONE_TORCH}.\n      */\n     public static final Supplier<Key<Value<Boolean>>> LIT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LIT\");\n \n     /**\n-     * Represents the {@link Key} for a {@link Llama}s carrying strength. The higher the strength,\n-     * the more items it can carry (effectively the size of inventory).\n+     * A {@link Llama}'s {@link LlamaType}.\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> LLAMA_STRENGTH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LLAMA_STRENGTH\");\n+    public static final Supplier<Key<Value<LlamaType>>> LLAMA_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LLAMA_TYPE\");\n \n     /**\n-     * Represents the {@link Key} for a {@link Llama}'s {@link LlamaType}.\n+     * The token used to lock a {@link CarrierBlockEntity}. Or the token on an {@link ItemStack} to unlock it.\n      */\n-    public static final Supplier<Key<Value<LlamaType>>> LLAMA_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LLAMA_TYPE\");\n+    public static final Supplier<Key<Value<String>>> LOCK_TOKEN = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LOCK_TOKEN\");\n \n     /**\n-     * Represents the {@link Key} for the token used to lock a\n-     * {@link CarrierBlockEntity}.\n+     * The displayed description (\"lore\") text of an {@link ItemStack}.\n+     *\n+     * <p>The lore text is usually displayed when the player hovers his cursor\n+     * over the stack. For the contents of a book see {@link #PAGES}\n+     * instead.</p>\n      */\n-    public static final Supplier<Key<Value<String>>> LOCK_TOKEN = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LOCK_TOKEN\");\n+    public static final Supplier<Key<ListValue<Text>>> LORE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"LORE\");\n \n     /**\n-     * Represents the {@link Key} for the matter\n-     * state. Usually of a block.\n+     * The matter state of a {@link BlockState}\n      */\n     public static final Supplier<Key<Value<MatterState>>> MATTER_STATE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MATTER_STATE\");\n \n     /**\n-     * Represents the {@link Key} for the maximum air supply a {@link Living}\n-     * may have.\n+     * The maximum amount of ticks between two\n+     * batches of entities spawned by a {@link MobSpawner}.\n+     */\n+    public static final Supplier<Key<BoundedValue<Integer>>> MAXIMUM_DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAXIMUM_DELAY\");\n+\n+    /**\n+     * The maximum number of entities around a {@link MobSpawner}.\n+     * A spawner will not spawn entities if there are more\n+     * entities around than this value permits.\n+     */\n+    public static final Supplier<Key<BoundedValue<Integer>>> MAXIMUM_NEARBY_ENTITIES = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAXIMUM_NEARBY_ENTITIES\");", "originalCommit": "b8751271af7a7d06b8bd48adc136638397cf7513", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMzU5MA==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r408713590", "bodyText": "Should stay BANNER_PATTERN_LAYERS", "author": "Cybermaxke", "createdAt": "2020-04-15T09:41:41Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -1794,169 +1701,221 @@\n     public static final Supplier<Key<BoundedValue<Double>>> MAX_HEALTH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAX_HEALTH\");\n \n     /**\n-     * Represents the maximum stack size of slots in an inventory.\n+     * The max speed of a {@link Boat}. In vanilla, this is 0.4\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> MAX_STACK_SIZE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAX_STACK_SIZE\");\n+    public static final Supplier<Key<BoundedValue<Double>>> MAX_SPEED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAX_SPEED\");\n \n     /**\n-     * Represents the {@link Key} for the modifier to {@link Keys#VELOCITY} of a {@link Minecart} while airborne.\n+     * The maximum stack size of slots in an inventory. For most vanilla inventories this is 64.\n      */\n-    public static final Supplier<Key<Value<Vector3d>>> MINECART_AIRBORNE_VELOCITY_MODIFIER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_AIRBORNE_VELOCITY_MODIFIER\");\n-\n-    /**\n-     * Represents the {@link Key} for representing a block's offset when inside\n-     * a {@link MinecartEntity}.\n-     */\n-    public static final Supplier<Key<Value<Integer>>> MINECART_BLOCK_OFFSET = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_BLOCK_OFFSET\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> MAX_STACK_SIZE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAX_STACK_SIZE\");\n \n     /**\n-     * Represents the {@link Key} for the modifier to {@link Keys#VELOCITY} of a {@link Minecart} while derailed.\n+     * The minimum amount of ticks between two\n+     * batches of entities spawned by a {@link MobSpawner}.\n      */\n-    public static final Supplier<Key<Value<Vector3d>>> MINECART_DERAILED_VELOCITY_MODIFIER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_DERAILED_VELOCITY_MODIFIER\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> MINIMUM_DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINIMUM_DELAY\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Minecart} is on it's rail\n+     * The moisture value of a {@link BlockTypes#FARMLAND} {@link BlockState}.\n      */\n-    public static final Supplier<Key<Value<Boolean>>> MINECART_IS_ON_RAIL = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_IS_ON_RAIL\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> MOISTURE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MOISTURE\");\n \n     /**\n-     * Represents the {@link Key} for the potential max speed of a {@link Minecart}.\n+     * The type of a {@link Mooshroom}.\n      */\n-    public static final Supplier<Key<BoundedValue<Double>>> MINECART_POTENTIAL_MAX_SPEED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_POTENTIAL_MAX_SPEED\");\n+    public static final Supplier<Key<Value<MooshroomType>>> MOOSHROOM_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MOOSHROOM_TYPE\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Minecart} slows down when it has now {@link Keys#PASSENGERS}.\n+     * The type of {@link MusicDisc} an {@link ItemStack} holds.\n      */\n-    public static final Supplier<Key<Value<Boolean>>> MINECART_SLOWS_UNOCCUPIED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_SLOW_WHEN_EMPTY\");\n+    public static final Supplier<Key<Value<MusicDisc>>> MUSIC_DISK = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MUSIC_DISK\");\n \n     /**\n-     * Represents the {@link Key} for the swiftness of a {@link Minecart}.\n+     * The next entity that will be spawned by a {@link MobSpawner}.\n+     *\n+     * <p>Normally the entities to be spawned are determined by a random value\n+     * applied to the {@link #SPAWNABLE_ENTITIES} weighted collection. If this\n+     * value exists, it will override the random spawn with a definite one.</p>\n      */\n-    public static final Supplier<Key<BoundedValue<Double>>> MINECART_SWIFTNESS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_SWIFTNESS\");\n+    public static final Supplier<Key<Value<WeightedSerializableObject<EntityArchetype>>>> NEXT_ENTITY_TO_SPAWN = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NEXT_ENTITY_TO_SPAWN\");\n \n     /**\n-     * Represents the {@link Key} for representing the \"moisture\" state of {@link BlockTypes#FARMLAND}.\n+     * The pitch of a {@link BlockTypes#NOTE_BLOCK} {@link BlockState}.\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> MOISTURE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MOISTURE\");\n+    public static final Supplier<Key<Value<NotePitch>>> NOTE_PITCH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NOTE_PITCH\");\n \n     /**\n-     * Represents the {@link Key} for the type of a {@link Mooshroom}.\n+     * The notifier, usually of an {@link Entity}. It is up to the implementation to define.\n      */\n-    public static final Supplier<Key<Value<MooshroomType>>> MOOSHROOM_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MOOSHROOM_TYPE\");\n+    public static final Supplier<Key<Value<UUID>>> NOTIFIER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NOTIFIER\");\n \n     /**\n-     * Represents the {@link Key} for the pitch of a {@link BlockTypes#NOTE_BLOCK}.\n+     * The deceleration a {@link Boat} while it has {@link Keys#PASSENGERS}.\n      */\n-    public static final Supplier<Key<Value<NotePitch>>> NOTE_PITCH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NOTE_PITCH\");\n+    public static final Supplier<Key<BoundedValue<Double>>> OCCUPIED_DECELERATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"OCCUPIED_DECELERATION\");\n \n     /**\n-     * Represents the {@link Key} for the notifier, usually of an {@link Entity}. It is up to the implementation to define.\n+     * Whether an {@link Entity} is currently considered to be on the ground.\n      */\n-    public static final Supplier<Key<Value<UUID>>> NOTIFIER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NOTIFIER\");\n+    public static final Supplier<Key<Value<Boolean>>> ON_GROUND = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ON_GROUND\");\n \n     /**\n-     * Represents the {@link Key} for if an {@link Entity} is currently considered to be on the ground or not.\n+     * The content of a {@link ItemTypes#WRITTEN_BOOK} {@link ItemStack}.\n+     *\n+     * <p>Use {@link Keys#PLAIN_PAGES} if you wish to inspect the contents\n+     * of a {@link ItemTypes#WRITABLE_BOOK}.</p>\n      */\n-    public static final Supplier<Key<Value<Boolean>>> ON_GROUND = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ON_GROUND\");\n+    public static final Supplier<Key<ListValue<Text>>> PAGES = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PAGES\");\n \n     /**\n-     * Represents the {@link ParrotType type} of a {@link Parrot}.\n+     * The {@link ParrotType type} of a {@link Parrot}.\n      */\n     public static final Supplier<Key<Value<ParrotType>>> PARROT_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PARROT_TYPE\");\n \n     /**\n-     * Represents the {@link Key} for the amount of ticks a {@link FurnaceBlockEntity} has\n-     * already been burning with the current fuel item.\n+     * The particle type of an {@link AreaEffectCloud} created by a lingering potion.\n      *\n-     * <p>Once this value reaches the one of {@link #MAX_BURN_TIME}, the\n-     * furnace will require more fuel in order to keep burning.</p>\n+     * <p>Only a few {@link ParticleOption}s will be usable for this\n+     * effect for specific {@link ParticleType}s and not every\n+     * {@link ParticleType} will be applicable.</p>\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> PASSED_BURN_TIME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PASSED_BURN_TIME\");\n+    public static final Supplier<Key<Value<ParticleEffect>>> PARTICLE_EFFECT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PARTICLE_EFFECT\");\n \n     /**\n-     * Represents the {@link Key} for the amount of ticks a {@link FurnaceBlockEntity} has\n+     * The amount of ticks a {@link FurnaceBlockEntity} has\n      * been cooking the current item for.\n      *\n-     * <p>Once this value reaches the one of {@link #MAX_COOK_TIME}, the\n+     * <p>Once this value reaches the {@link #MAX_COOK_TIME}, the\n      * item will be finished cooking.</p>\n      */\n     public static final Supplier<Key<BoundedValue<Integer>>> PASSED_COOK_TIME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PASSED_COOK_TIME\");\n \n     /**\n-     * Represents the {@link Key} for the entities that act as passengers for\n-     * an {@link Entity}.\n+     * The entities that act as passengers for an {@link Entity}.\n      *\n      * <p>For example, a {@link Player} riding on a {@link Horse} or a\n      * {@link Pig} would be considered its passenger.</p>\n      */\n     public static final Supplier<Key<ListValue<Entity>>> PASSENGERS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PASSENGERS\");\n \n     /**\n-     * Represents the {@link Key} for the {@link PhantomPhase phase} of a {@link Phantom}.\n+     * A {@link TropicalFish}'s pattern color.\n      */\n-    public static final Supplier<Key<Value<PhantomPhase>>> PHANTOM_PHASE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PHANTOM_PHASE\");\n+    public static final Supplier<Key<Value<DyeColor>>> PATTERN_COLOR = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PATTERN_COLOR\");\n \n     /**\n-     * Represents the {@link Key} of the size of a {@link Phantom}. In vanilla, this ranges between 0 and 64.\n+     * The {@link BannerPatternLayer}s of a {@link Banner}.\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> PHANTOM_SIZE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class,\"PHANTOM_SIZE\");\n+    public static final Supplier<Key<ListValue<BannerPatternLayer>>> PATTERN_LAYERS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PATTERN_LAYERS\");", "originalCommit": "b8751271af7a7d06b8bd48adc136638397cf7513", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMzc3MA==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r408713770", "bodyText": "IS_PLACING_DISABLED", "author": "Cybermaxke", "createdAt": "2020-04-15T09:41:58Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -1794,169 +1701,221 @@\n     public static final Supplier<Key<BoundedValue<Double>>> MAX_HEALTH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAX_HEALTH\");\n \n     /**\n-     * Represents the maximum stack size of slots in an inventory.\n+     * The max speed of a {@link Boat}. In vanilla, this is 0.4\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> MAX_STACK_SIZE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAX_STACK_SIZE\");\n+    public static final Supplier<Key<BoundedValue<Double>>> MAX_SPEED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAX_SPEED\");\n \n     /**\n-     * Represents the {@link Key} for the modifier to {@link Keys#VELOCITY} of a {@link Minecart} while airborne.\n+     * The maximum stack size of slots in an inventory. For most vanilla inventories this is 64.\n      */\n-    public static final Supplier<Key<Value<Vector3d>>> MINECART_AIRBORNE_VELOCITY_MODIFIER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_AIRBORNE_VELOCITY_MODIFIER\");\n-\n-    /**\n-     * Represents the {@link Key} for representing a block's offset when inside\n-     * a {@link MinecartEntity}.\n-     */\n-    public static final Supplier<Key<Value<Integer>>> MINECART_BLOCK_OFFSET = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_BLOCK_OFFSET\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> MAX_STACK_SIZE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAX_STACK_SIZE\");\n \n     /**\n-     * Represents the {@link Key} for the modifier to {@link Keys#VELOCITY} of a {@link Minecart} while derailed.\n+     * The minimum amount of ticks between two\n+     * batches of entities spawned by a {@link MobSpawner}.\n      */\n-    public static final Supplier<Key<Value<Vector3d>>> MINECART_DERAILED_VELOCITY_MODIFIER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_DERAILED_VELOCITY_MODIFIER\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> MINIMUM_DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINIMUM_DELAY\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Minecart} is on it's rail\n+     * The moisture value of a {@link BlockTypes#FARMLAND} {@link BlockState}.\n      */\n-    public static final Supplier<Key<Value<Boolean>>> MINECART_IS_ON_RAIL = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_IS_ON_RAIL\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> MOISTURE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MOISTURE\");\n \n     /**\n-     * Represents the {@link Key} for the potential max speed of a {@link Minecart}.\n+     * The type of a {@link Mooshroom}.\n      */\n-    public static final Supplier<Key<BoundedValue<Double>>> MINECART_POTENTIAL_MAX_SPEED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_POTENTIAL_MAX_SPEED\");\n+    public static final Supplier<Key<Value<MooshroomType>>> MOOSHROOM_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MOOSHROOM_TYPE\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Minecart} slows down when it has now {@link Keys#PASSENGERS}.\n+     * The type of {@link MusicDisc} an {@link ItemStack} holds.\n      */\n-    public static final Supplier<Key<Value<Boolean>>> MINECART_SLOWS_UNOCCUPIED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_SLOW_WHEN_EMPTY\");\n+    public static final Supplier<Key<Value<MusicDisc>>> MUSIC_DISK = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MUSIC_DISK\");\n \n     /**\n-     * Represents the {@link Key} for the swiftness of a {@link Minecart}.\n+     * The next entity that will be spawned by a {@link MobSpawner}.\n+     *\n+     * <p>Normally the entities to be spawned are determined by a random value\n+     * applied to the {@link #SPAWNABLE_ENTITIES} weighted collection. If this\n+     * value exists, it will override the random spawn with a definite one.</p>\n      */\n-    public static final Supplier<Key<BoundedValue<Double>>> MINECART_SWIFTNESS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_SWIFTNESS\");\n+    public static final Supplier<Key<Value<WeightedSerializableObject<EntityArchetype>>>> NEXT_ENTITY_TO_SPAWN = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NEXT_ENTITY_TO_SPAWN\");\n \n     /**\n-     * Represents the {@link Key} for representing the \"moisture\" state of {@link BlockTypes#FARMLAND}.\n+     * The pitch of a {@link BlockTypes#NOTE_BLOCK} {@link BlockState}.\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> MOISTURE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MOISTURE\");\n+    public static final Supplier<Key<Value<NotePitch>>> NOTE_PITCH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NOTE_PITCH\");\n \n     /**\n-     * Represents the {@link Key} for the type of a {@link Mooshroom}.\n+     * The notifier, usually of an {@link Entity}. It is up to the implementation to define.\n      */\n-    public static final Supplier<Key<Value<MooshroomType>>> MOOSHROOM_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MOOSHROOM_TYPE\");\n+    public static final Supplier<Key<Value<UUID>>> NOTIFIER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NOTIFIER\");\n \n     /**\n-     * Represents the {@link Key} for the pitch of a {@link BlockTypes#NOTE_BLOCK}.\n+     * The deceleration a {@link Boat} while it has {@link Keys#PASSENGERS}.\n      */\n-    public static final Supplier<Key<Value<NotePitch>>> NOTE_PITCH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NOTE_PITCH\");\n+    public static final Supplier<Key<BoundedValue<Double>>> OCCUPIED_DECELERATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"OCCUPIED_DECELERATION\");\n \n     /**\n-     * Represents the {@link Key} for the notifier, usually of an {@link Entity}. It is up to the implementation to define.\n+     * Whether an {@link Entity} is currently considered to be on the ground.\n      */\n-    public static final Supplier<Key<Value<UUID>>> NOTIFIER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NOTIFIER\");\n+    public static final Supplier<Key<Value<Boolean>>> ON_GROUND = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ON_GROUND\");\n \n     /**\n-     * Represents the {@link Key} for if an {@link Entity} is currently considered to be on the ground or not.\n+     * The content of a {@link ItemTypes#WRITTEN_BOOK} {@link ItemStack}.\n+     *\n+     * <p>Use {@link Keys#PLAIN_PAGES} if you wish to inspect the contents\n+     * of a {@link ItemTypes#WRITABLE_BOOK}.</p>\n      */\n-    public static final Supplier<Key<Value<Boolean>>> ON_GROUND = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ON_GROUND\");\n+    public static final Supplier<Key<ListValue<Text>>> PAGES = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PAGES\");\n \n     /**\n-     * Represents the {@link ParrotType type} of a {@link Parrot}.\n+     * The {@link ParrotType type} of a {@link Parrot}.\n      */\n     public static final Supplier<Key<Value<ParrotType>>> PARROT_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PARROT_TYPE\");\n \n     /**\n-     * Represents the {@link Key} for the amount of ticks a {@link FurnaceBlockEntity} has\n-     * already been burning with the current fuel item.\n+     * The particle type of an {@link AreaEffectCloud} created by a lingering potion.\n      *\n-     * <p>Once this value reaches the one of {@link #MAX_BURN_TIME}, the\n-     * furnace will require more fuel in order to keep burning.</p>\n+     * <p>Only a few {@link ParticleOption}s will be usable for this\n+     * effect for specific {@link ParticleType}s and not every\n+     * {@link ParticleType} will be applicable.</p>\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> PASSED_BURN_TIME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PASSED_BURN_TIME\");\n+    public static final Supplier<Key<Value<ParticleEffect>>> PARTICLE_EFFECT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PARTICLE_EFFECT\");\n \n     /**\n-     * Represents the {@link Key} for the amount of ticks a {@link FurnaceBlockEntity} has\n+     * The amount of ticks a {@link FurnaceBlockEntity} has\n      * been cooking the current item for.\n      *\n-     * <p>Once this value reaches the one of {@link #MAX_COOK_TIME}, the\n+     * <p>Once this value reaches the {@link #MAX_COOK_TIME}, the\n      * item will be finished cooking.</p>\n      */\n     public static final Supplier<Key<BoundedValue<Integer>>> PASSED_COOK_TIME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PASSED_COOK_TIME\");\n \n     /**\n-     * Represents the {@link Key} for the entities that act as passengers for\n-     * an {@link Entity}.\n+     * The entities that act as passengers for an {@link Entity}.\n      *\n      * <p>For example, a {@link Player} riding on a {@link Horse} or a\n      * {@link Pig} would be considered its passenger.</p>\n      */\n     public static final Supplier<Key<ListValue<Entity>>> PASSENGERS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PASSENGERS\");\n \n     /**\n-     * Represents the {@link Key} for the {@link PhantomPhase phase} of a {@link Phantom}.\n+     * A {@link TropicalFish}'s pattern color.\n      */\n-    public static final Supplier<Key<Value<PhantomPhase>>> PHANTOM_PHASE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PHANTOM_PHASE\");\n+    public static final Supplier<Key<Value<DyeColor>>> PATTERN_COLOR = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PATTERN_COLOR\");\n \n     /**\n-     * Represents the {@link Key} of the size of a {@link Phantom}. In vanilla, this ranges between 0 and 64.\n+     * The {@link BannerPatternLayer}s of a {@link Banner}.\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> PHANTOM_SIZE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class,\"PHANTOM_SIZE\");\n+    public static final Supplier<Key<ListValue<BannerPatternLayer>>> PATTERN_LAYERS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PATTERN_LAYERS\");\n \n     /**\n-     * Represents the {@link Key} for representing the pickup delay\n-     * of an {@link Item}.\n+     * The {@link PhantomPhase phase} of a {@link Phantom}.\n+     */\n+    public static final Supplier<Key<Value<PhantomPhase>>> PHANTOM_PHASE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PHANTOM_PHASE\");\n+\n+    /**\n+     * The pickup delay (in ticks) of an {@link Item}.\n      */\n     public static final Supplier<Key<BoundedValue<Integer>>> PICKUP_DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PICKUP_DELAY\");\n \n     /**\n-     * Represents the {@link Key} for the \"pickup rule\" of an {@link ArrowEntity}.\n+     * The {@link PickupRule} of an {@link ArrowEntity}.\n      */\n     public static final Supplier<Key<Value<PickupRule>>> PICKUP_RULE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PICKUP_RULE\");\n \n     /**\n-     * Represents the {@link Key} for the piston type of an {@link Piston}.\n+     * The piston type of an {@link Piston}. TODO dataholder blockstate?\n      */\n     public static final Supplier<Key<Value<PistonType>>> PISTON_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PISTON_TYPE\");\n \n     /**\n-     * Represents the {@link Key} for which block types an {@link ItemStack}\n-     * may be placed on.\n+     * The block types an {@link ItemStack} may be placed on.\n      */\n     public static final Supplier<Key<SetValue<BlockType>>> PLACEABLE_BLOCK_TYPES = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PLACEABLE_BLOCK_TYPES\");\n \n     /**\n-     * Represents the {@link Key} for the content of a\n-     * {@link ItemTypes#WRITABLE_BOOK}.\n+     * Whether players are prevented from placing\n+     * items from an equipment slot on an {@link ArmorStand}\n+     */\n+    public static final Supplier<Key<SetValue<EquipmentType>>> PLACING_DISABLED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PLACING_DISABLED\");", "originalCommit": "b8751271af7a7d06b8bd48adc136638397cf7513", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNDA3Ng==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r408714076", "bodyText": "HAS_PORES_...", "author": "Cybermaxke", "createdAt": "2020-04-15T09:42:26Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -1794,169 +1701,221 @@\n     public static final Supplier<Key<BoundedValue<Double>>> MAX_HEALTH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAX_HEALTH\");\n \n     /**\n-     * Represents the maximum stack size of slots in an inventory.\n+     * The max speed of a {@link Boat}. In vanilla, this is 0.4\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> MAX_STACK_SIZE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAX_STACK_SIZE\");\n+    public static final Supplier<Key<BoundedValue<Double>>> MAX_SPEED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAX_SPEED\");\n \n     /**\n-     * Represents the {@link Key} for the modifier to {@link Keys#VELOCITY} of a {@link Minecart} while airborne.\n+     * The maximum stack size of slots in an inventory. For most vanilla inventories this is 64.\n      */\n-    public static final Supplier<Key<Value<Vector3d>>> MINECART_AIRBORNE_VELOCITY_MODIFIER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_AIRBORNE_VELOCITY_MODIFIER\");\n-\n-    /**\n-     * Represents the {@link Key} for representing a block's offset when inside\n-     * a {@link MinecartEntity}.\n-     */\n-    public static final Supplier<Key<Value<Integer>>> MINECART_BLOCK_OFFSET = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_BLOCK_OFFSET\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> MAX_STACK_SIZE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MAX_STACK_SIZE\");\n \n     /**\n-     * Represents the {@link Key} for the modifier to {@link Keys#VELOCITY} of a {@link Minecart} while derailed.\n+     * The minimum amount of ticks between two\n+     * batches of entities spawned by a {@link MobSpawner}.\n      */\n-    public static final Supplier<Key<Value<Vector3d>>> MINECART_DERAILED_VELOCITY_MODIFIER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_DERAILED_VELOCITY_MODIFIER\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> MINIMUM_DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINIMUM_DELAY\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Minecart} is on it's rail\n+     * The moisture value of a {@link BlockTypes#FARMLAND} {@link BlockState}.\n      */\n-    public static final Supplier<Key<Value<Boolean>>> MINECART_IS_ON_RAIL = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_IS_ON_RAIL\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> MOISTURE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MOISTURE\");\n \n     /**\n-     * Represents the {@link Key} for the potential max speed of a {@link Minecart}.\n+     * The type of a {@link Mooshroom}.\n      */\n-    public static final Supplier<Key<BoundedValue<Double>>> MINECART_POTENTIAL_MAX_SPEED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_POTENTIAL_MAX_SPEED\");\n+    public static final Supplier<Key<Value<MooshroomType>>> MOOSHROOM_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MOOSHROOM_TYPE\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Minecart} slows down when it has now {@link Keys#PASSENGERS}.\n+     * The type of {@link MusicDisc} an {@link ItemStack} holds.\n      */\n-    public static final Supplier<Key<Value<Boolean>>> MINECART_SLOWS_UNOCCUPIED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_SLOW_WHEN_EMPTY\");\n+    public static final Supplier<Key<Value<MusicDisc>>> MUSIC_DISK = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MUSIC_DISK\");\n \n     /**\n-     * Represents the {@link Key} for the swiftness of a {@link Minecart}.\n+     * The next entity that will be spawned by a {@link MobSpawner}.\n+     *\n+     * <p>Normally the entities to be spawned are determined by a random value\n+     * applied to the {@link #SPAWNABLE_ENTITIES} weighted collection. If this\n+     * value exists, it will override the random spawn with a definite one.</p>\n      */\n-    public static final Supplier<Key<BoundedValue<Double>>> MINECART_SWIFTNESS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MINECART_SWIFTNESS\");\n+    public static final Supplier<Key<Value<WeightedSerializableObject<EntityArchetype>>>> NEXT_ENTITY_TO_SPAWN = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NEXT_ENTITY_TO_SPAWN\");\n \n     /**\n-     * Represents the {@link Key} for representing the \"moisture\" state of {@link BlockTypes#FARMLAND}.\n+     * The pitch of a {@link BlockTypes#NOTE_BLOCK} {@link BlockState}.\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> MOISTURE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MOISTURE\");\n+    public static final Supplier<Key<Value<NotePitch>>> NOTE_PITCH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NOTE_PITCH\");\n \n     /**\n-     * Represents the {@link Key} for the type of a {@link Mooshroom}.\n+     * The notifier, usually of an {@link Entity}. It is up to the implementation to define.\n      */\n-    public static final Supplier<Key<Value<MooshroomType>>> MOOSHROOM_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"MOOSHROOM_TYPE\");\n+    public static final Supplier<Key<Value<UUID>>> NOTIFIER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NOTIFIER\");\n \n     /**\n-     * Represents the {@link Key} for the pitch of a {@link BlockTypes#NOTE_BLOCK}.\n+     * The deceleration a {@link Boat} while it has {@link Keys#PASSENGERS}.\n      */\n-    public static final Supplier<Key<Value<NotePitch>>> NOTE_PITCH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NOTE_PITCH\");\n+    public static final Supplier<Key<BoundedValue<Double>>> OCCUPIED_DECELERATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"OCCUPIED_DECELERATION\");\n \n     /**\n-     * Represents the {@link Key} for the notifier, usually of an {@link Entity}. It is up to the implementation to define.\n+     * Whether an {@link Entity} is currently considered to be on the ground.\n      */\n-    public static final Supplier<Key<Value<UUID>>> NOTIFIER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"NOTIFIER\");\n+    public static final Supplier<Key<Value<Boolean>>> ON_GROUND = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ON_GROUND\");\n \n     /**\n-     * Represents the {@link Key} for if an {@link Entity} is currently considered to be on the ground or not.\n+     * The content of a {@link ItemTypes#WRITTEN_BOOK} {@link ItemStack}.\n+     *\n+     * <p>Use {@link Keys#PLAIN_PAGES} if you wish to inspect the contents\n+     * of a {@link ItemTypes#WRITABLE_BOOK}.</p>\n      */\n-    public static final Supplier<Key<Value<Boolean>>> ON_GROUND = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ON_GROUND\");\n+    public static final Supplier<Key<ListValue<Text>>> PAGES = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PAGES\");\n \n     /**\n-     * Represents the {@link ParrotType type} of a {@link Parrot}.\n+     * The {@link ParrotType type} of a {@link Parrot}.\n      */\n     public static final Supplier<Key<Value<ParrotType>>> PARROT_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PARROT_TYPE\");\n \n     /**\n-     * Represents the {@link Key} for the amount of ticks a {@link FurnaceBlockEntity} has\n-     * already been burning with the current fuel item.\n+     * The particle type of an {@link AreaEffectCloud} created by a lingering potion.\n      *\n-     * <p>Once this value reaches the one of {@link #MAX_BURN_TIME}, the\n-     * furnace will require more fuel in order to keep burning.</p>\n+     * <p>Only a few {@link ParticleOption}s will be usable for this\n+     * effect for specific {@link ParticleType}s and not every\n+     * {@link ParticleType} will be applicable.</p>\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> PASSED_BURN_TIME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PASSED_BURN_TIME\");\n+    public static final Supplier<Key<Value<ParticleEffect>>> PARTICLE_EFFECT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PARTICLE_EFFECT\");\n \n     /**\n-     * Represents the {@link Key} for the amount of ticks a {@link FurnaceBlockEntity} has\n+     * The amount of ticks a {@link FurnaceBlockEntity} has\n      * been cooking the current item for.\n      *\n-     * <p>Once this value reaches the one of {@link #MAX_COOK_TIME}, the\n+     * <p>Once this value reaches the {@link #MAX_COOK_TIME}, the\n      * item will be finished cooking.</p>\n      */\n     public static final Supplier<Key<BoundedValue<Integer>>> PASSED_COOK_TIME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PASSED_COOK_TIME\");\n \n     /**\n-     * Represents the {@link Key} for the entities that act as passengers for\n-     * an {@link Entity}.\n+     * The entities that act as passengers for an {@link Entity}.\n      *\n      * <p>For example, a {@link Player} riding on a {@link Horse} or a\n      * {@link Pig} would be considered its passenger.</p>\n      */\n     public static final Supplier<Key<ListValue<Entity>>> PASSENGERS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PASSENGERS\");\n \n     /**\n-     * Represents the {@link Key} for the {@link PhantomPhase phase} of a {@link Phantom}.\n+     * A {@link TropicalFish}'s pattern color.\n      */\n-    public static final Supplier<Key<Value<PhantomPhase>>> PHANTOM_PHASE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PHANTOM_PHASE\");\n+    public static final Supplier<Key<Value<DyeColor>>> PATTERN_COLOR = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PATTERN_COLOR\");\n \n     /**\n-     * Represents the {@link Key} of the size of a {@link Phantom}. In vanilla, this ranges between 0 and 64.\n+     * The {@link BannerPatternLayer}s of a {@link Banner}.\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> PHANTOM_SIZE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class,\"PHANTOM_SIZE\");\n+    public static final Supplier<Key<ListValue<BannerPatternLayer>>> PATTERN_LAYERS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PATTERN_LAYERS\");\n \n     /**\n-     * Represents the {@link Key} for representing the pickup delay\n-     * of an {@link Item}.\n+     * The {@link PhantomPhase phase} of a {@link Phantom}.\n+     */\n+    public static final Supplier<Key<Value<PhantomPhase>>> PHANTOM_PHASE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PHANTOM_PHASE\");\n+\n+    /**\n+     * The pickup delay (in ticks) of an {@link Item}.\n      */\n     public static final Supplier<Key<BoundedValue<Integer>>> PICKUP_DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PICKUP_DELAY\");\n \n     /**\n-     * Represents the {@link Key} for the \"pickup rule\" of an {@link ArrowEntity}.\n+     * The {@link PickupRule} of an {@link ArrowEntity}.\n      */\n     public static final Supplier<Key<Value<PickupRule>>> PICKUP_RULE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PICKUP_RULE\");\n \n     /**\n-     * Represents the {@link Key} for the piston type of an {@link Piston}.\n+     * The piston type of an {@link Piston}. TODO dataholder blockstate?\n      */\n     public static final Supplier<Key<Value<PistonType>>> PISTON_TYPE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PISTON_TYPE\");\n \n     /**\n-     * Represents the {@link Key} for which block types an {@link ItemStack}\n-     * may be placed on.\n+     * The block types an {@link ItemStack} may be placed on.\n      */\n     public static final Supplier<Key<SetValue<BlockType>>> PLACEABLE_BLOCK_TYPES = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PLACEABLE_BLOCK_TYPES\");\n \n     /**\n-     * Represents the {@link Key} for the content of a\n-     * {@link ItemTypes#WRITABLE_BOOK}.\n+     * Whether players are prevented from placing\n+     * items from an equipment slot on an {@link ArmorStand}\n+     */\n+    public static final Supplier<Key<SetValue<EquipmentType>>> PLACING_DISABLED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PLACING_DISABLED\");\n+\n+    /**\n+     * The content of a {@link ItemTypes#WRITABLE_BOOK} {@link ItemStack}.\n      *\n-     * <p>Use {@link Keys#BOOK_PAGES} if you wish to get the contents of a\n+     * <p>Use {@link Keys#PAGES} if you wish to get the contents of a\n      * {@link ItemTypes#WRITTEN_BOOK}</p>\n      */\n-    public static final Supplier<Key<ListValue<String>>> PLAIN_BOOK_PAGES = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PLAIN_BOOK_PAGES\");\n+    public static final Supplier<Key<ListValue<String>>> PLAIN_PAGES = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PLAIN_PAGES\");\n \n     /**\n-     * Represents the plugin that created this inventory.\n+     * The plugin that created an {@link Inventory}\n      */\n     public static final Supplier<Key<Value<PluginContainer>>> PLUGIN = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PLUGIN\");\n \n     /**\n-     * Represents the {@link Key} for representing the {@link PortionType}\n-     * of a {@link BlockState}.\n+     * The pore sides of a {@link BlockTypes#BROWN_MUSHROOM_BLOCK} or\n+     * {@link BlockTypes#RED_MUSHROOM_BLOCK} {@link BlockState}.\n+     * See {@link #PORES_UP}, {@link #PORES_DOWN}, {@link #PORES_NORTH}, {@link #PORES_EAST}, {@link #PORES_SOUTH}, {@link #PORES_WEST}.\n+     */\n+    public static final Supplier<Key<SetValue<Direction>>> PORES = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PORES\");\n+\n+    /**\n+     * Whether a giant mushroom {@link BlockState} has pores on the {@link Direction#DOWN} direction. See {@link #PORES}.\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> PORES_DOWN = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"PORES_DOWN\");", "originalCommit": "b8751271af7a7d06b8bd48adc136638397cf7513", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNTc2Nw==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r408715767", "bodyText": "I wouldn't name it SIZE, since it will likely conflict with possible future keys. So maybe just SLIME_SIZE and PHANTOM_SIZE, but I'm not sure", "author": "Cybermaxke", "createdAt": "2020-04-15T09:45:12Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -2052,39 +2052,46 @@\n     public static final Supplier<Key<BoundedValue<Double>>> SATURATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SATURATION\");\n \n     /**\n-     * Represents the {@link Key} for the \"scale\" for the size of an\n-     * {@link Entity}.\n+     * The \"scale\" for the size of an {@link Entity}.\n+     *\n+     * <p>Together with {@link #BASE_SIZE} and {@link #HEIGHT} this defines the size of an {@link Entity}.</p>\n      */\n     public static final Supplier<Key<BoundedValue<Double>>> SCALE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SCALE\");\n \n     /**\n-     * Represents the {@link Key} for a {@link Fox fox's} second trusted {@link UUID}, usually a {@link Player}.\n+     * A {@link Beacon}'s secondary effect.\n      */\n-    public static final Supplier<Key<Value<UUID>>> SECOND_TRUSTED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SECOND_TRUSTED\");\n+    public static final Supplier<Key<Value<PotionEffectType>>> SECONDARY_EFFECT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SECONDARY_EFFECT\");\n \n     /**\n-     * Represents the {@link Key} for the shooter of a {@link Projectile}.\n+     * A {@link Fox fox's} second trusted {@link UUID}, usually a {@link Player}.\n      */\n-    public static final Supplier<Key<Value<ProjectileSource>>> SHOOTER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SHOOTER\");\n+    public static final Supplier<Key<Value<UUID>>> SECOND_TRUSTED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SECOND_TRUSTED\");\n \n     /**\n-     * Represents the {@link Key} for representing the \"should drop\" state\n-     * of a {@link BlockState}.\n+     * The shooter of a {@link Projectile}.\n      */\n-    public static final Supplier<Key<Value<Boolean>>> SHOULD_DROP = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SHOULD_DROP\");\n+    public static final Supplier<Key<Value<ProjectileSource>>> SHOOTER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SHOOTER\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link EnderCrystal} should show it's bottom bedrock platform.\n+     * Whether a {@link EnderCrystal} should show it's bottom bedrock platform.\n      */\n     public static final Supplier<Key<Value<Boolean>>> SHOW_BOTTOM = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SHOW_BOTTOM\");\n \n     /**\n-     * Represents the {@link Key} for the lines displayed on a {@link Sign}.\n+     * The lines displayed on a {@link Sign}.\n      */\n     public static final Supplier<Key<ListValue<Text>>> SIGN_LINES = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SIGN_LINES\");\n \n     /**\n-     * Represents the {@link Key} for the skin of a {@link Humanoid}.\n+     * The size of a {@link Slime}.\n+     * or\n+     * The size of a {@link Phantom}. In vanilla, this ranges between 0 and 64.\n+     */\n+    public static final Supplier<Key<BoundedValue<Integer>>> SIZE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SIZE\");", "originalCommit": "b8751271af7a7d06b8bd48adc136638397cf7513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE0OTY1Mg==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r415149652", "bodyText": "yeah I'm not sure either", "author": "Faithcaio", "createdAt": "2020-04-25T21:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNTc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNjEyOQ==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r408716129", "bodyText": "IS_SNOWY", "author": "Cybermaxke", "createdAt": "2020-04-15T09:45:48Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -2093,335 +2100,289 @@\n     public static final Supplier<Key<Value<ProfileProperty>>> SKIN = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SKIN\");\n \n     /**\n-     * Represents the {@link Key} for representing the {@link SlabPortion}\n-     * of a {@link BlockState}.\n-     */\n-    public static final Supplier<Key<Value<SlabPortion>>> SLAB_PORTION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SLAB_PORTION\");\n-\n-    /**\n-     * Represents the {@link Key} for the size of a {@link Slime}.\n-     */\n-    public static final Supplier<Key<BoundedValue<Integer>>> SLIME_SIZE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SLIME_SIZE\");\n-\n-    /**\n-     * Represents the index of a slot.\n-     */\n-    public static final Supplier<Key<BoundedValue<Integer>>> SLOT_INDEX = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SLOT_INDEX\");\n-\n-    /**\n-     * A property which represents the position of a slot within a grid. Bear in mind\n-     * that this property should be retrieved from the relevant parent, since a\n-     * slot may have multiple parent inventories.\n-     */\n-    public static final Supplier<Key<Value<Vector2i>>> SLOT_POSITION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SLOT_POSITION\");\n-\n-    /**\n-     * A property which represents a \"side\" for a particular slot, for use in querying \"sided inventories\".\n+     * The \"moisture\" state of a {@link Dolphin}.\n+     *\n+     * <p>\n+     *     Vanilla sets the dolphin's skin moisture to 2400 so long as the entity\n+     *     is in water, being rained on, or in a bubble column. If not, the dolphin\n+     *     will loose 1 moisture per tick. Once this value is 0 or below, the dolphin\n+     *     will be damaged via {@link DamageSources#DRYOUT} with a value of 1 per tick\n+     *     until death.\n+     * </p>\n      */\n-    public static final Supplier<Key<Value<Direction>>> SLOT_SIDE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SLOT_SIDE\");\n+    public static final Supplier<Key<Value<Integer>>> SKIN_MOISTURE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SKIN_MOISTURE\");\n \n     /**\n-     * Represents the {@link Key} for the time a {@link Panda} has been sneezing (in ticks)\n+     * The skylight value at a {@link Location}.\n+     * For the blocklight see {@link #BLOCK_LIGHT}.\n      */\n-    public static final Supplier<Key<Value<Integer>>> SNEEZING_TIME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SNEEZING_TIME\");\n+    public static final Supplier<Key<Value<Integer>>> SKY_LIGHT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SKY_LIGHT\");\n \n     /**\n-     * Represents the {@link Key} for representing the \"snowed\" state\n-     * of a {@link BlockState}.\n+     * The {@link SlabPortion} of a {@link BlockState}.\n      */\n-    public static final Supplier<Key<Value<Boolean>>> SNOWED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SNOWED\");\n+    public static final Supplier<Key<Value<SlabPortion>>> SLAB_PORTION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SLAB_PORTION\");\n \n     /**\n-     * Represents the {@link Key} for the list of {@link EntityArchetype}s able\n-     * to be spawned by a {@link MobSpawner}.\n+     * The index of a {@link Slot} in an {@link Inventory}\n      */\n-    public static final Supplier<Key<WeightedCollectionValue<EntityArchetype>>> SPAWNER_ENTITIES = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SPAWNER_ENTITIES\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> SLOT_INDEX = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SLOT_INDEX\");\n \n     /**\n-     * Represents the {@link Key} for the maximum amount of ticks between two\n-     * batches of entities spawned by a {@link MobSpawner}.\n+     * The position of a {@link Slot} within a {@link GridInventory}.\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> SPAWNER_MAXIMUM_DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SPAWNER_MAXIMUM_DELAY\");\n+    public static final Supplier<Key<Value<Vector2i>>> SLOT_POSITION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SLOT_POSITION\");\n \n     /**\n-     * Represents the {@link Key} for the maximum number of entities around a\n-     * {@link MobSpawner}. A spawner will not spawn entities if there are more\n-     * entities around than this value permits.\n+     * The side of a particular {@link Slot}, for use in querying \"sided inventories\".\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> SPAWNER_MAXIMUM_NEARBY_ENTITIES = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SPAWNER_MAXIMUM_NEARBY_ENTITIES\");\n+    public static final Supplier<Key<Value<Direction>>> SLOT_SIDE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SLOT_SIDE\");\n \n     /**\n-     * Represents the {@link Key} for the minimum amount of ticks between two\n-     * batches of entities spawned by a {@link MobSpawner}.\n+     * Whether a {@link Minecart} slows down when it has no {@link Keys#PASSENGERS}.\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> SPAWNER_MINIMUM_DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SPAWNER_MINIMUM_DELAY\");\n+    public static final Supplier<Key<Value<Boolean>>> SLOWS_UNOCCUPIED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SLOWS_UNOCCUPIED\");\n \n     /**\n-     * Represents the {@link Key} for the next entity that will be spawned\n-     * by a {@link MobSpawner}.\n-     *\n-     * <p>Normally the entities to be spawned are determined by a random value\n-     * applied to the {@link #SPAWNER_ENTITIES} weighted collection. If this\n-     * value exists, it will override the random spawn with a definite one.</p>\n+     * The time a {@link Panda} has been sneezing (in ticks)\n      */\n-    public static final Supplier<Key<Value<WeightedSerializableObject<EntityArchetype>>>> SPAWNER_NEXT_ENTITY_TO_SPAWN = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SPAWNER_NEXT_ENTITY_TO_SPAWN\");\n+    public static final Supplier<Key<Value<Integer>>> SNEEZING_TIME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SNEEZING_TIME\");\n \n     /**\n-     * Represents the {@link Key} for the remaining number of ticks to pass\n-     * before another attempt to spawn entities is made by a {@link MobSpawner}.\n+     * Whether a {@link BlockTypes#DIRT} {@link BlockState} is snowy.\n      */\n-    public static final Supplier<Key<BoundedValue<Integer>>> SPAWNER_REMAINING_DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SPAWNER_REMAINING_DELAY\");\n+    public static final Supplier<Key<Value<Boolean>>> SNOWY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"SNOWY\");", "originalCommit": "b8751271af7a7d06b8bd48adc136638397cf7513", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "89533c495c89e08708871d7edadc9cec621f2b71", "url": "https://github.com/SpongePowered/SpongeAPI/commit/89533c495c89e08708871d7edadc9cec621f2b71", "message": "sorting", "committedDate": "2020-04-17T14:24:31Z", "type": "forcePushed"}, {"oid": "d7a63fc4e9b433a8daa04e397a69b1de37d37d37", "url": "https://github.com/SpongePowered/SpongeAPI/commit/d7a63fc4e9b433a8daa04e397a69b1de37d37d37", "message": "API8 Keys\n\nsorting\n\nrename\n\nsorting", "committedDate": "2020-04-25T21:31:47Z", "type": "forcePushed"}, {"oid": "3fadf7c77e09816fa4576b961006934f7fa08979", "url": "https://github.com/SpongePowered/SpongeAPI/commit/3fadf7c77e09816fa4576b961006934f7fa08979", "message": "API8 Keys", "committedDate": "2020-04-29T20:15:37Z", "type": "forcePushed"}, {"oid": "cc867e3f47db0354dcb1c18ed283985da72b7c1d", "url": "https://github.com/SpongePowered/SpongeAPI/commit/cc867e3f47db0354dcb1c18ed283985da72b7c1d", "message": "API8 Keys", "committedDate": "2020-04-29T20:43:33Z", "type": "forcePushed"}, {"oid": "b641fc9acdbba2b916773c5ec5b7f1f168867510", "url": "https://github.com/SpongePowered/SpongeAPI/commit/b641fc9acdbba2b916773c5ec5b7f1f168867510", "message": "implement some dataproviders", "committedDate": "2020-04-29T22:30:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk1MjY1Nw==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r418952657", "bodyText": "Change this back to Double, using int is an impl detail.", "author": "Cybermaxke", "createdAt": "2020-05-02T12:25:33Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -1501,291 +1429,329 @@\n     public static final Supplier<Key<Value<Boolean>>> IS_POWERED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_POWERED\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link FusedExplosive} is currently primed.\n+     * Whether a {@link FusedExplosive} is currently primed.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_PRIMED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_PRIMED\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Cat} is purring.\n+     * Whether a {@link Cat} is purring.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_PURRING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_PURRING\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Cat} is relaxed.\n+     * Whether a {@link Cat} is relaxed.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_RELAXED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_RELAXED\");\n \n     /**\n-     * Represents the {@link Key} for whether a living entity is roaring. Usually ravagers.\n+     * Whether a {@link BlockState} can be replaced by a player without breaking it first.\n+     * e.g. {@link BlockTypes#WATER}\n+     * Readonly\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_REPLACEABLE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_REPLACEABLE\");\n+\n+    /**\n+     * Whether a {@link Ravager} is roaring.\n+     * Readonly\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_ROARING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_ROARING\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Panda} is rolling around.\n+     * Whether a {@link Panda} is rolling around.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_ROLLING_AROUND = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_ROLLING_AROUND\");\n \n     /**\n-     * Represents the {@link Key} for whether a {@link Entity} is saddled.\n+     * Whether an entity is saddled.\n+     * e.g. {@link Horse}s and {@link Pig}s\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SADDLED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SADDLED\");\n \n     /**\n-     * Represents the {@link Key} for whether an {@link Enderman} is screaming.\n+     * Whether an {@link Enderman} is screaming.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SCREAMING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SCREAMING\");\n \n     /**\n-     * Represents the {@link Key} for whether a {@link Sheep} is sheared.\n+     * Whether a {@link Sheep} is sheared.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SHEARED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SHEARED\");\n \n     /**\n-     * Represents the {@link Key} for whether an {@link Entity} is silent.\n+     * Whether an {@link Entity} is silent.\n      *\n      * <p>A silent entity will not emit sounds or make noises.</p>\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SILENT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SILENT\");\n \n     /**\n-     * Represents the {@link Key} for whether a {@link Wolf}, {@link Cat}, {@link Panda}, or {@link Fox} is sitting.\n+     * Whether a {@link Wolf}, {@link Cat}, {@link Panda}, or {@link Fox} is sitting.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SITTING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SITTING\");\n \n     /**\n-     * Represents the {@link Key} for whether a {@link Bat}, {@link Fox} or {@link Player}\n-     * is sleeping.\n+     * Whether a {@link Bat}, {@link Fox} or {@link Player} is sleeping.\n      *\n-     * <p>If a player is considered sleeping as per this data value, he does\n+     * <p>If a player is considered sleeping as per this data value, the player does\n      * not need to be in bed in order for the other players to be able to\n      * advance through the night by going to bed.</p>\n+     * Readonly(Player.class)\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SLEEPING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SLEEPING\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Player Player's} sleeping status is ignored when checking whether to\n+     * Whether a {@link Player Player's} sleeping status is ignored when checking whether to\n      * skip the night due to players sleeping. The time in a world will be\n      * advanced to day if all players in it either are sleeping or are set to ignore.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SLEEPING_IGNORED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SLEEPING_IGNORED\");\n \n     /**\n-     * Represents the {@link Key} for whether an {@link Entity} is sneaking.\n+     * Whether an {@link ArmorStand} is small.\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_SMALL = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SMALL\");\n+\n+    /**\n+     * Whether an {@link Entity} is sneaking.\n      *\n      * <p>Sneaking entities generally move slower and do not make walking\n      * sounds.</p>\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SNEAKING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SNEAKING\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Panda} is sneezing.\n+     * Whether a {@link Panda} is sneezing.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SNEEZING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SNEEZING\");\n \n     /**\n-     * Represents the {@link Key} for whether an {@link Entity} is sprinting.\n+     * Whether a {@link BlockTypes#DIRT} {@link BlockState} is snowy.\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_SNOWY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SNOWY\");\n+\n+    /**\n+     * Whether a {@link BlockState} is solid.\n+     * Readonly\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_SOLID = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SOLID\");\n+\n+    /**\n+     * Whether an {@link Entity} is sprinting.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_SPRINTING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SPRINTING\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link PolarBear} is currently standing.\n+     * Whether a {@link PolarBear} is currently standing.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_STANDING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_STANDING\");\n \n     /**\n-     * Represents the {@link Key} for whether an entity is stunned.\n+     * Whether a {@link Ravager} is stunned.\n+     * Readonly\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_STUNNED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_STUNNED\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link TameableAnimal} is currently tamed\n+     * Whether a {@link BlockState} is a surrogate block for a block that was provided in an environment\n+     * (almost always modded), that the block type provider no longer exists.\n+     * If true this may indicate that the surrogate block functions differently than the original block.\n+     * Readonly\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_SURROGATE_BLOCK = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_SURROGATE_BLOCK\");\n+\n+    /**\n+     * Whether players are prevented from taking\n+     * items from an equipment slot on an {@link ArmorStand}\n+     */\n+    public static final Supplier<Key<SetValue<EquipmentType>>> IS_TAKING_DISABLED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"TAKING_DISABLED\");\n+\n+    /**\n+     * Whether a {@link TameableAnimal} is currently tamed\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_TAMED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_TAMED\");\n \n     /**\n-     * Represents the {@link Key} for if a {@link Trader} is currently trading with a {@link Player}.\n+     * Whether a {@link Trader} is currently trading with a {@link Player}.\n+     * Readonly\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_TRADING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_TRADING\");\n \n     /**\n-     * Represents the {@link Key} for if an {@link Ocelot} is currently trusting of {@link Player}s.\n+     * Whether a {@link Turtle} is currently traveling.\n+     */\n+    public static final Supplier<Key<Value<Boolean>>> IS_TRAVELING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_TRAVELING\");\n+\n+    /**\n+     * Whether an {@link Ocelot} is currently trusting of {@link Player}s.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_TRUSTING = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_TRUSTING\");\n \n     /**\n-     * Represents the {@link Key} for whether an {@link ItemStack} or {@link BlockState} is unbreakable.\n+     * Whether an {@link ItemStack} or {@link BlockState} is unbreakable.\n      *\n-     * <p>Setting this to {@code  true} will prevent the item stack's\n+     * <p>Setting this to {@code true} will prevent the item stack's\n      * {@link #ITEM_DURABILITY} from changing.</p>\n+     * Readonly(BlockState.class)\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_UNBREAKABLE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_UNBREAKABLE\");\n \n     /**\n-     * Represents the {@link Key} for whether a {@link Panda} is unhappy.\n+     * Whether a {@link Panda} is unhappy.\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_UNHAPPY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_UNHAPPY\");\n \n     /**\n-     * Represents the {@link Key} for whether a {@link Wolf}, a\n-     * {@link BlockState} of {@link BlockTypes#SPONGE} or an {@link ItemStack}\n-     * of {@link ItemTypes#SPONGE} is wet.\n+     * Whether an {@link Entity} like {@link Wolf} or a\n+     * {@link BlockState} of {@link BlockTypes#SPONGE} is wet.\n+     * Readonly(Entity.class) except Wolf\n      */\n     public static final Supplier<Key<Value<Boolean>>> IS_WET = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"IS_WET\");\n \n     /**\n-     * Represents the {@link Key} for the durability of an {@link ItemStack}.\n+     * The durability of an {@link ItemStack}.\n      */\n     public static final Supplier<Key<BoundedValue<Integer>>> ITEM_DURABILITY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ITEM_DURABILITY\");\n \n     /**\n-     * Represents the {@link Key} for the displayed description (\"lore\") text\n-     * of an {@link ItemStack}.\n-     *\n-     * <p>The lore text is usually displayed when the player hovers his cursor\n-     * over the stack. For the contents of a book see {@link #BOOK_PAGES}\n-     * instead.</p>\n-     */\n-    public static final Supplier<Key<ListValue<Text>>> ITEM_LORE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ITEM_LORE\");\n-\n-    /**\n-     * Represents the {@link Key} for the {@link ItemStackSnapshot item} in an\n+     * The {@link ItemStackSnapshot item} in an\n      * {@link Item}, {@link ItemFrame}, {@link Jukebox}, {@link Lectern} or\n      * {@link Potion}.\n      */\n     public static final Supplier<Key<Value<ItemStackSnapshot>>> ITEM_STACK_SNAPSHOT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ITEM_STACK_SNAPSHOT\");\n \n     /**\n-     * Represents the {@link Key} for the knockback strength applied by an\n-     * {@link ArrowEntity}.\n+     * The knockback strength applied by an {@link ArrowEntity}.\n      *\n      * <p>For the knockback provided by hits with a weapon according to the\n      * enchantment of the same name, see {@link #APPLIED_ENCHANTMENTS}.</p>\n      */\n-    public static final Supplier<Key<BoundedValue<Double>>> KNOCKBACK_STRENGTH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"KNOCKBACK_STRENGTH\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> KNOCKBACK_STRENGTH = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"KNOCKBACK_STRENGTH\");", "originalCommit": "eb14d1278bbba81746bd9d34f138eabd60aeabf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0f0afdba606c9c3afa3aad7d2c26a3f56b3f8782", "url": "https://github.com/SpongePowered/SpongeAPI/commit/0f0afdba606c9c3afa3aad7d2c26a3f56b3f8782", "message": "API8 Keys", "committedDate": "2020-05-03T13:20:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg0MDEyMQ==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r419840121", "bodyText": "Is it worth merging this into DYE_COLOR?", "author": "JBYoshi", "createdAt": "2020-05-05T03:05:09Z", "path": "src/main/java/org/spongepowered/api/data/Keys.java", "diffHunk": "@@ -285,280 +306,109 @@\n     public static final Supplier<Key<ListValue<Enchantment>>> APPLIED_ENCHANTMENTS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ITEM_ENCHANTMENTS\");\n \n     /**\n-     * Represents the {@link Key} for the age (in ticks) of an\n-     * {@link AreaEffectCloud} created by a lingering potion.\n-     */\n-    public static final Supplier<Key<BoundedValue<Integer>>> AREA_EFFECT_CLOUD_AGE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_AGE\");\n-\n-    /**\n-     * Represents the {@link Key} for the color of an {@link AreaEffectCloud}\n-     * created by a lingering potion.\n-     */\n-    public static final Supplier<Key<Value<Color>>> AREA_EFFECT_CLOUD_COLOR = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_COLOR\");\n-\n-    /**\n-     * Represents the {@link Key} for the maximum age (in ticks) of an\n-     * {@link AreaEffectCloud} created by a lingering potion.\n-     */\n-    public static final Supplier<Key<BoundedValue<Integer>>> AREA_EFFECT_CLOUD_DURATION = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_DURATION\");\n-\n-    /**\n-     * Represents the {@link Key} for the amount of ticks the duration of an\n-     * {@link AreaEffectCloud} is increased or reduced when it applies its\n-     * effect.\n-     */\n-    public static final Supplier<Key<BoundedValue<Integer>>> AREA_EFFECT_CLOUD_DURATION_ON_USE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_DURATION_ON_USE\");\n-\n-    /**\n-     * Represents the {@link Key} for the particle type of an\n-     * {@link AreaEffectCloud} created by a lingering potion.\n-     *\n-     * <p>Only a few {@link ParticleOption}s will be usable for this\n-     * effect for specific {@link ParticleType}s and not every\n-     * {@link ParticleType} will be applicable.</p>\n-     */\n-    public static final Supplier<Key<Value<ParticleEffect>>> AREA_EFFECT_CLOUD_PARTICLE_EFFECT = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_PARTICLE_EFFECT\");\n-\n-    /**\n-     * Represents the {@link Key} for the radius of an {@link AreaEffectCloud}.\n-     */\n-    public static final Supplier<Key<BoundedValue<Double>>> AREA_EFFECT_CLOUD_RADIUS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_RADIUS\");\n-\n-    /**\n-     * Represents the {@link Key} for the amount the radius of an\n-     * {@link AreaEffectCloud} grows or shrinks each time it applies its\n-     * effect.\n-     */\n-    public static final Supplier<Key<BoundedValue<Double>>> AREA_EFFECT_CLOUD_RADIUS_ON_USE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_RADIUS_ON_USE\");\n-\n-    /**\n-     * Represents the {@link Key} for the amount the radius of an\n-     * {@link AreaEffectCloud} grows or shrinks per tick.\n-     */\n-    public static final Supplier<Key<BoundedValue<Double>>> AREA_EFFECT_CLOUD_RADIUS_PER_TICK = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_RADIUS_PER_TICK\");\n-\n-    /**\n-     * Represents the {@link Key} for the delay (in ticks) after which an\n-     * {@link AreaEffectCloud} will reapply its effect on a previously\n-     * affected {@link Entity}.\n-     */\n-    public static final Supplier<Key<BoundedValue<Integer>>> AREA_EFFECT_CLOUD_REAPPLICATION_DELAY = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_REAPPLICATION_DELAY\");\n-\n-    /**\n-     * Represents the {@link Key} for the duration in ticks after which an\n-     * {@link AreaEffectCloud} will begin to apply its effect to entities.\n-     */\n-    public static final Supplier<Key<BoundedValue<Integer>>> AREA_EFFECT_CLOUD_WAIT_TIME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AREA_EFFECT_CLOUD_WAIT_TIME\");\n-\n-    /**\n-     * Represents the {@link Key} for whether an {@link ArmorStand}'s arms are\n-     * visible.\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> ARMOR_STAND_HAS_ARMS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ARMOR_STAND_HAS_ARMS\");\n-\n-    /**\n-     * Represents the {@link Key} for whether an {@link ArmorStand} has a\n-     * visible base plate.\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> ARMOR_STAND_HAS_BASE_PLATE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ARMOR_STAND_HAS_BASE_PLATE\");\n-\n-    /**\n-     * Represents the {@link Key} for if an {@link ArmorStand} is a \"marker\" stand.\n-     *\n-     * <p>If {@code true}, the armor stand's bounding box is near\n-     * impossible to see, and the armor stand can no longer be\n-     * interacted with.</p>\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> ARMOR_STAND_HAS_MARKER = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ARMOR_STAND_HAS_MARKER\");\n-\n-    /**\n-     * Represents the {@link Key} for whether an {@link ArmorStand} is small.\n-     */\n-    public static final Supplier<Key<Value<Boolean>>> ARMOR_STAND_IS_SMALL = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ARMOR_STAND_IS_SMALL\");\n-\n-    /**\n-     * Represents the {@link Key} for whether players are prevented from taking\n-     * items from an equipment slot on an {@link ArmorStand}\n-     */\n-    public static final Supplier<Key<SetValue<EquipmentType>>> ARMOR_STAND_PLACING_DISABLED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ARMOR_STAND_PLACING_DISABLED\");\n-\n-    /**\n-     * Represents the {@link Key} for whether players are prevented from taking\n-     * items from an equipment slot on an {@link ArmorStand}\n-     */\n-    public static final Supplier<Key<SetValue<EquipmentType>>> ARMOR_STAND_TAKING_DISABLED = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ARMOR_STAND_TAKING_DISABLED\");\n-\n-    /**\n-     * Represents the {@link Key} for the type of {@link ArtType} shown by\n-     * (usually) a {@link Painting}.\n+     * The type of {@link ArtType} shown by {@link Painting}s.\n      */\n     public static final Supplier<Key<Value<ArtType>>> ART = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ART\");\n \n     /**\n-     * Represents the {@link Key} for the attachment {@link Surface}\n-     * of a button or lever.\n+     * The attachment {@link Surface} of a button or lever {@link BlockState}\n      */\n     public static final Supplier<Key<Value<Surface>>> ATTACHMENT_SURFACE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ATTACHMENT_SURFACE\");\n \n     /**\n-     * Represents the {@link Key} for the damage dealt by a\n-     * {@link DamagingProjectile}, e.g. an {@link ArrowEntity}.\n+     * The damage dealt by an {@link ArrowEntity} on impact.\n      */\n     public static final Supplier<Key<BoundedValue<Double>>> ATTACK_DAMAGE = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ATTACK_DAMAGE\");\n \n     /**\n-     * Represents the {@link Key} for the time of a {@link Ravager} is considered attacking.\n+     * The time of a {@link Ravager} is considered attacking.\n      */\n     public static final Supplier<Key<Value<Integer>>> ATTACK_TIME = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"ATTACK_TIME\");\n \n     /**\n-     * Represents the {@link Key} for representing the {@link Axis} direction\n-     * of a {@link BlockState}.\n+     * The author of a {@link ItemTypes#WRITTEN_BOOK} {@link ItemStack}.\n+     */\n+    public static final Supplier<Key<Value<Text>>> AUTHOR = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AUTHOR\");\n+\n+    /**\n+     * The {@link Axis} direction of a {@link BlockState}.\n      */\n     public static final Supplier<Key<Value<Axis>>> AXIS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"AXIS\");\n \n     /**\n-     * Represents the {@link Key} for a {@link Banner}'s base {@link DyeColor}.\n+     * The ticks until a {@link Ageable} turns into an adult.\n      */\n-    public static final Supplier<Key<Value<DyeColor>>> BANNER_BASE_COLOR = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BANNER_BASE_COLOR\");\n+    public static final Supplier<Key<BoundedValue<Integer>>> BABY_TICKS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BABY_TICKS\");\n \n     /**\n-     * Represents the {@link Key} for a {@link Banner}'s patterns.\n+     * The {@link BannerPatternLayer}s of a {@link Banner}.\n      */\n     public static final Supplier<Key<ListValue<BannerPatternLayer>>> BANNER_PATTERN_LAYERS = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BANNER_PATTERN_LAYERS\");\n \n     /**\n-     * Represents the {@link Key} for the width of the physical form of an\n-     * {@link Entity}.\n+     * The base {@link DyeColor} of a {@link Banner} or {@link TropicalFish}.\n+     */\n+    public static final Supplier<Key<Value<DyeColor>>> BASE_COLOR = Sponge.getRegistry().getCatalogRegistry().provideSupplier(Key.class, \"BASE_COLOR\");", "originalCommit": "0f0afdba606c9c3afa3aad7d2c26a3f56b3f8782", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc4MDQyOA==", "url": "https://github.com/SpongePowered/SpongeAPI/pull/2108#discussion_r423780428", "bodyText": "done it", "author": "Faithcaio", "createdAt": "2020-05-12T14:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg0MDEyMQ=="}], "type": "inlineReview"}, {"oid": "344626e1683640cee088a03072359097b6eddf76", "url": "https://github.com/SpongePowered/SpongeAPI/commit/344626e1683640cee088a03072359097b6eddf76", "message": "API8 Keys", "committedDate": "2020-05-12T14:25:55Z", "type": "forcePushed"}, {"oid": "ad2bad92694b96022cc24dd6ab15420882a0ec5b", "url": "https://github.com/SpongePowered/SpongeAPI/commit/ad2bad92694b96022cc24dd6ab15420882a0ec5b", "message": "API8 Keys", "committedDate": "2020-05-12T14:32:46Z", "type": "commit"}, {"oid": "ad2bad92694b96022cc24dd6ab15420882a0ec5b", "url": "https://github.com/SpongePowered/SpongeAPI/commit/ad2bad92694b96022cc24dd6ab15420882a0ec5b", "message": "API8 Keys", "committedDate": "2020-05-12T14:32:46Z", "type": "forcePushed"}]}