{"pr_number": 1051, "pr_title": "Fixes #1050: IndexFunctionHelper.getGroupedKey / getGroupingKey can \u2026", "pr_createdAt": "2020-10-22T03:40:28Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1051", "timeline": [{"oid": "36df0ec5eed5757a3fcd986006a79e8c7e3c5d70", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/36df0ec5eed5757a3fcd986006a79e8c7e3c5d70", "message": "Fixes #1050: IndexFunctionHelper.getGroupedKey / getGroupingKey can get array bounds error", "committedDate": "2020-10-22T03:39:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM3NDgwOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1051#discussion_r510374809", "bodyText": "Is this required for correctness, or just an optimization?", "author": "alecgrieser", "createdAt": "2020-10-22T18:34:32Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexFunctionHelper.java", "diffHunk": "@@ -145,6 +147,9 @@ private IndexFunctionHelper() {\n      * @return {@code true} if the operand is compatible with the index\n      */\n     public static boolean isGroupPrefix(@Nonnull KeyExpression functionOperand, @Nonnull KeyExpression indexRoot) {\n+        if (functionOperand.equals(indexRoot)) {\n+            return true;", "originalCommit": "36df0ec5eed5757a3fcd986006a79e8c7e3c5d70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNzE0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1051#discussion_r510407145", "bodyText": "An optimization, since correctness makes an actual prefix comparison rather more expensive.", "author": "MMcM", "createdAt": "2020-10-22T19:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM3NDgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4MjAwMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1051#discussion_r510382001", "bodyText": "Was the prior behavior here (for nested) that it would just throw an error? I'm not seeing any handling of it at all in the old code.", "author": "alecgrieser", "createdAt": "2020-10-22T18:47:25Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/IndexFunctionHelperTest.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * IndexFunctionHelperTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+/**\n+ * Tests for {@link IndexFunctionHelper}.\n+ */\n+public class IndexFunctionHelperTest {\n+\n+    @Test\n+    public void groupSubKeysBasic() {\n+        final KeyExpression ungrouped = Key.Expressions.field(\"value\").ungrouped();\n+        assertEquals(Key.Expressions.field(\"value\"), IndexFunctionHelper.getGroupedKey(ungrouped));\n+        assertEquals(Key.Expressions.empty(), IndexFunctionHelper.getGroupingKey(ungrouped));\n+\n+        final KeyExpression group = Key.Expressions.field(\"value\").groupBy(Key.Expressions.field(\"group\"));\n+        assertEquals(Key.Expressions.field(\"value\"), IndexFunctionHelper.getGroupedKey(group));\n+        assertEquals(Key.Expressions.field(\"group\"), IndexFunctionHelper.getGroupingKey(group));\n+    }\n+\n+    @Test\n+    public void groupSubKeysNested() {\n+        final KeyExpression nested = new GroupingKeyExpression(Key.Expressions.field(\"values\", KeyExpression.FanType.FanOut).nest(Key.Expressions.concatenateFields(\"one\", \"two\")), 1);", "originalCommit": "36df0ec5eed5757a3fcd986006a79e8c7e3c5d70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNzc4OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1051#discussion_r510407788", "bodyText": "Prior behavior was it would throw an unsupported error, unless the split happened to be inside the nesting, in which case it would throw an index out of bounds exception.", "author": "MMcM", "createdAt": "2020-10-22T19:33:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4MjAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4NDc4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1051#discussion_r510384784", "bodyText": "I think this is missing a test that takes a then with a nested and splits it \"within the nest\". Something like:\nconcat(nest(a, concat(b, c)), d, nest(e, concat(f, g))\nAnd then splitting it at various points", "author": "alecgrieser", "createdAt": "2020-10-22T18:52:28Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/IndexFunctionHelperTest.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * IndexFunctionHelperTest.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.provider.foundationdb;\n+\n+import com.apple.foundationdb.record.metadata.Key;\n+import com.apple.foundationdb.record.metadata.expressions.GroupingKeyExpression;\n+import com.apple.foundationdb.record.metadata.expressions.KeyExpression;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+/**\n+ * Tests for {@link IndexFunctionHelper}.\n+ */\n+public class IndexFunctionHelperTest {", "originalCommit": "36df0ec5eed5757a3fcd986006a79e8c7e3c5d70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyMzg5MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1051#discussion_r510423890", "bodyText": "I changed the test to split that at various places.", "author": "MMcM", "createdAt": "2020-10-22T20:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4NDc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4NTkxNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1051#discussion_r510385915", "bodyText": "Is there a concern that with this change, there will be a behavior change in some kind of incompatible way? E.g., if you had an index defined on concat(nest(a, concat(b, c)), d) with 1 grouping column, and you rely on this incorrectly grouping the expression into nest(a, concat(b, c)) and d? Or will a situation like that have always thrown an error before?", "author": "alecgrieser", "createdAt": "2020-10-22T18:54:19Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexFunctionHelper.java", "diffHunk": "@@ -154,34 +159,72 @@ public static KeyExpression getGroupedKey(@Nonnull KeyExpression key) {\n             return key;\n         }\n         GroupingKeyExpression grouping = (GroupingKeyExpression) key;\n-        return getGroupingSubkey(grouping, grouping.getGroupingCount(), grouping.getColumnSize());\n+        return getSubKey(grouping.getWholeKey(), grouping.getGroupingCount(), grouping.getColumnSize());\n     }\n \n     public static KeyExpression getGroupingKey(@Nonnull KeyExpression key) {\n         if (!(key instanceof GroupingKeyExpression)) {\n             return EmptyKeyExpression.EMPTY;\n         }\n         GroupingKeyExpression grouping = (GroupingKeyExpression) key;\n-        return getGroupingSubkey(grouping, 0, grouping.getGroupingCount());\n+        return getSubKey(grouping.getWholeKey(), 0, grouping.getGroupingCount());\n     }\n \n-    protected static KeyExpression getGroupingSubkey(GroupingKeyExpression grouping, int start, int end) {\n+    protected static KeyExpression getSubKey(KeyExpression key, int start, int end) {\n         if (start == end) {\n             return EmptyKeyExpression.EMPTY;\n         }\n-        final KeyExpression key = grouping.getWholeKey();\n-        if (!(key instanceof ThenKeyExpression)) {\n-            if (start == 0 && end == 1) {\n-                return key;\n-            }\n-            throw new RecordCoreException(\"grouping breaks apart key other than Then\");\n+        if (start == 0 && end == key.getColumnSize()) {\n+            return key;\n+        }\n+        if (key instanceof ThenKeyExpression) {\n+            return getThenSubKey((ThenKeyExpression)key, start, end);\n+        }\n+        if (key instanceof NestingKeyExpression) {\n+            final NestingKeyExpression nesting = (NestingKeyExpression)key;\n+            return new NestingKeyExpression(nesting.getParent(), getSubKey(nesting.getChild(), start, end));\n         }\n-        ThenKeyExpression then = (ThenKeyExpression)key;\n-        List<KeyExpression> children = then.getChildren();\n-        if (end == start + 1) {\n-            return children.get(start);", "originalCommit": "36df0ec5eed5757a3fcd986006a79e8c7e3c5d70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMTE1Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1051#discussion_r510411156", "bodyText": "It is a behavior change, yes. If you have concat(nest(a, concat(b, c)), d), that means you're grouping by just a/b.  The previous behavior did have cases like that where it did not throw an exception, but I submit that they returned the wrong answer.", "author": "MMcM", "createdAt": "2020-10-22T19:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4NTkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzODE3Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1051#discussion_r510438172", "bodyText": "Yeah, I definitely think it was returning the wrong answer, even if it didn't throw an exception. My main concern was If the wrong answer would somehow result in old index entries somehow looking like a corrupt index. Based on the way this function is used, I don't think that's a problem, so I think that this change makes sense (without needing to introduce some compatibility mode to \"ask for the buggy behavior\").", "author": "alecgrieser", "createdAt": "2020-10-22T20:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4NTkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzOTQ3Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1051#discussion_r510439477", "bodyText": "Ah, right, yeah. I don't think these are used where the caller actually evaluates the result, as opposed to lining up meta-data.", "author": "MMcM", "createdAt": "2020-10-22T20:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4NTkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5MDgyMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1051#discussion_r510390822", "bodyText": "This looks right to me, but I think it could use more coverage on the various cases to validate that", "author": "alecgrieser", "createdAt": "2020-10-22T19:02:45Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/provider/foundationdb/IndexFunctionHelper.java", "diffHunk": "@@ -154,34 +159,72 @@ public static KeyExpression getGroupedKey(@Nonnull KeyExpression key) {\n             return key;\n         }\n         GroupingKeyExpression grouping = (GroupingKeyExpression) key;\n-        return getGroupingSubkey(grouping, grouping.getGroupingCount(), grouping.getColumnSize());\n+        return getSubKey(grouping.getWholeKey(), grouping.getGroupingCount(), grouping.getColumnSize());\n     }\n \n     public static KeyExpression getGroupingKey(@Nonnull KeyExpression key) {\n         if (!(key instanceof GroupingKeyExpression)) {\n             return EmptyKeyExpression.EMPTY;\n         }\n         GroupingKeyExpression grouping = (GroupingKeyExpression) key;\n-        return getGroupingSubkey(grouping, 0, grouping.getGroupingCount());\n+        return getSubKey(grouping.getWholeKey(), 0, grouping.getGroupingCount());\n     }\n \n-    protected static KeyExpression getGroupingSubkey(GroupingKeyExpression grouping, int start, int end) {\n+    protected static KeyExpression getSubKey(KeyExpression key, int start, int end) {\n         if (start == end) {\n             return EmptyKeyExpression.EMPTY;\n         }\n-        final KeyExpression key = grouping.getWholeKey();\n-        if (!(key instanceof ThenKeyExpression)) {\n-            if (start == 0 && end == 1) {\n-                return key;\n-            }\n-            throw new RecordCoreException(\"grouping breaks apart key other than Then\");\n+        if (start == 0 && end == key.getColumnSize()) {\n+            return key;\n+        }\n+        if (key instanceof ThenKeyExpression) {\n+            return getThenSubKey((ThenKeyExpression)key, start, end);\n+        }\n+        if (key instanceof NestingKeyExpression) {\n+            final NestingKeyExpression nesting = (NestingKeyExpression)key;\n+            return new NestingKeyExpression(nesting.getParent(), getSubKey(nesting.getChild(), start, end));\n         }\n-        ThenKeyExpression then = (ThenKeyExpression)key;\n-        List<KeyExpression> children = then.getChildren();\n-        if (end == start + 1) {\n-            return children.get(start);\n+        throw new RecordCoreException(\"grouping breaks apart key other than Then\");\n+    }\n+\n+    protected static KeyExpression getThenSubKey(ThenKeyExpression then, int columnStart, int columnEnd) {\n+        final List<KeyExpression> children = then.getChildren();\n+        int columnPosition = 0;\n+        int startChildPosition = -1;\n+        int startChildStart = -1;\n+        int startChildEnd = -1;\n+        for (int childPosition = 0; childPosition < children.size(); childPosition++) {\n+            final KeyExpression child = children.get(childPosition);\n+            final int childColumns = child.getColumnSize();\n+            if (startChildPosition < 0 && columnPosition + childColumns > columnStart) {\n+                startChildPosition = childPosition;\n+                startChildStart = columnStart - columnPosition;\n+                startChildEnd = childColumns;\n+            }\n+            if (columnPosition + childColumns >= columnEnd) {\n+                int endChildEnd = columnEnd - columnPosition;\n+                if (childPosition == startChildPosition) {\n+                    // Just one child spans column start, end.\n+                    if (startChildPosition == 0 && endChildEnd == childColumns) {\n+                        return child;\n+                    } else {\n+                        return getSubKey(child, startChildStart, endChildEnd);\n+                    }\n+                }\n+                if (startChildStart == 0 && endChildEnd == childColumns) {\n+                    return new ThenKeyExpression(children.subList(startChildPosition, childPosition + 1));\n+                }\n+                final List<KeyExpression> keys = new ArrayList<>(childPosition - startChildPosition + 1);\n+                keys.add(getSubKey(children.get(startChildPosition), startChildStart, startChildEnd));\n+                if (childPosition > startChildPosition + 1) {\n+                    keys.addAll(children.subList(startChildPosition + 1, childPosition));\n+                }\n+                keys.add(getSubKey(child, 0, endChildEnd));\n+                return new ThenKeyExpression(keys);", "originalCommit": "36df0ec5eed5757a3fcd986006a79e8c7e3c5d70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2b3d9fd60929ce54561fcd7cb95347779f019737", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/2b3d9fd60929ce54561fcd7cb95347779f019737", "message": "Expand test cases", "committedDate": "2020-10-22T20:03:12Z", "type": "commit"}]}