{"pr_number": 1040, "pr_title": "Resolves #1039: partition residual filters into index fiters and true\u2026", "pr_createdAt": "2020-10-12T14:52:58Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/1040", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM1NzEyNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1040#discussion_r503357125", "bodyText": "Had to remove the dual planner annotation as the temp planner cannot plan this anymore.", "author": "normen662", "createdAt": "2020-10-12T15:03:00Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBReturnedRecordLimitQueryTest.java", "diffHunk": "@@ -65,7 +67,7 @@\n      * Verify that a returned record limit works properly against a query with a filter on one field and a sort on another,\n      * when the filter field is un-indexed and the sort is in reverse order.\n      */\n-    @DualPlannerTest\n+    @Test", "originalCommit": "13542980a4616d1bb7123cfbc5d41be2d2e3c01c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM1NzgxOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1040#discussion_r503357818", "bodyText": "While the plan is better it seems that we discard more records. I am assuming that is because of prefetching but it would be nice to understand exactly why that is. (this is in conjunction with a limit on the query)", "author": "normen662", "createdAt": "2020-10-12T15:04:10Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBReturnedRecordLimitQueryTest.java", "diffHunk": "@@ -88,13 +90,13 @@ public void testComplexLimits2() throws Exception {\n                     FDBQueriedRecord<Message> rec = cursor.next();\n                     TestRecords1Proto.MySimpleRecord.Builder myrec = TestRecords1Proto.MySimpleRecord.newBuilder();\n                     myrec.mergeFrom(rec.getRecord());\n-                    assertEquals(\"odd\", myrec.getStrValueIndexed());\n                     assertEquals(0, myrec.getNumValue2());\n+                    assertEquals(\"odd\", myrec.getStrValueIndexed());\n                     i += 1;\n                 }\n             }\n             assertEquals(10, i);\n-            assertDiscardedAtMost(18, context);\n+            assertDiscardedAtMost(34, context);", "originalCommit": "13542980a4616d1bb7123cfbc5d41be2d2e3c01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3ODczNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1040#discussion_r503578736", "bodyText": "Prefetching is not particularly relevant.\nWith the new plan, the entire index scan must be reversed to accomplish reverse sorting by the first field, which means that we do the odd-2's, then the odd-1's, then odd-0's. So we have to skip over those first two before getting to any matches and then we get 10 in a row. With the old single-field index plan, we go in reverse primary key order and every third matches, so we get the 10 we need faster.", "author": "MMcM", "createdAt": "2020-10-12T23:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM1NzgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM1ODU3Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1040#discussion_r503358573", "bodyText": "The chosen plan uses a different index that uses a second field (name) to impose a secondary order which is not specified in the test case.", "author": "normen662", "createdAt": "2020-10-12T15:05:25Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/query/FDBRepeatedFieldQueryTest.java", "diffHunk": "@@ -336,17 +338,17 @@ public void sortRepeated() throws Exception {\n                     .setFilter(Query.field(\"name\").greaterThan(\"A\"));\n             RecordQuery query = builder.setRemoveDuplicates(false).build();\n             RecordQueryPlan plan = planner.plan(query);\n-            assertThat(plan, filter(query.getFilter(), indexScan(allOf(indexName(\"customers\"), unbounded()))));\n-            assertEquals(1833106833, plan.planHash());\n-            assertEquals(Arrays.asList(1000L, 1001L, 1000L, 1001L, 1000L, 1000L, 1001L), fetchResultValues(plan, TestRecords4Proto.RestaurantRecord.REST_NO_FIELD_NUMBER,\n+            assertThat(plan, fetch(filter(query.getFilter(), coveringIndexScan(indexScan(allOf(indexName(\"customers-name\"), unbounded()))))));\n+            assertEquals(-505715770, plan.planHash());\n+            assertEquals(Arrays.asList(1000L, 1001L, 1000L, 1001L, 1000L, 1001L, 1000L), fetchResultValues(plan, TestRecords4Proto.RestaurantRecord.REST_NO_FIELD_NUMBER,", "originalCommit": "13542980a4616d1bb7123cfbc5d41be2d2e3c01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3OTQzMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1040#discussion_r503579430", "bodyText": "That is, the better (because we can check the filter using the index key) plan incidentally imposes an order by that key rather than by something like the primary key.", "author": "MMcM", "createdAt": "2020-10-12T23:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM1ODU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM2MjgwOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1040#discussion_r503362809", "bodyText": "This plan change is due to different costing. Previously SCAN() and INDEX_SCAN() where intrinsically considered equal and the PREFER_SCAN configuration parameter was the tie breaker. Now, the index is considered better as the filter on header/{id GREATER THAN 100} can be applied on the index key. Not sure if we want it like this.", "author": "normen662", "createdAt": "2020-10-12T15:12:26Z", "path": "fdb-record-layer-core/src/test/java/com/apple/foundationdb/record/provider/foundationdb/indexes/RankIndexTest.java", "diffHunk": "@@ -1116,8 +1116,7 @@ public void headerRankAndIdQuery() throws Exception {\n                 .build();\n         planner.setIndexScanPreference(QueryPlanner.IndexScanPreference.PREFER_SCAN);\n         RecordQueryPlan plan = planner.plan(query);\n-        assertEquals(\"Scan(([buffaloes, 100],[buffaloes]]) | [HeaderRankedRecord]\" +\n-                        \" | score LESS_THAN $__rank_0 WHERE __rank_0 = score_by_nested_id.score_for_rank_else_skip(buffaloes, 2)\",\n+        assertEquals(\"Fetch(Covering(Index(score_by_nested_id ([buffaloes, null],[buffaloes, 2]) BY_RANK) -> [score: KEY[1], header: [group: KEY[0], id: KEY[2]]]) | header/{id GREATER_THAN 100})\",", "originalCommit": "13542980a4616d1bb7123cfbc5d41be2d2e3c01c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MDg5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1040#discussion_r503580892", "bodyText": "SCAN gives us something that is capable of evaluating the predicate with no further database traffic. More data is fetched in the scan itself. Whether this matters depends on the selectivity: if most pass, then we end up doing a fetch of the record anyway, using a less-efficient (even in parallel) single point fetch.\nI kind of expected that all filters to a SCAN would be index filters and not residuals. With that change, the same tie would result, restoring the status quo, right?", "author": "MMcM", "createdAt": "2020-10-12T23:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM2MjgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkxODA4MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1040#discussion_r504918081", "bodyText": "It does! I have added that functionality.", "author": "normen662", "createdAt": "2020-10-14T19:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM2MjgwOQ=="}], "type": "inlineReview"}, {"oid": "775eefa968b683aa26c03b833a2f05b6104b7215", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/775eefa968b683aa26c03b833a2f05b6104b7215", "message": "Resolves #1039: partition residual filters into index fiters and true residuals", "committedDate": "2020-10-12T15:57:51Z", "type": "forcePushed"}, {"oid": "7df62c83cdc433a108a3c01ccbb6763b23dc688d", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/7df62c83cdc433a108a3c01ccbb6763b23dc688d", "message": "Resolves #1039: partition residual filters into index fiters and true residuals", "committedDate": "2020-10-12T19:26:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MjM4Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/1040#discussion_r503582383", "bodyText": "A RecordQueryScanPlan could treat all filters as index filters and not residuals, I think.", "author": "MMcM", "createdAt": "2020-10-12T23:24:18Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/RecordQueryPlanner.java", "diffHunk": "@@ -517,9 +566,38 @@ private ScoredPlan planIndex(@Nonnull PlanContext planContext, @Nonnull QueryCom\n                 }\n             }\n         }\n+\n         return p;\n     }\n \n+    private ScoredPlan computeIndexFilters(@Nonnull PlanContext planContext, @Nonnull final ScoredPlan plan) {\n+        if (plan.plan instanceof RecordQueryPlanWithIndex) {", "originalCommit": "7df62c83cdc433a108a3c01ccbb6763b23dc688d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8289d20e9028339765a108db42798df7ac12ced1", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/8289d20e9028339765a108db42798df7ac12ced1", "message": "Resolves #1039: partition residual filters into index fiters and true residuals", "committedDate": "2020-10-13T15:56:44Z", "type": "forcePushed"}, {"oid": "28b9b7848a852037a17e6348f27ef84f47fdb44c", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/28b9b7848a852037a17e6348f27ef84f47fdb44c", "message": "Resolves #1039: partition residual filters into index fiters and true residuals", "committedDate": "2020-10-14T19:23:38Z", "type": "commit"}, {"oid": "28b9b7848a852037a17e6348f27ef84f47fdb44c", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/28b9b7848a852037a17e6348f27ef84f47fdb44c", "message": "Resolves #1039: partition residual filters into index fiters and true residuals", "committedDate": "2020-10-14T19:23:38Z", "type": "forcePushed"}]}