{"pr_number": 951, "pr_title": "Resolves #950: introduce the concept of a quantifier to the data flow\u2026", "pr_createdAt": "2020-05-20T16:37:18Z", "pr_url": "https://github.com/FoundationDB/fdb-record-layer/pull/951", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE1NjE0Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428156142", "bodyText": "Quantifiers.java", "author": "normen662", "createdAt": "2020-05-20T16:40:22Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2MjI5Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430162297", "bodyText": "Done", "author": "normen662", "createdAt": "2020-05-26T05:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE1NjE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMzNTA2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429335061", "bodyText": "I found the phrasing on these javadocs confusing, specifically the beginning part that is not really a sentence really threw me off and seems unnecessary.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n          \n          \n            \n                 * the owning expression.\n          \n          \n            \n                 * A quantifier that conceptually flows one record at a time from the expression it ranges over to\n          \n          \n            \n                 * the owning expression.", "author": "ScottDugas", "createdAt": "2020-05-22T16:14:31Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMzNzQ1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429337454", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n          \n          \n            \n                 * A quantifier that conceptually flows exactly one record containing a boolean to the owning", "author": "ScottDugas", "createdAt": "2020-05-22T16:19:05Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMzODcxNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429338715", "bodyText": "OK, this one I just don't understand. Why would you ever use this?", "author": "ScottDugas", "createdAt": "2020-05-22T16:21:33Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMzODc4Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429338782", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n          \n          \n            \n                @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and hashCode() should be overwritten which is not necessary", "author": "ScottDugas", "createdAt": "2020-05-22T16:21:41Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n+     * by the record plans themselves.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMzODkyMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429338921", "bodyText": "Any idea why ForEach is not an issue?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n          \n          \n            \n                @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and hashCode() should be overwritten which is not necessary", "author": "ScottDugas", "createdAt": "2020-05-22T16:22:01Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0MTcwOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429341708", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Quantifier.java\n          \n          \n            \n             * Quantifiers.java", "author": "ScottDugas", "createdAt": "2020-05-22T16:27:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0MTg1NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429341854", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n          \n          \n            \n             * Auxiliary class containing factory methods and helpers for {@link Quantifier}.", "author": "ScottDugas", "createdAt": "2020-05-22T16:28:10Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2Njk2MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430166961", "bodyText": "resolved in other comment suggestion", "author": "normen662", "createdAt": "2020-05-26T05:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0MTg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0NTMyMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429345321", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // since we do visit expression references in this property we can insist on rangesOverResult not being null\n          \n          \n            \n                    // since we visit the expression reference under the quantifier, and don't return null ourselves, we can\n          \n          \n            \n                    // insist that rangesOverResult is never null", "author": "ScottDugas", "createdAt": "2020-05-22T16:35:41Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/explain/PlannerGraphProperty.java", "diffHunk": "@@ -323,4 +331,12 @@ public PlannerGraph evaluateAtRef(@Nonnull ExpressionRef<? extends RelationalExp\n             return Iterables.getOnlyElement(memberResults);\n         }\n     }\n+\n+    @Nonnull\n+    @Override\n+    @SpotBugsSuppressWarnings(\"NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE\")\n+    public PlannerGraph evaluateAtQuantifier(@Nonnull final Quantifier quantifier, @Nullable final PlannerGraph rangesOverResult) {\n+        // since we do visit expression references in this property we can insist on rangesOverResult not being null", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2MDMxMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430460312", "bodyText": "done", "author": "normen662", "createdAt": "2020-05-26T14:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0NTMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0OTI4NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429349285", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // since we do visit expression references in this property we can insist on rangesOverResult not being null\n          \n          \n            \n                    // since we visit the expression reference under the quantifier, and don't return null ourselves, we can\n          \n          \n            \n                    // insist that rangesOverResult is never null", "author": "ScottDugas", "createdAt": "2020-05-22T16:44:12Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/CreatesDuplicatesProperty.java", "diffHunk": "@@ -104,4 +113,12 @@ public static boolean evaluate(@Nonnull RelationalExpression expression, @Nonnul\n         // Won't actually be null for relational planner expressions.\n         return expression.acceptPropertyVisitor(new CreatesDuplicatesProperty(context));\n     }\n+\n+    @Nonnull\n+    @Override\n+    @SpotBugsSuppressWarnings(\"NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE\")\n+    public Boolean evaluateAtQuantifier(@Nonnull final Quantifier quantifier, @Nullable final Boolean rangesOverResult) {\n+        // since we do visit expression references in this property we can insist on rangesOverResult not being null", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0OTM2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429349366", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // since we do visit expression references in this property we can insist on rangesOverResult not being null\n          \n          \n            \n                    // since we visit the expression reference under the quantifier, and don't return null ourselves, we can\n          \n          \n            \n                    // insist that rangesOverResult is never null", "author": "ScottDugas", "createdAt": "2020-05-22T16:44:19Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/ElementPredicateCountProperty.java", "diffHunk": "@@ -104,4 +113,12 @@ public static int evaluate(@Nonnull RelationalExpression expression) {\n         }\n         return result;\n     }\n+\n+    @Nonnull\n+    @Override\n+    @SpotBugsSuppressWarnings(\"NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE\")\n+    public Integer evaluateAtQuantifier(@Nonnull final Quantifier quantifier, @Nullable final Integer rangesOverResult) {\n+        // since we do visit expression references in this property we can insist on rangesOverResult not being null", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0OTY3Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429349676", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // since we do visit expression references in this property we can insist on rangesOverResult not being null\n          \n          \n            \n                    // since we visit the expression reference under the quantifier, and don't return null ourselves, we can\n          \n          \n            \n                    // insist that rangesOverResult is never null", "author": "ScottDugas", "createdAt": "2020-05-22T16:44:44Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/FieldWithComparisonCountProperty.java", "diffHunk": "@@ -109,4 +118,12 @@ public static int evaluate(@Nonnull RelationalExpression expression) {\n         }\n         return result;\n     }\n+\n+    @Nonnull\n+    @Override\n+    @SpotBugsSuppressWarnings(\"NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE\")\n+    public Integer evaluateAtQuantifier(@Nonnull final Quantifier quantifier, @Nullable final Integer rangesOverResult) {\n+        // since we do visit expression references in this property we can insist on rangesOverResult not being null", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0OTc2Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429349762", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // since we do visit expression references in this property we can insist on rangesOverResult not being null\n          \n          \n            \n                    // since we visit the expression reference under the quantifier, and don't return null ourselves, we can\n          \n          \n            \n                    // insist that rangesOverResult is never null", "author": "ScottDugas", "createdAt": "2020-05-22T16:44:51Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/RecordTypesProperty.java", "diffHunk": "@@ -152,4 +161,12 @@ public boolean shouldVisit(@Nonnull ExpressionRef<? extends RelationalExpression\n     public static Set<String> evaluate(@Nonnull PlanContext context, @Nonnull RelationalExpression ref) {\n         return ref.acceptPropertyVisitor(new RecordTypesProperty(context));\n     }\n+\n+    @Nonnull\n+    @Override\n+    @SpotBugsSuppressWarnings(\"NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE\")\n+    public Set<String> evaluateAtQuantifier(@Nonnull final Quantifier quantifier, @Nullable final Set<String> rangesOverResult) {\n+        // since we do visit expression references in this property we can insist on rangesOverResult not being null", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM1MDYwMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429350601", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // since we do visit expression references in this property we can insist on rangesOverResult not being null\n          \n          \n            \n                    // since we visit the expression reference under the quantifier, and don't return null ourselves, we can\n          \n          \n            \n                    // insist that rangesOverResult is never null", "author": "ScottDugas", "createdAt": "2020-05-22T16:45:55Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/RelationalExpressionDepthProperty.java", "diffHunk": "@@ -90,4 +99,11 @@ public int evaluate(@Nonnull RelationalExpression expression) {\n         return expression.acceptPropertyVisitor(this);\n     }\n \n+    @Nonnull\n+    @Override\n+    @SpotBugsSuppressWarnings(\"NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE\")\n+    public Integer evaluateAtQuantifier(@Nonnull final Quantifier quantifier, @Nullable final Integer rangesOverResult) {\n+        // since we do visit expression references in this property we can insist on rangesOverResult not being null", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM1MDczNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429350735", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // since we do visit expression references in this property we can insist on rangesOverResult not being null\n          \n          \n            \n                    // since we visit the expression reference under the quantifier, and don't return null ourselves, we can\n          \n          \n            \n                    // insist that rangesOverResult is never null", "author": "ScottDugas", "createdAt": "2020-05-22T16:46:07Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/TypeFilterCountProperty.java", "diffHunk": "@@ -85,4 +94,12 @@ public static int evaluate(@Nonnull RelationalExpression expression) {\n         }\n         return result;\n     }\n+\n+    @Nonnull\n+    @Override\n+    @SpotBugsSuppressWarnings(\"NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE\")\n+    public Integer evaluateAtQuantifier(@Nonnull final Quantifier quantifier, @Nullable final Integer rangesOverResult) {\n+        // since we do visit expression references in this property we can insist on rangesOverResult not being null", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM1MTAzOQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429351039", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // since we do visit expression references in this property we can insist on rangesOverResult not being null\n          \n          \n            \n                    // since we visit the expression reference under the quantifier, and don't return null ourselves, we can\n          \n          \n            \n                    // insist that rangesOverResult is never null", "author": "ScottDugas", "createdAt": "2020-05-22T16:46:34Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/UnmatchedFieldsProperty.java", "diffHunk": "@@ -119,4 +128,12 @@ public static int evaluate(@Nonnull PlanContext context, @Nonnull RelationalExpr\n         }\n         return result;\n     }\n+\n+    @Nonnull\n+    @Override\n+    @SpotBugsSuppressWarnings(\"NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE\")\n+    public Integer evaluateAtQuantifier(@Nonnull final Quantifier quantifier, @Nullable final Integer rangesOverResult) {\n+        // since we do visit expression references in this property we can insist on rangesOverResult not being null", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI4MzM3MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428283370", "bodyText": "I think that we decided that RecordQueryCoveringIndexPlan.indexPlan shouldn't be a reference, since it doesn't make much sense to memoize.", "author": "nschiefer", "createdAt": "2020-05-20T20:18:27Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -65,9 +66,9 @@ public RecordQueryCoveringIndexPlan(@Nonnull final String indexName, @Nonnull In\n         this(new RecordQueryIndexPlan(indexName, scanType, comparisons, reverse), recordTypeName, toRecord);\n     }\n \n-    public RecordQueryCoveringIndexPlan(@Nonnull RecordQueryPlanWithIndex plan,\n+    public RecordQueryCoveringIndexPlan(@Nonnull RecordQueryPlanWithIndex indexPlan,\n                                         @Nonnull final String recordTypeName, @Nonnull IndexKeyValueToPartialRecord toRecord) {\n-        this.indexPlan = GroupExpressionRef.of(plan);\n+        this.indexPlan = GroupExpressionRef.of(indexPlan);", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2NDA0NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430464044", "bodyText": "done", "author": "normen662", "createdAt": "2020-05-26T14:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI4MzM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI4MzU4OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428283589", "bodyText": "Similarly, I don't think that there should be a quantifier here.", "author": "nschiefer", "createdAt": "2020-05-20T20:18:54Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -190,7 +193,7 @@ public int planHash() {\n     @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public Iterator<? extends ExpressionRef<? extends RelationalExpression>> getPlannerExpressionChildren() {\n-        return Iterators.singletonIterator(indexPlan);\n+    public List<? extends Quantifier> getQuantifiers() {\n+        return ImmutableList.of(Quantifier.physical(indexPlan));", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2NDEzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430464131", "bodyText": "done", "author": "normen662", "createdAt": "2020-05-26T14:39:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI4MzU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NjA5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428296095", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * using a variant of the hierarchical visitor pattern over a dag of {@link RelationalExpression}s, {@link Quantifier},\n          \n          \n            \n             * using a variant of the hierarchical visitor pattern over a DAG of {@link RelationalExpression}s, {@link Quantifier}s,", "author": "nschiefer", "createdAt": "2020-05-20T20:43:47Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/PlannerProperty.java", "diffHunk": "@@ -36,20 +37,24 @@\n  *\n  * <p>\n  * To avoid littering {@link RelationalExpression} classes with methods for various properties, properties are implemented\n- * using a variant of the hierarchical visitor pattern the tree of {@code PlannerExpression}s and {@link ExpressionRef}s.\n- * A property can be evaluated against an expression tree by having the visitor traverse the tree. Note that the\n- * \"{@code visitLeave()}\" methods {@link #evaluateAtExpression} and {@link #evaluateAtRef} are handed the results of the\n- * visitor evaluated at their children and members respectively. Since most properties are easy to describe as a\n- * recursion with depth one, this makes properties easier to read and write.\n- * </p>\n+ * using a variant of the hierarchical visitor pattern over a dag of {@link RelationalExpression}s, {@link Quantifier},", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NjQ1Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428296453", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * again. Shared sub graphs are visited multiple times. If desired, the caller must ensure that a sub graph is not\n          \n          \n            \n             * again. Shared sub graphs are visited multiple times. If desired, the caller must ensure that a sub-graph is not", "author": "nschiefer", "createdAt": "2020-05-20T20:44:35Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/PlannerProperty.java", "diffHunk": "@@ -36,20 +37,24 @@\n  *\n  * <p>\n  * To avoid littering {@link RelationalExpression} classes with methods for various properties, properties are implemented\n- * using a variant of the hierarchical visitor pattern the tree of {@code PlannerExpression}s and {@link ExpressionRef}s.\n- * A property can be evaluated against an expression tree by having the visitor traverse the tree. Note that the\n- * \"{@code visitLeave()}\" methods {@link #evaluateAtExpression} and {@link #evaluateAtRef} are handed the results of the\n- * visitor evaluated at their children and members respectively. Since most properties are easy to describe as a\n- * recursion with depth one, this makes properties easier to read and write.\n- * </p>\n+ * using a variant of the hierarchical visitor pattern over a dag of {@link RelationalExpression}s, {@link Quantifier},\n+ * and {@link ExpressionRef}s.\n+ * A property can be evaluated against an expression tree by having the visitor traverse a DAG of heterogeneous objects\n+ * where expressions are said to own quantifiers which range over expression references which then contain expressions\n+ * again. Shared sub graphs are visited multiple times. If desired, the caller must ensure that a sub graph is not", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NjU2OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428296568", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * revisited if visited before.\n          \n          \n            \n             * visited more than once.", "author": "nschiefer", "createdAt": "2020-05-20T20:44:48Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/PlannerProperty.java", "diffHunk": "@@ -36,20 +37,24 @@\n  *\n  * <p>\n  * To avoid littering {@link RelationalExpression} classes with methods for various properties, properties are implemented\n- * using a variant of the hierarchical visitor pattern the tree of {@code PlannerExpression}s and {@link ExpressionRef}s.\n- * A property can be evaluated against an expression tree by having the visitor traverse the tree. Note that the\n- * \"{@code visitLeave()}\" methods {@link #evaluateAtExpression} and {@link #evaluateAtRef} are handed the results of the\n- * visitor evaluated at their children and members respectively. Since most properties are easy to describe as a\n- * recursion with depth one, this makes properties easier to read and write.\n- * </p>\n+ * using a variant of the hierarchical visitor pattern over a dag of {@link RelationalExpression}s, {@link Quantifier},\n+ * and {@link ExpressionRef}s.\n+ * A property can be evaluated against an expression tree by having the visitor traverse a DAG of heterogeneous objects\n+ * where expressions are said to own quantifiers which range over expression references which then contain expressions\n+ * again. Shared sub graphs are visited multiple times. If desired, the caller must ensure that a sub graph is not\n+ * revisited if visited before.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5NzYxNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428297614", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Return whether the property should visit the sub graph rooted at the given expression.\n          \n          \n            \n                 * Return whether the property should visit the sub-graph rooted at the given expression.", "author": "nschiefer", "createdAt": "2020-05-20T20:46:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/PlannerProperty.java", "diffHunk": "@@ -36,20 +37,24 @@\n  *\n  * <p>\n  * To avoid littering {@link RelationalExpression} classes with methods for various properties, properties are implemented\n- * using a variant of the hierarchical visitor pattern the tree of {@code PlannerExpression}s and {@link ExpressionRef}s.\n- * A property can be evaluated against an expression tree by having the visitor traverse the tree. Note that the\n- * \"{@code visitLeave()}\" methods {@link #evaluateAtExpression} and {@link #evaluateAtRef} are handed the results of the\n- * visitor evaluated at their children and members respectively. Since most properties are easy to describe as a\n- * recursion with depth one, this makes properties easier to read and write.\n- * </p>\n+ * using a variant of the hierarchical visitor pattern over a dag of {@link RelationalExpression}s, {@link Quantifier},\n+ * and {@link ExpressionRef}s.\n+ * A property can be evaluated against an expression tree by having the visitor traverse a DAG of heterogeneous objects\n+ * where expressions are said to own quantifiers which range over expression references which then contain expressions\n+ * again. Shared sub graphs are visited multiple times. If desired, the caller must ensure that a sub graph is not\n+ * revisited if visited before.\n+ *\n+ * Note that the methods {@link #evaluateAtExpression}, {@link #evaluateAtQuantifier}, and {@link #evaluateAtRef} are handed the\n+ * results of the visitor evaluated at their owned quantifiers, references, and members respectively. Since most properties\n+ * are easy to describe as a recursion with depth one, this makes properties easier to read and write.\n  *\n  * @param <T> the result type of the property\n  */\n @API(API.Status.EXPERIMENTAL)\n public interface PlannerProperty<T> {\n     /**\n-     * Return whether the property should visit the subtree rooted at the given expression.\n-     * Called on nodes in the expression tree in visit pre-order of the depth-first traversal of the tree.\n+     * Return whether the property should visit the sub graph rooted at the given expression.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5ODI0Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428298247", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Return whether the property should visit the given expression reference and by transitive property the expressions\n          \n          \n            \n                 * the {@link ExpressionRef} references.\n          \n          \n            \n                 * Return whether the property should visit the given reference and, transitively, the members of the reference.", "author": "nschiefer", "createdAt": "2020-05-20T20:48:02Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/PlannerProperty.java", "diffHunk": "@@ -59,21 +64,35 @@\n     boolean shouldVisit(@Nonnull RelationalExpression expression);\n \n     /**\n-     * Return whether the property should visit the subtree rooted at the given expression.\n-     * Called on nodes in the expression tree in visit pre-order of the depth-first traversal of the tree.\n-     * That is, as each node is visited for the first time, {@code shouldVisit()} is called on that node.\n+     * Return whether the property should visit the given expression reference and by transitive property the expressions\n+     * the {@link ExpressionRef} references.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5ODQ4Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428298487", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * not be called on the given expression reference.\n          \n          \n            \n                 * not be called on the given reference.", "author": "nschiefer", "createdAt": "2020-05-20T20:48:28Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/PlannerProperty.java", "diffHunk": "@@ -59,21 +64,35 @@\n     boolean shouldVisit(@Nonnull RelationalExpression expression);\n \n     /**\n-     * Return whether the property should visit the subtree rooted at the given expression.\n-     * Called on nodes in the expression tree in visit pre-order of the depth-first traversal of the tree.\n-     * That is, as each node is visited for the first time, {@code shouldVisit()} is called on that node.\n+     * Return whether the property should visit the given expression reference and by transitive property the expressions\n+     * the {@link ExpressionRef} references.\n+     * Called on expression references in the graph in visit pre-order of the depth-first traversal of the graph.\n+     * That is, as a reference is visited, {@code shouldVisit()} is called on that reference.\n      * If {@code shouldVisit()} returns {@code false}, then {@link #evaluateAtRef(ExpressionRef, List)} will\n-     * not be called on the given expression.\n+     * not be called on the given expression reference.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMDAxMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428300011", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Return whether the property should visit the given quantifier and the expression reference that the quantifier\n          \n          \n            \n                 * Return whether the property should visit the given quantifier and the references that the quantifier", "author": "nschiefer", "createdAt": "2020-05-20T20:51:34Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/PlannerProperty.java", "diffHunk": "@@ -59,21 +64,35 @@\n     boolean shouldVisit(@Nonnull RelationalExpression expression);\n \n     /**\n-     * Return whether the property should visit the subtree rooted at the given expression.\n-     * Called on nodes in the expression tree in visit pre-order of the depth-first traversal of the tree.\n-     * That is, as each node is visited for the first time, {@code shouldVisit()} is called on that node.\n+     * Return whether the property should visit the given expression reference and by transitive property the expressions\n+     * the {@link ExpressionRef} references.\n+     * Called on expression references in the graph in visit pre-order of the depth-first traversal of the graph.\n+     * That is, as a reference is visited, {@code shouldVisit()} is called on that reference.\n      * If {@code shouldVisit()} returns {@code false}, then {@link #evaluateAtRef(ExpressionRef, List)} will\n-     * not be called on the given expression.\n+     * not be called on the given expression reference.\n      * @param ref the expression reference to visit\n      * @return {@code true} if the members of {@code ref} should be visited and {@code false} if they should not be visited\n      */\n     boolean shouldVisit(@Nonnull ExpressionRef<? extends RelationalExpression> ref);\n \n+    /**\n+     * Return whether the property should visit the given quantifier and the expression reference that the quantifier", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMDc4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428300784", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Evaluate the property at the given quantifier, using the result of evaluating the property at the expression\n          \n          \n            \n                 * Evaluate the property at the given quantifier, using the result of evaluating the property at the", "author": "nschiefer", "createdAt": "2020-05-20T20:53:06Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/PlannerProperty.java", "diffHunk": "@@ -83,13 +102,27 @@\n \n     /**\n      * Evaluate the property at the given reference, using the results of evaluating the property at its members.\n-     * Called on nodes in the expression tree in visit post-order of the depth-first traversal of the tree.\n-     * That is, as each node is visited for the last time (after all of its children have been visited, if applicable),\n-     * {@code evaluateAtRef()} is called on that node.\n+     * Called on nodes in the graph in visit post-order of the depth-first traversal of the graph.\n+     * That is, as each reference is visited (after all of its members have been visited, if applicable),\n+     * {@code evaluateAtRef()} is called on that reference.\n      * @param ref the expression reference to visit\n      * @param memberResults the results of the property evaluated at the members of {@code ref}\n      * @return the value of property at the given reference\n      */\n     @Nonnull\n     T evaluateAtRef(@Nonnull ExpressionRef<? extends RelationalExpression> ref, @Nonnull List<T> memberResults);\n+\n+    /**\n+     * Evaluate the property at the given quantifier, using the result of evaluating the property at the expression", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMTQxMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428301412", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n          \n          \n            \n             * A quantifier describes the data flow between the output of one {@link RelationalExpression} {@code R} and the", "author": "nschiefer", "createdAt": "2020-05-20T20:54:19Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMTYyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428301620", "bodyText": "Probably don't need both links here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n          \n          \n            \n             * consumption of that data by another {@code RelationalExpression} {@code S}. {@code S} is said to own the quantifier, while the", "author": "nschiefer", "createdAt": "2020-05-20T20:54:44Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMTc0OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428301748", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n          \n          \n            \n             * quantifier is said to range over {@code R}. Quantifiers come in very few but very distinct flavors. All flavors are", "author": "nschiefer", "createdAt": "2020-05-20T20:54:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMTkyMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428301923", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * implemented by static inner final classes as to emulate a sealed trait.\n          \n          \n            \n             * implemented by static inner final classes in order to emulate a sealed trait.\n          \n      \n    \n    \n  \n\nOh, Java...", "author": "nschiefer", "createdAt": "2020-05-20T20:55:16Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMjM5NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428302395", "bodyText": "I think it would be conventional to separate the paragraphs of this class-level Javadoc with HTML paragraph tags <p></p>.", "author": "nschiefer", "createdAt": "2020-05-20T20:56:07Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2NjEzMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430466132", "bodyText": "done", "author": "normen662", "createdAt": "2020-05-26T14:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMjM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMjYxMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428302612", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n          \n          \n            \n             * produces records, the quantifier flows information (in a manner determined by the flavor) that is consumed by the expression", "author": "nschiefer", "createdAt": "2020-05-20T20:56:33Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzM1Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428303353", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n          \n          \n            \n             * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n          \n          \n            \n             * at the owning (join) expression.\n          \n          \n            \n             * it becomes possible to model correlations. For example, in a logical join expression the quantifier can provide a binding\n          \n          \n            \n             * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n          \n          \n            \n             * at the owning (join) expression.", "author": "nschiefer", "createdAt": "2020-05-20T20:58:03Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzgwNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428303804", "bodyText": "I think that quantifiers can pass things other than \"records\". Perhaps \"item (such as a record) is a more useful description?", "author": "nschiefer", "createdAt": "2020-05-20T20:58:54Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2OTQ0OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430469448", "bodyText": "done", "author": "normen662", "createdAt": "2020-05-26T14:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwMzgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNDI2OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428304268", "bodyText": "Likewise, I think something other than \"record\" will paint a clearer picture.", "author": "nschiefer", "createdAt": "2020-05-20T20:59:48Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2OTU1Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430469552", "bodyText": "done", "author": "normen662", "createdAt": "2020-05-26T14:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNDI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNDQ3OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428304478", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n          \n          \n            \n                 * expression indicating whether the sub-graph that the quantifier ranges over produced a non-empty or an empty", "author": "nschiefer", "createdAt": "2020-05-20T21:00:12Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNDYzOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428304638", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n          \n          \n            \n                 * facilitate a boolean \"short-circuit\" mechanism as the result will be {@code record(true)} as soon as the sub-graph produces", "author": "nschiefer", "createdAt": "2020-05-20T21:00:35Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNTI1Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428305257", "bodyText": "I think that we do need to override equals() and hashCode(). It seems that the implementation of equals() in Quantifier assumes that the quantifier is ForEach. Am I missing something?", "author": "nschiefer", "createdAt": "2020-05-20T21:01:53Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n+     * by the record plans themselves.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNTYxMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428305611", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n          \n          \n            \n                 * not have any associated semantics; all semantics and execution details must be subsumed", "author": "nschiefer", "createdAt": "2020-05-20T21:02:35Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNTY2Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428305667", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * by the record plans themselves.\n          \n          \n            \n                 * by the query plans themselves.", "author": "nschiefer", "createdAt": "2020-05-20T21:02:43Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n+     * by the record plans themselves.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNTk5NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428305994", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Factory method to create a physical quantifier over a given expression reference containing record plans.\n          \n          \n            \n                 * Factory method to create a physical quantifier over a given expression reference containing query plans.", "author": "nschiefer", "createdAt": "2020-05-20T21:03:20Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n+     * by the record plans themselves.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Physical extends Quantifier {\n+        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        private Physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RecordQueryPlan> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\ud835\udcc5\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over a given expression reference containing record plans.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjA2NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428306064", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a physical quantifier ranging over the given expression reference\n          \n          \n            \n                 * @return a physical quantifier ranging over the given reference", "author": "nschiefer", "createdAt": "2020-05-20T21:03:30Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n+     * by the record plans themselves.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Physical extends Quantifier {\n+        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        private Physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RecordQueryPlan> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\ud835\udcc5\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over a given expression reference containing record plans.\n+     * @param rangesOver expression reference to {@link RecordQueryPlan}s\n+     * @return a physical quantifier ranging over the given expression reference", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjM3OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428306379", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Physical physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n          \n          \n            \n                public static Physical physical(@Nonnull final ExpressionRef<? extends RecordQueryPlan> rangesOver) {", "author": "nschiefer", "createdAt": "2020-05-20T21:04:12Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n+     * by the record plans themselves.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Physical extends Quantifier {\n+        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        private Physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RecordQueryPlan> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\ud835\udcc5\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over a given expression reference containing record plans.\n+     * @param rangesOver expression reference to {@link RecordQueryPlan}s\n+     * @return a physical quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjQ3NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428306474", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private Physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n          \n          \n            \n                    private Physical(@Nonnull final ExpressionRef<? extends RecordQueryPlan> rangesOver) {", "author": "nschiefer", "createdAt": "2020-05-20T21:04:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n+     * by the record plans themselves.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Physical extends Quantifier {\n+        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        private Physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjU4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428306584", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n          \n          \n            \n                public static Existential existential(@Nonnull final ExpressionRef<? extends RelationalExpression> rangesOver) {", "author": "nschiefer", "createdAt": "2020-05-20T21:04:38Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNjkzMQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428306931", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Physical physical(final RecordQueryPlan rangesOverPlan) {\n          \n          \n            \n                public static Physical physical(@Nonnull final RecordQueryPlan rangesOverPlan) {", "author": "nschiefer", "createdAt": "2020-05-20T21:05:24Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n+     * by the record plans themselves.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Physical extends Quantifier {\n+        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        private Physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RecordQueryPlan> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\ud835\udcc5\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over a given expression reference containing record plans.\n+     * @param rangesOver expression reference to {@link RecordQueryPlan}s\n+     * @return a physical quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+        return new Physical(rangesOver);\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over newly created expression reference containing the given\n+     * record plan.\n+     * @param rangesOverPlan {@link RecordQueryPlan} the new quantifier should range over.\n+     * @return a physical quantifier ranging over a new expression reference containing the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(final RecordQueryPlan rangesOverPlan) {", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxNTc0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428315745", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * not distract from expressions when e.g. a data flow is visualized the returned string should be _short_.\n          \n          \n            \n                 * not distract from expressions. For example, when a data flow is visualized the returned string should be <em>short</em>.\n          \n          \n            \n            ``", "author": "nschiefer", "createdAt": "2020-05-20T21:24:46Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n+     * by the record plans themselves.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Physical extends Quantifier {\n+        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        private Physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RecordQueryPlan> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\ud835\udcc5\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over a given expression reference containing record plans.\n+     * @param rangesOver expression reference to {@link RecordQueryPlan}s\n+     * @return a physical quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+        return new Physical(rangesOver);\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over newly created expression reference containing the given\n+     * record plan.\n+     * @param rangesOverPlan {@link RecordQueryPlan} the new quantifier should range over.\n+     * @return a physical quantifier ranging over a new expression reference containing the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(final RecordQueryPlan rangesOverPlan) {\n+        return new Physical(GroupExpressionRef.of(rangesOverPlan));\n+    }\n+\n+    /**\n+     * Getter to retrieve the expression reference the quantifier ranges over.\n+     * @return {@link ExpressionRef} this quantifier ranges over\n+     */\n+    @Nonnull\n+    public abstract ExpressionRef<? extends RelationalExpression> getRangesOver();\n+\n+    /**\n+     * Return a short hand string for the quantifier. As a quantifier's semantics is usually quite subtle and should\n+     * not distract from expressions when e.g. a data flow is visualized the returned string should be _short_.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxNjEwMw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428316103", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Getter to retrieve the expression reference the quantifier ranges over.\n          \n          \n            \n                 * Return the reference that the quantifier ranges over.", "author": "nschiefer", "createdAt": "2020-05-20T21:25:26Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n+     * by the record plans themselves.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Physical extends Quantifier {\n+        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        private Physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RecordQueryPlan> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\ud835\udcc5\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over a given expression reference containing record plans.\n+     * @param rangesOver expression reference to {@link RecordQueryPlan}s\n+     * @return a physical quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+        return new Physical(rangesOver);\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over newly created expression reference containing the given\n+     * record plan.\n+     * @param rangesOverPlan {@link RecordQueryPlan} the new quantifier should range over.\n+     * @return a physical quantifier ranging over a new expression reference containing the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(final RecordQueryPlan rangesOverPlan) {\n+        return new Physical(GroupExpressionRef.of(rangesOverPlan));\n+    }\n+\n+    /**\n+     * Getter to retrieve the expression reference the quantifier ranges over.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxNjYxOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428316618", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * This method allows for computation of {@link PlannerProperty}s across the data flow graph.\n          \n          \n            \n                 * Allow the computation of {@link PlannerProperty}s across the quantifiers in the data flow graph.", "author": "nschiefer", "createdAt": "2020-05-20T21:26:29Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n+     * by the record plans themselves.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Physical extends Quantifier {\n+        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        private Physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RecordQueryPlan> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\ud835\udcc5\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over a given expression reference containing record plans.\n+     * @param rangesOver expression reference to {@link RecordQueryPlan}s\n+     * @return a physical quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+        return new Physical(rangesOver);\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over newly created expression reference containing the given\n+     * record plan.\n+     * @param rangesOverPlan {@link RecordQueryPlan} the new quantifier should range over.\n+     * @return a physical quantifier ranging over a new expression reference containing the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(final RecordQueryPlan rangesOverPlan) {\n+        return new Physical(GroupExpressionRef.of(rangesOverPlan));\n+    }\n+\n+    /**\n+     * Getter to retrieve the expression reference the quantifier ranges over.\n+     * @return {@link ExpressionRef} this quantifier ranges over\n+     */\n+    @Nonnull\n+    public abstract ExpressionRef<? extends RelationalExpression> getRangesOver();\n+\n+    /**\n+     * Return a short hand string for the quantifier. As a quantifier's semantics is usually quite subtle and should\n+     * not distract from expressions when e.g. a data flow is visualized the returned string should be _short_.\n+     * @return a short string representing the quantifier.\n+     */\n+    @Nonnull\n+    public abstract String getShorthand();\n+\n+    @Nonnull\n+    @Override\n+    public Stream<PlannerBindings> bindTo(@Nonnull final ExpressionMatcher<? extends Bindable> matcher) {\n+        Stream<PlannerBindings> bindings = matcher.matchWith(this);\n+        return bindings.flatMap(outerBindings -> matcher.getChildrenMatcher().matches(ImmutableList.of(getRangesOver()))\n+                .map(outerBindings::mergedWith));\n+    }\n+\n+    /**\n+     * This method allows for computation of {@link PlannerProperty}s across the data flow graph.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxNjc0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428316740", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param <U> the type of the property we are computing\n          \n          \n            \n                 * @param <U> the type of the property being computed", "author": "nschiefer", "createdAt": "2020-05-20T21:26:44Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n+     * by the record plans themselves.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Physical extends Quantifier {\n+        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        private Physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RecordQueryPlan> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\ud835\udcc5\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over a given expression reference containing record plans.\n+     * @param rangesOver expression reference to {@link RecordQueryPlan}s\n+     * @return a physical quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+        return new Physical(rangesOver);\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over newly created expression reference containing the given\n+     * record plan.\n+     * @param rangesOverPlan {@link RecordQueryPlan} the new quantifier should range over.\n+     * @return a physical quantifier ranging over a new expression reference containing the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(final RecordQueryPlan rangesOverPlan) {\n+        return new Physical(GroupExpressionRef.of(rangesOverPlan));\n+    }\n+\n+    /**\n+     * Getter to retrieve the expression reference the quantifier ranges over.\n+     * @return {@link ExpressionRef} this quantifier ranges over\n+     */\n+    @Nonnull\n+    public abstract ExpressionRef<? extends RelationalExpression> getRangesOver();\n+\n+    /**\n+     * Return a short hand string for the quantifier. As a quantifier's semantics is usually quite subtle and should\n+     * not distract from expressions when e.g. a data flow is visualized the returned string should be _short_.\n+     * @return a short string representing the quantifier.\n+     */\n+    @Nonnull\n+    public abstract String getShorthand();\n+\n+    @Nonnull\n+    @Override\n+    public Stream<PlannerBindings> bindTo(@Nonnull final ExpressionMatcher<? extends Bindable> matcher) {\n+        Stream<PlannerBindings> bindings = matcher.matchWith(this);\n+        return bindings.flatMap(outerBindings -> matcher.getChildrenMatcher().matches(ImmutableList.of(getRangesOver()))\n+                .map(outerBindings::mergedWith));\n+    }\n+\n+    /**\n+     * This method allows for computation of {@link PlannerProperty}s across the data flow graph.\n+     * @param visitor the planner property that is being computed\n+     * @param <U> the type of the property we are computing", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxNjkzMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428316932", "bodyText": "I think this is specialized to ForEach?", "author": "nschiefer", "createdAt": "2020-05-20T21:27:08Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A quantifier is a conduit facilitating the data flow between the output of one {@link RelationalExpression} R and the\n+ * consumption of that data by another {@link RelationalExpression} S. S is said to own the quantifier, while the\n+ * quantifier is said to range over R. Quantifiers come in very few but very distinct flavors. All flavors are\n+ * implemented by static inner final classes as to emulate a sealed trait.\n+ *\n+ * Quantifiers separate what it means to be producing versus consuming records. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (according to the flavor) which is then consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ *\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations,  e.g. for a logical join expression the quantifier can provide a binding\n+ * of the record being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * For Each quantifier. Conceptually flows one record at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * Existential quantifier. Conceptually flows exactly one record containing a boolean to the owning\n+     * expression indicating whether the sub graph the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate an early out mechanism as the result will be {@code record(true)} as soon as the sub graph produces\n+     * the first record.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have an associated semantics as by that time all semantics and execution details must have been subsumed\n+     * by the record plans themselves.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and heshCode() should be overwritten which is not necessary\n+    public static final class Physical extends Quantifier {\n+        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        private Physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RecordQueryPlan> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\ud835\udcc5\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over a given expression reference containing record plans.\n+     * @param rangesOver expression reference to {@link RecordQueryPlan}s\n+     * @return a physical quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+        return new Physical(rangesOver);\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over newly created expression reference containing the given\n+     * record plan.\n+     * @param rangesOverPlan {@link RecordQueryPlan} the new quantifier should range over.\n+     * @return a physical quantifier ranging over a new expression reference containing the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(final RecordQueryPlan rangesOverPlan) {\n+        return new Physical(GroupExpressionRef.of(rangesOverPlan));\n+    }\n+\n+    /**\n+     * Getter to retrieve the expression reference the quantifier ranges over.\n+     * @return {@link ExpressionRef} this quantifier ranges over\n+     */\n+    @Nonnull\n+    public abstract ExpressionRef<? extends RelationalExpression> getRangesOver();\n+\n+    /**\n+     * Return a short hand string for the quantifier. As a quantifier's semantics is usually quite subtle and should\n+     * not distract from expressions when e.g. a data flow is visualized the returned string should be _short_.\n+     * @return a short string representing the quantifier.\n+     */\n+    @Nonnull\n+    public abstract String getShorthand();\n+\n+    @Nonnull\n+    @Override\n+    public Stream<PlannerBindings> bindTo(@Nonnull final ExpressionMatcher<? extends Bindable> matcher) {\n+        Stream<PlannerBindings> bindings = matcher.matchWith(this);\n+        return bindings.flatMap(outerBindings -> matcher.getChildrenMatcher().matches(ImmutableList.of(getRangesOver()))\n+                .map(outerBindings::mergedWith));\n+    }\n+\n+    /**\n+     * This method allows for computation of {@link PlannerProperty}s across the data flow graph.\n+     * @param visitor the planner property that is being computed\n+     * @param <U> the type of the property we are computing\n+     * @return the property\n+     */\n+    @Nullable\n+    public <U> U acceptPropertyVisitor(@Nonnull PlannerProperty<U> visitor) {\n+        if (visitor.shouldVisit(this)) {\n+            return visitor.evaluateAtQuantifier(this, getRangesOver().acceptPropertyVisitor(visitor));\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxNzA2OA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428317068", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n          \n          \n            \n             * Auxiliary class containing factory methods and helpers for {@link Quantifier}.", "author": "nschiefer", "createdAt": "2020-05-20T21:27:26Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxNzI0MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428317240", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Factory method to create a list of for-each quantifiers given a list of expression references these quantifiers should range over.\n          \n          \n            \n                 * Create a list of for-each quantifiers from a list of references to range over.", "author": "nschiefer", "createdAt": "2020-05-20T21:27:51Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n+ */\n+public class Quantifiers {\n+    /**\n+     * Factory method to create a list of for-each quantifiers given a list of expression references these quantifiers should range over.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxNzU0NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428317545", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a list of for-each quantifiers where each quantifier ranges over an expression reference contained in the list of\n          \n          \n            \n                 *         references of relational expressions passed in in order of the references in that iterable.\n          \n          \n            \n                 * @return a list of for-each quantifiers where each quantifier ranges over one of the given references", "author": "nschiefer", "createdAt": "2020-05-20T21:28:34Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n+ */\n+public class Quantifiers {\n+    /**\n+     * Factory method to create a list of for-each quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverExpressions iterable {@link ExpressionRef}s of {@link RelationalExpression}s\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of for-each quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxNzY2Ng==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428317666", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static <E extends RelationalExpression> List<ForEach> forEachQuantifiers(final Iterable<ExpressionRef<E>> rangesOverExpressions) {\n          \n          \n            \n                public static <E extends RelationalExpression> List<ForEach> forEachQuantifiers(@Nonnull final Iterable<ExpressionRef<E>> rangesOverExpressions) {", "author": "nschiefer", "createdAt": "2020-05-20T21:28:50Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n+ */\n+public class Quantifiers {\n+    /**\n+     * Factory method to create a list of for-each quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverExpressions iterable {@link ExpressionRef}s of {@link RelationalExpression}s\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of for-each quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<ForEach> forEachQuantifiers(final Iterable<ExpressionRef<E>> rangesOverExpressions) {", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxNzkxMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428317912", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Factory method to create a list of existential quantifiers given a list of expression references these quantifiers should range over.\n          \n          \n            \n                 * Create a list of existential quantifiers from a list of expression references these quantifiers should range over.", "author": "nschiefer", "createdAt": "2020-05-20T21:29:25Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n+ */\n+public class Quantifiers {\n+    /**\n+     * Factory method to create a list of for-each quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverExpressions iterable {@link ExpressionRef}s of {@link RelationalExpression}s\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of for-each quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<ForEach> forEachQuantifiers(final Iterable<ExpressionRef<E>> rangesOverExpressions) {\n+        return fromExpressions(rangesOverExpressions, Quantifier::forEach);\n+    }\n+\n+    /**\n+     * Factory method to create a list of existential quantifiers given a list of expression references these quantifiers should range over.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxODE4Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428318187", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n          \n          \n            \n                 *         references of relational expressions passed in in order of the references in that iterable.\n          \n          \n            \n                 * @return a list of physical quantifiers where each quantifier ranges over one of the given references", "author": "nschiefer", "createdAt": "2020-05-20T21:29:58Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n+ */\n+public class Quantifiers {\n+    /**\n+     * Factory method to create a list of for-each quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverExpressions iterable {@link ExpressionRef}s of {@link RelationalExpression}s\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of for-each quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<ForEach> forEachQuantifiers(final Iterable<ExpressionRef<E>> rangesOverExpressions) {\n+        return fromExpressions(rangesOverExpressions, Quantifier::forEach);\n+    }\n+\n+    /**\n+     * Factory method to create a list of existential quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverPlans iterable {@link ExpressionRef}s of of {@link RelationalExpression}s.\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxODMwNw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428318307", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static <E extends RelationalExpression> List<Existential> existentialQuantifiers(final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {\n          \n          \n            \n                public static <E extends RelationalExpression> List<Existential> existentialQuantifiers(@Nonnull final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {", "author": "nschiefer", "createdAt": "2020-05-20T21:30:11Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n+ */\n+public class Quantifiers {\n+    /**\n+     * Factory method to create a list of for-each quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverExpressions iterable {@link ExpressionRef}s of {@link RelationalExpression}s\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of for-each quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<ForEach> forEachQuantifiers(final Iterable<ExpressionRef<E>> rangesOverExpressions) {\n+        return fromExpressions(rangesOverExpressions, Quantifier::forEach);\n+    }\n+\n+    /**\n+     * Factory method to create a list of existential quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverPlans iterable {@link ExpressionRef}s of of {@link RelationalExpression}s.\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<Existential> existentialQuantifiers(final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxOTQxOA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428319418", "bodyText": "Perhaps this can be Collections.emptyList() instead?", "author": "nschiefer", "createdAt": "2020-05-20T21:31:56Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/FullUnorderedScanExpression.java", "diffHunk": "@@ -44,8 +44,8 @@\n public class FullUnorderedScanExpression implements RelationalExpression {\n     @Nonnull\n     @Override\n-    public Iterator<? extends ExpressionRef<? extends RelationalExpression>> getPlannerExpressionChildren() {\n-        return Collections.emptyIterator();\n+    public List<? extends Quantifier> getQuantifiers() {\n+        return ImmutableList.of();", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE2NDkyNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430164926", "bodyText": "No, I like my lists immutable, even if they are empty. In all seriousness, I think it's just style. If you use a lot of ImmutableList construction it's quite useful to have them all be ImmutableList as e.g. copyOf() actually avoids the copy if the source is immutable. Doesn't matter here, but that's why I prefer this way of writing it (out of habit).", "author": "normen662", "createdAt": "2020-05-26T05:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxOTQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxOTc3NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r428319774", "bodyText": "Same here.", "author": "nschiefer", "createdAt": "2020-05-20T21:32:30Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/expressions/IndexEntrySourceScanExpression.java", "diffHunk": "@@ -63,8 +63,8 @@ public IndexEntrySourceScanExpression(@Nonnull final IndexEntrySource indexEntry\n \n     @Nonnull\n     @Override\n-    public Iterator<? extends ExpressionRef<? extends RelationalExpression>> getPlannerExpressionChildren() {\n-        return Collections.emptyIterator();\n+    public List<? extends Quantifier> getQuantifiers() {\n+        return ImmutableList.of();", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5MTEwMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429391102", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Factory method to create a list of physical quantifiers given a list of expression references these quantifiers should range over.\n          \n          \n            \n                 * Create a list of physical quantifiers given a list of references these quantifiers should range over.", "author": "nschiefer", "createdAt": "2020-05-22T18:17:45Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n+ */\n+public class Quantifiers {\n+    /**\n+     * Factory method to create a list of for-each quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverExpressions iterable {@link ExpressionRef}s of {@link RelationalExpression}s\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of for-each quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<ForEach> forEachQuantifiers(final Iterable<ExpressionRef<E>> rangesOverExpressions) {\n+        return fromExpressions(rangesOverExpressions, Quantifier::forEach);\n+    }\n+\n+    /**\n+     * Factory method to create a list of existential quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverPlans iterable {@link ExpressionRef}s of of {@link RelationalExpression}s.\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<Existential> existentialQuantifiers(final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {\n+        return fromExpressions(rangesOverPlans, Quantifier::existential);\n+    }\n+\n+    /**\n+     * Factory method to create a list of physical quantifiers given a list of expression references these quantifiers should range over.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5MTI0Nw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429391247", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static <E extends RecordQueryPlan> List<Physical> fromPlans(final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {\n          \n          \n            \n                public static <E extends RecordQueryPlan> List<Physical> fromPlans(@Nonnull final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {", "author": "nschiefer", "createdAt": "2020-05-22T18:18:04Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n+ */\n+public class Quantifiers {\n+    /**\n+     * Factory method to create a list of for-each quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverExpressions iterable {@link ExpressionRef}s of {@link RelationalExpression}s\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of for-each quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<ForEach> forEachQuantifiers(final Iterable<ExpressionRef<E>> rangesOverExpressions) {\n+        return fromExpressions(rangesOverExpressions, Quantifier::forEach);\n+    }\n+\n+    /**\n+     * Factory method to create a list of existential quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverPlans iterable {@link ExpressionRef}s of of {@link RelationalExpression}s.\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<Existential> existentialQuantifiers(final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {\n+        return fromExpressions(rangesOverPlans, Quantifier::existential);\n+    }\n+\n+    /**\n+     * Factory method to create a list of physical quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverPlans iterable {@link ExpressionRef}s of {@link RecordQueryPlan}\n+     * @param <E> type parameter to constrain expressions to {@link RecordQueryPlan}\n+     * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of record query plans passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RecordQueryPlan> List<Physical> fromPlans(final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5MTMxNA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429391314", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Factory method to create a list of quantifiers given a list of expression references these quantifiers should range over.\n          \n          \n            \n                 * Create a list of quantifiers given a list of references these quantifiers should range over.", "author": "nschiefer", "createdAt": "2020-05-22T18:18:15Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n+ */\n+public class Quantifiers {\n+    /**\n+     * Factory method to create a list of for-each quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverExpressions iterable {@link ExpressionRef}s of {@link RelationalExpression}s\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of for-each quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<ForEach> forEachQuantifiers(final Iterable<ExpressionRef<E>> rangesOverExpressions) {\n+        return fromExpressions(rangesOverExpressions, Quantifier::forEach);\n+    }\n+\n+    /**\n+     * Factory method to create a list of existential quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverPlans iterable {@link ExpressionRef}s of of {@link RelationalExpression}s.\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<Existential> existentialQuantifiers(final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {\n+        return fromExpressions(rangesOverPlans, Quantifier::existential);\n+    }\n+\n+    /**\n+     * Factory method to create a list of physical quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverPlans iterable {@link ExpressionRef}s of {@link RecordQueryPlan}\n+     * @param <E> type parameter to constrain expressions to {@link RecordQueryPlan}\n+     * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of record query plans passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RecordQueryPlan> List<Physical> fromPlans(final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {\n+        return fromExpressions(rangesOverPlans, Quantifier::physical);\n+    }\n+\n+    /**\n+     * Factory method to create a list of quantifiers given a list of expression references these quantifiers should range over.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5MTUyMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429391520", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n          \n          \n            \n                 *         references of record query plans passed in in order of the references in that iterable.\n          \n          \n            \n                 * @return a list of physical quantifiers where each quantifier ranges over a reference contained in the given iterable", "author": "nschiefer", "createdAt": "2020-05-22T18:18:49Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n+ */\n+public class Quantifiers {\n+    /**\n+     * Factory method to create a list of for-each quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverExpressions iterable {@link ExpressionRef}s of {@link RelationalExpression}s\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of for-each quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<ForEach> forEachQuantifiers(final Iterable<ExpressionRef<E>> rangesOverExpressions) {\n+        return fromExpressions(rangesOverExpressions, Quantifier::forEach);\n+    }\n+\n+    /**\n+     * Factory method to create a list of existential quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverPlans iterable {@link ExpressionRef}s of of {@link RelationalExpression}s.\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<Existential> existentialQuantifiers(final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {\n+        return fromExpressions(rangesOverPlans, Quantifier::existential);\n+    }\n+\n+    /**\n+     * Factory method to create a list of physical quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverPlans iterable {@link ExpressionRef}s of {@link RecordQueryPlan}\n+     * @param <E> type parameter to constrain expressions to {@link RecordQueryPlan}\n+     * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of record query plans passed in in order of the references in that iterable.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5MTY0MQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429391641", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a list of quantifiers where each quantifier ranges over an expression reference contained in the iterable of\n          \n          \n            \n                 *         references passed in in order of iteration.\n          \n          \n            \n                 * @return a list of quantifiers where each quantifier ranges over an reference contained in the given iterable", "author": "nschiefer", "createdAt": "2020-05-22T18:19:07Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n+ */\n+public class Quantifiers {\n+    /**\n+     * Factory method to create a list of for-each quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverExpressions iterable {@link ExpressionRef}s of {@link RelationalExpression}s\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of for-each quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<ForEach> forEachQuantifiers(final Iterable<ExpressionRef<E>> rangesOverExpressions) {\n+        return fromExpressions(rangesOverExpressions, Quantifier::forEach);\n+    }\n+\n+    /**\n+     * Factory method to create a list of existential quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverPlans iterable {@link ExpressionRef}s of of {@link RelationalExpression}s.\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<Existential> existentialQuantifiers(final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {\n+        return fromExpressions(rangesOverPlans, Quantifier::existential);\n+    }\n+\n+    /**\n+     * Factory method to create a list of physical quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverPlans iterable {@link ExpressionRef}s of {@link RecordQueryPlan}\n+     * @param <E> type parameter to constrain expressions to {@link RecordQueryPlan}\n+     * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of record query plans passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RecordQueryPlan> List<Physical> fromPlans(final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {\n+        return fromExpressions(rangesOverPlans, Quantifier::physical);\n+    }\n+\n+    /**\n+     * Factory method to create a list of quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverExpressions iterable of {@link ExpressionRef}s the quantifiers will be created to range over\n+     * @param creator lambda to to be called for each expression reference contained in {@code rangesOverExpression}s\n+     *        to create the actual quantifier. This allows for callers to create different kinds of quantifier based\n+     *        on needs.\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @param <Q> the type of the quantifier to be created\n+     * @return a list of quantifiers where each quantifier ranges over an expression reference contained in the iterable of\n+     *         references passed in in order of iteration.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5MTgwNQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429391805", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static <E extends RelationalExpression, Q extends Quantifier> List<Q> fromExpressions(final Iterable<? extends ExpressionRef<E>> rangesOverExpressions,\n          \n          \n            \n                                                                                                             final Function<ExpressionRef<E>, Q> creator) {\n          \n          \n            \n                public static <E extends RelationalExpression, Q extends Quantifier> List<Q> fromExpressions(@Nonnull final Iterable<? extends ExpressionRef<E>> rangesOverExpressions,\n          \n          \n            \n                                                                                                             @Nonnull final Function<ExpressionRef<E>, Q> creator) {", "author": "nschiefer", "createdAt": "2020-05-22T18:19:32Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifiers.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Auxiliary class containing factory methods and helpers fro {@link Quantifier}.\n+ */\n+public class Quantifiers {\n+    /**\n+     * Factory method to create a list of for-each quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverExpressions iterable {@link ExpressionRef}s of {@link RelationalExpression}s\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of for-each quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<ForEach> forEachQuantifiers(final Iterable<ExpressionRef<E>> rangesOverExpressions) {\n+        return fromExpressions(rangesOverExpressions, Quantifier::forEach);\n+    }\n+\n+    /**\n+     * Factory method to create a list of existential quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverPlans iterable {@link ExpressionRef}s of of {@link RelationalExpression}s.\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of relational expressions passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression> List<Existential> existentialQuantifiers(final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {\n+        return fromExpressions(rangesOverPlans, Quantifier::existential);\n+    }\n+\n+    /**\n+     * Factory method to create a list of physical quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverPlans iterable {@link ExpressionRef}s of {@link RecordQueryPlan}\n+     * @param <E> type parameter to constrain expressions to {@link RecordQueryPlan}\n+     * @return a list of physical quantifiers where each quantifier ranges over an expression reference contained in the list of\n+     *         references of record query plans passed in in order of the references in that iterable.\n+     */\n+    @Nonnull\n+    public static <E extends RecordQueryPlan> List<Physical> fromPlans(final Iterable<? extends ExpressionRef<E>> rangesOverPlans) {\n+        return fromExpressions(rangesOverPlans, Quantifier::physical);\n+    }\n+\n+    /**\n+     * Factory method to create a list of quantifiers given a list of expression references these quantifiers should range over.\n+     * @param rangesOverExpressions iterable of {@link ExpressionRef}s the quantifiers will be created to range over\n+     * @param creator lambda to to be called for each expression reference contained in {@code rangesOverExpression}s\n+     *        to create the actual quantifier. This allows for callers to create different kinds of quantifier based\n+     *        on needs.\n+     * @param <E> type parameter to constrain expressions to {@link RelationalExpression}\n+     * @param <Q> the type of the quantifier to be created\n+     * @return a list of quantifiers where each quantifier ranges over an expression reference contained in the iterable of\n+     *         references passed in in order of iteration.\n+     */\n+    @Nonnull\n+    public static <E extends RelationalExpression, Q extends Quantifier> List<Q> fromExpressions(final Iterable<? extends ExpressionRef<E>> rangesOverExpressions,\n+                                                                                                 final Function<ExpressionRef<E>, Q> creator) {", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5MzE3NQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429393175", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a matcher matching a for each quantifier together with the given matcher for expression reference\n          \n          \n            \n                 *         it ranges over.\n          \n          \n            \n                 * @return a matcher matching a for each quantifier together with the given matcher for reference it ranges over.", "author": "nschiefer", "createdAt": "2020-05-22T18:22:59Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/matchers/QuantifierMatcher.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * QuantifierMatcher.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.matchers;\n+\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * Matches a subclass of {@link com.apple.foundationdb.record.query.plan.temp.Quantifier} and a given matcher against the children.\n+ * @param <T> the type of {@link com.apple.foundationdb.record.query.plan.temp.Quantifier} to match against\n+ */\n+public class QuantifierMatcher<T extends Quantifier> extends TypeMatcher<T> {\n+    /**\n+     * Private constructor. Use static factory methods.\n+     * @param quantifierClass the class of the quantifier\n+     * @param childrenMatcher matcher for children\n+     */\n+    private QuantifierMatcher(@Nonnull final Class<? extends T> quantifierClass, @Nonnull final ExpressionChildrenMatcher childrenMatcher) {\n+        super(quantifierClass, childrenMatcher);\n+    }\n+\n+    /**\n+     * Matches a {@link com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach} quantifier together\n+     * with the given matcher for its {@code rangesOver()}.\n+     * @param rangesOverMatcher matcher for the rangesOver expression reference\n+     * @return a matcher matching a for each quantifier together with the given matcher for expression reference\n+     *         it ranges over.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5MzQwMg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429393402", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a matcher matching an existential quantifier together with the given matcher for the expression reference\n          \n          \n            \n                 *         it ranges over.\n          \n          \n            \n                 */\n          \n          \n            \n                 * @return a matcher matching an existential quantifier together with the given matcher for the reference it ranges over\n          \n          \n            \n                 */", "author": "nschiefer", "createdAt": "2020-05-22T18:23:35Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/matchers/QuantifierMatcher.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * QuantifierMatcher.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.matchers;\n+\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * Matches a subclass of {@link com.apple.foundationdb.record.query.plan.temp.Quantifier} and a given matcher against the children.\n+ * @param <T> the type of {@link com.apple.foundationdb.record.query.plan.temp.Quantifier} to match against\n+ */\n+public class QuantifierMatcher<T extends Quantifier> extends TypeMatcher<T> {\n+    /**\n+     * Private constructor. Use static factory methods.\n+     * @param quantifierClass the class of the quantifier\n+     * @param childrenMatcher matcher for children\n+     */\n+    private QuantifierMatcher(@Nonnull final Class<? extends T> quantifierClass, @Nonnull final ExpressionChildrenMatcher childrenMatcher) {\n+        super(quantifierClass, childrenMatcher);\n+    }\n+\n+    /**\n+     * Matches a {@link com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach} quantifier together\n+     * with the given matcher for its {@code rangesOver()}.\n+     * @param rangesOverMatcher matcher for the rangesOver expression reference\n+     * @return a matcher matching a for each quantifier together with the given matcher for expression reference\n+     *         it ranges over.\n+     */\n+    @Nonnull\n+    public static QuantifierMatcher<Quantifier.ForEach> forEach(@Nonnull ExpressionMatcher<? extends Bindable> rangesOverMatcher) {\n+        return ofKind(Quantifier.ForEach.class, rangesOverMatcher);\n+    }\n+\n+    /**\n+     * Matches a {@link com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential} quantifier together\n+     * with the given matcher for its {@code rangesOver()}.\n+     * @param rangesOverMatcher matcher for the rangesOver expression reference\n+     * @return a matcher matching an existential quantifier together with the given matcher for the expression reference\n+     *         it ranges over.\n+     */", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5MzU0Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429393542", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a matcher matching a physical quantifier together with the given matcher for the expression reference\n          \n          \n            \n                 *         it ranges over.\n          \n          \n            \n                 * @return a matcher matching a physical quantifier together with the given matcher for the reference it ranges over", "author": "nschiefer", "createdAt": "2020-05-22T18:23:57Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/matchers/QuantifierMatcher.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * QuantifierMatcher.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.matchers;\n+\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * Matches a subclass of {@link com.apple.foundationdb.record.query.plan.temp.Quantifier} and a given matcher against the children.\n+ * @param <T> the type of {@link com.apple.foundationdb.record.query.plan.temp.Quantifier} to match against\n+ */\n+public class QuantifierMatcher<T extends Quantifier> extends TypeMatcher<T> {\n+    /**\n+     * Private constructor. Use static factory methods.\n+     * @param quantifierClass the class of the quantifier\n+     * @param childrenMatcher matcher for children\n+     */\n+    private QuantifierMatcher(@Nonnull final Class<? extends T> quantifierClass, @Nonnull final ExpressionChildrenMatcher childrenMatcher) {\n+        super(quantifierClass, childrenMatcher);\n+    }\n+\n+    /**\n+     * Matches a {@link com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach} quantifier together\n+     * with the given matcher for its {@code rangesOver()}.\n+     * @param rangesOverMatcher matcher for the rangesOver expression reference\n+     * @return a matcher matching a for each quantifier together with the given matcher for expression reference\n+     *         it ranges over.\n+     */\n+    @Nonnull\n+    public static QuantifierMatcher<Quantifier.ForEach> forEach(@Nonnull ExpressionMatcher<? extends Bindable> rangesOverMatcher) {\n+        return ofKind(Quantifier.ForEach.class, rangesOverMatcher);\n+    }\n+\n+    /**\n+     * Matches a {@link com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential} quantifier together\n+     * with the given matcher for its {@code rangesOver()}.\n+     * @param rangesOverMatcher matcher for the rangesOver expression reference\n+     * @return a matcher matching an existential quantifier together with the given matcher for the expression reference\n+     *         it ranges over.\n+     */\n+    @Nonnull\n+    public static QuantifierMatcher<Quantifier.Existential> existential(@Nonnull ExpressionMatcher<? extends Bindable> rangesOverMatcher) {\n+        return ofKind(Quantifier.Existential.class, rangesOverMatcher);\n+    }\n+\n+    /**\n+     * Matches a {@link com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical} quantifier together\n+     * with the given matcher for its {@code rangesOver()}.\n+     * @param rangesOverMatcher matcher for the rangesOver expression reference\n+     * @return a matcher matching a physical quantifier together with the given matcher for the expression reference\n+     *         it ranges over.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5Mzc4MA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429393780", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a matcher matching a for each quantifier together with the given matcher for the expression reference\n          \n          \n            \n                 *         it ranges over.\n          \n          \n            \n                 * @return a matcher matching a for each quantifier together with the given matcher for the reference it ranges over", "author": "nschiefer", "createdAt": "2020-05-22T18:24:32Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/matchers/QuantifierMatcher.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * QuantifierMatcher.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp.matchers;\n+\n+import com.apple.foundationdb.record.query.plan.temp.Bindable;\n+import com.apple.foundationdb.record.query.plan.temp.Quantifier;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * Matches a subclass of {@link com.apple.foundationdb.record.query.plan.temp.Quantifier} and a given matcher against the children.\n+ * @param <T> the type of {@link com.apple.foundationdb.record.query.plan.temp.Quantifier} to match against\n+ */\n+public class QuantifierMatcher<T extends Quantifier> extends TypeMatcher<T> {\n+    /**\n+     * Private constructor. Use static factory methods.\n+     * @param quantifierClass the class of the quantifier\n+     * @param childrenMatcher matcher for children\n+     */\n+    private QuantifierMatcher(@Nonnull final Class<? extends T> quantifierClass, @Nonnull final ExpressionChildrenMatcher childrenMatcher) {\n+        super(quantifierClass, childrenMatcher);\n+    }\n+\n+    /**\n+     * Matches a {@link com.apple.foundationdb.record.query.plan.temp.Quantifier.ForEach} quantifier together\n+     * with the given matcher for its {@code rangesOver()}.\n+     * @param rangesOverMatcher matcher for the rangesOver expression reference\n+     * @return a matcher matching a for each quantifier together with the given matcher for expression reference\n+     *         it ranges over.\n+     */\n+    @Nonnull\n+    public static QuantifierMatcher<Quantifier.ForEach> forEach(@Nonnull ExpressionMatcher<? extends Bindable> rangesOverMatcher) {\n+        return ofKind(Quantifier.ForEach.class, rangesOverMatcher);\n+    }\n+\n+    /**\n+     * Matches a {@link com.apple.foundationdb.record.query.plan.temp.Quantifier.Existential} quantifier together\n+     * with the given matcher for its {@code rangesOver()}.\n+     * @param rangesOverMatcher matcher for the rangesOver expression reference\n+     * @return a matcher matching an existential quantifier together with the given matcher for the expression reference\n+     *         it ranges over.\n+     */\n+    @Nonnull\n+    public static QuantifierMatcher<Quantifier.Existential> existential(@Nonnull ExpressionMatcher<? extends Bindable> rangesOverMatcher) {\n+        return ofKind(Quantifier.Existential.class, rangesOverMatcher);\n+    }\n+\n+    /**\n+     * Matches a {@link com.apple.foundationdb.record.query.plan.temp.Quantifier.Physical} quantifier together\n+     * with the given matcher for its {@code rangesOver()}.\n+     * @param rangesOverMatcher matcher for the rangesOver expression reference\n+     * @return a matcher matching a physical quantifier together with the given matcher for the expression reference\n+     *         it ranges over.\n+     */\n+    @Nonnull\n+    public static QuantifierMatcher<Quantifier.Physical> physical(@Nonnull ExpressionMatcher<? extends Bindable> rangesOverMatcher) {\n+        return ofKind(Quantifier.Physical.class, rangesOverMatcher);\n+    }\n+\n+    /**\n+     * Matches a subclass of {@link com.apple.foundationdb.record.query.plan.temp.Quantifier} together\n+     * with the given matcher for its {@code rangesOver()}.\n+     * @param quantifierClass class specific flavor of quantifier to match\n+     * @param rangesOverMatcher matcher for the rangesOver expression reference\n+     * @param <Q> class of specific flavor of quantifier to match\n+     * @return a matcher matching a for each quantifier together with the given matcher for the expression reference\n+     *         it ranges over.", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5NDU1Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429394553", "bodyText": "Given how many of these there are, perhaps we should adjust the PlannerProperty interface to have a version of this method where rangesOverResult is necessarily non-null? I'm happy to do that in a follow-up PR.", "author": "nschiefer", "createdAt": "2020-05-22T18:26:32Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/properties/RelationalExpressionDepthProperty.java", "diffHunk": "@@ -90,4 +99,11 @@ public int evaluate(@Nonnull RelationalExpression expression) {\n         return expression.acceptPropertyVisitor(this);\n     }\n \n+    @Nonnull\n+    @Override\n+    @SpotBugsSuppressWarnings(\"NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE\")\n+    public Integer evaluateAtQuantifier(@Nonnull final Quantifier quantifier, @Nullable final Integer rangesOverResult) {\n+        // since we do visit expression references in this property we can insist on rangesOverResult not being null", "originalCommit": "96bdeaa04428264c23b0c3b3154f2e64483ba012", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzU2NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r429473564", "bodyText": "So this one is interesting, I had it like that, the problem is the following:\nevaluateAtQuantifier can be called on null but must return non null. This cannot be done in the generic sense other than bombing by means of e.g. requireNonNull(). Yes, you could put that into the default implementation, however, that would cause this method to immediately throw an exception if shouldVisit is false for expression refs. That seems to behave weird. So I left it up to the implementor to deal with this. As all of them return for that shouldVisit(expressionRef) false they can in fact assume there is an internal problem if the method gets called on null.\nWhat we could do instead is to default all shouldVisit() in the interface and set them to true. We then could point out that the default implementation would always visit everything and that if you want to override, then you must deal with the fallout of having an evaluate... to be called with nulls.", "author": "normen662", "createdAt": "2020-05-22T22:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5NDU1Mw=="}], "type": "inlineReview"}, {"oid": "07e511ed61a60a9ef8e8291c26e6d2ed4a2d7751", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/07e511ed61a60a9ef8e8291c26e6d2ed4a2d7751", "message": "Resolves #950: introduce the concept of a quantifier to the data flow representation used by the cascades planner", "committedDate": "2020-05-26T16:32:24Z", "type": "commit"}, {"oid": "53a167fc59ea384abe8a51875a4ee907bdad36e4", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/53a167fc59ea384abe8a51875a4ee907bdad36e4", "message": "Update fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java\n\nCo-authored-by: Nicholas Schiefer <nicholasschiefer@gmail.com>", "committedDate": "2020-05-26T16:32:24Z", "type": "commit"}, {"oid": "5642280fe308c54c7499d35b084b537953d837ef", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/5642280fe308c54c7499d35b084b537953d837ef", "message": "Apply comment suggestions from code review\n\nCo-authored-by: Nicholas Schiefer <nicholasschiefer@gmail.com>\nCo-authored-by: Scott Dugas <scott.dugas@gmail.com>", "committedDate": "2020-05-26T16:32:24Z", "type": "commit"}, {"oid": "626a9b0098714090251921f2ab5d0645cdfc6294", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/626a9b0098714090251921f2ab5d0645cdfc6294", "message": "Resolves #950: address remaining non-trivial review comments", "committedDate": "2020-05-26T16:33:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxNjc1OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430616759", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * assumed to are non-nullable even though parameters are annotated as {@link Nullable}. On the other hand, if the\n          \n          \n            \n             * assumed to be non-nullable even though parameters are annotated as {@link Nullable}. On the other hand, if the", "author": "ScottDugas", "createdAt": "2020-05-26T18:22:15Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/PlannerProperty.java", "diffHunk": "@@ -36,44 +39,82 @@\n  *\n  * <p>\n  * To avoid littering {@link RelationalExpression} classes with methods for various properties, properties are implemented\n- * using a variant of the hierarchical visitor pattern the tree of {@code PlannerExpression}s and {@link ExpressionRef}s.\n- * A property can be evaluated against an expression tree by having the visitor traverse the tree. Note that the\n- * \"{@code visitLeave()}\" methods {@link #evaluateAtExpression} and {@link #evaluateAtRef} are handed the results of the\n- * visitor evaluated at their children and members respectively. Since most properties are easy to describe as a\n- * recursion with depth one, this makes properties easier to read and write.\n+ * using a variant of the hierarchical visitor pattern over a DAG of {@link RelationalExpression}s, {@link Quantifier}s,\n+ * and {@link ExpressionRef}s.\n+ * A property can be evaluated against an expression tree by having the visitor traverse a DAG of heterogeneous objects\n+ * where expressions are said to own quantifiers which range over expression references which then contain expressions\n+ * again. Shared sub graphs are visited multiple times. If desired, the caller must ensure that a sub-graph is not\n+ * visited more than once.\n+ * </p>\n+ *\n+ * <p>\n+ * Note that the methods {@link #evaluateAtExpression}, {@link #evaluateAtQuantifier}, and {@link #evaluateAtRef} are handed the\n+ * results of the visitor evaluated at their owned quantifiers, references, and members respectively. Since most properties\n+ * are easy to describe as a recursion with depth one, this makes properties easier to read and write.\n+ * </p>\n+ *\n+ * <p>\n+ * Note that the default implementations provided in this interface walk the entire DAG, i.e. all {@link #shouldVisit}\n+ * methods return {@code true}. That implies that properties have been computed for sub-structures of the graph when\n+ * {@code evaluateAtXXX()} is called and therefore are not {@code null}. That means that all such arguments can be\n+ * assumed to are non-nullable even though parameters are annotated as {@link Nullable}. On the other hand, if the", "originalCommit": "626a9b0098714090251921f2ab5d0645cdfc6294", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYzOTUzMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430639530", "bodyText": "done", "author": "normen662", "createdAt": "2020-05-26T19:01:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxNjc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxOTIzNg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430619236", "bodyText": "I'm guessing this was an accidental change due to suggested edits\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ``", "author": "ScottDugas", "createdAt": "2020-05-26T18:26:29Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Quantifier.java\n+ *\n+ * This source file is part of the FoundationDB open source project\n+ *\n+ * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.apple.foundationdb.record.query.plan.temp;\n+\n+import com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher;\n+import com.apple.foundationdb.record.query.plan.temp.matchers.PlannerBindings;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Models the concept of quantification.\n+ * \n+ * <p>\n+ * A quantifier describes the data flow between the output of one {@link RelationalExpression} {@code R} and the\n+ * consumption of that data by another {@code RelationalExpression} {@code S}. {@code S} is said to own the quantifier,\n+ * while the quantifier is said to range over {@code R}. Quantifiers come in very few but very distinct flavors.\n+ * All flavors are implemented by static inner final classes in order to emulate a sealed trait.\n+ * </p>\n+ *\n+ * <p>\n+ * Quantifiers separate what it means to be producing versus consuming items. The expression a quantifier ranges over\n+ * produces records, the quantifier flows information (in a manner determined by the flavor) that is consumed by the expression\n+ * containing or owning the quantifier. That expression can consume the data in a way independent of how the data was\n+ * produced in the first place.\n+ * </p>\n+ *\n+ * <p>\n+ * A quantifier works closely with the expression that owns it. Depending on the semantics of the owning expression\n+ * it becomes possible to model correlations. For example, in a logical join expression the quantifier can provide a binding\n+ * of the item being currently consumed by the join's outer to other (inner) parts of the data flow that are also rooted\n+ * at the owning (join) expression.\n+ * </p>\n+ */\n+public abstract class Quantifier implements Bindable {\n+    /**\n+     * A quantifier that conceptually flows one item at a time from the expression it ranges over to\n+     * the owning expression.\n+     */\n+    public static final class ForEach extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private ForEach(ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u0192\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a for-each quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static ForEach forEach(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new ForEach(rangesOver);\n+    }\n+\n+    /**\n+     * A quantifier that conceptually flows exactly one item containing a boolean to the owning\n+     * expression indicating whether the sub-graph that the quantifier ranges over produced a non-empty or an empty\n+     * result. When the semantics of this quantifiers are realized in an execution strategy that strategy should\n+     * facilitate a boolean \"short-circuit\" mechanism as the result will be {@code true} as soon as the sub-graph produces\n+     * the first item.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and hashCode() should be overwritten which is not necessary\n+    public static final class Existential extends Quantifier {\n+        private final ExpressionRef<? extends RelationalExpression> rangesOver;\n+\n+        private Existential(final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RelationalExpression> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\u2203\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create an existential quantifier over a given expression reference containing relational\n+     * expressions.\n+     * @param rangesOver expression reference to {@link RelationalExpression}s\n+     * @return a for-each quantifier ranging over the given expression reference\n+     */\n+    @Nonnull\n+    public static Existential existential(@Nonnull final ExpressionRef<? extends RelationalExpression> rangesOver) {\n+        return new Existential(rangesOver);\n+    }\n+\n+    /**\n+     * Physical quantifier. This kind of quantifier is the conduit between two {@link RecordQueryPlan}s. It does\n+     * not have any associated semantics; all semantics and execution details must be subsumed\n+     * by the query plans themselves.\n+     */\n+    @SuppressWarnings(\"squid:S2160\") // sonarqube thinks .equals() and hashCode() should be overwritten which is not necessary\n+    public static final class Physical extends Quantifier {\n+        private final ExpressionRef<? extends RecordQueryPlan> rangesOver;\n+\n+        private Physical(@Nonnull final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+            this.rangesOver = rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public ExpressionRef<? extends RecordQueryPlan> getRangesOver() {\n+            return rangesOver;\n+        }\n+\n+        @Override\n+        @Nonnull\n+        public String getShorthand() {\n+            return \"\ud835\udcc5\";\n+        }\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over a given expression reference containing query plans.\n+     * @param rangesOver expression reference to {@link RecordQueryPlan}s\n+     * @return a physical quantifier ranging over the given reference\n+     */\n+    @Nonnull\n+    public static Physical physical(@Nonnull final ExpressionRef<? extends RecordQueryPlan> rangesOver) {\n+        return new Physical(rangesOver);\n+    }\n+\n+    /**\n+     * Factory method to create a physical quantifier over newly created expression reference containing the given\n+     * record plan.\n+     * @param rangesOverPlan {@link RecordQueryPlan} the new quantifier should range over.\n+     * @return a physical quantifier ranging over a new expression reference containing the given expression reference\n+     */\n+    @Nonnull\n+    public static Physical physical(@Nonnull final RecordQueryPlan rangesOverPlan) {\n+        return new Physical(GroupExpressionRef.of(rangesOverPlan));\n+    }\n+\n+    /**\n+     * Return the reference that the quantifier ranges over.\n+     * @return {@link ExpressionRef} this quantifier ranges over\n+     */\n+    @Nonnull\n+    public abstract ExpressionRef<? extends RelationalExpression> getRangesOver();\n+\n+    /**\n+     * Return a short hand string for the quantifier. As a quantifier's semantics is usually quite subtle and should\n+     * not distract from expressions. For example, when a data flow is visualized the returned string should be <em>short</em>.\n+``", "originalCommit": "626a9b0098714090251921f2ab5d0645cdfc6294", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYzOTE4NA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430639184", "bodyText": "done.", "author": "normen662", "createdAt": "2020-05-26T19:00:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxOTIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyMzg4Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430623883", "bodyText": "Should this return the indexPlan?", "author": "ScottDugas", "createdAt": "2020-05-26T18:34:20Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/plans/RecordQueryCoveringIndexPlan.java", "diffHunk": "@@ -190,7 +190,7 @@ public int planHash() {\n     @Nonnull\n     @Override\n     @API(API.Status.EXPERIMENTAL)\n-    public Iterator<? extends ExpressionRef<? extends RelationalExpression>> getPlannerExpressionChildren() {\n-        return Iterators.singletonIterator(indexPlan);\n+    public List<? extends Quantifier> getQuantifiers() {", "originalCommit": "626a9b0098714090251921f2ab5d0645cdfc6294", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyODcxMA==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430628710", "bodyText": "No, it shouldn't. We decided that RecordQueryCoveringIndexPlan is basically a \"wrapper\" around a RecordQueryIndexPlan that happens to use composition rather than inheritance. The child isn't really a child in the relational expression sense.", "author": "nschiefer", "createdAt": "2020-05-26T18:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyMzg4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1OTk3OQ==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430759979", "bodyText": "done", "author": "normen662", "createdAt": "2020-05-26T23:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyMzg4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyOTk5Mg==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430629992", "bodyText": "For a quantifier to be equal, doesn't the flavor also need to match? Is that used anywhere?", "author": "nschiefer", "createdAt": "2020-05-26T18:45:02Z", "path": "fdb-record-layer-core/src/main/java/com/apple/foundationdb/record/query/plan/temp/Quantifier.java", "diffHunk": "@@ -211,11 +219,11 @@ public boolean equals(final Object o) {\n         if (this == o) {\n             return true;\n         }\n-        if (!(o instanceof ForEach)) {\n+        if (!(o instanceof Quantifier)) {\n             return false;\n         }\n-        final ForEach forEach = (ForEach)o;\n-        return Objects.equals(getRangesOver(), forEach.getRangesOver());\n+        final Quantifier quantifier = (Quantifier)o;\n+        return Objects.equals(getRangesOver(), quantifier.getRangesOver());", "originalCommit": "626a9b0098714090251921f2ab5d0645cdfc6294", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY1MDc4Mw==", "url": "https://github.com/FoundationDB/fdb-record-layer/pull/951#discussion_r430650783", "bodyText": "it does -- fixing", "author": "normen662", "createdAt": "2020-05-26T19:22:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyOTk5Mg=="}], "type": "inlineReview"}, {"oid": "24dcb255142e649fcb6a7f81e5762ec311a23f3f", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/24dcb255142e649fcb6a7f81e5762ec311a23f3f", "message": "Resolves #950: address remaining non-trivial review comments", "committedDate": "2020-05-26T19:21:08Z", "type": "commit"}, {"oid": "24dcb255142e649fcb6a7f81e5762ec311a23f3f", "url": "https://github.com/FoundationDB/fdb-record-layer/commit/24dcb255142e649fcb6a7f81e5762ec311a23f3f", "message": "Resolves #950: address remaining non-trivial review comments", "committedDate": "2020-05-26T19:21:08Z", "type": "forcePushed"}]}